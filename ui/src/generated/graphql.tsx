import * as luxon from 'luxon';
import { useAsyncQuery } from '../hooks/useAsyncQuery';
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  _uuid: any;
  bigint: any;
  bytea: any;
  date: luxon.DateTime;
  daterange: any;
  float8: number;
  geography: GeoJSON.Geometry;
  geography_linestring: GeoJSON.LineString;
  geography_point: GeoJSON.Point;
  geometry: GeoJSON.Geometry;
  interval: luxon.Duration;
  jsonb: any;
  localized_string: LocalizedString;
  name: any;
  numeric: any;
  smallint: number;
  /** Built-in java.math.BigDecimal */
  stop_registry_BigDecimal: any;
  /** Built-in java.math.BigInteger */
  stop_registry_BigInteger: any;
  stop_registry_Coordinates: any;
  /** Date time using the format: yyyy-MM-dd'T'HH:mm:ss.SSSXXXX. Example: 2017-04-23T18:25:43.511+0100 */
  stop_registry_DateTime: any;
  timestamp: any;
  timestamptz: luxon.DateTime;
  uuid: UUID;
};

/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
export type BooleanComparisonExp = {
  _eq?: InputMaybe<Scalars['Boolean']>;
  _gt?: InputMaybe<Scalars['Boolean']>;
  _gte?: InputMaybe<Scalars['Boolean']>;
  _in?: InputMaybe<Array<Scalars['Boolean']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['Boolean']>;
  _lte?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Scalars['Boolean']>;
  _nin?: InputMaybe<Array<Scalars['Boolean']>>;
};

export type CombineTimetablesInput = {
  stagingVehicleScheduleFrameIds: Array<InputMaybe<Scalars['uuid']>>;
  targetPriority: Scalars['Int'];
};

export type CombineTimetablesOutput = {
  __typename?: 'CombineTimetablesOutput';
  combinedIntoVehicleScheduleFrameIds: Array<Maybe<Scalars['uuid']>>;
};

/** Boolean expression to compare columns of type "Float". All fields are combined with logical 'AND'. */
export type FloatComparisonExp = {
  _eq?: InputMaybe<Scalars['Float']>;
  _gt?: InputMaybe<Scalars['Float']>;
  _gte?: InputMaybe<Scalars['Float']>;
  _in?: InputMaybe<Array<Scalars['Float']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['Float']>;
  _lte?: InputMaybe<Scalars['Float']>;
  _neq?: InputMaybe<Scalars['Float']>;
  _nin?: InputMaybe<Array<Scalars['Float']>>;
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type IntComparisonExp = {
  _eq?: InputMaybe<Scalars['Int']>;
  _gt?: InputMaybe<Scalars['Int']>;
  _gte?: InputMaybe<Scalars['Int']>;
  _in?: InputMaybe<Array<Scalars['Int']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['Int']>;
  _lte?: InputMaybe<Scalars['Int']>;
  _neq?: InputMaybe<Scalars['Int']>;
  _nin?: InputMaybe<Array<Scalars['Int']>>;
};

export type ReplaceTimetablesInput = {
  stagingVehicleScheduleFrameIds: Array<InputMaybe<Scalars['uuid']>>;
  targetPriority: Scalars['Int'];
};

export type ReplaceTimetablesOutput = {
  __typename?: 'ReplaceTimetablesOutput';
  replacedVehicleScheduleFrameIds: Array<Maybe<Scalars['uuid']>>;
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type StringComparisonExp = {
  _eq?: InputMaybe<Scalars['String']>;
  _gt?: InputMaybe<Scalars['String']>;
  _gte?: InputMaybe<Scalars['String']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: InputMaybe<Scalars['String']>;
  _in?: InputMaybe<Array<Scalars['String']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: InputMaybe<Scalars['String']>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  /** does the column match the given pattern */
  _like?: InputMaybe<Scalars['String']>;
  _lt?: InputMaybe<Scalars['String']>;
  _lte?: InputMaybe<Scalars['String']>;
  _neq?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: InputMaybe<Scalars['String']>;
  _nin?: InputMaybe<Array<Scalars['String']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given pattern */
  _nlike?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: InputMaybe<Scalars['String']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: InputMaybe<Scalars['String']>;
  /** does the column match the given SQL regular expression */
  _similar?: InputMaybe<Scalars['String']>;
};

export type ToCombineTargetVehicleScheduleFrameIdInput = {
  stagingVehicleScheduleFrameId: Scalars['uuid'];
  targetPriority: Scalars['Int'];
};

export type ToCombineTargetVehicleScheduleFrameIdOutput = {
  __typename?: 'ToCombineTargetVehicleScheduleFrameIdOutput';
  toCombineTargetVehicleScheduleFrameId: Scalars['uuid'];
};

export type ToReplaceVehicleScheduleFrameIdsInput = {
  stagingVehicleScheduleFrameId: Scalars['uuid'];
  targetPriority: Scalars['Int'];
};

export type ToReplaceVehicleScheduleFrameIdsOutput = {
  __typename?: 'ToReplaceVehicleScheduleFrameIdsOutput';
  toReplaceVehicleScheduleFrameIds: Array<Maybe<Scalars['uuid']>>;
};

export type AccessSpaceAlternativeNamesAggregateBoolExp = {
  count?: InputMaybe<AccessSpaceAlternativeNamesAggregateBoolExpCount>;
};

export type AccessSpaceAlternativeNamesAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<StopsDatabaseAccessSpaceAlternativeNamesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>;
  predicate: IntComparisonExp;
};

export type AccessSpaceEquipmentPlacesAggregateBoolExp = {
  count?: InputMaybe<AccessSpaceEquipmentPlacesAggregateBoolExpCount>;
};

export type AccessSpaceEquipmentPlacesAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<StopsDatabaseAccessSpaceEquipmentPlacesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>;
  predicate: IntComparisonExp;
};

export type AccessSpaceKeyValuesAggregateBoolExp = {
  count?: InputMaybe<AccessSpaceKeyValuesAggregateBoolExpCount>;
};

export type AccessSpaceKeyValuesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<StopsDatabaseAccessSpaceKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesBoolExp>;
  predicate: IntComparisonExp;
};

export type AccessibilityAssessmentLimitationsAggregateBoolExp = {
  count?: InputMaybe<AccessibilityAssessmentLimitationsAggregateBoolExpCount>;
};

export type AccessibilityAssessmentLimitationsAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<StopsDatabaseAccessibilityAssessmentLimitationsSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>;
  predicate: IntComparisonExp;
};

/** Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'. */
export type BigintComparisonExp = {
  _eq?: InputMaybe<Scalars['bigint']>;
  _gt?: InputMaybe<Scalars['bigint']>;
  _gte?: InputMaybe<Scalars['bigint']>;
  _in?: InputMaybe<Array<Scalars['bigint']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['bigint']>;
  _lte?: InputMaybe<Scalars['bigint']>;
  _neq?: InputMaybe<Scalars['bigint']>;
  _nin?: InputMaybe<Array<Scalars['bigint']>>;
};

export type BoardingPositionAlternativeNamesAggregateBoolExp = {
  count?: InputMaybe<BoardingPositionAlternativeNamesAggregateBoolExpCount>;
};

export type BoardingPositionAlternativeNamesAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<StopsDatabaseBoardingPositionAlternativeNamesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>;
  predicate: IntComparisonExp;
};

export type BoardingPositionEquipmentPlacesAggregateBoolExp = {
  count?: InputMaybe<BoardingPositionEquipmentPlacesAggregateBoolExpCount>;
};

export type BoardingPositionEquipmentPlacesAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<StopsDatabaseBoardingPositionEquipmentPlacesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>;
  predicate: IntComparisonExp;
};

export type BoardingPositionKeyValuesAggregateBoolExp = {
  count?: InputMaybe<BoardingPositionKeyValuesAggregateBoolExpCount>;
};

export type BoardingPositionKeyValuesAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<StopsDatabaseBoardingPositionKeyValuesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesBoolExp>;
  predicate: IntComparisonExp;
};

/** Boolean expression to compare columns of type "bytea". All fields are combined with logical 'AND'. */
export type ByteaComparisonExp = {
  _eq?: InputMaybe<Scalars['bytea']>;
  _gt?: InputMaybe<Scalars['bytea']>;
  _gte?: InputMaybe<Scalars['bytea']>;
  _in?: InputMaybe<Array<Scalars['bytea']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['bytea']>;
  _lte?: InputMaybe<Scalars['bytea']>;
  _neq?: InputMaybe<Scalars['bytea']>;
  _nin?: InputMaybe<Array<Scalars['bytea']>>;
};

/** ordering argument of a cursor */
export enum CursorOrdering {
  /** ascending ordering of the cursor */
  Asc = 'ASC',
  /** descending ordering of the cursor */
  Desc = 'DESC',
}

/** Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'. */
export type DateComparisonExp = {
  _eq?: InputMaybe<Scalars['date']>;
  _gt?: InputMaybe<Scalars['date']>;
  _gte?: InputMaybe<Scalars['date']>;
  _in?: InputMaybe<Array<Scalars['date']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['date']>;
  _lte?: InputMaybe<Scalars['date']>;
  _neq?: InputMaybe<Scalars['date']>;
  _nin?: InputMaybe<Array<Scalars['date']>>;
};

/** Boolean expression to compare columns of type "daterange". All fields are combined with logical 'AND'. */
export type DaterangeComparisonExp = {
  _eq?: InputMaybe<Scalars['daterange']>;
  _gt?: InputMaybe<Scalars['daterange']>;
  _gte?: InputMaybe<Scalars['daterange']>;
  _in?: InputMaybe<Array<Scalars['daterange']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['daterange']>;
  _lte?: InputMaybe<Scalars['daterange']>;
  _neq?: InputMaybe<Scalars['daterange']>;
  _nin?: InputMaybe<Array<Scalars['daterange']>>;
};

export type EquipmentPlaceEquipmentPositionsAggregateBoolExp = {
  count?: InputMaybe<EquipmentPlaceEquipmentPositionsAggregateBoolExpCount>;
};

export type EquipmentPlaceEquipmentPositionsAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<StopsDatabaseEquipmentPlaceEquipmentPositionsSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>;
  predicate: IntComparisonExp;
};

export type EquipmentPlaceKeyValuesAggregateBoolExp = {
  count?: InputMaybe<EquipmentPlaceKeyValuesAggregateBoolExpCount>;
};

export type EquipmentPlaceKeyValuesAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<StopsDatabaseEquipmentPlaceKeyValuesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>;
  predicate: IntComparisonExp;
};

export type EquipmentPositionKeyValuesAggregateBoolExp = {
  count?: InputMaybe<EquipmentPositionKeyValuesAggregateBoolExpCount>;
};

export type EquipmentPositionKeyValuesAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<StopsDatabaseEquipmentPositionKeyValuesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesBoolExp>;
  predicate: IntComparisonExp;
};

export type FareZoneKeyValuesAggregateBoolExp = {
  count?: InputMaybe<FareZoneKeyValuesAggregateBoolExpCount>;
};

export type FareZoneKeyValuesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<StopsDatabaseFareZoneKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseFareZoneKeyValuesBoolExp>;
  predicate: IntComparisonExp;
};

export type FareZoneMembersAggregateBoolExp = {
  count?: InputMaybe<FareZoneMembersAggregateBoolExpCount>;
};

export type FareZoneMembersAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<StopsDatabaseFareZoneMembersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseFareZoneMembersBoolExp>;
  predicate: IntComparisonExp;
};

export type FareZoneNeighboursAggregateBoolExp = {
  count?: InputMaybe<FareZoneNeighboursAggregateBoolExpCount>;
};

export type FareZoneNeighboursAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<StopsDatabaseFareZoneNeighboursSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseFareZoneNeighboursBoolExp>;
  predicate: IntComparisonExp;
};

/** Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'. */
export type Float8ComparisonExp = {
  _eq?: InputMaybe<Scalars['float8']>;
  _gt?: InputMaybe<Scalars['float8']>;
  _gte?: InputMaybe<Scalars['float8']>;
  _in?: InputMaybe<Array<Scalars['float8']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['float8']>;
  _lte?: InputMaybe<Scalars['float8']>;
  _neq?: InputMaybe<Scalars['float8']>;
  _nin?: InputMaybe<Array<Scalars['float8']>>;
};

export type GeographyCastExp = {
  geometry?: InputMaybe<GeometryComparisonExp>;
};

/** Boolean expression to compare columns of type "geography". All fields are combined with logical 'AND'. */
export type GeographyComparisonExp = {
  _cast?: InputMaybe<GeographyCastExp>;
  _eq?: InputMaybe<Scalars['geography']>;
  _gt?: InputMaybe<Scalars['geography']>;
  _gte?: InputMaybe<Scalars['geography']>;
  _in?: InputMaybe<Array<Scalars['geography']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['geography']>;
  _lte?: InputMaybe<Scalars['geography']>;
  _neq?: InputMaybe<Scalars['geography']>;
  _nin?: InputMaybe<Array<Scalars['geography']>>;
  /** is the column within a given distance from the given geography value */
  _st_d_within?: InputMaybe<StDWithinGeographyInput>;
  /** does the column spatially intersect the given geography value */
  _st_intersects?: InputMaybe<Scalars['geography']>;
};

export type GeometryCastExp = {
  geography?: InputMaybe<GeographyComparisonExp>;
};

/** Boolean expression to compare columns of type "geometry". All fields are combined with logical 'AND'. */
export type GeometryComparisonExp = {
  _cast?: InputMaybe<GeometryCastExp>;
  _eq?: InputMaybe<Scalars['geometry']>;
  _gt?: InputMaybe<Scalars['geometry']>;
  _gte?: InputMaybe<Scalars['geometry']>;
  _in?: InputMaybe<Array<Scalars['geometry']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['geometry']>;
  _lte?: InputMaybe<Scalars['geometry']>;
  _neq?: InputMaybe<Scalars['geometry']>;
  _nin?: InputMaybe<Array<Scalars['geometry']>>;
  /** is the column within a given 3D distance from the given geometry value */
  _st_3d_d_within?: InputMaybe<StDWithinInput>;
  /** does the column spatially intersect the given geometry value in 3D */
  _st_3d_intersects?: InputMaybe<Scalars['geometry']>;
  /** does the column contain the given geometry value */
  _st_contains?: InputMaybe<Scalars['geometry']>;
  /** does the column cross the given geometry value */
  _st_crosses?: InputMaybe<Scalars['geometry']>;
  /** is the column within a given distance from the given geometry value */
  _st_d_within?: InputMaybe<StDWithinInput>;
  /** is the column equal to given geometry value (directionality is ignored) */
  _st_equals?: InputMaybe<Scalars['geometry']>;
  /** does the column spatially intersect the given geometry value */
  _st_intersects?: InputMaybe<Scalars['geometry']>;
  /** does the column 'spatially overlap' (intersect but not completely contain) the given geometry value */
  _st_overlaps?: InputMaybe<Scalars['geometry']>;
  /** does the column have atleast one point in common with the given geometry value */
  _st_touches?: InputMaybe<Scalars['geometry']>;
  /** is the column contained in the given geometry value */
  _st_within?: InputMaybe<Scalars['geometry']>;
};

export type GroupOfStopPlacesAlternativeNamesAggregateBoolExp = {
  count?: InputMaybe<GroupOfStopPlacesAlternativeNamesAggregateBoolExpCount>;
};

export type GroupOfStopPlacesAlternativeNamesAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<StopsDatabaseGroupOfStopPlacesAlternativeNamesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>;
  predicate: IntComparisonExp;
};

export type GroupOfStopPlacesKeyValuesAggregateBoolExp = {
  count?: InputMaybe<GroupOfStopPlacesKeyValuesAggregateBoolExpCount>;
};

export type GroupOfStopPlacesKeyValuesAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<StopsDatabaseGroupOfStopPlacesKeyValuesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>;
  predicate: IntComparisonExp;
};

export type GroupOfStopPlacesMembersAggregateBoolExp = {
  count?: InputMaybe<GroupOfStopPlacesMembersAggregateBoolExpCount>;
};

export type GroupOfStopPlacesMembersAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<StopsDatabaseGroupOfStopPlacesMembersSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersBoolExp>;
  predicate: IntComparisonExp;
};

export type GroupOfTariffZonesKeyValuesAggregateBoolExp = {
  count?: InputMaybe<GroupOfTariffZonesKeyValuesAggregateBoolExpCount>;
};

export type GroupOfTariffZonesKeyValuesAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<StopsDatabaseGroupOfTariffZonesKeyValuesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>;
  predicate: IntComparisonExp;
};

export type GroupOfTariffZonesMembersAggregateBoolExp = {
  count?: InputMaybe<GroupOfTariffZonesMembersAggregateBoolExpCount>;
};

export type GroupOfTariffZonesMembersAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<StopsDatabaseGroupOfTariffZonesMembersSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersBoolExp>;
  predicate: IntComparisonExp;
};

/** Legacy, avoid using. Main use nowadays is to enable support for eg. data exports that still need this. Originally this was used to represent the primary region for routes/lines. */
export type HslRouteLegacyHslMunicipalityCode = {
  __typename?: 'hsl_route_legacy_hsl_municipality_code';
  hsl_municipality: Scalars['String'];
  jore3_code: Scalars['smallint'];
  /** An array relationship */
  lines: Array<RouteLine>;
  /** An aggregate relationship */
  lines_aggregate: RouteLineAggregate;
  /** An array relationship */
  routes: Array<RouteRoute>;
  /** An aggregate relationship */
  routes_aggregate: RouteRouteAggregate;
};

/** Legacy, avoid using. Main use nowadays is to enable support for eg. data exports that still need this. Originally this was used to represent the primary region for routes/lines. */
export type HslRouteLegacyHslMunicipalityCodeLinesArgs = {
  distinct_on?: InputMaybe<Array<RouteLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteLineOrderBy>>;
  where?: InputMaybe<RouteLineBoolExp>;
};

/** Legacy, avoid using. Main use nowadays is to enable support for eg. data exports that still need this. Originally this was used to represent the primary region for routes/lines. */
export type HslRouteLegacyHslMunicipalityCodeLinesAggregateArgs = {
  distinct_on?: InputMaybe<Array<RouteLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteLineOrderBy>>;
  where?: InputMaybe<RouteLineBoolExp>;
};

/** Legacy, avoid using. Main use nowadays is to enable support for eg. data exports that still need this. Originally this was used to represent the primary region for routes/lines. */
export type HslRouteLegacyHslMunicipalityCodeRoutesArgs = {
  distinct_on?: InputMaybe<Array<RouteRouteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteRouteOrderBy>>;
  where?: InputMaybe<RouteRouteBoolExp>;
};

/** Legacy, avoid using. Main use nowadays is to enable support for eg. data exports that still need this. Originally this was used to represent the primary region for routes/lines. */
export type HslRouteLegacyHslMunicipalityCodeRoutesAggregateArgs = {
  distinct_on?: InputMaybe<Array<RouteRouteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteRouteOrderBy>>;
  where?: InputMaybe<RouteRouteBoolExp>;
};

/** aggregated selection of "hsl_route.legacy_hsl_municipality_code" */
export type HslRouteLegacyHslMunicipalityCodeAggregate = {
  __typename?: 'hsl_route_legacy_hsl_municipality_code_aggregate';
  aggregate?: Maybe<HslRouteLegacyHslMunicipalityCodeAggregateFields>;
  nodes: Array<HslRouteLegacyHslMunicipalityCode>;
};

/** aggregate fields of "hsl_route.legacy_hsl_municipality_code" */
export type HslRouteLegacyHslMunicipalityCodeAggregateFields = {
  __typename?: 'hsl_route_legacy_hsl_municipality_code_aggregate_fields';
  avg?: Maybe<HslRouteLegacyHslMunicipalityCodeAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<HslRouteLegacyHslMunicipalityCodeMaxFields>;
  min?: Maybe<HslRouteLegacyHslMunicipalityCodeMinFields>;
  stddev?: Maybe<HslRouteLegacyHslMunicipalityCodeStddevFields>;
  stddev_pop?: Maybe<HslRouteLegacyHslMunicipalityCodeStddevPopFields>;
  stddev_samp?: Maybe<HslRouteLegacyHslMunicipalityCodeStddevSampFields>;
  sum?: Maybe<HslRouteLegacyHslMunicipalityCodeSumFields>;
  var_pop?: Maybe<HslRouteLegacyHslMunicipalityCodeVarPopFields>;
  var_samp?: Maybe<HslRouteLegacyHslMunicipalityCodeVarSampFields>;
  variance?: Maybe<HslRouteLegacyHslMunicipalityCodeVarianceFields>;
};

/** aggregate fields of "hsl_route.legacy_hsl_municipality_code" */
export type HslRouteLegacyHslMunicipalityCodeAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<HslRouteLegacyHslMunicipalityCodeSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type HslRouteLegacyHslMunicipalityCodeAvgFields = {
  __typename?: 'hsl_route_legacy_hsl_municipality_code_avg_fields';
  jore3_code?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "hsl_route.legacy_hsl_municipality_code". All fields are combined with a logical 'AND'. */
export type HslRouteLegacyHslMunicipalityCodeBoolExp = {
  _and?: InputMaybe<Array<HslRouteLegacyHslMunicipalityCodeBoolExp>>;
  _not?: InputMaybe<HslRouteLegacyHslMunicipalityCodeBoolExp>;
  _or?: InputMaybe<Array<HslRouteLegacyHslMunicipalityCodeBoolExp>>;
  hsl_municipality?: InputMaybe<StringComparisonExp>;
  jore3_code?: InputMaybe<SmallintComparisonExp>;
  lines?: InputMaybe<RouteLineBoolExp>;
  lines_aggregate?: InputMaybe<RouteLineAggregateBoolExp>;
  routes?: InputMaybe<RouteRouteBoolExp>;
  routes_aggregate?: InputMaybe<RouteRouteAggregateBoolExp>;
};

/** unique or primary key constraints on table "hsl_route.legacy_hsl_municipality_code" */
export enum HslRouteLegacyHslMunicipalityCodeConstraint {
  /** unique or primary key constraint on columns "hsl_municipality" */
  LegacyHslMunicipalityCodePkey = 'legacy_hsl_municipality_code_pkey',
}

/** input type for incrementing numeric columns in table "hsl_route.legacy_hsl_municipality_code" */
export type HslRouteLegacyHslMunicipalityCodeIncInput = {
  jore3_code?: InputMaybe<Scalars['smallint']>;
};

/** input type for inserting data into table "hsl_route.legacy_hsl_municipality_code" */
export type HslRouteLegacyHslMunicipalityCodeInsertInput = {
  hsl_municipality?: InputMaybe<Scalars['String']>;
  jore3_code?: InputMaybe<Scalars['smallint']>;
  lines?: InputMaybe<RouteLineArrRelInsertInput>;
  routes?: InputMaybe<RouteRouteArrRelInsertInput>;
};

/** aggregate max on columns */
export type HslRouteLegacyHslMunicipalityCodeMaxFields = {
  __typename?: 'hsl_route_legacy_hsl_municipality_code_max_fields';
  hsl_municipality?: Maybe<Scalars['String']>;
  jore3_code?: Maybe<Scalars['smallint']>;
};

/** aggregate min on columns */
export type HslRouteLegacyHslMunicipalityCodeMinFields = {
  __typename?: 'hsl_route_legacy_hsl_municipality_code_min_fields';
  hsl_municipality?: Maybe<Scalars['String']>;
  jore3_code?: Maybe<Scalars['smallint']>;
};

/** response of any mutation on the table "hsl_route.legacy_hsl_municipality_code" */
export type HslRouteLegacyHslMunicipalityCodeMutationResponse = {
  __typename?: 'hsl_route_legacy_hsl_municipality_code_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<HslRouteLegacyHslMunicipalityCode>;
};

/** input type for inserting object relation for remote table "hsl_route.legacy_hsl_municipality_code" */
export type HslRouteLegacyHslMunicipalityCodeObjRelInsertInput = {
  data: HslRouteLegacyHslMunicipalityCodeInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<HslRouteLegacyHslMunicipalityCodeOnConflict>;
};

/** on_conflict condition type for table "hsl_route.legacy_hsl_municipality_code" */
export type HslRouteLegacyHslMunicipalityCodeOnConflict = {
  constraint: HslRouteLegacyHslMunicipalityCodeConstraint;
  update_columns?: Array<HslRouteLegacyHslMunicipalityCodeUpdateColumn>;
  where?: InputMaybe<HslRouteLegacyHslMunicipalityCodeBoolExp>;
};

/** Ordering options when selecting data from "hsl_route.legacy_hsl_municipality_code". */
export type HslRouteLegacyHslMunicipalityCodeOrderBy = {
  hsl_municipality?: InputMaybe<OrderBy>;
  jore3_code?: InputMaybe<OrderBy>;
  lines_aggregate?: InputMaybe<RouteLineAggregateOrderBy>;
  routes_aggregate?: InputMaybe<RouteRouteAggregateOrderBy>;
};

/** primary key columns input for table: hsl_route.legacy_hsl_municipality_code */
export type HslRouteLegacyHslMunicipalityCodePkColumnsInput = {
  hsl_municipality: Scalars['String'];
};

/** select columns of table "hsl_route.legacy_hsl_municipality_code" */
export enum HslRouteLegacyHslMunicipalityCodeSelectColumn {
  /** column name */
  HslMunicipality = 'hsl_municipality',
  /** column name */
  Jore3Code = 'jore3_code',
}

/** input type for updating data in table "hsl_route.legacy_hsl_municipality_code" */
export type HslRouteLegacyHslMunicipalityCodeSetInput = {
  hsl_municipality?: InputMaybe<Scalars['String']>;
  jore3_code?: InputMaybe<Scalars['smallint']>;
};

/** aggregate stddev on columns */
export type HslRouteLegacyHslMunicipalityCodeStddevFields = {
  __typename?: 'hsl_route_legacy_hsl_municipality_code_stddev_fields';
  jore3_code?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type HslRouteLegacyHslMunicipalityCodeStddevPopFields = {
  __typename?: 'hsl_route_legacy_hsl_municipality_code_stddev_pop_fields';
  jore3_code?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type HslRouteLegacyHslMunicipalityCodeStddevSampFields = {
  __typename?: 'hsl_route_legacy_hsl_municipality_code_stddev_samp_fields';
  jore3_code?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "hsl_route_legacy_hsl_municipality_code" */
export type HslRouteLegacyHslMunicipalityCodeStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: HslRouteLegacyHslMunicipalityCodeStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type HslRouteLegacyHslMunicipalityCodeStreamCursorValueInput = {
  hsl_municipality?: InputMaybe<Scalars['String']>;
  jore3_code?: InputMaybe<Scalars['smallint']>;
};

/** aggregate sum on columns */
export type HslRouteLegacyHslMunicipalityCodeSumFields = {
  __typename?: 'hsl_route_legacy_hsl_municipality_code_sum_fields';
  jore3_code?: Maybe<Scalars['smallint']>;
};

/** update columns of table "hsl_route.legacy_hsl_municipality_code" */
export enum HslRouteLegacyHslMunicipalityCodeUpdateColumn {
  /** column name */
  HslMunicipality = 'hsl_municipality',
  /** column name */
  Jore3Code = 'jore3_code',
}

export type HslRouteLegacyHslMunicipalityCodeUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<HslRouteLegacyHslMunicipalityCodeIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<HslRouteLegacyHslMunicipalityCodeSetInput>;
  /** filter the rows which have to be updated */
  where: HslRouteLegacyHslMunicipalityCodeBoolExp;
};

/** aggregate var_pop on columns */
export type HslRouteLegacyHslMunicipalityCodeVarPopFields = {
  __typename?: 'hsl_route_legacy_hsl_municipality_code_var_pop_fields';
  jore3_code?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type HslRouteLegacyHslMunicipalityCodeVarSampFields = {
  __typename?: 'hsl_route_legacy_hsl_municipality_code_var_samp_fields';
  jore3_code?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type HslRouteLegacyHslMunicipalityCodeVarianceFields = {
  __typename?: 'hsl_route_legacy_hsl_municipality_code_variance_fields';
  jore3_code?: Maybe<Scalars['Float']>;
};

/** Transport target, can be used e.g. for cost sharing. */
export type HslRouteTransportTarget = {
  __typename?: 'hsl_route_transport_target';
  /** An array relationship */
  lines: Array<RouteLine>;
  /** An aggregate relationship */
  lines_aggregate: RouteLineAggregate;
  transport_target: Scalars['String'];
};

/** Transport target, can be used e.g. for cost sharing. */
export type HslRouteTransportTargetLinesArgs = {
  distinct_on?: InputMaybe<Array<RouteLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteLineOrderBy>>;
  where?: InputMaybe<RouteLineBoolExp>;
};

/** Transport target, can be used e.g. for cost sharing. */
export type HslRouteTransportTargetLinesAggregateArgs = {
  distinct_on?: InputMaybe<Array<RouteLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteLineOrderBy>>;
  where?: InputMaybe<RouteLineBoolExp>;
};

/** aggregated selection of "hsl_route.transport_target" */
export type HslRouteTransportTargetAggregate = {
  __typename?: 'hsl_route_transport_target_aggregate';
  aggregate?: Maybe<HslRouteTransportTargetAggregateFields>;
  nodes: Array<HslRouteTransportTarget>;
};

/** aggregate fields of "hsl_route.transport_target" */
export type HslRouteTransportTargetAggregateFields = {
  __typename?: 'hsl_route_transport_target_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<HslRouteTransportTargetMaxFields>;
  min?: Maybe<HslRouteTransportTargetMinFields>;
};

/** aggregate fields of "hsl_route.transport_target" */
export type HslRouteTransportTargetAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<HslRouteTransportTargetSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "hsl_route.transport_target". All fields are combined with a logical 'AND'. */
export type HslRouteTransportTargetBoolExp = {
  _and?: InputMaybe<Array<HslRouteTransportTargetBoolExp>>;
  _not?: InputMaybe<HslRouteTransportTargetBoolExp>;
  _or?: InputMaybe<Array<HslRouteTransportTargetBoolExp>>;
  lines?: InputMaybe<RouteLineBoolExp>;
  lines_aggregate?: InputMaybe<RouteLineAggregateBoolExp>;
  transport_target?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "hsl_route.transport_target" */
export enum HslRouteTransportTargetConstraint {
  /** unique or primary key constraint on columns "transport_target" */
  TransportTargetPkey = 'transport_target_pkey',
}

export enum HslRouteTransportTargetEnum {
  EspooAndKauniainenInternalTraffic = 'espoo_and_kauniainen_internal_traffic',
  EspooRegionalTraffic = 'espoo_regional_traffic',
  HelsinkiInternalTraffic = 'helsinki_internal_traffic',
  KeravaInternalTraffic = 'kerava_internal_traffic',
  KeravaRegionalTraffic = 'kerava_regional_traffic',
  KirkkonummiInternalTraffic = 'kirkkonummi_internal_traffic',
  KirkkonummiRegionalTraffic = 'kirkkonummi_regional_traffic',
  SipooInternalTraffic = 'sipoo_internal_traffic',
  SiuntioInternalTraffic = 'siuntio_internal_traffic',
  SiuntioRegionalTraffic = 'siuntio_regional_traffic',
  TransverseRegional = 'transverse_regional',
  TuusulaInternalTraffic = 'tuusula_internal_traffic',
  TuusulaRegionalTraffic = 'tuusula_regional_traffic',
  VantaaInternalTraffic = 'vantaa_internal_traffic',
  VantaaRegionalTraffic = 'vantaa_regional_traffic',
}

/** Boolean expression to compare columns of type "hsl_route_transport_target_enum". All fields are combined with logical 'AND'. */
export type HslRouteTransportTargetEnumComparisonExp = {
  _eq?: InputMaybe<HslRouteTransportTargetEnum>;
  _in?: InputMaybe<Array<HslRouteTransportTargetEnum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<HslRouteTransportTargetEnum>;
  _nin?: InputMaybe<Array<HslRouteTransportTargetEnum>>;
};

/** input type for inserting data into table "hsl_route.transport_target" */
export type HslRouteTransportTargetInsertInput = {
  lines?: InputMaybe<RouteLineArrRelInsertInput>;
  transport_target?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type HslRouteTransportTargetMaxFields = {
  __typename?: 'hsl_route_transport_target_max_fields';
  transport_target?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type HslRouteTransportTargetMinFields = {
  __typename?: 'hsl_route_transport_target_min_fields';
  transport_target?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "hsl_route.transport_target" */
export type HslRouteTransportTargetMutationResponse = {
  __typename?: 'hsl_route_transport_target_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<HslRouteTransportTarget>;
};

/** input type for inserting object relation for remote table "hsl_route.transport_target" */
export type HslRouteTransportTargetObjRelInsertInput = {
  data: HslRouteTransportTargetInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<HslRouteTransportTargetOnConflict>;
};

/** on_conflict condition type for table "hsl_route.transport_target" */
export type HslRouteTransportTargetOnConflict = {
  constraint: HslRouteTransportTargetConstraint;
  update_columns?: Array<HslRouteTransportTargetUpdateColumn>;
  where?: InputMaybe<HslRouteTransportTargetBoolExp>;
};

/** Ordering options when selecting data from "hsl_route.transport_target". */
export type HslRouteTransportTargetOrderBy = {
  lines_aggregate?: InputMaybe<RouteLineAggregateOrderBy>;
  transport_target?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: hsl_route.transport_target */
export type HslRouteTransportTargetPkColumnsInput = {
  transport_target: Scalars['String'];
};

/** select columns of table "hsl_route.transport_target" */
export enum HslRouteTransportTargetSelectColumn {
  /** column name */
  TransportTarget = 'transport_target',
}

/** input type for updating data in table "hsl_route.transport_target" */
export type HslRouteTransportTargetSetInput = {
  transport_target?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "hsl_route_transport_target" */
export type HslRouteTransportTargetStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: HslRouteTransportTargetStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type HslRouteTransportTargetStreamCursorValueInput = {
  transport_target?: InputMaybe<Scalars['String']>;
};

/** update columns of table "hsl_route.transport_target" */
export enum HslRouteTransportTargetUpdateColumn {
  /** column name */
  TransportTarget = 'transport_target',
}

export type HslRouteTransportTargetUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<HslRouteTransportTargetSetInput>;
  /** filter the rows which have to be updated */
  where: HslRouteTransportTargetBoolExp;
};

/** The direction in which an e.g. infrastructure link can be traversed */
export type InfrastructureNetworkDirection = {
  __typename?: 'infrastructure_network_direction';
  /** An array relationship */
  infrastructure_links: Array<InfrastructureNetworkInfrastructureLink>;
  /** An aggregate relationship */
  infrastructure_links_aggregate: InfrastructureNetworkInfrastructureLinkAggregate;
  value: InfrastructureNetworkDirectionEnum;
};

/** The direction in which an e.g. infrastructure link can be traversed */
export type InfrastructureNetworkDirectionInfrastructureLinksArgs = {
  distinct_on?: InputMaybe<
    Array<InfrastructureNetworkInfrastructureLinkSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<InfrastructureNetworkInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
};

/** The direction in which an e.g. infrastructure link can be traversed */
export type InfrastructureNetworkDirectionInfrastructureLinksAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<InfrastructureNetworkInfrastructureLinkSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<InfrastructureNetworkInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
};

/** aggregated selection of "infrastructure_network.direction" */
export type InfrastructureNetworkDirectionAggregate = {
  __typename?: 'infrastructure_network_direction_aggregate';
  aggregate?: Maybe<InfrastructureNetworkDirectionAggregateFields>;
  nodes: Array<InfrastructureNetworkDirection>;
};

/** aggregate fields of "infrastructure_network.direction" */
export type InfrastructureNetworkDirectionAggregateFields = {
  __typename?: 'infrastructure_network_direction_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<InfrastructureNetworkDirectionMaxFields>;
  min?: Maybe<InfrastructureNetworkDirectionMinFields>;
};

/** aggregate fields of "infrastructure_network.direction" */
export type InfrastructureNetworkDirectionAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<InfrastructureNetworkDirectionSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "infrastructure_network.direction". All fields are combined with a logical 'AND'. */
export type InfrastructureNetworkDirectionBoolExp = {
  _and?: InputMaybe<Array<InfrastructureNetworkDirectionBoolExp>>;
  _not?: InputMaybe<InfrastructureNetworkDirectionBoolExp>;
  _or?: InputMaybe<Array<InfrastructureNetworkDirectionBoolExp>>;
  infrastructure_links?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  infrastructure_links_aggregate?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateBoolExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "infrastructure_network.direction" */
export enum InfrastructureNetworkDirectionConstraint {
  /** unique or primary key constraint on columns "value" */
  DirectionPkey = 'direction_pkey',
}

export enum InfrastructureNetworkDirectionEnum {
  Backward = 'backward',
  Bidirectional = 'bidirectional',
  Forward = 'forward',
}

/** Boolean expression to compare columns of type "infrastructure_network_direction_enum". All fields are combined with logical 'AND'. */
export type InfrastructureNetworkDirectionEnumComparisonExp = {
  _eq?: InputMaybe<InfrastructureNetworkDirectionEnum>;
  _in?: InputMaybe<Array<InfrastructureNetworkDirectionEnum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<InfrastructureNetworkDirectionEnum>;
  _nin?: InputMaybe<Array<InfrastructureNetworkDirectionEnum>>;
};

/** input type for inserting data into table "infrastructure_network.direction" */
export type InfrastructureNetworkDirectionInsertInput = {
  infrastructure_links?: InputMaybe<InfrastructureNetworkInfrastructureLinkArrRelInsertInput>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type InfrastructureNetworkDirectionMaxFields = {
  __typename?: 'infrastructure_network_direction_max_fields';
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type InfrastructureNetworkDirectionMinFields = {
  __typename?: 'infrastructure_network_direction_min_fields';
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "infrastructure_network.direction" */
export type InfrastructureNetworkDirectionMutationResponse = {
  __typename?: 'infrastructure_network_direction_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<InfrastructureNetworkDirection>;
};

/** input type for inserting object relation for remote table "infrastructure_network.direction" */
export type InfrastructureNetworkDirectionObjRelInsertInput = {
  data: InfrastructureNetworkDirectionInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<InfrastructureNetworkDirectionOnConflict>;
};

/** on_conflict condition type for table "infrastructure_network.direction" */
export type InfrastructureNetworkDirectionOnConflict = {
  constraint: InfrastructureNetworkDirectionConstraint;
  update_columns?: Array<InfrastructureNetworkDirectionUpdateColumn>;
  where?: InputMaybe<InfrastructureNetworkDirectionBoolExp>;
};

/** Ordering options when selecting data from "infrastructure_network.direction". */
export type InfrastructureNetworkDirectionOrderBy = {
  infrastructure_links_aggregate?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateOrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: infrastructure_network.direction */
export type InfrastructureNetworkDirectionPkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "infrastructure_network.direction" */
export enum InfrastructureNetworkDirectionSelectColumn {
  /** column name */
  Value = 'value',
}

/** input type for updating data in table "infrastructure_network.direction" */
export type InfrastructureNetworkDirectionSetInput = {
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "infrastructure_network_direction" */
export type InfrastructureNetworkDirectionStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: InfrastructureNetworkDirectionStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type InfrastructureNetworkDirectionStreamCursorValueInput = {
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "infrastructure_network.direction" */
export enum InfrastructureNetworkDirectionUpdateColumn {
  /** column name */
  Value = 'value',
}

export type InfrastructureNetworkDirectionUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<InfrastructureNetworkDirectionSetInput>;
  /** filter the rows which have to be updated */
  where: InfrastructureNetworkDirectionBoolExp;
};

/** An external source from which infrastructure network parts are imported */
export type InfrastructureNetworkExternalSource = {
  __typename?: 'infrastructure_network_external_source';
  /** An array relationship */
  infrastructure_links: Array<InfrastructureNetworkInfrastructureLink>;
  /** An aggregate relationship */
  infrastructure_links_aggregate: InfrastructureNetworkInfrastructureLinkAggregate;
  value: Scalars['String'];
};

/** An external source from which infrastructure network parts are imported */
export type InfrastructureNetworkExternalSourceInfrastructureLinksArgs = {
  distinct_on?: InputMaybe<
    Array<InfrastructureNetworkInfrastructureLinkSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<InfrastructureNetworkInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
};

/** An external source from which infrastructure network parts are imported */
export type InfrastructureNetworkExternalSourceInfrastructureLinksAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<InfrastructureNetworkInfrastructureLinkSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<InfrastructureNetworkInfrastructureLinkOrderBy>
    >;
    where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  };

/** aggregated selection of "infrastructure_network.external_source" */
export type InfrastructureNetworkExternalSourceAggregate = {
  __typename?: 'infrastructure_network_external_source_aggregate';
  aggregate?: Maybe<InfrastructureNetworkExternalSourceAggregateFields>;
  nodes: Array<InfrastructureNetworkExternalSource>;
};

/** aggregate fields of "infrastructure_network.external_source" */
export type InfrastructureNetworkExternalSourceAggregateFields = {
  __typename?: 'infrastructure_network_external_source_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<InfrastructureNetworkExternalSourceMaxFields>;
  min?: Maybe<InfrastructureNetworkExternalSourceMinFields>;
};

/** aggregate fields of "infrastructure_network.external_source" */
export type InfrastructureNetworkExternalSourceAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<InfrastructureNetworkExternalSourceSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "infrastructure_network.external_source". All fields are combined with a logical 'AND'. */
export type InfrastructureNetworkExternalSourceBoolExp = {
  _and?: InputMaybe<Array<InfrastructureNetworkExternalSourceBoolExp>>;
  _not?: InputMaybe<InfrastructureNetworkExternalSourceBoolExp>;
  _or?: InputMaybe<Array<InfrastructureNetworkExternalSourceBoolExp>>;
  infrastructure_links?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  infrastructure_links_aggregate?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateBoolExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "infrastructure_network.external_source" */
export enum InfrastructureNetworkExternalSourceConstraint {
  /** unique or primary key constraint on columns "value" */
  ExternalSourcePkey = 'external_source_pkey',
}

export enum InfrastructureNetworkExternalSourceEnum {
  DigiroadR = 'digiroad_r',
  HslFixup = 'hsl_fixup',
}

/** Boolean expression to compare columns of type "infrastructure_network_external_source_enum". All fields are combined with logical 'AND'. */
export type InfrastructureNetworkExternalSourceEnumComparisonExp = {
  _eq?: InputMaybe<InfrastructureNetworkExternalSourceEnum>;
  _in?: InputMaybe<Array<InfrastructureNetworkExternalSourceEnum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<InfrastructureNetworkExternalSourceEnum>;
  _nin?: InputMaybe<Array<InfrastructureNetworkExternalSourceEnum>>;
};

/** input type for inserting data into table "infrastructure_network.external_source" */
export type InfrastructureNetworkExternalSourceInsertInput = {
  infrastructure_links?: InputMaybe<InfrastructureNetworkInfrastructureLinkArrRelInsertInput>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type InfrastructureNetworkExternalSourceMaxFields = {
  __typename?: 'infrastructure_network_external_source_max_fields';
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type InfrastructureNetworkExternalSourceMinFields = {
  __typename?: 'infrastructure_network_external_source_min_fields';
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "infrastructure_network.external_source" */
export type InfrastructureNetworkExternalSourceMutationResponse = {
  __typename?: 'infrastructure_network_external_source_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<InfrastructureNetworkExternalSource>;
};

/** input type for inserting object relation for remote table "infrastructure_network.external_source" */
export type InfrastructureNetworkExternalSourceObjRelInsertInput = {
  data: InfrastructureNetworkExternalSourceInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<InfrastructureNetworkExternalSourceOnConflict>;
};

/** on_conflict condition type for table "infrastructure_network.external_source" */
export type InfrastructureNetworkExternalSourceOnConflict = {
  constraint: InfrastructureNetworkExternalSourceConstraint;
  update_columns?: Array<InfrastructureNetworkExternalSourceUpdateColumn>;
  where?: InputMaybe<InfrastructureNetworkExternalSourceBoolExp>;
};

/** Ordering options when selecting data from "infrastructure_network.external_source". */
export type InfrastructureNetworkExternalSourceOrderBy = {
  infrastructure_links_aggregate?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateOrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: infrastructure_network.external_source */
export type InfrastructureNetworkExternalSourcePkColumnsInput = {
  value: Scalars['String'];
};

/** select columns of table "infrastructure_network.external_source" */
export enum InfrastructureNetworkExternalSourceSelectColumn {
  /** column name */
  Value = 'value',
}

/** input type for updating data in table "infrastructure_network.external_source" */
export type InfrastructureNetworkExternalSourceSetInput = {
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "infrastructure_network_external_source" */
export type InfrastructureNetworkExternalSourceStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: InfrastructureNetworkExternalSourceStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type InfrastructureNetworkExternalSourceStreamCursorValueInput = {
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "infrastructure_network.external_source" */
export enum InfrastructureNetworkExternalSourceUpdateColumn {
  /** column name */
  Value = 'value',
}

export type InfrastructureNetworkExternalSourceUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<InfrastructureNetworkExternalSourceSetInput>;
  /** filter the rows which have to be updated */
  where: InfrastructureNetworkExternalSourceBoolExp;
};

export type InfrastructureNetworkFindPointDirectionOnLinkArgs = {
  infrastructure_link_uuid?: InputMaybe<Scalars['uuid']>;
  point_max_distance_in_meters?: InputMaybe<Scalars['float8']>;
  point_of_interest?: InputMaybe<Scalars['geography']>;
};

/** The infrastructure links, e.g. road or rail elements: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:1:1:453 */
export type InfrastructureNetworkInfrastructureLink = {
  __typename?: 'infrastructure_network_infrastructure_link';
  /** The direction(s) of traffic with respect to the digitization, i.e. the direction of the specified line string. */
  direction: InfrastructureNetworkDirectionEnum;
  /** An object relationship */
  directionByDirection: InfrastructureNetworkDirection;
  /** The estimated length of the infrastructure link in metres. */
  estimated_length_in_metres?: Maybe<Scalars['float8']>;
  external_link_id: Scalars['String'];
  external_link_source: InfrastructureNetworkExternalSourceEnum;
  /** An object relationship */
  external_source: InfrastructureNetworkExternalSource;
  /** An array relationship */
  infrastructure_link_along_routes: Array<RouteInfrastructureLinkAlongRoute>;
  /** An aggregate relationship */
  infrastructure_link_along_routes_aggregate: RouteInfrastructureLinkAlongRouteAggregate;
  /** The ID of the infrastructure link. */
  infrastructure_link_id: Scalars['uuid'];
  /** An array relationship */
  scheduled_stop_points_located_on_infrastructure_link: Array<ServicePatternScheduledStopPoint>;
  /** An aggregate relationship */
  scheduled_stop_points_located_on_infrastructure_link_aggregate: ServicePatternScheduledStopPointAggregate;
  /** A PostGIS LinestringZ geography in EPSG:4326 describing the infrastructure link. */
  shape: Scalars['geography_linestring'];
  /** An array relationship */
  vehicle_submode_on_infrastructure_link: Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
  /** An aggregate relationship */
  vehicle_submode_on_infrastructure_link_aggregate: InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregate;
  /** An array relationship */
  vehicle_submode_on_infrastructure_links: Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
  /** An aggregate relationship */
  vehicle_submode_on_infrastructure_links_aggregate: InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregate;
};

/** The infrastructure links, e.g. road or rail elements: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:1:1:453 */
export type InfrastructureNetworkInfrastructureLinkInfrastructureLinkAlongRoutesArgs =
  {
    distinct_on?: InputMaybe<
      Array<RouteInfrastructureLinkAlongRouteSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<RouteInfrastructureLinkAlongRouteOrderBy>>;
    where?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
  };

/** The infrastructure links, e.g. road or rail elements: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:1:1:453 */
export type InfrastructureNetworkInfrastructureLinkInfrastructureLinkAlongRoutesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<RouteInfrastructureLinkAlongRouteSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<RouteInfrastructureLinkAlongRouteOrderBy>>;
    where?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
  };

/** The infrastructure links, e.g. road or rail elements: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:1:1:453 */
export type InfrastructureNetworkInfrastructureLinkScheduledStopPointsLocatedOnInfrastructureLinkArgs =
  {
    distinct_on?: InputMaybe<
      Array<ServicePatternScheduledStopPointSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<ServicePatternScheduledStopPointOrderBy>>;
    where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
  };

/** The infrastructure links, e.g. road or rail elements: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:1:1:453 */
export type InfrastructureNetworkInfrastructureLinkScheduledStopPointsLocatedOnInfrastructureLinkAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<ServicePatternScheduledStopPointSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<ServicePatternScheduledStopPointOrderBy>>;
    where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
  };

/** The infrastructure links, e.g. road or rail elements: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:1:1:453 */
export type InfrastructureNetworkInfrastructureLinkVehicleSubmodeOnInfrastructureLinkArgs =
  {
    distinct_on?: InputMaybe<
      Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOrderBy>
    >;
    where?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
  };

/** The infrastructure links, e.g. road or rail elements: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:1:1:453 */
export type InfrastructureNetworkInfrastructureLinkVehicleSubmodeOnInfrastructureLinkAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOrderBy>
    >;
    where?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
  };

/** The infrastructure links, e.g. road or rail elements: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:1:1:453 */
export type InfrastructureNetworkInfrastructureLinkVehicleSubmodeOnInfrastructureLinksArgs =
  {
    distinct_on?: InputMaybe<
      Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOrderBy>
    >;
    where?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
  };

/** The infrastructure links, e.g. road or rail elements: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:1:1:453 */
export type InfrastructureNetworkInfrastructureLinkVehicleSubmodeOnInfrastructureLinksAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOrderBy>
    >;
    where?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
  };

/** aggregated selection of "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkAggregate = {
  __typename?: 'infrastructure_network_infrastructure_link_aggregate';
  aggregate?: Maybe<InfrastructureNetworkInfrastructureLinkAggregateFields>;
  nodes: Array<InfrastructureNetworkInfrastructureLink>;
};

export type InfrastructureNetworkInfrastructureLinkAggregateBoolExp = {
  avg?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateBoolExpAvg>;
  corr?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateBoolExpCorr>;
  count?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateBoolExpCount>;
  covar_samp?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateBoolExpCovarSamp>;
  max?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateBoolExpMax>;
  min?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateBoolExpMin>;
  stddev_samp?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateBoolExpStddevSamp>;
  sum?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateBoolExpSum>;
  var_samp?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateBoolExpVarSamp>;
};

export type InfrastructureNetworkInfrastructureLinkAggregateBoolExpAvg = {
  arguments: InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpAvgArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  predicate: Float8ComparisonExp;
};

export type InfrastructureNetworkInfrastructureLinkAggregateBoolExpCorr = {
  arguments: InfrastructureNetworkInfrastructureLinkAggregateBoolExpCorrArguments;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  predicate: Float8ComparisonExp;
};

export type InfrastructureNetworkInfrastructureLinkAggregateBoolExpCorrArguments =
  {
    X: InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpCorrArgumentsColumns;
    Y: InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpCorrArgumentsColumns;
  };

export type InfrastructureNetworkInfrastructureLinkAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<InfrastructureNetworkInfrastructureLinkSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  predicate: IntComparisonExp;
};

export type InfrastructureNetworkInfrastructureLinkAggregateBoolExpCovarSamp = {
  arguments: InfrastructureNetworkInfrastructureLinkAggregateBoolExpCovarSampArguments;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  predicate: Float8ComparisonExp;
};

export type InfrastructureNetworkInfrastructureLinkAggregateBoolExpCovarSampArguments =
  {
    X: InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpCovarSampArgumentsColumns;
    Y: InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpCovarSampArgumentsColumns;
  };

export type InfrastructureNetworkInfrastructureLinkAggregateBoolExpMax = {
  arguments: InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpMaxArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  predicate: Float8ComparisonExp;
};

export type InfrastructureNetworkInfrastructureLinkAggregateBoolExpMin = {
  arguments: InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpMinArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  predicate: Float8ComparisonExp;
};

export type InfrastructureNetworkInfrastructureLinkAggregateBoolExpStddevSamp =
  {
    arguments: InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpStddevSampArgumentsColumns;
    distinct?: InputMaybe<Scalars['Boolean']>;
    filter?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
    predicate: Float8ComparisonExp;
  };

export type InfrastructureNetworkInfrastructureLinkAggregateBoolExpSum = {
  arguments: InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpSumArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  predicate: Float8ComparisonExp;
};

export type InfrastructureNetworkInfrastructureLinkAggregateBoolExpVarSamp = {
  arguments: InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpVarSampArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  predicate: Float8ComparisonExp;
};

/** aggregate fields of "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkAggregateFields = {
  __typename?: 'infrastructure_network_infrastructure_link_aggregate_fields';
  avg?: Maybe<InfrastructureNetworkInfrastructureLinkAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<InfrastructureNetworkInfrastructureLinkMaxFields>;
  min?: Maybe<InfrastructureNetworkInfrastructureLinkMinFields>;
  stddev?: Maybe<InfrastructureNetworkInfrastructureLinkStddevFields>;
  stddev_pop?: Maybe<InfrastructureNetworkInfrastructureLinkStddevPopFields>;
  stddev_samp?: Maybe<InfrastructureNetworkInfrastructureLinkStddevSampFields>;
  sum?: Maybe<InfrastructureNetworkInfrastructureLinkSumFields>;
  var_pop?: Maybe<InfrastructureNetworkInfrastructureLinkVarPopFields>;
  var_samp?: Maybe<InfrastructureNetworkInfrastructureLinkVarSampFields>;
  variance?: Maybe<InfrastructureNetworkInfrastructureLinkVarianceFields>;
};

/** aggregate fields of "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkAggregateFieldsCountArgs = {
  columns?: InputMaybe<
    Array<InfrastructureNetworkInfrastructureLinkSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkAggregateOrderBy = {
  avg?: InputMaybe<InfrastructureNetworkInfrastructureLinkAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<InfrastructureNetworkInfrastructureLinkMaxOrderBy>;
  min?: InputMaybe<InfrastructureNetworkInfrastructureLinkMinOrderBy>;
  stddev?: InputMaybe<InfrastructureNetworkInfrastructureLinkStddevOrderBy>;
  stddev_pop?: InputMaybe<InfrastructureNetworkInfrastructureLinkStddevPopOrderBy>;
  stddev_samp?: InputMaybe<InfrastructureNetworkInfrastructureLinkStddevSampOrderBy>;
  sum?: InputMaybe<InfrastructureNetworkInfrastructureLinkSumOrderBy>;
  var_pop?: InputMaybe<InfrastructureNetworkInfrastructureLinkVarPopOrderBy>;
  var_samp?: InputMaybe<InfrastructureNetworkInfrastructureLinkVarSampOrderBy>;
  variance?: InputMaybe<InfrastructureNetworkInfrastructureLinkVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkArrRelInsertInput = {
  data: Array<InfrastructureNetworkInfrastructureLinkInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<InfrastructureNetworkInfrastructureLinkOnConflict>;
};

/** aggregate avg on columns */
export type InfrastructureNetworkInfrastructureLinkAvgFields = {
  __typename?: 'infrastructure_network_infrastructure_link_avg_fields';
  /** The estimated length of the infrastructure link in metres. */
  estimated_length_in_metres?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkAvgOrderBy = {
  /** The estimated length of the infrastructure link in metres. */
  estimated_length_in_metres?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "infrastructure_network.infrastructure_link". All fields are combined with a logical 'AND'. */
export type InfrastructureNetworkInfrastructureLinkBoolExp = {
  _and?: InputMaybe<Array<InfrastructureNetworkInfrastructureLinkBoolExp>>;
  _not?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  _or?: InputMaybe<Array<InfrastructureNetworkInfrastructureLinkBoolExp>>;
  direction?: InputMaybe<InfrastructureNetworkDirectionEnumComparisonExp>;
  directionByDirection?: InputMaybe<InfrastructureNetworkDirectionBoolExp>;
  estimated_length_in_metres?: InputMaybe<Float8ComparisonExp>;
  external_link_id?: InputMaybe<StringComparisonExp>;
  external_link_source?: InputMaybe<InfrastructureNetworkExternalSourceEnumComparisonExp>;
  external_source?: InputMaybe<InfrastructureNetworkExternalSourceBoolExp>;
  infrastructure_link_along_routes?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
  infrastructure_link_along_routes_aggregate?: InputMaybe<RouteInfrastructureLinkAlongRouteAggregateBoolExp>;
  infrastructure_link_id?: InputMaybe<UuidComparisonExp>;
  scheduled_stop_points_located_on_infrastructure_link?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
  scheduled_stop_points_located_on_infrastructure_link_aggregate?: InputMaybe<ServicePatternScheduledStopPointAggregateBoolExp>;
  shape?: InputMaybe<GeographyComparisonExp>;
  vehicle_submode_on_infrastructure_link?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
  vehicle_submode_on_infrastructure_link_aggregate?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateBoolExp>;
  vehicle_submode_on_infrastructure_links?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
  vehicle_submode_on_infrastructure_links_aggregate?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateBoolExp>;
};

/** unique or primary key constraints on table "infrastructure_network.infrastructure_link" */
export enum InfrastructureNetworkInfrastructureLinkConstraint {
  /** unique or primary key constraint on columns "external_link_id", "external_link_source" */
  InfrastructureLinkExternalLinkIdExternalLinkSourceIdx = 'infrastructure_link_external_link_id_external_link_source_idx',
  /** unique or primary key constraint on columns "infrastructure_link_id" */
  InfrastructureLinkPkey = 'infrastructure_link_pkey',
}

/** input type for incrementing numeric columns in table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkIncInput = {
  /** The estimated length of the infrastructure link in metres. */
  estimated_length_in_metres?: InputMaybe<Scalars['float8']>;
};

/** input type for inserting data into table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkInsertInput = {
  /** The direction(s) of traffic with respect to the digitization, i.e. the direction of the specified line string. */
  direction?: InputMaybe<InfrastructureNetworkDirectionEnum>;
  directionByDirection?: InputMaybe<InfrastructureNetworkDirectionObjRelInsertInput>;
  /** The estimated length of the infrastructure link in metres. */
  estimated_length_in_metres?: InputMaybe<Scalars['float8']>;
  external_link_id?: InputMaybe<Scalars['String']>;
  external_link_source?: InputMaybe<InfrastructureNetworkExternalSourceEnum>;
  external_source?: InputMaybe<InfrastructureNetworkExternalSourceObjRelInsertInput>;
  infrastructure_link_along_routes?: InputMaybe<RouteInfrastructureLinkAlongRouteArrRelInsertInput>;
  /** The ID of the infrastructure link. */
  infrastructure_link_id?: InputMaybe<Scalars['uuid']>;
  scheduled_stop_points_located_on_infrastructure_link?: InputMaybe<ServicePatternScheduledStopPointArrRelInsertInput>;
  /** A PostGIS LinestringZ geography in EPSG:4326 describing the infrastructure link. */
  shape?: InputMaybe<Scalars['geography']>;
  vehicle_submode_on_infrastructure_link?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkArrRelInsertInput>;
  vehicle_submode_on_infrastructure_links?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkArrRelInsertInput>;
};

/** aggregate max on columns */
export type InfrastructureNetworkInfrastructureLinkMaxFields = {
  __typename?: 'infrastructure_network_infrastructure_link_max_fields';
  /** The estimated length of the infrastructure link in metres. */
  estimated_length_in_metres?: Maybe<Scalars['float8']>;
  external_link_id?: Maybe<Scalars['String']>;
  /** The ID of the infrastructure link. */
  infrastructure_link_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkMaxOrderBy = {
  /** The estimated length of the infrastructure link in metres. */
  estimated_length_in_metres?: InputMaybe<OrderBy>;
  external_link_id?: InputMaybe<OrderBy>;
  /** The ID of the infrastructure link. */
  infrastructure_link_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type InfrastructureNetworkInfrastructureLinkMinFields = {
  __typename?: 'infrastructure_network_infrastructure_link_min_fields';
  /** The estimated length of the infrastructure link in metres. */
  estimated_length_in_metres?: Maybe<Scalars['float8']>;
  external_link_id?: Maybe<Scalars['String']>;
  /** The ID of the infrastructure link. */
  infrastructure_link_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkMinOrderBy = {
  /** The estimated length of the infrastructure link in metres. */
  estimated_length_in_metres?: InputMaybe<OrderBy>;
  external_link_id?: InputMaybe<OrderBy>;
  /** The ID of the infrastructure link. */
  infrastructure_link_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkMutationResponse = {
  __typename?: 'infrastructure_network_infrastructure_link_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<InfrastructureNetworkInfrastructureLink>;
};

/** input type for inserting object relation for remote table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkObjRelInsertInput = {
  data: InfrastructureNetworkInfrastructureLinkInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<InfrastructureNetworkInfrastructureLinkOnConflict>;
};

/** on_conflict condition type for table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkOnConflict = {
  constraint: InfrastructureNetworkInfrastructureLinkConstraint;
  update_columns?: Array<InfrastructureNetworkInfrastructureLinkUpdateColumn>;
  where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
};

/** Ordering options when selecting data from "infrastructure_network.infrastructure_link". */
export type InfrastructureNetworkInfrastructureLinkOrderBy = {
  direction?: InputMaybe<OrderBy>;
  directionByDirection?: InputMaybe<InfrastructureNetworkDirectionOrderBy>;
  estimated_length_in_metres?: InputMaybe<OrderBy>;
  external_link_id?: InputMaybe<OrderBy>;
  external_link_source?: InputMaybe<OrderBy>;
  external_source?: InputMaybe<InfrastructureNetworkExternalSourceOrderBy>;
  infrastructure_link_along_routes_aggregate?: InputMaybe<RouteInfrastructureLinkAlongRouteAggregateOrderBy>;
  infrastructure_link_id?: InputMaybe<OrderBy>;
  scheduled_stop_points_located_on_infrastructure_link_aggregate?: InputMaybe<ServicePatternScheduledStopPointAggregateOrderBy>;
  shape?: InputMaybe<OrderBy>;
  vehicle_submode_on_infrastructure_link_aggregate?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateOrderBy>;
  vehicle_submode_on_infrastructure_links_aggregate?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateOrderBy>;
};

/** primary key columns input for table: infrastructure_network.infrastructure_link */
export type InfrastructureNetworkInfrastructureLinkPkColumnsInput = {
  /** The ID of the infrastructure link. */
  infrastructure_link_id: Scalars['uuid'];
};

/** select columns of table "infrastructure_network.infrastructure_link" */
export enum InfrastructureNetworkInfrastructureLinkSelectColumn {
  /** column name */
  Direction = 'direction',
  /** column name */
  EstimatedLengthInMetres = 'estimated_length_in_metres',
  /** column name */
  ExternalLinkId = 'external_link_id',
  /** column name */
  ExternalLinkSource = 'external_link_source',
  /** column name */
  InfrastructureLinkId = 'infrastructure_link_id',
  /** column name */
  Shape = 'shape',
}

/** select "infrastructure_network_infrastructure_link_aggregate_bool_exp_avg_arguments_columns" columns of table "infrastructure_network.infrastructure_link" */
export enum InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpAvgArgumentsColumns {
  /** column name */
  EstimatedLengthInMetres = 'estimated_length_in_metres',
}

/** select "infrastructure_network_infrastructure_link_aggregate_bool_exp_corr_arguments_columns" columns of table "infrastructure_network.infrastructure_link" */
export enum InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpCorrArgumentsColumns {
  /** column name */
  EstimatedLengthInMetres = 'estimated_length_in_metres',
}

/** select "infrastructure_network_infrastructure_link_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "infrastructure_network.infrastructure_link" */
export enum InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpCovarSampArgumentsColumns {
  /** column name */
  EstimatedLengthInMetres = 'estimated_length_in_metres',
}

/** select "infrastructure_network_infrastructure_link_aggregate_bool_exp_max_arguments_columns" columns of table "infrastructure_network.infrastructure_link" */
export enum InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpMaxArgumentsColumns {
  /** column name */
  EstimatedLengthInMetres = 'estimated_length_in_metres',
}

/** select "infrastructure_network_infrastructure_link_aggregate_bool_exp_min_arguments_columns" columns of table "infrastructure_network.infrastructure_link" */
export enum InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpMinArgumentsColumns {
  /** column name */
  EstimatedLengthInMetres = 'estimated_length_in_metres',
}

/** select "infrastructure_network_infrastructure_link_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "infrastructure_network.infrastructure_link" */
export enum InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpStddevSampArgumentsColumns {
  /** column name */
  EstimatedLengthInMetres = 'estimated_length_in_metres',
}

/** select "infrastructure_network_infrastructure_link_aggregate_bool_exp_sum_arguments_columns" columns of table "infrastructure_network.infrastructure_link" */
export enum InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpSumArgumentsColumns {
  /** column name */
  EstimatedLengthInMetres = 'estimated_length_in_metres',
}

/** select "infrastructure_network_infrastructure_link_aggregate_bool_exp_var_samp_arguments_columns" columns of table "infrastructure_network.infrastructure_link" */
export enum InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpVarSampArgumentsColumns {
  /** column name */
  EstimatedLengthInMetres = 'estimated_length_in_metres',
}

/** input type for updating data in table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkSetInput = {
  /** The direction(s) of traffic with respect to the digitization, i.e. the direction of the specified line string. */
  direction?: InputMaybe<InfrastructureNetworkDirectionEnum>;
  /** The estimated length of the infrastructure link in metres. */
  estimated_length_in_metres?: InputMaybe<Scalars['float8']>;
  external_link_id?: InputMaybe<Scalars['String']>;
  external_link_source?: InputMaybe<InfrastructureNetworkExternalSourceEnum>;
  /** The ID of the infrastructure link. */
  infrastructure_link_id?: InputMaybe<Scalars['uuid']>;
  /** A PostGIS LinestringZ geography in EPSG:4326 describing the infrastructure link. */
  shape?: InputMaybe<Scalars['geography']>;
};

/** aggregate stddev on columns */
export type InfrastructureNetworkInfrastructureLinkStddevFields = {
  __typename?: 'infrastructure_network_infrastructure_link_stddev_fields';
  /** The estimated length of the infrastructure link in metres. */
  estimated_length_in_metres?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkStddevOrderBy = {
  /** The estimated length of the infrastructure link in metres. */
  estimated_length_in_metres?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type InfrastructureNetworkInfrastructureLinkStddevPopFields = {
  __typename?: 'infrastructure_network_infrastructure_link_stddev_pop_fields';
  /** The estimated length of the infrastructure link in metres. */
  estimated_length_in_metres?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkStddevPopOrderBy = {
  /** The estimated length of the infrastructure link in metres. */
  estimated_length_in_metres?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type InfrastructureNetworkInfrastructureLinkStddevSampFields = {
  __typename?: 'infrastructure_network_infrastructure_link_stddev_samp_fields';
  /** The estimated length of the infrastructure link in metres. */
  estimated_length_in_metres?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkStddevSampOrderBy = {
  /** The estimated length of the infrastructure link in metres. */
  estimated_length_in_metres?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "infrastructure_network_infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: InfrastructureNetworkInfrastructureLinkStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type InfrastructureNetworkInfrastructureLinkStreamCursorValueInput = {
  /** The direction(s) of traffic with respect to the digitization, i.e. the direction of the specified line string. */
  direction?: InputMaybe<InfrastructureNetworkDirectionEnum>;
  /** The estimated length of the infrastructure link in metres. */
  estimated_length_in_metres?: InputMaybe<Scalars['float8']>;
  external_link_id?: InputMaybe<Scalars['String']>;
  external_link_source?: InputMaybe<InfrastructureNetworkExternalSourceEnum>;
  /** The ID of the infrastructure link. */
  infrastructure_link_id?: InputMaybe<Scalars['uuid']>;
  /** A PostGIS LinestringZ geography in EPSG:4326 describing the infrastructure link. */
  shape?: InputMaybe<Scalars['geography']>;
};

/** aggregate sum on columns */
export type InfrastructureNetworkInfrastructureLinkSumFields = {
  __typename?: 'infrastructure_network_infrastructure_link_sum_fields';
  /** The estimated length of the infrastructure link in metres. */
  estimated_length_in_metres?: Maybe<Scalars['float8']>;
};

/** order by sum() on columns of table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkSumOrderBy = {
  /** The estimated length of the infrastructure link in metres. */
  estimated_length_in_metres?: InputMaybe<OrderBy>;
};

/** update columns of table "infrastructure_network.infrastructure_link" */
export enum InfrastructureNetworkInfrastructureLinkUpdateColumn {
  /** column name */
  Direction = 'direction',
  /** column name */
  EstimatedLengthInMetres = 'estimated_length_in_metres',
  /** column name */
  ExternalLinkId = 'external_link_id',
  /** column name */
  ExternalLinkSource = 'external_link_source',
  /** column name */
  InfrastructureLinkId = 'infrastructure_link_id',
  /** column name */
  Shape = 'shape',
}

export type InfrastructureNetworkInfrastructureLinkUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<InfrastructureNetworkInfrastructureLinkIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<InfrastructureNetworkInfrastructureLinkSetInput>;
  /** filter the rows which have to be updated */
  where: InfrastructureNetworkInfrastructureLinkBoolExp;
};

/** aggregate var_pop on columns */
export type InfrastructureNetworkInfrastructureLinkVarPopFields = {
  __typename?: 'infrastructure_network_infrastructure_link_var_pop_fields';
  /** The estimated length of the infrastructure link in metres. */
  estimated_length_in_metres?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkVarPopOrderBy = {
  /** The estimated length of the infrastructure link in metres. */
  estimated_length_in_metres?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type InfrastructureNetworkInfrastructureLinkVarSampFields = {
  __typename?: 'infrastructure_network_infrastructure_link_var_samp_fields';
  /** The estimated length of the infrastructure link in metres. */
  estimated_length_in_metres?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkVarSampOrderBy = {
  /** The estimated length of the infrastructure link in metres. */
  estimated_length_in_metres?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type InfrastructureNetworkInfrastructureLinkVarianceFields = {
  __typename?: 'infrastructure_network_infrastructure_link_variance_fields';
  /** The estimated length of the infrastructure link in metres. */
  estimated_length_in_metres?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkVarianceOrderBy = {
  /** The estimated length of the infrastructure link in metres. */
  estimated_length_in_metres?: InputMaybe<OrderBy>;
};

export type InfrastructureNetworkResolvePointToClosestLinkArgs = {
  geog?: InputMaybe<Scalars['geography']>;
};

/** Which infrastructure links are safely traversed by which vehicle submodes? */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLink = {
  __typename?: 'infrastructure_network_vehicle_submode_on_infrastructure_link';
  /** An object relationship */
  infrastructure_link: InfrastructureNetworkInfrastructureLink;
  /** The infrastructure link that can be safely traversed by the vehicle submode. */
  infrastructure_link_id: Scalars['uuid'];
  /** An object relationship */
  vehicleSubmodeByVehicleSubmode: ReusableComponentsVehicleSubmode;
  /** The vehicle submode that can safely traverse the infrastructure link. */
  vehicle_submode: ReusableComponentsVehicleSubmodeEnum;
};

/** aggregated selection of "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregate = {
  __typename?: 'infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate';
  aggregate?: Maybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateFields>;
  nodes: Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
};

export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateBoolExp =
  {
    count?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateBoolExpCount>;
  };

export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateBoolExpCount =
  {
    arguments?: InputMaybe<
      Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
    filter?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
    predicate: IntComparisonExp;
  };

/** aggregate fields of "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateFields =
  {
    __typename?: 'infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate_fields';
    count: Scalars['Int'];
    max?: Maybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMaxFields>;
    min?: Maybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMinFields>;
  };

/** aggregate fields of "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateFieldsCountArgs =
  {
    columns?: InputMaybe<
      Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
  };

/** order by aggregate values of table "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateOrderBy =
  {
    count?: InputMaybe<OrderBy>;
    max?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMaxOrderBy>;
    min?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMinOrderBy>;
  };

/** input type for inserting array relation for remote table "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkArrRelInsertInput =
  {
    data: Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkInsertInput>;
    /** upsert condition */
    on_conflict?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOnConflict>;
  };

/** Boolean expression to filter rows from the table "infrastructure_network.vehicle_submode_on_infrastructure_link". All fields are combined with a logical 'AND'. */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp = {
  _and?: InputMaybe<
    Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>
  >;
  _not?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
  _or?: InputMaybe<
    Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>
  >;
  infrastructure_link?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  infrastructure_link_id?: InputMaybe<UuidComparisonExp>;
  vehicleSubmodeByVehicleSubmode?: InputMaybe<ReusableComponentsVehicleSubmodeBoolExp>;
  vehicle_submode?: InputMaybe<ReusableComponentsVehicleSubmodeEnumComparisonExp>;
};

/** unique or primary key constraints on table "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export enum InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkConstraint {
  /** unique or primary key constraint on columns "infrastructure_link_id", "vehicle_submode" */
  VehicleSubmodeOnInfrastructureLinkPkey = 'vehicle_submode_on_infrastructure_link_pkey',
}

/** input type for inserting data into table "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkInsertInput =
  {
    infrastructure_link?: InputMaybe<InfrastructureNetworkInfrastructureLinkObjRelInsertInput>;
    /** The infrastructure link that can be safely traversed by the vehicle submode. */
    infrastructure_link_id?: InputMaybe<Scalars['uuid']>;
    vehicleSubmodeByVehicleSubmode?: InputMaybe<ReusableComponentsVehicleSubmodeObjRelInsertInput>;
    /** The vehicle submode that can safely traverse the infrastructure link. */
    vehicle_submode?: InputMaybe<ReusableComponentsVehicleSubmodeEnum>;
  };

/** aggregate max on columns */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMaxFields = {
  __typename?: 'infrastructure_network_vehicle_submode_on_infrastructure_link_max_fields';
  /** The infrastructure link that can be safely traversed by the vehicle submode. */
  infrastructure_link_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMaxOrderBy =
  {
    /** The infrastructure link that can be safely traversed by the vehicle submode. */
    infrastructure_link_id?: InputMaybe<OrderBy>;
  };

/** aggregate min on columns */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMinFields = {
  __typename?: 'infrastructure_network_vehicle_submode_on_infrastructure_link_min_fields';
  /** The infrastructure link that can be safely traversed by the vehicle submode. */
  infrastructure_link_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMinOrderBy =
  {
    /** The infrastructure link that can be safely traversed by the vehicle submode. */
    infrastructure_link_id?: InputMaybe<OrderBy>;
  };

/** response of any mutation on the table "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMutationResponse =
  {
    __typename?: 'infrastructure_network_vehicle_submode_on_infrastructure_link_mutation_response';
    /** number of rows affected by the mutation */
    affected_rows: Scalars['Int'];
    /** data from the rows affected by the mutation */
    returning: Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
  };

/** on_conflict condition type for table "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOnConflict =
  {
    constraint: InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkConstraint;
    update_columns?: Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkUpdateColumn>;
    where?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
  };

/** Ordering options when selecting data from "infrastructure_network.vehicle_submode_on_infrastructure_link". */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOrderBy = {
  infrastructure_link?: InputMaybe<InfrastructureNetworkInfrastructureLinkOrderBy>;
  infrastructure_link_id?: InputMaybe<OrderBy>;
  vehicleSubmodeByVehicleSubmode?: InputMaybe<ReusableComponentsVehicleSubmodeOrderBy>;
  vehicle_submode?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: infrastructure_network.vehicle_submode_on_infrastructure_link */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkPkColumnsInput =
  {
    /** The infrastructure link that can be safely traversed by the vehicle submode. */
    infrastructure_link_id: Scalars['uuid'];
    /** The vehicle submode that can safely traverse the infrastructure link. */
    vehicle_submode: ReusableComponentsVehicleSubmodeEnum;
  };

/** select columns of table "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export enum InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn {
  /** column name */
  InfrastructureLinkId = 'infrastructure_link_id',
  /** column name */
  VehicleSubmode = 'vehicle_submode',
}

/** input type for updating data in table "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSetInput = {
  /** The infrastructure link that can be safely traversed by the vehicle submode. */
  infrastructure_link_id?: InputMaybe<Scalars['uuid']>;
  /** The vehicle submode that can safely traverse the infrastructure link. */
  vehicle_submode?: InputMaybe<ReusableComponentsVehicleSubmodeEnum>;
};

/** Streaming cursor of the table "infrastructure_network_vehicle_submode_on_infrastructure_link" */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkStreamCursorInput =
  {
    /** Stream column input with initial value */
    initial_value: InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
  };

/** Initial value of the column from where the streaming should start */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkStreamCursorValueInput =
  {
    /** The infrastructure link that can be safely traversed by the vehicle submode. */
    infrastructure_link_id?: InputMaybe<Scalars['uuid']>;
    /** The vehicle submode that can safely traverse the infrastructure link. */
    vehicle_submode?: InputMaybe<ReusableComponentsVehicleSubmodeEnum>;
  };

/** update columns of table "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export enum InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkUpdateColumn {
  /** column name */
  InfrastructureLinkId = 'infrastructure_link_id',
  /** column name */
  VehicleSubmode = 'vehicle_submode',
}

export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSetInput>;
  /** filter the rows which have to be updated */
  where: InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp;
};

export type InstalledEquipmentVersionStructureInstalledEquipmentAggregateBoolExp =
  {
    count?: InputMaybe<InstalledEquipmentVersionStructureInstalledEquipmentAggregateBoolExpCount>;
  };

export type InstalledEquipmentVersionStructureInstalledEquipmentAggregateBoolExpCount =
  {
    arguments?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
    filter?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>;
    predicate: IntComparisonExp;
  };

/** Boolean expression to compare columns of type "interval". All fields are combined with logical 'AND'. */
export type IntervalComparisonExp = {
  _eq?: InputMaybe<Scalars['interval']>;
  _gt?: InputMaybe<Scalars['interval']>;
  _gte?: InputMaybe<Scalars['interval']>;
  _in?: InputMaybe<Array<Scalars['interval']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['interval']>;
  _lte?: InputMaybe<Scalars['interval']>;
  _neq?: InputMaybe<Scalars['interval']>;
  _nin?: InputMaybe<Array<Scalars['interval']>>;
};

export type JourneyPatternCheckInfraLinkStopRefsWithNewScheduledStopPointArgs =
  {
    new_direction?: InputMaybe<Scalars['String']>;
    new_label?: InputMaybe<Scalars['String']>;
    new_located_on_infrastructure_link_id?: InputMaybe<Scalars['uuid']>;
    new_measured_location?: InputMaybe<Scalars['geography']>;
    new_priority?: InputMaybe<Scalars['Int']>;
    new_validity_end?: InputMaybe<Scalars['date']>;
    new_validity_start?: InputMaybe<Scalars['date']>;
    replace_scheduled_stop_point_id?: InputMaybe<Scalars['uuid']>;
  };

/** The journey patterns, i.e. the ordered lists of stops and timing points along routes: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813 */
export type JourneyPatternJourneyPattern = {
  __typename?: 'journey_pattern_journey_pattern';
  /** The ID of the journey pattern. */
  journey_pattern_id: Scalars['uuid'];
  journey_pattern_refs: Array<TimetablesJourneyPatternJourneyPatternRef>;
  journey_pattern_refs_aggregate: TimetablesJourneyPatternJourneyPatternRefAggregate;
  /** An object relationship */
  journey_pattern_route?: Maybe<RouteRoute>;
  journey_pattern_vehicle_services: Array<TimetablesVehicleServiceJourneyPatternsInVehicleService>;
  journey_pattern_vehicle_services_aggregate: TimetablesVehicleServiceJourneyPatternsInVehicleServiceAggregate;
  /** The ID of the route the journey pattern is on. */
  on_route_id: Scalars['uuid'];
  /** An array relationship */
  scheduled_stop_point_in_journey_patterns: Array<JourneyPatternScheduledStopPointInJourneyPattern>;
  /** An aggregate relationship */
  scheduled_stop_point_in_journey_patterns_aggregate: JourneyPatternScheduledStopPointInJourneyPatternAggregate;
};

/** The journey patterns, i.e. the ordered lists of stops and timing points along routes: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813 */
export type JourneyPatternJourneyPatternJourneyPatternRefsArgs = {
  distinct_on?: InputMaybe<
    Array<TimetablesJourneyPatternJourneyPatternRefSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<
    Array<TimetablesJourneyPatternJourneyPatternRefOrderBy>
  >;
  where?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefBoolExp>;
};

/** The journey patterns, i.e. the ordered lists of stops and timing points along routes: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813 */
export type JourneyPatternJourneyPatternJourneyPatternRefsAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<TimetablesJourneyPatternJourneyPatternRefSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<
    Array<TimetablesJourneyPatternJourneyPatternRefOrderBy>
  >;
  where?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefBoolExp>;
};

/** The journey patterns, i.e. the ordered lists of stops and timing points along routes: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813 */
export type JourneyPatternJourneyPatternJourneyPatternVehicleServicesArgs = {
  distinct_on?: InputMaybe<
    Array<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<
    Array<TimetablesVehicleServiceJourneyPatternsInVehicleServiceOrderBy>
  >;
  where?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
};

/** The journey patterns, i.e. the ordered lists of stops and timing points along routes: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813 */
export type JourneyPatternJourneyPatternJourneyPatternVehicleServicesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesVehicleServiceJourneyPatternsInVehicleServiceOrderBy>
    >;
    where?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
  };

/** The journey patterns, i.e. the ordered lists of stops and timing points along routes: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813 */
export type JourneyPatternJourneyPatternScheduledStopPointInJourneyPatternsArgs =
  {
    distinct_on?: InputMaybe<
      Array<JourneyPatternScheduledStopPointInJourneyPatternSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<JourneyPatternScheduledStopPointInJourneyPatternOrderBy>
    >;
    where?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
  };

/** The journey patterns, i.e. the ordered lists of stops and timing points along routes: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813 */
export type JourneyPatternJourneyPatternScheduledStopPointInJourneyPatternsAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<JourneyPatternScheduledStopPointInJourneyPatternSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<JourneyPatternScheduledStopPointInJourneyPatternOrderBy>
    >;
    where?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
  };

/** aggregated selection of "journey_pattern.journey_pattern" */
export type JourneyPatternJourneyPatternAggregate = {
  __typename?: 'journey_pattern_journey_pattern_aggregate';
  aggregate?: Maybe<JourneyPatternJourneyPatternAggregateFields>;
  nodes: Array<JourneyPatternJourneyPattern>;
};

export type JourneyPatternJourneyPatternAggregateBoolExp = {
  count?: InputMaybe<JourneyPatternJourneyPatternAggregateBoolExpCount>;
};

export type JourneyPatternJourneyPatternAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<JourneyPatternJourneyPatternSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "journey_pattern.journey_pattern" */
export type JourneyPatternJourneyPatternAggregateFields = {
  __typename?: 'journey_pattern_journey_pattern_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<JourneyPatternJourneyPatternMaxFields>;
  min?: Maybe<JourneyPatternJourneyPatternMinFields>;
};

/** aggregate fields of "journey_pattern.journey_pattern" */
export type JourneyPatternJourneyPatternAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<JourneyPatternJourneyPatternSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "journey_pattern.journey_pattern" */
export type JourneyPatternJourneyPatternAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<JourneyPatternJourneyPatternMaxOrderBy>;
  min?: InputMaybe<JourneyPatternJourneyPatternMinOrderBy>;
};

/** input type for inserting array relation for remote table "journey_pattern.journey_pattern" */
export type JourneyPatternJourneyPatternArrRelInsertInput = {
  data: Array<JourneyPatternJourneyPatternInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<JourneyPatternJourneyPatternOnConflict>;
};

/** Boolean expression to filter rows from the table "journey_pattern.journey_pattern". All fields are combined with a logical 'AND'. */
export type JourneyPatternJourneyPatternBoolExp = {
  _and?: InputMaybe<Array<JourneyPatternJourneyPatternBoolExp>>;
  _not?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
  _or?: InputMaybe<Array<JourneyPatternJourneyPatternBoolExp>>;
  journey_pattern_id?: InputMaybe<UuidComparisonExp>;
  journey_pattern_route?: InputMaybe<RouteRouteBoolExp>;
  on_route_id?: InputMaybe<UuidComparisonExp>;
  scheduled_stop_point_in_journey_patterns?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
  scheduled_stop_point_in_journey_patterns_aggregate?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExp>;
};

/** unique or primary key constraints on table "journey_pattern.journey_pattern" */
export enum JourneyPatternJourneyPatternConstraint {
  /** unique or primary key constraint on columns "on_route_id" */
  JourneyPatternOnRouteIdIdx = 'journey_pattern_on_route_id_idx',
  /** unique or primary key constraint on columns "journey_pattern_id" */
  JourneyPatternPkey = 'journey_pattern_pkey',
}

/** input type for inserting data into table "journey_pattern.journey_pattern" */
export type JourneyPatternJourneyPatternInsertInput = {
  /** The ID of the journey pattern. */
  journey_pattern_id?: InputMaybe<Scalars['uuid']>;
  journey_pattern_route?: InputMaybe<RouteRouteObjRelInsertInput>;
  /** The ID of the route the journey pattern is on. */
  on_route_id?: InputMaybe<Scalars['uuid']>;
  scheduled_stop_point_in_journey_patterns?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternArrRelInsertInput>;
};

/** aggregate max on columns */
export type JourneyPatternJourneyPatternMaxFields = {
  __typename?: 'journey_pattern_journey_pattern_max_fields';
  /** The ID of the journey pattern. */
  journey_pattern_id?: Maybe<Scalars['uuid']>;
  /** The ID of the route the journey pattern is on. */
  on_route_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "journey_pattern.journey_pattern" */
export type JourneyPatternJourneyPatternMaxOrderBy = {
  /** The ID of the journey pattern. */
  journey_pattern_id?: InputMaybe<OrderBy>;
  /** The ID of the route the journey pattern is on. */
  on_route_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type JourneyPatternJourneyPatternMinFields = {
  __typename?: 'journey_pattern_journey_pattern_min_fields';
  /** The ID of the journey pattern. */
  journey_pattern_id?: Maybe<Scalars['uuid']>;
  /** The ID of the route the journey pattern is on. */
  on_route_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "journey_pattern.journey_pattern" */
export type JourneyPatternJourneyPatternMinOrderBy = {
  /** The ID of the journey pattern. */
  journey_pattern_id?: InputMaybe<OrderBy>;
  /** The ID of the route the journey pattern is on. */
  on_route_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "journey_pattern.journey_pattern" */
export type JourneyPatternJourneyPatternMutationResponse = {
  __typename?: 'journey_pattern_journey_pattern_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<JourneyPatternJourneyPattern>;
};

/** input type for inserting object relation for remote table "journey_pattern.journey_pattern" */
export type JourneyPatternJourneyPatternObjRelInsertInput = {
  data: JourneyPatternJourneyPatternInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<JourneyPatternJourneyPatternOnConflict>;
};

/** on_conflict condition type for table "journey_pattern.journey_pattern" */
export type JourneyPatternJourneyPatternOnConflict = {
  constraint: JourneyPatternJourneyPatternConstraint;
  update_columns?: Array<JourneyPatternJourneyPatternUpdateColumn>;
  where?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
};

/** Ordering options when selecting data from "journey_pattern.journey_pattern". */
export type JourneyPatternJourneyPatternOrderBy = {
  journey_pattern_id?: InputMaybe<OrderBy>;
  journey_pattern_route?: InputMaybe<RouteRouteOrderBy>;
  on_route_id?: InputMaybe<OrderBy>;
  scheduled_stop_point_in_journey_patterns_aggregate?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternAggregateOrderBy>;
};

/** primary key columns input for table: journey_pattern.journey_pattern */
export type JourneyPatternJourneyPatternPkColumnsInput = {
  /** The ID of the journey pattern. */
  journey_pattern_id: Scalars['uuid'];
};

/** select columns of table "journey_pattern.journey_pattern" */
export enum JourneyPatternJourneyPatternSelectColumn {
  /** column name */
  JourneyPatternId = 'journey_pattern_id',
  /** column name */
  OnRouteId = 'on_route_id',
}

/** input type for updating data in table "journey_pattern.journey_pattern" */
export type JourneyPatternJourneyPatternSetInput = {
  /** The ID of the journey pattern. */
  journey_pattern_id?: InputMaybe<Scalars['uuid']>;
  /** The ID of the route the journey pattern is on. */
  on_route_id?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "journey_pattern_journey_pattern" */
export type JourneyPatternJourneyPatternStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: JourneyPatternJourneyPatternStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type JourneyPatternJourneyPatternStreamCursorValueInput = {
  /** The ID of the journey pattern. */
  journey_pattern_id?: InputMaybe<Scalars['uuid']>;
  /** The ID of the route the journey pattern is on. */
  on_route_id?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "journey_pattern.journey_pattern" */
export enum JourneyPatternJourneyPatternUpdateColumn {
  /** column name */
  JourneyPatternId = 'journey_pattern_id',
  /** column name */
  OnRouteId = 'on_route_id',
}

export type JourneyPatternJourneyPatternUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<JourneyPatternJourneyPatternSetInput>;
  /** filter the rows which have to be updated */
  where: JourneyPatternJourneyPatternBoolExp;
};

/** The scheduled stop points that form the journey pattern, in order: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813 . For HSL, all timing points are stops, hence journey pattern instead of service pattern. */
export type JourneyPatternScheduledStopPointInJourneyPattern = {
  __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
  /** Is adding loading time to this scheduled stop point in the journey pattern allowed? */
  is_loading_time_allowed: Scalars['Boolean'];
  /** Is this stop point passing time regulated so that it cannot be passed before scheduled time? */
  is_regulated_timing_point: Scalars['Boolean'];
  /** Is this scheduled stop point used as a timing point in the journey pattern? */
  is_used_as_timing_point: Scalars['Boolean'];
  /** Is this scheduled stop point a via point? */
  is_via_point: Scalars['Boolean'];
  /** An object relationship */
  journey_pattern: JourneyPatternJourneyPattern;
  /** The ID of the journey pattern. */
  journey_pattern_id: Scalars['uuid'];
  scheduled_stop_point_label: Scalars['String'];
  /** The order of the scheduled stop point within the journey pattern. */
  scheduled_stop_point_sequence: Scalars['Int'];
  /** An array relationship */
  scheduled_stop_points: Array<ServicePatternScheduledStopPoint>;
  /** An aggregate relationship */
  scheduled_stop_points_aggregate: ServicePatternScheduledStopPointAggregate;
  via_point_name_i18n?: Maybe<Scalars['localized_string']>;
  via_point_short_name_i18n?: Maybe<Scalars['localized_string']>;
};

/** The scheduled stop points that form the journey pattern, in order: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813 . For HSL, all timing points are stops, hence journey pattern instead of service pattern. */
export type JourneyPatternScheduledStopPointInJourneyPatternScheduledStopPointsArgs =
  {
    distinct_on?: InputMaybe<
      Array<ServicePatternScheduledStopPointSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<ServicePatternScheduledStopPointOrderBy>>;
    where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
  };

/** The scheduled stop points that form the journey pattern, in order: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813 . For HSL, all timing points are stops, hence journey pattern instead of service pattern. */
export type JourneyPatternScheduledStopPointInJourneyPatternScheduledStopPointsAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<ServicePatternScheduledStopPointSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<ServicePatternScheduledStopPointOrderBy>>;
    where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
  };

/** The scheduled stop points that form the journey pattern, in order: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813 . For HSL, all timing points are stops, hence journey pattern instead of service pattern. */
export type JourneyPatternScheduledStopPointInJourneyPatternViaPointNameI18nArgs =
  {
    path?: InputMaybe<Scalars['String']>;
  };

/** The scheduled stop points that form the journey pattern, in order: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813 . For HSL, all timing points are stops, hence journey pattern instead of service pattern. */
export type JourneyPatternScheduledStopPointInJourneyPatternViaPointShortNameI18nArgs =
  {
    path?: InputMaybe<Scalars['String']>;
  };

/** aggregated selection of "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternAggregate = {
  __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate';
  aggregate?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternAggregateFields>;
  nodes: Array<JourneyPatternScheduledStopPointInJourneyPattern>;
};

export type JourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExp = {
  bool_and?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExpBoolAnd>;
  bool_or?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExpBoolOr>;
  count?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExpCount>;
};

export type JourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExpBoolAnd =
  {
    arguments: JourneyPatternScheduledStopPointInJourneyPatternSelectColumnJourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExpBoolAndArgumentsColumns;
    distinct?: InputMaybe<Scalars['Boolean']>;
    filter?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
    predicate: BooleanComparisonExp;
  };

export type JourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExpBoolOr =
  {
    arguments: JourneyPatternScheduledStopPointInJourneyPatternSelectColumnJourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExpBoolOrArgumentsColumns;
    distinct?: InputMaybe<Scalars['Boolean']>;
    filter?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
    predicate: BooleanComparisonExp;
  };

export type JourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExpCount =
  {
    arguments?: InputMaybe<
      Array<JourneyPatternScheduledStopPointInJourneyPatternSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
    filter?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
    predicate: IntComparisonExp;
  };

/** aggregate fields of "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternAggregateFields = {
  __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_fields';
  avg?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternMaxFields>;
  min?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternMinFields>;
  stddev?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternStddevFields>;
  stddev_pop?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternStddevPopFields>;
  stddev_samp?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternStddevSampFields>;
  sum?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternSumFields>;
  var_pop?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternVarPopFields>;
  var_samp?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternVarSampFields>;
  variance?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternVarianceFields>;
};

/** aggregate fields of "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternAggregateFieldsCountArgs =
  {
    columns?: InputMaybe<
      Array<JourneyPatternScheduledStopPointInJourneyPatternSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
  };

/** order by aggregate values of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternAggregateOrderBy = {
  avg?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternMaxOrderBy>;
  min?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternMinOrderBy>;
  stddev?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternStddevOrderBy>;
  stddev_pop?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternStddevPopOrderBy>;
  stddev_samp?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternStddevSampOrderBy>;
  sum?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternSumOrderBy>;
  var_pop?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternVarPopOrderBy>;
  var_samp?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternVarSampOrderBy>;
  variance?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type JourneyPatternScheduledStopPointInJourneyPatternAppendInput = {
  via_point_name_i18n?: InputMaybe<Scalars['jsonb']>;
  via_point_short_name_i18n?: InputMaybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternArrRelInsertInput =
  {
    data: Array<JourneyPatternScheduledStopPointInJourneyPatternInsertInput>;
    /** upsert condition */
    on_conflict?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternOnConflict>;
  };

/** aggregate avg on columns */
export type JourneyPatternScheduledStopPointInJourneyPatternAvgFields = {
  __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_avg_fields';
  /** The order of the scheduled stop point within the journey pattern. */
  scheduled_stop_point_sequence?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternAvgOrderBy = {
  /** The order of the scheduled stop point within the journey pattern. */
  scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "journey_pattern.scheduled_stop_point_in_journey_pattern". All fields are combined with a logical 'AND'. */
export type JourneyPatternScheduledStopPointInJourneyPatternBoolExp = {
  _and?: InputMaybe<
    Array<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>
  >;
  _not?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
  _or?: InputMaybe<
    Array<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>
  >;
  is_loading_time_allowed?: InputMaybe<BooleanComparisonExp>;
  is_regulated_timing_point?: InputMaybe<BooleanComparisonExp>;
  is_used_as_timing_point?: InputMaybe<BooleanComparisonExp>;
  is_via_point?: InputMaybe<BooleanComparisonExp>;
  journey_pattern?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
  journey_pattern_id?: InputMaybe<UuidComparisonExp>;
  scheduled_stop_point_label?: InputMaybe<StringComparisonExp>;
  scheduled_stop_point_sequence?: InputMaybe<IntComparisonExp>;
  scheduled_stop_points?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
  scheduled_stop_points_aggregate?: InputMaybe<ServicePatternScheduledStopPointAggregateBoolExp>;
  via_point_name_i18n?: InputMaybe<JsonbComparisonExp>;
  via_point_short_name_i18n?: InputMaybe<JsonbComparisonExp>;
};

/** unique or primary key constraints on table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export enum JourneyPatternScheduledStopPointInJourneyPatternConstraint {
  /** unique or primary key constraint on columns "scheduled_stop_point_sequence", "journey_pattern_id" */
  ScheduledStopPointInJourneyPatternPkey = 'scheduled_stop_point_in_journey_pattern_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type JourneyPatternScheduledStopPointInJourneyPatternDeleteAtPathInput =
  {
    via_point_name_i18n?: InputMaybe<Array<Scalars['String']>>;
    via_point_short_name_i18n?: InputMaybe<Array<Scalars['String']>>;
  };

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type JourneyPatternScheduledStopPointInJourneyPatternDeleteElemInput = {
  via_point_name_i18n?: InputMaybe<Scalars['Int']>;
  via_point_short_name_i18n?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type JourneyPatternScheduledStopPointInJourneyPatternDeleteKeyInput = {
  via_point_name_i18n?: InputMaybe<Scalars['String']>;
  via_point_short_name_i18n?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternIncInput = {
  /** The order of the scheduled stop point within the journey pattern. */
  scheduled_stop_point_sequence?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternInsertInput = {
  /** Is adding loading time to this scheduled stop point in the journey pattern allowed? */
  is_loading_time_allowed?: InputMaybe<Scalars['Boolean']>;
  /** Is this stop point passing time regulated so that it cannot be passed before scheduled time? */
  is_regulated_timing_point?: InputMaybe<Scalars['Boolean']>;
  /** Is this scheduled stop point used as a timing point in the journey pattern? */
  is_used_as_timing_point?: InputMaybe<Scalars['Boolean']>;
  /** Is this scheduled stop point a via point? */
  is_via_point?: InputMaybe<Scalars['Boolean']>;
  journey_pattern?: InputMaybe<JourneyPatternJourneyPatternObjRelInsertInput>;
  /** The ID of the journey pattern. */
  journey_pattern_id?: InputMaybe<Scalars['uuid']>;
  scheduled_stop_point_label?: InputMaybe<Scalars['String']>;
  /** The order of the scheduled stop point within the journey pattern. */
  scheduled_stop_point_sequence?: InputMaybe<Scalars['Int']>;
  scheduled_stop_points?: InputMaybe<ServicePatternScheduledStopPointArrRelInsertInput>;
  via_point_name_i18n?: InputMaybe<Scalars['localized_string']>;
  via_point_short_name_i18n?: InputMaybe<Scalars['localized_string']>;
};

/** aggregate max on columns */
export type JourneyPatternScheduledStopPointInJourneyPatternMaxFields = {
  __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_max_fields';
  /** The ID of the journey pattern. */
  journey_pattern_id?: Maybe<Scalars['uuid']>;
  scheduled_stop_point_label?: Maybe<Scalars['String']>;
  /** The order of the scheduled stop point within the journey pattern. */
  scheduled_stop_point_sequence?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternMaxOrderBy = {
  /** The ID of the journey pattern. */
  journey_pattern_id?: InputMaybe<OrderBy>;
  scheduled_stop_point_label?: InputMaybe<OrderBy>;
  /** The order of the scheduled stop point within the journey pattern. */
  scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type JourneyPatternScheduledStopPointInJourneyPatternMinFields = {
  __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_min_fields';
  /** The ID of the journey pattern. */
  journey_pattern_id?: Maybe<Scalars['uuid']>;
  scheduled_stop_point_label?: Maybe<Scalars['String']>;
  /** The order of the scheduled stop point within the journey pattern. */
  scheduled_stop_point_sequence?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternMinOrderBy = {
  /** The ID of the journey pattern. */
  journey_pattern_id?: InputMaybe<OrderBy>;
  scheduled_stop_point_label?: InputMaybe<OrderBy>;
  /** The order of the scheduled stop point within the journey pattern. */
  scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternMutationResponse = {
  __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<JourneyPatternScheduledStopPointInJourneyPattern>;
};

/** on_conflict condition type for table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternOnConflict = {
  constraint: JourneyPatternScheduledStopPointInJourneyPatternConstraint;
  update_columns?: Array<JourneyPatternScheduledStopPointInJourneyPatternUpdateColumn>;
  where?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
};

/** Ordering options when selecting data from "journey_pattern.scheduled_stop_point_in_journey_pattern". */
export type JourneyPatternScheduledStopPointInJourneyPatternOrderBy = {
  is_loading_time_allowed?: InputMaybe<OrderBy>;
  is_regulated_timing_point?: InputMaybe<OrderBy>;
  is_used_as_timing_point?: InputMaybe<OrderBy>;
  is_via_point?: InputMaybe<OrderBy>;
  journey_pattern?: InputMaybe<JourneyPatternJourneyPatternOrderBy>;
  journey_pattern_id?: InputMaybe<OrderBy>;
  scheduled_stop_point_label?: InputMaybe<OrderBy>;
  scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
  scheduled_stop_points_aggregate?: InputMaybe<ServicePatternScheduledStopPointAggregateOrderBy>;
  via_point_name_i18n?: InputMaybe<OrderBy>;
  via_point_short_name_i18n?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: journey_pattern.scheduled_stop_point_in_journey_pattern */
export type JourneyPatternScheduledStopPointInJourneyPatternPkColumnsInput = {
  /** The ID of the journey pattern. */
  journey_pattern_id: Scalars['uuid'];
  /** The order of the scheduled stop point within the journey pattern. */
  scheduled_stop_point_sequence: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type JourneyPatternScheduledStopPointInJourneyPatternPrependInput = {
  via_point_name_i18n?: InputMaybe<Scalars['jsonb']>;
  via_point_short_name_i18n?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export enum JourneyPatternScheduledStopPointInJourneyPatternSelectColumn {
  /** column name */
  IsLoadingTimeAllowed = 'is_loading_time_allowed',
  /** column name */
  IsRegulatedTimingPoint = 'is_regulated_timing_point',
  /** column name */
  IsUsedAsTimingPoint = 'is_used_as_timing_point',
  /** column name */
  IsViaPoint = 'is_via_point',
  /** column name */
  JourneyPatternId = 'journey_pattern_id',
  /** column name */
  ScheduledStopPointLabel = 'scheduled_stop_point_label',
  /** column name */
  ScheduledStopPointSequence = 'scheduled_stop_point_sequence',
  /** column name */
  ViaPointNameI18n = 'via_point_name_i18n',
  /** column name */
  ViaPointShortNameI18n = 'via_point_short_name_i18n',
}

/** select "journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_bool_exp_bool_and_arguments_columns" columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export enum JourneyPatternScheduledStopPointInJourneyPatternSelectColumnJourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExpBoolAndArgumentsColumns {
  /** column name */
  IsLoadingTimeAllowed = 'is_loading_time_allowed',
  /** column name */
  IsRegulatedTimingPoint = 'is_regulated_timing_point',
  /** column name */
  IsUsedAsTimingPoint = 'is_used_as_timing_point',
  /** column name */
  IsViaPoint = 'is_via_point',
}

/** select "journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_bool_exp_bool_or_arguments_columns" columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export enum JourneyPatternScheduledStopPointInJourneyPatternSelectColumnJourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExpBoolOrArgumentsColumns {
  /** column name */
  IsLoadingTimeAllowed = 'is_loading_time_allowed',
  /** column name */
  IsRegulatedTimingPoint = 'is_regulated_timing_point',
  /** column name */
  IsUsedAsTimingPoint = 'is_used_as_timing_point',
  /** column name */
  IsViaPoint = 'is_via_point',
}

/** input type for updating data in table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternSetInput = {
  /** Is adding loading time to this scheduled stop point in the journey pattern allowed? */
  is_loading_time_allowed?: InputMaybe<Scalars['Boolean']>;
  /** Is this stop point passing time regulated so that it cannot be passed before scheduled time? */
  is_regulated_timing_point?: InputMaybe<Scalars['Boolean']>;
  /** Is this scheduled stop point used as a timing point in the journey pattern? */
  is_used_as_timing_point?: InputMaybe<Scalars['Boolean']>;
  /** Is this scheduled stop point a via point? */
  is_via_point?: InputMaybe<Scalars['Boolean']>;
  /** The ID of the journey pattern. */
  journey_pattern_id?: InputMaybe<Scalars['uuid']>;
  scheduled_stop_point_label?: InputMaybe<Scalars['String']>;
  /** The order of the scheduled stop point within the journey pattern. */
  scheduled_stop_point_sequence?: InputMaybe<Scalars['Int']>;
  via_point_name_i18n?: InputMaybe<Scalars['localized_string']>;
  via_point_short_name_i18n?: InputMaybe<Scalars['localized_string']>;
};

/** aggregate stddev on columns */
export type JourneyPatternScheduledStopPointInJourneyPatternStddevFields = {
  __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_stddev_fields';
  /** The order of the scheduled stop point within the journey pattern. */
  scheduled_stop_point_sequence?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternStddevOrderBy = {
  /** The order of the scheduled stop point within the journey pattern. */
  scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type JourneyPatternScheduledStopPointInJourneyPatternStddevPopFields = {
  __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_stddev_pop_fields';
  /** The order of the scheduled stop point within the journey pattern. */
  scheduled_stop_point_sequence?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternStddevPopOrderBy = {
  /** The order of the scheduled stop point within the journey pattern. */
  scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type JourneyPatternScheduledStopPointInJourneyPatternStddevSampFields = {
  __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_stddev_samp_fields';
  /** The order of the scheduled stop point within the journey pattern. */
  scheduled_stop_point_sequence?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternStddevSampOrderBy =
  {
    /** The order of the scheduled stop point within the journey pattern. */
    scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
  };

/** Streaming cursor of the table "journey_pattern_scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternStreamCursorInput =
  {
    /** Stream column input with initial value */
    initial_value: JourneyPatternScheduledStopPointInJourneyPatternStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
  };

/** Initial value of the column from where the streaming should start */
export type JourneyPatternScheduledStopPointInJourneyPatternStreamCursorValueInput =
  {
    /** Is adding loading time to this scheduled stop point in the journey pattern allowed? */
    is_loading_time_allowed?: InputMaybe<Scalars['Boolean']>;
    /** Is this stop point passing time regulated so that it cannot be passed before scheduled time? */
    is_regulated_timing_point?: InputMaybe<Scalars['Boolean']>;
    /** Is this scheduled stop point used as a timing point in the journey pattern? */
    is_used_as_timing_point?: InputMaybe<Scalars['Boolean']>;
    /** Is this scheduled stop point a via point? */
    is_via_point?: InputMaybe<Scalars['Boolean']>;
    /** The ID of the journey pattern. */
    journey_pattern_id?: InputMaybe<Scalars['uuid']>;
    scheduled_stop_point_label?: InputMaybe<Scalars['String']>;
    /** The order of the scheduled stop point within the journey pattern. */
    scheduled_stop_point_sequence?: InputMaybe<Scalars['Int']>;
    via_point_name_i18n?: InputMaybe<Scalars['jsonb']>;
    via_point_short_name_i18n?: InputMaybe<Scalars['jsonb']>;
  };

/** aggregate sum on columns */
export type JourneyPatternScheduledStopPointInJourneyPatternSumFields = {
  __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_sum_fields';
  /** The order of the scheduled stop point within the journey pattern. */
  scheduled_stop_point_sequence?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternSumOrderBy = {
  /** The order of the scheduled stop point within the journey pattern. */
  scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

/** update columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export enum JourneyPatternScheduledStopPointInJourneyPatternUpdateColumn {
  /** column name */
  IsLoadingTimeAllowed = 'is_loading_time_allowed',
  /** column name */
  IsRegulatedTimingPoint = 'is_regulated_timing_point',
  /** column name */
  IsUsedAsTimingPoint = 'is_used_as_timing_point',
  /** column name */
  IsViaPoint = 'is_via_point',
  /** column name */
  JourneyPatternId = 'journey_pattern_id',
  /** column name */
  ScheduledStopPointLabel = 'scheduled_stop_point_label',
  /** column name */
  ScheduledStopPointSequence = 'scheduled_stop_point_sequence',
  /** column name */
  ViaPointNameI18n = 'via_point_name_i18n',
  /** column name */
  ViaPointShortNameI18n = 'via_point_short_name_i18n',
}

export type JourneyPatternScheduledStopPointInJourneyPatternUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternSetInput>;
  /** filter the rows which have to be updated */
  where: JourneyPatternScheduledStopPointInJourneyPatternBoolExp;
};

/** aggregate var_pop on columns */
export type JourneyPatternScheduledStopPointInJourneyPatternVarPopFields = {
  __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_var_pop_fields';
  /** The order of the scheduled stop point within the journey pattern. */
  scheduled_stop_point_sequence?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternVarPopOrderBy = {
  /** The order of the scheduled stop point within the journey pattern. */
  scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type JourneyPatternScheduledStopPointInJourneyPatternVarSampFields = {
  __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_var_samp_fields';
  /** The order of the scheduled stop point within the journey pattern. */
  scheduled_stop_point_sequence?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternVarSampOrderBy = {
  /** The order of the scheduled stop point within the journey pattern. */
  scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type JourneyPatternScheduledStopPointInJourneyPatternVarianceFields = {
  __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_variance_fields';
  /** The order of the scheduled stop point within the journey pattern. */
  scheduled_stop_point_sequence?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternVarianceOrderBy = {
  /** The order of the scheduled stop point within the journey pattern. */
  scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

export type JsonbCastExp = {
  String?: InputMaybe<StringComparisonExp>;
};

/** Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'. */
export type JsonbComparisonExp = {
  _cast?: InputMaybe<JsonbCastExp>;
  /** is the column contained in the given json value */
  _contained_in?: InputMaybe<Scalars['jsonb']>;
  /** does the column contain the given json value at the top level */
  _contains?: InputMaybe<Scalars['jsonb']>;
  _eq?: InputMaybe<Scalars['jsonb']>;
  _gt?: InputMaybe<Scalars['jsonb']>;
  _gte?: InputMaybe<Scalars['jsonb']>;
  /** does the string exist as a top-level key in the column */
  _has_key?: InputMaybe<Scalars['String']>;
  /** do all of these strings exist as top-level keys in the column */
  _has_keys_all?: InputMaybe<Array<Scalars['String']>>;
  /** do any of these strings exist as top-level keys in the column */
  _has_keys_any?: InputMaybe<Array<Scalars['String']>>;
  _in?: InputMaybe<Array<Scalars['jsonb']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['jsonb']>;
  _lte?: InputMaybe<Scalars['jsonb']>;
  _neq?: InputMaybe<Scalars['jsonb']>;
  _nin?: InputMaybe<Array<Scalars['jsonb']>>;
};

export type LevelKeyValuesAggregateBoolExp = {
  count?: InputMaybe<LevelKeyValuesAggregateBoolExpCount>;
};

export type LevelKeyValuesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<StopsDatabaseLevelKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseLevelKeyValuesBoolExp>;
  predicate: IntComparisonExp;
};

/** mutation root */
export type MutationRoot = {
  __typename?: 'mutation_root';
  combineTimetables?: Maybe<CombineTimetablesOutput>;
  /** delete data from the table: "hsl_route.legacy_hsl_municipality_code" */
  delete_hsl_route_legacy_hsl_municipality_code?: Maybe<HslRouteLegacyHslMunicipalityCodeMutationResponse>;
  /** delete single row from the table: "hsl_route.legacy_hsl_municipality_code" */
  delete_hsl_route_legacy_hsl_municipality_code_by_pk?: Maybe<HslRouteLegacyHslMunicipalityCode>;
  /** delete data from the table: "hsl_route.transport_target" */
  delete_hsl_route_transport_target?: Maybe<HslRouteTransportTargetMutationResponse>;
  /** delete single row from the table: "hsl_route.transport_target" */
  delete_hsl_route_transport_target_by_pk?: Maybe<HslRouteTransportTarget>;
  /** delete data from the table: "infrastructure_network.direction" */
  delete_infrastructure_network_direction?: Maybe<InfrastructureNetworkDirectionMutationResponse>;
  /** delete single row from the table: "infrastructure_network.direction" */
  delete_infrastructure_network_direction_by_pk?: Maybe<InfrastructureNetworkDirection>;
  /** delete data from the table: "infrastructure_network.external_source" */
  delete_infrastructure_network_external_source?: Maybe<InfrastructureNetworkExternalSourceMutationResponse>;
  /** delete single row from the table: "infrastructure_network.external_source" */
  delete_infrastructure_network_external_source_by_pk?: Maybe<InfrastructureNetworkExternalSource>;
  /** delete data from the table: "infrastructure_network.infrastructure_link" */
  delete_infrastructure_network_infrastructure_link?: Maybe<InfrastructureNetworkInfrastructureLinkMutationResponse>;
  /** delete single row from the table: "infrastructure_network.infrastructure_link" */
  delete_infrastructure_network_infrastructure_link_by_pk?: Maybe<InfrastructureNetworkInfrastructureLink>;
  /** delete data from the table: "infrastructure_network.vehicle_submode_on_infrastructure_link" */
  delete_infrastructure_network_vehicle_submode_on_infrastructure_link?: Maybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMutationResponse>;
  /** delete single row from the table: "infrastructure_network.vehicle_submode_on_infrastructure_link" */
  delete_infrastructure_network_vehicle_submode_on_infrastructure_link_by_pk?: Maybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
  /** delete data from the table: "journey_pattern.journey_pattern" */
  delete_journey_pattern_journey_pattern?: Maybe<JourneyPatternJourneyPatternMutationResponse>;
  /** delete single row from the table: "journey_pattern.journey_pattern" */
  delete_journey_pattern_journey_pattern_by_pk?: Maybe<JourneyPatternJourneyPattern>;
  /** delete data from the table: "journey_pattern.scheduled_stop_point_in_journey_pattern" */
  delete_journey_pattern_scheduled_stop_point_in_journey_pattern?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternMutationResponse>;
  /** delete single row from the table: "journey_pattern.scheduled_stop_point_in_journey_pattern" */
  delete_journey_pattern_scheduled_stop_point_in_journey_pattern_by_pk?: Maybe<JourneyPatternScheduledStopPointInJourneyPattern>;
  /** delete data from the table: "reusable_components.vehicle_mode" */
  delete_reusable_components_vehicle_mode?: Maybe<ReusableComponentsVehicleModeMutationResponse>;
  /** delete single row from the table: "reusable_components.vehicle_mode" */
  delete_reusable_components_vehicle_mode_by_pk?: Maybe<ReusableComponentsVehicleMode>;
  /** delete data from the table: "reusable_components.vehicle_submode" */
  delete_reusable_components_vehicle_submode?: Maybe<ReusableComponentsVehicleSubmodeMutationResponse>;
  /** delete single row from the table: "reusable_components.vehicle_submode" */
  delete_reusable_components_vehicle_submode_by_pk?: Maybe<ReusableComponentsVehicleSubmode>;
  /** delete data from the table: "route.direction" */
  delete_route_direction?: Maybe<RouteDirectionMutationResponse>;
  /** delete single row from the table: "route.direction" */
  delete_route_direction_by_pk?: Maybe<RouteDirection>;
  /** delete data from the table: "route.infrastructure_link_along_route" */
  delete_route_infrastructure_link_along_route?: Maybe<RouteInfrastructureLinkAlongRouteMutationResponse>;
  /** delete single row from the table: "route.infrastructure_link_along_route" */
  delete_route_infrastructure_link_along_route_by_pk?: Maybe<RouteInfrastructureLinkAlongRoute>;
  /** delete data from the table: "route.line" */
  delete_route_line?: Maybe<RouteLineMutationResponse>;
  /** delete single row from the table: "route.line" */
  delete_route_line_by_pk?: Maybe<RouteLine>;
  /** delete data from the table: "route.route" */
  delete_route_route?: Maybe<RouteRouteMutationResponse>;
  /** delete single row from the table: "route.route" */
  delete_route_route_by_pk?: Maybe<RouteRoute>;
  /** delete data from the table: "route.type_of_line" */
  delete_route_type_of_line?: Maybe<RouteTypeOfLineMutationResponse>;
  /** delete single row from the table: "route.type_of_line" */
  delete_route_type_of_line_by_pk?: Maybe<RouteTypeOfLine>;
  /** delete data from the table: "service_pattern.distance_between_stops_calculation" */
  delete_service_pattern_distance_between_stops_calculation?: Maybe<ServicePatternDistanceBetweenStopsCalculationMutationResponse>;
  /** delete single row from the table: "service_pattern.distance_between_stops_calculation" */
  delete_service_pattern_distance_between_stops_calculation_by_pk?: Maybe<ServicePatternDistanceBetweenStopsCalculation>;
  /** delete data from the table: "service_pattern.scheduled_stop_point" */
  delete_service_pattern_scheduled_stop_point?: Maybe<ServicePatternScheduledStopPointMutationResponse>;
  /** delete single row from the table: "service_pattern.scheduled_stop_point" */
  delete_service_pattern_scheduled_stop_point_by_pk?: Maybe<ServicePatternScheduledStopPoint>;
  /** delete data from the table: "service_pattern.vehicle_mode_on_scheduled_stop_point" */
  delete_service_pattern_vehicle_mode_on_scheduled_stop_point?: Maybe<ServicePatternVehicleModeOnScheduledStopPointMutationResponse>;
  /** delete single row from the table: "service_pattern.vehicle_mode_on_scheduled_stop_point" */
  delete_service_pattern_vehicle_mode_on_scheduled_stop_point_by_pk?: Maybe<ServicePatternVehicleModeOnScheduledStopPoint>;
  /** delete data from the table: "timing_pattern.timing_place" */
  delete_timing_pattern_timing_place?: Maybe<TimingPatternTimingPlaceMutationResponse>;
  /** delete single row from the table: "timing_pattern.timing_place" */
  delete_timing_pattern_timing_place_by_pk?: Maybe<TimingPatternTimingPlace>;
  /** insert data into the table: "hsl_route.legacy_hsl_municipality_code" */
  insert_hsl_route_legacy_hsl_municipality_code?: Maybe<HslRouteLegacyHslMunicipalityCodeMutationResponse>;
  /** insert a single row into the table: "hsl_route.legacy_hsl_municipality_code" */
  insert_hsl_route_legacy_hsl_municipality_code_one?: Maybe<HslRouteLegacyHslMunicipalityCode>;
  /** insert data into the table: "hsl_route.transport_target" */
  insert_hsl_route_transport_target?: Maybe<HslRouteTransportTargetMutationResponse>;
  /** insert a single row into the table: "hsl_route.transport_target" */
  insert_hsl_route_transport_target_one?: Maybe<HslRouteTransportTarget>;
  /** insert data into the table: "infrastructure_network.direction" */
  insert_infrastructure_network_direction?: Maybe<InfrastructureNetworkDirectionMutationResponse>;
  /** insert a single row into the table: "infrastructure_network.direction" */
  insert_infrastructure_network_direction_one?: Maybe<InfrastructureNetworkDirection>;
  /** insert data into the table: "infrastructure_network.external_source" */
  insert_infrastructure_network_external_source?: Maybe<InfrastructureNetworkExternalSourceMutationResponse>;
  /** insert a single row into the table: "infrastructure_network.external_source" */
  insert_infrastructure_network_external_source_one?: Maybe<InfrastructureNetworkExternalSource>;
  /** insert data into the table: "infrastructure_network.infrastructure_link" */
  insert_infrastructure_network_infrastructure_link?: Maybe<InfrastructureNetworkInfrastructureLinkMutationResponse>;
  /** insert a single row into the table: "infrastructure_network.infrastructure_link" */
  insert_infrastructure_network_infrastructure_link_one?: Maybe<InfrastructureNetworkInfrastructureLink>;
  /** insert data into the table: "infrastructure_network.vehicle_submode_on_infrastructure_link" */
  insert_infrastructure_network_vehicle_submode_on_infrastructure_link?: Maybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMutationResponse>;
  /** insert a single row into the table: "infrastructure_network.vehicle_submode_on_infrastructure_link" */
  insert_infrastructure_network_vehicle_submode_on_infrastructure_link_one?: Maybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
  /** insert data into the table: "journey_pattern.journey_pattern" */
  insert_journey_pattern_journey_pattern?: Maybe<JourneyPatternJourneyPatternMutationResponse>;
  /** insert a single row into the table: "journey_pattern.journey_pattern" */
  insert_journey_pattern_journey_pattern_one?: Maybe<JourneyPatternJourneyPattern>;
  /** insert data into the table: "journey_pattern.scheduled_stop_point_in_journey_pattern" */
  insert_journey_pattern_scheduled_stop_point_in_journey_pattern?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternMutationResponse>;
  /** insert a single row into the table: "journey_pattern.scheduled_stop_point_in_journey_pattern" */
  insert_journey_pattern_scheduled_stop_point_in_journey_pattern_one?: Maybe<JourneyPatternScheduledStopPointInJourneyPattern>;
  /** insert data into the table: "reusable_components.vehicle_mode" */
  insert_reusable_components_vehicle_mode?: Maybe<ReusableComponentsVehicleModeMutationResponse>;
  /** insert a single row into the table: "reusable_components.vehicle_mode" */
  insert_reusable_components_vehicle_mode_one?: Maybe<ReusableComponentsVehicleMode>;
  /** insert data into the table: "reusable_components.vehicle_submode" */
  insert_reusable_components_vehicle_submode?: Maybe<ReusableComponentsVehicleSubmodeMutationResponse>;
  /** insert a single row into the table: "reusable_components.vehicle_submode" */
  insert_reusable_components_vehicle_submode_one?: Maybe<ReusableComponentsVehicleSubmode>;
  /** insert data into the table: "route.direction" */
  insert_route_direction?: Maybe<RouteDirectionMutationResponse>;
  /** insert a single row into the table: "route.direction" */
  insert_route_direction_one?: Maybe<RouteDirection>;
  /** insert data into the table: "route.infrastructure_link_along_route" */
  insert_route_infrastructure_link_along_route?: Maybe<RouteInfrastructureLinkAlongRouteMutationResponse>;
  /** insert a single row into the table: "route.infrastructure_link_along_route" */
  insert_route_infrastructure_link_along_route_one?: Maybe<RouteInfrastructureLinkAlongRoute>;
  /** insert data into the table: "route.line" */
  insert_route_line?: Maybe<RouteLineMutationResponse>;
  /** insert a single row into the table: "route.line" */
  insert_route_line_one?: Maybe<RouteLine>;
  /** insert data into the table: "route.route" */
  insert_route_route?: Maybe<RouteRouteMutationResponse>;
  /** insert a single row into the table: "route.route" */
  insert_route_route_one?: Maybe<RouteRoute>;
  /** insert data into the table: "route.type_of_line" */
  insert_route_type_of_line?: Maybe<RouteTypeOfLineMutationResponse>;
  /** insert a single row into the table: "route.type_of_line" */
  insert_route_type_of_line_one?: Maybe<RouteTypeOfLine>;
  /** insert data into the table: "service_pattern.distance_between_stops_calculation" */
  insert_service_pattern_distance_between_stops_calculation?: Maybe<ServicePatternDistanceBetweenStopsCalculationMutationResponse>;
  /** insert a single row into the table: "service_pattern.distance_between_stops_calculation" */
  insert_service_pattern_distance_between_stops_calculation_one?: Maybe<ServicePatternDistanceBetweenStopsCalculation>;
  /** insert data into the table: "service_pattern.scheduled_stop_point" */
  insert_service_pattern_scheduled_stop_point?: Maybe<ServicePatternScheduledStopPointMutationResponse>;
  /** insert a single row into the table: "service_pattern.scheduled_stop_point" */
  insert_service_pattern_scheduled_stop_point_one?: Maybe<ServicePatternScheduledStopPoint>;
  /** insert data into the table: "service_pattern.vehicle_mode_on_scheduled_stop_point" */
  insert_service_pattern_vehicle_mode_on_scheduled_stop_point?: Maybe<ServicePatternVehicleModeOnScheduledStopPointMutationResponse>;
  /** insert a single row into the table: "service_pattern.vehicle_mode_on_scheduled_stop_point" */
  insert_service_pattern_vehicle_mode_on_scheduled_stop_point_one?: Maybe<ServicePatternVehicleModeOnScheduledStopPoint>;
  /** insert data into the table: "timing_pattern.timing_place" */
  insert_timing_pattern_timing_place?: Maybe<TimingPatternTimingPlaceMutationResponse>;
  /** insert a single row into the table: "timing_pattern.timing_place" */
  insert_timing_pattern_timing_place_one?: Maybe<TimingPatternTimingPlace>;
  replaceTimetables?: Maybe<ReplaceTimetablesOutput>;
  stop_registry?: Maybe<StopRegistryStopPlaceMutation>;
  stops_database?: Maybe<StopsDatabaseStopsDatabaseMutationFrontend>;
  timetables?: Maybe<TimetablesTimetablesMutationFrontend>;
  /** update data of the table: "hsl_route.legacy_hsl_municipality_code" */
  update_hsl_route_legacy_hsl_municipality_code?: Maybe<HslRouteLegacyHslMunicipalityCodeMutationResponse>;
  /** update single row of the table: "hsl_route.legacy_hsl_municipality_code" */
  update_hsl_route_legacy_hsl_municipality_code_by_pk?: Maybe<HslRouteLegacyHslMunicipalityCode>;
  /** update multiples rows of table: "hsl_route.legacy_hsl_municipality_code" */
  update_hsl_route_legacy_hsl_municipality_code_many?: Maybe<
    Array<Maybe<HslRouteLegacyHslMunicipalityCodeMutationResponse>>
  >;
  /** update data of the table: "hsl_route.transport_target" */
  update_hsl_route_transport_target?: Maybe<HslRouteTransportTargetMutationResponse>;
  /** update single row of the table: "hsl_route.transport_target" */
  update_hsl_route_transport_target_by_pk?: Maybe<HslRouteTransportTarget>;
  /** update multiples rows of table: "hsl_route.transport_target" */
  update_hsl_route_transport_target_many?: Maybe<
    Array<Maybe<HslRouteTransportTargetMutationResponse>>
  >;
  /** update data of the table: "infrastructure_network.direction" */
  update_infrastructure_network_direction?: Maybe<InfrastructureNetworkDirectionMutationResponse>;
  /** update single row of the table: "infrastructure_network.direction" */
  update_infrastructure_network_direction_by_pk?: Maybe<InfrastructureNetworkDirection>;
  /** update multiples rows of table: "infrastructure_network.direction" */
  update_infrastructure_network_direction_many?: Maybe<
    Array<Maybe<InfrastructureNetworkDirectionMutationResponse>>
  >;
  /** update data of the table: "infrastructure_network.external_source" */
  update_infrastructure_network_external_source?: Maybe<InfrastructureNetworkExternalSourceMutationResponse>;
  /** update single row of the table: "infrastructure_network.external_source" */
  update_infrastructure_network_external_source_by_pk?: Maybe<InfrastructureNetworkExternalSource>;
  /** update multiples rows of table: "infrastructure_network.external_source" */
  update_infrastructure_network_external_source_many?: Maybe<
    Array<Maybe<InfrastructureNetworkExternalSourceMutationResponse>>
  >;
  /** update data of the table: "infrastructure_network.infrastructure_link" */
  update_infrastructure_network_infrastructure_link?: Maybe<InfrastructureNetworkInfrastructureLinkMutationResponse>;
  /** update single row of the table: "infrastructure_network.infrastructure_link" */
  update_infrastructure_network_infrastructure_link_by_pk?: Maybe<InfrastructureNetworkInfrastructureLink>;
  /** update multiples rows of table: "infrastructure_network.infrastructure_link" */
  update_infrastructure_network_infrastructure_link_many?: Maybe<
    Array<Maybe<InfrastructureNetworkInfrastructureLinkMutationResponse>>
  >;
  /** update data of the table: "infrastructure_network.vehicle_submode_on_infrastructure_link" */
  update_infrastructure_network_vehicle_submode_on_infrastructure_link?: Maybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMutationResponse>;
  /** update single row of the table: "infrastructure_network.vehicle_submode_on_infrastructure_link" */
  update_infrastructure_network_vehicle_submode_on_infrastructure_link_by_pk?: Maybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
  /** update multiples rows of table: "infrastructure_network.vehicle_submode_on_infrastructure_link" */
  update_infrastructure_network_vehicle_submode_on_infrastructure_link_many?: Maybe<
    Array<
      Maybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMutationResponse>
    >
  >;
  /** update data of the table: "journey_pattern.journey_pattern" */
  update_journey_pattern_journey_pattern?: Maybe<JourneyPatternJourneyPatternMutationResponse>;
  /** update single row of the table: "journey_pattern.journey_pattern" */
  update_journey_pattern_journey_pattern_by_pk?: Maybe<JourneyPatternJourneyPattern>;
  /** update multiples rows of table: "journey_pattern.journey_pattern" */
  update_journey_pattern_journey_pattern_many?: Maybe<
    Array<Maybe<JourneyPatternJourneyPatternMutationResponse>>
  >;
  /** update data of the table: "journey_pattern.scheduled_stop_point_in_journey_pattern" */
  update_journey_pattern_scheduled_stop_point_in_journey_pattern?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternMutationResponse>;
  /** update single row of the table: "journey_pattern.scheduled_stop_point_in_journey_pattern" */
  update_journey_pattern_scheduled_stop_point_in_journey_pattern_by_pk?: Maybe<JourneyPatternScheduledStopPointInJourneyPattern>;
  /** update multiples rows of table: "journey_pattern.scheduled_stop_point_in_journey_pattern" */
  update_journey_pattern_scheduled_stop_point_in_journey_pattern_many?: Maybe<
    Array<
      Maybe<JourneyPatternScheduledStopPointInJourneyPatternMutationResponse>
    >
  >;
  /** update data of the table: "reusable_components.vehicle_mode" */
  update_reusable_components_vehicle_mode?: Maybe<ReusableComponentsVehicleModeMutationResponse>;
  /** update single row of the table: "reusable_components.vehicle_mode" */
  update_reusable_components_vehicle_mode_by_pk?: Maybe<ReusableComponentsVehicleMode>;
  /** update multiples rows of table: "reusable_components.vehicle_mode" */
  update_reusable_components_vehicle_mode_many?: Maybe<
    Array<Maybe<ReusableComponentsVehicleModeMutationResponse>>
  >;
  /** update data of the table: "reusable_components.vehicle_submode" */
  update_reusable_components_vehicle_submode?: Maybe<ReusableComponentsVehicleSubmodeMutationResponse>;
  /** update single row of the table: "reusable_components.vehicle_submode" */
  update_reusable_components_vehicle_submode_by_pk?: Maybe<ReusableComponentsVehicleSubmode>;
  /** update multiples rows of table: "reusable_components.vehicle_submode" */
  update_reusable_components_vehicle_submode_many?: Maybe<
    Array<Maybe<ReusableComponentsVehicleSubmodeMutationResponse>>
  >;
  /** update data of the table: "route.direction" */
  update_route_direction?: Maybe<RouteDirectionMutationResponse>;
  /** update single row of the table: "route.direction" */
  update_route_direction_by_pk?: Maybe<RouteDirection>;
  /** update multiples rows of table: "route.direction" */
  update_route_direction_many?: Maybe<
    Array<Maybe<RouteDirectionMutationResponse>>
  >;
  /** update data of the table: "route.infrastructure_link_along_route" */
  update_route_infrastructure_link_along_route?: Maybe<RouteInfrastructureLinkAlongRouteMutationResponse>;
  /** update single row of the table: "route.infrastructure_link_along_route" */
  update_route_infrastructure_link_along_route_by_pk?: Maybe<RouteInfrastructureLinkAlongRoute>;
  /** update multiples rows of table: "route.infrastructure_link_along_route" */
  update_route_infrastructure_link_along_route_many?: Maybe<
    Array<Maybe<RouteInfrastructureLinkAlongRouteMutationResponse>>
  >;
  /** update data of the table: "route.line" */
  update_route_line?: Maybe<RouteLineMutationResponse>;
  /** update single row of the table: "route.line" */
  update_route_line_by_pk?: Maybe<RouteLine>;
  /** update multiples rows of table: "route.line" */
  update_route_line_many?: Maybe<Array<Maybe<RouteLineMutationResponse>>>;
  /** update data of the table: "route.route" */
  update_route_route?: Maybe<RouteRouteMutationResponse>;
  /** update single row of the table: "route.route" */
  update_route_route_by_pk?: Maybe<RouteRoute>;
  /** update multiples rows of table: "route.route" */
  update_route_route_many?: Maybe<Array<Maybe<RouteRouteMutationResponse>>>;
  /** update data of the table: "route.type_of_line" */
  update_route_type_of_line?: Maybe<RouteTypeOfLineMutationResponse>;
  /** update single row of the table: "route.type_of_line" */
  update_route_type_of_line_by_pk?: Maybe<RouteTypeOfLine>;
  /** update multiples rows of table: "route.type_of_line" */
  update_route_type_of_line_many?: Maybe<
    Array<Maybe<RouteTypeOfLineMutationResponse>>
  >;
  /** update data of the table: "service_pattern.distance_between_stops_calculation" */
  update_service_pattern_distance_between_stops_calculation?: Maybe<ServicePatternDistanceBetweenStopsCalculationMutationResponse>;
  /** update single row of the table: "service_pattern.distance_between_stops_calculation" */
  update_service_pattern_distance_between_stops_calculation_by_pk?: Maybe<ServicePatternDistanceBetweenStopsCalculation>;
  /** update multiples rows of table: "service_pattern.distance_between_stops_calculation" */
  update_service_pattern_distance_between_stops_calculation_many?: Maybe<
    Array<Maybe<ServicePatternDistanceBetweenStopsCalculationMutationResponse>>
  >;
  /** update data of the table: "service_pattern.scheduled_stop_point" */
  update_service_pattern_scheduled_stop_point?: Maybe<ServicePatternScheduledStopPointMutationResponse>;
  /** update single row of the table: "service_pattern.scheduled_stop_point" */
  update_service_pattern_scheduled_stop_point_by_pk?: Maybe<ServicePatternScheduledStopPoint>;
  /** update multiples rows of table: "service_pattern.scheduled_stop_point" */
  update_service_pattern_scheduled_stop_point_many?: Maybe<
    Array<Maybe<ServicePatternScheduledStopPointMutationResponse>>
  >;
  /** update data of the table: "service_pattern.vehicle_mode_on_scheduled_stop_point" */
  update_service_pattern_vehicle_mode_on_scheduled_stop_point?: Maybe<ServicePatternVehicleModeOnScheduledStopPointMutationResponse>;
  /** update single row of the table: "service_pattern.vehicle_mode_on_scheduled_stop_point" */
  update_service_pattern_vehicle_mode_on_scheduled_stop_point_by_pk?: Maybe<ServicePatternVehicleModeOnScheduledStopPoint>;
  /** update multiples rows of table: "service_pattern.vehicle_mode_on_scheduled_stop_point" */
  update_service_pattern_vehicle_mode_on_scheduled_stop_point_many?: Maybe<
    Array<Maybe<ServicePatternVehicleModeOnScheduledStopPointMutationResponse>>
  >;
  /** update data of the table: "timing_pattern.timing_place" */
  update_timing_pattern_timing_place?: Maybe<TimingPatternTimingPlaceMutationResponse>;
  /** update single row of the table: "timing_pattern.timing_place" */
  update_timing_pattern_timing_place_by_pk?: Maybe<TimingPatternTimingPlace>;
  /** update multiples rows of table: "timing_pattern.timing_place" */
  update_timing_pattern_timing_place_many?: Maybe<
    Array<Maybe<TimingPatternTimingPlaceMutationResponse>>
  >;
};

/** mutation root */
export type MutationRootCombineTimetablesArgs = {
  arg1: CombineTimetablesInput;
};

/** mutation root */
export type MutationRootDeleteHslRouteLegacyHslMunicipalityCodeArgs = {
  where: HslRouteLegacyHslMunicipalityCodeBoolExp;
};

/** mutation root */
export type MutationRootDeleteHslRouteLegacyHslMunicipalityCodeByPkArgs = {
  hsl_municipality: Scalars['String'];
};

/** mutation root */
export type MutationRootDeleteHslRouteTransportTargetArgs = {
  where: HslRouteTransportTargetBoolExp;
};

/** mutation root */
export type MutationRootDeleteHslRouteTransportTargetByPkArgs = {
  transport_target: Scalars['String'];
};

/** mutation root */
export type MutationRootDeleteInfrastructureNetworkDirectionArgs = {
  where: InfrastructureNetworkDirectionBoolExp;
};

/** mutation root */
export type MutationRootDeleteInfrastructureNetworkDirectionByPkArgs = {
  value: Scalars['String'];
};

/** mutation root */
export type MutationRootDeleteInfrastructureNetworkExternalSourceArgs = {
  where: InfrastructureNetworkExternalSourceBoolExp;
};

/** mutation root */
export type MutationRootDeleteInfrastructureNetworkExternalSourceByPkArgs = {
  value: Scalars['String'];
};

/** mutation root */
export type MutationRootDeleteInfrastructureNetworkInfrastructureLinkArgs = {
  where: InfrastructureNetworkInfrastructureLinkBoolExp;
};

/** mutation root */
export type MutationRootDeleteInfrastructureNetworkInfrastructureLinkByPkArgs =
  {
    infrastructure_link_id: Scalars['uuid'];
  };

/** mutation root */
export type MutationRootDeleteInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkArgs =
  {
    where: InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp;
  };

/** mutation root */
export type MutationRootDeleteInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkByPkArgs =
  {
    infrastructure_link_id: Scalars['uuid'];
    vehicle_submode: ReusableComponentsVehicleSubmodeEnum;
  };

/** mutation root */
export type MutationRootDeleteJourneyPatternJourneyPatternArgs = {
  where: JourneyPatternJourneyPatternBoolExp;
};

/** mutation root */
export type MutationRootDeleteJourneyPatternJourneyPatternByPkArgs = {
  journey_pattern_id: Scalars['uuid'];
};

/** mutation root */
export type MutationRootDeleteJourneyPatternScheduledStopPointInJourneyPatternArgs =
  {
    where: JourneyPatternScheduledStopPointInJourneyPatternBoolExp;
  };

/** mutation root */
export type MutationRootDeleteJourneyPatternScheduledStopPointInJourneyPatternByPkArgs =
  {
    journey_pattern_id: Scalars['uuid'];
    scheduled_stop_point_sequence: Scalars['Int'];
  };

/** mutation root */
export type MutationRootDeleteReusableComponentsVehicleModeArgs = {
  where: ReusableComponentsVehicleModeBoolExp;
};

/** mutation root */
export type MutationRootDeleteReusableComponentsVehicleModeByPkArgs = {
  vehicle_mode: Scalars['String'];
};

/** mutation root */
export type MutationRootDeleteReusableComponentsVehicleSubmodeArgs = {
  where: ReusableComponentsVehicleSubmodeBoolExp;
};

/** mutation root */
export type MutationRootDeleteReusableComponentsVehicleSubmodeByPkArgs = {
  vehicle_submode: Scalars['String'];
};

/** mutation root */
export type MutationRootDeleteRouteDirectionArgs = {
  where: RouteDirectionBoolExp;
};

/** mutation root */
export type MutationRootDeleteRouteDirectionByPkArgs = {
  direction: Scalars['String'];
};

/** mutation root */
export type MutationRootDeleteRouteInfrastructureLinkAlongRouteArgs = {
  where: RouteInfrastructureLinkAlongRouteBoolExp;
};

/** mutation root */
export type MutationRootDeleteRouteInfrastructureLinkAlongRouteByPkArgs = {
  infrastructure_link_sequence: Scalars['Int'];
  route_id: Scalars['uuid'];
};

/** mutation root */
export type MutationRootDeleteRouteLineArgs = {
  where: RouteLineBoolExp;
};

/** mutation root */
export type MutationRootDeleteRouteLineByPkArgs = {
  line_id: Scalars['uuid'];
};

/** mutation root */
export type MutationRootDeleteRouteRouteArgs = {
  where: RouteRouteBoolExp;
};

/** mutation root */
export type MutationRootDeleteRouteRouteByPkArgs = {
  route_id: Scalars['uuid'];
};

/** mutation root */
export type MutationRootDeleteRouteTypeOfLineArgs = {
  where: RouteTypeOfLineBoolExp;
};

/** mutation root */
export type MutationRootDeleteRouteTypeOfLineByPkArgs = {
  type_of_line: Scalars['String'];
};

/** mutation root */
export type MutationRootDeleteServicePatternDistanceBetweenStopsCalculationArgs =
  {
    where: ServicePatternDistanceBetweenStopsCalculationBoolExp;
  };

/** mutation root */
export type MutationRootDeleteServicePatternDistanceBetweenStopsCalculationByPkArgs =
  {
    journey_pattern_id: Scalars['uuid'];
    observation_date: Scalars['date'];
    route_priority: Scalars['Int'];
    stop_interval_sequence: Scalars['Int'];
  };

/** mutation root */
export type MutationRootDeleteServicePatternScheduledStopPointArgs = {
  where: ServicePatternScheduledStopPointBoolExp;
};

/** mutation root */
export type MutationRootDeleteServicePatternScheduledStopPointByPkArgs = {
  scheduled_stop_point_id: Scalars['uuid'];
};

/** mutation root */
export type MutationRootDeleteServicePatternVehicleModeOnScheduledStopPointArgs =
  {
    where: ServicePatternVehicleModeOnScheduledStopPointBoolExp;
  };

/** mutation root */
export type MutationRootDeleteServicePatternVehicleModeOnScheduledStopPointByPkArgs =
  {
    scheduled_stop_point_id: Scalars['uuid'];
    vehicle_mode: ReusableComponentsVehicleModeEnum;
  };

/** mutation root */
export type MutationRootDeleteTimingPatternTimingPlaceArgs = {
  where: TimingPatternTimingPlaceBoolExp;
};

/** mutation root */
export type MutationRootDeleteTimingPatternTimingPlaceByPkArgs = {
  timing_place_id: Scalars['uuid'];
};

/** mutation root */
export type MutationRootInsertHslRouteLegacyHslMunicipalityCodeArgs = {
  objects: Array<HslRouteLegacyHslMunicipalityCodeInsertInput>;
  on_conflict?: InputMaybe<HslRouteLegacyHslMunicipalityCodeOnConflict>;
};

/** mutation root */
export type MutationRootInsertHslRouteLegacyHslMunicipalityCodeOneArgs = {
  object: HslRouteLegacyHslMunicipalityCodeInsertInput;
  on_conflict?: InputMaybe<HslRouteLegacyHslMunicipalityCodeOnConflict>;
};

/** mutation root */
export type MutationRootInsertHslRouteTransportTargetArgs = {
  objects: Array<HslRouteTransportTargetInsertInput>;
  on_conflict?: InputMaybe<HslRouteTransportTargetOnConflict>;
};

/** mutation root */
export type MutationRootInsertHslRouteTransportTargetOneArgs = {
  object: HslRouteTransportTargetInsertInput;
  on_conflict?: InputMaybe<HslRouteTransportTargetOnConflict>;
};

/** mutation root */
export type MutationRootInsertInfrastructureNetworkDirectionArgs = {
  objects: Array<InfrastructureNetworkDirectionInsertInput>;
  on_conflict?: InputMaybe<InfrastructureNetworkDirectionOnConflict>;
};

/** mutation root */
export type MutationRootInsertInfrastructureNetworkDirectionOneArgs = {
  object: InfrastructureNetworkDirectionInsertInput;
  on_conflict?: InputMaybe<InfrastructureNetworkDirectionOnConflict>;
};

/** mutation root */
export type MutationRootInsertInfrastructureNetworkExternalSourceArgs = {
  objects: Array<InfrastructureNetworkExternalSourceInsertInput>;
  on_conflict?: InputMaybe<InfrastructureNetworkExternalSourceOnConflict>;
};

/** mutation root */
export type MutationRootInsertInfrastructureNetworkExternalSourceOneArgs = {
  object: InfrastructureNetworkExternalSourceInsertInput;
  on_conflict?: InputMaybe<InfrastructureNetworkExternalSourceOnConflict>;
};

/** mutation root */
export type MutationRootInsertInfrastructureNetworkInfrastructureLinkArgs = {
  objects: Array<InfrastructureNetworkInfrastructureLinkInsertInput>;
  on_conflict?: InputMaybe<InfrastructureNetworkInfrastructureLinkOnConflict>;
};

/** mutation root */
export type MutationRootInsertInfrastructureNetworkInfrastructureLinkOneArgs = {
  object: InfrastructureNetworkInfrastructureLinkInsertInput;
  on_conflict?: InputMaybe<InfrastructureNetworkInfrastructureLinkOnConflict>;
};

/** mutation root */
export type MutationRootInsertInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkArgs =
  {
    objects: Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkInsertInput>;
    on_conflict?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOnConflict>;
  };

/** mutation root */
export type MutationRootInsertInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOneArgs =
  {
    object: InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkInsertInput;
    on_conflict?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOnConflict>;
  };

/** mutation root */
export type MutationRootInsertJourneyPatternJourneyPatternArgs = {
  objects: Array<JourneyPatternJourneyPatternInsertInput>;
  on_conflict?: InputMaybe<JourneyPatternJourneyPatternOnConflict>;
};

/** mutation root */
export type MutationRootInsertJourneyPatternJourneyPatternOneArgs = {
  object: JourneyPatternJourneyPatternInsertInput;
  on_conflict?: InputMaybe<JourneyPatternJourneyPatternOnConflict>;
};

/** mutation root */
export type MutationRootInsertJourneyPatternScheduledStopPointInJourneyPatternArgs =
  {
    objects: Array<JourneyPatternScheduledStopPointInJourneyPatternInsertInput>;
    on_conflict?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternOnConflict>;
  };

/** mutation root */
export type MutationRootInsertJourneyPatternScheduledStopPointInJourneyPatternOneArgs =
  {
    object: JourneyPatternScheduledStopPointInJourneyPatternInsertInput;
    on_conflict?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternOnConflict>;
  };

/** mutation root */
export type MutationRootInsertReusableComponentsVehicleModeArgs = {
  objects: Array<ReusableComponentsVehicleModeInsertInput>;
  on_conflict?: InputMaybe<ReusableComponentsVehicleModeOnConflict>;
};

/** mutation root */
export type MutationRootInsertReusableComponentsVehicleModeOneArgs = {
  object: ReusableComponentsVehicleModeInsertInput;
  on_conflict?: InputMaybe<ReusableComponentsVehicleModeOnConflict>;
};

/** mutation root */
export type MutationRootInsertReusableComponentsVehicleSubmodeArgs = {
  objects: Array<ReusableComponentsVehicleSubmodeInsertInput>;
  on_conflict?: InputMaybe<ReusableComponentsVehicleSubmodeOnConflict>;
};

/** mutation root */
export type MutationRootInsertReusableComponentsVehicleSubmodeOneArgs = {
  object: ReusableComponentsVehicleSubmodeInsertInput;
  on_conflict?: InputMaybe<ReusableComponentsVehicleSubmodeOnConflict>;
};

/** mutation root */
export type MutationRootInsertRouteDirectionArgs = {
  objects: Array<RouteDirectionInsertInput>;
  on_conflict?: InputMaybe<RouteDirectionOnConflict>;
};

/** mutation root */
export type MutationRootInsertRouteDirectionOneArgs = {
  object: RouteDirectionInsertInput;
  on_conflict?: InputMaybe<RouteDirectionOnConflict>;
};

/** mutation root */
export type MutationRootInsertRouteInfrastructureLinkAlongRouteArgs = {
  objects: Array<RouteInfrastructureLinkAlongRouteInsertInput>;
  on_conflict?: InputMaybe<RouteInfrastructureLinkAlongRouteOnConflict>;
};

/** mutation root */
export type MutationRootInsertRouteInfrastructureLinkAlongRouteOneArgs = {
  object: RouteInfrastructureLinkAlongRouteInsertInput;
  on_conflict?: InputMaybe<RouteInfrastructureLinkAlongRouteOnConflict>;
};

/** mutation root */
export type MutationRootInsertRouteLineArgs = {
  objects: Array<RouteLineInsertInput>;
  on_conflict?: InputMaybe<RouteLineOnConflict>;
};

/** mutation root */
export type MutationRootInsertRouteLineOneArgs = {
  object: RouteLineInsertInput;
  on_conflict?: InputMaybe<RouteLineOnConflict>;
};

/** mutation root */
export type MutationRootInsertRouteRouteArgs = {
  objects: Array<RouteRouteInsertInput>;
  on_conflict?: InputMaybe<RouteRouteOnConflict>;
};

/** mutation root */
export type MutationRootInsertRouteRouteOneArgs = {
  object: RouteRouteInsertInput;
  on_conflict?: InputMaybe<RouteRouteOnConflict>;
};

/** mutation root */
export type MutationRootInsertRouteTypeOfLineArgs = {
  objects: Array<RouteTypeOfLineInsertInput>;
  on_conflict?: InputMaybe<RouteTypeOfLineOnConflict>;
};

/** mutation root */
export type MutationRootInsertRouteTypeOfLineOneArgs = {
  object: RouteTypeOfLineInsertInput;
  on_conflict?: InputMaybe<RouteTypeOfLineOnConflict>;
};

/** mutation root */
export type MutationRootInsertServicePatternDistanceBetweenStopsCalculationArgs =
  {
    objects: Array<ServicePatternDistanceBetweenStopsCalculationInsertInput>;
    on_conflict?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationOnConflict>;
  };

/** mutation root */
export type MutationRootInsertServicePatternDistanceBetweenStopsCalculationOneArgs =
  {
    object: ServicePatternDistanceBetweenStopsCalculationInsertInput;
    on_conflict?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationOnConflict>;
  };

/** mutation root */
export type MutationRootInsertServicePatternScheduledStopPointArgs = {
  objects: Array<ServicePatternScheduledStopPointInsertInput>;
  on_conflict?: InputMaybe<ServicePatternScheduledStopPointOnConflict>;
};

/** mutation root */
export type MutationRootInsertServicePatternScheduledStopPointOneArgs = {
  object: ServicePatternScheduledStopPointInsertInput;
  on_conflict?: InputMaybe<ServicePatternScheduledStopPointOnConflict>;
};

/** mutation root */
export type MutationRootInsertServicePatternVehicleModeOnScheduledStopPointArgs =
  {
    objects: Array<ServicePatternVehicleModeOnScheduledStopPointInsertInput>;
    on_conflict?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointOnConflict>;
  };

/** mutation root */
export type MutationRootInsertServicePatternVehicleModeOnScheduledStopPointOneArgs =
  {
    object: ServicePatternVehicleModeOnScheduledStopPointInsertInput;
    on_conflict?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointOnConflict>;
  };

/** mutation root */
export type MutationRootInsertTimingPatternTimingPlaceArgs = {
  objects: Array<TimingPatternTimingPlaceInsertInput>;
  on_conflict?: InputMaybe<TimingPatternTimingPlaceOnConflict>;
};

/** mutation root */
export type MutationRootInsertTimingPatternTimingPlaceOneArgs = {
  object: TimingPatternTimingPlaceInsertInput;
  on_conflict?: InputMaybe<TimingPatternTimingPlaceOnConflict>;
};

/** mutation root */
export type MutationRootReplaceTimetablesArgs = {
  arg1: ReplaceTimetablesInput;
};

/** mutation root */
export type MutationRootUpdateHslRouteLegacyHslMunicipalityCodeArgs = {
  _inc?: InputMaybe<HslRouteLegacyHslMunicipalityCodeIncInput>;
  _set?: InputMaybe<HslRouteLegacyHslMunicipalityCodeSetInput>;
  where: HslRouteLegacyHslMunicipalityCodeBoolExp;
};

/** mutation root */
export type MutationRootUpdateHslRouteLegacyHslMunicipalityCodeByPkArgs = {
  _inc?: InputMaybe<HslRouteLegacyHslMunicipalityCodeIncInput>;
  _set?: InputMaybe<HslRouteLegacyHslMunicipalityCodeSetInput>;
  pk_columns: HslRouteLegacyHslMunicipalityCodePkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateHslRouteLegacyHslMunicipalityCodeManyArgs = {
  updates: Array<HslRouteLegacyHslMunicipalityCodeUpdates>;
};

/** mutation root */
export type MutationRootUpdateHslRouteTransportTargetArgs = {
  _set?: InputMaybe<HslRouteTransportTargetSetInput>;
  where: HslRouteTransportTargetBoolExp;
};

/** mutation root */
export type MutationRootUpdateHslRouteTransportTargetByPkArgs = {
  _set?: InputMaybe<HslRouteTransportTargetSetInput>;
  pk_columns: HslRouteTransportTargetPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateHslRouteTransportTargetManyArgs = {
  updates: Array<HslRouteTransportTargetUpdates>;
};

/** mutation root */
export type MutationRootUpdateInfrastructureNetworkDirectionArgs = {
  _set?: InputMaybe<InfrastructureNetworkDirectionSetInput>;
  where: InfrastructureNetworkDirectionBoolExp;
};

/** mutation root */
export type MutationRootUpdateInfrastructureNetworkDirectionByPkArgs = {
  _set?: InputMaybe<InfrastructureNetworkDirectionSetInput>;
  pk_columns: InfrastructureNetworkDirectionPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateInfrastructureNetworkDirectionManyArgs = {
  updates: Array<InfrastructureNetworkDirectionUpdates>;
};

/** mutation root */
export type MutationRootUpdateInfrastructureNetworkExternalSourceArgs = {
  _set?: InputMaybe<InfrastructureNetworkExternalSourceSetInput>;
  where: InfrastructureNetworkExternalSourceBoolExp;
};

/** mutation root */
export type MutationRootUpdateInfrastructureNetworkExternalSourceByPkArgs = {
  _set?: InputMaybe<InfrastructureNetworkExternalSourceSetInput>;
  pk_columns: InfrastructureNetworkExternalSourcePkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateInfrastructureNetworkExternalSourceManyArgs = {
  updates: Array<InfrastructureNetworkExternalSourceUpdates>;
};

/** mutation root */
export type MutationRootUpdateInfrastructureNetworkInfrastructureLinkArgs = {
  _inc?: InputMaybe<InfrastructureNetworkInfrastructureLinkIncInput>;
  _set?: InputMaybe<InfrastructureNetworkInfrastructureLinkSetInput>;
  where: InfrastructureNetworkInfrastructureLinkBoolExp;
};

/** mutation root */
export type MutationRootUpdateInfrastructureNetworkInfrastructureLinkByPkArgs =
  {
    _inc?: InputMaybe<InfrastructureNetworkInfrastructureLinkIncInput>;
    _set?: InputMaybe<InfrastructureNetworkInfrastructureLinkSetInput>;
    pk_columns: InfrastructureNetworkInfrastructureLinkPkColumnsInput;
  };

/** mutation root */
export type MutationRootUpdateInfrastructureNetworkInfrastructureLinkManyArgs =
  {
    updates: Array<InfrastructureNetworkInfrastructureLinkUpdates>;
  };

/** mutation root */
export type MutationRootUpdateInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkArgs =
  {
    _set?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSetInput>;
    where: InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp;
  };

/** mutation root */
export type MutationRootUpdateInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkByPkArgs =
  {
    _set?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSetInput>;
    pk_columns: InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkPkColumnsInput;
  };

/** mutation root */
export type MutationRootUpdateInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkManyArgs =
  {
    updates: Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkUpdates>;
  };

/** mutation root */
export type MutationRootUpdateJourneyPatternJourneyPatternArgs = {
  _set?: InputMaybe<JourneyPatternJourneyPatternSetInput>;
  where: JourneyPatternJourneyPatternBoolExp;
};

/** mutation root */
export type MutationRootUpdateJourneyPatternJourneyPatternByPkArgs = {
  _set?: InputMaybe<JourneyPatternJourneyPatternSetInput>;
  pk_columns: JourneyPatternJourneyPatternPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateJourneyPatternJourneyPatternManyArgs = {
  updates: Array<JourneyPatternJourneyPatternUpdates>;
};

/** mutation root */
export type MutationRootUpdateJourneyPatternScheduledStopPointInJourneyPatternArgs =
  {
    _append?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternAppendInput>;
    _delete_at_path?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternDeleteAtPathInput>;
    _delete_elem?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternDeleteElemInput>;
    _delete_key?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternDeleteKeyInput>;
    _inc?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternIncInput>;
    _prepend?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternPrependInput>;
    _set?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternSetInput>;
    where: JourneyPatternScheduledStopPointInJourneyPatternBoolExp;
  };

/** mutation root */
export type MutationRootUpdateJourneyPatternScheduledStopPointInJourneyPatternByPkArgs =
  {
    _append?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternAppendInput>;
    _delete_at_path?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternDeleteAtPathInput>;
    _delete_elem?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternDeleteElemInput>;
    _delete_key?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternDeleteKeyInput>;
    _inc?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternIncInput>;
    _prepend?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternPrependInput>;
    _set?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternSetInput>;
    pk_columns: JourneyPatternScheduledStopPointInJourneyPatternPkColumnsInput;
  };

/** mutation root */
export type MutationRootUpdateJourneyPatternScheduledStopPointInJourneyPatternManyArgs =
  {
    updates: Array<JourneyPatternScheduledStopPointInJourneyPatternUpdates>;
  };

/** mutation root */
export type MutationRootUpdateReusableComponentsVehicleModeArgs = {
  _set?: InputMaybe<ReusableComponentsVehicleModeSetInput>;
  where: ReusableComponentsVehicleModeBoolExp;
};

/** mutation root */
export type MutationRootUpdateReusableComponentsVehicleModeByPkArgs = {
  _set?: InputMaybe<ReusableComponentsVehicleModeSetInput>;
  pk_columns: ReusableComponentsVehicleModePkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateReusableComponentsVehicleModeManyArgs = {
  updates: Array<ReusableComponentsVehicleModeUpdates>;
};

/** mutation root */
export type MutationRootUpdateReusableComponentsVehicleSubmodeArgs = {
  _set?: InputMaybe<ReusableComponentsVehicleSubmodeSetInput>;
  where: ReusableComponentsVehicleSubmodeBoolExp;
};

/** mutation root */
export type MutationRootUpdateReusableComponentsVehicleSubmodeByPkArgs = {
  _set?: InputMaybe<ReusableComponentsVehicleSubmodeSetInput>;
  pk_columns: ReusableComponentsVehicleSubmodePkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateReusableComponentsVehicleSubmodeManyArgs = {
  updates: Array<ReusableComponentsVehicleSubmodeUpdates>;
};

/** mutation root */
export type MutationRootUpdateRouteDirectionArgs = {
  _set?: InputMaybe<RouteDirectionSetInput>;
  where: RouteDirectionBoolExp;
};

/** mutation root */
export type MutationRootUpdateRouteDirectionByPkArgs = {
  _set?: InputMaybe<RouteDirectionSetInput>;
  pk_columns: RouteDirectionPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateRouteDirectionManyArgs = {
  updates: Array<RouteDirectionUpdates>;
};

/** mutation root */
export type MutationRootUpdateRouteInfrastructureLinkAlongRouteArgs = {
  _inc?: InputMaybe<RouteInfrastructureLinkAlongRouteIncInput>;
  _set?: InputMaybe<RouteInfrastructureLinkAlongRouteSetInput>;
  where: RouteInfrastructureLinkAlongRouteBoolExp;
};

/** mutation root */
export type MutationRootUpdateRouteInfrastructureLinkAlongRouteByPkArgs = {
  _inc?: InputMaybe<RouteInfrastructureLinkAlongRouteIncInput>;
  _set?: InputMaybe<RouteInfrastructureLinkAlongRouteSetInput>;
  pk_columns: RouteInfrastructureLinkAlongRoutePkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateRouteInfrastructureLinkAlongRouteManyArgs = {
  updates: Array<RouteInfrastructureLinkAlongRouteUpdates>;
};

/** mutation root */
export type MutationRootUpdateRouteLineArgs = {
  _append?: InputMaybe<RouteLineAppendInput>;
  _delete_at_path?: InputMaybe<RouteLineDeleteAtPathInput>;
  _delete_elem?: InputMaybe<RouteLineDeleteElemInput>;
  _delete_key?: InputMaybe<RouteLineDeleteKeyInput>;
  _inc?: InputMaybe<RouteLineIncInput>;
  _prepend?: InputMaybe<RouteLinePrependInput>;
  _set?: InputMaybe<RouteLineSetInput>;
  where: RouteLineBoolExp;
};

/** mutation root */
export type MutationRootUpdateRouteLineByPkArgs = {
  _append?: InputMaybe<RouteLineAppendInput>;
  _delete_at_path?: InputMaybe<RouteLineDeleteAtPathInput>;
  _delete_elem?: InputMaybe<RouteLineDeleteElemInput>;
  _delete_key?: InputMaybe<RouteLineDeleteKeyInput>;
  _inc?: InputMaybe<RouteLineIncInput>;
  _prepend?: InputMaybe<RouteLinePrependInput>;
  _set?: InputMaybe<RouteLineSetInput>;
  pk_columns: RouteLinePkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateRouteLineManyArgs = {
  updates: Array<RouteLineUpdates>;
};

/** mutation root */
export type MutationRootUpdateRouteRouteArgs = {
  _append?: InputMaybe<RouteRouteAppendInput>;
  _delete_at_path?: InputMaybe<RouteRouteDeleteAtPathInput>;
  _delete_elem?: InputMaybe<RouteRouteDeleteElemInput>;
  _delete_key?: InputMaybe<RouteRouteDeleteKeyInput>;
  _inc?: InputMaybe<RouteRouteIncInput>;
  _prepend?: InputMaybe<RouteRoutePrependInput>;
  _set?: InputMaybe<RouteRouteSetInput>;
  where: RouteRouteBoolExp;
};

/** mutation root */
export type MutationRootUpdateRouteRouteByPkArgs = {
  _append?: InputMaybe<RouteRouteAppendInput>;
  _delete_at_path?: InputMaybe<RouteRouteDeleteAtPathInput>;
  _delete_elem?: InputMaybe<RouteRouteDeleteElemInput>;
  _delete_key?: InputMaybe<RouteRouteDeleteKeyInput>;
  _inc?: InputMaybe<RouteRouteIncInput>;
  _prepend?: InputMaybe<RouteRoutePrependInput>;
  _set?: InputMaybe<RouteRouteSetInput>;
  pk_columns: RouteRoutePkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateRouteRouteManyArgs = {
  updates: Array<RouteRouteUpdates>;
};

/** mutation root */
export type MutationRootUpdateRouteTypeOfLineArgs = {
  _set?: InputMaybe<RouteTypeOfLineSetInput>;
  where: RouteTypeOfLineBoolExp;
};

/** mutation root */
export type MutationRootUpdateRouteTypeOfLineByPkArgs = {
  _set?: InputMaybe<RouteTypeOfLineSetInput>;
  pk_columns: RouteTypeOfLinePkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateRouteTypeOfLineManyArgs = {
  updates: Array<RouteTypeOfLineUpdates>;
};

/** mutation root */
export type MutationRootUpdateServicePatternDistanceBetweenStopsCalculationArgs =
  {
    _inc?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationIncInput>;
    _set?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationSetInput>;
    where: ServicePatternDistanceBetweenStopsCalculationBoolExp;
  };

/** mutation root */
export type MutationRootUpdateServicePatternDistanceBetweenStopsCalculationByPkArgs =
  {
    _inc?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationIncInput>;
    _set?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationSetInput>;
    pk_columns: ServicePatternDistanceBetweenStopsCalculationPkColumnsInput;
  };

/** mutation root */
export type MutationRootUpdateServicePatternDistanceBetweenStopsCalculationManyArgs =
  {
    updates: Array<ServicePatternDistanceBetweenStopsCalculationUpdates>;
  };

/** mutation root */
export type MutationRootUpdateServicePatternScheduledStopPointArgs = {
  _inc?: InputMaybe<ServicePatternScheduledStopPointIncInput>;
  _set?: InputMaybe<ServicePatternScheduledStopPointSetInput>;
  where: ServicePatternScheduledStopPointBoolExp;
};

/** mutation root */
export type MutationRootUpdateServicePatternScheduledStopPointByPkArgs = {
  _inc?: InputMaybe<ServicePatternScheduledStopPointIncInput>;
  _set?: InputMaybe<ServicePatternScheduledStopPointSetInput>;
  pk_columns: ServicePatternScheduledStopPointPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateServicePatternScheduledStopPointManyArgs = {
  updates: Array<ServicePatternScheduledStopPointUpdates>;
};

/** mutation root */
export type MutationRootUpdateServicePatternVehicleModeOnScheduledStopPointArgs =
  {
    _set?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointSetInput>;
    where: ServicePatternVehicleModeOnScheduledStopPointBoolExp;
  };

/** mutation root */
export type MutationRootUpdateServicePatternVehicleModeOnScheduledStopPointByPkArgs =
  {
    _set?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointSetInput>;
    pk_columns: ServicePatternVehicleModeOnScheduledStopPointPkColumnsInput;
  };

/** mutation root */
export type MutationRootUpdateServicePatternVehicleModeOnScheduledStopPointManyArgs =
  {
    updates: Array<ServicePatternVehicleModeOnScheduledStopPointUpdates>;
  };

/** mutation root */
export type MutationRootUpdateTimingPatternTimingPlaceArgs = {
  _append?: InputMaybe<TimingPatternTimingPlaceAppendInput>;
  _delete_at_path?: InputMaybe<TimingPatternTimingPlaceDeleteAtPathInput>;
  _delete_elem?: InputMaybe<TimingPatternTimingPlaceDeleteElemInput>;
  _delete_key?: InputMaybe<TimingPatternTimingPlaceDeleteKeyInput>;
  _prepend?: InputMaybe<TimingPatternTimingPlacePrependInput>;
  _set?: InputMaybe<TimingPatternTimingPlaceSetInput>;
  where: TimingPatternTimingPlaceBoolExp;
};

/** mutation root */
export type MutationRootUpdateTimingPatternTimingPlaceByPkArgs = {
  _append?: InputMaybe<TimingPatternTimingPlaceAppendInput>;
  _delete_at_path?: InputMaybe<TimingPatternTimingPlaceDeleteAtPathInput>;
  _delete_elem?: InputMaybe<TimingPatternTimingPlaceDeleteElemInput>;
  _delete_key?: InputMaybe<TimingPatternTimingPlaceDeleteKeyInput>;
  _prepend?: InputMaybe<TimingPatternTimingPlacePrependInput>;
  _set?: InputMaybe<TimingPatternTimingPlaceSetInput>;
  pk_columns: TimingPatternTimingPlacePkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateTimingPatternTimingPlaceManyArgs = {
  updates: Array<TimingPatternTimingPlaceUpdates>;
};

/** Boolean expression to compare columns of type "name". All fields are combined with logical 'AND'. */
export type NameComparisonExp = {
  _eq?: InputMaybe<Scalars['name']>;
  _gt?: InputMaybe<Scalars['name']>;
  _gte?: InputMaybe<Scalars['name']>;
  _in?: InputMaybe<Array<Scalars['name']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['name']>;
  _lte?: InputMaybe<Scalars['name']>;
  _neq?: InputMaybe<Scalars['name']>;
  _nin?: InputMaybe<Array<Scalars['name']>>;
};

/** Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'. */
export type NumericComparisonExp = {
  _eq?: InputMaybe<Scalars['numeric']>;
  _gt?: InputMaybe<Scalars['numeric']>;
  _gte?: InputMaybe<Scalars['numeric']>;
  _in?: InputMaybe<Array<Scalars['numeric']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['numeric']>;
  _lte?: InputMaybe<Scalars['numeric']>;
  _neq?: InputMaybe<Scalars['numeric']>;
  _nin?: InputMaybe<Array<Scalars['numeric']>>;
};

/** column ordering options */
export enum OrderBy {
  /** in ascending order, nulls last */
  Asc = 'asc',
  /** in ascending order, nulls first */
  AscNullsFirst = 'asc_nulls_first',
  /** in ascending order, nulls last */
  AscNullsLast = 'asc_nulls_last',
  /** in descending order, nulls first */
  Desc = 'desc',
  /** in descending order, nulls first */
  DescNullsFirst = 'desc_nulls_first',
  /** in descending order, nulls last */
  DescNullsLast = 'desc_nulls_last',
}

export type ParkingAlternativeNamesAggregateBoolExp = {
  count?: InputMaybe<ParkingAlternativeNamesAggregateBoolExpCount>;
};

export type ParkingAlternativeNamesAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<StopsDatabaseParkingAlternativeNamesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseParkingAlternativeNamesBoolExp>;
  predicate: IntComparisonExp;
};

export type ParkingAreaAlternativeNamesAggregateBoolExp = {
  count?: InputMaybe<ParkingAreaAlternativeNamesAggregateBoolExpCount>;
};

export type ParkingAreaAlternativeNamesAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<StopsDatabaseParkingAreaAlternativeNamesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesBoolExp>;
  predicate: IntComparisonExp;
};

export type ParkingAreaEquipmentPlacesAggregateBoolExp = {
  count?: InputMaybe<ParkingAreaEquipmentPlacesAggregateBoolExpCount>;
};

export type ParkingAreaEquipmentPlacesAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<StopsDatabaseParkingAreaEquipmentPlacesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>;
  predicate: IntComparisonExp;
};

export type ParkingAreaKeyValuesAggregateBoolExp = {
  count?: InputMaybe<ParkingAreaKeyValuesAggregateBoolExpCount>;
};

export type ParkingAreaKeyValuesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<StopsDatabaseParkingAreaKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseParkingAreaKeyValuesBoolExp>;
  predicate: IntComparisonExp;
};

export type ParkingEquipmentPlacesAggregateBoolExp = {
  count?: InputMaybe<ParkingEquipmentPlacesAggregateBoolExpCount>;
};

export type ParkingEquipmentPlacesAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<StopsDatabaseParkingEquipmentPlacesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseParkingEquipmentPlacesBoolExp>;
  predicate: IntComparisonExp;
};

export type ParkingKeyValuesAggregateBoolExp = {
  count?: InputMaybe<ParkingKeyValuesAggregateBoolExpCount>;
};

export type ParkingKeyValuesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<StopsDatabaseParkingKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseParkingKeyValuesBoolExp>;
  predicate: IntComparisonExp;
};

export type ParkingParkingAreasAggregateBoolExp = {
  count?: InputMaybe<ParkingParkingAreasAggregateBoolExpCount>;
};

export type ParkingParkingAreasAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<StopsDatabaseParkingParkingAreasSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseParkingParkingAreasBoolExp>;
  predicate: IntComparisonExp;
};

export type ParkingParkingPaymentProcessAggregateBoolExp = {
  count?: InputMaybe<ParkingParkingPaymentProcessAggregateBoolExpCount>;
};

export type ParkingParkingPaymentProcessAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<StopsDatabaseParkingParkingPaymentProcessSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessBoolExp>;
  predicate: IntComparisonExp;
};

export type ParkingParkingPropertiesAggregateBoolExp = {
  count?: InputMaybe<ParkingParkingPropertiesAggregateBoolExpCount>;
};

export type ParkingParkingPropertiesAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<StopsDatabaseParkingParkingPropertiesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseParkingParkingPropertiesBoolExp>;
  predicate: IntComparisonExp;
};

export type ParkingParkingVehicleTypesAggregateBoolExp = {
  count?: InputMaybe<ParkingParkingVehicleTypesAggregateBoolExpCount>;
};

export type ParkingParkingVehicleTypesAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<StopsDatabaseParkingParkingVehicleTypesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesBoolExp>;
  predicate: IntComparisonExp;
};

export type PassingTimesTimetabledPassingTimeAggregateBoolExp = {
  count?: InputMaybe<PassingTimesTimetabledPassingTimeAggregateBoolExpCount>;
};

export type PassingTimesTimetabledPassingTimeAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<TimetablesPassingTimesTimetabledPassingTimeSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
  predicate: IntComparisonExp;
};

export type QuayAlternativeNamesAggregateBoolExp = {
  count?: InputMaybe<QuayAlternativeNamesAggregateBoolExpCount>;
};

export type QuayAlternativeNamesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<StopsDatabaseQuayAlternativeNamesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseQuayAlternativeNamesBoolExp>;
  predicate: IntComparisonExp;
};

export type QuayBoardingPositionsAggregateBoolExp = {
  count?: InputMaybe<QuayBoardingPositionsAggregateBoolExpCount>;
};

export type QuayBoardingPositionsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<StopsDatabaseQuayBoardingPositionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseQuayBoardingPositionsBoolExp>;
  predicate: IntComparisonExp;
};

export type QuayEquipmentPlacesAggregateBoolExp = {
  count?: InputMaybe<QuayEquipmentPlacesAggregateBoolExpCount>;
};

export type QuayEquipmentPlacesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<StopsDatabaseQuayEquipmentPlacesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseQuayEquipmentPlacesBoolExp>;
  predicate: IntComparisonExp;
};

export type QuayKeyValuesAggregateBoolExp = {
  count?: InputMaybe<QuayKeyValuesAggregateBoolExpCount>;
};

export type QuayKeyValuesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<StopsDatabaseQuayKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseQuayKeyValuesBoolExp>;
  predicate: IntComparisonExp;
};

export type QueryRoot = {
  __typename?: 'query_root';
  /** fetch data from the table: "hsl_route.legacy_hsl_municipality_code" */
  hsl_route_legacy_hsl_municipality_code: Array<HslRouteLegacyHslMunicipalityCode>;
  /** fetch aggregated fields from the table: "hsl_route.legacy_hsl_municipality_code" */
  hsl_route_legacy_hsl_municipality_code_aggregate: HslRouteLegacyHslMunicipalityCodeAggregate;
  /** fetch data from the table: "hsl_route.legacy_hsl_municipality_code" using primary key columns */
  hsl_route_legacy_hsl_municipality_code_by_pk?: Maybe<HslRouteLegacyHslMunicipalityCode>;
  /** fetch data from the table: "hsl_route.transport_target" */
  hsl_route_transport_target: Array<HslRouteTransportTarget>;
  /** fetch aggregated fields from the table: "hsl_route.transport_target" */
  hsl_route_transport_target_aggregate: HslRouteTransportTargetAggregate;
  /** fetch data from the table: "hsl_route.transport_target" using primary key columns */
  hsl_route_transport_target_by_pk?: Maybe<HslRouteTransportTarget>;
  /** fetch data from the table: "infrastructure_network.direction" */
  infrastructure_network_direction: Array<InfrastructureNetworkDirection>;
  /** fetch aggregated fields from the table: "infrastructure_network.direction" */
  infrastructure_network_direction_aggregate: InfrastructureNetworkDirectionAggregate;
  /** fetch data from the table: "infrastructure_network.direction" using primary key columns */
  infrastructure_network_direction_by_pk?: Maybe<InfrastructureNetworkDirection>;
  /** fetch data from the table: "infrastructure_network.external_source" */
  infrastructure_network_external_source: Array<InfrastructureNetworkExternalSource>;
  /** fetch aggregated fields from the table: "infrastructure_network.external_source" */
  infrastructure_network_external_source_aggregate: InfrastructureNetworkExternalSourceAggregate;
  /** fetch data from the table: "infrastructure_network.external_source" using primary key columns */
  infrastructure_network_external_source_by_pk?: Maybe<InfrastructureNetworkExternalSource>;
  /** execute function "infrastructure_network.find_point_direction_on_link" which returns "infrastructure_network.direction" */
  infrastructure_network_find_point_direction_on_link: Array<InfrastructureNetworkDirection>;
  /** execute function "infrastructure_network.find_point_direction_on_link" and query aggregates on result of table type "infrastructure_network.direction" */
  infrastructure_network_find_point_direction_on_link_aggregate: InfrastructureNetworkDirectionAggregate;
  /** fetch data from the table: "infrastructure_network.infrastructure_link" */
  infrastructure_network_infrastructure_link: Array<InfrastructureNetworkInfrastructureLink>;
  /** fetch aggregated fields from the table: "infrastructure_network.infrastructure_link" */
  infrastructure_network_infrastructure_link_aggregate: InfrastructureNetworkInfrastructureLinkAggregate;
  /** fetch data from the table: "infrastructure_network.infrastructure_link" using primary key columns */
  infrastructure_network_infrastructure_link_by_pk?: Maybe<InfrastructureNetworkInfrastructureLink>;
  /** execute function "infrastructure_network.resolve_point_to_closest_link" which returns "infrastructure_network.infrastructure_link" */
  infrastructure_network_resolve_point_to_closest_link: Array<InfrastructureNetworkInfrastructureLink>;
  /** execute function "infrastructure_network.resolve_point_to_closest_link" and query aggregates on result of table type "infrastructure_network.infrastructure_link" */
  infrastructure_network_resolve_point_to_closest_link_aggregate: InfrastructureNetworkInfrastructureLinkAggregate;
  /** fetch data from the table: "infrastructure_network.vehicle_submode_on_infrastructure_link" */
  infrastructure_network_vehicle_submode_on_infrastructure_link: Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
  /** fetch aggregated fields from the table: "infrastructure_network.vehicle_submode_on_infrastructure_link" */
  infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate: InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregate;
  /** fetch data from the table: "infrastructure_network.vehicle_submode_on_infrastructure_link" using primary key columns */
  infrastructure_network_vehicle_submode_on_infrastructure_link_by_pk?: Maybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
  /** execute function "journey_pattern.check_infra_link_stop_refs_with_new_scheduled_stop_point" which returns "journey_pattern.journey_pattern" */
  journey_pattern_check_infra_link_stop_refs_with_new_scheduled_stop_point: Array<JourneyPatternJourneyPattern>;
  /** execute function "journey_pattern.check_infra_link_stop_refs_with_new_scheduled_stop_point" and query aggregates on result of table type "journey_pattern.journey_pattern" */
  journey_pattern_check_infra_link_stop_refs_with_new_scheduled_stop_point_aggregate: JourneyPatternJourneyPatternAggregate;
  /** fetch data from the table: "journey_pattern.journey_pattern" */
  journey_pattern_journey_pattern: Array<JourneyPatternJourneyPattern>;
  /** fetch aggregated fields from the table: "journey_pattern.journey_pattern" */
  journey_pattern_journey_pattern_aggregate: JourneyPatternJourneyPatternAggregate;
  /** fetch data from the table: "journey_pattern.journey_pattern" using primary key columns */
  journey_pattern_journey_pattern_by_pk?: Maybe<JourneyPatternJourneyPattern>;
  /** fetch data from the table: "journey_pattern.scheduled_stop_point_in_journey_pattern" */
  journey_pattern_scheduled_stop_point_in_journey_pattern: Array<JourneyPatternScheduledStopPointInJourneyPattern>;
  /** fetch aggregated fields from the table: "journey_pattern.scheduled_stop_point_in_journey_pattern" */
  journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate: JourneyPatternScheduledStopPointInJourneyPatternAggregate;
  /** fetch data from the table: "journey_pattern.scheduled_stop_point_in_journey_pattern" using primary key columns */
  journey_pattern_scheduled_stop_point_in_journey_pattern_by_pk?: Maybe<JourneyPatternScheduledStopPointInJourneyPattern>;
  /** fetch data from the table: "reusable_components.vehicle_mode" */
  reusable_components_vehicle_mode: Array<ReusableComponentsVehicleMode>;
  /** fetch aggregated fields from the table: "reusable_components.vehicle_mode" */
  reusable_components_vehicle_mode_aggregate: ReusableComponentsVehicleModeAggregate;
  /** fetch data from the table: "reusable_components.vehicle_mode" using primary key columns */
  reusable_components_vehicle_mode_by_pk?: Maybe<ReusableComponentsVehicleMode>;
  /** fetch data from the table: "reusable_components.vehicle_submode" */
  reusable_components_vehicle_submode: Array<ReusableComponentsVehicleSubmode>;
  /** fetch aggregated fields from the table: "reusable_components.vehicle_submode" */
  reusable_components_vehicle_submode_aggregate: ReusableComponentsVehicleSubmodeAggregate;
  /** fetch data from the table: "reusable_components.vehicle_submode" using primary key columns */
  reusable_components_vehicle_submode_by_pk?: Maybe<ReusableComponentsVehicleSubmode>;
  /** fetch data from the table: "route.direction" */
  route_direction: Array<RouteDirection>;
  /** fetch aggregated fields from the table: "route.direction" */
  route_direction_aggregate: RouteDirectionAggregate;
  /** fetch data from the table: "route.direction" using primary key columns */
  route_direction_by_pk?: Maybe<RouteDirection>;
  /** fetch data from the table: "route.infrastructure_link_along_route" */
  route_infrastructure_link_along_route: Array<RouteInfrastructureLinkAlongRoute>;
  /** fetch aggregated fields from the table: "route.infrastructure_link_along_route" */
  route_infrastructure_link_along_route_aggregate: RouteInfrastructureLinkAlongRouteAggregate;
  /** fetch data from the table: "route.infrastructure_link_along_route" using primary key columns */
  route_infrastructure_link_along_route_by_pk?: Maybe<RouteInfrastructureLinkAlongRoute>;
  /** fetch data from the table: "route.line" */
  route_line: Array<RouteLine>;
  /** fetch aggregated fields from the table: "route.line" */
  route_line_aggregate: RouteLineAggregate;
  /** fetch data from the table: "route.line" using primary key columns */
  route_line_by_pk?: Maybe<RouteLine>;
  /** fetch data from the table: "route.route" */
  route_route: Array<RouteRoute>;
  /** fetch aggregated fields from the table: "route.route" */
  route_route_aggregate: RouteRouteAggregate;
  /** fetch data from the table: "route.route" using primary key columns */
  route_route_by_pk?: Maybe<RouteRoute>;
  /** fetch data from the table: "route.type_of_line" */
  route_type_of_line: Array<RouteTypeOfLine>;
  /** fetch aggregated fields from the table: "route.type_of_line" */
  route_type_of_line_aggregate: RouteTypeOfLineAggregate;
  /** fetch data from the table: "route.type_of_line" using primary key columns */
  route_type_of_line_by_pk?: Maybe<RouteTypeOfLine>;
  /** fetch data from the table: "service_pattern.distance_between_stops_calculation" */
  service_pattern_distance_between_stops_calculation: Array<ServicePatternDistanceBetweenStopsCalculation>;
  /** fetch aggregated fields from the table: "service_pattern.distance_between_stops_calculation" */
  service_pattern_distance_between_stops_calculation_aggregate: ServicePatternDistanceBetweenStopsCalculationAggregate;
  /** fetch data from the table: "service_pattern.distance_between_stops_calculation" using primary key columns */
  service_pattern_distance_between_stops_calculation_by_pk?: Maybe<ServicePatternDistanceBetweenStopsCalculation>;
  /** execute function "service_pattern.get_distances_between_stop_points_by_routes" which returns "service_pattern.distance_between_stops_calculation" */
  service_pattern_get_distances_between_stop_points_by_routes: Array<ServicePatternDistanceBetweenStopsCalculation>;
  /** execute function "service_pattern.get_distances_between_stop_points_by_routes" and query aggregates on result of table type "service_pattern.distance_between_stops_calculation" */
  service_pattern_get_distances_between_stop_points_by_routes_aggregate: ServicePatternDistanceBetweenStopsCalculationAggregate;
  /** execute function "service_pattern.get_distances_between_stop_points_in_journey_patterns" which returns "service_pattern.distance_between_stops_calculation" */
  service_pattern_get_distances_between_stop_points_in_journey_patterns: Array<ServicePatternDistanceBetweenStopsCalculation>;
  /** execute function "service_pattern.get_distances_between_stop_points_in_journey_patterns" and query aggregates on result of table type "service_pattern.distance_between_stops_calculation" */
  service_pattern_get_distances_between_stop_points_in_journey_patterns_aggregate: ServicePatternDistanceBetweenStopsCalculationAggregate;
  /** fetch data from the table: "service_pattern.scheduled_stop_point" */
  service_pattern_scheduled_stop_point: Array<ServicePatternScheduledStopPoint>;
  /** fetch aggregated fields from the table: "service_pattern.scheduled_stop_point" */
  service_pattern_scheduled_stop_point_aggregate: ServicePatternScheduledStopPointAggregate;
  /** fetch data from the table: "service_pattern.scheduled_stop_point" using primary key columns */
  service_pattern_scheduled_stop_point_by_pk?: Maybe<ServicePatternScheduledStopPoint>;
  /** fetch data from the table: "service_pattern.vehicle_mode_on_scheduled_stop_point" */
  service_pattern_vehicle_mode_on_scheduled_stop_point: Array<ServicePatternVehicleModeOnScheduledStopPoint>;
  /** fetch aggregated fields from the table: "service_pattern.vehicle_mode_on_scheduled_stop_point" */
  service_pattern_vehicle_mode_on_scheduled_stop_point_aggregate: ServicePatternVehicleModeOnScheduledStopPointAggregate;
  /** fetch data from the table: "service_pattern.vehicle_mode_on_scheduled_stop_point" using primary key columns */
  service_pattern_vehicle_mode_on_scheduled_stop_point_by_pk?: Maybe<ServicePatternVehicleModeOnScheduledStopPoint>;
  stop_registry?: Maybe<StopRegistryStopPlaceRegister>;
  stops_database?: Maybe<StopsDatabaseStopsDatabaseQuery>;
  timetables?: Maybe<TimetablesTimetablesQuery>;
  /** fetch data from the table: "timing_pattern.timing_place" */
  timing_pattern_timing_place: Array<TimingPatternTimingPlace>;
  /** fetch aggregated fields from the table: "timing_pattern.timing_place" */
  timing_pattern_timing_place_aggregate: TimingPatternTimingPlaceAggregate;
  /** fetch data from the table: "timing_pattern.timing_place" using primary key columns */
  timing_pattern_timing_place_by_pk?: Maybe<TimingPatternTimingPlace>;
  toCombineTargetVehicleScheduleFrameId?: Maybe<ToCombineTargetVehicleScheduleFrameIdOutput>;
  toReplaceVehicleScheduleFrameIds?: Maybe<ToReplaceVehicleScheduleFrameIdsOutput>;
};

export type QueryRootHslRouteLegacyHslMunicipalityCodeArgs = {
  distinct_on?: InputMaybe<
    Array<HslRouteLegacyHslMunicipalityCodeSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<HslRouteLegacyHslMunicipalityCodeOrderBy>>;
  where?: InputMaybe<HslRouteLegacyHslMunicipalityCodeBoolExp>;
};

export type QueryRootHslRouteLegacyHslMunicipalityCodeAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<HslRouteLegacyHslMunicipalityCodeSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<HslRouteLegacyHslMunicipalityCodeOrderBy>>;
  where?: InputMaybe<HslRouteLegacyHslMunicipalityCodeBoolExp>;
};

export type QueryRootHslRouteLegacyHslMunicipalityCodeByPkArgs = {
  hsl_municipality: Scalars['String'];
};

export type QueryRootHslRouteTransportTargetArgs = {
  distinct_on?: InputMaybe<Array<HslRouteTransportTargetSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<HslRouteTransportTargetOrderBy>>;
  where?: InputMaybe<HslRouteTransportTargetBoolExp>;
};

export type QueryRootHslRouteTransportTargetAggregateArgs = {
  distinct_on?: InputMaybe<Array<HslRouteTransportTargetSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<HslRouteTransportTargetOrderBy>>;
  where?: InputMaybe<HslRouteTransportTargetBoolExp>;
};

export type QueryRootHslRouteTransportTargetByPkArgs = {
  transport_target: Scalars['String'];
};

export type QueryRootInfrastructureNetworkDirectionArgs = {
  distinct_on?: InputMaybe<Array<InfrastructureNetworkDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<InfrastructureNetworkDirectionOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkDirectionBoolExp>;
};

export type QueryRootInfrastructureNetworkDirectionAggregateArgs = {
  distinct_on?: InputMaybe<Array<InfrastructureNetworkDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<InfrastructureNetworkDirectionOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkDirectionBoolExp>;
};

export type QueryRootInfrastructureNetworkDirectionByPkArgs = {
  value: Scalars['String'];
};

export type QueryRootInfrastructureNetworkExternalSourceArgs = {
  distinct_on?: InputMaybe<
    Array<InfrastructureNetworkExternalSourceSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<InfrastructureNetworkExternalSourceOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkExternalSourceBoolExp>;
};

export type QueryRootInfrastructureNetworkExternalSourceAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<InfrastructureNetworkExternalSourceSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<InfrastructureNetworkExternalSourceOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkExternalSourceBoolExp>;
};

export type QueryRootInfrastructureNetworkExternalSourceByPkArgs = {
  value: Scalars['String'];
};

export type QueryRootInfrastructureNetworkFindPointDirectionOnLinkArgs = {
  args: InfrastructureNetworkFindPointDirectionOnLinkArgs;
  distinct_on?: InputMaybe<Array<InfrastructureNetworkDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<InfrastructureNetworkDirectionOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkDirectionBoolExp>;
};

export type QueryRootInfrastructureNetworkFindPointDirectionOnLinkAggregateArgs =
  {
    args: InfrastructureNetworkFindPointDirectionOnLinkArgs;
    distinct_on?: InputMaybe<Array<InfrastructureNetworkDirectionSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<InfrastructureNetworkDirectionOrderBy>>;
    where?: InputMaybe<InfrastructureNetworkDirectionBoolExp>;
  };

export type QueryRootInfrastructureNetworkInfrastructureLinkArgs = {
  distinct_on?: InputMaybe<
    Array<InfrastructureNetworkInfrastructureLinkSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<InfrastructureNetworkInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
};

export type QueryRootInfrastructureNetworkInfrastructureLinkAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<InfrastructureNetworkInfrastructureLinkSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<InfrastructureNetworkInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
};

export type QueryRootInfrastructureNetworkInfrastructureLinkByPkArgs = {
  infrastructure_link_id: Scalars['uuid'];
};

export type QueryRootInfrastructureNetworkResolvePointToClosestLinkArgs = {
  args: InfrastructureNetworkResolvePointToClosestLinkArgs;
  distinct_on?: InputMaybe<
    Array<InfrastructureNetworkInfrastructureLinkSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<InfrastructureNetworkInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
};

export type QueryRootInfrastructureNetworkResolvePointToClosestLinkAggregateArgs =
  {
    args: InfrastructureNetworkResolvePointToClosestLinkArgs;
    distinct_on?: InputMaybe<
      Array<InfrastructureNetworkInfrastructureLinkSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<InfrastructureNetworkInfrastructureLinkOrderBy>
    >;
    where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  };

export type QueryRootInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkArgs =
  {
    distinct_on?: InputMaybe<
      Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOrderBy>
    >;
    where?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
  };

export type QueryRootInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOrderBy>
    >;
    where?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
  };

export type QueryRootInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkByPkArgs =
  {
    infrastructure_link_id: Scalars['uuid'];
    vehicle_submode: ReusableComponentsVehicleSubmodeEnum;
  };

export type QueryRootJourneyPatternCheckInfraLinkStopRefsWithNewScheduledStopPointArgs =
  {
    args: JourneyPatternCheckInfraLinkStopRefsWithNewScheduledStopPointArgs;
    distinct_on?: InputMaybe<Array<JourneyPatternJourneyPatternSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<JourneyPatternJourneyPatternOrderBy>>;
    where?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
  };

export type QueryRootJourneyPatternCheckInfraLinkStopRefsWithNewScheduledStopPointAggregateArgs =
  {
    args: JourneyPatternCheckInfraLinkStopRefsWithNewScheduledStopPointArgs;
    distinct_on?: InputMaybe<Array<JourneyPatternJourneyPatternSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<JourneyPatternJourneyPatternOrderBy>>;
    where?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
  };

export type QueryRootJourneyPatternJourneyPatternArgs = {
  distinct_on?: InputMaybe<Array<JourneyPatternJourneyPatternSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<JourneyPatternJourneyPatternOrderBy>>;
  where?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
};

export type QueryRootJourneyPatternJourneyPatternAggregateArgs = {
  distinct_on?: InputMaybe<Array<JourneyPatternJourneyPatternSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<JourneyPatternJourneyPatternOrderBy>>;
  where?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
};

export type QueryRootJourneyPatternJourneyPatternByPkArgs = {
  journey_pattern_id: Scalars['uuid'];
};

export type QueryRootJourneyPatternScheduledStopPointInJourneyPatternArgs = {
  distinct_on?: InputMaybe<
    Array<JourneyPatternScheduledStopPointInJourneyPatternSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<
    Array<JourneyPatternScheduledStopPointInJourneyPatternOrderBy>
  >;
  where?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
};

export type QueryRootJourneyPatternScheduledStopPointInJourneyPatternAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<JourneyPatternScheduledStopPointInJourneyPatternSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<JourneyPatternScheduledStopPointInJourneyPatternOrderBy>
    >;
    where?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
  };

export type QueryRootJourneyPatternScheduledStopPointInJourneyPatternByPkArgs =
  {
    journey_pattern_id: Scalars['uuid'];
    scheduled_stop_point_sequence: Scalars['Int'];
  };

export type QueryRootReusableComponentsVehicleModeArgs = {
  distinct_on?: InputMaybe<Array<ReusableComponentsVehicleModeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<ReusableComponentsVehicleModeOrderBy>>;
  where?: InputMaybe<ReusableComponentsVehicleModeBoolExp>;
};

export type QueryRootReusableComponentsVehicleModeAggregateArgs = {
  distinct_on?: InputMaybe<Array<ReusableComponentsVehicleModeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<ReusableComponentsVehicleModeOrderBy>>;
  where?: InputMaybe<ReusableComponentsVehicleModeBoolExp>;
};

export type QueryRootReusableComponentsVehicleModeByPkArgs = {
  vehicle_mode: Scalars['String'];
};

export type QueryRootReusableComponentsVehicleSubmodeArgs = {
  distinct_on?: InputMaybe<Array<ReusableComponentsVehicleSubmodeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<ReusableComponentsVehicleSubmodeOrderBy>>;
  where?: InputMaybe<ReusableComponentsVehicleSubmodeBoolExp>;
};

export type QueryRootReusableComponentsVehicleSubmodeAggregateArgs = {
  distinct_on?: InputMaybe<Array<ReusableComponentsVehicleSubmodeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<ReusableComponentsVehicleSubmodeOrderBy>>;
  where?: InputMaybe<ReusableComponentsVehicleSubmodeBoolExp>;
};

export type QueryRootReusableComponentsVehicleSubmodeByPkArgs = {
  vehicle_submode: Scalars['String'];
};

export type QueryRootRouteDirectionArgs = {
  distinct_on?: InputMaybe<Array<RouteDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteDirectionOrderBy>>;
  where?: InputMaybe<RouteDirectionBoolExp>;
};

export type QueryRootRouteDirectionAggregateArgs = {
  distinct_on?: InputMaybe<Array<RouteDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteDirectionOrderBy>>;
  where?: InputMaybe<RouteDirectionBoolExp>;
};

export type QueryRootRouteDirectionByPkArgs = {
  direction: Scalars['String'];
};

export type QueryRootRouteInfrastructureLinkAlongRouteArgs = {
  distinct_on?: InputMaybe<
    Array<RouteInfrastructureLinkAlongRouteSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteInfrastructureLinkAlongRouteOrderBy>>;
  where?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
};

export type QueryRootRouteInfrastructureLinkAlongRouteAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<RouteInfrastructureLinkAlongRouteSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteInfrastructureLinkAlongRouteOrderBy>>;
  where?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
};

export type QueryRootRouteInfrastructureLinkAlongRouteByPkArgs = {
  infrastructure_link_sequence: Scalars['Int'];
  route_id: Scalars['uuid'];
};

export type QueryRootRouteLineArgs = {
  distinct_on?: InputMaybe<Array<RouteLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteLineOrderBy>>;
  where?: InputMaybe<RouteLineBoolExp>;
};

export type QueryRootRouteLineAggregateArgs = {
  distinct_on?: InputMaybe<Array<RouteLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteLineOrderBy>>;
  where?: InputMaybe<RouteLineBoolExp>;
};

export type QueryRootRouteLineByPkArgs = {
  line_id: Scalars['uuid'];
};

export type QueryRootRouteRouteArgs = {
  distinct_on?: InputMaybe<Array<RouteRouteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteRouteOrderBy>>;
  where?: InputMaybe<RouteRouteBoolExp>;
};

export type QueryRootRouteRouteAggregateArgs = {
  distinct_on?: InputMaybe<Array<RouteRouteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteRouteOrderBy>>;
  where?: InputMaybe<RouteRouteBoolExp>;
};

export type QueryRootRouteRouteByPkArgs = {
  route_id: Scalars['uuid'];
};

export type QueryRootRouteTypeOfLineArgs = {
  distinct_on?: InputMaybe<Array<RouteTypeOfLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteTypeOfLineOrderBy>>;
  where?: InputMaybe<RouteTypeOfLineBoolExp>;
};

export type QueryRootRouteTypeOfLineAggregateArgs = {
  distinct_on?: InputMaybe<Array<RouteTypeOfLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteTypeOfLineOrderBy>>;
  where?: InputMaybe<RouteTypeOfLineBoolExp>;
};

export type QueryRootRouteTypeOfLineByPkArgs = {
  type_of_line: Scalars['String'];
};

export type QueryRootServicePatternDistanceBetweenStopsCalculationArgs = {
  distinct_on?: InputMaybe<
    Array<ServicePatternDistanceBetweenStopsCalculationSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<
    Array<ServicePatternDistanceBetweenStopsCalculationOrderBy>
  >;
  where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
};

export type QueryRootServicePatternDistanceBetweenStopsCalculationAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<ServicePatternDistanceBetweenStopsCalculationSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<ServicePatternDistanceBetweenStopsCalculationOrderBy>
    >;
    where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
  };

export type QueryRootServicePatternDistanceBetweenStopsCalculationByPkArgs = {
  journey_pattern_id: Scalars['uuid'];
  observation_date: Scalars['date'];
  route_priority: Scalars['Int'];
  stop_interval_sequence: Scalars['Int'];
};

export type QueryRootServicePatternGetDistancesBetweenStopPointsByRoutesArgs = {
  args: ServicePatternGetDistancesBetweenStopPointsByRoutesArgs;
  distinct_on?: InputMaybe<
    Array<ServicePatternDistanceBetweenStopsCalculationSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<
    Array<ServicePatternDistanceBetweenStopsCalculationOrderBy>
  >;
  where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
};

export type QueryRootServicePatternGetDistancesBetweenStopPointsByRoutesAggregateArgs =
  {
    args: ServicePatternGetDistancesBetweenStopPointsByRoutesArgs;
    distinct_on?: InputMaybe<
      Array<ServicePatternDistanceBetweenStopsCalculationSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<ServicePatternDistanceBetweenStopsCalculationOrderBy>
    >;
    where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
  };

export type QueryRootServicePatternGetDistancesBetweenStopPointsInJourneyPatternsArgs =
  {
    args: ServicePatternGetDistancesBetweenStopPointsInJourneyPatternsArgs;
    distinct_on?: InputMaybe<
      Array<ServicePatternDistanceBetweenStopsCalculationSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<ServicePatternDistanceBetweenStopsCalculationOrderBy>
    >;
    where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
  };

export type QueryRootServicePatternGetDistancesBetweenStopPointsInJourneyPatternsAggregateArgs =
  {
    args: ServicePatternGetDistancesBetweenStopPointsInJourneyPatternsArgs;
    distinct_on?: InputMaybe<
      Array<ServicePatternDistanceBetweenStopsCalculationSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<ServicePatternDistanceBetweenStopsCalculationOrderBy>
    >;
    where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
  };

export type QueryRootServicePatternScheduledStopPointArgs = {
  distinct_on?: InputMaybe<Array<ServicePatternScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<ServicePatternScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};

export type QueryRootServicePatternScheduledStopPointAggregateArgs = {
  distinct_on?: InputMaybe<Array<ServicePatternScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<ServicePatternScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};

export type QueryRootServicePatternScheduledStopPointByPkArgs = {
  scheduled_stop_point_id: Scalars['uuid'];
};

export type QueryRootServicePatternVehicleModeOnScheduledStopPointArgs = {
  distinct_on?: InputMaybe<
    Array<ServicePatternVehicleModeOnScheduledStopPointSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<
    Array<ServicePatternVehicleModeOnScheduledStopPointOrderBy>
  >;
  where?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointBoolExp>;
};

export type QueryRootServicePatternVehicleModeOnScheduledStopPointAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<ServicePatternVehicleModeOnScheduledStopPointSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<ServicePatternVehicleModeOnScheduledStopPointOrderBy>
    >;
    where?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointBoolExp>;
  };

export type QueryRootServicePatternVehicleModeOnScheduledStopPointByPkArgs = {
  scheduled_stop_point_id: Scalars['uuid'];
  vehicle_mode: ReusableComponentsVehicleModeEnum;
};

export type QueryRootTimingPatternTimingPlaceArgs = {
  distinct_on?: InputMaybe<Array<TimingPatternTimingPlaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<TimingPatternTimingPlaceOrderBy>>;
  where?: InputMaybe<TimingPatternTimingPlaceBoolExp>;
};

export type QueryRootTimingPatternTimingPlaceAggregateArgs = {
  distinct_on?: InputMaybe<Array<TimingPatternTimingPlaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<TimingPatternTimingPlaceOrderBy>>;
  where?: InputMaybe<TimingPatternTimingPlaceBoolExp>;
};

export type QueryRootTimingPatternTimingPlaceByPkArgs = {
  timing_place_id: Scalars['uuid'];
};

export type QueryRootToCombineTargetVehicleScheduleFrameIdArgs = {
  arg1: ToCombineTargetVehicleScheduleFrameIdInput;
};

export type QueryRootToReplaceVehicleScheduleFrameIdsArgs = {
  arg1: ToReplaceVehicleScheduleFrameIdsInput;
};

/** The vehicle modes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
export type ReusableComponentsVehicleMode = {
  __typename?: 'reusable_components_vehicle_mode';
  /** The vehicle mode from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
  vehicle_mode: Scalars['String'];
  /** An array relationship */
  vehicle_submodes: Array<ReusableComponentsVehicleSubmode>;
  /** An aggregate relationship */
  vehicle_submodes_aggregate: ReusableComponentsVehicleSubmodeAggregate;
};

/** The vehicle modes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
export type ReusableComponentsVehicleModeVehicleSubmodesArgs = {
  distinct_on?: InputMaybe<Array<ReusableComponentsVehicleSubmodeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<ReusableComponentsVehicleSubmodeOrderBy>>;
  where?: InputMaybe<ReusableComponentsVehicleSubmodeBoolExp>;
};

/** The vehicle modes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
export type ReusableComponentsVehicleModeVehicleSubmodesAggregateArgs = {
  distinct_on?: InputMaybe<Array<ReusableComponentsVehicleSubmodeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<ReusableComponentsVehicleSubmodeOrderBy>>;
  where?: InputMaybe<ReusableComponentsVehicleSubmodeBoolExp>;
};

/** aggregated selection of "reusable_components.vehicle_mode" */
export type ReusableComponentsVehicleModeAggregate = {
  __typename?: 'reusable_components_vehicle_mode_aggregate';
  aggregate?: Maybe<ReusableComponentsVehicleModeAggregateFields>;
  nodes: Array<ReusableComponentsVehicleMode>;
};

/** aggregate fields of "reusable_components.vehicle_mode" */
export type ReusableComponentsVehicleModeAggregateFields = {
  __typename?: 'reusable_components_vehicle_mode_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<ReusableComponentsVehicleModeMaxFields>;
  min?: Maybe<ReusableComponentsVehicleModeMinFields>;
};

/** aggregate fields of "reusable_components.vehicle_mode" */
export type ReusableComponentsVehicleModeAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ReusableComponentsVehicleModeSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "reusable_components.vehicle_mode". All fields are combined with a logical 'AND'. */
export type ReusableComponentsVehicleModeBoolExp = {
  _and?: InputMaybe<Array<ReusableComponentsVehicleModeBoolExp>>;
  _not?: InputMaybe<ReusableComponentsVehicleModeBoolExp>;
  _or?: InputMaybe<Array<ReusableComponentsVehicleModeBoolExp>>;
  vehicle_mode?: InputMaybe<StringComparisonExp>;
  vehicle_submodes?: InputMaybe<ReusableComponentsVehicleSubmodeBoolExp>;
  vehicle_submodes_aggregate?: InputMaybe<ReusableComponentsVehicleSubmodeAggregateBoolExp>;
};

/** unique or primary key constraints on table "reusable_components.vehicle_mode" */
export enum ReusableComponentsVehicleModeConstraint {
  /** unique or primary key constraint on columns "vehicle_mode" */
  VehicleModePkey = 'vehicle_mode_pkey',
}

export enum ReusableComponentsVehicleModeEnum {
  Bus = 'bus',
  Ferry = 'ferry',
  Metro = 'metro',
  Train = 'train',
  Tram = 'tram',
}

/** Boolean expression to compare columns of type "reusable_components_vehicle_mode_enum". All fields are combined with logical 'AND'. */
export type ReusableComponentsVehicleModeEnumComparisonExp = {
  _eq?: InputMaybe<ReusableComponentsVehicleModeEnum>;
  _in?: InputMaybe<Array<ReusableComponentsVehicleModeEnum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<ReusableComponentsVehicleModeEnum>;
  _nin?: InputMaybe<Array<ReusableComponentsVehicleModeEnum>>;
};

/** input type for inserting data into table "reusable_components.vehicle_mode" */
export type ReusableComponentsVehicleModeInsertInput = {
  /** The vehicle mode from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
  vehicle_mode?: InputMaybe<Scalars['String']>;
  vehicle_submodes?: InputMaybe<ReusableComponentsVehicleSubmodeArrRelInsertInput>;
};

/** aggregate max on columns */
export type ReusableComponentsVehicleModeMaxFields = {
  __typename?: 'reusable_components_vehicle_mode_max_fields';
  /** The vehicle mode from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
  vehicle_mode?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type ReusableComponentsVehicleModeMinFields = {
  __typename?: 'reusable_components_vehicle_mode_min_fields';
  /** The vehicle mode from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
  vehicle_mode?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "reusable_components.vehicle_mode" */
export type ReusableComponentsVehicleModeMutationResponse = {
  __typename?: 'reusable_components_vehicle_mode_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<ReusableComponentsVehicleMode>;
};

/** input type for inserting object relation for remote table "reusable_components.vehicle_mode" */
export type ReusableComponentsVehicleModeObjRelInsertInput = {
  data: ReusableComponentsVehicleModeInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<ReusableComponentsVehicleModeOnConflict>;
};

/** on_conflict condition type for table "reusable_components.vehicle_mode" */
export type ReusableComponentsVehicleModeOnConflict = {
  constraint: ReusableComponentsVehicleModeConstraint;
  update_columns?: Array<ReusableComponentsVehicleModeUpdateColumn>;
  where?: InputMaybe<ReusableComponentsVehicleModeBoolExp>;
};

/** Ordering options when selecting data from "reusable_components.vehicle_mode". */
export type ReusableComponentsVehicleModeOrderBy = {
  vehicle_mode?: InputMaybe<OrderBy>;
  vehicle_submodes_aggregate?: InputMaybe<ReusableComponentsVehicleSubmodeAggregateOrderBy>;
};

/** primary key columns input for table: reusable_components.vehicle_mode */
export type ReusableComponentsVehicleModePkColumnsInput = {
  /** The vehicle mode from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
  vehicle_mode: Scalars['String'];
};

/** select columns of table "reusable_components.vehicle_mode" */
export enum ReusableComponentsVehicleModeSelectColumn {
  /** column name */
  VehicleMode = 'vehicle_mode',
}

/** input type for updating data in table "reusable_components.vehicle_mode" */
export type ReusableComponentsVehicleModeSetInput = {
  /** The vehicle mode from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
  vehicle_mode?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "reusable_components_vehicle_mode" */
export type ReusableComponentsVehicleModeStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ReusableComponentsVehicleModeStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ReusableComponentsVehicleModeStreamCursorValueInput = {
  /** The vehicle mode from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
  vehicle_mode?: InputMaybe<Scalars['String']>;
};

/** update columns of table "reusable_components.vehicle_mode" */
export enum ReusableComponentsVehicleModeUpdateColumn {
  /** column name */
  VehicleMode = 'vehicle_mode',
}

export type ReusableComponentsVehicleModeUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ReusableComponentsVehicleModeSetInput>;
  /** filter the rows which have to be updated */
  where: ReusableComponentsVehicleModeBoolExp;
};

/** The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse */
export type ReusableComponentsVehicleSubmode = {
  __typename?: 'reusable_components_vehicle_submode';
  /** The vehicle mode the vehicle submode belongs to: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
  belonging_to_vehicle_mode: ReusableComponentsVehicleModeEnum;
  /** An object relationship */
  vehicle_mode: ReusableComponentsVehicleMode;
  /** The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse */
  vehicle_submode: Scalars['String'];
  /** An array relationship */
  vehicle_submode_on_infrastructure_links: Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
  /** An aggregate relationship */
  vehicle_submode_on_infrastructure_links_aggregate: InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregate;
};

/** The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse */
export type ReusableComponentsVehicleSubmodeVehicleSubmodeOnInfrastructureLinksArgs =
  {
    distinct_on?: InputMaybe<
      Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOrderBy>
    >;
    where?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
  };

/** The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse */
export type ReusableComponentsVehicleSubmodeVehicleSubmodeOnInfrastructureLinksAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOrderBy>
    >;
    where?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
  };

/** aggregated selection of "reusable_components.vehicle_submode" */
export type ReusableComponentsVehicleSubmodeAggregate = {
  __typename?: 'reusable_components_vehicle_submode_aggregate';
  aggregate?: Maybe<ReusableComponentsVehicleSubmodeAggregateFields>;
  nodes: Array<ReusableComponentsVehicleSubmode>;
};

export type ReusableComponentsVehicleSubmodeAggregateBoolExp = {
  count?: InputMaybe<ReusableComponentsVehicleSubmodeAggregateBoolExpCount>;
};

export type ReusableComponentsVehicleSubmodeAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<ReusableComponentsVehicleSubmodeSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<ReusableComponentsVehicleSubmodeBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "reusable_components.vehicle_submode" */
export type ReusableComponentsVehicleSubmodeAggregateFields = {
  __typename?: 'reusable_components_vehicle_submode_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<ReusableComponentsVehicleSubmodeMaxFields>;
  min?: Maybe<ReusableComponentsVehicleSubmodeMinFields>;
};

/** aggregate fields of "reusable_components.vehicle_submode" */
export type ReusableComponentsVehicleSubmodeAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ReusableComponentsVehicleSubmodeSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "reusable_components.vehicle_submode" */
export type ReusableComponentsVehicleSubmodeAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<ReusableComponentsVehicleSubmodeMaxOrderBy>;
  min?: InputMaybe<ReusableComponentsVehicleSubmodeMinOrderBy>;
};

/** input type for inserting array relation for remote table "reusable_components.vehicle_submode" */
export type ReusableComponentsVehicleSubmodeArrRelInsertInput = {
  data: Array<ReusableComponentsVehicleSubmodeInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<ReusableComponentsVehicleSubmodeOnConflict>;
};

/** Boolean expression to filter rows from the table "reusable_components.vehicle_submode". All fields are combined with a logical 'AND'. */
export type ReusableComponentsVehicleSubmodeBoolExp = {
  _and?: InputMaybe<Array<ReusableComponentsVehicleSubmodeBoolExp>>;
  _not?: InputMaybe<ReusableComponentsVehicleSubmodeBoolExp>;
  _or?: InputMaybe<Array<ReusableComponentsVehicleSubmodeBoolExp>>;
  belonging_to_vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnumComparisonExp>;
  vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeBoolExp>;
  vehicle_submode?: InputMaybe<StringComparisonExp>;
  vehicle_submode_on_infrastructure_links?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
  vehicle_submode_on_infrastructure_links_aggregate?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateBoolExp>;
};

/** unique or primary key constraints on table "reusable_components.vehicle_submode" */
export enum ReusableComponentsVehicleSubmodeConstraint {
  /** unique or primary key constraint on columns "vehicle_submode" */
  VehicleSubmodePkey = 'vehicle_submode_pkey',
}

export enum ReusableComponentsVehicleSubmodeEnum {
  /** bus */
  GenericBus = 'generic_bus',
  /** ferry */
  GenericFerry = 'generic_ferry',
  /** metro */
  GenericMetro = 'generic_metro',
  /** train */
  GenericTrain = 'generic_train',
  /** tram */
  GenericTram = 'generic_tram',
  /** bus */
  TallElectricBus = 'tall_electric_bus',
}

/** Boolean expression to compare columns of type "reusable_components_vehicle_submode_enum". All fields are combined with logical 'AND'. */
export type ReusableComponentsVehicleSubmodeEnumComparisonExp = {
  _eq?: InputMaybe<ReusableComponentsVehicleSubmodeEnum>;
  _in?: InputMaybe<Array<ReusableComponentsVehicleSubmodeEnum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<ReusableComponentsVehicleSubmodeEnum>;
  _nin?: InputMaybe<Array<ReusableComponentsVehicleSubmodeEnum>>;
};

/** input type for inserting data into table "reusable_components.vehicle_submode" */
export type ReusableComponentsVehicleSubmodeInsertInput = {
  /** The vehicle mode the vehicle submode belongs to: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
  belonging_to_vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnum>;
  vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeObjRelInsertInput>;
  /** The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse */
  vehicle_submode?: InputMaybe<Scalars['String']>;
  vehicle_submode_on_infrastructure_links?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkArrRelInsertInput>;
};

/** aggregate max on columns */
export type ReusableComponentsVehicleSubmodeMaxFields = {
  __typename?: 'reusable_components_vehicle_submode_max_fields';
  /** The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse */
  vehicle_submode?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "reusable_components.vehicle_submode" */
export type ReusableComponentsVehicleSubmodeMaxOrderBy = {
  /** The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse */
  vehicle_submode?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type ReusableComponentsVehicleSubmodeMinFields = {
  __typename?: 'reusable_components_vehicle_submode_min_fields';
  /** The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse */
  vehicle_submode?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "reusable_components.vehicle_submode" */
export type ReusableComponentsVehicleSubmodeMinOrderBy = {
  /** The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse */
  vehicle_submode?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "reusable_components.vehicle_submode" */
export type ReusableComponentsVehicleSubmodeMutationResponse = {
  __typename?: 'reusable_components_vehicle_submode_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<ReusableComponentsVehicleSubmode>;
};

/** input type for inserting object relation for remote table "reusable_components.vehicle_submode" */
export type ReusableComponentsVehicleSubmodeObjRelInsertInput = {
  data: ReusableComponentsVehicleSubmodeInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<ReusableComponentsVehicleSubmodeOnConflict>;
};

/** on_conflict condition type for table "reusable_components.vehicle_submode" */
export type ReusableComponentsVehicleSubmodeOnConflict = {
  constraint: ReusableComponentsVehicleSubmodeConstraint;
  update_columns?: Array<ReusableComponentsVehicleSubmodeUpdateColumn>;
  where?: InputMaybe<ReusableComponentsVehicleSubmodeBoolExp>;
};

/** Ordering options when selecting data from "reusable_components.vehicle_submode". */
export type ReusableComponentsVehicleSubmodeOrderBy = {
  belonging_to_vehicle_mode?: InputMaybe<OrderBy>;
  vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeOrderBy>;
  vehicle_submode?: InputMaybe<OrderBy>;
  vehicle_submode_on_infrastructure_links_aggregate?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateOrderBy>;
};

/** primary key columns input for table: reusable_components.vehicle_submode */
export type ReusableComponentsVehicleSubmodePkColumnsInput = {
  /** The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse */
  vehicle_submode: Scalars['String'];
};

/** select columns of table "reusable_components.vehicle_submode" */
export enum ReusableComponentsVehicleSubmodeSelectColumn {
  /** column name */
  BelongingToVehicleMode = 'belonging_to_vehicle_mode',
  /** column name */
  VehicleSubmode = 'vehicle_submode',
}

/** input type for updating data in table "reusable_components.vehicle_submode" */
export type ReusableComponentsVehicleSubmodeSetInput = {
  /** The vehicle mode the vehicle submode belongs to: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
  belonging_to_vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnum>;
  /** The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse */
  vehicle_submode?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "reusable_components_vehicle_submode" */
export type ReusableComponentsVehicleSubmodeStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ReusableComponentsVehicleSubmodeStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ReusableComponentsVehicleSubmodeStreamCursorValueInput = {
  /** The vehicle mode the vehicle submode belongs to: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
  belonging_to_vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnum>;
  /** The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse */
  vehicle_submode?: InputMaybe<Scalars['String']>;
};

/** update columns of table "reusable_components.vehicle_submode" */
export enum ReusableComponentsVehicleSubmodeUpdateColumn {
  /** column name */
  BelongingToVehicleMode = 'belonging_to_vehicle_mode',
  /** column name */
  VehicleSubmode = 'vehicle_submode',
}

export type ReusableComponentsVehicleSubmodeUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ReusableComponentsVehicleSubmodeSetInput>;
  /** filter the rows which have to be updated */
  where: ReusableComponentsVehicleSubmodeBoolExp;
};

/** The route directions from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:480 */
export type RouteDirection = {
  __typename?: 'route_direction';
  /** The name of the route direction. */
  direction: Scalars['String'];
  /** An object relationship */
  directionByTheOppositeOfDirection?: Maybe<RouteDirection>;
  /** An array relationship */
  directions: Array<RouteDirection>;
  /** An aggregate relationship */
  directions_aggregate: RouteDirectionAggregate;
  /** The opposite direction. */
  the_opposite_of_direction?: Maybe<RouteDirectionEnum>;
};

/** The route directions from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:480 */
export type RouteDirectionDirectionsArgs = {
  distinct_on?: InputMaybe<Array<RouteDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteDirectionOrderBy>>;
  where?: InputMaybe<RouteDirectionBoolExp>;
};

/** The route directions from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:480 */
export type RouteDirectionDirectionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<RouteDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteDirectionOrderBy>>;
  where?: InputMaybe<RouteDirectionBoolExp>;
};

/** aggregated selection of "route.direction" */
export type RouteDirectionAggregate = {
  __typename?: 'route_direction_aggregate';
  aggregate?: Maybe<RouteDirectionAggregateFields>;
  nodes: Array<RouteDirection>;
};

export type RouteDirectionAggregateBoolExp = {
  count?: InputMaybe<RouteDirectionAggregateBoolExpCount>;
};

export type RouteDirectionAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<RouteDirectionSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<RouteDirectionBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "route.direction" */
export type RouteDirectionAggregateFields = {
  __typename?: 'route_direction_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<RouteDirectionMaxFields>;
  min?: Maybe<RouteDirectionMinFields>;
};

/** aggregate fields of "route.direction" */
export type RouteDirectionAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<RouteDirectionSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "route.direction" */
export type RouteDirectionAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<RouteDirectionMaxOrderBy>;
  min?: InputMaybe<RouteDirectionMinOrderBy>;
};

/** input type for inserting array relation for remote table "route.direction" */
export type RouteDirectionArrRelInsertInput = {
  data: Array<RouteDirectionInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<RouteDirectionOnConflict>;
};

/** Boolean expression to filter rows from the table "route.direction". All fields are combined with a logical 'AND'. */
export type RouteDirectionBoolExp = {
  _and?: InputMaybe<Array<RouteDirectionBoolExp>>;
  _not?: InputMaybe<RouteDirectionBoolExp>;
  _or?: InputMaybe<Array<RouteDirectionBoolExp>>;
  direction?: InputMaybe<StringComparisonExp>;
  directionByTheOppositeOfDirection?: InputMaybe<RouteDirectionBoolExp>;
  directions?: InputMaybe<RouteDirectionBoolExp>;
  directions_aggregate?: InputMaybe<RouteDirectionAggregateBoolExp>;
  the_opposite_of_direction?: InputMaybe<RouteDirectionEnumComparisonExp>;
};

/** unique or primary key constraints on table "route.direction" */
export enum RouteDirectionConstraint {
  /** unique or primary key constraint on columns "direction" */
  DirectionPkey = 'direction_pkey',
}

export enum RouteDirectionEnum {
  /** clockwise */
  Anticlockwise = 'anticlockwise',
  /** anticlockwise */
  Clockwise = 'clockwise',
  /** westbound */
  Eastbound = 'eastbound',
  /** outbound */
  Inbound = 'inbound',
  /** southbound */
  Northbound = 'northbound',
  /** inbound */
  Outbound = 'outbound',
  /** northbound */
  Southbound = 'southbound',
  /** eastbound */
  Westbound = 'westbound',
}

/** Boolean expression to compare columns of type "route_direction_enum". All fields are combined with logical 'AND'. */
export type RouteDirectionEnumComparisonExp = {
  _eq?: InputMaybe<RouteDirectionEnum>;
  _in?: InputMaybe<Array<RouteDirectionEnum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<RouteDirectionEnum>;
  _nin?: InputMaybe<Array<RouteDirectionEnum>>;
};

/** input type for inserting data into table "route.direction" */
export type RouteDirectionInsertInput = {
  /** The name of the route direction. */
  direction?: InputMaybe<Scalars['String']>;
  directionByTheOppositeOfDirection?: InputMaybe<RouteDirectionObjRelInsertInput>;
  directions?: InputMaybe<RouteDirectionArrRelInsertInput>;
  /** The opposite direction. */
  the_opposite_of_direction?: InputMaybe<RouteDirectionEnum>;
};

/** aggregate max on columns */
export type RouteDirectionMaxFields = {
  __typename?: 'route_direction_max_fields';
  /** The name of the route direction. */
  direction?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "route.direction" */
export type RouteDirectionMaxOrderBy = {
  /** The name of the route direction. */
  direction?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type RouteDirectionMinFields = {
  __typename?: 'route_direction_min_fields';
  /** The name of the route direction. */
  direction?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "route.direction" */
export type RouteDirectionMinOrderBy = {
  /** The name of the route direction. */
  direction?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "route.direction" */
export type RouteDirectionMutationResponse = {
  __typename?: 'route_direction_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<RouteDirection>;
};

/** input type for inserting object relation for remote table "route.direction" */
export type RouteDirectionObjRelInsertInput = {
  data: RouteDirectionInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<RouteDirectionOnConflict>;
};

/** on_conflict condition type for table "route.direction" */
export type RouteDirectionOnConflict = {
  constraint: RouteDirectionConstraint;
  update_columns?: Array<RouteDirectionUpdateColumn>;
  where?: InputMaybe<RouteDirectionBoolExp>;
};

/** Ordering options when selecting data from "route.direction". */
export type RouteDirectionOrderBy = {
  direction?: InputMaybe<OrderBy>;
  directionByTheOppositeOfDirection?: InputMaybe<RouteDirectionOrderBy>;
  directions_aggregate?: InputMaybe<RouteDirectionAggregateOrderBy>;
  the_opposite_of_direction?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: route.direction */
export type RouteDirectionPkColumnsInput = {
  /** The name of the route direction. */
  direction: Scalars['String'];
};

/** select columns of table "route.direction" */
export enum RouteDirectionSelectColumn {
  /** column name */
  Direction = 'direction',
  /** column name */
  TheOppositeOfDirection = 'the_opposite_of_direction',
}

/** input type for updating data in table "route.direction" */
export type RouteDirectionSetInput = {
  /** The name of the route direction. */
  direction?: InputMaybe<Scalars['String']>;
  /** The opposite direction. */
  the_opposite_of_direction?: InputMaybe<RouteDirectionEnum>;
};

/** Streaming cursor of the table "route_direction" */
export type RouteDirectionStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: RouteDirectionStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type RouteDirectionStreamCursorValueInput = {
  /** The name of the route direction. */
  direction?: InputMaybe<Scalars['String']>;
  /** The opposite direction. */
  the_opposite_of_direction?: InputMaybe<RouteDirectionEnum>;
};

/** update columns of table "route.direction" */
export enum RouteDirectionUpdateColumn {
  /** column name */
  Direction = 'direction',
  /** column name */
  TheOppositeOfDirection = 'the_opposite_of_direction',
}

export type RouteDirectionUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<RouteDirectionSetInput>;
  /** filter the rows which have to be updated */
  where: RouteDirectionBoolExp;
};

/** The infrastructure links along which the routes are defined. */
export type RouteInfrastructureLinkAlongRoute = {
  __typename?: 'route_infrastructure_link_along_route';
  /** An object relationship */
  infrastructure_link: InfrastructureNetworkInfrastructureLink;
  /** The ID of the infrastructure link. */
  infrastructure_link_id: Scalars['uuid'];
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence: Scalars['Int'];
  /** Is the infrastructure link traversed in the direction of its linestring? */
  is_traversal_forwards: Scalars['Boolean'];
  /** The ID of the route. */
  route_id: Scalars['uuid'];
};

/** aggregated selection of "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteAggregate = {
  __typename?: 'route_infrastructure_link_along_route_aggregate';
  aggregate?: Maybe<RouteInfrastructureLinkAlongRouteAggregateFields>;
  nodes: Array<RouteInfrastructureLinkAlongRoute>;
};

export type RouteInfrastructureLinkAlongRouteAggregateBoolExp = {
  bool_and?: InputMaybe<RouteInfrastructureLinkAlongRouteAggregateBoolExpBoolAnd>;
  bool_or?: InputMaybe<RouteInfrastructureLinkAlongRouteAggregateBoolExpBoolOr>;
  count?: InputMaybe<RouteInfrastructureLinkAlongRouteAggregateBoolExpCount>;
};

export type RouteInfrastructureLinkAlongRouteAggregateBoolExpBoolAnd = {
  arguments: RouteInfrastructureLinkAlongRouteSelectColumnRouteInfrastructureLinkAlongRouteAggregateBoolExpBoolAndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
  predicate: BooleanComparisonExp;
};

export type RouteInfrastructureLinkAlongRouteAggregateBoolExpBoolOr = {
  arguments: RouteInfrastructureLinkAlongRouteSelectColumnRouteInfrastructureLinkAlongRouteAggregateBoolExpBoolOrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
  predicate: BooleanComparisonExp;
};

export type RouteInfrastructureLinkAlongRouteAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<RouteInfrastructureLinkAlongRouteSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteAggregateFields = {
  __typename?: 'route_infrastructure_link_along_route_aggregate_fields';
  avg?: Maybe<RouteInfrastructureLinkAlongRouteAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<RouteInfrastructureLinkAlongRouteMaxFields>;
  min?: Maybe<RouteInfrastructureLinkAlongRouteMinFields>;
  stddev?: Maybe<RouteInfrastructureLinkAlongRouteStddevFields>;
  stddev_pop?: Maybe<RouteInfrastructureLinkAlongRouteStddevPopFields>;
  stddev_samp?: Maybe<RouteInfrastructureLinkAlongRouteStddevSampFields>;
  sum?: Maybe<RouteInfrastructureLinkAlongRouteSumFields>;
  var_pop?: Maybe<RouteInfrastructureLinkAlongRouteVarPopFields>;
  var_samp?: Maybe<RouteInfrastructureLinkAlongRouteVarSampFields>;
  variance?: Maybe<RouteInfrastructureLinkAlongRouteVarianceFields>;
};

/** aggregate fields of "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<RouteInfrastructureLinkAlongRouteSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteAggregateOrderBy = {
  avg?: InputMaybe<RouteInfrastructureLinkAlongRouteAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<RouteInfrastructureLinkAlongRouteMaxOrderBy>;
  min?: InputMaybe<RouteInfrastructureLinkAlongRouteMinOrderBy>;
  stddev?: InputMaybe<RouteInfrastructureLinkAlongRouteStddevOrderBy>;
  stddev_pop?: InputMaybe<RouteInfrastructureLinkAlongRouteStddevPopOrderBy>;
  stddev_samp?: InputMaybe<RouteInfrastructureLinkAlongRouteStddevSampOrderBy>;
  sum?: InputMaybe<RouteInfrastructureLinkAlongRouteSumOrderBy>;
  var_pop?: InputMaybe<RouteInfrastructureLinkAlongRouteVarPopOrderBy>;
  var_samp?: InputMaybe<RouteInfrastructureLinkAlongRouteVarSampOrderBy>;
  variance?: InputMaybe<RouteInfrastructureLinkAlongRouteVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteArrRelInsertInput = {
  data: Array<RouteInfrastructureLinkAlongRouteInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<RouteInfrastructureLinkAlongRouteOnConflict>;
};

/** aggregate avg on columns */
export type RouteInfrastructureLinkAlongRouteAvgFields = {
  __typename?: 'route_infrastructure_link_along_route_avg_fields';
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteAvgOrderBy = {
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "route.infrastructure_link_along_route". All fields are combined with a logical 'AND'. */
export type RouteInfrastructureLinkAlongRouteBoolExp = {
  _and?: InputMaybe<Array<RouteInfrastructureLinkAlongRouteBoolExp>>;
  _not?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
  _or?: InputMaybe<Array<RouteInfrastructureLinkAlongRouteBoolExp>>;
  infrastructure_link?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  infrastructure_link_id?: InputMaybe<UuidComparisonExp>;
  infrastructure_link_sequence?: InputMaybe<IntComparisonExp>;
  is_traversal_forwards?: InputMaybe<BooleanComparisonExp>;
  route_id?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "route.infrastructure_link_along_route" */
export enum RouteInfrastructureLinkAlongRouteConstraint {
  /** unique or primary key constraint on columns "infrastructure_link_sequence", "route_id" */
  InfrastructureLinkAlongRoutePkey = 'infrastructure_link_along_route_pkey',
}

/** input type for incrementing numeric columns in table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteIncInput = {
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteInsertInput = {
  infrastructure_link?: InputMaybe<InfrastructureNetworkInfrastructureLinkObjRelInsertInput>;
  /** The ID of the infrastructure link. */
  infrastructure_link_id?: InputMaybe<Scalars['uuid']>;
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence?: InputMaybe<Scalars['Int']>;
  /** Is the infrastructure link traversed in the direction of its linestring? */
  is_traversal_forwards?: InputMaybe<Scalars['Boolean']>;
  /** The ID of the route. */
  route_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type RouteInfrastructureLinkAlongRouteMaxFields = {
  __typename?: 'route_infrastructure_link_along_route_max_fields';
  /** The ID of the infrastructure link. */
  infrastructure_link_id?: Maybe<Scalars['uuid']>;
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence?: Maybe<Scalars['Int']>;
  /** The ID of the route. */
  route_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteMaxOrderBy = {
  /** The ID of the infrastructure link. */
  infrastructure_link_id?: InputMaybe<OrderBy>;
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence?: InputMaybe<OrderBy>;
  /** The ID of the route. */
  route_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type RouteInfrastructureLinkAlongRouteMinFields = {
  __typename?: 'route_infrastructure_link_along_route_min_fields';
  /** The ID of the infrastructure link. */
  infrastructure_link_id?: Maybe<Scalars['uuid']>;
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence?: Maybe<Scalars['Int']>;
  /** The ID of the route. */
  route_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteMinOrderBy = {
  /** The ID of the infrastructure link. */
  infrastructure_link_id?: InputMaybe<OrderBy>;
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence?: InputMaybe<OrderBy>;
  /** The ID of the route. */
  route_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteMutationResponse = {
  __typename?: 'route_infrastructure_link_along_route_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<RouteInfrastructureLinkAlongRoute>;
};

/** on_conflict condition type for table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteOnConflict = {
  constraint: RouteInfrastructureLinkAlongRouteConstraint;
  update_columns?: Array<RouteInfrastructureLinkAlongRouteUpdateColumn>;
  where?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
};

/** Ordering options when selecting data from "route.infrastructure_link_along_route". */
export type RouteInfrastructureLinkAlongRouteOrderBy = {
  infrastructure_link?: InputMaybe<InfrastructureNetworkInfrastructureLinkOrderBy>;
  infrastructure_link_id?: InputMaybe<OrderBy>;
  infrastructure_link_sequence?: InputMaybe<OrderBy>;
  is_traversal_forwards?: InputMaybe<OrderBy>;
  route_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: route.infrastructure_link_along_route */
export type RouteInfrastructureLinkAlongRoutePkColumnsInput = {
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence: Scalars['Int'];
  /** The ID of the route. */
  route_id: Scalars['uuid'];
};

/** select columns of table "route.infrastructure_link_along_route" */
export enum RouteInfrastructureLinkAlongRouteSelectColumn {
  /** column name */
  InfrastructureLinkId = 'infrastructure_link_id',
  /** column name */
  InfrastructureLinkSequence = 'infrastructure_link_sequence',
  /** column name */
  IsTraversalForwards = 'is_traversal_forwards',
  /** column name */
  RouteId = 'route_id',
}

/** select "route_infrastructure_link_along_route_aggregate_bool_exp_bool_and_arguments_columns" columns of table "route.infrastructure_link_along_route" */
export enum RouteInfrastructureLinkAlongRouteSelectColumnRouteInfrastructureLinkAlongRouteAggregateBoolExpBoolAndArgumentsColumns {
  /** column name */
  IsTraversalForwards = 'is_traversal_forwards',
}

/** select "route_infrastructure_link_along_route_aggregate_bool_exp_bool_or_arguments_columns" columns of table "route.infrastructure_link_along_route" */
export enum RouteInfrastructureLinkAlongRouteSelectColumnRouteInfrastructureLinkAlongRouteAggregateBoolExpBoolOrArgumentsColumns {
  /** column name */
  IsTraversalForwards = 'is_traversal_forwards',
}

/** input type for updating data in table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteSetInput = {
  /** The ID of the infrastructure link. */
  infrastructure_link_id?: InputMaybe<Scalars['uuid']>;
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence?: InputMaybe<Scalars['Int']>;
  /** Is the infrastructure link traversed in the direction of its linestring? */
  is_traversal_forwards?: InputMaybe<Scalars['Boolean']>;
  /** The ID of the route. */
  route_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type RouteInfrastructureLinkAlongRouteStddevFields = {
  __typename?: 'route_infrastructure_link_along_route_stddev_fields';
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteStddevOrderBy = {
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type RouteInfrastructureLinkAlongRouteStddevPopFields = {
  __typename?: 'route_infrastructure_link_along_route_stddev_pop_fields';
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteStddevPopOrderBy = {
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type RouteInfrastructureLinkAlongRouteStddevSampFields = {
  __typename?: 'route_infrastructure_link_along_route_stddev_samp_fields';
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteStddevSampOrderBy = {
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "route_infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: RouteInfrastructureLinkAlongRouteStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type RouteInfrastructureLinkAlongRouteStreamCursorValueInput = {
  /** The ID of the infrastructure link. */
  infrastructure_link_id?: InputMaybe<Scalars['uuid']>;
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence?: InputMaybe<Scalars['Int']>;
  /** Is the infrastructure link traversed in the direction of its linestring? */
  is_traversal_forwards?: InputMaybe<Scalars['Boolean']>;
  /** The ID of the route. */
  route_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type RouteInfrastructureLinkAlongRouteSumFields = {
  __typename?: 'route_infrastructure_link_along_route_sum_fields';
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteSumOrderBy = {
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence?: InputMaybe<OrderBy>;
};

/** update columns of table "route.infrastructure_link_along_route" */
export enum RouteInfrastructureLinkAlongRouteUpdateColumn {
  /** column name */
  InfrastructureLinkId = 'infrastructure_link_id',
  /** column name */
  InfrastructureLinkSequence = 'infrastructure_link_sequence',
  /** column name */
  IsTraversalForwards = 'is_traversal_forwards',
  /** column name */
  RouteId = 'route_id',
}

export type RouteInfrastructureLinkAlongRouteUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<RouteInfrastructureLinkAlongRouteIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<RouteInfrastructureLinkAlongRouteSetInput>;
  /** filter the rows which have to be updated */
  where: RouteInfrastructureLinkAlongRouteBoolExp;
};

/** aggregate var_pop on columns */
export type RouteInfrastructureLinkAlongRouteVarPopFields = {
  __typename?: 'route_infrastructure_link_along_route_var_pop_fields';
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteVarPopOrderBy = {
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type RouteInfrastructureLinkAlongRouteVarSampFields = {
  __typename?: 'route_infrastructure_link_along_route_var_samp_fields';
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteVarSampOrderBy = {
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type RouteInfrastructureLinkAlongRouteVarianceFields = {
  __typename?: 'route_infrastructure_link_along_route_variance_fields';
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteVarianceOrderBy = {
  /** The order of the infrastructure link within the journey pattern. */
  infrastructure_link_sequence?: InputMaybe<OrderBy>;
};

/** The line from Transmodel: http://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:487 */
export type RouteLine = {
  __typename?: 'route_line';
  /** The label of the line definition. The label is unique for a certain priority and validity period. */
  label: Scalars['String'];
  /** An object relationship */
  legacyHslMunicipalityCodeByLegacyHslMunicipalityCode?: Maybe<HslRouteLegacyHslMunicipalityCode>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  legacy_hsl_municipality_code?: Maybe<Scalars['String']>;
  /** The ID of the line. */
  line_id: Scalars['uuid'];
  /** An array relationship */
  line_routes: Array<RouteRoute>;
  /** An aggregate relationship */
  line_routes_aggregate: RouteRouteAggregate;
  /** The name of the line. Placeholder for multilingual strings. */
  name_i18n: Scalars['localized_string'];
  /** The mode of the vehicles used as primary on the line. */
  primary_vehicle_mode: ReusableComponentsVehicleModeEnum;
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  priority: Scalars['Int'];
  /** The shorted name of the line. Placeholder for multilingual strings. */
  short_name_i18n: Scalars['localized_string'];
  /** An object relationship */
  transportTargetByTransportTarget: HslRouteTransportTarget;
  transport_target: HslRouteTransportTargetEnum;
  /** An object relationship */
  typeOfLineByTypeOfLine: RouteTypeOfLine;
  /** The type of the line. */
  type_of_line: RouteTypeOfLineEnum;
  /** The point in time from which onwards the line is no longer valid (inclusive). If NULL, the line will be always valid. */
  validity_end?: Maybe<Scalars['date']>;
  /** The point in time when the line becomes valid (inclusive). If NULL, the line has been always valid. */
  validity_start?: Maybe<Scalars['date']>;
  /** An object relationship */
  vehicle_mode: ReusableComponentsVehicleMode;
};

/** The line from Transmodel: http://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:487 */
export type RouteLineLineRoutesArgs = {
  distinct_on?: InputMaybe<Array<RouteRouteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteRouteOrderBy>>;
  where?: InputMaybe<RouteRouteBoolExp>;
};

/** The line from Transmodel: http://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:487 */
export type RouteLineLineRoutesAggregateArgs = {
  distinct_on?: InputMaybe<Array<RouteRouteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteRouteOrderBy>>;
  where?: InputMaybe<RouteRouteBoolExp>;
};

/** The line from Transmodel: http://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:487 */
export type RouteLineNameI18nArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** The line from Transmodel: http://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:487 */
export type RouteLineShortNameI18nArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "route.line" */
export type RouteLineAggregate = {
  __typename?: 'route_line_aggregate';
  aggregate?: Maybe<RouteLineAggregateFields>;
  nodes: Array<RouteLine>;
};

export type RouteLineAggregateBoolExp = {
  count?: InputMaybe<RouteLineAggregateBoolExpCount>;
};

export type RouteLineAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<RouteLineSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<RouteLineBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "route.line" */
export type RouteLineAggregateFields = {
  __typename?: 'route_line_aggregate_fields';
  avg?: Maybe<RouteLineAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<RouteLineMaxFields>;
  min?: Maybe<RouteLineMinFields>;
  stddev?: Maybe<RouteLineStddevFields>;
  stddev_pop?: Maybe<RouteLineStddevPopFields>;
  stddev_samp?: Maybe<RouteLineStddevSampFields>;
  sum?: Maybe<RouteLineSumFields>;
  var_pop?: Maybe<RouteLineVarPopFields>;
  var_samp?: Maybe<RouteLineVarSampFields>;
  variance?: Maybe<RouteLineVarianceFields>;
};

/** aggregate fields of "route.line" */
export type RouteLineAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<RouteLineSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "route.line" */
export type RouteLineAggregateOrderBy = {
  avg?: InputMaybe<RouteLineAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<RouteLineMaxOrderBy>;
  min?: InputMaybe<RouteLineMinOrderBy>;
  stddev?: InputMaybe<RouteLineStddevOrderBy>;
  stddev_pop?: InputMaybe<RouteLineStddevPopOrderBy>;
  stddev_samp?: InputMaybe<RouteLineStddevSampOrderBy>;
  sum?: InputMaybe<RouteLineSumOrderBy>;
  var_pop?: InputMaybe<RouteLineVarPopOrderBy>;
  var_samp?: InputMaybe<RouteLineVarSampOrderBy>;
  variance?: InputMaybe<RouteLineVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type RouteLineAppendInput = {
  /** The name of the line. Placeholder for multilingual strings. */
  name_i18n?: InputMaybe<Scalars['jsonb']>;
  /** The shorted name of the line. Placeholder for multilingual strings. */
  short_name_i18n?: InputMaybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "route.line" */
export type RouteLineArrRelInsertInput = {
  data: Array<RouteLineInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<RouteLineOnConflict>;
};

/** aggregate avg on columns */
export type RouteLineAvgFields = {
  __typename?: 'route_line_avg_fields';
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "route.line" */
export type RouteLineAvgOrderBy = {
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "route.line". All fields are combined with a logical 'AND'. */
export type RouteLineBoolExp = {
  _and?: InputMaybe<Array<RouteLineBoolExp>>;
  _not?: InputMaybe<RouteLineBoolExp>;
  _or?: InputMaybe<Array<RouteLineBoolExp>>;
  label?: InputMaybe<StringComparisonExp>;
  legacyHslMunicipalityCodeByLegacyHslMunicipalityCode?: InputMaybe<HslRouteLegacyHslMunicipalityCodeBoolExp>;
  legacy_hsl_municipality_code?: InputMaybe<StringComparisonExp>;
  line_id?: InputMaybe<UuidComparisonExp>;
  line_routes?: InputMaybe<RouteRouteBoolExp>;
  line_routes_aggregate?: InputMaybe<RouteRouteAggregateBoolExp>;
  name_i18n?: InputMaybe<JsonbComparisonExp>;
  primary_vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnumComparisonExp>;
  priority?: InputMaybe<IntComparisonExp>;
  short_name_i18n?: InputMaybe<JsonbComparisonExp>;
  transportTargetByTransportTarget?: InputMaybe<HslRouteTransportTargetBoolExp>;
  transport_target?: InputMaybe<HslRouteTransportTargetEnumComparisonExp>;
  typeOfLineByTypeOfLine?: InputMaybe<RouteTypeOfLineBoolExp>;
  type_of_line?: InputMaybe<RouteTypeOfLineEnumComparisonExp>;
  validity_end?: InputMaybe<DateComparisonExp>;
  validity_start?: InputMaybe<DateComparisonExp>;
  vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeBoolExp>;
};

/** unique or primary key constraints on table "route.line" */
export enum RouteLineConstraint {
  /** unique or primary key constraint on columns "line_id" */
  LinePkey = 'line_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type RouteLineDeleteAtPathInput = {
  /** The name of the line. Placeholder for multilingual strings. */
  name_i18n?: InputMaybe<Array<Scalars['String']>>;
  /** The shorted name of the line. Placeholder for multilingual strings. */
  short_name_i18n?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type RouteLineDeleteElemInput = {
  /** The name of the line. Placeholder for multilingual strings. */
  name_i18n?: InputMaybe<Scalars['Int']>;
  /** The shorted name of the line. Placeholder for multilingual strings. */
  short_name_i18n?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type RouteLineDeleteKeyInput = {
  /** The name of the line. Placeholder for multilingual strings. */
  name_i18n?: InputMaybe<Scalars['String']>;
  /** The shorted name of the line. Placeholder for multilingual strings. */
  short_name_i18n?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "route.line" */
export type RouteLineIncInput = {
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "route.line" */
export type RouteLineInsertInput = {
  /** The label of the line definition. The label is unique for a certain priority and validity period. */
  label?: InputMaybe<Scalars['String']>;
  legacyHslMunicipalityCodeByLegacyHslMunicipalityCode?: InputMaybe<HslRouteLegacyHslMunicipalityCodeObjRelInsertInput>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  legacy_hsl_municipality_code?: InputMaybe<Scalars['String']>;
  /** The ID of the line. */
  line_id?: InputMaybe<Scalars['uuid']>;
  line_routes?: InputMaybe<RouteRouteArrRelInsertInput>;
  /** The name of the line. Placeholder for multilingual strings. */
  name_i18n: Scalars['localized_string'];
  /** The mode of the vehicles used as primary on the line. */
  primary_vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnum>;
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<Scalars['Int']>;
  /** The shorted name of the line. Placeholder for multilingual strings. */
  short_name_i18n: Scalars['localized_string'];
  transportTargetByTransportTarget?: InputMaybe<HslRouteTransportTargetObjRelInsertInput>;
  transport_target?: InputMaybe<HslRouteTransportTargetEnum>;
  typeOfLineByTypeOfLine?: InputMaybe<RouteTypeOfLineObjRelInsertInput>;
  /** The type of the line. */
  type_of_line?: InputMaybe<RouteTypeOfLineEnum>;
  /** The point in time from which onwards the line is no longer valid (inclusive). If NULL, the line will be always valid. */
  validity_end?: InputMaybe<Scalars['date']>;
  /** The point in time when the line becomes valid (inclusive). If NULL, the line has been always valid. */
  validity_start?: InputMaybe<Scalars['date']>;
  vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeObjRelInsertInput>;
};

/** aggregate max on columns */
export type RouteLineMaxFields = {
  __typename?: 'route_line_max_fields';
  /** The label of the line definition. The label is unique for a certain priority and validity period. */
  label?: Maybe<Scalars['String']>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  legacy_hsl_municipality_code?: Maybe<Scalars['String']>;
  /** The ID of the line. */
  line_id?: Maybe<Scalars['uuid']>;
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Int']>;
  /** The point in time from which onwards the line is no longer valid (inclusive). If NULL, the line will be always valid. */
  validity_end?: Maybe<Scalars['date']>;
  /** The point in time when the line becomes valid (inclusive). If NULL, the line has been always valid. */
  validity_start?: Maybe<Scalars['date']>;
};

/** order by max() on columns of table "route.line" */
export type RouteLineMaxOrderBy = {
  /** The label of the line definition. The label is unique for a certain priority and validity period. */
  label?: InputMaybe<OrderBy>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  legacy_hsl_municipality_code?: InputMaybe<OrderBy>;
  /** The ID of the line. */
  line_id?: InputMaybe<OrderBy>;
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<OrderBy>;
  /** The point in time from which onwards the line is no longer valid (inclusive). If NULL, the line will be always valid. */
  validity_end?: InputMaybe<OrderBy>;
  /** The point in time when the line becomes valid (inclusive). If NULL, the line has been always valid. */
  validity_start?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type RouteLineMinFields = {
  __typename?: 'route_line_min_fields';
  /** The label of the line definition. The label is unique for a certain priority and validity period. */
  label?: Maybe<Scalars['String']>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  legacy_hsl_municipality_code?: Maybe<Scalars['String']>;
  /** The ID of the line. */
  line_id?: Maybe<Scalars['uuid']>;
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Int']>;
  /** The point in time from which onwards the line is no longer valid (inclusive). If NULL, the line will be always valid. */
  validity_end?: Maybe<Scalars['date']>;
  /** The point in time when the line becomes valid (inclusive). If NULL, the line has been always valid. */
  validity_start?: Maybe<Scalars['date']>;
};

/** order by min() on columns of table "route.line" */
export type RouteLineMinOrderBy = {
  /** The label of the line definition. The label is unique for a certain priority and validity period. */
  label?: InputMaybe<OrderBy>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  legacy_hsl_municipality_code?: InputMaybe<OrderBy>;
  /** The ID of the line. */
  line_id?: InputMaybe<OrderBy>;
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<OrderBy>;
  /** The point in time from which onwards the line is no longer valid (inclusive). If NULL, the line will be always valid. */
  validity_end?: InputMaybe<OrderBy>;
  /** The point in time when the line becomes valid (inclusive). If NULL, the line has been always valid. */
  validity_start?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "route.line" */
export type RouteLineMutationResponse = {
  __typename?: 'route_line_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<RouteLine>;
};

/** input type for inserting object relation for remote table "route.line" */
export type RouteLineObjRelInsertInput = {
  data: RouteLineInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<RouteLineOnConflict>;
};

/** on_conflict condition type for table "route.line" */
export type RouteLineOnConflict = {
  constraint: RouteLineConstraint;
  update_columns?: Array<RouteLineUpdateColumn>;
  where?: InputMaybe<RouteLineBoolExp>;
};

/** Ordering options when selecting data from "route.line". */
export type RouteLineOrderBy = {
  label?: InputMaybe<OrderBy>;
  legacyHslMunicipalityCodeByLegacyHslMunicipalityCode?: InputMaybe<HslRouteLegacyHslMunicipalityCodeOrderBy>;
  legacy_hsl_municipality_code?: InputMaybe<OrderBy>;
  line_id?: InputMaybe<OrderBy>;
  line_routes_aggregate?: InputMaybe<RouteRouteAggregateOrderBy>;
  name_i18n?: InputMaybe<OrderBy>;
  primary_vehicle_mode?: InputMaybe<OrderBy>;
  priority?: InputMaybe<OrderBy>;
  short_name_i18n?: InputMaybe<OrderBy>;
  transportTargetByTransportTarget?: InputMaybe<HslRouteTransportTargetOrderBy>;
  transport_target?: InputMaybe<OrderBy>;
  typeOfLineByTypeOfLine?: InputMaybe<RouteTypeOfLineOrderBy>;
  type_of_line?: InputMaybe<OrderBy>;
  validity_end?: InputMaybe<OrderBy>;
  validity_start?: InputMaybe<OrderBy>;
  vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeOrderBy>;
};

/** primary key columns input for table: route.line */
export type RouteLinePkColumnsInput = {
  /** The ID of the line. */
  line_id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type RouteLinePrependInput = {
  /** The name of the line. Placeholder for multilingual strings. */
  name_i18n?: InputMaybe<Scalars['jsonb']>;
  /** The shorted name of the line. Placeholder for multilingual strings. */
  short_name_i18n?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "route.line" */
export enum RouteLineSelectColumn {
  /** column name */
  Label = 'label',
  /** column name */
  LegacyHslMunicipalityCode = 'legacy_hsl_municipality_code',
  /** column name */
  LineId = 'line_id',
  /** column name */
  NameI18n = 'name_i18n',
  /** column name */
  PrimaryVehicleMode = 'primary_vehicle_mode',
  /** column name */
  Priority = 'priority',
  /** column name */
  ShortNameI18n = 'short_name_i18n',
  /** column name */
  TransportTarget = 'transport_target',
  /** column name */
  TypeOfLine = 'type_of_line',
  /** column name */
  ValidityEnd = 'validity_end',
  /** column name */
  ValidityStart = 'validity_start',
}

/** input type for updating data in table "route.line" */
export type RouteLineSetInput = {
  /** The label of the line definition. The label is unique for a certain priority and validity period. */
  label?: InputMaybe<Scalars['String']>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  legacy_hsl_municipality_code?: InputMaybe<Scalars['String']>;
  /** The ID of the line. */
  line_id?: InputMaybe<Scalars['uuid']>;
  /** The name of the line. Placeholder for multilingual strings. */
  name_i18n?: InputMaybe<Scalars['localized_string']>;
  /** The mode of the vehicles used as primary on the line. */
  primary_vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnum>;
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<Scalars['Int']>;
  /** The shorted name of the line. Placeholder for multilingual strings. */
  short_name_i18n?: InputMaybe<Scalars['localized_string']>;
  transport_target?: InputMaybe<HslRouteTransportTargetEnum>;
  /** The type of the line. */
  type_of_line?: InputMaybe<RouteTypeOfLineEnum>;
  /** The point in time from which onwards the line is no longer valid (inclusive). If NULL, the line will be always valid. */
  validity_end?: InputMaybe<Scalars['date']>;
  /** The point in time when the line becomes valid (inclusive). If NULL, the line has been always valid. */
  validity_start?: InputMaybe<Scalars['date']>;
};

/** aggregate stddev on columns */
export type RouteLineStddevFields = {
  __typename?: 'route_line_stddev_fields';
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "route.line" */
export type RouteLineStddevOrderBy = {
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type RouteLineStddevPopFields = {
  __typename?: 'route_line_stddev_pop_fields';
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "route.line" */
export type RouteLineStddevPopOrderBy = {
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type RouteLineStddevSampFields = {
  __typename?: 'route_line_stddev_samp_fields';
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "route.line" */
export type RouteLineStddevSampOrderBy = {
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "route_line" */
export type RouteLineStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: RouteLineStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type RouteLineStreamCursorValueInput = {
  /** The label of the line definition. The label is unique for a certain priority and validity period. */
  label?: InputMaybe<Scalars['String']>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  legacy_hsl_municipality_code?: InputMaybe<Scalars['String']>;
  /** The ID of the line. */
  line_id?: InputMaybe<Scalars['uuid']>;
  /** The name of the line. Placeholder for multilingual strings. */
  name_i18n?: InputMaybe<Scalars['jsonb']>;
  /** The mode of the vehicles used as primary on the line. */
  primary_vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnum>;
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<Scalars['Int']>;
  /** The shorted name of the line. Placeholder for multilingual strings. */
  short_name_i18n?: InputMaybe<Scalars['jsonb']>;
  transport_target?: InputMaybe<HslRouteTransportTargetEnum>;
  /** The type of the line. */
  type_of_line?: InputMaybe<RouteTypeOfLineEnum>;
  /** The point in time from which onwards the line is no longer valid (inclusive). If NULL, the line will be always valid. */
  validity_end?: InputMaybe<Scalars['date']>;
  /** The point in time when the line becomes valid (inclusive). If NULL, the line has been always valid. */
  validity_start?: InputMaybe<Scalars['date']>;
};

/** aggregate sum on columns */
export type RouteLineSumFields = {
  __typename?: 'route_line_sum_fields';
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "route.line" */
export type RouteLineSumOrderBy = {
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<OrderBy>;
};

/** update columns of table "route.line" */
export enum RouteLineUpdateColumn {
  /** column name */
  Label = 'label',
  /** column name */
  LegacyHslMunicipalityCode = 'legacy_hsl_municipality_code',
  /** column name */
  LineId = 'line_id',
  /** column name */
  NameI18n = 'name_i18n',
  /** column name */
  PrimaryVehicleMode = 'primary_vehicle_mode',
  /** column name */
  Priority = 'priority',
  /** column name */
  ShortNameI18n = 'short_name_i18n',
  /** column name */
  TransportTarget = 'transport_target',
  /** column name */
  TypeOfLine = 'type_of_line',
  /** column name */
  ValidityEnd = 'validity_end',
  /** column name */
  ValidityStart = 'validity_start',
}

export type RouteLineUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<RouteLineAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<RouteLineDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<RouteLineDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<RouteLineDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<RouteLineIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<RouteLinePrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<RouteLineSetInput>;
  /** filter the rows which have to be updated */
  where: RouteLineBoolExp;
};

/** aggregate var_pop on columns */
export type RouteLineVarPopFields = {
  __typename?: 'route_line_var_pop_fields';
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "route.line" */
export type RouteLineVarPopOrderBy = {
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type RouteLineVarSampFields = {
  __typename?: 'route_line_var_samp_fields';
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "route.line" */
export type RouteLineVarSampOrderBy = {
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type RouteLineVarianceFields = {
  __typename?: 'route_line_variance_fields';
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "route.line" */
export type RouteLineVarianceOrderBy = {
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<OrderBy>;
};

/** The routes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:483 */
export type RouteRoute = {
  __typename?: 'route_route';
  /** The description of the route in the form of starting location - destination. Placeholder for multilingual strings. */
  description_i18n?: Maybe<Scalars['localized_string']>;
  destination_name_i18n: Scalars['localized_string'];
  destination_short_name_i18n: Scalars['localized_string'];
  /** The direction of the route definition. */
  direction: RouteDirectionEnum;
  /** An array relationship */
  infrastructure_links_along_route: Array<RouteInfrastructureLinkAlongRoute>;
  /** An aggregate relationship */
  infrastructure_links_along_route_aggregate: RouteInfrastructureLinkAlongRouteAggregate;
  /** The label of the route definition. */
  label: Scalars['String'];
  /** An object relationship */
  legacyHslMunicipalityCodeByLegacyHslMunicipalityCode?: Maybe<HslRouteLegacyHslMunicipalityCode>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  legacy_hsl_municipality_code?: Maybe<Scalars['String']>;
  name_i18n: Scalars['localized_string'];
  /** The line to which this route belongs. */
  on_line_id: Scalars['uuid'];
  origin_name_i18n: Scalars['localized_string'];
  origin_short_name_i18n: Scalars['localized_string'];
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  priority: Scalars['Int'];
  /** The ID of the route. */
  route_id: Scalars['uuid'];
  /** An array relationship */
  route_journey_patterns: Array<JourneyPatternJourneyPattern>;
  /** An aggregate relationship */
  route_journey_patterns_aggregate: JourneyPatternJourneyPatternAggregate;
  /** An object relationship */
  route_line: RouteLine;
  /** A computed field, executes function "route.route_shape" */
  route_shape?: Maybe<Scalars['geography_linestring']>;
  /** Derived from label and variant. Routes are unique for each unique label for a certain direction, priority and validity period */
  unique_label: Scalars['String'];
  /** The point in time (inclusive) from which onwards the route is no longer valid. If NULL, the route is valid indefinitely after the start time of the validity period. */
  validity_end?: Maybe<Scalars['date']>;
  /** The point in time (inclusive) when the route becomes valid. If NULL, the route has been always valid before end time of validity period. */
  validity_start?: Maybe<Scalars['date']>;
  /** The variant for route definition. */
  variant?: Maybe<Scalars['smallint']>;
};

/** The routes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:483 */
export type RouteRouteDescriptionI18nArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** The routes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:483 */
export type RouteRouteDestinationNameI18nArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** The routes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:483 */
export type RouteRouteDestinationShortNameI18nArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** The routes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:483 */
export type RouteRouteInfrastructureLinksAlongRouteArgs = {
  distinct_on?: InputMaybe<
    Array<RouteInfrastructureLinkAlongRouteSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteInfrastructureLinkAlongRouteOrderBy>>;
  where?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
};

/** The routes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:483 */
export type RouteRouteInfrastructureLinksAlongRouteAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<RouteInfrastructureLinkAlongRouteSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteInfrastructureLinkAlongRouteOrderBy>>;
  where?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
};

/** The routes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:483 */
export type RouteRouteNameI18nArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** The routes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:483 */
export type RouteRouteOriginNameI18nArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** The routes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:483 */
export type RouteRouteOriginShortNameI18nArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** The routes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:483 */
export type RouteRouteRouteJourneyPatternsArgs = {
  distinct_on?: InputMaybe<Array<JourneyPatternJourneyPatternSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<JourneyPatternJourneyPatternOrderBy>>;
  where?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
};

/** The routes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:483 */
export type RouteRouteRouteJourneyPatternsAggregateArgs = {
  distinct_on?: InputMaybe<Array<JourneyPatternJourneyPatternSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<JourneyPatternJourneyPatternOrderBy>>;
  where?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
};

/** aggregated selection of "route.route" */
export type RouteRouteAggregate = {
  __typename?: 'route_route_aggregate';
  aggregate?: Maybe<RouteRouteAggregateFields>;
  nodes: Array<RouteRoute>;
};

export type RouteRouteAggregateBoolExp = {
  count?: InputMaybe<RouteRouteAggregateBoolExpCount>;
};

export type RouteRouteAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<RouteRouteSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<RouteRouteBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "route.route" */
export type RouteRouteAggregateFields = {
  __typename?: 'route_route_aggregate_fields';
  avg?: Maybe<RouteRouteAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<RouteRouteMaxFields>;
  min?: Maybe<RouteRouteMinFields>;
  stddev?: Maybe<RouteRouteStddevFields>;
  stddev_pop?: Maybe<RouteRouteStddevPopFields>;
  stddev_samp?: Maybe<RouteRouteStddevSampFields>;
  sum?: Maybe<RouteRouteSumFields>;
  var_pop?: Maybe<RouteRouteVarPopFields>;
  var_samp?: Maybe<RouteRouteVarSampFields>;
  variance?: Maybe<RouteRouteVarianceFields>;
};

/** aggregate fields of "route.route" */
export type RouteRouteAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<RouteRouteSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "route.route" */
export type RouteRouteAggregateOrderBy = {
  avg?: InputMaybe<RouteRouteAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<RouteRouteMaxOrderBy>;
  min?: InputMaybe<RouteRouteMinOrderBy>;
  stddev?: InputMaybe<RouteRouteStddevOrderBy>;
  stddev_pop?: InputMaybe<RouteRouteStddevPopOrderBy>;
  stddev_samp?: InputMaybe<RouteRouteStddevSampOrderBy>;
  sum?: InputMaybe<RouteRouteSumOrderBy>;
  var_pop?: InputMaybe<RouteRouteVarPopOrderBy>;
  var_samp?: InputMaybe<RouteRouteVarSampOrderBy>;
  variance?: InputMaybe<RouteRouteVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type RouteRouteAppendInput = {
  /** The description of the route in the form of starting location - destination. Placeholder for multilingual strings. */
  description_i18n?: InputMaybe<Scalars['jsonb']>;
  destination_name_i18n?: InputMaybe<Scalars['jsonb']>;
  destination_short_name_i18n?: InputMaybe<Scalars['jsonb']>;
  name_i18n?: InputMaybe<Scalars['jsonb']>;
  origin_name_i18n?: InputMaybe<Scalars['jsonb']>;
  origin_short_name_i18n?: InputMaybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "route.route" */
export type RouteRouteArrRelInsertInput = {
  data: Array<RouteRouteInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<RouteRouteOnConflict>;
};

/** aggregate avg on columns */
export type RouteRouteAvgFields = {
  __typename?: 'route_route_avg_fields';
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Float']>;
  /** The variant for route definition. */
  variant?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "route.route" */
export type RouteRouteAvgOrderBy = {
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<OrderBy>;
  /** The variant for route definition. */
  variant?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "route.route". All fields are combined with a logical 'AND'. */
export type RouteRouteBoolExp = {
  _and?: InputMaybe<Array<RouteRouteBoolExp>>;
  _not?: InputMaybe<RouteRouteBoolExp>;
  _or?: InputMaybe<Array<RouteRouteBoolExp>>;
  description_i18n?: InputMaybe<JsonbComparisonExp>;
  destination_name_i18n?: InputMaybe<JsonbComparisonExp>;
  destination_short_name_i18n?: InputMaybe<JsonbComparisonExp>;
  direction?: InputMaybe<RouteDirectionEnumComparisonExp>;
  infrastructure_links_along_route?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
  infrastructure_links_along_route_aggregate?: InputMaybe<RouteInfrastructureLinkAlongRouteAggregateBoolExp>;
  label?: InputMaybe<StringComparisonExp>;
  legacyHslMunicipalityCodeByLegacyHslMunicipalityCode?: InputMaybe<HslRouteLegacyHslMunicipalityCodeBoolExp>;
  legacy_hsl_municipality_code?: InputMaybe<StringComparisonExp>;
  name_i18n?: InputMaybe<JsonbComparisonExp>;
  on_line_id?: InputMaybe<UuidComparisonExp>;
  origin_name_i18n?: InputMaybe<JsonbComparisonExp>;
  origin_short_name_i18n?: InputMaybe<JsonbComparisonExp>;
  priority?: InputMaybe<IntComparisonExp>;
  route_id?: InputMaybe<UuidComparisonExp>;
  route_journey_patterns?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
  route_journey_patterns_aggregate?: InputMaybe<JourneyPatternJourneyPatternAggregateBoolExp>;
  route_line?: InputMaybe<RouteLineBoolExp>;
  route_shape?: InputMaybe<GeographyComparisonExp>;
  unique_label?: InputMaybe<StringComparisonExp>;
  validity_end?: InputMaybe<DateComparisonExp>;
  validity_start?: InputMaybe<DateComparisonExp>;
  variant?: InputMaybe<SmallintComparisonExp>;
};

/** unique or primary key constraints on table "route.route" */
export enum RouteRouteConstraint {
  /** unique or primary key constraint on columns "route_id" */
  RoutePkey = 'route_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type RouteRouteDeleteAtPathInput = {
  /** The description of the route in the form of starting location - destination. Placeholder for multilingual strings. */
  description_i18n?: InputMaybe<Array<Scalars['String']>>;
  destination_name_i18n?: InputMaybe<Array<Scalars['String']>>;
  destination_short_name_i18n?: InputMaybe<Array<Scalars['String']>>;
  name_i18n?: InputMaybe<Array<Scalars['String']>>;
  origin_name_i18n?: InputMaybe<Array<Scalars['String']>>;
  origin_short_name_i18n?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type RouteRouteDeleteElemInput = {
  /** The description of the route in the form of starting location - destination. Placeholder for multilingual strings. */
  description_i18n?: InputMaybe<Scalars['Int']>;
  destination_name_i18n?: InputMaybe<Scalars['Int']>;
  destination_short_name_i18n?: InputMaybe<Scalars['Int']>;
  name_i18n?: InputMaybe<Scalars['Int']>;
  origin_name_i18n?: InputMaybe<Scalars['Int']>;
  origin_short_name_i18n?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type RouteRouteDeleteKeyInput = {
  /** The description of the route in the form of starting location - destination. Placeholder for multilingual strings. */
  description_i18n?: InputMaybe<Scalars['String']>;
  destination_name_i18n?: InputMaybe<Scalars['String']>;
  destination_short_name_i18n?: InputMaybe<Scalars['String']>;
  name_i18n?: InputMaybe<Scalars['String']>;
  origin_name_i18n?: InputMaybe<Scalars['String']>;
  origin_short_name_i18n?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "route.route" */
export type RouteRouteIncInput = {
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<Scalars['Int']>;
  /** The variant for route definition. */
  variant?: InputMaybe<Scalars['smallint']>;
};

/** input type for inserting data into table "route.route" */
export type RouteRouteInsertInput = {
  /** The description of the route in the form of starting location - destination. Placeholder for multilingual strings. */
  description_i18n?: InputMaybe<Scalars['localized_string']>;
  destination_name_i18n: Scalars['localized_string'];
  destination_short_name_i18n: Scalars['localized_string'];
  /** The direction of the route definition. */
  direction?: InputMaybe<RouteDirectionEnum>;
  infrastructure_links_along_route?: InputMaybe<RouteInfrastructureLinkAlongRouteArrRelInsertInput>;
  /** The label of the route definition. */
  label: Scalars['String'];
  legacyHslMunicipalityCodeByLegacyHslMunicipalityCode?: InputMaybe<HslRouteLegacyHslMunicipalityCodeObjRelInsertInput>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  legacy_hsl_municipality_code?: InputMaybe<Scalars['String']>;
  name_i18n: Scalars['localized_string'];
  /** The line to which this route belongs. */
  on_line_id?: InputMaybe<Scalars['uuid']>;
  origin_name_i18n: Scalars['localized_string'];
  origin_short_name_i18n: Scalars['localized_string'];
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<Scalars['Int']>;
  /** The ID of the route. */
  route_id?: InputMaybe<Scalars['uuid']>;
  route_journey_patterns?: InputMaybe<JourneyPatternJourneyPatternArrRelInsertInput>;
  route_line?: InputMaybe<RouteLineObjRelInsertInput>;
  /** The point in time (inclusive) from which onwards the route is no longer valid. If NULL, the route is valid indefinitely after the start time of the validity period. */
  validity_end?: InputMaybe<Scalars['date']>;
  /** The point in time (inclusive) when the route becomes valid. If NULL, the route has been always valid before end time of validity period. */
  validity_start?: InputMaybe<Scalars['date']>;
  /** The variant for route definition. */
  variant?: InputMaybe<Scalars['smallint']>;
};

/** aggregate max on columns */
export type RouteRouteMaxFields = {
  __typename?: 'route_route_max_fields';
  /** The label of the route definition. */
  label?: Maybe<Scalars['String']>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  legacy_hsl_municipality_code?: Maybe<Scalars['String']>;
  /** The line to which this route belongs. */
  on_line_id?: Maybe<Scalars['uuid']>;
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Int']>;
  /** The ID of the route. */
  route_id?: Maybe<Scalars['uuid']>;
  /** Derived from label and variant. Routes are unique for each unique label for a certain direction, priority and validity period */
  unique_label?: Maybe<Scalars['String']>;
  /** The point in time (inclusive) from which onwards the route is no longer valid. If NULL, the route is valid indefinitely after the start time of the validity period. */
  validity_end?: Maybe<Scalars['date']>;
  /** The point in time (inclusive) when the route becomes valid. If NULL, the route has been always valid before end time of validity period. */
  validity_start?: Maybe<Scalars['date']>;
  /** The variant for route definition. */
  variant?: Maybe<Scalars['smallint']>;
};

/** order by max() on columns of table "route.route" */
export type RouteRouteMaxOrderBy = {
  /** The label of the route definition. */
  label?: InputMaybe<OrderBy>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  legacy_hsl_municipality_code?: InputMaybe<OrderBy>;
  /** The line to which this route belongs. */
  on_line_id?: InputMaybe<OrderBy>;
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<OrderBy>;
  /** The ID of the route. */
  route_id?: InputMaybe<OrderBy>;
  /** Derived from label and variant. Routes are unique for each unique label for a certain direction, priority and validity period */
  unique_label?: InputMaybe<OrderBy>;
  /** The point in time (inclusive) from which onwards the route is no longer valid. If NULL, the route is valid indefinitely after the start time of the validity period. */
  validity_end?: InputMaybe<OrderBy>;
  /** The point in time (inclusive) when the route becomes valid. If NULL, the route has been always valid before end time of validity period. */
  validity_start?: InputMaybe<OrderBy>;
  /** The variant for route definition. */
  variant?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type RouteRouteMinFields = {
  __typename?: 'route_route_min_fields';
  /** The label of the route definition. */
  label?: Maybe<Scalars['String']>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  legacy_hsl_municipality_code?: Maybe<Scalars['String']>;
  /** The line to which this route belongs. */
  on_line_id?: Maybe<Scalars['uuid']>;
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Int']>;
  /** The ID of the route. */
  route_id?: Maybe<Scalars['uuid']>;
  /** Derived from label and variant. Routes are unique for each unique label for a certain direction, priority and validity period */
  unique_label?: Maybe<Scalars['String']>;
  /** The point in time (inclusive) from which onwards the route is no longer valid. If NULL, the route is valid indefinitely after the start time of the validity period. */
  validity_end?: Maybe<Scalars['date']>;
  /** The point in time (inclusive) when the route becomes valid. If NULL, the route has been always valid before end time of validity period. */
  validity_start?: Maybe<Scalars['date']>;
  /** The variant for route definition. */
  variant?: Maybe<Scalars['smallint']>;
};

/** order by min() on columns of table "route.route" */
export type RouteRouteMinOrderBy = {
  /** The label of the route definition. */
  label?: InputMaybe<OrderBy>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  legacy_hsl_municipality_code?: InputMaybe<OrderBy>;
  /** The line to which this route belongs. */
  on_line_id?: InputMaybe<OrderBy>;
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<OrderBy>;
  /** The ID of the route. */
  route_id?: InputMaybe<OrderBy>;
  /** Derived from label and variant. Routes are unique for each unique label for a certain direction, priority and validity period */
  unique_label?: InputMaybe<OrderBy>;
  /** The point in time (inclusive) from which onwards the route is no longer valid. If NULL, the route is valid indefinitely after the start time of the validity period. */
  validity_end?: InputMaybe<OrderBy>;
  /** The point in time (inclusive) when the route becomes valid. If NULL, the route has been always valid before end time of validity period. */
  validity_start?: InputMaybe<OrderBy>;
  /** The variant for route definition. */
  variant?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "route.route" */
export type RouteRouteMutationResponse = {
  __typename?: 'route_route_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<RouteRoute>;
};

/** input type for inserting object relation for remote table "route.route" */
export type RouteRouteObjRelInsertInput = {
  data: RouteRouteInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<RouteRouteOnConflict>;
};

/** on_conflict condition type for table "route.route" */
export type RouteRouteOnConflict = {
  constraint: RouteRouteConstraint;
  update_columns?: Array<RouteRouteUpdateColumn>;
  where?: InputMaybe<RouteRouteBoolExp>;
};

/** Ordering options when selecting data from "route.route". */
export type RouteRouteOrderBy = {
  description_i18n?: InputMaybe<OrderBy>;
  destination_name_i18n?: InputMaybe<OrderBy>;
  destination_short_name_i18n?: InputMaybe<OrderBy>;
  direction?: InputMaybe<OrderBy>;
  infrastructure_links_along_route_aggregate?: InputMaybe<RouteInfrastructureLinkAlongRouteAggregateOrderBy>;
  label?: InputMaybe<OrderBy>;
  legacyHslMunicipalityCodeByLegacyHslMunicipalityCode?: InputMaybe<HslRouteLegacyHslMunicipalityCodeOrderBy>;
  legacy_hsl_municipality_code?: InputMaybe<OrderBy>;
  name_i18n?: InputMaybe<OrderBy>;
  on_line_id?: InputMaybe<OrderBy>;
  origin_name_i18n?: InputMaybe<OrderBy>;
  origin_short_name_i18n?: InputMaybe<OrderBy>;
  priority?: InputMaybe<OrderBy>;
  route_id?: InputMaybe<OrderBy>;
  route_journey_patterns_aggregate?: InputMaybe<JourneyPatternJourneyPatternAggregateOrderBy>;
  route_line?: InputMaybe<RouteLineOrderBy>;
  route_shape?: InputMaybe<OrderBy>;
  unique_label?: InputMaybe<OrderBy>;
  validity_end?: InputMaybe<OrderBy>;
  validity_start?: InputMaybe<OrderBy>;
  variant?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: route.route */
export type RouteRoutePkColumnsInput = {
  /** The ID of the route. */
  route_id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type RouteRoutePrependInput = {
  /** The description of the route in the form of starting location - destination. Placeholder for multilingual strings. */
  description_i18n?: InputMaybe<Scalars['jsonb']>;
  destination_name_i18n?: InputMaybe<Scalars['jsonb']>;
  destination_short_name_i18n?: InputMaybe<Scalars['jsonb']>;
  name_i18n?: InputMaybe<Scalars['jsonb']>;
  origin_name_i18n?: InputMaybe<Scalars['jsonb']>;
  origin_short_name_i18n?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "route.route" */
export enum RouteRouteSelectColumn {
  /** column name */
  DescriptionI18n = 'description_i18n',
  /** column name */
  DestinationNameI18n = 'destination_name_i18n',
  /** column name */
  DestinationShortNameI18n = 'destination_short_name_i18n',
  /** column name */
  Direction = 'direction',
  /** column name */
  Label = 'label',
  /** column name */
  LegacyHslMunicipalityCode = 'legacy_hsl_municipality_code',
  /** column name */
  NameI18n = 'name_i18n',
  /** column name */
  OnLineId = 'on_line_id',
  /** column name */
  OriginNameI18n = 'origin_name_i18n',
  /** column name */
  OriginShortNameI18n = 'origin_short_name_i18n',
  /** column name */
  Priority = 'priority',
  /** column name */
  RouteId = 'route_id',
  /** column name */
  UniqueLabel = 'unique_label',
  /** column name */
  ValidityEnd = 'validity_end',
  /** column name */
  ValidityStart = 'validity_start',
  /** column name */
  Variant = 'variant',
}

/** input type for updating data in table "route.route" */
export type RouteRouteSetInput = {
  /** The description of the route in the form of starting location - destination. Placeholder for multilingual strings. */
  description_i18n?: InputMaybe<Scalars['localized_string']>;
  destination_name_i18n?: InputMaybe<Scalars['localized_string']>;
  destination_short_name_i18n?: InputMaybe<Scalars['localized_string']>;
  /** The direction of the route definition. */
  direction?: InputMaybe<RouteDirectionEnum>;
  /** The label of the route definition. */
  label?: InputMaybe<Scalars['String']>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  legacy_hsl_municipality_code?: InputMaybe<Scalars['String']>;
  name_i18n?: InputMaybe<Scalars['localized_string']>;
  /** The line to which this route belongs. */
  on_line_id?: InputMaybe<Scalars['uuid']>;
  origin_name_i18n?: InputMaybe<Scalars['localized_string']>;
  origin_short_name_i18n?: InputMaybe<Scalars['localized_string']>;
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<Scalars['Int']>;
  /** The ID of the route. */
  route_id?: InputMaybe<Scalars['uuid']>;
  /** The point in time (inclusive) from which onwards the route is no longer valid. If NULL, the route is valid indefinitely after the start time of the validity period. */
  validity_end?: InputMaybe<Scalars['date']>;
  /** The point in time (inclusive) when the route becomes valid. If NULL, the route has been always valid before end time of validity period. */
  validity_start?: InputMaybe<Scalars['date']>;
  /** The variant for route definition. */
  variant?: InputMaybe<Scalars['smallint']>;
};

/** aggregate stddev on columns */
export type RouteRouteStddevFields = {
  __typename?: 'route_route_stddev_fields';
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Float']>;
  /** The variant for route definition. */
  variant?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "route.route" */
export type RouteRouteStddevOrderBy = {
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<OrderBy>;
  /** The variant for route definition. */
  variant?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type RouteRouteStddevPopFields = {
  __typename?: 'route_route_stddev_pop_fields';
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Float']>;
  /** The variant for route definition. */
  variant?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "route.route" */
export type RouteRouteStddevPopOrderBy = {
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<OrderBy>;
  /** The variant for route definition. */
  variant?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type RouteRouteStddevSampFields = {
  __typename?: 'route_route_stddev_samp_fields';
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Float']>;
  /** The variant for route definition. */
  variant?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "route.route" */
export type RouteRouteStddevSampOrderBy = {
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<OrderBy>;
  /** The variant for route definition. */
  variant?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "route_route" */
export type RouteRouteStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: RouteRouteStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type RouteRouteStreamCursorValueInput = {
  /** The description of the route in the form of starting location - destination. Placeholder for multilingual strings. */
  description_i18n?: InputMaybe<Scalars['jsonb']>;
  destination_name_i18n?: InputMaybe<Scalars['jsonb']>;
  destination_short_name_i18n?: InputMaybe<Scalars['jsonb']>;
  /** The direction of the route definition. */
  direction?: InputMaybe<RouteDirectionEnum>;
  /** The label of the route definition. */
  label?: InputMaybe<Scalars['String']>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  legacy_hsl_municipality_code?: InputMaybe<Scalars['String']>;
  name_i18n?: InputMaybe<Scalars['jsonb']>;
  /** The line to which this route belongs. */
  on_line_id?: InputMaybe<Scalars['uuid']>;
  origin_name_i18n?: InputMaybe<Scalars['jsonb']>;
  origin_short_name_i18n?: InputMaybe<Scalars['jsonb']>;
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<Scalars['Int']>;
  /** The ID of the route. */
  route_id?: InputMaybe<Scalars['uuid']>;
  /** Derived from label and variant. Routes are unique for each unique label for a certain direction, priority and validity period */
  unique_label?: InputMaybe<Scalars['String']>;
  /** The point in time (inclusive) from which onwards the route is no longer valid. If NULL, the route is valid indefinitely after the start time of the validity period. */
  validity_end?: InputMaybe<Scalars['date']>;
  /** The point in time (inclusive) when the route becomes valid. If NULL, the route has been always valid before end time of validity period. */
  validity_start?: InputMaybe<Scalars['date']>;
  /** The variant for route definition. */
  variant?: InputMaybe<Scalars['smallint']>;
};

/** aggregate sum on columns */
export type RouteRouteSumFields = {
  __typename?: 'route_route_sum_fields';
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Int']>;
  /** The variant for route definition. */
  variant?: Maybe<Scalars['smallint']>;
};

/** order by sum() on columns of table "route.route" */
export type RouteRouteSumOrderBy = {
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<OrderBy>;
  /** The variant for route definition. */
  variant?: InputMaybe<OrderBy>;
};

/** update columns of table "route.route" */
export enum RouteRouteUpdateColumn {
  /** column name */
  DescriptionI18n = 'description_i18n',
  /** column name */
  DestinationNameI18n = 'destination_name_i18n',
  /** column name */
  DestinationShortNameI18n = 'destination_short_name_i18n',
  /** column name */
  Direction = 'direction',
  /** column name */
  Label = 'label',
  /** column name */
  LegacyHslMunicipalityCode = 'legacy_hsl_municipality_code',
  /** column name */
  NameI18n = 'name_i18n',
  /** column name */
  OnLineId = 'on_line_id',
  /** column name */
  OriginNameI18n = 'origin_name_i18n',
  /** column name */
  OriginShortNameI18n = 'origin_short_name_i18n',
  /** column name */
  Priority = 'priority',
  /** column name */
  RouteId = 'route_id',
  /** column name */
  ValidityEnd = 'validity_end',
  /** column name */
  ValidityStart = 'validity_start',
  /** column name */
  Variant = 'variant',
}

export type RouteRouteUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<RouteRouteAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<RouteRouteDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<RouteRouteDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<RouteRouteDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<RouteRouteIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<RouteRoutePrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<RouteRouteSetInput>;
  /** filter the rows which have to be updated */
  where: RouteRouteBoolExp;
};

/** aggregate var_pop on columns */
export type RouteRouteVarPopFields = {
  __typename?: 'route_route_var_pop_fields';
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Float']>;
  /** The variant for route definition. */
  variant?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "route.route" */
export type RouteRouteVarPopOrderBy = {
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<OrderBy>;
  /** The variant for route definition. */
  variant?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type RouteRouteVarSampFields = {
  __typename?: 'route_route_var_samp_fields';
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Float']>;
  /** The variant for route definition. */
  variant?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "route.route" */
export type RouteRouteVarSampOrderBy = {
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<OrderBy>;
  /** The variant for route definition. */
  variant?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type RouteRouteVarianceFields = {
  __typename?: 'route_route_variance_fields';
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Float']>;
  /** The variant for route definition. */
  variant?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "route.route" */
export type RouteRouteVarianceOrderBy = {
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<OrderBy>;
  /** The variant for route definition. */
  variant?: InputMaybe<OrderBy>;
};

/** Type of line. https://www.transmodel-cen.eu/model/EARoot/EA2/EA1/EA3/EA491.htm */
export type RouteTypeOfLine = {
  __typename?: 'route_type_of_line';
  belonging_to_vehicle_mode: ReusableComponentsVehicleModeEnum;
  /** An array relationship */
  lines: Array<RouteLine>;
  /** An aggregate relationship */
  lines_aggregate: RouteLineAggregate;
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  type_of_line: Scalars['String'];
  /** An object relationship */
  vehicle_mode: ReusableComponentsVehicleMode;
};

/** Type of line. https://www.transmodel-cen.eu/model/EARoot/EA2/EA1/EA3/EA491.htm */
export type RouteTypeOfLineLinesArgs = {
  distinct_on?: InputMaybe<Array<RouteLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteLineOrderBy>>;
  where?: InputMaybe<RouteLineBoolExp>;
};

/** Type of line. https://www.transmodel-cen.eu/model/EARoot/EA2/EA1/EA3/EA491.htm */
export type RouteTypeOfLineLinesAggregateArgs = {
  distinct_on?: InputMaybe<Array<RouteLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteLineOrderBy>>;
  where?: InputMaybe<RouteLineBoolExp>;
};

/** aggregated selection of "route.type_of_line" */
export type RouteTypeOfLineAggregate = {
  __typename?: 'route_type_of_line_aggregate';
  aggregate?: Maybe<RouteTypeOfLineAggregateFields>;
  nodes: Array<RouteTypeOfLine>;
};

/** aggregate fields of "route.type_of_line" */
export type RouteTypeOfLineAggregateFields = {
  __typename?: 'route_type_of_line_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<RouteTypeOfLineMaxFields>;
  min?: Maybe<RouteTypeOfLineMinFields>;
};

/** aggregate fields of "route.type_of_line" */
export type RouteTypeOfLineAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<RouteTypeOfLineSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "route.type_of_line". All fields are combined with a logical 'AND'. */
export type RouteTypeOfLineBoolExp = {
  _and?: InputMaybe<Array<RouteTypeOfLineBoolExp>>;
  _not?: InputMaybe<RouteTypeOfLineBoolExp>;
  _or?: InputMaybe<Array<RouteTypeOfLineBoolExp>>;
  belonging_to_vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnumComparisonExp>;
  lines?: InputMaybe<RouteLineBoolExp>;
  lines_aggregate?: InputMaybe<RouteLineAggregateBoolExp>;
  type_of_line?: InputMaybe<StringComparisonExp>;
  vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeBoolExp>;
};

/** unique or primary key constraints on table "route.type_of_line" */
export enum RouteTypeOfLineConstraint {
  /** unique or primary key constraint on columns "type_of_line" */
  TypeOfLinePkey = 'type_of_line_pkey',
}

export enum RouteTypeOfLineEnum {
  /** tram */
  CityTramService = 'city_tram_service',
  /** bus */
  DemandAndResponseBusService = 'demand_and_response_bus_service',
  /** bus */
  ExpressBusService = 'express_bus_service',
  /** ferry */
  FerryService = 'ferry_service',
  /** metro */
  MetroService = 'metro_service',
  /** bus */
  RegionalBusService = 'regional_bus_service',
  /** train */
  RegionalRailService = 'regional_rail_service',
  /** tram */
  RegionalTramService = 'regional_tram_service',
  /** bus */
  SpecialNeedsBus = 'special_needs_bus',
  /** bus */
  StoppingBusService = 'stopping_bus_service',
  /** train */
  SuburbanRailway = 'suburban_railway',
}

/** Boolean expression to compare columns of type "route_type_of_line_enum". All fields are combined with logical 'AND'. */
export type RouteTypeOfLineEnumComparisonExp = {
  _eq?: InputMaybe<RouteTypeOfLineEnum>;
  _in?: InputMaybe<Array<RouteTypeOfLineEnum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<RouteTypeOfLineEnum>;
  _nin?: InputMaybe<Array<RouteTypeOfLineEnum>>;
};

/** input type for inserting data into table "route.type_of_line" */
export type RouteTypeOfLineInsertInput = {
  belonging_to_vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnum>;
  lines?: InputMaybe<RouteLineArrRelInsertInput>;
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  type_of_line?: InputMaybe<Scalars['String']>;
  vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeObjRelInsertInput>;
};

/** aggregate max on columns */
export type RouteTypeOfLineMaxFields = {
  __typename?: 'route_type_of_line_max_fields';
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  type_of_line?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type RouteTypeOfLineMinFields = {
  __typename?: 'route_type_of_line_min_fields';
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  type_of_line?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "route.type_of_line" */
export type RouteTypeOfLineMutationResponse = {
  __typename?: 'route_type_of_line_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<RouteTypeOfLine>;
};

/** input type for inserting object relation for remote table "route.type_of_line" */
export type RouteTypeOfLineObjRelInsertInput = {
  data: RouteTypeOfLineInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<RouteTypeOfLineOnConflict>;
};

/** on_conflict condition type for table "route.type_of_line" */
export type RouteTypeOfLineOnConflict = {
  constraint: RouteTypeOfLineConstraint;
  update_columns?: Array<RouteTypeOfLineUpdateColumn>;
  where?: InputMaybe<RouteTypeOfLineBoolExp>;
};

/** Ordering options when selecting data from "route.type_of_line". */
export type RouteTypeOfLineOrderBy = {
  belonging_to_vehicle_mode?: InputMaybe<OrderBy>;
  lines_aggregate?: InputMaybe<RouteLineAggregateOrderBy>;
  type_of_line?: InputMaybe<OrderBy>;
  vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeOrderBy>;
};

/** primary key columns input for table: route.type_of_line */
export type RouteTypeOfLinePkColumnsInput = {
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  type_of_line: Scalars['String'];
};

/** select columns of table "route.type_of_line" */
export enum RouteTypeOfLineSelectColumn {
  /** column name */
  BelongingToVehicleMode = 'belonging_to_vehicle_mode',
  /** column name */
  TypeOfLine = 'type_of_line',
}

/** input type for updating data in table "route.type_of_line" */
export type RouteTypeOfLineSetInput = {
  belonging_to_vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnum>;
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  type_of_line?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "route_type_of_line" */
export type RouteTypeOfLineStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: RouteTypeOfLineStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type RouteTypeOfLineStreamCursorValueInput = {
  belonging_to_vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnum>;
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  type_of_line?: InputMaybe<Scalars['String']>;
};

/** update columns of table "route.type_of_line" */
export enum RouteTypeOfLineUpdateColumn {
  /** column name */
  BelongingToVehicleMode = 'belonging_to_vehicle_mode',
  /** column name */
  TypeOfLine = 'type_of_line',
}

export type RouteTypeOfLineUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<RouteTypeOfLineSetInput>;
  /** filter the rows which have to be updated */
  where: RouteTypeOfLineBoolExp;
};

export type ServiceCalendarDayTypeActiveOnDayOfWeekAggregateBoolExp = {
  count?: InputMaybe<ServiceCalendarDayTypeActiveOnDayOfWeekAggregateBoolExpCount>;
};

export type ServiceCalendarDayTypeActiveOnDayOfWeekAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>;
  predicate: IntComparisonExp;
};

export type ServiceCalendarSubstituteOperatingDayByLineTypeAggregateBoolExp = {
  count?: InputMaybe<ServiceCalendarSubstituteOperatingDayByLineTypeAggregateBoolExpCount>;
};

export type ServiceCalendarSubstituteOperatingDayByLineTypeAggregateBoolExpCount =
  {
    arguments?: InputMaybe<
      Array<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
    filter?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>;
    predicate: IntComparisonExp;
  };

/** A dummy table that models the results of calculating the lengths of stop intervals from the given journey patterns. The table exists due to the limitations of Hasura and there is no intention to insert anything to it. */
export type ServicePatternDistanceBetweenStopsCalculation = {
  __typename?: 'service_pattern_distance_between_stops_calculation';
  /** The length of the stop interval in metres. */
  distance_in_metres: Scalars['float8'];
  /** The label of the end stop of the stop interval. */
  end_stop_label: Scalars['String'];
  /** The ID of the journey pattern. */
  journey_pattern_id: Scalars['uuid'];
  /** The observation date for the state of the route related to the journey pattern. */
  observation_date: Scalars['date'];
  /** The ID of the route related to the journey pattern. */
  route_id: Scalars['uuid'];
  /** The priority of the route related to the journey pattern. */
  route_priority: Scalars['Int'];
  /** The label of the start stop of the stop interval. */
  start_stop_label: Scalars['String'];
  /** The sequence number of the stop interval within the journey pattern. */
  stop_interval_sequence: Scalars['Int'];
};

/** aggregated selection of "service_pattern.distance_between_stops_calculation" */
export type ServicePatternDistanceBetweenStopsCalculationAggregate = {
  __typename?: 'service_pattern_distance_between_stops_calculation_aggregate';
  aggregate?: Maybe<ServicePatternDistanceBetweenStopsCalculationAggregateFields>;
  nodes: Array<ServicePatternDistanceBetweenStopsCalculation>;
};

/** aggregate fields of "service_pattern.distance_between_stops_calculation" */
export type ServicePatternDistanceBetweenStopsCalculationAggregateFields = {
  __typename?: 'service_pattern_distance_between_stops_calculation_aggregate_fields';
  avg?: Maybe<ServicePatternDistanceBetweenStopsCalculationAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<ServicePatternDistanceBetweenStopsCalculationMaxFields>;
  min?: Maybe<ServicePatternDistanceBetweenStopsCalculationMinFields>;
  stddev?: Maybe<ServicePatternDistanceBetweenStopsCalculationStddevFields>;
  stddev_pop?: Maybe<ServicePatternDistanceBetweenStopsCalculationStddevPopFields>;
  stddev_samp?: Maybe<ServicePatternDistanceBetweenStopsCalculationStddevSampFields>;
  sum?: Maybe<ServicePatternDistanceBetweenStopsCalculationSumFields>;
  var_pop?: Maybe<ServicePatternDistanceBetweenStopsCalculationVarPopFields>;
  var_samp?: Maybe<ServicePatternDistanceBetweenStopsCalculationVarSampFields>;
  variance?: Maybe<ServicePatternDistanceBetweenStopsCalculationVarianceFields>;
};

/** aggregate fields of "service_pattern.distance_between_stops_calculation" */
export type ServicePatternDistanceBetweenStopsCalculationAggregateFieldsCountArgs =
  {
    columns?: InputMaybe<
      Array<ServicePatternDistanceBetweenStopsCalculationSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
  };

/** aggregate avg on columns */
export type ServicePatternDistanceBetweenStopsCalculationAvgFields = {
  __typename?: 'service_pattern_distance_between_stops_calculation_avg_fields';
  /** The length of the stop interval in metres. */
  distance_in_metres?: Maybe<Scalars['Float']>;
  /** The priority of the route related to the journey pattern. */
  route_priority?: Maybe<Scalars['Float']>;
  /** The sequence number of the stop interval within the journey pattern. */
  stop_interval_sequence?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "service_pattern.distance_between_stops_calculation". All fields are combined with a logical 'AND'. */
export type ServicePatternDistanceBetweenStopsCalculationBoolExp = {
  _and?: InputMaybe<
    Array<ServicePatternDistanceBetweenStopsCalculationBoolExp>
  >;
  _not?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
  _or?: InputMaybe<Array<ServicePatternDistanceBetweenStopsCalculationBoolExp>>;
  distance_in_metres?: InputMaybe<Float8ComparisonExp>;
  end_stop_label?: InputMaybe<StringComparisonExp>;
  journey_pattern_id?: InputMaybe<UuidComparisonExp>;
  observation_date?: InputMaybe<DateComparisonExp>;
  route_id?: InputMaybe<UuidComparisonExp>;
  route_priority?: InputMaybe<IntComparisonExp>;
  start_stop_label?: InputMaybe<StringComparisonExp>;
  stop_interval_sequence?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "service_pattern.distance_between_stops_calculation" */
export enum ServicePatternDistanceBetweenStopsCalculationConstraint {
  /** unique or primary key constraint on columns "observation_date", "stop_interval_sequence", "journey_pattern_id", "route_priority" */
  DistanceBetweenStopsCalculationPkey = 'distance_between_stops_calculation_pkey',
}

/** input type for incrementing numeric columns in table "service_pattern.distance_between_stops_calculation" */
export type ServicePatternDistanceBetweenStopsCalculationIncInput = {
  /** The length of the stop interval in metres. */
  distance_in_metres?: InputMaybe<Scalars['float8']>;
  /** The priority of the route related to the journey pattern. */
  route_priority?: InputMaybe<Scalars['Int']>;
  /** The sequence number of the stop interval within the journey pattern. */
  stop_interval_sequence?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "service_pattern.distance_between_stops_calculation" */
export type ServicePatternDistanceBetweenStopsCalculationInsertInput = {
  /** The length of the stop interval in metres. */
  distance_in_metres?: InputMaybe<Scalars['float8']>;
  /** The label of the end stop of the stop interval. */
  end_stop_label?: InputMaybe<Scalars['String']>;
  /** The ID of the journey pattern. */
  journey_pattern_id?: InputMaybe<Scalars['uuid']>;
  /** The observation date for the state of the route related to the journey pattern. */
  observation_date?: InputMaybe<Scalars['date']>;
  /** The ID of the route related to the journey pattern. */
  route_id?: InputMaybe<Scalars['uuid']>;
  /** The priority of the route related to the journey pattern. */
  route_priority?: InputMaybe<Scalars['Int']>;
  /** The label of the start stop of the stop interval. */
  start_stop_label?: InputMaybe<Scalars['String']>;
  /** The sequence number of the stop interval within the journey pattern. */
  stop_interval_sequence?: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type ServicePatternDistanceBetweenStopsCalculationMaxFields = {
  __typename?: 'service_pattern_distance_between_stops_calculation_max_fields';
  /** The length of the stop interval in metres. */
  distance_in_metres?: Maybe<Scalars['float8']>;
  /** The label of the end stop of the stop interval. */
  end_stop_label?: Maybe<Scalars['String']>;
  /** The ID of the journey pattern. */
  journey_pattern_id?: Maybe<Scalars['uuid']>;
  /** The observation date for the state of the route related to the journey pattern. */
  observation_date?: Maybe<Scalars['date']>;
  /** The ID of the route related to the journey pattern. */
  route_id?: Maybe<Scalars['uuid']>;
  /** The priority of the route related to the journey pattern. */
  route_priority?: Maybe<Scalars['Int']>;
  /** The label of the start stop of the stop interval. */
  start_stop_label?: Maybe<Scalars['String']>;
  /** The sequence number of the stop interval within the journey pattern. */
  stop_interval_sequence?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type ServicePatternDistanceBetweenStopsCalculationMinFields = {
  __typename?: 'service_pattern_distance_between_stops_calculation_min_fields';
  /** The length of the stop interval in metres. */
  distance_in_metres?: Maybe<Scalars['float8']>;
  /** The label of the end stop of the stop interval. */
  end_stop_label?: Maybe<Scalars['String']>;
  /** The ID of the journey pattern. */
  journey_pattern_id?: Maybe<Scalars['uuid']>;
  /** The observation date for the state of the route related to the journey pattern. */
  observation_date?: Maybe<Scalars['date']>;
  /** The ID of the route related to the journey pattern. */
  route_id?: Maybe<Scalars['uuid']>;
  /** The priority of the route related to the journey pattern. */
  route_priority?: Maybe<Scalars['Int']>;
  /** The label of the start stop of the stop interval. */
  start_stop_label?: Maybe<Scalars['String']>;
  /** The sequence number of the stop interval within the journey pattern. */
  stop_interval_sequence?: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "service_pattern.distance_between_stops_calculation" */
export type ServicePatternDistanceBetweenStopsCalculationMutationResponse = {
  __typename?: 'service_pattern_distance_between_stops_calculation_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<ServicePatternDistanceBetweenStopsCalculation>;
};

/** on_conflict condition type for table "service_pattern.distance_between_stops_calculation" */
export type ServicePatternDistanceBetweenStopsCalculationOnConflict = {
  constraint: ServicePatternDistanceBetweenStopsCalculationConstraint;
  update_columns?: Array<ServicePatternDistanceBetweenStopsCalculationUpdateColumn>;
  where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
};

/** Ordering options when selecting data from "service_pattern.distance_between_stops_calculation". */
export type ServicePatternDistanceBetweenStopsCalculationOrderBy = {
  distance_in_metres?: InputMaybe<OrderBy>;
  end_stop_label?: InputMaybe<OrderBy>;
  journey_pattern_id?: InputMaybe<OrderBy>;
  observation_date?: InputMaybe<OrderBy>;
  route_id?: InputMaybe<OrderBy>;
  route_priority?: InputMaybe<OrderBy>;
  start_stop_label?: InputMaybe<OrderBy>;
  stop_interval_sequence?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: service_pattern.distance_between_stops_calculation */
export type ServicePatternDistanceBetweenStopsCalculationPkColumnsInput = {
  /** The ID of the journey pattern. */
  journey_pattern_id: Scalars['uuid'];
  /** The observation date for the state of the route related to the journey pattern. */
  observation_date: Scalars['date'];
  /** The priority of the route related to the journey pattern. */
  route_priority: Scalars['Int'];
  /** The sequence number of the stop interval within the journey pattern. */
  stop_interval_sequence: Scalars['Int'];
};

/** select columns of table "service_pattern.distance_between_stops_calculation" */
export enum ServicePatternDistanceBetweenStopsCalculationSelectColumn {
  /** column name */
  DistanceInMetres = 'distance_in_metres',
  /** column name */
  EndStopLabel = 'end_stop_label',
  /** column name */
  JourneyPatternId = 'journey_pattern_id',
  /** column name */
  ObservationDate = 'observation_date',
  /** column name */
  RouteId = 'route_id',
  /** column name */
  RoutePriority = 'route_priority',
  /** column name */
  StartStopLabel = 'start_stop_label',
  /** column name */
  StopIntervalSequence = 'stop_interval_sequence',
}

/** input type for updating data in table "service_pattern.distance_between_stops_calculation" */
export type ServicePatternDistanceBetweenStopsCalculationSetInput = {
  /** The length of the stop interval in metres. */
  distance_in_metres?: InputMaybe<Scalars['float8']>;
  /** The label of the end stop of the stop interval. */
  end_stop_label?: InputMaybe<Scalars['String']>;
  /** The ID of the journey pattern. */
  journey_pattern_id?: InputMaybe<Scalars['uuid']>;
  /** The observation date for the state of the route related to the journey pattern. */
  observation_date?: InputMaybe<Scalars['date']>;
  /** The ID of the route related to the journey pattern. */
  route_id?: InputMaybe<Scalars['uuid']>;
  /** The priority of the route related to the journey pattern. */
  route_priority?: InputMaybe<Scalars['Int']>;
  /** The label of the start stop of the stop interval. */
  start_stop_label?: InputMaybe<Scalars['String']>;
  /** The sequence number of the stop interval within the journey pattern. */
  stop_interval_sequence?: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type ServicePatternDistanceBetweenStopsCalculationStddevFields = {
  __typename?: 'service_pattern_distance_between_stops_calculation_stddev_fields';
  /** The length of the stop interval in metres. */
  distance_in_metres?: Maybe<Scalars['Float']>;
  /** The priority of the route related to the journey pattern. */
  route_priority?: Maybe<Scalars['Float']>;
  /** The sequence number of the stop interval within the journey pattern. */
  stop_interval_sequence?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type ServicePatternDistanceBetweenStopsCalculationStddevPopFields = {
  __typename?: 'service_pattern_distance_between_stops_calculation_stddev_pop_fields';
  /** The length of the stop interval in metres. */
  distance_in_metres?: Maybe<Scalars['Float']>;
  /** The priority of the route related to the journey pattern. */
  route_priority?: Maybe<Scalars['Float']>;
  /** The sequence number of the stop interval within the journey pattern. */
  stop_interval_sequence?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type ServicePatternDistanceBetweenStopsCalculationStddevSampFields = {
  __typename?: 'service_pattern_distance_between_stops_calculation_stddev_samp_fields';
  /** The length of the stop interval in metres. */
  distance_in_metres?: Maybe<Scalars['Float']>;
  /** The priority of the route related to the journey pattern. */
  route_priority?: Maybe<Scalars['Float']>;
  /** The sequence number of the stop interval within the journey pattern. */
  stop_interval_sequence?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "service_pattern_distance_between_stops_calculation" */
export type ServicePatternDistanceBetweenStopsCalculationStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ServicePatternDistanceBetweenStopsCalculationStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ServicePatternDistanceBetweenStopsCalculationStreamCursorValueInput =
  {
    /** The length of the stop interval in metres. */
    distance_in_metres?: InputMaybe<Scalars['float8']>;
    /** The label of the end stop of the stop interval. */
    end_stop_label?: InputMaybe<Scalars['String']>;
    /** The ID of the journey pattern. */
    journey_pattern_id?: InputMaybe<Scalars['uuid']>;
    /** The observation date for the state of the route related to the journey pattern. */
    observation_date?: InputMaybe<Scalars['date']>;
    /** The ID of the route related to the journey pattern. */
    route_id?: InputMaybe<Scalars['uuid']>;
    /** The priority of the route related to the journey pattern. */
    route_priority?: InputMaybe<Scalars['Int']>;
    /** The label of the start stop of the stop interval. */
    start_stop_label?: InputMaybe<Scalars['String']>;
    /** The sequence number of the stop interval within the journey pattern. */
    stop_interval_sequence?: InputMaybe<Scalars['Int']>;
  };

/** aggregate sum on columns */
export type ServicePatternDistanceBetweenStopsCalculationSumFields = {
  __typename?: 'service_pattern_distance_between_stops_calculation_sum_fields';
  /** The length of the stop interval in metres. */
  distance_in_metres?: Maybe<Scalars['float8']>;
  /** The priority of the route related to the journey pattern. */
  route_priority?: Maybe<Scalars['Int']>;
  /** The sequence number of the stop interval within the journey pattern. */
  stop_interval_sequence?: Maybe<Scalars['Int']>;
};

/** update columns of table "service_pattern.distance_between_stops_calculation" */
export enum ServicePatternDistanceBetweenStopsCalculationUpdateColumn {
  /** column name */
  DistanceInMetres = 'distance_in_metres',
  /** column name */
  EndStopLabel = 'end_stop_label',
  /** column name */
  JourneyPatternId = 'journey_pattern_id',
  /** column name */
  ObservationDate = 'observation_date',
  /** column name */
  RouteId = 'route_id',
  /** column name */
  RoutePriority = 'route_priority',
  /** column name */
  StartStopLabel = 'start_stop_label',
  /** column name */
  StopIntervalSequence = 'stop_interval_sequence',
}

export type ServicePatternDistanceBetweenStopsCalculationUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationSetInput>;
  /** filter the rows which have to be updated */
  where: ServicePatternDistanceBetweenStopsCalculationBoolExp;
};

/** aggregate var_pop on columns */
export type ServicePatternDistanceBetweenStopsCalculationVarPopFields = {
  __typename?: 'service_pattern_distance_between_stops_calculation_var_pop_fields';
  /** The length of the stop interval in metres. */
  distance_in_metres?: Maybe<Scalars['Float']>;
  /** The priority of the route related to the journey pattern. */
  route_priority?: Maybe<Scalars['Float']>;
  /** The sequence number of the stop interval within the journey pattern. */
  stop_interval_sequence?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type ServicePatternDistanceBetweenStopsCalculationVarSampFields = {
  __typename?: 'service_pattern_distance_between_stops_calculation_var_samp_fields';
  /** The length of the stop interval in metres. */
  distance_in_metres?: Maybe<Scalars['Float']>;
  /** The priority of the route related to the journey pattern. */
  route_priority?: Maybe<Scalars['Float']>;
  /** The sequence number of the stop interval within the journey pattern. */
  stop_interval_sequence?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type ServicePatternDistanceBetweenStopsCalculationVarianceFields = {
  __typename?: 'service_pattern_distance_between_stops_calculation_variance_fields';
  /** The length of the stop interval in metres. */
  distance_in_metres?: Maybe<Scalars['Float']>;
  /** The priority of the route related to the journey pattern. */
  route_priority?: Maybe<Scalars['Float']>;
  /** The sequence number of the stop interval within the journey pattern. */
  stop_interval_sequence?: Maybe<Scalars['Float']>;
};

export type ServicePatternGetDistancesBetweenStopPointsByRoutesArgs = {
  observation_date?: InputMaybe<Scalars['date']>;
  route_ids?: InputMaybe<Scalars['_uuid']>;
};

export type ServicePatternGetDistancesBetweenStopPointsInJourneyPatternsArgs = {
  include_draft_stops?: InputMaybe<Scalars['Boolean']>;
  journey_pattern_ids?: InputMaybe<Scalars['_uuid']>;
  observation_date?: InputMaybe<Scalars['date']>;
};

/** The scheduled stop points: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:845 . Colloquially known as stops from the perspective of timetable planning. */
export type ServicePatternScheduledStopPoint = {
  __typename?: 'service_pattern_scheduled_stop_point';
  /** The point on the infrastructure link closest to measured_location. A PostGIS PointZ geography in EPSG:4326. */
  closest_point_on_infrastructure_link?: Maybe<Scalars['geography_point']>;
  /** The direction(s) of traffic with respect to the digitization, i.e. the direction of the specified line string. */
  direction: InfrastructureNetworkDirectionEnum;
  /** The label is the short code that identifies the stop to the passengers. There can be at most one stop with the same label at a time. The label matches the GTFS stop_code. */
  label: Scalars['String'];
  /** An object relationship */
  located_on_infrastructure_link: InfrastructureNetworkInfrastructureLink;
  /** The infrastructure link on which the stop is located. */
  located_on_infrastructure_link_id: Scalars['uuid'];
  /** The measured location describes the physical location of the stop. For some stops this describes the location of the pole-mounted flag. A PostGIS PointZ geography in EPSG:4326. */
  measured_location: Scalars['geography_point'];
  /** An array relationship */
  other_label_instances: Array<ServicePatternScheduledStopPoint>;
  /** An aggregate relationship */
  other_label_instances_aggregate: ServicePatternScheduledStopPointAggregate;
  priority: Scalars['Int'];
  /** The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]. */
  relative_distance_from_infrastructure_link_start: Scalars['Float'];
  /** The ID of the scheduled stop point. */
  scheduled_stop_point_id: Scalars['uuid'];
  /** An array relationship */
  scheduled_stop_point_in_journey_patterns: Array<JourneyPatternScheduledStopPointInJourneyPattern>;
  /** An aggregate relationship */
  scheduled_stop_point_in_journey_patterns_aggregate: JourneyPatternScheduledStopPointInJourneyPatternAggregate;
  stop_place?: Maybe<Array<Maybe<StopRegistryStopPlaceInterface>>>;
  /** The id of the related stop place in stop registry database. */
  stop_place_ref?: Maybe<Scalars['String']>;
  /** An object relationship */
  timing_place?: Maybe<TimingPatternTimingPlace>;
  /** Optional reference to a TIMING PLACE. If NULL, the SCHEDULED STOP POINT is not used for timing. */
  timing_place_id?: Maybe<Scalars['uuid']>;
  /** end of the operating date span in the scheduled stop point's local time (inclusive). */
  validity_end?: Maybe<Scalars['date']>;
  /** start of the operating date span in the scheduled stop point's local time (inclusive). */
  validity_start?: Maybe<Scalars['date']>;
  /** An array relationship */
  vehicle_mode_on_scheduled_stop_point: Array<ServicePatternVehicleModeOnScheduledStopPoint>;
  /** An aggregate relationship */
  vehicle_mode_on_scheduled_stop_point_aggregate: ServicePatternVehicleModeOnScheduledStopPointAggregate;
};

/** The scheduled stop points: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:845 . Colloquially known as stops from the perspective of timetable planning. */
export type ServicePatternScheduledStopPointOtherLabelInstancesArgs = {
  distinct_on?: InputMaybe<Array<ServicePatternScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<ServicePatternScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};

/** The scheduled stop points: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:845 . Colloquially known as stops from the perspective of timetable planning. */
export type ServicePatternScheduledStopPointOtherLabelInstancesAggregateArgs = {
  distinct_on?: InputMaybe<Array<ServicePatternScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<ServicePatternScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};

/** The scheduled stop points: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:845 . Colloquially known as stops from the perspective of timetable planning. */
export type ServicePatternScheduledStopPointScheduledStopPointInJourneyPatternsArgs =
  {
    distinct_on?: InputMaybe<
      Array<JourneyPatternScheduledStopPointInJourneyPatternSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<JourneyPatternScheduledStopPointInJourneyPatternOrderBy>
    >;
    where?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
  };

/** The scheduled stop points: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:845 . Colloquially known as stops from the perspective of timetable planning. */
export type ServicePatternScheduledStopPointScheduledStopPointInJourneyPatternsAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<JourneyPatternScheduledStopPointInJourneyPatternSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<JourneyPatternScheduledStopPointInJourneyPatternOrderBy>
    >;
    where?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
  };

/** The scheduled stop points: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:845 . Colloquially known as stops from the perspective of timetable planning. */
export type ServicePatternScheduledStopPointStopPlaceArgs = {
  allVersions?: InputMaybe<Scalars['Boolean']>;
  code?: InputMaybe<Scalars['String']>;
  countryReference?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  countyReference?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  hasParking?: InputMaybe<Scalars['Boolean']>;
  importedId?: InputMaybe<Scalars['String']>;
  key?: InputMaybe<Scalars['String']>;
  municipalityReference?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  onlyMonomodalStopPlaces?: InputMaybe<Scalars['Boolean']>;
  page?: InputMaybe<Scalars['Int']>;
  pointInTime?: InputMaybe<Scalars['stop_registry_DateTime']>;
  query?: InputMaybe<Scalars['String']>;
  size?: InputMaybe<Scalars['Int']>;
  stopPlaceType?: InputMaybe<Array<InputMaybe<StopRegistryStopPlaceType>>>;
  tags?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  version?: InputMaybe<Scalars['Int']>;
  versionValidity?: InputMaybe<StopRegistryVersionValidity>;
  withDuplicatedQuayImportedIds?: InputMaybe<Scalars['Boolean']>;
  withNearbySimilarDuplicates?: InputMaybe<Scalars['Boolean']>;
  withTags?: InputMaybe<Scalars['Boolean']>;
  withoutLocationOnly?: InputMaybe<Scalars['Boolean']>;
  withoutQuaysOnly?: InputMaybe<Scalars['Boolean']>;
};

/** The scheduled stop points: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:845 . Colloquially known as stops from the perspective of timetable planning. */
export type ServicePatternScheduledStopPointVehicleModeOnScheduledStopPointArgs =
  {
    distinct_on?: InputMaybe<
      Array<ServicePatternVehicleModeOnScheduledStopPointSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<ServicePatternVehicleModeOnScheduledStopPointOrderBy>
    >;
    where?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointBoolExp>;
  };

/** The scheduled stop points: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:845 . Colloquially known as stops from the perspective of timetable planning. */
export type ServicePatternScheduledStopPointVehicleModeOnScheduledStopPointAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<ServicePatternVehicleModeOnScheduledStopPointSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<ServicePatternVehicleModeOnScheduledStopPointOrderBy>
    >;
    where?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointBoolExp>;
  };

/** aggregated selection of "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointAggregate = {
  __typename?: 'service_pattern_scheduled_stop_point_aggregate';
  aggregate?: Maybe<ServicePatternScheduledStopPointAggregateFields>;
  nodes: Array<ServicePatternScheduledStopPoint>;
};

export type ServicePatternScheduledStopPointAggregateBoolExp = {
  count?: InputMaybe<ServicePatternScheduledStopPointAggregateBoolExpCount>;
};

export type ServicePatternScheduledStopPointAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<ServicePatternScheduledStopPointSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointAggregateFields = {
  __typename?: 'service_pattern_scheduled_stop_point_aggregate_fields';
  avg?: Maybe<ServicePatternScheduledStopPointAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<ServicePatternScheduledStopPointMaxFields>;
  min?: Maybe<ServicePatternScheduledStopPointMinFields>;
  stddev?: Maybe<ServicePatternScheduledStopPointStddevFields>;
  stddev_pop?: Maybe<ServicePatternScheduledStopPointStddevPopFields>;
  stddev_samp?: Maybe<ServicePatternScheduledStopPointStddevSampFields>;
  sum?: Maybe<ServicePatternScheduledStopPointSumFields>;
  var_pop?: Maybe<ServicePatternScheduledStopPointVarPopFields>;
  var_samp?: Maybe<ServicePatternScheduledStopPointVarSampFields>;
  variance?: Maybe<ServicePatternScheduledStopPointVarianceFields>;
};

/** aggregate fields of "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ServicePatternScheduledStopPointSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointAggregateOrderBy = {
  avg?: InputMaybe<ServicePatternScheduledStopPointAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<ServicePatternScheduledStopPointMaxOrderBy>;
  min?: InputMaybe<ServicePatternScheduledStopPointMinOrderBy>;
  stddev?: InputMaybe<ServicePatternScheduledStopPointStddevOrderBy>;
  stddev_pop?: InputMaybe<ServicePatternScheduledStopPointStddevPopOrderBy>;
  stddev_samp?: InputMaybe<ServicePatternScheduledStopPointStddevSampOrderBy>;
  sum?: InputMaybe<ServicePatternScheduledStopPointSumOrderBy>;
  var_pop?: InputMaybe<ServicePatternScheduledStopPointVarPopOrderBy>;
  var_samp?: InputMaybe<ServicePatternScheduledStopPointVarSampOrderBy>;
  variance?: InputMaybe<ServicePatternScheduledStopPointVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointArrRelInsertInput = {
  data: Array<ServicePatternScheduledStopPointInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<ServicePatternScheduledStopPointOnConflict>;
};

/** aggregate avg on columns */
export type ServicePatternScheduledStopPointAvgFields = {
  __typename?: 'service_pattern_scheduled_stop_point_avg_fields';
  priority?: Maybe<Scalars['Float']>;
  /** The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]. */
  relative_distance_from_infrastructure_link_start?: Maybe<Scalars['float8']>;
};

/** order by avg() on columns of table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointAvgOrderBy = {
  priority?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "service_pattern.scheduled_stop_point". All fields are combined with a logical 'AND'. */
export type ServicePatternScheduledStopPointBoolExp = {
  _and?: InputMaybe<Array<ServicePatternScheduledStopPointBoolExp>>;
  _not?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
  _or?: InputMaybe<Array<ServicePatternScheduledStopPointBoolExp>>;
  closest_point_on_infrastructure_link?: InputMaybe<GeographyComparisonExp>;
  direction?: InputMaybe<InfrastructureNetworkDirectionEnumComparisonExp>;
  label?: InputMaybe<StringComparisonExp>;
  located_on_infrastructure_link?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  located_on_infrastructure_link_id?: InputMaybe<UuidComparisonExp>;
  measured_location?: InputMaybe<GeographyComparisonExp>;
  other_label_instances?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
  other_label_instances_aggregate?: InputMaybe<ServicePatternScheduledStopPointAggregateBoolExp>;
  priority?: InputMaybe<IntComparisonExp>;
  relative_distance_from_infrastructure_link_start?: InputMaybe<Float8ComparisonExp>;
  scheduled_stop_point_id?: InputMaybe<UuidComparisonExp>;
  scheduled_stop_point_in_journey_patterns?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
  scheduled_stop_point_in_journey_patterns_aggregate?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExp>;
  stop_place_ref?: InputMaybe<StringComparisonExp>;
  timing_place?: InputMaybe<TimingPatternTimingPlaceBoolExp>;
  timing_place_id?: InputMaybe<UuidComparisonExp>;
  validity_end?: InputMaybe<DateComparisonExp>;
  validity_start?: InputMaybe<DateComparisonExp>;
  vehicle_mode_on_scheduled_stop_point?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointBoolExp>;
  vehicle_mode_on_scheduled_stop_point_aggregate?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointAggregateBoolExp>;
};

/** unique or primary key constraints on table "service_pattern.scheduled_stop_point" */
export enum ServicePatternScheduledStopPointConstraint {
  /** unique or primary key constraint on columns "scheduled_stop_point_id" */
  ScheduledStopPointPkey = 'scheduled_stop_point_pkey',
  /** unique or primary key constraint on columns "stop_place_ref" */
  ScheduledStopPointStopPlaceRefIdx = 'scheduled_stop_point_stop_place_ref_idx',
}

export type ServicePatternScheduledStopPointInJourneyPatternRefAggregateBoolExp =
  {
    count?: InputMaybe<ServicePatternScheduledStopPointInJourneyPatternRefAggregateBoolExpCount>;
  };

export type ServicePatternScheduledStopPointInJourneyPatternRefAggregateBoolExpCount =
  {
    arguments?: InputMaybe<
      Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
    filter?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>;
    predicate: IntComparisonExp;
  };

/** input type for incrementing numeric columns in table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointIncInput = {
  priority?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointInsertInput = {
  /** The direction(s) of traffic with respect to the digitization, i.e. the direction of the specified line string. */
  direction: InfrastructureNetworkDirectionEnum;
  /** The label is the short code that identifies the stop to the passengers. There can be at most one stop with the same label at a time. The label matches the GTFS stop_code. */
  label: Scalars['String'];
  located_on_infrastructure_link?: InputMaybe<InfrastructureNetworkInfrastructureLinkObjRelInsertInput>;
  /** The infrastructure link on which the stop is located. */
  located_on_infrastructure_link_id: Scalars['uuid'];
  /** The measured location describes the physical location of the stop. For some stops this describes the location of the pole-mounted flag. A PostGIS PointZ geography in EPSG:4326. */
  measured_location: Scalars['geography_point'];
  other_label_instances?: InputMaybe<ServicePatternScheduledStopPointArrRelInsertInput>;
  priority: Scalars['Int'];
  /** The ID of the scheduled stop point. */
  scheduled_stop_point_id?: InputMaybe<Scalars['uuid']>;
  scheduled_stop_point_in_journey_patterns?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternArrRelInsertInput>;
  /** The id of the related stop place in stop registry database. */
  stop_place_ref?: InputMaybe<Scalars['String']>;
  timing_place?: InputMaybe<TimingPatternTimingPlaceObjRelInsertInput>;
  /** Optional reference to a TIMING PLACE. If NULL, the SCHEDULED STOP POINT is not used for timing. */
  timing_place_id?: InputMaybe<Scalars['uuid']>;
  /** end of the operating date span in the scheduled stop point's local time (inclusive). */
  validity_end?: InputMaybe<Scalars['date']>;
  /** start of the operating date span in the scheduled stop point's local time (inclusive). */
  validity_start?: InputMaybe<Scalars['date']>;
  vehicle_mode_on_scheduled_stop_point?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointArrRelInsertInput>;
};

/** aggregate max on columns */
export type ServicePatternScheduledStopPointMaxFields = {
  __typename?: 'service_pattern_scheduled_stop_point_max_fields';
  /** The label is the short code that identifies the stop to the passengers. There can be at most one stop with the same label at a time. The label matches the GTFS stop_code. */
  label?: Maybe<Scalars['String']>;
  /** The infrastructure link on which the stop is located. */
  located_on_infrastructure_link_id?: Maybe<Scalars['uuid']>;
  priority?: Maybe<Scalars['Int']>;
  /** The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]. */
  relative_distance_from_infrastructure_link_start?: Maybe<Scalars['float8']>;
  /** The ID of the scheduled stop point. */
  scheduled_stop_point_id?: Maybe<Scalars['uuid']>;
  /** The id of the related stop place in stop registry database. */
  stop_place_ref?: Maybe<Scalars['String']>;
  /** Optional reference to a TIMING PLACE. If NULL, the SCHEDULED STOP POINT is not used for timing. */
  timing_place_id?: Maybe<Scalars['uuid']>;
  /** end of the operating date span in the scheduled stop point's local time (inclusive). */
  validity_end?: Maybe<Scalars['date']>;
  /** start of the operating date span in the scheduled stop point's local time (inclusive). */
  validity_start?: Maybe<Scalars['date']>;
};

/** order by max() on columns of table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointMaxOrderBy = {
  /** The label is the short code that identifies the stop to the passengers. There can be at most one stop with the same label at a time. The label matches the GTFS stop_code. */
  label?: InputMaybe<OrderBy>;
  /** The infrastructure link on which the stop is located. */
  located_on_infrastructure_link_id?: InputMaybe<OrderBy>;
  priority?: InputMaybe<OrderBy>;
  /** The ID of the scheduled stop point. */
  scheduled_stop_point_id?: InputMaybe<OrderBy>;
  /** The id of the related stop place in stop registry database. */
  stop_place_ref?: InputMaybe<OrderBy>;
  /** Optional reference to a TIMING PLACE. If NULL, the SCHEDULED STOP POINT is not used for timing. */
  timing_place_id?: InputMaybe<OrderBy>;
  /** end of the operating date span in the scheduled stop point's local time (inclusive). */
  validity_end?: InputMaybe<OrderBy>;
  /** start of the operating date span in the scheduled stop point's local time (inclusive). */
  validity_start?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type ServicePatternScheduledStopPointMinFields = {
  __typename?: 'service_pattern_scheduled_stop_point_min_fields';
  /** The label is the short code that identifies the stop to the passengers. There can be at most one stop with the same label at a time. The label matches the GTFS stop_code. */
  label?: Maybe<Scalars['String']>;
  /** The infrastructure link on which the stop is located. */
  located_on_infrastructure_link_id?: Maybe<Scalars['uuid']>;
  priority?: Maybe<Scalars['Int']>;
  /** The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]. */
  relative_distance_from_infrastructure_link_start?: Maybe<Scalars['float8']>;
  /** The ID of the scheduled stop point. */
  scheduled_stop_point_id?: Maybe<Scalars['uuid']>;
  /** The id of the related stop place in stop registry database. */
  stop_place_ref?: Maybe<Scalars['String']>;
  /** Optional reference to a TIMING PLACE. If NULL, the SCHEDULED STOP POINT is not used for timing. */
  timing_place_id?: Maybe<Scalars['uuid']>;
  /** end of the operating date span in the scheduled stop point's local time (inclusive). */
  validity_end?: Maybe<Scalars['date']>;
  /** start of the operating date span in the scheduled stop point's local time (inclusive). */
  validity_start?: Maybe<Scalars['date']>;
};

/** order by min() on columns of table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointMinOrderBy = {
  /** The label is the short code that identifies the stop to the passengers. There can be at most one stop with the same label at a time. The label matches the GTFS stop_code. */
  label?: InputMaybe<OrderBy>;
  /** The infrastructure link on which the stop is located. */
  located_on_infrastructure_link_id?: InputMaybe<OrderBy>;
  priority?: InputMaybe<OrderBy>;
  /** The ID of the scheduled stop point. */
  scheduled_stop_point_id?: InputMaybe<OrderBy>;
  /** The id of the related stop place in stop registry database. */
  stop_place_ref?: InputMaybe<OrderBy>;
  /** Optional reference to a TIMING PLACE. If NULL, the SCHEDULED STOP POINT is not used for timing. */
  timing_place_id?: InputMaybe<OrderBy>;
  /** end of the operating date span in the scheduled stop point's local time (inclusive). */
  validity_end?: InputMaybe<OrderBy>;
  /** start of the operating date span in the scheduled stop point's local time (inclusive). */
  validity_start?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointMutationResponse = {
  __typename?: 'service_pattern_scheduled_stop_point_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<ServicePatternScheduledStopPoint>;
};

/** on_conflict condition type for table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointOnConflict = {
  constraint: ServicePatternScheduledStopPointConstraint;
  update_columns?: Array<ServicePatternScheduledStopPointUpdateColumn>;
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};

/** Ordering options when selecting data from "service_pattern.scheduled_stop_point". */
export type ServicePatternScheduledStopPointOrderBy = {
  closest_point_on_infrastructure_link?: InputMaybe<OrderBy>;
  direction?: InputMaybe<OrderBy>;
  label?: InputMaybe<OrderBy>;
  located_on_infrastructure_link?: InputMaybe<InfrastructureNetworkInfrastructureLinkOrderBy>;
  located_on_infrastructure_link_id?: InputMaybe<OrderBy>;
  measured_location?: InputMaybe<OrderBy>;
  other_label_instances_aggregate?: InputMaybe<ServicePatternScheduledStopPointAggregateOrderBy>;
  priority?: InputMaybe<OrderBy>;
  relative_distance_from_infrastructure_link_start?: InputMaybe<OrderBy>;
  scheduled_stop_point_id?: InputMaybe<OrderBy>;
  scheduled_stop_point_in_journey_patterns_aggregate?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternAggregateOrderBy>;
  stop_place_ref?: InputMaybe<OrderBy>;
  timing_place?: InputMaybe<TimingPatternTimingPlaceOrderBy>;
  timing_place_id?: InputMaybe<OrderBy>;
  validity_end?: InputMaybe<OrderBy>;
  validity_start?: InputMaybe<OrderBy>;
  vehicle_mode_on_scheduled_stop_point_aggregate?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointAggregateOrderBy>;
};

/** primary key columns input for table: service_pattern.scheduled_stop_point */
export type ServicePatternScheduledStopPointPkColumnsInput = {
  /** The ID of the scheduled stop point. */
  scheduled_stop_point_id: Scalars['uuid'];
};

/** select columns of table "service_pattern.scheduled_stop_point" */
export enum ServicePatternScheduledStopPointSelectColumn {
  /** column name */
  Direction = 'direction',
  /** column name */
  Label = 'label',
  /** column name */
  LocatedOnInfrastructureLinkId = 'located_on_infrastructure_link_id',
  /** column name */
  MeasuredLocation = 'measured_location',
  /** column name */
  Priority = 'priority',
  /** column name */
  ScheduledStopPointId = 'scheduled_stop_point_id',
  /** column name */
  StopPlaceRef = 'stop_place_ref',
  /** column name */
  TimingPlaceId = 'timing_place_id',
  /** column name */
  ValidityEnd = 'validity_end',
  /** column name */
  ValidityStart = 'validity_start',
}

/** input type for updating data in table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointSetInput = {
  /** The direction(s) of traffic with respect to the digitization, i.e. the direction of the specified line string. */
  direction?: InputMaybe<InfrastructureNetworkDirectionEnum>;
  /** The label is the short code that identifies the stop to the passengers. There can be at most one stop with the same label at a time. The label matches the GTFS stop_code. */
  label?: InputMaybe<Scalars['String']>;
  /** The infrastructure link on which the stop is located. */
  located_on_infrastructure_link_id?: InputMaybe<Scalars['uuid']>;
  /** The measured location describes the physical location of the stop. For some stops this describes the location of the pole-mounted flag. A PostGIS PointZ geography in EPSG:4326. */
  measured_location?: InputMaybe<Scalars['geography_point']>;
  priority?: InputMaybe<Scalars['Int']>;
  /** The ID of the scheduled stop point. */
  scheduled_stop_point_id?: InputMaybe<Scalars['uuid']>;
  /** The id of the related stop place in stop registry database. */
  stop_place_ref?: InputMaybe<Scalars['String']>;
  /** Optional reference to a TIMING PLACE. If NULL, the SCHEDULED STOP POINT is not used for timing. */
  timing_place_id?: InputMaybe<Scalars['uuid']>;
  /** end of the operating date span in the scheduled stop point's local time (inclusive). */
  validity_end?: InputMaybe<Scalars['date']>;
  /** start of the operating date span in the scheduled stop point's local time (inclusive). */
  validity_start?: InputMaybe<Scalars['date']>;
};

/** aggregate stddev on columns */
export type ServicePatternScheduledStopPointStddevFields = {
  __typename?: 'service_pattern_scheduled_stop_point_stddev_fields';
  priority?: Maybe<Scalars['Float']>;
  /** The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]. */
  relative_distance_from_infrastructure_link_start?: Maybe<Scalars['float8']>;
};

/** order by stddev() on columns of table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointStddevOrderBy = {
  priority?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type ServicePatternScheduledStopPointStddevPopFields = {
  __typename?: 'service_pattern_scheduled_stop_point_stddev_pop_fields';
  priority?: Maybe<Scalars['Float']>;
  /** The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]. */
  relative_distance_from_infrastructure_link_start?: Maybe<Scalars['float8']>;
};

/** order by stddev_pop() on columns of table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointStddevPopOrderBy = {
  priority?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type ServicePatternScheduledStopPointStddevSampFields = {
  __typename?: 'service_pattern_scheduled_stop_point_stddev_samp_fields';
  priority?: Maybe<Scalars['Float']>;
  /** The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]. */
  relative_distance_from_infrastructure_link_start?: Maybe<Scalars['float8']>;
};

/** order by stddev_samp() on columns of table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointStddevSampOrderBy = {
  priority?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "service_pattern_scheduled_stop_point" */
export type ServicePatternScheduledStopPointStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ServicePatternScheduledStopPointStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ServicePatternScheduledStopPointStreamCursorValueInput = {
  /** The direction(s) of traffic with respect to the digitization, i.e. the direction of the specified line string. */
  direction?: InputMaybe<InfrastructureNetworkDirectionEnum>;
  /** The label is the short code that identifies the stop to the passengers. There can be at most one stop with the same label at a time. The label matches the GTFS stop_code. */
  label?: InputMaybe<Scalars['String']>;
  /** The infrastructure link on which the stop is located. */
  located_on_infrastructure_link_id?: InputMaybe<Scalars['uuid']>;
  /** The measured location describes the physical location of the stop. For some stops this describes the location of the pole-mounted flag. A PostGIS PointZ geography in EPSG:4326. */
  measured_location?: InputMaybe<Scalars['geography']>;
  priority?: InputMaybe<Scalars['Int']>;
  /** The ID of the scheduled stop point. */
  scheduled_stop_point_id?: InputMaybe<Scalars['uuid']>;
  /** The id of the related stop place in stop registry database. */
  stop_place_ref?: InputMaybe<Scalars['String']>;
  /** Optional reference to a TIMING PLACE. If NULL, the SCHEDULED STOP POINT is not used for timing. */
  timing_place_id?: InputMaybe<Scalars['uuid']>;
  /** end of the operating date span in the scheduled stop point's local time (inclusive). */
  validity_end?: InputMaybe<Scalars['date']>;
  /** start of the operating date span in the scheduled stop point's local time (inclusive). */
  validity_start?: InputMaybe<Scalars['date']>;
};

/** aggregate sum on columns */
export type ServicePatternScheduledStopPointSumFields = {
  __typename?: 'service_pattern_scheduled_stop_point_sum_fields';
  priority?: Maybe<Scalars['Int']>;
  /** The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]. */
  relative_distance_from_infrastructure_link_start?: Maybe<Scalars['float8']>;
};

/** order by sum() on columns of table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointSumOrderBy = {
  priority?: InputMaybe<OrderBy>;
};

/** update columns of table "service_pattern.scheduled_stop_point" */
export enum ServicePatternScheduledStopPointUpdateColumn {
  /** column name */
  Direction = 'direction',
  /** column name */
  Label = 'label',
  /** column name */
  LocatedOnInfrastructureLinkId = 'located_on_infrastructure_link_id',
  /** column name */
  MeasuredLocation = 'measured_location',
  /** column name */
  Priority = 'priority',
  /** column name */
  ScheduledStopPointId = 'scheduled_stop_point_id',
  /** column name */
  StopPlaceRef = 'stop_place_ref',
  /** column name */
  TimingPlaceId = 'timing_place_id',
  /** column name */
  ValidityEnd = 'validity_end',
  /** column name */
  ValidityStart = 'validity_start',
}

export type ServicePatternScheduledStopPointUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ServicePatternScheduledStopPointIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ServicePatternScheduledStopPointSetInput>;
  /** filter the rows which have to be updated */
  where: ServicePatternScheduledStopPointBoolExp;
};

/** aggregate var_pop on columns */
export type ServicePatternScheduledStopPointVarPopFields = {
  __typename?: 'service_pattern_scheduled_stop_point_var_pop_fields';
  priority?: Maybe<Scalars['Float']>;
  /** The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]. */
  relative_distance_from_infrastructure_link_start?: Maybe<Scalars['float8']>;
};

/** order by var_pop() on columns of table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointVarPopOrderBy = {
  priority?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type ServicePatternScheduledStopPointVarSampFields = {
  __typename?: 'service_pattern_scheduled_stop_point_var_samp_fields';
  priority?: Maybe<Scalars['Float']>;
  /** The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]. */
  relative_distance_from_infrastructure_link_start?: Maybe<Scalars['float8']>;
};

/** order by var_samp() on columns of table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointVarSampOrderBy = {
  priority?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type ServicePatternScheduledStopPointVarianceFields = {
  __typename?: 'service_pattern_scheduled_stop_point_variance_fields';
  priority?: Maybe<Scalars['Float']>;
  /** The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]. */
  relative_distance_from_infrastructure_link_start?: Maybe<Scalars['float8']>;
};

/** order by variance() on columns of table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointVarianceOrderBy = {
  priority?: InputMaybe<OrderBy>;
};

/** Which scheduled stop points are serviced by which vehicle modes? */
export type ServicePatternVehicleModeOnScheduledStopPoint = {
  __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point';
  /** The scheduled stop point that is serviced by the vehicle mode. */
  scheduled_stop_point_id: Scalars['uuid'];
  /** The vehicle mode servicing the scheduled stop point. */
  vehicle_mode: ReusableComponentsVehicleModeEnum;
};

/** aggregated selection of "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export type ServicePatternVehicleModeOnScheduledStopPointAggregate = {
  __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point_aggregate';
  aggregate?: Maybe<ServicePatternVehicleModeOnScheduledStopPointAggregateFields>;
  nodes: Array<ServicePatternVehicleModeOnScheduledStopPoint>;
};

export type ServicePatternVehicleModeOnScheduledStopPointAggregateBoolExp = {
  count?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointAggregateBoolExpCount>;
};

export type ServicePatternVehicleModeOnScheduledStopPointAggregateBoolExpCount =
  {
    arguments?: InputMaybe<
      Array<ServicePatternVehicleModeOnScheduledStopPointSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
    filter?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointBoolExp>;
    predicate: IntComparisonExp;
  };

/** aggregate fields of "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export type ServicePatternVehicleModeOnScheduledStopPointAggregateFields = {
  __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<ServicePatternVehicleModeOnScheduledStopPointMaxFields>;
  min?: Maybe<ServicePatternVehicleModeOnScheduledStopPointMinFields>;
};

/** aggregate fields of "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export type ServicePatternVehicleModeOnScheduledStopPointAggregateFieldsCountArgs =
  {
    columns?: InputMaybe<
      Array<ServicePatternVehicleModeOnScheduledStopPointSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
  };

/** order by aggregate values of table "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export type ServicePatternVehicleModeOnScheduledStopPointAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointMaxOrderBy>;
  min?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointMinOrderBy>;
};

/** input type for inserting array relation for remote table "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export type ServicePatternVehicleModeOnScheduledStopPointArrRelInsertInput = {
  data: Array<ServicePatternVehicleModeOnScheduledStopPointInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointOnConflict>;
};

/** Boolean expression to filter rows from the table "service_pattern.vehicle_mode_on_scheduled_stop_point". All fields are combined with a logical 'AND'. */
export type ServicePatternVehicleModeOnScheduledStopPointBoolExp = {
  _and?: InputMaybe<
    Array<ServicePatternVehicleModeOnScheduledStopPointBoolExp>
  >;
  _not?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointBoolExp>;
  _or?: InputMaybe<Array<ServicePatternVehicleModeOnScheduledStopPointBoolExp>>;
  scheduled_stop_point_id?: InputMaybe<UuidComparisonExp>;
  vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnumComparisonExp>;
};

/** unique or primary key constraints on table "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export enum ServicePatternVehicleModeOnScheduledStopPointConstraint {
  /** unique or primary key constraint on columns "scheduled_stop_point_id", "vehicle_mode" */
  ScheduledStopPointServicedByVehicleModePkey = 'scheduled_stop_point_serviced_by_vehicle_mode_pkey',
}

/** input type for inserting data into table "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export type ServicePatternVehicleModeOnScheduledStopPointInsertInput = {
  /** The scheduled stop point that is serviced by the vehicle mode. */
  scheduled_stop_point_id?: InputMaybe<Scalars['uuid']>;
  /** The vehicle mode servicing the scheduled stop point. */
  vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnum>;
};

/** aggregate max on columns */
export type ServicePatternVehicleModeOnScheduledStopPointMaxFields = {
  __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point_max_fields';
  /** The scheduled stop point that is serviced by the vehicle mode. */
  scheduled_stop_point_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export type ServicePatternVehicleModeOnScheduledStopPointMaxOrderBy = {
  /** The scheduled stop point that is serviced by the vehicle mode. */
  scheduled_stop_point_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type ServicePatternVehicleModeOnScheduledStopPointMinFields = {
  __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point_min_fields';
  /** The scheduled stop point that is serviced by the vehicle mode. */
  scheduled_stop_point_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export type ServicePatternVehicleModeOnScheduledStopPointMinOrderBy = {
  /** The scheduled stop point that is serviced by the vehicle mode. */
  scheduled_stop_point_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export type ServicePatternVehicleModeOnScheduledStopPointMutationResponse = {
  __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<ServicePatternVehicleModeOnScheduledStopPoint>;
};

/** on_conflict condition type for table "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export type ServicePatternVehicleModeOnScheduledStopPointOnConflict = {
  constraint: ServicePatternVehicleModeOnScheduledStopPointConstraint;
  update_columns?: Array<ServicePatternVehicleModeOnScheduledStopPointUpdateColumn>;
  where?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointBoolExp>;
};

/** Ordering options when selecting data from "service_pattern.vehicle_mode_on_scheduled_stop_point". */
export type ServicePatternVehicleModeOnScheduledStopPointOrderBy = {
  scheduled_stop_point_id?: InputMaybe<OrderBy>;
  vehicle_mode?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: service_pattern.vehicle_mode_on_scheduled_stop_point */
export type ServicePatternVehicleModeOnScheduledStopPointPkColumnsInput = {
  /** The scheduled stop point that is serviced by the vehicle mode. */
  scheduled_stop_point_id: Scalars['uuid'];
  /** The vehicle mode servicing the scheduled stop point. */
  vehicle_mode: ReusableComponentsVehicleModeEnum;
};

/** select columns of table "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export enum ServicePatternVehicleModeOnScheduledStopPointSelectColumn {
  /** column name */
  ScheduledStopPointId = 'scheduled_stop_point_id',
  /** column name */
  VehicleMode = 'vehicle_mode',
}

/** input type for updating data in table "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export type ServicePatternVehicleModeOnScheduledStopPointSetInput = {
  /** The scheduled stop point that is serviced by the vehicle mode. */
  scheduled_stop_point_id?: InputMaybe<Scalars['uuid']>;
  /** The vehicle mode servicing the scheduled stop point. */
  vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnum>;
};

/** Streaming cursor of the table "service_pattern_vehicle_mode_on_scheduled_stop_point" */
export type ServicePatternVehicleModeOnScheduledStopPointStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ServicePatternVehicleModeOnScheduledStopPointStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ServicePatternVehicleModeOnScheduledStopPointStreamCursorValueInput =
  {
    /** The scheduled stop point that is serviced by the vehicle mode. */
    scheduled_stop_point_id?: InputMaybe<Scalars['uuid']>;
    /** The vehicle mode servicing the scheduled stop point. */
    vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnum>;
  };

/** update columns of table "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export enum ServicePatternVehicleModeOnScheduledStopPointUpdateColumn {
  /** column name */
  ScheduledStopPointId = 'scheduled_stop_point_id',
  /** column name */
  VehicleMode = 'vehicle_mode',
}

export type ServicePatternVehicleModeOnScheduledStopPointUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointSetInput>;
  /** filter the rows which have to be updated */
  where: ServicePatternVehicleModeOnScheduledStopPointBoolExp;
};

/** Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'. */
export type SmallintComparisonExp = {
  _eq?: InputMaybe<Scalars['smallint']>;
  _gt?: InputMaybe<Scalars['smallint']>;
  _gte?: InputMaybe<Scalars['smallint']>;
  _in?: InputMaybe<Array<Scalars['smallint']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['smallint']>;
  _lte?: InputMaybe<Scalars['smallint']>;
  _neq?: InputMaybe<Scalars['smallint']>;
  _nin?: InputMaybe<Array<Scalars['smallint']>>;
};

export type StDWithinGeographyInput = {
  distance: Scalars['Float'];
  from: Scalars['geography'];
  use_spheroid?: InputMaybe<Scalars['Boolean']>;
};

export type StDWithinInput = {
  distance: Scalars['Float'];
  from: Scalars['geometry'];
};

export type StopPlaceAccessSpacesAggregateBoolExp = {
  count?: InputMaybe<StopPlaceAccessSpacesAggregateBoolExpCount>;
};

export type StopPlaceAccessSpacesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<StopsDatabaseStopPlaceAccessSpacesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesBoolExp>;
  predicate: IntComparisonExp;
};

export type StopPlaceAlternativeNamesAggregateBoolExp = {
  count?: InputMaybe<StopPlaceAlternativeNamesAggregateBoolExpCount>;
};

export type StopPlaceAlternativeNamesAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<StopsDatabaseStopPlaceAlternativeNamesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesBoolExp>;
  predicate: IntComparisonExp;
};

export type StopPlaceChildrenAggregateBoolExp = {
  count?: InputMaybe<StopPlaceChildrenAggregateBoolExpCount>;
};

export type StopPlaceChildrenAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<StopsDatabaseStopPlaceChildrenSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
  predicate: IntComparisonExp;
};

export type StopPlaceEquipmentPlacesAggregateBoolExp = {
  count?: InputMaybe<StopPlaceEquipmentPlacesAggregateBoolExpCount>;
};

export type StopPlaceEquipmentPlacesAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<StopsDatabaseStopPlaceEquipmentPlacesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>;
  predicate: IntComparisonExp;
};

export type StopPlaceKeyValuesAggregateBoolExp = {
  count?: InputMaybe<StopPlaceKeyValuesAggregateBoolExpCount>;
};

export type StopPlaceKeyValuesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<StopsDatabaseStopPlaceKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseStopPlaceKeyValuesBoolExp>;
  predicate: IntComparisonExp;
};

export type StopPlaceQuaysAggregateBoolExp = {
  count?: InputMaybe<StopPlaceQuaysAggregateBoolExpCount>;
};

export type StopPlaceQuaysAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<StopsDatabaseStopPlaceQuaysSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseStopPlaceQuaysBoolExp>;
  predicate: IntComparisonExp;
};

export type StopPlaceTariffZonesAggregateBoolExp = {
  count?: InputMaybe<StopPlaceTariffZonesAggregateBoolExpCount>;
};

export type StopPlaceTariffZonesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<StopsDatabaseStopPlaceTariffZonesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseStopPlaceTariffZonesBoolExp>;
  predicate: IntComparisonExp;
};

export type StopRegistryStopPlaceMutation = {
  __typename?: 'stop_registryStopPlaceMutation';
  /** Adds a StopPlace to an existing ParentStopPlace */
  addToMultiModalStopPlace?: Maybe<StopRegistryParentStopPlace>;
  /** Creates a new multimodal parent StopPlace */
  createMultiModalStopPlace?: Maybe<StopRegistryParentStopPlace>;
  /** Create tag for referenced entity. */
  createTag?: Maybe<StopRegistryTag>;
  /** Hard delete group of stop places by ID */
  deleteGroupOfStopPlaces?: Maybe<Scalars['Boolean']>;
  /** !!! Deletes all versions of Parking from database - use with caution !!! */
  deleteParking?: Maybe<Scalars['Boolean']>;
  /** Removes quay from StopPlace */
  deleteQuay?: Maybe<StopRegistryStopPlaceInterface>;
  /** !!! Deletes all versions of StopPlace from database - use with caution !!! */
  deleteStopPlace?: Maybe<Scalars['Boolean']>;
  /** Merges two Quays on a StopPlace. */
  mergeQuays?: Maybe<StopRegistryStopPlaceInterface>;
  /** Merges two StopPlaces by terminating 'from'-StopPlace, and copying quays/values into 'to'-StopPlace */
  mergeStopPlaces?: Maybe<StopRegistryStopPlaceInterface>;
  /** Moves one or more quays to a new or existing stop place. Returns the destination stop place. */
  moveQuaysToStop?: Maybe<StopRegistryStopPlaceInterface>;
  /** Mutate group of stop places */
  mutateGroupOfStopPlaces?: Maybe<StopRegistryGroupOfStopPlaces>;
  /** Update existing Parent StopPlace */
  mutateParentStopPlace?: Maybe<Array<Maybe<StopRegistryParentStopPlace>>>;
  /** Create new or update existing Parking */
  mutateParking?: Maybe<Array<Maybe<StopRegistryParking>>>;
  /** Create new or update existing PathLink */
  mutatePathlink?: Maybe<Array<Maybe<StopRegistryPathLink>>>;
  /** Mutate purpose of grouping */
  mutatePurposeOfGrouping?: Maybe<StopRegistryPurposeOfGrouping>;
  /** Create new or update existing StopPlace */
  mutateStopPlace?: Maybe<Array<Maybe<StopRegistryStopPlace>>>;
  /** Removes a StopPlace from an existing ParentStopPlace */
  removeFromMultiModalStopPlace?: Maybe<StopRegistryParentStopPlace>;
  /** Remove tag from referenced entity */
  removeTag?: Maybe<StopRegistryTag>;
  /** StopPlace will be reopened and immidiately active. */
  reopenStopPlace?: Maybe<StopRegistryStopPlaceInterface>;
  /** StopPlace will be terminated and no longer be active after the given date. */
  terminateStopPlace?: Maybe<StopRegistryStopPlaceInterface>;
  /** TariffZone will be terminated and no longer be active after the given date. */
  terminateTariffZone?: Maybe<StopRegistryTariffZone>;
};

export type StopRegistryStopPlaceMutationAddToMultiModalStopPlaceArgs = {
  input?: InputMaybe<StopRegistryAddToMultiModalStopPlaceInput>;
};

export type StopRegistryStopPlaceMutationCreateMultiModalStopPlaceArgs = {
  input?: InputMaybe<StopRegistryCreateMultiModalStopPlaceInput>;
};

export type StopRegistryStopPlaceMutationCreateTagArgs = {
  comment?: InputMaybe<Scalars['String']>;
  idReference: Scalars['String'];
  name: Scalars['String'];
};

export type StopRegistryStopPlaceMutationDeleteGroupOfStopPlacesArgs = {
  id: Scalars['String'];
};

export type StopRegistryStopPlaceMutationDeleteParkingArgs = {
  parkingId: Scalars['String'];
};

export type StopRegistryStopPlaceMutationDeleteQuayArgs = {
  quayId: Scalars['String'];
  stopPlaceId: Scalars['String'];
  versionComment?: InputMaybe<Scalars['String']>;
};

export type StopRegistryStopPlaceMutationDeleteStopPlaceArgs = {
  stopPlaceId: Scalars['String'];
};

export type StopRegistryStopPlaceMutationMergeQuaysArgs = {
  dryRun?: InputMaybe<Scalars['Boolean']>;
  fromQuayId: Scalars['String'];
  stopPlaceId: Scalars['String'];
  toQuayId: Scalars['String'];
  versionComment?: InputMaybe<Scalars['String']>;
};

export type StopRegistryStopPlaceMutationMergeStopPlacesArgs = {
  dryRun?: InputMaybe<Scalars['Boolean']>;
  fromStopPlaceId: Scalars['String'];
  fromVersionComment?: InputMaybe<Scalars['String']>;
  toStopPlaceId: Scalars['String'];
  toVersionComment?: InputMaybe<Scalars['String']>;
};

export type StopRegistryStopPlaceMutationMoveQuaysToStopArgs = {
  fromVersionComment?: InputMaybe<Scalars['String']>;
  quayIds?: InputMaybe<Array<Scalars['String']>>;
  toStopPlaceId?: InputMaybe<Scalars['String']>;
  toVersionComment?: InputMaybe<Scalars['String']>;
};

export type StopRegistryStopPlaceMutationMutateGroupOfStopPlacesArgs = {
  GroupOfStopPlaces?: InputMaybe<StopRegistryGroupOfStopPlacesInput>;
};

export type StopRegistryStopPlaceMutationMutateParentStopPlaceArgs = {
  ParentStopPlace?: InputMaybe<StopRegistryParentStopPlaceInput>;
};

export type StopRegistryStopPlaceMutationMutateParkingArgs = {
  Parking?: InputMaybe<Array<InputMaybe<StopRegistryParkingInput>>>;
};

export type StopRegistryStopPlaceMutationMutatePathlinkArgs = {
  PathLink?: InputMaybe<Array<InputMaybe<StopRegistryPathLinkInput>>>;
};

export type StopRegistryStopPlaceMutationMutatePurposeOfGroupingArgs = {
  PurposeOfGrouping?: InputMaybe<StopRegistryPurposeOfGroupingInput>;
};

export type StopRegistryStopPlaceMutationMutateStopPlaceArgs = {
  StopPlace?: InputMaybe<StopRegistryStopPlaceInput>;
};

export type StopRegistryStopPlaceMutationRemoveFromMultiModalStopPlaceArgs = {
  parentSiteRef: Scalars['String'];
  stopPlaceId?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type StopRegistryStopPlaceMutationRemoveTagArgs = {
  comment?: InputMaybe<Scalars['String']>;
  idReference: Scalars['String'];
  name: Scalars['String'];
};

export type StopRegistryStopPlaceMutationReopenStopPlaceArgs = {
  stopPlaceId: Scalars['String'];
  versionComment?: InputMaybe<Scalars['String']>;
};

export type StopRegistryStopPlaceMutationTerminateStopPlaceArgs = {
  modificationEnumeration?: InputMaybe<StopRegistryModificationEnumerationType>;
  stopPlaceId: Scalars['String'];
  toDate: Scalars['stop_registry_DateTime'];
  versionComment?: InputMaybe<Scalars['String']>;
};

export type StopRegistryStopPlaceMutationTerminateTariffZoneArgs = {
  tariffZoneId: Scalars['String'];
  toDate: Scalars['stop_registry_DateTime'];
  versionComment?: InputMaybe<Scalars['String']>;
};

export type StopRegistryStopPlaceRegister = {
  __typename?: 'stop_registryStopPlaceRegister';
  /** Check if authorized for entity with role */
  checkAuthorized?: Maybe<StopRegistryAuthorizationCheck>;
  /** Fare zones */
  fareZones?: Maybe<Array<Maybe<StopRegistryFareZone>>>;
  /** List all fare zone authorities. */
  fareZonesAuthorities?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Group of stop places */
  groupOfStopPlaces?: Maybe<Array<Maybe<StopRegistryGroupOfStopPlaces>>>;
  /** Group of tariff zones */
  groupOfTariffZones?: Maybe<Array<Maybe<StopRegistryGroupOfTariffZones>>>;
  /** Find parking */
  parking?: Maybe<Array<Maybe<StopRegistryParking>>>;
  /** Find path links */
  pathLink?: Maybe<Array<Maybe<StopRegistryPathLink>>>;
  /** List all purpose of grouping */
  purposeOfGrouping?: Maybe<Array<Maybe<StopRegistryPurposeOfGrouping>>>;
  /** Search for StopPlaces */
  stopPlace?: Maybe<Array<Maybe<StopRegistryStopPlaceInterface>>>;
  /** Find StopPlaces within given BoundingBox. */
  stopPlaceBBox?: Maybe<Array<Maybe<StopRegistryStopPlaceInterface>>>;
  /** Fetches already used tags by name distinctively */
  tags?: Maybe<Array<Maybe<StopRegistryTag>>>;
  /** Tariff zones */
  tariffZones?: Maybe<Array<Maybe<StopRegistryTariffZone>>>;
  /** Find topographic places */
  topographicPlace?: Maybe<Array<Maybe<StopRegistryTopographicPlace>>>;
  /** List all valid Transportmode/Submode-combinations. */
  validTransportModes?: Maybe<Array<Maybe<StopRegistryTransportModes>>>;
};

export type StopRegistryStopPlaceRegisterCheckAuthorizedArgs = {
  id?: InputMaybe<Scalars['String']>;
};

export type StopRegistryStopPlaceRegisterFareZonesArgs = {
  authorityRef?: InputMaybe<Scalars['String']>;
  ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  page?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
  scopingMethod?: InputMaybe<StopRegistryScopingMethodEnumerationType>;
  size?: InputMaybe<Scalars['Int']>;
  zoneTopology?: InputMaybe<StopRegistryZoneTopologyEnumerationType>;
};

export type StopRegistryStopPlaceRegisterGroupOfStopPlacesArgs = {
  id?: InputMaybe<Scalars['String']>;
  page?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
  size?: InputMaybe<Scalars['Int']>;
  stopPlaceId?: InputMaybe<Scalars['String']>;
};

export type StopRegistryStopPlaceRegisterGroupOfTariffZonesArgs = {
  id?: InputMaybe<Scalars['String']>;
  page?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
  size?: InputMaybe<Scalars['Int']>;
  tariffZoneId?: InputMaybe<Scalars['String']>;
};

export type StopRegistryStopPlaceRegisterParkingArgs = {
  allVersions?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['String']>;
  page?: InputMaybe<Scalars['Int']>;
  size?: InputMaybe<Scalars['Int']>;
  stopPlaceId?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['Int']>;
};

export type StopRegistryStopPlaceRegisterPathLinkArgs = {
  allVersions?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['String']>;
  stopPlaceId?: InputMaybe<Scalars['String']>;
};

export type StopRegistryStopPlaceRegisterPurposeOfGroupingArgs = {
  id?: InputMaybe<Scalars['String']>;
  page?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
  size?: InputMaybe<Scalars['Int']>;
};

export type StopRegistryStopPlaceRegisterStopPlaceArgs = {
  allVersions?: InputMaybe<Scalars['Boolean']>;
  code?: InputMaybe<Scalars['String']>;
  countryReference?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  countyReference?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  hasParking?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['String']>;
  importedId?: InputMaybe<Scalars['String']>;
  key?: InputMaybe<Scalars['String']>;
  municipalityReference?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  onlyMonomodalStopPlaces?: InputMaybe<Scalars['Boolean']>;
  page?: InputMaybe<Scalars['Int']>;
  pointInTime?: InputMaybe<Scalars['stop_registry_DateTime']>;
  query?: InputMaybe<Scalars['String']>;
  size?: InputMaybe<Scalars['Int']>;
  stopPlaceType?: InputMaybe<Array<InputMaybe<StopRegistryStopPlaceType>>>;
  tags?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  version?: InputMaybe<Scalars['Int']>;
  versionValidity?: InputMaybe<StopRegistryVersionValidity>;
  withDuplicatedQuayImportedIds?: InputMaybe<Scalars['Boolean']>;
  withNearbySimilarDuplicates?: InputMaybe<Scalars['Boolean']>;
  withTags?: InputMaybe<Scalars['Boolean']>;
  withoutLocationOnly?: InputMaybe<Scalars['Boolean']>;
  withoutQuaysOnly?: InputMaybe<Scalars['Boolean']>;
};

export type StopRegistryStopPlaceRegisterStopPlaceBBoxArgs = {
  ignoreStopPlaceId?: InputMaybe<Scalars['String']>;
  includeExpired?: InputMaybe<Scalars['Boolean']>;
  latMax: Scalars['stop_registry_BigDecimal'];
  latMin: Scalars['stop_registry_BigDecimal'];
  lonMax: Scalars['stop_registry_BigDecimal'];
  lonMin: Scalars['stop_registry_BigDecimal'];
  page?: InputMaybe<Scalars['Int']>;
  pointInTime?: InputMaybe<Scalars['stop_registry_DateTime']>;
  size?: InputMaybe<Scalars['Int']>;
};

export type StopRegistryStopPlaceRegisterTagsArgs = {
  name: Scalars['String'];
};

export type StopRegistryStopPlaceRegisterTariffZonesArgs = {
  ids?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  page?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
  size?: InputMaybe<Scalars['Int']>;
};

export type StopRegistryStopPlaceRegisterTopographicPlaceArgs = {
  allVersions?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['String']>;
  query?: InputMaybe<Scalars['String']>;
  topographicPlaceType?: InputMaybe<StopRegistryTopographicPlaceType>;
};

export type StopRegistryAccessibilityAssessment = {
  __typename?: 'stop_registry_AccessibilityAssessment';
  id?: Maybe<Scalars['String']>;
  limitations?: Maybe<StopRegistryAccessibilityLimitations>;
  mobilityImpairedAccess?: Maybe<StopRegistryLimitationStatusType>;
  version?: Maybe<Scalars['String']>;
};

export type StopRegistryAccessibilityAssessmentInput = {
  id?: InputMaybe<Scalars['String']>;
  limitations?: InputMaybe<StopRegistryAccessibilityLimitationsInput>;
};

export type StopRegistryAccessibilityLimitations = {
  __typename?: 'stop_registry_AccessibilityLimitations';
  audibleSignalsAvailable?: Maybe<StopRegistryLimitationStatusType>;
  escalatorFreeAccess?: Maybe<StopRegistryLimitationStatusType>;
  id?: Maybe<Scalars['String']>;
  liftFreeAccess?: Maybe<StopRegistryLimitationStatusType>;
  stepFreeAccess?: Maybe<StopRegistryLimitationStatusType>;
  version?: Maybe<Scalars['String']>;
  wheelchairAccess?: Maybe<StopRegistryLimitationStatusType>;
};

export type StopRegistryAccessibilityLimitationsInput = {
  audibleSignalsAvailable: StopRegistryLimitationStatusType;
  escalatorFreeAccess: StopRegistryLimitationStatusType;
  id?: InputMaybe<Scalars['String']>;
  liftFreeAccess: StopRegistryLimitationStatusType;
  stepFreeAccess: StopRegistryLimitationStatusType;
  wheelchairAccess: StopRegistryLimitationStatusType;
};

export type StopRegistryAddressablePlace = {
  __typename?: 'stop_registry_AddressablePlace';
  /** This field is set either on StopPlace (i.e. all Quays are equal), or on every Quay. */
  accessibilityAssessment?: Maybe<StopRegistryAccessibilityAssessment>;
  description?: Maybe<StopRegistryEmbeddableMultilingualString>;
  geometry?: Maybe<StopRegistryGeoJson>;
  id?: Maybe<Scalars['String']>;
  importedId?: Maybe<Array<Maybe<Scalars['String']>>>;
  keyValues?: Maybe<Array<Maybe<StopRegistryKeyValues>>>;
  modificationEnumeration?: Maybe<StopRegistryModificationEnumerationType>;
  name?: Maybe<StopRegistryEmbeddableMultilingualString>;
  placeEquipments?: Maybe<StopRegistryPlaceEquipments>;
  polygon?: Maybe<StopRegistryGeoJson>;
  privateCode?: Maybe<StopRegistryPrivateCode>;
  publicCode?: Maybe<Scalars['String']>;
  shortName?: Maybe<StopRegistryEmbeddableMultilingualString>;
  validBetween?: Maybe<StopRegistryValidBetween>;
  version?: Maybe<Scalars['String']>;
};

export type StopRegistryAlternativeName = {
  __typename?: 'stop_registry_AlternativeName';
  name: StopRegistryEmbeddableMultilingualString;
  nameType: StopRegistryNameType;
};

export type StopRegistryAlternativeNameInput = {
  name: StopRegistryEmbeddableMultilingualStringInput;
  nameType?: InputMaybe<StopRegistryNameType>;
};

/** Check if authorized for entity with role */
export type StopRegistryAuthorizationCheck = {
  __typename?: 'stop_registry_AuthorizationCheck';
  /** The identificatior for entity */
  id?: Maybe<Scalars['String']>;
  /** The relevant roles for the given ID */
  roles?: Maybe<Array<Maybe<Scalars['String']>>>;
};

export type StopRegistryBoardingPosition = {
  __typename?: 'stop_registry_BoardingPosition';
  geometry?: Maybe<StopRegistryGeoJson>;
  id?: Maybe<Scalars['String']>;
  publicCode?: Maybe<Scalars['String']>;
};

export type StopRegistryBoardingPositionInput = {
  geometry?: InputMaybe<StopRegistryGeoJsonInput>;
  id?: InputMaybe<Scalars['String']>;
  publicCode?: InputMaybe<Scalars['String']>;
};

export type StopRegistryCycleStorageEquipment = {
  __typename?: 'stop_registry_CycleStorageEquipment';
  cycleStorageType?: Maybe<StopRegistryCycleStorageType>;
  id?: Maybe<Scalars['String']>;
  numberOfSpaces?: Maybe<Scalars['stop_registry_BigInteger']>;
};

export type StopRegistryCycleStorageEquipmentInput = {
  cycleStorageType?: InputMaybe<StopRegistryCycleStorageType>;
  numberOfSpaces?: InputMaybe<Scalars['stop_registry_BigInteger']>;
};

export type StopRegistryEmbeddableMultilingualString = {
  __typename?: 'stop_registry_EmbeddableMultilingualString';
  lang?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

export type StopRegistryEmbeddableMultilingualStringInput = {
  lang?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** The version of the referenced entity. */
export type StopRegistryEntityRef = {
  __typename?: 'stop_registry_EntityRef';
  addressablePlace?: Maybe<StopRegistryAddressablePlace>;
  ref?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['String']>;
};

/** A reference to an entity with version */
export type StopRegistryEntityRefInput = {
  /** The NeTEx ID of the of the referenced entity. The reference must already exist */
  ref: Scalars['String'];
  /** The version of the referenced entity. */
  version?: InputMaybe<Scalars['String']>;
};

export type StopRegistryFareZone = {
  __typename?: 'stop_registry_FareZone';
  authorityRef?: Maybe<Scalars['String']>;
  description?: Maybe<StopRegistryEmbeddableMultilingualString>;
  geometry?: Maybe<StopRegistryGeoJson>;
  id?: Maybe<Scalars['String']>;
  importedId?: Maybe<Array<Maybe<Scalars['String']>>>;
  keyValues?: Maybe<Array<Maybe<StopRegistryKeyValues>>>;
  members?: Maybe<Array<Maybe<StopRegistryStopPlace>>>;
  name?: Maybe<StopRegistryEmbeddableMultilingualString>;
  neighbours?: Maybe<Array<Maybe<StopRegistryFareZone>>>;
  polygon?: Maybe<StopRegistryGeoJson>;
  privateCode?: Maybe<StopRegistryPrivateCode>;
  scopingMethod?: Maybe<StopRegistryScopingMethodEnumerationType>;
  shortName?: Maybe<StopRegistryEmbeddableMultilingualString>;
  validBetween?: Maybe<StopRegistryValidBetween>;
  version?: Maybe<Scalars['String']>;
  zoneTopology?: Maybe<StopRegistryZoneTopologyEnumerationType>;
};

export type StopRegistryGeneralSign = {
  __typename?: 'stop_registry_GeneralSign';
  content?: Maybe<StopRegistryEmbeddableMultilingualString>;
  id?: Maybe<Scalars['String']>;
  lineSignage?: Maybe<Scalars['Boolean']>;
  mainLineSign?: Maybe<Scalars['Boolean']>;
  note?: Maybe<StopRegistryEmbeddableMultilingualString>;
  numberOfFrames?: Maybe<Scalars['Int']>;
  privateCode?: Maybe<StopRegistryPrivateCode>;
  replacesRailSign?: Maybe<Scalars['Boolean']>;
  signContentType?: Maybe<StopRegistrySignContentType>;
};

export type StopRegistryGeneralSignInput = {
  content?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  lineSignage?: InputMaybe<Scalars['Boolean']>;
  mainLineSign?: InputMaybe<Scalars['Boolean']>;
  note?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  numberOfFrames?: InputMaybe<Scalars['Int']>;
  privateCode?: InputMaybe<StopRegistryPrivateCodeInput>;
  replacesRailSign?: InputMaybe<Scalars['Boolean']>;
  signContentType?: InputMaybe<StopRegistrySignContentType>;
};

/** Geometry-object as specified in the GeoJSON-standard (http://geojson.org/geojson-spec.html). */
export type StopRegistryGeoJson = {
  __typename?: 'stop_registry_GeoJSON';
  coordinates?: Maybe<Scalars['stop_registry_Coordinates']>;
  type?: Maybe<StopRegistryGeoJsonType>;
};

/** Geometry-object as specified in the GeoJSON-standard (http://geojson.org/geojson-spec.html). */
export type StopRegistryGeoJsonInput = {
  coordinates: Scalars['stop_registry_Coordinates'];
  type: StopRegistryGeoJsonType;
};

export enum StopRegistryGeoJsonType {
  GeometryCollection = 'GeometryCollection',
  LineString = 'LineString',
  MultiLineString = 'MultiLineString',
  MultiPoint = 'MultiPoint',
  MultiPolygon = 'MultiPolygon',
  Point = 'Point',
  Polygon = 'Polygon',
}

export type StopRegistryGroupOfStopPlaces = {
  __typename?: 'stop_registry_GroupOfStopPlaces';
  description?: Maybe<StopRegistryEmbeddableMultilingualString>;
  id?: Maybe<Scalars['String']>;
  members?: Maybe<Array<Maybe<StopRegistryStopPlaceInterface>>>;
  name?: Maybe<StopRegistryEmbeddableMultilingualString>;
  purposeOfGrouping?: Maybe<StopRegistryPurposeOfGrouping>;
  shortName?: Maybe<StopRegistryEmbeddableMultilingualString>;
  version?: Maybe<Scalars['String']>;
  versionComment?: Maybe<Scalars['String']>;
};

export type StopRegistryGroupOfStopPlacesInput = {
  alternativeNames?: InputMaybe<
    Array<InputMaybe<StopRegistryAlternativeNameInput>>
  >;
  description?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  /** Ignore ID when creating new */
  id?: InputMaybe<Scalars['String']>;
  /** References to group of stop places members. Stop place IDs. */
  members?: InputMaybe<
    Array<InputMaybe<StopRegistryVersionLessEntityRefInput>>
  >;
  name: StopRegistryEmbeddableMultilingualStringInput;
  /** References to purpose of grouping */
  purposeOfGrouping?: InputMaybe<StopRegistryVersionLessEntityRefInput>;
  shortName?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  versionComment?: InputMaybe<Scalars['String']>;
};

export type StopRegistryGroupOfTariffZones = {
  __typename?: 'stop_registry_GroupOfTariffZones';
  description?: Maybe<StopRegistryEmbeddableMultilingualString>;
  id?: Maybe<Scalars['String']>;
  members?: Maybe<Array<Maybe<StopRegistryFareZone>>>;
  name?: Maybe<StopRegistryEmbeddableMultilingualString>;
  version?: Maybe<Scalars['String']>;
  versionComment?: Maybe<Scalars['String']>;
};

export enum StopRegistryInterchangeWeightingType {
  InterchangeAllowed = 'interchangeAllowed',
  NoInterchange = 'noInterchange',
  PreferredInterchange = 'preferredInterchange',
  RecommendedInterchange = 'recommendedInterchange',
}

export type StopRegistryKeyValues = {
  __typename?: 'stop_registry_KeyValues';
  key?: Maybe<Scalars['String']>;
  values?: Maybe<Array<Maybe<Scalars['String']>>>;
};

export type StopRegistryKeyValuesInput = {
  key?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export enum StopRegistryLimitationStatusType {
  False = 'FALSE',
  Partial = 'PARTIAL',
  True = 'TRUE',
  Unknown = 'UNKNOWN',
}

export enum StopRegistryModificationEnumerationType {
  Delete = 'delete',
  Delta = 'delta',
  New = 'new',
  Revise = 'revise',
}

export type StopRegistryParentStopPlace = StopRegistryStopPlaceInterface & {
  __typename?: 'stop_registry_ParentStopPlace';
  /** This field is set either on StopPlace (i.e. all Quays are equal), or on every Quay. */
  accessibilityAssessment?: Maybe<StopRegistryAccessibilityAssessment>;
  alternativeNames?: Maybe<Array<Maybe<StopRegistryAlternativeName>>>;
  changedBy?: Maybe<Scalars['String']>;
  children?: Maybe<Array<Maybe<StopRegistryStopPlace>>>;
  description?: Maybe<StopRegistryEmbeddableMultilingualString>;
  fareZones?: Maybe<Array<Maybe<StopRegistryFareZone>>>;
  geometry?: Maybe<StopRegistryGeoJson>;
  groups?: Maybe<Array<Maybe<StopRegistryGroupOfStopPlaces>>>;
  id?: Maybe<Scalars['String']>;
  importedId?: Maybe<Array<Maybe<Scalars['String']>>>;
  keyValues?: Maybe<Array<Maybe<StopRegistryKeyValues>>>;
  modificationEnumeration?: Maybe<StopRegistryModificationEnumerationType>;
  name?: Maybe<StopRegistryEmbeddableMultilingualString>;
  placeEquipments?: Maybe<StopRegistryPlaceEquipments>;
  polygon?: Maybe<StopRegistryGeoJson>;
  privateCode?: Maybe<StopRegistryPrivateCode>;
  publicCode?: Maybe<Scalars['String']>;
  shortName?: Maybe<StopRegistryEmbeddableMultilingualString>;
  tags?: Maybe<Array<Maybe<StopRegistryTag>>>;
  tariffZones?: Maybe<Array<Maybe<StopRegistryTariffZone>>>;
  topographicPlace?: Maybe<StopRegistryTopographicPlace>;
  validBetween?: Maybe<StopRegistryValidBetween>;
  version?: Maybe<Scalars['String']>;
  versionComment?: Maybe<Scalars['String']>;
};

export type StopRegistryParentStopPlaceInput = {
  /** This field is set either on StopPlace (i.e. all Quays are equal), or on every Quay. */
  accessibilityAssessment?: InputMaybe<StopRegistryAccessibilityAssessmentInput>;
  alternativeNames?: InputMaybe<
    Array<InputMaybe<StopRegistryAlternativeNameInput>>
  >;
  children?: InputMaybe<Array<InputMaybe<StopRegistryStopPlaceInput>>>;
  description?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  geometry?: InputMaybe<StopRegistryGeoJsonInput>;
  /** Ignore when creating new */
  id?: InputMaybe<Scalars['String']>;
  keyValues?: InputMaybe<Array<InputMaybe<StopRegistryKeyValuesInput>>>;
  name?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  placeEquipments?: InputMaybe<StopRegistryPlaceEquipmentsInput>;
  privateCode?: InputMaybe<StopRegistryPrivateCodeInput>;
  publicCode?: InputMaybe<Scalars['String']>;
  shortName?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  submode?: InputMaybe<StopRegistrySubmodeType>;
  transportMode?: InputMaybe<StopRegistryTransportModeType>;
  validBetween?: InputMaybe<StopRegistryValidBetweenInput>;
  versionComment?: InputMaybe<Scalars['String']>;
};

export type StopRegistryParking = {
  __typename?: 'stop_registry_Parking';
  bookingUrl?: Maybe<Scalars['String']>;
  freeParkingOutOfHours?: Maybe<Scalars['Boolean']>;
  geometry?: Maybe<StopRegistryGeoJson>;
  id?: Maybe<Scalars['String']>;
  name?: Maybe<StopRegistryEmbeddableMultilingualString>;
  overnightParkingPermitted?: Maybe<Scalars['Boolean']>;
  parentSiteRef?: Maybe<Scalars['String']>;
  parkingAreas?: Maybe<Array<Maybe<StopRegistryParkingArea>>>;
  parkingLayout?: Maybe<StopRegistryParkingLayoutType>;
  parkingPaymentProcess?: Maybe<
    Array<Maybe<StopRegistryParkingPaymentProcessType>>
  >;
  parkingProperties?: Maybe<Array<Maybe<StopRegistryParkingProperties>>>;
  parkingReservation?: Maybe<StopRegistryParkingReservationType>;
  parkingType?: Maybe<StopRegistryParkingType>;
  parkingVehicleTypes?: Maybe<Array<Maybe<StopRegistryParkingVehicleType>>>;
  principalCapacity?: Maybe<Scalars['stop_registry_BigInteger']>;
  realTimeOccupancyAvailable?: Maybe<Scalars['Boolean']>;
  rechargingAvailable?: Maybe<Scalars['Boolean']>;
  secure?: Maybe<Scalars['Boolean']>;
  totalCapacity?: Maybe<Scalars['stop_registry_BigInteger']>;
  validBetween?: Maybe<StopRegistryValidBetween>;
  version?: Maybe<Scalars['String']>;
};

export type StopRegistryParkingArea = {
  __typename?: 'stop_registry_ParkingArea';
  label?: Maybe<StopRegistryEmbeddableMultilingualString>;
  parkingProperties?: Maybe<StopRegistryParkingProperties>;
  totalCapacity?: Maybe<Scalars['stop_registry_BigInteger']>;
};

export type StopRegistryParkingAreaInput = {
  label?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  parkingProperties?: InputMaybe<StopRegistryParkingPropertiesInput>;
  totalCapacity?: InputMaybe<Scalars['stop_registry_BigInteger']>;
};

export type StopRegistryParkingCapacity = {
  __typename?: 'stop_registry_ParkingCapacity';
  numberOfSpaces?: Maybe<Scalars['stop_registry_BigInteger']>;
  numberOfSpacesWithRechargePoint?: Maybe<Scalars['stop_registry_BigInteger']>;
  parkingStayType?: Maybe<StopRegistryParkingStayType>;
  parkingUserType?: Maybe<StopRegistryParkingUserType>;
  parkingVehicleType?: Maybe<StopRegistryParkingVehicleType>;
};

export type StopRegistryParkingCapacityInput = {
  numberOfSpaces?: InputMaybe<Scalars['stop_registry_BigInteger']>;
  numberOfSpacesWithRechargePoint?: InputMaybe<
    Scalars['stop_registry_BigInteger']
  >;
  parkingStayType?: InputMaybe<StopRegistryParkingStayType>;
  parkingUserType?: InputMaybe<StopRegistryParkingUserType>;
  parkingVehicleType?: InputMaybe<StopRegistryParkingVehicleType>;
};

export type StopRegistryParkingInput = {
  bookingUrl?: InputMaybe<Scalars['String']>;
  freeParkingOutOfHours?: InputMaybe<Scalars['Boolean']>;
  geometry?: InputMaybe<StopRegistryGeoJsonInput>;
  id?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  overnightParkingPermitted?: InputMaybe<Scalars['Boolean']>;
  parentSiteRef?: InputMaybe<Scalars['String']>;
  parkingAreas?: InputMaybe<Array<InputMaybe<StopRegistryParkingAreaInput>>>;
  parkingLayout?: InputMaybe<StopRegistryParkingLayoutType>;
  parkingPaymentProcess?: InputMaybe<
    Array<InputMaybe<StopRegistryParkingPaymentProcessType>>
  >;
  parkingProperties?: InputMaybe<
    Array<InputMaybe<StopRegistryParkingPropertiesInput>>
  >;
  parkingReservation?: InputMaybe<StopRegistryParkingReservationType>;
  parkingType?: InputMaybe<StopRegistryParkingType>;
  parkingVehicleTypes?: InputMaybe<
    Array<InputMaybe<StopRegistryParkingVehicleType>>
  >;
  principalCapacity?: InputMaybe<Scalars['stop_registry_BigInteger']>;
  realTimeOccupancyAvailable?: InputMaybe<Scalars['Boolean']>;
  rechargingAvailable?: InputMaybe<Scalars['Boolean']>;
  secure?: InputMaybe<Scalars['Boolean']>;
  totalCapacity?: InputMaybe<Scalars['stop_registry_BigInteger']>;
  validBetween?: InputMaybe<StopRegistryValidBetweenInput>;
};

export enum StopRegistryParkingLayoutType {
  Covered = 'covered',
  CycleHire = 'cycleHire',
  Multistorey = 'multistorey',
  OpenSpace = 'openSpace',
  Other = 'other',
  Roadside = 'roadside',
  Undefined = 'undefined',
  Underground = 'underground',
}

export enum StopRegistryParkingPaymentProcessType {
  Free = 'free',
  Other = 'other',
  PayAndDisplay = 'payAndDisplay',
  PayAtBay = 'payAtBay',
  PayAtExitBoothManualCollection = 'payAtExitBoothManualCollection',
  PayAtMachineOnFootPriorToExit = 'payAtMachineOnFootPriorToExit',
  PayByMobileDevice = 'payByMobileDevice',
  PayByPrepaidToken = 'payByPrepaidToken',
  Undefined = 'undefined',
}

export type StopRegistryParkingProperties = {
  __typename?: 'stop_registry_ParkingProperties';
  maximumStay?: Maybe<Scalars['stop_registry_BigInteger']>;
  parkingUserTypes?: Maybe<Array<Maybe<StopRegistryParkingUserType>>>;
  spaces?: Maybe<Array<Maybe<StopRegistryParkingCapacity>>>;
};

export type StopRegistryParkingPropertiesInput = {
  maximumStay?: InputMaybe<Scalars['stop_registry_BigInteger']>;
  parkingUserTypes?: InputMaybe<Array<InputMaybe<StopRegistryParkingUserType>>>;
  spaces?: InputMaybe<Array<InputMaybe<StopRegistryParkingCapacityInput>>>;
};

export enum StopRegistryParkingReservationType {
  NoReservations = 'noReservations',
  Other = 'other',
  RegistrationRequired = 'registrationRequired',
  ReservationAllowed = 'reservationAllowed',
  ReservationRequired = 'reservationRequired',
}

export enum StopRegistryParkingStayType {
  All = 'all',
  Dropoff = 'dropoff',
  LongTerm = 'longTerm',
  MidTerm = 'midTerm',
  Other = 'other',
  ShortStay = 'shortStay',
  Unlimited = 'unlimited',
}

export enum StopRegistryParkingType {
  AirportParking = 'airportParking',
  CycleRental = 'cycleRental',
  ExhibitionCentreParking = 'exhibitionCentreParking',
  LiftShareParking = 'liftShareParking',
  MotorwayParking = 'motorwayParking',
  Other = 'other',
  ParkAndRide = 'parkAndRide',
  ParkingZone = 'parkingZone',
  RentalCarParking = 'rentalCarParking',
  Roadside = 'roadside',
  ShoppingCentreParking = 'shoppingCentreParking',
  TrainStationParking = 'trainStationParking',
  Undefined = 'undefined',
  UrbanParking = 'urbanParking',
}

export enum StopRegistryParkingUserType {
  All = 'all',
  AllUsers = 'allUsers',
  Doctors = 'doctors',
  EmergencyServices = 'emergencyServices',
  Other = 'other',
  Registered = 'registered',
  RegisteredDisabled = 'registeredDisabled',
  Rental = 'rental',
  ReservationHolders = 'reservationHolders',
  ResidentsWithPermits = 'residentsWithPermits',
  Staff = 'staff',
  Visitors = 'visitors',
}

export enum StopRegistryParkingVehicleType {
  AgriculturalVehicle = 'agriculturalVehicle',
  All = 'all',
  AllPassengerVehicles = 'allPassengerVehicles',
  ArticulatedVehicle = 'articulatedVehicle',
  Bus = 'bus',
  CamperCar = 'camperCar',
  Car = 'car',
  CarWithCaravan = 'carWithCaravan',
  CarWithTrailer = 'carWithTrailer',
  FourWheelDrive = 'fourWheelDrive',
  HeavyGoodsVehicle = 'heavyGoodsVehicle',
  HeavyGoodsVehicleWithTrailer = 'heavyGoodsVehicleWithTrailer',
  HighSidedVehicle = 'highSidedVehicle',
  LargeCar = 'largeCar',
  LargeVan = 'largeVan',
  LightGoodsVehicle = 'lightGoodsVehicle',
  LightGoodsVehicleWithTrailer = 'lightGoodsVehicleWithTrailer',
  Minibus = 'minibus',
  Moped = 'moped',
  MotorScooter = 'motorScooter',
  Motorcycle = 'motorcycle',
  MotorcycleWithSidecar = 'motorcycleWithSidecar',
  Other = 'other',
  PassengerCar = 'passengerCar',
  PedalCycle = 'pedalCycle',
  SmallCar = 'smallCar',
  Tanker = 'tanker',
  Taxi = 'taxi',
  ThreeWheeledVehicle = 'threeWheeledVehicle',
  Tram = 'tram',
  Truck = 'truck',
  TwoWheeledVehicle = 'twoWheeledVehicle',
  Undefined = 'undefined',
  Van = 'van',
  VehicleWithTrailer = 'vehicleWithTrailer',
}

export type StopRegistryPathLink = {
  __typename?: 'stop_registry_PathLink';
  from?: Maybe<StopRegistryPathLinkEnd>;
  geometry?: Maybe<StopRegistryGeoJson>;
  id?: Maybe<Scalars['String']>;
  to?: Maybe<StopRegistryPathLinkEnd>;
  transferDuration?: Maybe<StopRegistryTransferDuration>;
  version?: Maybe<Scalars['String']>;
};

export type StopRegistryPathLinkEnd = {
  __typename?: 'stop_registry_PathLinkEnd';
  id?: Maybe<Scalars['String']>;
  placeRef?: Maybe<StopRegistryEntityRef>;
};

export type StopRegistryPathLinkEndInput = {
  placeRef?: InputMaybe<StopRegistryEntityRefInput>;
};

/** Transfer durations in seconds */
export type StopRegistryPathLinkInput = {
  from?: InputMaybe<StopRegistryPathLinkEndInput>;
  geometry?: InputMaybe<StopRegistryGeoJsonInput>;
  id?: InputMaybe<Scalars['String']>;
  to?: InputMaybe<StopRegistryPathLinkEndInput>;
  transferDuration?: InputMaybe<StopRegistryTransferDurationInput>;
};

export type StopRegistryPlaceEquipments = {
  __typename?: 'stop_registry_PlaceEquipments';
  cycleStorageEquipment?: Maybe<
    Array<Maybe<StopRegistryCycleStorageEquipment>>
  >;
  generalSign?: Maybe<Array<Maybe<StopRegistryGeneralSign>>>;
  id?: Maybe<Scalars['String']>;
  sanitaryEquipment?: Maybe<Array<Maybe<StopRegistrySanitaryEquipment>>>;
  shelterEquipment?: Maybe<Array<Maybe<StopRegistryShelterEquipment>>>;
  ticketingEquipment?: Maybe<Array<Maybe<StopRegistryTicketingEquipment>>>;
  waitingRoomEquipment?: Maybe<Array<Maybe<StopRegistryWaitingRoomEquipment>>>;
};

export type StopRegistryPlaceEquipmentsInput = {
  cycleStorageEquipment?: InputMaybe<
    Array<InputMaybe<StopRegistryCycleStorageEquipmentInput>>
  >;
  generalSign?: InputMaybe<Array<InputMaybe<StopRegistryGeneralSignInput>>>;
  sanitaryEquipment?: InputMaybe<
    Array<InputMaybe<StopRegistrySanitaryEquipmentInput>>
  >;
  shelterEquipment?: InputMaybe<
    Array<InputMaybe<StopRegistryShelterEquipmentInput>>
  >;
  ticketingEquipment?: InputMaybe<
    Array<InputMaybe<StopRegistryTicketingEquipmentInput>>
  >;
  waitingRoomEquipment?: InputMaybe<
    Array<InputMaybe<StopRegistryWaitingRoomEquipmentInput>>
  >;
};

export type StopRegistryPrivateCode = {
  __typename?: 'stop_registry_PrivateCode';
  type?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

export type StopRegistryPrivateCodeInput = {
  type?: InputMaybe<Scalars['String']>;
  value: Scalars['String'];
};

export type StopRegistryPurposeOfGrouping = {
  __typename?: 'stop_registry_PurposeOfGrouping';
  description?: Maybe<StopRegistryEmbeddableMultilingualString>;
  id?: Maybe<Scalars['String']>;
  name?: Maybe<StopRegistryEmbeddableMultilingualString>;
  version?: Maybe<Scalars['String']>;
  versionComment?: Maybe<Scalars['String']>;
};

export type StopRegistryPurposeOfGroupingInput = {
  description?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  /** Ignore ID when creating new */
  id?: InputMaybe<Scalars['String']>;
  name: StopRegistryEmbeddableMultilingualStringInput;
  versionComment?: InputMaybe<Scalars['String']>;
};

export type StopRegistryQuay = {
  __typename?: 'stop_registry_Quay';
  /** This field is set either on StopPlace (i.e. all Quays are equal), or on every Quay. */
  accessibilityAssessment?: Maybe<StopRegistryAccessibilityAssessment>;
  alternativeNames?: Maybe<Array<Maybe<StopRegistryAlternativeName>>>;
  boardingPositions?: Maybe<Array<Maybe<StopRegistryBoardingPosition>>>;
  compassBearing?: Maybe<Scalars['stop_registry_BigDecimal']>;
  description?: Maybe<StopRegistryEmbeddableMultilingualString>;
  geometry?: Maybe<StopRegistryGeoJson>;
  id?: Maybe<Scalars['String']>;
  importedId?: Maybe<Array<Maybe<Scalars['String']>>>;
  keyValues?: Maybe<Array<Maybe<StopRegistryKeyValues>>>;
  modificationEnumeration?: Maybe<StopRegistryModificationEnumerationType>;
  name?: Maybe<StopRegistryEmbeddableMultilingualString>;
  placeEquipments?: Maybe<StopRegistryPlaceEquipments>;
  polygon?: Maybe<StopRegistryGeoJson>;
  privateCode?: Maybe<StopRegistryPrivateCode>;
  publicCode?: Maybe<Scalars['String']>;
  shortName?: Maybe<StopRegistryEmbeddableMultilingualString>;
  validBetween?: Maybe<StopRegistryValidBetween>;
  version?: Maybe<Scalars['String']>;
};

export type StopRegistryQuayInput = {
  /** This field is set either on StopPlace (i.e. all Quays are equal), or on every Quay. */
  accessibilityAssessment?: InputMaybe<StopRegistryAccessibilityAssessmentInput>;
  alternativeNames?: InputMaybe<
    Array<InputMaybe<StopRegistryAlternativeNameInput>>
  >;
  boardingPositions?: InputMaybe<
    Array<InputMaybe<StopRegistryBoardingPositionInput>>
  >;
  compassBearing?: InputMaybe<Scalars['stop_registry_BigDecimal']>;
  description?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  geometry?: InputMaybe<StopRegistryGeoJsonInput>;
  /** Ignore when creating new */
  id?: InputMaybe<Scalars['String']>;
  keyValues?: InputMaybe<Array<InputMaybe<StopRegistryKeyValuesInput>>>;
  name?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  placeEquipments?: InputMaybe<StopRegistryPlaceEquipmentsInput>;
  privateCode?: InputMaybe<StopRegistryPrivateCodeInput>;
  publicCode?: InputMaybe<Scalars['String']>;
  shortName?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
};

export type StopRegistrySanitaryEquipment = {
  __typename?: 'stop_registry_SanitaryEquipment';
  gender?: Maybe<StopRegistryGender>;
  id?: Maybe<Scalars['String']>;
  numberOfToilets?: Maybe<Scalars['stop_registry_BigInteger']>;
};

export type StopRegistrySanitaryEquipmentInput = {
  gender?: InputMaybe<StopRegistryGender>;
  numberOfToilets?: InputMaybe<Scalars['stop_registry_BigInteger']>;
};

export enum StopRegistryScopingMethodEnumerationType {
  ExplicitPeripheryStops = 'explicitPeripheryStops',
  ExplicitStops = 'explicitStops',
  ImplicitSpatialProjection = 'implicitSpatialProjection',
  Other = 'other',
}

export type StopRegistryShelterEquipment = {
  __typename?: 'stop_registry_ShelterEquipment';
  enclosed?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['String']>;
  seats?: Maybe<Scalars['stop_registry_BigInteger']>;
  stepFree?: Maybe<Scalars['Boolean']>;
};

export type StopRegistryShelterEquipmentInput = {
  enclosed?: InputMaybe<Scalars['Boolean']>;
  seats?: InputMaybe<Scalars['stop_registry_BigInteger']>;
  stepFree?: InputMaybe<Scalars['Boolean']>;
};

export type StopRegistryStopPlace = StopRegistryStopPlaceInterface & {
  __typename?: 'stop_registry_StopPlace';
  /** This field is set either on StopPlace (i.e. all Quays are equal), or on every Quay. */
  accessibilityAssessment?: Maybe<StopRegistryAccessibilityAssessment>;
  /** Any references to another SITE of which this STOP PLACE is deemed to be a nearby but distinct. */
  adjacentSites?: Maybe<Array<Maybe<StopRegistryVersionLessEntityRef>>>;
  alternativeNames?: Maybe<Array<Maybe<StopRegistryAlternativeName>>>;
  changedBy?: Maybe<Scalars['String']>;
  description?: Maybe<StopRegistryEmbeddableMultilingualString>;
  fareZones?: Maybe<Array<Maybe<StopRegistryFareZone>>>;
  geometry?: Maybe<StopRegistryGeoJson>;
  groups?: Maybe<Array<Maybe<StopRegistryGroupOfStopPlaces>>>;
  id?: Maybe<Scalars['String']>;
  importedId?: Maybe<Array<Maybe<Scalars['String']>>>;
  keyValues?: Maybe<Array<Maybe<StopRegistryKeyValues>>>;
  modificationEnumeration?: Maybe<StopRegistryModificationEnumerationType>;
  name?: Maybe<StopRegistryEmbeddableMultilingualString>;
  parentSiteRef?: Maybe<Scalars['String']>;
  placeEquipments?: Maybe<StopRegistryPlaceEquipments>;
  polygon?: Maybe<StopRegistryGeoJson>;
  privateCode?: Maybe<StopRegistryPrivateCode>;
  publicCode?: Maybe<Scalars['String']>;
  quays?: Maybe<Array<Maybe<StopRegistryQuay>>>;
  scheduled_stop_point?: Maybe<ServicePatternScheduledStopPoint>;
  shortName?: Maybe<StopRegistryEmbeddableMultilingualString>;
  stopPlaceType?: Maybe<StopRegistryStopPlaceType>;
  submode?: Maybe<StopRegistrySubmodeType>;
  tags?: Maybe<Array<Maybe<StopRegistryTag>>>;
  tariffZones?: Maybe<Array<Maybe<StopRegistryTariffZone>>>;
  topographicPlace?: Maybe<StopRegistryTopographicPlace>;
  transportMode?: Maybe<StopRegistryTransportModeType>;
  validBetween?: Maybe<StopRegistryValidBetween>;
  version?: Maybe<Scalars['String']>;
  versionComment?: Maybe<Scalars['String']>;
  weighting?: Maybe<StopRegistryInterchangeWeightingType>;
};

export type StopRegistryStopPlaceInput = {
  /** This field is set either on StopPlace (i.e. all Quays are equal), or on every Quay. */
  accessibilityAssessment?: InputMaybe<StopRegistryAccessibilityAssessmentInput>;
  /** Any references to another SITE of which this STOP PLACE is deemed to be a nearby but distinct. */
  adjacentSites?: InputMaybe<
    Array<InputMaybe<StopRegistryVersionLessEntityRefInput>>
  >;
  alternativeNames?: InputMaybe<
    Array<InputMaybe<StopRegistryAlternativeNameInput>>
  >;
  description?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  geometry?: InputMaybe<StopRegistryGeoJsonInput>;
  /** Ignore when creating new */
  id?: InputMaybe<Scalars['String']>;
  keyValues?: InputMaybe<Array<InputMaybe<StopRegistryKeyValuesInput>>>;
  name?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  parentSiteRef?: InputMaybe<Scalars['String']>;
  placeEquipments?: InputMaybe<StopRegistryPlaceEquipmentsInput>;
  privateCode?: InputMaybe<StopRegistryPrivateCodeInput>;
  publicCode?: InputMaybe<Scalars['String']>;
  quays?: InputMaybe<Array<InputMaybe<StopRegistryQuayInput>>>;
  shortName?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  stopPlaceType?: InputMaybe<StopRegistryStopPlaceType>;
  submode?: InputMaybe<StopRegistrySubmodeType>;
  /** List of tariff zone references without version */
  tariffZones?: InputMaybe<
    Array<InputMaybe<StopRegistryVersionLessEntityRefInput>>
  >;
  topographicPlace?: InputMaybe<StopRegistryTopographicPlaceInput>;
  transportMode?: InputMaybe<StopRegistryTransportModeType>;
  validBetween?: InputMaybe<StopRegistryValidBetweenInput>;
  versionComment?: InputMaybe<Scalars['String']>;
  weighting?: InputMaybe<StopRegistryInterchangeWeightingType>;
};

export type StopRegistryStopPlaceInterface = {
  /** This field is set either on StopPlace (i.e. all Quays are equal), or on every Quay. */
  accessibilityAssessment?: Maybe<StopRegistryAccessibilityAssessment>;
  alternativeNames?: Maybe<Array<Maybe<StopRegistryAlternativeName>>>;
  changedBy?: Maybe<Scalars['String']>;
  description?: Maybe<StopRegistryEmbeddableMultilingualString>;
  fareZones?: Maybe<Array<Maybe<StopRegistryFareZone>>>;
  geometry?: Maybe<StopRegistryGeoJson>;
  groups?: Maybe<Array<Maybe<StopRegistryGroupOfStopPlaces>>>;
  id?: Maybe<Scalars['String']>;
  importedId?: Maybe<Array<Maybe<Scalars['String']>>>;
  keyValues?: Maybe<Array<Maybe<StopRegistryKeyValues>>>;
  modificationEnumeration?: Maybe<StopRegistryModificationEnumerationType>;
  name?: Maybe<StopRegistryEmbeddableMultilingualString>;
  placeEquipments?: Maybe<StopRegistryPlaceEquipments>;
  polygon?: Maybe<StopRegistryGeoJson>;
  privateCode?: Maybe<StopRegistryPrivateCode>;
  publicCode?: Maybe<Scalars['String']>;
  shortName?: Maybe<StopRegistryEmbeddableMultilingualString>;
  tags?: Maybe<Array<Maybe<StopRegistryTag>>>;
  tariffZones?: Maybe<Array<Maybe<StopRegistryTariffZone>>>;
  topographicPlace?: Maybe<StopRegistryTopographicPlace>;
  validBetween?: Maybe<StopRegistryValidBetween>;
  version?: Maybe<Scalars['String']>;
  versionComment?: Maybe<Scalars['String']>;
};

export enum StopRegistryStopPlaceType {
  Airport = 'airport',
  BusStation = 'busStation',
  CoachStation = 'coachStation',
  FerryPort = 'ferryPort',
  FerryStop = 'ferryStop',
  HarbourPort = 'harbourPort',
  LiftStation = 'liftStation',
  MetroStation = 'metroStation',
  OnstreetBus = 'onstreetBus',
  OnstreetTram = 'onstreetTram',
  Other = 'other',
  RailStation = 'railStation',
  TramStation = 'tramStation',
  VehicleRailInterchange = 'vehicleRailInterchange',
}

export enum StopRegistrySubmodeType {
  AirportLinkBus = 'airportLinkBus',
  DomesticFlight = 'domesticFlight',
  ExpressBus = 'expressBus',
  Funicular = 'funicular',
  HelicopterService = 'helicopterService',
  HighSpeedPassengerService = 'highSpeedPassengerService',
  HighSpeedVehicleService = 'highSpeedVehicleService',
  InternationalCarFerry = 'internationalCarFerry',
  InternationalFlight = 'internationalFlight',
  InternationalPassengerFerry = 'internationalPassengerFerry',
  InterregionalRail = 'interregionalRail',
  Local = 'local',
  LocalBus = 'localBus',
  LocalCarFerry = 'localCarFerry',
  LocalPassengerFerry = 'localPassengerFerry',
  LocalTram = 'localTram',
  LongDistance = 'longDistance',
  Metro = 'metro',
  NationalCarFerry = 'nationalCarFerry',
  NightBus = 'nightBus',
  NightRail = 'nightRail',
  RailReplacementBus = 'railReplacementBus',
  RegionalBus = 'regionalBus',
  RegionalRail = 'regionalRail',
  SchoolBus = 'schoolBus',
  ShuttleBus = 'shuttleBus',
  SightseeingBus = 'sightseeingBus',
  SightseeingService = 'sightseeingService',
  Telecabin = 'telecabin',
  TouristRailway = 'touristRailway',
}

/** A tag for an entity like StopPlace */
export type StopRegistryTag = {
  __typename?: 'stop_registry_Tag';
  /** A comment for this tag on this entity */
  comment?: Maybe<Scalars['String']>;
  /** When this tag was added to the referenced entity */
  created?: Maybe<Scalars['stop_registry_DateTime']>;
  /** Who created this tag for the referenced entity */
  createdBy?: Maybe<Scalars['String']>;
  /** A reference to a netex ID. For instance: NSR:StopPlace:1. Types supported: StopPlace */
  idReference?: Maybe<Scalars['String']>;
  /** Tag name */
  name?: Maybe<Scalars['String']>;
  /** When this tag was removed. If set, the tag is removed from entity it references in field 'idReference' */
  removed?: Maybe<Scalars['stop_registry_DateTime']>;
  /** Removed by username. Only set if tag has been removed */
  removedBy?: Maybe<Scalars['String']>;
};

export type StopRegistryTariffZone = {
  __typename?: 'stop_registry_TariffZone';
  description?: Maybe<StopRegistryEmbeddableMultilingualString>;
  geometry?: Maybe<StopRegistryGeoJson>;
  id?: Maybe<Scalars['String']>;
  importedId?: Maybe<Array<Maybe<Scalars['String']>>>;
  keyValues?: Maybe<Array<Maybe<StopRegistryKeyValues>>>;
  name?: Maybe<StopRegistryEmbeddableMultilingualString>;
  polygon?: Maybe<StopRegistryGeoJson>;
  shortName?: Maybe<StopRegistryEmbeddableMultilingualString>;
  validBetween?: Maybe<StopRegistryValidBetween>;
  version?: Maybe<Scalars['String']>;
};

export type StopRegistryTicketingEquipment = {
  __typename?: 'stop_registry_TicketingEquipment';
  id?: Maybe<Scalars['String']>;
  numberOfMachines?: Maybe<Scalars['stop_registry_BigInteger']>;
  ticketMachines?: Maybe<Scalars['Boolean']>;
  ticketOffice?: Maybe<Scalars['Boolean']>;
};

export type StopRegistryTicketingEquipmentInput = {
  numberOfMachines?: InputMaybe<Scalars['stop_registry_BigInteger']>;
  ticketMachines?: InputMaybe<Scalars['Boolean']>;
  ticketOffice?: InputMaybe<Scalars['Boolean']>;
};

export type StopRegistryTopographicPlace = {
  __typename?: 'stop_registry_TopographicPlace';
  id?: Maybe<Scalars['String']>;
  name?: Maybe<StopRegistryEmbeddableMultilingualString>;
  parentTopographicPlace?: Maybe<StopRegistryTopographicPlace>;
  polygon?: Maybe<StopRegistryGeoJson>;
  topographicPlaceType?: Maybe<StopRegistryTopographicPlaceType>;
  version?: Maybe<Scalars['Int']>;
};

export type StopRegistryTopographicPlaceInput = {
  id?: InputMaybe<Scalars['String']>;
};

export enum StopRegistryTopographicPlaceType {
  Area = 'area',
  City = 'city',
  Continent = 'continent',
  Conurbation = 'conurbation',
  Country = 'country',
  County = 'county',
  District = 'district',
  Hamlet = 'hamlet',
  Interregion = 'interregion',
  Municipality = 'municipality',
  Other = 'other',
  Parish = 'parish',
  PlaceOfInterest = 'placeOfInterest',
  Principality = 'principality',
  Province = 'province',
  Quarter = 'quarter',
  Region = 'region',
  State = 'state',
  Suburb = 'suburb',
  Town = 'town',
  Unrecorded = 'unrecorded',
  UrbanCentre = 'urbanCentre',
  Village = 'village',
}

/** Transfer durations in seconds */
export type StopRegistryTransferDuration = {
  __typename?: 'stop_registry_TransferDuration';
  /** Default duration in seconds */
  defaultDuration?: Maybe<Scalars['Int']>;
  /** Frequent traveller duration in seconds */
  frequentTravellerDuration?: Maybe<Scalars['Int']>;
  /** Mobility restriced traveller duration in seconds */
  mobilityRestrictedTravellerDuration?: Maybe<Scalars['Int']>;
  /** Occasional traveller duration in seconds */
  occasionalTravellerDuration?: Maybe<Scalars['Int']>;
};

/** Transfer durations in seconds */
export type StopRegistryTransferDurationInput = {
  /** Default duration in seconds */
  defaultDuration?: InputMaybe<Scalars['Int']>;
  /** Frequent traveller duration in seconds */
  frequentTravellerDuration?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['String']>;
  /** Mobility restriced traveller duration in seconds */
  mobilityRestrictedTravellerDuration?: InputMaybe<Scalars['Int']>;
  /** Occasional traveller duration in seconds */
  occasionalTravellerDuration?: InputMaybe<Scalars['Int']>;
};

export enum StopRegistryTransportModeType {
  Air = 'air',
  Bus = 'bus',
  Cableway = 'cableway',
  Funicular = 'funicular',
  Metro = 'metro',
  Rail = 'rail',
  Tram = 'tram',
  Water = 'water',
}

export type StopRegistryTransportModes = {
  __typename?: 'stop_registry_TransportModes';
  submode?: Maybe<Array<Maybe<Scalars['String']>>>;
  transportMode?: Maybe<Scalars['String']>;
};

export type StopRegistryValidBetween = {
  __typename?: 'stop_registry_ValidBetween';
  /** Date time using the format: yyyy-MM-dd'T'HH:mm:ss.SSSXXXX. Example: 2017-04-23T18:25:43.511+0100 */
  fromDate?: Maybe<Scalars['stop_registry_DateTime']>;
  /** Date time using the format: yyyy-MM-dd'T'HH:mm:ss.SSSXXXX. Example: 2017-04-23T18:25:43.511+0100 */
  toDate?: Maybe<Scalars['stop_registry_DateTime']>;
};

export type StopRegistryValidBetweenInput = {
  /** When the new version is valid from */
  fromDate: Scalars['stop_registry_DateTime'];
  /** When the version is no longer valid */
  toDate?: InputMaybe<Scalars['stop_registry_DateTime']>;
};

/** A reference to an entity without version */
export type StopRegistryVersionLessEntityRef = {
  __typename?: 'stop_registry_VersionLessEntityRef';
  /** The NeTEx ID of the of the referenced entity. The reference must already exist */
  ref?: Maybe<Scalars['String']>;
};

/** A reference to an entity without version */
export type StopRegistryVersionLessEntityRefInput = {
  /** The NeTEx ID of the of the referenced entity. The reference must already exist */
  ref: Scalars['String'];
};

export enum StopRegistryVersionValidity {
  All = 'ALL',
  Current = 'CURRENT',
  CurrentFuture = 'CURRENT_FUTURE',
  MaxVersion = 'MAX_VERSION',
}

export type StopRegistryWaitingRoomEquipment = {
  __typename?: 'stop_registry_WaitingRoomEquipment';
  heated?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['String']>;
  seats?: Maybe<Scalars['stop_registry_BigInteger']>;
  stepFree?: Maybe<Scalars['Boolean']>;
};

export type StopRegistryWaitingRoomEquipmentInput = {
  heated?: InputMaybe<Scalars['Boolean']>;
  seats?: InputMaybe<Scalars['stop_registry_BigInteger']>;
  stepFree?: InputMaybe<Scalars['Boolean']>;
};

export enum StopRegistryZoneTopologyEnumerationType {
  Annular = 'annular',
  Honeycomb = 'honeycomb',
  Nested = 'nested',
  Other = 'other',
  Overlapping = 'overlapping',
  OverlappingSequence = 'overlappingSequence',
  Ring = 'ring',
  Sequence = 'sequence',
  Tiled = 'tiled',
}

export type StopRegistryAddToMultiModalStopPlaceInput = {
  parentSiteRef: Scalars['String'];
  stopPlaceIds: Array<InputMaybe<Scalars['String']>>;
  validBetween?: InputMaybe<StopRegistryValidBetweenInput>;
  versionComment?: InputMaybe<Scalars['String']>;
};

export type StopRegistryCreateMultiModalStopPlaceInput = {
  description?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  geometry?: InputMaybe<StopRegistryGeoJsonInput>;
  name: StopRegistryEmbeddableMultilingualStringInput;
  stopPlaceIds: Array<InputMaybe<Scalars['String']>>;
  validBetween?: InputMaybe<StopRegistryValidBetweenInput>;
  versionComment?: InputMaybe<Scalars['String']>;
};

export enum StopRegistryCycleStorageType {
  Bars = 'bars',
  CycleScheme = 'cycleScheme',
  Other = 'other',
  Racks = 'racks',
  Railings = 'railings',
}

export enum StopRegistryGender {
  Both = 'both',
  FemaleOnly = 'femaleOnly',
  MaleOnly = 'maleOnly',
  SameSexOnly = 'sameSexOnly',
}

export enum StopRegistryNameType {
  Alias = 'alias',
  Copy = 'copy',
  Label = 'label',
  Other = 'other',
  Translation = 'translation',
}

export enum StopRegistrySignContentType {
  TransportModePoint = 'TransportModePoint',
  Assistance = 'assistance',
  EmergencyExit = 'emergencyExit',
  Entrance = 'entrance',
  Exit = 'exit',
  MeetingPoint = 'meetingPoint',
  NoSmoking = 'noSmoking',
  Other = 'other',
  SosPhone = 'sosPhone',
  Tickets = 'tickets',
  TouchPoint = 'touchPoint',
  TransportMode = 'transportMode',
}

/** columns and relationships of "access_space" */
export type StopsDatabaseAccessSpace = {
  __typename?: 'stops_database_access_space';
  /** An array relationship */
  access_space_alternative_names: Array<StopsDatabaseAccessSpaceAlternativeNames>;
  /** An aggregate relationship */
  access_space_alternative_names_aggregate: StopsDatabaseAccessSpaceAlternativeNamesAggregate;
  /** An array relationship */
  access_space_equipment_places: Array<StopsDatabaseAccessSpaceEquipmentPlaces>;
  /** An aggregate relationship */
  access_space_equipment_places_aggregate: StopsDatabaseAccessSpaceEquipmentPlacesAggregate;
  /** An array relationship */
  access_space_key_values: Array<StopsDatabaseAccessSpaceKeyValues>;
  /** An aggregate relationship */
  access_space_key_values_aggregate: StopsDatabaseAccessSpaceKeyValuesAggregate;
  /** An object relationship */
  accessibility_assessment?: Maybe<StopsDatabaseAccessibilityAssessment>;
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  all_areas_wheelchair_accessible?: Maybe<Scalars['Boolean']>;
  centroid?: Maybe<Scalars['geometry']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  covered?: Maybe<Scalars['Int']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id: Scalars['bigint'];
  /** An object relationship */
  installed_equipment_version_structure?: Maybe<StopsDatabaseInstalledEquipmentVersionStructure>;
  label_lang?: Maybe<Scalars['String']>;
  label_value?: Maybe<Scalars['String']>;
  level_ref?: Maybe<Scalars['String']>;
  level_ref_version?: Maybe<Scalars['String']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  /** An object relationship */
  persistable_polygon?: Maybe<StopsDatabasePersistablePolygon>;
  place_equipments_id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  site_ref?: Maybe<Scalars['String']>;
  site_ref_version?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version: Scalars['bigint'];
  version_comment?: Maybe<Scalars['String']>;
};

/** columns and relationships of "access_space" */
export type StopsDatabaseAccessSpaceAccessSpaceAlternativeNamesArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseAccessSpaceAlternativeNamesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseAccessSpaceAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>;
};

/** columns and relationships of "access_space" */
export type StopsDatabaseAccessSpaceAccessSpaceAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseAccessSpaceAlternativeNamesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseAccessSpaceAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>;
};

/** columns and relationships of "access_space" */
export type StopsDatabaseAccessSpaceAccessSpaceEquipmentPlacesArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseAccessSpaceEquipmentPlacesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseAccessSpaceEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>;
};

/** columns and relationships of "access_space" */
export type StopsDatabaseAccessSpaceAccessSpaceEquipmentPlacesAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseAccessSpaceEquipmentPlacesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseAccessSpaceEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>;
};

/** columns and relationships of "access_space" */
export type StopsDatabaseAccessSpaceAccessSpaceKeyValuesArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseAccessSpaceKeyValuesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseAccessSpaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesBoolExp>;
};

/** columns and relationships of "access_space" */
export type StopsDatabaseAccessSpaceAccessSpaceKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseAccessSpaceKeyValuesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseAccessSpaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesBoolExp>;
};

/** aggregated selection of "access_space" */
export type StopsDatabaseAccessSpaceAggregate = {
  __typename?: 'stops_database_access_space_aggregate';
  aggregate?: Maybe<StopsDatabaseAccessSpaceAggregateFields>;
  nodes: Array<StopsDatabaseAccessSpace>;
};

/** aggregate fields of "access_space" */
export type StopsDatabaseAccessSpaceAggregateFields = {
  __typename?: 'stops_database_access_space_aggregate_fields';
  avg?: Maybe<StopsDatabaseAccessSpaceAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseAccessSpaceMaxFields>;
  min?: Maybe<StopsDatabaseAccessSpaceMinFields>;
  stddev?: Maybe<StopsDatabaseAccessSpaceStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseAccessSpaceStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseAccessSpaceStddevSampFields>;
  sum?: Maybe<StopsDatabaseAccessSpaceSumFields>;
  var_pop?: Maybe<StopsDatabaseAccessSpaceVarPopFields>;
  var_samp?: Maybe<StopsDatabaseAccessSpaceVarSampFields>;
  variance?: Maybe<StopsDatabaseAccessSpaceVarianceFields>;
};

/** aggregate fields of "access_space" */
export type StopsDatabaseAccessSpaceAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseAccessSpaceSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** columns and relationships of "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNames = {
  __typename?: 'stops_database_access_space_alternative_names';
  access_space_id: Scalars['bigint'];
  /** An object relationship */
  alternative_name: StopsDatabaseAlternativeName;
  alternative_names_id: Scalars['bigint'];
};

/** aggregated selection of "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesAggregate = {
  __typename?: 'stops_database_access_space_alternative_names_aggregate';
  aggregate?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesAggregateFields>;
  nodes: Array<StopsDatabaseAccessSpaceAlternativeNames>;
};

/** aggregate fields of "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesAggregateFields = {
  __typename?: 'stops_database_access_space_alternative_names_aggregate_fields';
  avg?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesMaxFields>;
  min?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesMinFields>;
  stddev?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesStddevSampFields>;
  sum?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesSumFields>;
  var_pop?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesVarSampFields>;
  variance?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesVarianceFields>;
};

/** aggregate fields of "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesAggregateFieldsCountArgs = {
  columns?: InputMaybe<
    Array<StopsDatabaseAccessSpaceAlternativeNamesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesArrRelInsertInput = {
  data: Array<StopsDatabaseAccessSpaceAlternativeNamesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseAccessSpaceAlternativeNamesAvgFields = {
  __typename?: 'stops_database_access_space_alternative_names_avg_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  alternative_names_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesAvgOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  alternative_names_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "access_space_alternative_names". All fields are combined with a logical 'AND'. */
export type StopsDatabaseAccessSpaceAlternativeNamesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>>;
  access_space_id?: InputMaybe<BigintComparisonExp>;
  alternative_name?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
  alternative_names_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "access_space_alternative_names" */
export enum StopsDatabaseAccessSpaceAlternativeNamesConstraint {
  /** unique or primary key constraint on columns "alternative_names_id" */
  UkQvw904jxmey0b5c2oenaks4o6 = 'uk_qvw904jxmey0b5c2oenaks4o6',
}

/** input type for incrementing numeric columns in table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesIncInput = {
  access_space_id?: InputMaybe<Scalars['bigint']>;
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesInsertInput = {
  access_space_id?: InputMaybe<Scalars['bigint']>;
  alternative_name?: InputMaybe<StopsDatabaseAlternativeNameObjRelInsertInput>;
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseAccessSpaceAlternativeNamesMaxFields = {
  __typename?: 'stops_database_access_space_alternative_names_max_fields';
  access_space_id?: Maybe<Scalars['bigint']>;
  alternative_names_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesMaxOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  alternative_names_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseAccessSpaceAlternativeNamesMinFields = {
  __typename?: 'stops_database_access_space_alternative_names_min_fields';
  access_space_id?: Maybe<Scalars['bigint']>;
  alternative_names_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesMinOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  alternative_names_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesMutationResponse = {
  __typename?: 'stops_database_access_space_alternative_names_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseAccessSpaceAlternativeNames>;
};

/** on_conflict condition type for table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesOnConflict = {
  constraint: StopsDatabaseAccessSpaceAlternativeNamesConstraint;
  update_columns?: Array<StopsDatabaseAccessSpaceAlternativeNamesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>;
};

/** Ordering options when selecting data from "access_space_alternative_names". */
export type StopsDatabaseAccessSpaceAlternativeNamesOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  alternative_name?: InputMaybe<StopsDatabaseAlternativeNameOrderBy>;
  alternative_names_id?: InputMaybe<OrderBy>;
};

/** select columns of table "access_space_alternative_names" */
export enum StopsDatabaseAccessSpaceAlternativeNamesSelectColumn {
  /** column name */
  AccessSpaceId = 'access_space_id',
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
}

/** input type for updating data in table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesSetInput = {
  access_space_id?: InputMaybe<Scalars['bigint']>;
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseAccessSpaceAlternativeNamesStddevFields = {
  __typename?: 'stops_database_access_space_alternative_names_stddev_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  alternative_names_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesStddevOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  alternative_names_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseAccessSpaceAlternativeNamesStddevPopFields = {
  __typename?: 'stops_database_access_space_alternative_names_stddev_pop_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  alternative_names_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesStddevPopOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  alternative_names_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseAccessSpaceAlternativeNamesStddevSampFields = {
  __typename?: 'stops_database_access_space_alternative_names_stddev_samp_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  alternative_names_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesStddevSampOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  alternative_names_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseAccessSpaceAlternativeNamesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseAccessSpaceAlternativeNamesStreamCursorValueInput = {
  access_space_id?: InputMaybe<Scalars['bigint']>;
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseAccessSpaceAlternativeNamesSumFields = {
  __typename?: 'stops_database_access_space_alternative_names_sum_fields';
  access_space_id?: Maybe<Scalars['bigint']>;
  alternative_names_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesSumOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  alternative_names_id?: InputMaybe<OrderBy>;
};

/** update columns of table "access_space_alternative_names" */
export enum StopsDatabaseAccessSpaceAlternativeNamesUpdateColumn {
  /** column name */
  AccessSpaceId = 'access_space_id',
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
}

export type StopsDatabaseAccessSpaceAlternativeNamesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseAccessSpaceAlternativeNamesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseAccessSpaceAlternativeNamesVarPopFields = {
  __typename?: 'stops_database_access_space_alternative_names_var_pop_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  alternative_names_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesVarPopOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  alternative_names_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseAccessSpaceAlternativeNamesVarSampFields = {
  __typename?: 'stops_database_access_space_alternative_names_var_samp_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  alternative_names_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesVarSampOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  alternative_names_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseAccessSpaceAlternativeNamesVarianceFields = {
  __typename?: 'stops_database_access_space_alternative_names_variance_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  alternative_names_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesVarianceOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  alternative_names_id?: InputMaybe<OrderBy>;
};

/** aggregate avg on columns */
export type StopsDatabaseAccessSpaceAvgFields = {
  __typename?: 'stops_database_access_space_avg_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "access_space". All fields are combined with a logical 'AND'. */
export type StopsDatabaseAccessSpaceBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseAccessSpaceBoolExp>>;
  _not?: InputMaybe<StopsDatabaseAccessSpaceBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseAccessSpaceBoolExp>>;
  access_space_alternative_names?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>;
  access_space_alternative_names_aggregate?: InputMaybe<AccessSpaceAlternativeNamesAggregateBoolExp>;
  access_space_equipment_places?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>;
  access_space_equipment_places_aggregate?: InputMaybe<AccessSpaceEquipmentPlacesAggregateBoolExp>;
  access_space_key_values?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesBoolExp>;
  access_space_key_values_aggregate?: InputMaybe<AccessSpaceKeyValuesAggregateBoolExp>;
  accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentBoolExp>;
  accessibility_assessment_id?: InputMaybe<BigintComparisonExp>;
  all_areas_wheelchair_accessible?: InputMaybe<BooleanComparisonExp>;
  centroid?: InputMaybe<GeometryComparisonExp>;
  changed?: InputMaybe<TimestampComparisonExp>;
  changed_by?: InputMaybe<StringComparisonExp>;
  covered?: InputMaybe<IntComparisonExp>;
  created?: InputMaybe<TimestampComparisonExp>;
  description_lang?: InputMaybe<StringComparisonExp>;
  description_value?: InputMaybe<StringComparisonExp>;
  from_date?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
  label_lang?: InputMaybe<StringComparisonExp>;
  label_value?: InputMaybe<StringComparisonExp>;
  level_ref?: InputMaybe<StringComparisonExp>;
  level_ref_version?: InputMaybe<StringComparisonExp>;
  name_lang?: InputMaybe<StringComparisonExp>;
  name_value?: InputMaybe<StringComparisonExp>;
  netex_id?: InputMaybe<StringComparisonExp>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  place_equipments_id?: InputMaybe<BigintComparisonExp>;
  polygon_id?: InputMaybe<BigintComparisonExp>;
  private_code_type?: InputMaybe<StringComparisonExp>;
  private_code_value?: InputMaybe<StringComparisonExp>;
  short_name_lang?: InputMaybe<StringComparisonExp>;
  short_name_value?: InputMaybe<StringComparisonExp>;
  site_ref?: InputMaybe<StringComparisonExp>;
  site_ref_version?: InputMaybe<StringComparisonExp>;
  to_date?: InputMaybe<TimestampComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
  version_comment?: InputMaybe<StringComparisonExp>;
};

/** columns and relationships of "access_space_check_constraints" */
export type StopsDatabaseAccessSpaceCheckConstraints = {
  __typename?: 'stops_database_access_space_check_constraints';
  access_space_id: Scalars['bigint'];
  check_constraints_id: Scalars['bigint'];
};

/** aggregated selection of "access_space_check_constraints" */
export type StopsDatabaseAccessSpaceCheckConstraintsAggregate = {
  __typename?: 'stops_database_access_space_check_constraints_aggregate';
  aggregate?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsAggregateFields>;
  nodes: Array<StopsDatabaseAccessSpaceCheckConstraints>;
};

/** aggregate fields of "access_space_check_constraints" */
export type StopsDatabaseAccessSpaceCheckConstraintsAggregateFields = {
  __typename?: 'stops_database_access_space_check_constraints_aggregate_fields';
  avg?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsMaxFields>;
  min?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsMinFields>;
  stddev?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsStddevSampFields>;
  sum?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsSumFields>;
  var_pop?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsVarPopFields>;
  var_samp?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsVarSampFields>;
  variance?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsVarianceFields>;
};

/** aggregate fields of "access_space_check_constraints" */
export type StopsDatabaseAccessSpaceCheckConstraintsAggregateFieldsCountArgs = {
  columns?: InputMaybe<
    Array<StopsDatabaseAccessSpaceCheckConstraintsSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseAccessSpaceCheckConstraintsAvgFields = {
  __typename?: 'stops_database_access_space_check_constraints_avg_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  check_constraints_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "access_space_check_constraints". All fields are combined with a logical 'AND'. */
export type StopsDatabaseAccessSpaceCheckConstraintsBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseAccessSpaceCheckConstraintsBoolExp>>;
  _not?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseAccessSpaceCheckConstraintsBoolExp>>;
  access_space_id?: InputMaybe<BigintComparisonExp>;
  check_constraints_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "access_space_check_constraints" */
export enum StopsDatabaseAccessSpaceCheckConstraintsConstraint {
  /** unique or primary key constraint on columns "check_constraints_id" */
  Uk_35wb7oemdnk85n1hg680228tv = 'uk_35wb7oemdnk85n1hg680228tv',
}

/** input type for incrementing numeric columns in table "access_space_check_constraints" */
export type StopsDatabaseAccessSpaceCheckConstraintsIncInput = {
  access_space_id?: InputMaybe<Scalars['bigint']>;
  check_constraints_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "access_space_check_constraints" */
export type StopsDatabaseAccessSpaceCheckConstraintsInsertInput = {
  access_space_id?: InputMaybe<Scalars['bigint']>;
  check_constraints_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseAccessSpaceCheckConstraintsMaxFields = {
  __typename?: 'stops_database_access_space_check_constraints_max_fields';
  access_space_id?: Maybe<Scalars['bigint']>;
  check_constraints_id?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type StopsDatabaseAccessSpaceCheckConstraintsMinFields = {
  __typename?: 'stops_database_access_space_check_constraints_min_fields';
  access_space_id?: Maybe<Scalars['bigint']>;
  check_constraints_id?: Maybe<Scalars['bigint']>;
};

/** response of any mutation on the table "access_space_check_constraints" */
export type StopsDatabaseAccessSpaceCheckConstraintsMutationResponse = {
  __typename?: 'stops_database_access_space_check_constraints_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseAccessSpaceCheckConstraints>;
};

/** on_conflict condition type for table "access_space_check_constraints" */
export type StopsDatabaseAccessSpaceCheckConstraintsOnConflict = {
  constraint: StopsDatabaseAccessSpaceCheckConstraintsConstraint;
  update_columns?: Array<StopsDatabaseAccessSpaceCheckConstraintsUpdateColumn>;
  where?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsBoolExp>;
};

/** Ordering options when selecting data from "access_space_check_constraints". */
export type StopsDatabaseAccessSpaceCheckConstraintsOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  check_constraints_id?: InputMaybe<OrderBy>;
};

/** select columns of table "access_space_check_constraints" */
export enum StopsDatabaseAccessSpaceCheckConstraintsSelectColumn {
  /** column name */
  AccessSpaceId = 'access_space_id',
  /** column name */
  CheckConstraintsId = 'check_constraints_id',
}

/** input type for updating data in table "access_space_check_constraints" */
export type StopsDatabaseAccessSpaceCheckConstraintsSetInput = {
  access_space_id?: InputMaybe<Scalars['bigint']>;
  check_constraints_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseAccessSpaceCheckConstraintsStddevFields = {
  __typename?: 'stops_database_access_space_check_constraints_stddev_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  check_constraints_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseAccessSpaceCheckConstraintsStddevPopFields = {
  __typename?: 'stops_database_access_space_check_constraints_stddev_pop_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  check_constraints_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseAccessSpaceCheckConstraintsStddevSampFields = {
  __typename?: 'stops_database_access_space_check_constraints_stddev_samp_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  check_constraints_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "access_space_check_constraints" */
export type StopsDatabaseAccessSpaceCheckConstraintsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseAccessSpaceCheckConstraintsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseAccessSpaceCheckConstraintsStreamCursorValueInput = {
  access_space_id?: InputMaybe<Scalars['bigint']>;
  check_constraints_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseAccessSpaceCheckConstraintsSumFields = {
  __typename?: 'stops_database_access_space_check_constraints_sum_fields';
  access_space_id?: Maybe<Scalars['bigint']>;
  check_constraints_id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "access_space_check_constraints" */
export enum StopsDatabaseAccessSpaceCheckConstraintsUpdateColumn {
  /** column name */
  AccessSpaceId = 'access_space_id',
  /** column name */
  CheckConstraintsId = 'check_constraints_id',
}

export type StopsDatabaseAccessSpaceCheckConstraintsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseAccessSpaceCheckConstraintsBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseAccessSpaceCheckConstraintsVarPopFields = {
  __typename?: 'stops_database_access_space_check_constraints_var_pop_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  check_constraints_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseAccessSpaceCheckConstraintsVarSampFields = {
  __typename?: 'stops_database_access_space_check_constraints_var_samp_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  check_constraints_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseAccessSpaceCheckConstraintsVarianceFields = {
  __typename?: 'stops_database_access_space_check_constraints_variance_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  check_constraints_id?: Maybe<Scalars['Float']>;
};

/** unique or primary key constraints on table "access_space" */
export enum StopsDatabaseAccessSpaceConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  AccessSpaceNetexIdVersionConstraint = 'access_space_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  AccessSpacePkey = 'access_space_pkey',
}

/** columns and relationships of "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlaces = {
  __typename?: 'stops_database_access_space_equipment_places';
  access_space_id: Scalars['bigint'];
  /** An object relationship */
  equipment_place: StopsDatabaseEquipmentPlace;
  equipment_places_id: Scalars['bigint'];
};

/** aggregated selection of "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesAggregate = {
  __typename?: 'stops_database_access_space_equipment_places_aggregate';
  aggregate?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesAggregateFields>;
  nodes: Array<StopsDatabaseAccessSpaceEquipmentPlaces>;
};

/** aggregate fields of "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesAggregateFields = {
  __typename?: 'stops_database_access_space_equipment_places_aggregate_fields';
  avg?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesMaxFields>;
  min?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesMinFields>;
  stddev?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesStddevSampFields>;
  sum?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesSumFields>;
  var_pop?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesVarSampFields>;
  variance?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesVarianceFields>;
};

/** aggregate fields of "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesAggregateFieldsCountArgs = {
  columns?: InputMaybe<
    Array<StopsDatabaseAccessSpaceEquipmentPlacesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesArrRelInsertInput = {
  data: Array<StopsDatabaseAccessSpaceEquipmentPlacesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseAccessSpaceEquipmentPlacesAvgFields = {
  __typename?: 'stops_database_access_space_equipment_places_avg_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  equipment_places_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesAvgOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  equipment_places_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "access_space_equipment_places". All fields are combined with a logical 'AND'. */
export type StopsDatabaseAccessSpaceEquipmentPlacesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>>;
  access_space_id?: InputMaybe<BigintComparisonExp>;
  equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceBoolExp>;
  equipment_places_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "access_space_equipment_places" */
export enum StopsDatabaseAccessSpaceEquipmentPlacesConstraint {
  /** unique or primary key constraint on columns "equipment_places_id" */
  Uk_15g5ep156j0s0m3dmh1by6dof = 'uk_15g5ep156j0s0m3dmh1by6dof',
}

/** input type for incrementing numeric columns in table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesIncInput = {
  access_space_id?: InputMaybe<Scalars['bigint']>;
  equipment_places_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesInsertInput = {
  access_space_id?: InputMaybe<Scalars['bigint']>;
  equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceObjRelInsertInput>;
  equipment_places_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseAccessSpaceEquipmentPlacesMaxFields = {
  __typename?: 'stops_database_access_space_equipment_places_max_fields';
  access_space_id?: Maybe<Scalars['bigint']>;
  equipment_places_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesMaxOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  equipment_places_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseAccessSpaceEquipmentPlacesMinFields = {
  __typename?: 'stops_database_access_space_equipment_places_min_fields';
  access_space_id?: Maybe<Scalars['bigint']>;
  equipment_places_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesMinOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  equipment_places_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesMutationResponse = {
  __typename?: 'stops_database_access_space_equipment_places_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseAccessSpaceEquipmentPlaces>;
};

/** on_conflict condition type for table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesOnConflict = {
  constraint: StopsDatabaseAccessSpaceEquipmentPlacesConstraint;
  update_columns?: Array<StopsDatabaseAccessSpaceEquipmentPlacesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>;
};

/** Ordering options when selecting data from "access_space_equipment_places". */
export type StopsDatabaseAccessSpaceEquipmentPlacesOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceOrderBy>;
  equipment_places_id?: InputMaybe<OrderBy>;
};

/** select columns of table "access_space_equipment_places" */
export enum StopsDatabaseAccessSpaceEquipmentPlacesSelectColumn {
  /** column name */
  AccessSpaceId = 'access_space_id',
  /** column name */
  EquipmentPlacesId = 'equipment_places_id',
}

/** input type for updating data in table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesSetInput = {
  access_space_id?: InputMaybe<Scalars['bigint']>;
  equipment_places_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseAccessSpaceEquipmentPlacesStddevFields = {
  __typename?: 'stops_database_access_space_equipment_places_stddev_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  equipment_places_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesStddevOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  equipment_places_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseAccessSpaceEquipmentPlacesStddevPopFields = {
  __typename?: 'stops_database_access_space_equipment_places_stddev_pop_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  equipment_places_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesStddevPopOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  equipment_places_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseAccessSpaceEquipmentPlacesStddevSampFields = {
  __typename?: 'stops_database_access_space_equipment_places_stddev_samp_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  equipment_places_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesStddevSampOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  equipment_places_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseAccessSpaceEquipmentPlacesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseAccessSpaceEquipmentPlacesStreamCursorValueInput = {
  access_space_id?: InputMaybe<Scalars['bigint']>;
  equipment_places_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseAccessSpaceEquipmentPlacesSumFields = {
  __typename?: 'stops_database_access_space_equipment_places_sum_fields';
  access_space_id?: Maybe<Scalars['bigint']>;
  equipment_places_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesSumOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  equipment_places_id?: InputMaybe<OrderBy>;
};

/** update columns of table "access_space_equipment_places" */
export enum StopsDatabaseAccessSpaceEquipmentPlacesUpdateColumn {
  /** column name */
  AccessSpaceId = 'access_space_id',
  /** column name */
  EquipmentPlacesId = 'equipment_places_id',
}

export type StopsDatabaseAccessSpaceEquipmentPlacesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseAccessSpaceEquipmentPlacesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseAccessSpaceEquipmentPlacesVarPopFields = {
  __typename?: 'stops_database_access_space_equipment_places_var_pop_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  equipment_places_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesVarPopOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  equipment_places_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseAccessSpaceEquipmentPlacesVarSampFields = {
  __typename?: 'stops_database_access_space_equipment_places_var_samp_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  equipment_places_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesVarSampOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  equipment_places_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseAccessSpaceEquipmentPlacesVarianceFields = {
  __typename?: 'stops_database_access_space_equipment_places_variance_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  equipment_places_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesVarianceOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  equipment_places_id?: InputMaybe<OrderBy>;
};

/** input type for incrementing numeric columns in table "access_space" */
export type StopsDatabaseAccessSpaceIncInput = {
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  covered?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['bigint']>;
  place_equipments_id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "access_space" */
export type StopsDatabaseAccessSpaceInsertInput = {
  access_space_alternative_names?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesArrRelInsertInput>;
  access_space_equipment_places?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesArrRelInsertInput>;
  access_space_key_values?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesArrRelInsertInput>;
  accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentObjRelInsertInput>;
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']>;
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  covered?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureObjRelInsertInput>;
  label_lang?: InputMaybe<Scalars['String']>;
  label_value?: InputMaybe<Scalars['String']>;
  level_ref?: InputMaybe<Scalars['String']>;
  level_ref_version?: InputMaybe<Scalars['String']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonObjRelInsertInput>;
  place_equipments_id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  site_ref?: InputMaybe<Scalars['String']>;
  site_ref_version?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValues = {
  __typename?: 'stops_database_access_space_key_values';
  access_space_id: Scalars['bigint'];
  key_values_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
  /** An object relationship */
  value: StopsDatabaseValue;
};

/** aggregated selection of "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesAggregate = {
  __typename?: 'stops_database_access_space_key_values_aggregate';
  aggregate?: Maybe<StopsDatabaseAccessSpaceKeyValuesAggregateFields>;
  nodes: Array<StopsDatabaseAccessSpaceKeyValues>;
};

/** aggregate fields of "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesAggregateFields = {
  __typename?: 'stops_database_access_space_key_values_aggregate_fields';
  avg?: Maybe<StopsDatabaseAccessSpaceKeyValuesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseAccessSpaceKeyValuesMaxFields>;
  min?: Maybe<StopsDatabaseAccessSpaceKeyValuesMinFields>;
  stddev?: Maybe<StopsDatabaseAccessSpaceKeyValuesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseAccessSpaceKeyValuesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseAccessSpaceKeyValuesStddevSampFields>;
  sum?: Maybe<StopsDatabaseAccessSpaceKeyValuesSumFields>;
  var_pop?: Maybe<StopsDatabaseAccessSpaceKeyValuesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseAccessSpaceKeyValuesVarSampFields>;
  variance?: Maybe<StopsDatabaseAccessSpaceKeyValuesVarianceFields>;
};

/** aggregate fields of "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseAccessSpaceKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesArrRelInsertInput = {
  data: Array<StopsDatabaseAccessSpaceKeyValuesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseAccessSpaceKeyValuesAvgFields = {
  __typename?: 'stops_database_access_space_key_values_avg_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesAvgOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "access_space_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseAccessSpaceKeyValuesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseAccessSpaceKeyValuesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseAccessSpaceKeyValuesBoolExp>>;
  access_space_id?: InputMaybe<BigintComparisonExp>;
  key_values_id?: InputMaybe<BigintComparisonExp>;
  key_values_key?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "access_space_key_values" */
export enum StopsDatabaseAccessSpaceKeyValuesConstraint {
  /** unique or primary key constraint on columns "access_space_id", "key_values_key" */
  AccessSpaceKeyValuesPkey = 'access_space_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkKcsgl47aba68824kjdceo60ql = 'uk_kcsgl47aba68824kjdceo60ql',
}

/** input type for incrementing numeric columns in table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesIncInput = {
  access_space_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesInsertInput = {
  access_space_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseAccessSpaceKeyValuesMaxFields = {
  __typename?: 'stops_database_access_space_key_values_max_fields';
  access_space_id?: Maybe<Scalars['bigint']>;
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesMaxOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseAccessSpaceKeyValuesMinFields = {
  __typename?: 'stops_database_access_space_key_values_min_fields';
  access_space_id?: Maybe<Scalars['bigint']>;
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesMinOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesMutationResponse = {
  __typename?: 'stops_database_access_space_key_values_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseAccessSpaceKeyValues>;
};

/** on_conflict condition type for table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesOnConflict = {
  constraint: StopsDatabaseAccessSpaceKeyValuesConstraint;
  update_columns?: Array<StopsDatabaseAccessSpaceKeyValuesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "access_space_key_values". */
export type StopsDatabaseAccessSpaceKeyValuesOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: access_space_key_values */
export type StopsDatabaseAccessSpaceKeyValuesPkColumnsInput = {
  access_space_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
};

/** select columns of table "access_space_key_values" */
export enum StopsDatabaseAccessSpaceKeyValuesSelectColumn {
  /** column name */
  AccessSpaceId = 'access_space_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
}

/** input type for updating data in table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesSetInput = {
  access_space_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseAccessSpaceKeyValuesStddevFields = {
  __typename?: 'stops_database_access_space_key_values_stddev_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesStddevOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseAccessSpaceKeyValuesStddevPopFields = {
  __typename?: 'stops_database_access_space_key_values_stddev_pop_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesStddevPopOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseAccessSpaceKeyValuesStddevSampFields = {
  __typename?: 'stops_database_access_space_key_values_stddev_samp_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesStddevSampOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseAccessSpaceKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseAccessSpaceKeyValuesStreamCursorValueInput = {
  access_space_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseAccessSpaceKeyValuesSumFields = {
  __typename?: 'stops_database_access_space_key_values_sum_fields';
  access_space_id?: Maybe<Scalars['bigint']>;
  key_values_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesSumOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** update columns of table "access_space_key_values" */
export enum StopsDatabaseAccessSpaceKeyValuesUpdateColumn {
  /** column name */
  AccessSpaceId = 'access_space_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
}

export type StopsDatabaseAccessSpaceKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseAccessSpaceKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseAccessSpaceKeyValuesVarPopFields = {
  __typename?: 'stops_database_access_space_key_values_var_pop_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesVarPopOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseAccessSpaceKeyValuesVarSampFields = {
  __typename?: 'stops_database_access_space_key_values_var_samp_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesVarSampOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseAccessSpaceKeyValuesVarianceFields = {
  __typename?: 'stops_database_access_space_key_values_variance_fields';
  access_space_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesVarianceOrderBy = {
  access_space_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseAccessSpaceMaxFields = {
  __typename?: 'stops_database_access_space_max_fields';
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  covered?: Maybe<Scalars['Int']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  label_lang?: Maybe<Scalars['String']>;
  label_value?: Maybe<Scalars['String']>;
  level_ref?: Maybe<Scalars['String']>;
  level_ref_version?: Maybe<Scalars['String']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  place_equipments_id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  site_ref?: Maybe<Scalars['String']>;
  site_ref_version?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseAccessSpaceMinFields = {
  __typename?: 'stops_database_access_space_min_fields';
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  covered?: Maybe<Scalars['Int']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  label_lang?: Maybe<Scalars['String']>;
  label_value?: Maybe<Scalars['String']>;
  level_ref?: Maybe<Scalars['String']>;
  level_ref_version?: Maybe<Scalars['String']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  place_equipments_id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  site_ref?: Maybe<Scalars['String']>;
  site_ref_version?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "access_space" */
export type StopsDatabaseAccessSpaceMutationResponse = {
  __typename?: 'stops_database_access_space_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseAccessSpace>;
};

/** input type for inserting object relation for remote table "access_space" */
export type StopsDatabaseAccessSpaceObjRelInsertInput = {
  data: StopsDatabaseAccessSpaceInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseAccessSpaceOnConflict>;
};

/** on_conflict condition type for table "access_space" */
export type StopsDatabaseAccessSpaceOnConflict = {
  constraint: StopsDatabaseAccessSpaceConstraint;
  update_columns?: Array<StopsDatabaseAccessSpaceUpdateColumn>;
  where?: InputMaybe<StopsDatabaseAccessSpaceBoolExp>;
};

/** Ordering options when selecting data from "access_space". */
export type StopsDatabaseAccessSpaceOrderBy = {
  access_space_alternative_names_aggregate?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesAggregateOrderBy>;
  access_space_equipment_places_aggregate?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesAggregateOrderBy>;
  access_space_key_values_aggregate?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesAggregateOrderBy>;
  accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentOrderBy>;
  accessibility_assessment_id?: InputMaybe<OrderBy>;
  all_areas_wheelchair_accessible?: InputMaybe<OrderBy>;
  centroid?: InputMaybe<OrderBy>;
  changed?: InputMaybe<OrderBy>;
  changed_by?: InputMaybe<OrderBy>;
  covered?: InputMaybe<OrderBy>;
  created?: InputMaybe<OrderBy>;
  description_lang?: InputMaybe<OrderBy>;
  description_value?: InputMaybe<OrderBy>;
  from_date?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureOrderBy>;
  label_lang?: InputMaybe<OrderBy>;
  label_value?: InputMaybe<OrderBy>;
  level_ref?: InputMaybe<OrderBy>;
  level_ref_version?: InputMaybe<OrderBy>;
  name_lang?: InputMaybe<OrderBy>;
  name_value?: InputMaybe<OrderBy>;
  netex_id?: InputMaybe<OrderBy>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonOrderBy>;
  place_equipments_id?: InputMaybe<OrderBy>;
  polygon_id?: InputMaybe<OrderBy>;
  private_code_type?: InputMaybe<OrderBy>;
  private_code_value?: InputMaybe<OrderBy>;
  short_name_lang?: InputMaybe<OrderBy>;
  short_name_value?: InputMaybe<OrderBy>;
  site_ref?: InputMaybe<OrderBy>;
  site_ref_version?: InputMaybe<OrderBy>;
  to_date?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
  version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: access_space */
export type StopsDatabaseAccessSpacePkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "access_space" */
export enum StopsDatabaseAccessSpaceSelectColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  LabelLang = 'label_lang',
  /** column name */
  LabelValue = 'label_value',
  /** column name */
  LevelRef = 'level_ref',
  /** column name */
  LevelRefVersion = 'level_ref_version',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  SiteRef = 'site_ref',
  /** column name */
  SiteRefVersion = 'site_ref_version',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

/** input type for updating data in table "access_space" */
export type StopsDatabaseAccessSpaceSetInput = {
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']>;
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  covered?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  label_lang?: InputMaybe<Scalars['String']>;
  label_value?: InputMaybe<Scalars['String']>;
  level_ref?: InputMaybe<Scalars['String']>;
  level_ref_version?: InputMaybe<Scalars['String']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  place_equipments_id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  site_ref?: InputMaybe<Scalars['String']>;
  site_ref_version?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseAccessSpaceStddevFields = {
  __typename?: 'stops_database_access_space_stddev_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseAccessSpaceStddevPopFields = {
  __typename?: 'stops_database_access_space_stddev_pop_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseAccessSpaceStddevSampFields = {
  __typename?: 'stops_database_access_space_stddev_samp_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "access_space" */
export type StopsDatabaseAccessSpaceStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseAccessSpaceStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseAccessSpaceStreamCursorValueInput = {
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']>;
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  covered?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  label_lang?: InputMaybe<Scalars['String']>;
  label_value?: InputMaybe<Scalars['String']>;
  level_ref?: InputMaybe<Scalars['String']>;
  level_ref_version?: InputMaybe<Scalars['String']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  place_equipments_id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  site_ref?: InputMaybe<Scalars['String']>;
  site_ref_version?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseAccessSpaceSumFields = {
  __typename?: 'stops_database_access_space_sum_fields';
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  covered?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['bigint']>;
  place_equipments_id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['bigint']>;
};

/** update columns of table "access_space" */
export enum StopsDatabaseAccessSpaceUpdateColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  LabelLang = 'label_lang',
  /** column name */
  LabelValue = 'label_value',
  /** column name */
  LevelRef = 'level_ref',
  /** column name */
  LevelRefVersion = 'level_ref_version',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  SiteRef = 'site_ref',
  /** column name */
  SiteRefVersion = 'site_ref_version',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

export type StopsDatabaseAccessSpaceUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseAccessSpaceIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseAccessSpaceSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseAccessSpaceBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseAccessSpaceVarPopFields = {
  __typename?: 'stops_database_access_space_var_pop_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseAccessSpaceVarSampFields = {
  __typename?: 'stops_database_access_space_var_samp_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseAccessSpaceVarianceFields = {
  __typename?: 'stops_database_access_space_variance_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessment = {
  __typename?: 'stops_database_accessibility_assessment';
  /** An array relationship */
  accessibility_assessment_limitations: Array<StopsDatabaseAccessibilityAssessmentLimitations>;
  /** An aggregate relationship */
  accessibility_assessment_limitations_aggregate: StopsDatabaseAccessibilityAssessmentLimitationsAggregate;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id: Scalars['bigint'];
  mobility_impaired_access?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version: Scalars['bigint'];
  version_comment?: Maybe<Scalars['String']>;
};

/** columns and relationships of "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessmentAccessibilityAssessmentLimitationsArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessibilityAssessmentLimitationsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseAccessibilityAssessmentLimitationsOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>;
  };

/** columns and relationships of "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessmentAccessibilityAssessmentLimitationsAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessibilityAssessmentLimitationsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseAccessibilityAssessmentLimitationsOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>;
  };

/** aggregated selection of "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessmentAggregate = {
  __typename?: 'stops_database_accessibility_assessment_aggregate';
  aggregate?: Maybe<StopsDatabaseAccessibilityAssessmentAggregateFields>;
  nodes: Array<StopsDatabaseAccessibilityAssessment>;
};

/** aggregate fields of "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessmentAggregateFields = {
  __typename?: 'stops_database_accessibility_assessment_aggregate_fields';
  avg?: Maybe<StopsDatabaseAccessibilityAssessmentAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseAccessibilityAssessmentMaxFields>;
  min?: Maybe<StopsDatabaseAccessibilityAssessmentMinFields>;
  stddev?: Maybe<StopsDatabaseAccessibilityAssessmentStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseAccessibilityAssessmentStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseAccessibilityAssessmentStddevSampFields>;
  sum?: Maybe<StopsDatabaseAccessibilityAssessmentSumFields>;
  var_pop?: Maybe<StopsDatabaseAccessibilityAssessmentVarPopFields>;
  var_samp?: Maybe<StopsDatabaseAccessibilityAssessmentVarSampFields>;
  variance?: Maybe<StopsDatabaseAccessibilityAssessmentVarianceFields>;
};

/** aggregate fields of "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessmentAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseAccessibilityAssessmentSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseAccessibilityAssessmentAvgFields = {
  __typename?: 'stops_database_accessibility_assessment_avg_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "accessibility_assessment". All fields are combined with a logical 'AND'. */
export type StopsDatabaseAccessibilityAssessmentBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseAccessibilityAssessmentBoolExp>>;
  _not?: InputMaybe<StopsDatabaseAccessibilityAssessmentBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseAccessibilityAssessmentBoolExp>>;
  accessibility_assessment_limitations?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>;
  accessibility_assessment_limitations_aggregate?: InputMaybe<AccessibilityAssessmentLimitationsAggregateBoolExp>;
  changed?: InputMaybe<TimestampComparisonExp>;
  changed_by?: InputMaybe<StringComparisonExp>;
  created?: InputMaybe<TimestampComparisonExp>;
  from_date?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  mobility_impaired_access?: InputMaybe<StringComparisonExp>;
  netex_id?: InputMaybe<StringComparisonExp>;
  to_date?: InputMaybe<TimestampComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
  version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "accessibility_assessment" */
export enum StopsDatabaseAccessibilityAssessmentConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  AccessibilityAssessmentNetexIdVersionConstraint = 'accessibility_assessment_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  AccessibilityAssessmentPkey = 'accessibility_assessment_pkey',
}

/** input type for incrementing numeric columns in table "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessmentIncInput = {
  id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessmentInsertInput = {
  accessibility_assessment_limitations?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsArrRelInsertInput>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  mobility_impaired_access?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitations = {
  __typename?: 'stops_database_accessibility_assessment_limitations';
  accessibility_assessment_id: Scalars['bigint'];
  /** An object relationship */
  accessibility_limitation: StopsDatabaseAccessibilityLimitation;
  limitations_id: Scalars['bigint'];
};

/** aggregated selection of "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsAggregate = {
  __typename?: 'stops_database_accessibility_assessment_limitations_aggregate';
  aggregate?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsAggregateFields>;
  nodes: Array<StopsDatabaseAccessibilityAssessmentLimitations>;
};

/** aggregate fields of "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsAggregateFields = {
  __typename?: 'stops_database_accessibility_assessment_limitations_aggregate_fields';
  avg?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsMaxFields>;
  min?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsMinFields>;
  stddev?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsStddevSampFields>;
  sum?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsSumFields>;
  var_pop?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsVarPopFields>;
  var_samp?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsVarSampFields>;
  variance?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsVarianceFields>;
};

/** aggregate fields of "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsAggregateFieldsCountArgs =
  {
    columns?: InputMaybe<
      Array<StopsDatabaseAccessibilityAssessmentLimitationsSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
  };

/** order by aggregate values of table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsArrRelInsertInput = {
  data: Array<StopsDatabaseAccessibilityAssessmentLimitationsInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseAccessibilityAssessmentLimitationsAvgFields = {
  __typename?: 'stops_database_accessibility_assessment_limitations_avg_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  limitations_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsAvgOrderBy = {
  accessibility_assessment_id?: InputMaybe<OrderBy>;
  limitations_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "accessibility_assessment_limitations". All fields are combined with a logical 'AND'. */
export type StopsDatabaseAccessibilityAssessmentLimitationsBoolExp = {
  _and?: InputMaybe<
    Array<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>
  >;
  _not?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>;
  _or?: InputMaybe<
    Array<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>
  >;
  accessibility_assessment_id?: InputMaybe<BigintComparisonExp>;
  accessibility_limitation?: InputMaybe<StopsDatabaseAccessibilityLimitationBoolExp>;
  limitations_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "accessibility_assessment_limitations" */
export enum StopsDatabaseAccessibilityAssessmentLimitationsConstraint {
  /** unique or primary key constraint on columns "limitations_id" */
  UkAeu5728ehva06k95lioaubr8s = 'uk_aeu5728ehva06k95lioaubr8s',
}

/** input type for incrementing numeric columns in table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsIncInput = {
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  limitations_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsInsertInput = {
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  accessibility_limitation?: InputMaybe<StopsDatabaseAccessibilityLimitationObjRelInsertInput>;
  limitations_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseAccessibilityAssessmentLimitationsMaxFields = {
  __typename?: 'stops_database_accessibility_assessment_limitations_max_fields';
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  limitations_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsMaxOrderBy = {
  accessibility_assessment_id?: InputMaybe<OrderBy>;
  limitations_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseAccessibilityAssessmentLimitationsMinFields = {
  __typename?: 'stops_database_accessibility_assessment_limitations_min_fields';
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  limitations_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsMinOrderBy = {
  accessibility_assessment_id?: InputMaybe<OrderBy>;
  limitations_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsMutationResponse = {
  __typename?: 'stops_database_accessibility_assessment_limitations_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseAccessibilityAssessmentLimitations>;
};

/** on_conflict condition type for table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsOnConflict = {
  constraint: StopsDatabaseAccessibilityAssessmentLimitationsConstraint;
  update_columns?: Array<StopsDatabaseAccessibilityAssessmentLimitationsUpdateColumn>;
  where?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>;
};

/** Ordering options when selecting data from "accessibility_assessment_limitations". */
export type StopsDatabaseAccessibilityAssessmentLimitationsOrderBy = {
  accessibility_assessment_id?: InputMaybe<OrderBy>;
  accessibility_limitation?: InputMaybe<StopsDatabaseAccessibilityLimitationOrderBy>;
  limitations_id?: InputMaybe<OrderBy>;
};

/** select columns of table "accessibility_assessment_limitations" */
export enum StopsDatabaseAccessibilityAssessmentLimitationsSelectColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  LimitationsId = 'limitations_id',
}

/** input type for updating data in table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsSetInput = {
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  limitations_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseAccessibilityAssessmentLimitationsStddevFields = {
  __typename?: 'stops_database_accessibility_assessment_limitations_stddev_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  limitations_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsStddevOrderBy = {
  accessibility_assessment_id?: InputMaybe<OrderBy>;
  limitations_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseAccessibilityAssessmentLimitationsStddevPopFields = {
  __typename?: 'stops_database_accessibility_assessment_limitations_stddev_pop_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  limitations_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsStddevPopOrderBy = {
  accessibility_assessment_id?: InputMaybe<OrderBy>;
  limitations_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseAccessibilityAssessmentLimitationsStddevSampFields = {
  __typename?: 'stops_database_accessibility_assessment_limitations_stddev_samp_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  limitations_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsStddevSampOrderBy = {
  accessibility_assessment_id?: InputMaybe<OrderBy>;
  limitations_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseAccessibilityAssessmentLimitationsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseAccessibilityAssessmentLimitationsStreamCursorValueInput =
  {
    accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
    limitations_id?: InputMaybe<Scalars['bigint']>;
  };

/** aggregate sum on columns */
export type StopsDatabaseAccessibilityAssessmentLimitationsSumFields = {
  __typename?: 'stops_database_accessibility_assessment_limitations_sum_fields';
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  limitations_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsSumOrderBy = {
  accessibility_assessment_id?: InputMaybe<OrderBy>;
  limitations_id?: InputMaybe<OrderBy>;
};

/** update columns of table "accessibility_assessment_limitations" */
export enum StopsDatabaseAccessibilityAssessmentLimitationsUpdateColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  LimitationsId = 'limitations_id',
}

export type StopsDatabaseAccessibilityAssessmentLimitationsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseAccessibilityAssessmentLimitationsBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseAccessibilityAssessmentLimitationsVarPopFields = {
  __typename?: 'stops_database_accessibility_assessment_limitations_var_pop_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  limitations_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsVarPopOrderBy = {
  accessibility_assessment_id?: InputMaybe<OrderBy>;
  limitations_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseAccessibilityAssessmentLimitationsVarSampFields = {
  __typename?: 'stops_database_accessibility_assessment_limitations_var_samp_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  limitations_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsVarSampOrderBy = {
  accessibility_assessment_id?: InputMaybe<OrderBy>;
  limitations_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseAccessibilityAssessmentLimitationsVarianceFields = {
  __typename?: 'stops_database_accessibility_assessment_limitations_variance_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  limitations_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsVarianceOrderBy = {
  accessibility_assessment_id?: InputMaybe<OrderBy>;
  limitations_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseAccessibilityAssessmentMaxFields = {
  __typename?: 'stops_database_accessibility_assessment_max_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  mobility_impaired_access?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseAccessibilityAssessmentMinFields = {
  __typename?: 'stops_database_accessibility_assessment_min_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  mobility_impaired_access?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessmentMutationResponse = {
  __typename?: 'stops_database_accessibility_assessment_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseAccessibilityAssessment>;
};

/** input type for inserting object relation for remote table "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessmentObjRelInsertInput = {
  data: StopsDatabaseAccessibilityAssessmentInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseAccessibilityAssessmentOnConflict>;
};

/** on_conflict condition type for table "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessmentOnConflict = {
  constraint: StopsDatabaseAccessibilityAssessmentConstraint;
  update_columns?: Array<StopsDatabaseAccessibilityAssessmentUpdateColumn>;
  where?: InputMaybe<StopsDatabaseAccessibilityAssessmentBoolExp>;
};

/** Ordering options when selecting data from "accessibility_assessment". */
export type StopsDatabaseAccessibilityAssessmentOrderBy = {
  accessibility_assessment_limitations_aggregate?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsAggregateOrderBy>;
  changed?: InputMaybe<OrderBy>;
  changed_by?: InputMaybe<OrderBy>;
  created?: InputMaybe<OrderBy>;
  from_date?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  mobility_impaired_access?: InputMaybe<OrderBy>;
  netex_id?: InputMaybe<OrderBy>;
  to_date?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
  version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: accessibility_assessment */
export type StopsDatabaseAccessibilityAssessmentPkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "accessibility_assessment" */
export enum StopsDatabaseAccessibilityAssessmentSelectColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  MobilityImpairedAccess = 'mobility_impaired_access',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

/** input type for updating data in table "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessmentSetInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  mobility_impaired_access?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseAccessibilityAssessmentStddevFields = {
  __typename?: 'stops_database_accessibility_assessment_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseAccessibilityAssessmentStddevPopFields = {
  __typename?: 'stops_database_accessibility_assessment_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseAccessibilityAssessmentStddevSampFields = {
  __typename?: 'stops_database_accessibility_assessment_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessmentStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseAccessibilityAssessmentStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseAccessibilityAssessmentStreamCursorValueInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  mobility_impaired_access?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseAccessibilityAssessmentSumFields = {
  __typename?: 'stops_database_accessibility_assessment_sum_fields';
  id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['bigint']>;
};

/** update columns of table "accessibility_assessment" */
export enum StopsDatabaseAccessibilityAssessmentUpdateColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  MobilityImpairedAccess = 'mobility_impaired_access',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

export type StopsDatabaseAccessibilityAssessmentUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseAccessibilityAssessmentIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseAccessibilityAssessmentSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseAccessibilityAssessmentBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseAccessibilityAssessmentVarPopFields = {
  __typename?: 'stops_database_accessibility_assessment_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseAccessibilityAssessmentVarSampFields = {
  __typename?: 'stops_database_accessibility_assessment_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseAccessibilityAssessmentVarianceFields = {
  __typename?: 'stops_database_accessibility_assessment_variance_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "accessibility_limitation" */
export type StopsDatabaseAccessibilityLimitation = {
  __typename?: 'stops_database_accessibility_limitation';
  audible_signals_available?: Maybe<Scalars['String']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  escalator_free_access?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id: Scalars['bigint'];
  lift_free_access?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  step_free_access?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version: Scalars['bigint'];
  version_comment?: Maybe<Scalars['String']>;
  visual_signs_available?: Maybe<Scalars['String']>;
  wheelchair_access?: Maybe<Scalars['String']>;
};

/** aggregated selection of "accessibility_limitation" */
export type StopsDatabaseAccessibilityLimitationAggregate = {
  __typename?: 'stops_database_accessibility_limitation_aggregate';
  aggregate?: Maybe<StopsDatabaseAccessibilityLimitationAggregateFields>;
  nodes: Array<StopsDatabaseAccessibilityLimitation>;
};

/** aggregate fields of "accessibility_limitation" */
export type StopsDatabaseAccessibilityLimitationAggregateFields = {
  __typename?: 'stops_database_accessibility_limitation_aggregate_fields';
  avg?: Maybe<StopsDatabaseAccessibilityLimitationAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseAccessibilityLimitationMaxFields>;
  min?: Maybe<StopsDatabaseAccessibilityLimitationMinFields>;
  stddev?: Maybe<StopsDatabaseAccessibilityLimitationStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseAccessibilityLimitationStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseAccessibilityLimitationStddevSampFields>;
  sum?: Maybe<StopsDatabaseAccessibilityLimitationSumFields>;
  var_pop?: Maybe<StopsDatabaseAccessibilityLimitationVarPopFields>;
  var_samp?: Maybe<StopsDatabaseAccessibilityLimitationVarSampFields>;
  variance?: Maybe<StopsDatabaseAccessibilityLimitationVarianceFields>;
};

/** aggregate fields of "accessibility_limitation" */
export type StopsDatabaseAccessibilityLimitationAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseAccessibilityLimitationSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseAccessibilityLimitationAvgFields = {
  __typename?: 'stops_database_accessibility_limitation_avg_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "accessibility_limitation". All fields are combined with a logical 'AND'. */
export type StopsDatabaseAccessibilityLimitationBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseAccessibilityLimitationBoolExp>>;
  _not?: InputMaybe<StopsDatabaseAccessibilityLimitationBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseAccessibilityLimitationBoolExp>>;
  audible_signals_available?: InputMaybe<StringComparisonExp>;
  changed?: InputMaybe<TimestampComparisonExp>;
  changed_by?: InputMaybe<StringComparisonExp>;
  created?: InputMaybe<TimestampComparisonExp>;
  escalator_free_access?: InputMaybe<StringComparisonExp>;
  from_date?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  lift_free_access?: InputMaybe<StringComparisonExp>;
  netex_id?: InputMaybe<StringComparisonExp>;
  step_free_access?: InputMaybe<StringComparisonExp>;
  to_date?: InputMaybe<TimestampComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
  version_comment?: InputMaybe<StringComparisonExp>;
  visual_signs_available?: InputMaybe<StringComparisonExp>;
  wheelchair_access?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "accessibility_limitation" */
export enum StopsDatabaseAccessibilityLimitationConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  AccessibilityLimitationNetexIdVersionConstraint = 'accessibility_limitation_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  AccessibilityLimitationPkey = 'accessibility_limitation_pkey',
}

/** input type for incrementing numeric columns in table "accessibility_limitation" */
export type StopsDatabaseAccessibilityLimitationIncInput = {
  id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "accessibility_limitation" */
export type StopsDatabaseAccessibilityLimitationInsertInput = {
  audible_signals_available?: InputMaybe<Scalars['String']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  escalator_free_access?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  lift_free_access?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  step_free_access?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
  visual_signs_available?: InputMaybe<Scalars['String']>;
  wheelchair_access?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type StopsDatabaseAccessibilityLimitationMaxFields = {
  __typename?: 'stops_database_accessibility_limitation_max_fields';
  audible_signals_available?: Maybe<Scalars['String']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  escalator_free_access?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  lift_free_access?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  step_free_access?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
  visual_signs_available?: Maybe<Scalars['String']>;
  wheelchair_access?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseAccessibilityLimitationMinFields = {
  __typename?: 'stops_database_accessibility_limitation_min_fields';
  audible_signals_available?: Maybe<Scalars['String']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  escalator_free_access?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  lift_free_access?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  step_free_access?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
  visual_signs_available?: Maybe<Scalars['String']>;
  wheelchair_access?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "accessibility_limitation" */
export type StopsDatabaseAccessibilityLimitationMutationResponse = {
  __typename?: 'stops_database_accessibility_limitation_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseAccessibilityLimitation>;
};

/** input type for inserting object relation for remote table "accessibility_limitation" */
export type StopsDatabaseAccessibilityLimitationObjRelInsertInput = {
  data: StopsDatabaseAccessibilityLimitationInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseAccessibilityLimitationOnConflict>;
};

/** on_conflict condition type for table "accessibility_limitation" */
export type StopsDatabaseAccessibilityLimitationOnConflict = {
  constraint: StopsDatabaseAccessibilityLimitationConstraint;
  update_columns?: Array<StopsDatabaseAccessibilityLimitationUpdateColumn>;
  where?: InputMaybe<StopsDatabaseAccessibilityLimitationBoolExp>;
};

/** Ordering options when selecting data from "accessibility_limitation". */
export type StopsDatabaseAccessibilityLimitationOrderBy = {
  audible_signals_available?: InputMaybe<OrderBy>;
  changed?: InputMaybe<OrderBy>;
  changed_by?: InputMaybe<OrderBy>;
  created?: InputMaybe<OrderBy>;
  escalator_free_access?: InputMaybe<OrderBy>;
  from_date?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lift_free_access?: InputMaybe<OrderBy>;
  netex_id?: InputMaybe<OrderBy>;
  step_free_access?: InputMaybe<OrderBy>;
  to_date?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
  version_comment?: InputMaybe<OrderBy>;
  visual_signs_available?: InputMaybe<OrderBy>;
  wheelchair_access?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: accessibility_limitation */
export type StopsDatabaseAccessibilityLimitationPkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "accessibility_limitation" */
export enum StopsDatabaseAccessibilityLimitationSelectColumn {
  /** column name */
  AudibleSignalsAvailable = 'audible_signals_available',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  EscalatorFreeAccess = 'escalator_free_access',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  LiftFreeAccess = 'lift_free_access',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  StepFreeAccess = 'step_free_access',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  VisualSignsAvailable = 'visual_signs_available',
  /** column name */
  WheelchairAccess = 'wheelchair_access',
}

/** input type for updating data in table "accessibility_limitation" */
export type StopsDatabaseAccessibilityLimitationSetInput = {
  audible_signals_available?: InputMaybe<Scalars['String']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  escalator_free_access?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  lift_free_access?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  step_free_access?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
  visual_signs_available?: InputMaybe<Scalars['String']>;
  wheelchair_access?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseAccessibilityLimitationStddevFields = {
  __typename?: 'stops_database_accessibility_limitation_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseAccessibilityLimitationStddevPopFields = {
  __typename?: 'stops_database_accessibility_limitation_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseAccessibilityLimitationStddevSampFields = {
  __typename?: 'stops_database_accessibility_limitation_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "accessibility_limitation" */
export type StopsDatabaseAccessibilityLimitationStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseAccessibilityLimitationStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseAccessibilityLimitationStreamCursorValueInput = {
  audible_signals_available?: InputMaybe<Scalars['String']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  escalator_free_access?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  lift_free_access?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  step_free_access?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
  visual_signs_available?: InputMaybe<Scalars['String']>;
  wheelchair_access?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseAccessibilityLimitationSumFields = {
  __typename?: 'stops_database_accessibility_limitation_sum_fields';
  id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['bigint']>;
};

/** update columns of table "accessibility_limitation" */
export enum StopsDatabaseAccessibilityLimitationUpdateColumn {
  /** column name */
  AudibleSignalsAvailable = 'audible_signals_available',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  EscalatorFreeAccess = 'escalator_free_access',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  LiftFreeAccess = 'lift_free_access',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  StepFreeAccess = 'step_free_access',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  VisualSignsAvailable = 'visual_signs_available',
  /** column name */
  WheelchairAccess = 'wheelchair_access',
}

export type StopsDatabaseAccessibilityLimitationUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseAccessibilityLimitationIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseAccessibilityLimitationSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseAccessibilityLimitationBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseAccessibilityLimitationVarPopFields = {
  __typename?: 'stops_database_accessibility_limitation_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseAccessibilityLimitationVarSampFields = {
  __typename?: 'stops_database_accessibility_limitation_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseAccessibilityLimitationVarianceFields = {
  __typename?: 'stops_database_accessibility_limitation_variance_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "alternative_name" */
export type StopsDatabaseAlternativeName = {
  __typename?: 'stops_database_alternative_name';
  abbreviation_lang?: Maybe<Scalars['String']>;
  abbreviation_value?: Maybe<Scalars['String']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id: Scalars['bigint'];
  lang?: Maybe<Scalars['String']>;
  name_lang?: Maybe<Scalars['String']>;
  name_type?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  named_object_ref?: Maybe<Scalars['bytea']>;
  netex_id?: Maybe<Scalars['String']>;
  qualifier_name_lang?: Maybe<Scalars['String']>;
  qualifier_name_value?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  type_of_name?: Maybe<Scalars['String']>;
  version: Scalars['bigint'];
  version_comment?: Maybe<Scalars['String']>;
};

/** aggregated selection of "alternative_name" */
export type StopsDatabaseAlternativeNameAggregate = {
  __typename?: 'stops_database_alternative_name_aggregate';
  aggregate?: Maybe<StopsDatabaseAlternativeNameAggregateFields>;
  nodes: Array<StopsDatabaseAlternativeName>;
};

/** aggregate fields of "alternative_name" */
export type StopsDatabaseAlternativeNameAggregateFields = {
  __typename?: 'stops_database_alternative_name_aggregate_fields';
  avg?: Maybe<StopsDatabaseAlternativeNameAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseAlternativeNameMaxFields>;
  min?: Maybe<StopsDatabaseAlternativeNameMinFields>;
  stddev?: Maybe<StopsDatabaseAlternativeNameStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseAlternativeNameStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseAlternativeNameStddevSampFields>;
  sum?: Maybe<StopsDatabaseAlternativeNameSumFields>;
  var_pop?: Maybe<StopsDatabaseAlternativeNameVarPopFields>;
  var_samp?: Maybe<StopsDatabaseAlternativeNameVarSampFields>;
  variance?: Maybe<StopsDatabaseAlternativeNameVarianceFields>;
};

/** aggregate fields of "alternative_name" */
export type StopsDatabaseAlternativeNameAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseAlternativeNameSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseAlternativeNameAvgFields = {
  __typename?: 'stops_database_alternative_name_avg_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "alternative_name". All fields are combined with a logical 'AND'. */
export type StopsDatabaseAlternativeNameBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseAlternativeNameBoolExp>>;
  _not?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseAlternativeNameBoolExp>>;
  abbreviation_lang?: InputMaybe<StringComparisonExp>;
  abbreviation_value?: InputMaybe<StringComparisonExp>;
  changed?: InputMaybe<TimestampComparisonExp>;
  changed_by?: InputMaybe<StringComparisonExp>;
  created?: InputMaybe<TimestampComparisonExp>;
  from_date?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  lang?: InputMaybe<StringComparisonExp>;
  name_lang?: InputMaybe<StringComparisonExp>;
  name_type?: InputMaybe<StringComparisonExp>;
  name_value?: InputMaybe<StringComparisonExp>;
  named_object_ref?: InputMaybe<ByteaComparisonExp>;
  netex_id?: InputMaybe<StringComparisonExp>;
  qualifier_name_lang?: InputMaybe<StringComparisonExp>;
  qualifier_name_value?: InputMaybe<StringComparisonExp>;
  short_name_lang?: InputMaybe<StringComparisonExp>;
  short_name_value?: InputMaybe<StringComparisonExp>;
  to_date?: InputMaybe<TimestampComparisonExp>;
  type_of_name?: InputMaybe<StringComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
  version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "alternative_name" */
export enum StopsDatabaseAlternativeNameConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  AlternativeNameNetexIdVersionConstraint = 'alternative_name_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  AlternativeNamePkey = 'alternative_name_pkey',
}

/** input type for incrementing numeric columns in table "alternative_name" */
export type StopsDatabaseAlternativeNameIncInput = {
  id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "alternative_name" */
export type StopsDatabaseAlternativeNameInsertInput = {
  abbreviation_lang?: InputMaybe<Scalars['String']>;
  abbreviation_value?: InputMaybe<Scalars['String']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  lang?: InputMaybe<Scalars['String']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_type?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  named_object_ref?: InputMaybe<Scalars['bytea']>;
  netex_id?: InputMaybe<Scalars['String']>;
  qualifier_name_lang?: InputMaybe<Scalars['String']>;
  qualifier_name_value?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  type_of_name?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type StopsDatabaseAlternativeNameMaxFields = {
  __typename?: 'stops_database_alternative_name_max_fields';
  abbreviation_lang?: Maybe<Scalars['String']>;
  abbreviation_value?: Maybe<Scalars['String']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  lang?: Maybe<Scalars['String']>;
  name_lang?: Maybe<Scalars['String']>;
  name_type?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  qualifier_name_lang?: Maybe<Scalars['String']>;
  qualifier_name_value?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  type_of_name?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseAlternativeNameMinFields = {
  __typename?: 'stops_database_alternative_name_min_fields';
  abbreviation_lang?: Maybe<Scalars['String']>;
  abbreviation_value?: Maybe<Scalars['String']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  lang?: Maybe<Scalars['String']>;
  name_lang?: Maybe<Scalars['String']>;
  name_type?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  qualifier_name_lang?: Maybe<Scalars['String']>;
  qualifier_name_value?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  type_of_name?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "alternative_name" */
export type StopsDatabaseAlternativeNameMutationResponse = {
  __typename?: 'stops_database_alternative_name_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseAlternativeName>;
};

/** input type for inserting object relation for remote table "alternative_name" */
export type StopsDatabaseAlternativeNameObjRelInsertInput = {
  data: StopsDatabaseAlternativeNameInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseAlternativeNameOnConflict>;
};

/** on_conflict condition type for table "alternative_name" */
export type StopsDatabaseAlternativeNameOnConflict = {
  constraint: StopsDatabaseAlternativeNameConstraint;
  update_columns?: Array<StopsDatabaseAlternativeNameUpdateColumn>;
  where?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
};

/** Ordering options when selecting data from "alternative_name". */
export type StopsDatabaseAlternativeNameOrderBy = {
  abbreviation_lang?: InputMaybe<OrderBy>;
  abbreviation_value?: InputMaybe<OrderBy>;
  changed?: InputMaybe<OrderBy>;
  changed_by?: InputMaybe<OrderBy>;
  created?: InputMaybe<OrderBy>;
  from_date?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lang?: InputMaybe<OrderBy>;
  name_lang?: InputMaybe<OrderBy>;
  name_type?: InputMaybe<OrderBy>;
  name_value?: InputMaybe<OrderBy>;
  named_object_ref?: InputMaybe<OrderBy>;
  netex_id?: InputMaybe<OrderBy>;
  qualifier_name_lang?: InputMaybe<OrderBy>;
  qualifier_name_value?: InputMaybe<OrderBy>;
  short_name_lang?: InputMaybe<OrderBy>;
  short_name_value?: InputMaybe<OrderBy>;
  to_date?: InputMaybe<OrderBy>;
  type_of_name?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
  version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: alternative_name */
export type StopsDatabaseAlternativeNamePkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "alternative_name" */
export enum StopsDatabaseAlternativeNameSelectColumn {
  /** column name */
  AbbreviationLang = 'abbreviation_lang',
  /** column name */
  AbbreviationValue = 'abbreviation_value',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  Lang = 'lang',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameType = 'name_type',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NamedObjectRef = 'named_object_ref',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  QualifierNameLang = 'qualifier_name_lang',
  /** column name */
  QualifierNameValue = 'qualifier_name_value',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TypeOfName = 'type_of_name',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

/** input type for updating data in table "alternative_name" */
export type StopsDatabaseAlternativeNameSetInput = {
  abbreviation_lang?: InputMaybe<Scalars['String']>;
  abbreviation_value?: InputMaybe<Scalars['String']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  lang?: InputMaybe<Scalars['String']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_type?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  named_object_ref?: InputMaybe<Scalars['bytea']>;
  netex_id?: InputMaybe<Scalars['String']>;
  qualifier_name_lang?: InputMaybe<Scalars['String']>;
  qualifier_name_value?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  type_of_name?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseAlternativeNameStddevFields = {
  __typename?: 'stops_database_alternative_name_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseAlternativeNameStddevPopFields = {
  __typename?: 'stops_database_alternative_name_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseAlternativeNameStddevSampFields = {
  __typename?: 'stops_database_alternative_name_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "alternative_name" */
export type StopsDatabaseAlternativeNameStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseAlternativeNameStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseAlternativeNameStreamCursorValueInput = {
  abbreviation_lang?: InputMaybe<Scalars['String']>;
  abbreviation_value?: InputMaybe<Scalars['String']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  lang?: InputMaybe<Scalars['String']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_type?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  named_object_ref?: InputMaybe<Scalars['bytea']>;
  netex_id?: InputMaybe<Scalars['String']>;
  qualifier_name_lang?: InputMaybe<Scalars['String']>;
  qualifier_name_value?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  type_of_name?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseAlternativeNameSumFields = {
  __typename?: 'stops_database_alternative_name_sum_fields';
  id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['bigint']>;
};

/** update columns of table "alternative_name" */
export enum StopsDatabaseAlternativeNameUpdateColumn {
  /** column name */
  AbbreviationLang = 'abbreviation_lang',
  /** column name */
  AbbreviationValue = 'abbreviation_value',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  Lang = 'lang',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameType = 'name_type',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NamedObjectRef = 'named_object_ref',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  QualifierNameLang = 'qualifier_name_lang',
  /** column name */
  QualifierNameValue = 'qualifier_name_value',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TypeOfName = 'type_of_name',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

export type StopsDatabaseAlternativeNameUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseAlternativeNameIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseAlternativeNameSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseAlternativeNameBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseAlternativeNameVarPopFields = {
  __typename?: 'stops_database_alternative_name_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseAlternativeNameVarSampFields = {
  __typename?: 'stops_database_alternative_name_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseAlternativeNameVarianceFields = {
  __typename?: 'stops_database_alternative_name_variance_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "boarding_position" */
export type StopsDatabaseBoardingPosition = {
  __typename?: 'stops_database_boarding_position';
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  all_areas_wheelchair_accessible?: Maybe<Scalars['Boolean']>;
  /** An array relationship */
  boarding_position_alternative_names: Array<StopsDatabaseBoardingPositionAlternativeNames>;
  /** An aggregate relationship */
  boarding_position_alternative_names_aggregate: StopsDatabaseBoardingPositionAlternativeNamesAggregate;
  /** An array relationship */
  boarding_position_equipment_places: Array<StopsDatabaseBoardingPositionEquipmentPlaces>;
  /** An aggregate relationship */
  boarding_position_equipment_places_aggregate: StopsDatabaseBoardingPositionEquipmentPlacesAggregate;
  /** An array relationship */
  boarding_position_key_values: Array<StopsDatabaseBoardingPositionKeyValues>;
  /** An aggregate relationship */
  boarding_position_key_values_aggregate: StopsDatabaseBoardingPositionKeyValuesAggregate;
  boarding_position_type?: Maybe<Scalars['String']>;
  centroid?: Maybe<Scalars['geometry']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  covered?: Maybe<Scalars['Int']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id: Scalars['bigint'];
  /** An object relationship */
  installed_equipment_version_structure?: Maybe<StopsDatabaseInstalledEquipmentVersionStructure>;
  label_lang?: Maybe<Scalars['String']>;
  label_value?: Maybe<Scalars['String']>;
  level_ref?: Maybe<Scalars['String']>;
  level_ref_version?: Maybe<Scalars['String']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  /** An object relationship */
  persistable_polygon?: Maybe<StopsDatabasePersistablePolygon>;
  place_equipments_id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  public_code?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  site_ref?: Maybe<Scalars['String']>;
  site_ref_version?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version: Scalars['bigint'];
  version_comment?: Maybe<Scalars['String']>;
};

/** columns and relationships of "boarding_position" */
export type StopsDatabaseBoardingPositionBoardingPositionAlternativeNamesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseBoardingPositionAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseBoardingPositionAlternativeNamesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>;
  };

/** columns and relationships of "boarding_position" */
export type StopsDatabaseBoardingPositionBoardingPositionAlternativeNamesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseBoardingPositionAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseBoardingPositionAlternativeNamesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>;
  };

/** columns and relationships of "boarding_position" */
export type StopsDatabaseBoardingPositionBoardingPositionEquipmentPlacesArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseBoardingPositionEquipmentPlacesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<
    Array<StopsDatabaseBoardingPositionEquipmentPlacesOrderBy>
  >;
  where?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>;
};

/** columns and relationships of "boarding_position" */
export type StopsDatabaseBoardingPositionBoardingPositionEquipmentPlacesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseBoardingPositionEquipmentPlacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseBoardingPositionEquipmentPlacesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>;
  };

/** columns and relationships of "boarding_position" */
export type StopsDatabaseBoardingPositionBoardingPositionKeyValuesArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseBoardingPositionKeyValuesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseBoardingPositionKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesBoolExp>;
};

/** columns and relationships of "boarding_position" */
export type StopsDatabaseBoardingPositionBoardingPositionKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseBoardingPositionKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseBoardingPositionKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesBoolExp>;
  };

/** aggregated selection of "boarding_position" */
export type StopsDatabaseBoardingPositionAggregate = {
  __typename?: 'stops_database_boarding_position_aggregate';
  aggregate?: Maybe<StopsDatabaseBoardingPositionAggregateFields>;
  nodes: Array<StopsDatabaseBoardingPosition>;
};

/** aggregate fields of "boarding_position" */
export type StopsDatabaseBoardingPositionAggregateFields = {
  __typename?: 'stops_database_boarding_position_aggregate_fields';
  avg?: Maybe<StopsDatabaseBoardingPositionAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseBoardingPositionMaxFields>;
  min?: Maybe<StopsDatabaseBoardingPositionMinFields>;
  stddev?: Maybe<StopsDatabaseBoardingPositionStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseBoardingPositionStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseBoardingPositionStddevSampFields>;
  sum?: Maybe<StopsDatabaseBoardingPositionSumFields>;
  var_pop?: Maybe<StopsDatabaseBoardingPositionVarPopFields>;
  var_samp?: Maybe<StopsDatabaseBoardingPositionVarSampFields>;
  variance?: Maybe<StopsDatabaseBoardingPositionVarianceFields>;
};

/** aggregate fields of "boarding_position" */
export type StopsDatabaseBoardingPositionAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseBoardingPositionSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** columns and relationships of "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNames = {
  __typename?: 'stops_database_boarding_position_alternative_names';
  /** An object relationship */
  alternative_name: StopsDatabaseAlternativeName;
  alternative_names_id: Scalars['bigint'];
  boarding_position_id: Scalars['bigint'];
};

/** aggregated selection of "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesAggregate = {
  __typename?: 'stops_database_boarding_position_alternative_names_aggregate';
  aggregate?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesAggregateFields>;
  nodes: Array<StopsDatabaseBoardingPositionAlternativeNames>;
};

/** aggregate fields of "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesAggregateFields = {
  __typename?: 'stops_database_boarding_position_alternative_names_aggregate_fields';
  avg?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesMaxFields>;
  min?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesMinFields>;
  stddev?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesStddevSampFields>;
  sum?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesSumFields>;
  var_pop?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesVarSampFields>;
  variance?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesVarianceFields>;
};

/** aggregate fields of "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesAggregateFieldsCountArgs =
  {
    columns?: InputMaybe<
      Array<StopsDatabaseBoardingPositionAlternativeNamesSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
  };

/** order by aggregate values of table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesArrRelInsertInput = {
  data: Array<StopsDatabaseBoardingPositionAlternativeNamesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseBoardingPositionAlternativeNamesAvgFields = {
  __typename?: 'stops_database_boarding_position_alternative_names_avg_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  boarding_position_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesAvgOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  boarding_position_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "boarding_position_alternative_names". All fields are combined with a logical 'AND'. */
export type StopsDatabaseBoardingPositionAlternativeNamesBoolExp = {
  _and?: InputMaybe<
    Array<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>
  >;
  _not?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>>;
  alternative_name?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
  alternative_names_id?: InputMaybe<BigintComparisonExp>;
  boarding_position_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "boarding_position_alternative_names" */
export enum StopsDatabaseBoardingPositionAlternativeNamesConstraint {
  /** unique or primary key constraint on columns "alternative_names_id" */
  Uk_250rbh3vi00fvoca1dqy5dnwa = 'uk_250rbh3vi00fvoca1dqy5dnwa',
}

/** input type for incrementing numeric columns in table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesIncInput = {
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
  boarding_position_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesInsertInput = {
  alternative_name?: InputMaybe<StopsDatabaseAlternativeNameObjRelInsertInput>;
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
  boarding_position_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseBoardingPositionAlternativeNamesMaxFields = {
  __typename?: 'stops_database_boarding_position_alternative_names_max_fields';
  alternative_names_id?: Maybe<Scalars['bigint']>;
  boarding_position_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesMaxOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  boarding_position_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseBoardingPositionAlternativeNamesMinFields = {
  __typename?: 'stops_database_boarding_position_alternative_names_min_fields';
  alternative_names_id?: Maybe<Scalars['bigint']>;
  boarding_position_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesMinOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  boarding_position_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesMutationResponse = {
  __typename?: 'stops_database_boarding_position_alternative_names_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseBoardingPositionAlternativeNames>;
};

/** on_conflict condition type for table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesOnConflict = {
  constraint: StopsDatabaseBoardingPositionAlternativeNamesConstraint;
  update_columns?: Array<StopsDatabaseBoardingPositionAlternativeNamesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>;
};

/** Ordering options when selecting data from "boarding_position_alternative_names". */
export type StopsDatabaseBoardingPositionAlternativeNamesOrderBy = {
  alternative_name?: InputMaybe<StopsDatabaseAlternativeNameOrderBy>;
  alternative_names_id?: InputMaybe<OrderBy>;
  boarding_position_id?: InputMaybe<OrderBy>;
};

/** select columns of table "boarding_position_alternative_names" */
export enum StopsDatabaseBoardingPositionAlternativeNamesSelectColumn {
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
  /** column name */
  BoardingPositionId = 'boarding_position_id',
}

/** input type for updating data in table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesSetInput = {
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
  boarding_position_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseBoardingPositionAlternativeNamesStddevFields = {
  __typename?: 'stops_database_boarding_position_alternative_names_stddev_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  boarding_position_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesStddevOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  boarding_position_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseBoardingPositionAlternativeNamesStddevPopFields = {
  __typename?: 'stops_database_boarding_position_alternative_names_stddev_pop_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  boarding_position_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesStddevPopOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  boarding_position_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseBoardingPositionAlternativeNamesStddevSampFields = {
  __typename?: 'stops_database_boarding_position_alternative_names_stddev_samp_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  boarding_position_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesStddevSampOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  boarding_position_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseBoardingPositionAlternativeNamesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseBoardingPositionAlternativeNamesStreamCursorValueInput =
  {
    alternative_names_id?: InputMaybe<Scalars['bigint']>;
    boarding_position_id?: InputMaybe<Scalars['bigint']>;
  };

/** aggregate sum on columns */
export type StopsDatabaseBoardingPositionAlternativeNamesSumFields = {
  __typename?: 'stops_database_boarding_position_alternative_names_sum_fields';
  alternative_names_id?: Maybe<Scalars['bigint']>;
  boarding_position_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesSumOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  boarding_position_id?: InputMaybe<OrderBy>;
};

/** update columns of table "boarding_position_alternative_names" */
export enum StopsDatabaseBoardingPositionAlternativeNamesUpdateColumn {
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
  /** column name */
  BoardingPositionId = 'boarding_position_id',
}

export type StopsDatabaseBoardingPositionAlternativeNamesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseBoardingPositionAlternativeNamesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseBoardingPositionAlternativeNamesVarPopFields = {
  __typename?: 'stops_database_boarding_position_alternative_names_var_pop_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  boarding_position_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesVarPopOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  boarding_position_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseBoardingPositionAlternativeNamesVarSampFields = {
  __typename?: 'stops_database_boarding_position_alternative_names_var_samp_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  boarding_position_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesVarSampOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  boarding_position_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseBoardingPositionAlternativeNamesVarianceFields = {
  __typename?: 'stops_database_boarding_position_alternative_names_variance_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  boarding_position_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesVarianceOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  boarding_position_id?: InputMaybe<OrderBy>;
};

/** aggregate avg on columns */
export type StopsDatabaseBoardingPositionAvgFields = {
  __typename?: 'stops_database_boarding_position_avg_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "boarding_position". All fields are combined with a logical 'AND'. */
export type StopsDatabaseBoardingPositionBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseBoardingPositionBoolExp>>;
  _not?: InputMaybe<StopsDatabaseBoardingPositionBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseBoardingPositionBoolExp>>;
  accessibility_assessment_id?: InputMaybe<BigintComparisonExp>;
  all_areas_wheelchair_accessible?: InputMaybe<BooleanComparisonExp>;
  boarding_position_alternative_names?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>;
  boarding_position_alternative_names_aggregate?: InputMaybe<BoardingPositionAlternativeNamesAggregateBoolExp>;
  boarding_position_equipment_places?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>;
  boarding_position_equipment_places_aggregate?: InputMaybe<BoardingPositionEquipmentPlacesAggregateBoolExp>;
  boarding_position_key_values?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesBoolExp>;
  boarding_position_key_values_aggregate?: InputMaybe<BoardingPositionKeyValuesAggregateBoolExp>;
  boarding_position_type?: InputMaybe<StringComparisonExp>;
  centroid?: InputMaybe<GeometryComparisonExp>;
  changed?: InputMaybe<TimestampComparisonExp>;
  changed_by?: InputMaybe<StringComparisonExp>;
  covered?: InputMaybe<IntComparisonExp>;
  created?: InputMaybe<TimestampComparisonExp>;
  description_lang?: InputMaybe<StringComparisonExp>;
  description_value?: InputMaybe<StringComparisonExp>;
  from_date?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
  label_lang?: InputMaybe<StringComparisonExp>;
  label_value?: InputMaybe<StringComparisonExp>;
  level_ref?: InputMaybe<StringComparisonExp>;
  level_ref_version?: InputMaybe<StringComparisonExp>;
  name_lang?: InputMaybe<StringComparisonExp>;
  name_value?: InputMaybe<StringComparisonExp>;
  netex_id?: InputMaybe<StringComparisonExp>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  place_equipments_id?: InputMaybe<BigintComparisonExp>;
  polygon_id?: InputMaybe<BigintComparisonExp>;
  private_code_type?: InputMaybe<StringComparisonExp>;
  private_code_value?: InputMaybe<StringComparisonExp>;
  public_code?: InputMaybe<StringComparisonExp>;
  short_name_lang?: InputMaybe<StringComparisonExp>;
  short_name_value?: InputMaybe<StringComparisonExp>;
  site_ref?: InputMaybe<StringComparisonExp>;
  site_ref_version?: InputMaybe<StringComparisonExp>;
  to_date?: InputMaybe<TimestampComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
  version_comment?: InputMaybe<StringComparisonExp>;
};

/** columns and relationships of "boarding_position_check_constraints" */
export type StopsDatabaseBoardingPositionCheckConstraints = {
  __typename?: 'stops_database_boarding_position_check_constraints';
  boarding_position_id: Scalars['bigint'];
  check_constraints_id: Scalars['bigint'];
};

/** aggregated selection of "boarding_position_check_constraints" */
export type StopsDatabaseBoardingPositionCheckConstraintsAggregate = {
  __typename?: 'stops_database_boarding_position_check_constraints_aggregate';
  aggregate?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsAggregateFields>;
  nodes: Array<StopsDatabaseBoardingPositionCheckConstraints>;
};

/** aggregate fields of "boarding_position_check_constraints" */
export type StopsDatabaseBoardingPositionCheckConstraintsAggregateFields = {
  __typename?: 'stops_database_boarding_position_check_constraints_aggregate_fields';
  avg?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsMaxFields>;
  min?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsMinFields>;
  stddev?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsStddevSampFields>;
  sum?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsSumFields>;
  var_pop?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsVarPopFields>;
  var_samp?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsVarSampFields>;
  variance?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsVarianceFields>;
};

/** aggregate fields of "boarding_position_check_constraints" */
export type StopsDatabaseBoardingPositionCheckConstraintsAggregateFieldsCountArgs =
  {
    columns?: InputMaybe<
      Array<StopsDatabaseBoardingPositionCheckConstraintsSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
  };

/** aggregate avg on columns */
export type StopsDatabaseBoardingPositionCheckConstraintsAvgFields = {
  __typename?: 'stops_database_boarding_position_check_constraints_avg_fields';
  boarding_position_id?: Maybe<Scalars['Float']>;
  check_constraints_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "boarding_position_check_constraints". All fields are combined with a logical 'AND'. */
export type StopsDatabaseBoardingPositionCheckConstraintsBoolExp = {
  _and?: InputMaybe<
    Array<StopsDatabaseBoardingPositionCheckConstraintsBoolExp>
  >;
  _not?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseBoardingPositionCheckConstraintsBoolExp>>;
  boarding_position_id?: InputMaybe<BigintComparisonExp>;
  check_constraints_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "boarding_position_check_constraints" */
export enum StopsDatabaseBoardingPositionCheckConstraintsConstraint {
  /** unique or primary key constraint on columns "check_constraints_id" */
  UkPcbtfcjcauaikel1s4uqjfldp = 'uk_pcbtfcjcauaikel1s4uqjfldp',
}

/** input type for incrementing numeric columns in table "boarding_position_check_constraints" */
export type StopsDatabaseBoardingPositionCheckConstraintsIncInput = {
  boarding_position_id?: InputMaybe<Scalars['bigint']>;
  check_constraints_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "boarding_position_check_constraints" */
export type StopsDatabaseBoardingPositionCheckConstraintsInsertInput = {
  boarding_position_id?: InputMaybe<Scalars['bigint']>;
  check_constraints_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseBoardingPositionCheckConstraintsMaxFields = {
  __typename?: 'stops_database_boarding_position_check_constraints_max_fields';
  boarding_position_id?: Maybe<Scalars['bigint']>;
  check_constraints_id?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type StopsDatabaseBoardingPositionCheckConstraintsMinFields = {
  __typename?: 'stops_database_boarding_position_check_constraints_min_fields';
  boarding_position_id?: Maybe<Scalars['bigint']>;
  check_constraints_id?: Maybe<Scalars['bigint']>;
};

/** response of any mutation on the table "boarding_position_check_constraints" */
export type StopsDatabaseBoardingPositionCheckConstraintsMutationResponse = {
  __typename?: 'stops_database_boarding_position_check_constraints_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseBoardingPositionCheckConstraints>;
};

/** on_conflict condition type for table "boarding_position_check_constraints" */
export type StopsDatabaseBoardingPositionCheckConstraintsOnConflict = {
  constraint: StopsDatabaseBoardingPositionCheckConstraintsConstraint;
  update_columns?: Array<StopsDatabaseBoardingPositionCheckConstraintsUpdateColumn>;
  where?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsBoolExp>;
};

/** Ordering options when selecting data from "boarding_position_check_constraints". */
export type StopsDatabaseBoardingPositionCheckConstraintsOrderBy = {
  boarding_position_id?: InputMaybe<OrderBy>;
  check_constraints_id?: InputMaybe<OrderBy>;
};

/** select columns of table "boarding_position_check_constraints" */
export enum StopsDatabaseBoardingPositionCheckConstraintsSelectColumn {
  /** column name */
  BoardingPositionId = 'boarding_position_id',
  /** column name */
  CheckConstraintsId = 'check_constraints_id',
}

/** input type for updating data in table "boarding_position_check_constraints" */
export type StopsDatabaseBoardingPositionCheckConstraintsSetInput = {
  boarding_position_id?: InputMaybe<Scalars['bigint']>;
  check_constraints_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseBoardingPositionCheckConstraintsStddevFields = {
  __typename?: 'stops_database_boarding_position_check_constraints_stddev_fields';
  boarding_position_id?: Maybe<Scalars['Float']>;
  check_constraints_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseBoardingPositionCheckConstraintsStddevPopFields = {
  __typename?: 'stops_database_boarding_position_check_constraints_stddev_pop_fields';
  boarding_position_id?: Maybe<Scalars['Float']>;
  check_constraints_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseBoardingPositionCheckConstraintsStddevSampFields = {
  __typename?: 'stops_database_boarding_position_check_constraints_stddev_samp_fields';
  boarding_position_id?: Maybe<Scalars['Float']>;
  check_constraints_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "boarding_position_check_constraints" */
export type StopsDatabaseBoardingPositionCheckConstraintsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseBoardingPositionCheckConstraintsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseBoardingPositionCheckConstraintsStreamCursorValueInput =
  {
    boarding_position_id?: InputMaybe<Scalars['bigint']>;
    check_constraints_id?: InputMaybe<Scalars['bigint']>;
  };

/** aggregate sum on columns */
export type StopsDatabaseBoardingPositionCheckConstraintsSumFields = {
  __typename?: 'stops_database_boarding_position_check_constraints_sum_fields';
  boarding_position_id?: Maybe<Scalars['bigint']>;
  check_constraints_id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "boarding_position_check_constraints" */
export enum StopsDatabaseBoardingPositionCheckConstraintsUpdateColumn {
  /** column name */
  BoardingPositionId = 'boarding_position_id',
  /** column name */
  CheckConstraintsId = 'check_constraints_id',
}

export type StopsDatabaseBoardingPositionCheckConstraintsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseBoardingPositionCheckConstraintsBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseBoardingPositionCheckConstraintsVarPopFields = {
  __typename?: 'stops_database_boarding_position_check_constraints_var_pop_fields';
  boarding_position_id?: Maybe<Scalars['Float']>;
  check_constraints_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseBoardingPositionCheckConstraintsVarSampFields = {
  __typename?: 'stops_database_boarding_position_check_constraints_var_samp_fields';
  boarding_position_id?: Maybe<Scalars['Float']>;
  check_constraints_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseBoardingPositionCheckConstraintsVarianceFields = {
  __typename?: 'stops_database_boarding_position_check_constraints_variance_fields';
  boarding_position_id?: Maybe<Scalars['Float']>;
  check_constraints_id?: Maybe<Scalars['Float']>;
};

/** unique or primary key constraints on table "boarding_position" */
export enum StopsDatabaseBoardingPositionConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  BoardingPositionNetexIdVersionConstraint = 'boarding_position_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  BoardingPositionPkey = 'boarding_position_pkey',
}

/** columns and relationships of "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlaces = {
  __typename?: 'stops_database_boarding_position_equipment_places';
  boarding_position_id: Scalars['bigint'];
  /** An object relationship */
  equipment_place: StopsDatabaseEquipmentPlace;
  equipment_places_id: Scalars['bigint'];
};

/** aggregated selection of "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesAggregate = {
  __typename?: 'stops_database_boarding_position_equipment_places_aggregate';
  aggregate?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesAggregateFields>;
  nodes: Array<StopsDatabaseBoardingPositionEquipmentPlaces>;
};

/** aggregate fields of "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesAggregateFields = {
  __typename?: 'stops_database_boarding_position_equipment_places_aggregate_fields';
  avg?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesMaxFields>;
  min?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesMinFields>;
  stddev?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesStddevSampFields>;
  sum?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesSumFields>;
  var_pop?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesVarSampFields>;
  variance?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesVarianceFields>;
};

/** aggregate fields of "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesAggregateFieldsCountArgs =
  {
    columns?: InputMaybe<
      Array<StopsDatabaseBoardingPositionEquipmentPlacesSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
  };

/** order by aggregate values of table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesArrRelInsertInput = {
  data: Array<StopsDatabaseBoardingPositionEquipmentPlacesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseBoardingPositionEquipmentPlacesAvgFields = {
  __typename?: 'stops_database_boarding_position_equipment_places_avg_fields';
  boarding_position_id?: Maybe<Scalars['Float']>;
  equipment_places_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesAvgOrderBy = {
  boarding_position_id?: InputMaybe<OrderBy>;
  equipment_places_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "boarding_position_equipment_places". All fields are combined with a logical 'AND'. */
export type StopsDatabaseBoardingPositionEquipmentPlacesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>>;
  boarding_position_id?: InputMaybe<BigintComparisonExp>;
  equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceBoolExp>;
  equipment_places_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "boarding_position_equipment_places" */
export enum StopsDatabaseBoardingPositionEquipmentPlacesConstraint {
  /** unique or primary key constraint on columns "equipment_places_id" */
  UkGq09mcv5i3kkrwltbnj3120j5 = 'uk_gq09mcv5i3kkrwltbnj3120j5',
}

/** input type for incrementing numeric columns in table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesIncInput = {
  boarding_position_id?: InputMaybe<Scalars['bigint']>;
  equipment_places_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesInsertInput = {
  boarding_position_id?: InputMaybe<Scalars['bigint']>;
  equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceObjRelInsertInput>;
  equipment_places_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseBoardingPositionEquipmentPlacesMaxFields = {
  __typename?: 'stops_database_boarding_position_equipment_places_max_fields';
  boarding_position_id?: Maybe<Scalars['bigint']>;
  equipment_places_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesMaxOrderBy = {
  boarding_position_id?: InputMaybe<OrderBy>;
  equipment_places_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseBoardingPositionEquipmentPlacesMinFields = {
  __typename?: 'stops_database_boarding_position_equipment_places_min_fields';
  boarding_position_id?: Maybe<Scalars['bigint']>;
  equipment_places_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesMinOrderBy = {
  boarding_position_id?: InputMaybe<OrderBy>;
  equipment_places_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesMutationResponse = {
  __typename?: 'stops_database_boarding_position_equipment_places_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseBoardingPositionEquipmentPlaces>;
};

/** on_conflict condition type for table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesOnConflict = {
  constraint: StopsDatabaseBoardingPositionEquipmentPlacesConstraint;
  update_columns?: Array<StopsDatabaseBoardingPositionEquipmentPlacesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>;
};

/** Ordering options when selecting data from "boarding_position_equipment_places". */
export type StopsDatabaseBoardingPositionEquipmentPlacesOrderBy = {
  boarding_position_id?: InputMaybe<OrderBy>;
  equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceOrderBy>;
  equipment_places_id?: InputMaybe<OrderBy>;
};

/** select columns of table "boarding_position_equipment_places" */
export enum StopsDatabaseBoardingPositionEquipmentPlacesSelectColumn {
  /** column name */
  BoardingPositionId = 'boarding_position_id',
  /** column name */
  EquipmentPlacesId = 'equipment_places_id',
}

/** input type for updating data in table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesSetInput = {
  boarding_position_id?: InputMaybe<Scalars['bigint']>;
  equipment_places_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseBoardingPositionEquipmentPlacesStddevFields = {
  __typename?: 'stops_database_boarding_position_equipment_places_stddev_fields';
  boarding_position_id?: Maybe<Scalars['Float']>;
  equipment_places_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesStddevOrderBy = {
  boarding_position_id?: InputMaybe<OrderBy>;
  equipment_places_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseBoardingPositionEquipmentPlacesStddevPopFields = {
  __typename?: 'stops_database_boarding_position_equipment_places_stddev_pop_fields';
  boarding_position_id?: Maybe<Scalars['Float']>;
  equipment_places_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesStddevPopOrderBy = {
  boarding_position_id?: InputMaybe<OrderBy>;
  equipment_places_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseBoardingPositionEquipmentPlacesStddevSampFields = {
  __typename?: 'stops_database_boarding_position_equipment_places_stddev_samp_fields';
  boarding_position_id?: Maybe<Scalars['Float']>;
  equipment_places_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesStddevSampOrderBy = {
  boarding_position_id?: InputMaybe<OrderBy>;
  equipment_places_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseBoardingPositionEquipmentPlacesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseBoardingPositionEquipmentPlacesStreamCursorValueInput =
  {
    boarding_position_id?: InputMaybe<Scalars['bigint']>;
    equipment_places_id?: InputMaybe<Scalars['bigint']>;
  };

/** aggregate sum on columns */
export type StopsDatabaseBoardingPositionEquipmentPlacesSumFields = {
  __typename?: 'stops_database_boarding_position_equipment_places_sum_fields';
  boarding_position_id?: Maybe<Scalars['bigint']>;
  equipment_places_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesSumOrderBy = {
  boarding_position_id?: InputMaybe<OrderBy>;
  equipment_places_id?: InputMaybe<OrderBy>;
};

/** update columns of table "boarding_position_equipment_places" */
export enum StopsDatabaseBoardingPositionEquipmentPlacesUpdateColumn {
  /** column name */
  BoardingPositionId = 'boarding_position_id',
  /** column name */
  EquipmentPlacesId = 'equipment_places_id',
}

export type StopsDatabaseBoardingPositionEquipmentPlacesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseBoardingPositionEquipmentPlacesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseBoardingPositionEquipmentPlacesVarPopFields = {
  __typename?: 'stops_database_boarding_position_equipment_places_var_pop_fields';
  boarding_position_id?: Maybe<Scalars['Float']>;
  equipment_places_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesVarPopOrderBy = {
  boarding_position_id?: InputMaybe<OrderBy>;
  equipment_places_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseBoardingPositionEquipmentPlacesVarSampFields = {
  __typename?: 'stops_database_boarding_position_equipment_places_var_samp_fields';
  boarding_position_id?: Maybe<Scalars['Float']>;
  equipment_places_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesVarSampOrderBy = {
  boarding_position_id?: InputMaybe<OrderBy>;
  equipment_places_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseBoardingPositionEquipmentPlacesVarianceFields = {
  __typename?: 'stops_database_boarding_position_equipment_places_variance_fields';
  boarding_position_id?: Maybe<Scalars['Float']>;
  equipment_places_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesVarianceOrderBy = {
  boarding_position_id?: InputMaybe<OrderBy>;
  equipment_places_id?: InputMaybe<OrderBy>;
};

/** input type for incrementing numeric columns in table "boarding_position" */
export type StopsDatabaseBoardingPositionIncInput = {
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  covered?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['bigint']>;
  place_equipments_id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "boarding_position" */
export type StopsDatabaseBoardingPositionInsertInput = {
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']>;
  boarding_position_alternative_names?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesArrRelInsertInput>;
  boarding_position_equipment_places?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesArrRelInsertInput>;
  boarding_position_key_values?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesArrRelInsertInput>;
  boarding_position_type?: InputMaybe<Scalars['String']>;
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  covered?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureObjRelInsertInput>;
  label_lang?: InputMaybe<Scalars['String']>;
  label_value?: InputMaybe<Scalars['String']>;
  level_ref?: InputMaybe<Scalars['String']>;
  level_ref_version?: InputMaybe<Scalars['String']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonObjRelInsertInput>;
  place_equipments_id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  public_code?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  site_ref?: InputMaybe<Scalars['String']>;
  site_ref_version?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValues = {
  __typename?: 'stops_database_boarding_position_key_values';
  boarding_position_id: Scalars['bigint'];
  key_values_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
  /** An object relationship */
  value: StopsDatabaseValue;
};

/** aggregated selection of "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesAggregate = {
  __typename?: 'stops_database_boarding_position_key_values_aggregate';
  aggregate?: Maybe<StopsDatabaseBoardingPositionKeyValuesAggregateFields>;
  nodes: Array<StopsDatabaseBoardingPositionKeyValues>;
};

/** aggregate fields of "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesAggregateFields = {
  __typename?: 'stops_database_boarding_position_key_values_aggregate_fields';
  avg?: Maybe<StopsDatabaseBoardingPositionKeyValuesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseBoardingPositionKeyValuesMaxFields>;
  min?: Maybe<StopsDatabaseBoardingPositionKeyValuesMinFields>;
  stddev?: Maybe<StopsDatabaseBoardingPositionKeyValuesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseBoardingPositionKeyValuesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseBoardingPositionKeyValuesStddevSampFields>;
  sum?: Maybe<StopsDatabaseBoardingPositionKeyValuesSumFields>;
  var_pop?: Maybe<StopsDatabaseBoardingPositionKeyValuesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseBoardingPositionKeyValuesVarSampFields>;
  variance?: Maybe<StopsDatabaseBoardingPositionKeyValuesVarianceFields>;
};

/** aggregate fields of "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<
    Array<StopsDatabaseBoardingPositionKeyValuesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesArrRelInsertInput = {
  data: Array<StopsDatabaseBoardingPositionKeyValuesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseBoardingPositionKeyValuesAvgFields = {
  __typename?: 'stops_database_boarding_position_key_values_avg_fields';
  boarding_position_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesAvgOrderBy = {
  boarding_position_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "boarding_position_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseBoardingPositionKeyValuesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseBoardingPositionKeyValuesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseBoardingPositionKeyValuesBoolExp>>;
  boarding_position_id?: InputMaybe<BigintComparisonExp>;
  key_values_id?: InputMaybe<BigintComparisonExp>;
  key_values_key?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "boarding_position_key_values" */
export enum StopsDatabaseBoardingPositionKeyValuesConstraint {
  /** unique or primary key constraint on columns "boarding_position_id", "key_values_key" */
  BoardingPositionKeyValuesPkey = 'boarding_position_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkJilhh4jbyloqka3r1xpv88lpb = 'uk_jilhh4jbyloqka3r1xpv88lpb',
}

/** input type for incrementing numeric columns in table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesIncInput = {
  boarding_position_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesInsertInput = {
  boarding_position_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseBoardingPositionKeyValuesMaxFields = {
  __typename?: 'stops_database_boarding_position_key_values_max_fields';
  boarding_position_id?: Maybe<Scalars['bigint']>;
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesMaxOrderBy = {
  boarding_position_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseBoardingPositionKeyValuesMinFields = {
  __typename?: 'stops_database_boarding_position_key_values_min_fields';
  boarding_position_id?: Maybe<Scalars['bigint']>;
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesMinOrderBy = {
  boarding_position_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesMutationResponse = {
  __typename?: 'stops_database_boarding_position_key_values_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseBoardingPositionKeyValues>;
};

/** on_conflict condition type for table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesOnConflict = {
  constraint: StopsDatabaseBoardingPositionKeyValuesConstraint;
  update_columns?: Array<StopsDatabaseBoardingPositionKeyValuesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "boarding_position_key_values". */
export type StopsDatabaseBoardingPositionKeyValuesOrderBy = {
  boarding_position_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: boarding_position_key_values */
export type StopsDatabaseBoardingPositionKeyValuesPkColumnsInput = {
  boarding_position_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
};

/** select columns of table "boarding_position_key_values" */
export enum StopsDatabaseBoardingPositionKeyValuesSelectColumn {
  /** column name */
  BoardingPositionId = 'boarding_position_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
}

/** input type for updating data in table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesSetInput = {
  boarding_position_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseBoardingPositionKeyValuesStddevFields = {
  __typename?: 'stops_database_boarding_position_key_values_stddev_fields';
  boarding_position_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesStddevOrderBy = {
  boarding_position_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseBoardingPositionKeyValuesStddevPopFields = {
  __typename?: 'stops_database_boarding_position_key_values_stddev_pop_fields';
  boarding_position_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesStddevPopOrderBy = {
  boarding_position_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseBoardingPositionKeyValuesStddevSampFields = {
  __typename?: 'stops_database_boarding_position_key_values_stddev_samp_fields';
  boarding_position_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesStddevSampOrderBy = {
  boarding_position_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseBoardingPositionKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseBoardingPositionKeyValuesStreamCursorValueInput = {
  boarding_position_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseBoardingPositionKeyValuesSumFields = {
  __typename?: 'stops_database_boarding_position_key_values_sum_fields';
  boarding_position_id?: Maybe<Scalars['bigint']>;
  key_values_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesSumOrderBy = {
  boarding_position_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** update columns of table "boarding_position_key_values" */
export enum StopsDatabaseBoardingPositionKeyValuesUpdateColumn {
  /** column name */
  BoardingPositionId = 'boarding_position_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
}

export type StopsDatabaseBoardingPositionKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseBoardingPositionKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseBoardingPositionKeyValuesVarPopFields = {
  __typename?: 'stops_database_boarding_position_key_values_var_pop_fields';
  boarding_position_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesVarPopOrderBy = {
  boarding_position_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseBoardingPositionKeyValuesVarSampFields = {
  __typename?: 'stops_database_boarding_position_key_values_var_samp_fields';
  boarding_position_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesVarSampOrderBy = {
  boarding_position_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseBoardingPositionKeyValuesVarianceFields = {
  __typename?: 'stops_database_boarding_position_key_values_variance_fields';
  boarding_position_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesVarianceOrderBy = {
  boarding_position_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseBoardingPositionMaxFields = {
  __typename?: 'stops_database_boarding_position_max_fields';
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  boarding_position_type?: Maybe<Scalars['String']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  covered?: Maybe<Scalars['Int']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  label_lang?: Maybe<Scalars['String']>;
  label_value?: Maybe<Scalars['String']>;
  level_ref?: Maybe<Scalars['String']>;
  level_ref_version?: Maybe<Scalars['String']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  place_equipments_id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  public_code?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  site_ref?: Maybe<Scalars['String']>;
  site_ref_version?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseBoardingPositionMinFields = {
  __typename?: 'stops_database_boarding_position_min_fields';
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  boarding_position_type?: Maybe<Scalars['String']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  covered?: Maybe<Scalars['Int']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  label_lang?: Maybe<Scalars['String']>;
  label_value?: Maybe<Scalars['String']>;
  level_ref?: Maybe<Scalars['String']>;
  level_ref_version?: Maybe<Scalars['String']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  place_equipments_id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  public_code?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  site_ref?: Maybe<Scalars['String']>;
  site_ref_version?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "boarding_position" */
export type StopsDatabaseBoardingPositionMutationResponse = {
  __typename?: 'stops_database_boarding_position_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseBoardingPosition>;
};

/** input type for inserting object relation for remote table "boarding_position" */
export type StopsDatabaseBoardingPositionObjRelInsertInput = {
  data: StopsDatabaseBoardingPositionInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseBoardingPositionOnConflict>;
};

/** on_conflict condition type for table "boarding_position" */
export type StopsDatabaseBoardingPositionOnConflict = {
  constraint: StopsDatabaseBoardingPositionConstraint;
  update_columns?: Array<StopsDatabaseBoardingPositionUpdateColumn>;
  where?: InputMaybe<StopsDatabaseBoardingPositionBoolExp>;
};

/** Ordering options when selecting data from "boarding_position". */
export type StopsDatabaseBoardingPositionOrderBy = {
  accessibility_assessment_id?: InputMaybe<OrderBy>;
  all_areas_wheelchair_accessible?: InputMaybe<OrderBy>;
  boarding_position_alternative_names_aggregate?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesAggregateOrderBy>;
  boarding_position_equipment_places_aggregate?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesAggregateOrderBy>;
  boarding_position_key_values_aggregate?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesAggregateOrderBy>;
  boarding_position_type?: InputMaybe<OrderBy>;
  centroid?: InputMaybe<OrderBy>;
  changed?: InputMaybe<OrderBy>;
  changed_by?: InputMaybe<OrderBy>;
  covered?: InputMaybe<OrderBy>;
  created?: InputMaybe<OrderBy>;
  description_lang?: InputMaybe<OrderBy>;
  description_value?: InputMaybe<OrderBy>;
  from_date?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureOrderBy>;
  label_lang?: InputMaybe<OrderBy>;
  label_value?: InputMaybe<OrderBy>;
  level_ref?: InputMaybe<OrderBy>;
  level_ref_version?: InputMaybe<OrderBy>;
  name_lang?: InputMaybe<OrderBy>;
  name_value?: InputMaybe<OrderBy>;
  netex_id?: InputMaybe<OrderBy>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonOrderBy>;
  place_equipments_id?: InputMaybe<OrderBy>;
  polygon_id?: InputMaybe<OrderBy>;
  private_code_type?: InputMaybe<OrderBy>;
  private_code_value?: InputMaybe<OrderBy>;
  public_code?: InputMaybe<OrderBy>;
  short_name_lang?: InputMaybe<OrderBy>;
  short_name_value?: InputMaybe<OrderBy>;
  site_ref?: InputMaybe<OrderBy>;
  site_ref_version?: InputMaybe<OrderBy>;
  to_date?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
  version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: boarding_position */
export type StopsDatabaseBoardingPositionPkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "boarding_position" */
export enum StopsDatabaseBoardingPositionSelectColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  BoardingPositionType = 'boarding_position_type',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  LabelLang = 'label_lang',
  /** column name */
  LabelValue = 'label_value',
  /** column name */
  LevelRef = 'level_ref',
  /** column name */
  LevelRefVersion = 'level_ref_version',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  PublicCode = 'public_code',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  SiteRef = 'site_ref',
  /** column name */
  SiteRefVersion = 'site_ref_version',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

/** input type for updating data in table "boarding_position" */
export type StopsDatabaseBoardingPositionSetInput = {
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']>;
  boarding_position_type?: InputMaybe<Scalars['String']>;
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  covered?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  label_lang?: InputMaybe<Scalars['String']>;
  label_value?: InputMaybe<Scalars['String']>;
  level_ref?: InputMaybe<Scalars['String']>;
  level_ref_version?: InputMaybe<Scalars['String']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  place_equipments_id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  public_code?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  site_ref?: InputMaybe<Scalars['String']>;
  site_ref_version?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseBoardingPositionStddevFields = {
  __typename?: 'stops_database_boarding_position_stddev_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseBoardingPositionStddevPopFields = {
  __typename?: 'stops_database_boarding_position_stddev_pop_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseBoardingPositionStddevSampFields = {
  __typename?: 'stops_database_boarding_position_stddev_samp_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "boarding_position" */
export type StopsDatabaseBoardingPositionStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseBoardingPositionStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseBoardingPositionStreamCursorValueInput = {
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']>;
  boarding_position_type?: InputMaybe<Scalars['String']>;
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  covered?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  label_lang?: InputMaybe<Scalars['String']>;
  label_value?: InputMaybe<Scalars['String']>;
  level_ref?: InputMaybe<Scalars['String']>;
  level_ref_version?: InputMaybe<Scalars['String']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  place_equipments_id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  public_code?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  site_ref?: InputMaybe<Scalars['String']>;
  site_ref_version?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseBoardingPositionSumFields = {
  __typename?: 'stops_database_boarding_position_sum_fields';
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  covered?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['bigint']>;
  place_equipments_id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['bigint']>;
};

/** update columns of table "boarding_position" */
export enum StopsDatabaseBoardingPositionUpdateColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  BoardingPositionType = 'boarding_position_type',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  LabelLang = 'label_lang',
  /** column name */
  LabelValue = 'label_value',
  /** column name */
  LevelRef = 'level_ref',
  /** column name */
  LevelRefVersion = 'level_ref_version',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  PublicCode = 'public_code',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  SiteRef = 'site_ref',
  /** column name */
  SiteRefVersion = 'site_ref_version',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

export type StopsDatabaseBoardingPositionUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseBoardingPositionIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseBoardingPositionSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseBoardingPositionBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseBoardingPositionVarPopFields = {
  __typename?: 'stops_database_boarding_position_var_pop_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseBoardingPositionVarSampFields = {
  __typename?: 'stops_database_boarding_position_var_samp_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseBoardingPositionVarianceFields = {
  __typename?: 'stops_database_boarding_position_variance_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "check_constraint" */
export type StopsDatabaseCheckConstraint = {
  __typename?: 'stops_database_check_constraint';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_id?: Maybe<Scalars['bigint']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id: Scalars['bigint'];
  name_id?: Maybe<Scalars['bigint']>;
  netex_id?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version: Scalars['bigint'];
  version_comment?: Maybe<Scalars['String']>;
};

/** aggregated selection of "check_constraint" */
export type StopsDatabaseCheckConstraintAggregate = {
  __typename?: 'stops_database_check_constraint_aggregate';
  aggregate?: Maybe<StopsDatabaseCheckConstraintAggregateFields>;
  nodes: Array<StopsDatabaseCheckConstraint>;
};

/** aggregate fields of "check_constraint" */
export type StopsDatabaseCheckConstraintAggregateFields = {
  __typename?: 'stops_database_check_constraint_aggregate_fields';
  avg?: Maybe<StopsDatabaseCheckConstraintAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseCheckConstraintMaxFields>;
  min?: Maybe<StopsDatabaseCheckConstraintMinFields>;
  stddev?: Maybe<StopsDatabaseCheckConstraintStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseCheckConstraintStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseCheckConstraintStddevSampFields>;
  sum?: Maybe<StopsDatabaseCheckConstraintSumFields>;
  var_pop?: Maybe<StopsDatabaseCheckConstraintVarPopFields>;
  var_samp?: Maybe<StopsDatabaseCheckConstraintVarSampFields>;
  variance?: Maybe<StopsDatabaseCheckConstraintVarianceFields>;
};

/** aggregate fields of "check_constraint" */
export type StopsDatabaseCheckConstraintAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseCheckConstraintSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseCheckConstraintAvgFields = {
  __typename?: 'stops_database_check_constraint_avg_fields';
  description_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  name_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "check_constraint". All fields are combined with a logical 'AND'. */
export type StopsDatabaseCheckConstraintBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseCheckConstraintBoolExp>>;
  _not?: InputMaybe<StopsDatabaseCheckConstraintBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseCheckConstraintBoolExp>>;
  changed?: InputMaybe<TimestampComparisonExp>;
  changed_by?: InputMaybe<StringComparisonExp>;
  created?: InputMaybe<TimestampComparisonExp>;
  description_id?: InputMaybe<BigintComparisonExp>;
  from_date?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  name_id?: InputMaybe<BigintComparisonExp>;
  netex_id?: InputMaybe<StringComparisonExp>;
  to_date?: InputMaybe<TimestampComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
  version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "check_constraint" */
export enum StopsDatabaseCheckConstraintConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  CheckConstraintNetexIdVersionConstraint = 'check_constraint_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  CheckConstraintPkey = 'check_constraint_pkey',
}

/** input type for incrementing numeric columns in table "check_constraint" */
export type StopsDatabaseCheckConstraintIncInput = {
  description_id?: InputMaybe<Scalars['bigint']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "check_constraint" */
export type StopsDatabaseCheckConstraintInsertInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_id?: InputMaybe<Scalars['bigint']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_id?: InputMaybe<Scalars['bigint']>;
  netex_id?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "check_constraint_key_values" */
export type StopsDatabaseCheckConstraintKeyValues = {
  __typename?: 'stops_database_check_constraint_key_values';
  check_constraint_id: Scalars['bigint'];
  key_values_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
};

/** aggregated selection of "check_constraint_key_values" */
export type StopsDatabaseCheckConstraintKeyValuesAggregate = {
  __typename?: 'stops_database_check_constraint_key_values_aggregate';
  aggregate?: Maybe<StopsDatabaseCheckConstraintKeyValuesAggregateFields>;
  nodes: Array<StopsDatabaseCheckConstraintKeyValues>;
};

/** aggregate fields of "check_constraint_key_values" */
export type StopsDatabaseCheckConstraintKeyValuesAggregateFields = {
  __typename?: 'stops_database_check_constraint_key_values_aggregate_fields';
  avg?: Maybe<StopsDatabaseCheckConstraintKeyValuesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseCheckConstraintKeyValuesMaxFields>;
  min?: Maybe<StopsDatabaseCheckConstraintKeyValuesMinFields>;
  stddev?: Maybe<StopsDatabaseCheckConstraintKeyValuesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseCheckConstraintKeyValuesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseCheckConstraintKeyValuesStddevSampFields>;
  sum?: Maybe<StopsDatabaseCheckConstraintKeyValuesSumFields>;
  var_pop?: Maybe<StopsDatabaseCheckConstraintKeyValuesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseCheckConstraintKeyValuesVarSampFields>;
  variance?: Maybe<StopsDatabaseCheckConstraintKeyValuesVarianceFields>;
};

/** aggregate fields of "check_constraint_key_values" */
export type StopsDatabaseCheckConstraintKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<
    Array<StopsDatabaseCheckConstraintKeyValuesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseCheckConstraintKeyValuesAvgFields = {
  __typename?: 'stops_database_check_constraint_key_values_avg_fields';
  check_constraint_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "check_constraint_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseCheckConstraintKeyValuesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseCheckConstraintKeyValuesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseCheckConstraintKeyValuesBoolExp>>;
  check_constraint_id?: InputMaybe<BigintComparisonExp>;
  key_values_id?: InputMaybe<BigintComparisonExp>;
  key_values_key?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "check_constraint_key_values" */
export enum StopsDatabaseCheckConstraintKeyValuesConstraint {
  /** unique or primary key constraint on columns "check_constraint_id", "key_values_key" */
  CheckConstraintKeyValuesPkey = 'check_constraint_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkGsegfx5ipotsd45aqbmq7kux0 = 'uk_gsegfx5ipotsd45aqbmq7kux0',
}

/** input type for incrementing numeric columns in table "check_constraint_key_values" */
export type StopsDatabaseCheckConstraintKeyValuesIncInput = {
  check_constraint_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "check_constraint_key_values" */
export type StopsDatabaseCheckConstraintKeyValuesInsertInput = {
  check_constraint_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type StopsDatabaseCheckConstraintKeyValuesMaxFields = {
  __typename?: 'stops_database_check_constraint_key_values_max_fields';
  check_constraint_id?: Maybe<Scalars['bigint']>;
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseCheckConstraintKeyValuesMinFields = {
  __typename?: 'stops_database_check_constraint_key_values_min_fields';
  check_constraint_id?: Maybe<Scalars['bigint']>;
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "check_constraint_key_values" */
export type StopsDatabaseCheckConstraintKeyValuesMutationResponse = {
  __typename?: 'stops_database_check_constraint_key_values_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseCheckConstraintKeyValues>;
};

/** on_conflict condition type for table "check_constraint_key_values" */
export type StopsDatabaseCheckConstraintKeyValuesOnConflict = {
  constraint: StopsDatabaseCheckConstraintKeyValuesConstraint;
  update_columns?: Array<StopsDatabaseCheckConstraintKeyValuesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "check_constraint_key_values". */
export type StopsDatabaseCheckConstraintKeyValuesOrderBy = {
  check_constraint_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: check_constraint_key_values */
export type StopsDatabaseCheckConstraintKeyValuesPkColumnsInput = {
  check_constraint_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
};

/** select columns of table "check_constraint_key_values" */
export enum StopsDatabaseCheckConstraintKeyValuesSelectColumn {
  /** column name */
  CheckConstraintId = 'check_constraint_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
}

/** input type for updating data in table "check_constraint_key_values" */
export type StopsDatabaseCheckConstraintKeyValuesSetInput = {
  check_constraint_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseCheckConstraintKeyValuesStddevFields = {
  __typename?: 'stops_database_check_constraint_key_values_stddev_fields';
  check_constraint_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseCheckConstraintKeyValuesStddevPopFields = {
  __typename?: 'stops_database_check_constraint_key_values_stddev_pop_fields';
  check_constraint_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseCheckConstraintKeyValuesStddevSampFields = {
  __typename?: 'stops_database_check_constraint_key_values_stddev_samp_fields';
  check_constraint_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "check_constraint_key_values" */
export type StopsDatabaseCheckConstraintKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseCheckConstraintKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseCheckConstraintKeyValuesStreamCursorValueInput = {
  check_constraint_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseCheckConstraintKeyValuesSumFields = {
  __typename?: 'stops_database_check_constraint_key_values_sum_fields';
  check_constraint_id?: Maybe<Scalars['bigint']>;
  key_values_id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "check_constraint_key_values" */
export enum StopsDatabaseCheckConstraintKeyValuesUpdateColumn {
  /** column name */
  CheckConstraintId = 'check_constraint_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
}

export type StopsDatabaseCheckConstraintKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseCheckConstraintKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseCheckConstraintKeyValuesVarPopFields = {
  __typename?: 'stops_database_check_constraint_key_values_var_pop_fields';
  check_constraint_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseCheckConstraintKeyValuesVarSampFields = {
  __typename?: 'stops_database_check_constraint_key_values_var_samp_fields';
  check_constraint_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseCheckConstraintKeyValuesVarianceFields = {
  __typename?: 'stops_database_check_constraint_key_values_variance_fields';
  check_constraint_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** aggregate max on columns */
export type StopsDatabaseCheckConstraintMaxFields = {
  __typename?: 'stops_database_check_constraint_max_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_id?: Maybe<Scalars['bigint']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  name_id?: Maybe<Scalars['bigint']>;
  netex_id?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseCheckConstraintMinFields = {
  __typename?: 'stops_database_check_constraint_min_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_id?: Maybe<Scalars['bigint']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  name_id?: Maybe<Scalars['bigint']>;
  netex_id?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "check_constraint" */
export type StopsDatabaseCheckConstraintMutationResponse = {
  __typename?: 'stops_database_check_constraint_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseCheckConstraint>;
};

/** on_conflict condition type for table "check_constraint" */
export type StopsDatabaseCheckConstraintOnConflict = {
  constraint: StopsDatabaseCheckConstraintConstraint;
  update_columns?: Array<StopsDatabaseCheckConstraintUpdateColumn>;
  where?: InputMaybe<StopsDatabaseCheckConstraintBoolExp>;
};

/** Ordering options when selecting data from "check_constraint". */
export type StopsDatabaseCheckConstraintOrderBy = {
  changed?: InputMaybe<OrderBy>;
  changed_by?: InputMaybe<OrderBy>;
  created?: InputMaybe<OrderBy>;
  description_id?: InputMaybe<OrderBy>;
  from_date?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name_id?: InputMaybe<OrderBy>;
  netex_id?: InputMaybe<OrderBy>;
  to_date?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
  version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: check_constraint */
export type StopsDatabaseCheckConstraintPkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "check_constraint" */
export enum StopsDatabaseCheckConstraintSelectColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionId = 'description_id',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameId = 'name_id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

/** input type for updating data in table "check_constraint" */
export type StopsDatabaseCheckConstraintSetInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_id?: InputMaybe<Scalars['bigint']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_id?: InputMaybe<Scalars['bigint']>;
  netex_id?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseCheckConstraintStddevFields = {
  __typename?: 'stops_database_check_constraint_stddev_fields';
  description_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  name_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseCheckConstraintStddevPopFields = {
  __typename?: 'stops_database_check_constraint_stddev_pop_fields';
  description_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  name_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseCheckConstraintStddevSampFields = {
  __typename?: 'stops_database_check_constraint_stddev_samp_fields';
  description_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  name_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "check_constraint" */
export type StopsDatabaseCheckConstraintStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseCheckConstraintStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseCheckConstraintStreamCursorValueInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_id?: InputMaybe<Scalars['bigint']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_id?: InputMaybe<Scalars['bigint']>;
  netex_id?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseCheckConstraintSumFields = {
  __typename?: 'stops_database_check_constraint_sum_fields';
  description_id?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['bigint']>;
  name_id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['bigint']>;
};

/** update columns of table "check_constraint" */
export enum StopsDatabaseCheckConstraintUpdateColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionId = 'description_id',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameId = 'name_id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

export type StopsDatabaseCheckConstraintUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseCheckConstraintIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseCheckConstraintSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseCheckConstraintBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseCheckConstraintVarPopFields = {
  __typename?: 'stops_database_check_constraint_var_pop_fields';
  description_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  name_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseCheckConstraintVarSampFields = {
  __typename?: 'stops_database_check_constraint_var_samp_fields';
  description_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  name_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseCheckConstraintVarianceFields = {
  __typename?: 'stops_database_check_constraint_variance_fields';
  description_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  name_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** ordering argument of a cursor */
export enum StopsDatabaseCursorOrdering {
  /** ascending ordering of the cursor */
  Asc = 'ASC',
  /** descending ordering of the cursor */
  Desc = 'DESC',
}

/** columns and relationships of "destination_display_view" */
export type StopsDatabaseDestinationDisplayView = {
  __typename?: 'stops_database_destination_display_view';
  branding_ref?: Maybe<Scalars['bytea']>;
  id: Scalars['bigint'];
  name_id?: Maybe<Scalars['bigint']>;
  public_code?: Maybe<Scalars['String']>;
  short_code?: Maybe<Scalars['String']>;
};

/** aggregated selection of "destination_display_view" */
export type StopsDatabaseDestinationDisplayViewAggregate = {
  __typename?: 'stops_database_destination_display_view_aggregate';
  aggregate?: Maybe<StopsDatabaseDestinationDisplayViewAggregateFields>;
  nodes: Array<StopsDatabaseDestinationDisplayView>;
};

/** aggregate fields of "destination_display_view" */
export type StopsDatabaseDestinationDisplayViewAggregateFields = {
  __typename?: 'stops_database_destination_display_view_aggregate_fields';
  avg?: Maybe<StopsDatabaseDestinationDisplayViewAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseDestinationDisplayViewMaxFields>;
  min?: Maybe<StopsDatabaseDestinationDisplayViewMinFields>;
  stddev?: Maybe<StopsDatabaseDestinationDisplayViewStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseDestinationDisplayViewStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseDestinationDisplayViewStddevSampFields>;
  sum?: Maybe<StopsDatabaseDestinationDisplayViewSumFields>;
  var_pop?: Maybe<StopsDatabaseDestinationDisplayViewVarPopFields>;
  var_samp?: Maybe<StopsDatabaseDestinationDisplayViewVarSampFields>;
  variance?: Maybe<StopsDatabaseDestinationDisplayViewVarianceFields>;
};

/** aggregate fields of "destination_display_view" */
export type StopsDatabaseDestinationDisplayViewAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseDestinationDisplayViewSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseDestinationDisplayViewAvgFields = {
  __typename?: 'stops_database_destination_display_view_avg_fields';
  id?: Maybe<Scalars['Float']>;
  name_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "destination_display_view". All fields are combined with a logical 'AND'. */
export type StopsDatabaseDestinationDisplayViewBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseDestinationDisplayViewBoolExp>>;
  _not?: InputMaybe<StopsDatabaseDestinationDisplayViewBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseDestinationDisplayViewBoolExp>>;
  branding_ref?: InputMaybe<ByteaComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  name_id?: InputMaybe<BigintComparisonExp>;
  public_code?: InputMaybe<StringComparisonExp>;
  short_code?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "destination_display_view" */
export enum StopsDatabaseDestinationDisplayViewConstraint {
  /** unique or primary key constraint on columns "id" */
  DestinationDisplayViewPkey = 'destination_display_view_pkey',
}

/** input type for incrementing numeric columns in table "destination_display_view" */
export type StopsDatabaseDestinationDisplayViewIncInput = {
  id?: InputMaybe<Scalars['bigint']>;
  name_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "destination_display_view" */
export type StopsDatabaseDestinationDisplayViewInsertInput = {
  branding_ref?: InputMaybe<Scalars['bytea']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_id?: InputMaybe<Scalars['bigint']>;
  public_code?: InputMaybe<Scalars['String']>;
  short_code?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type StopsDatabaseDestinationDisplayViewMaxFields = {
  __typename?: 'stops_database_destination_display_view_max_fields';
  id?: Maybe<Scalars['bigint']>;
  name_id?: Maybe<Scalars['bigint']>;
  public_code?: Maybe<Scalars['String']>;
  short_code?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseDestinationDisplayViewMinFields = {
  __typename?: 'stops_database_destination_display_view_min_fields';
  id?: Maybe<Scalars['bigint']>;
  name_id?: Maybe<Scalars['bigint']>;
  public_code?: Maybe<Scalars['String']>;
  short_code?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "destination_display_view" */
export type StopsDatabaseDestinationDisplayViewMutationResponse = {
  __typename?: 'stops_database_destination_display_view_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseDestinationDisplayView>;
};

/** on_conflict condition type for table "destination_display_view" */
export type StopsDatabaseDestinationDisplayViewOnConflict = {
  constraint: StopsDatabaseDestinationDisplayViewConstraint;
  update_columns?: Array<StopsDatabaseDestinationDisplayViewUpdateColumn>;
  where?: InputMaybe<StopsDatabaseDestinationDisplayViewBoolExp>;
};

/** Ordering options when selecting data from "destination_display_view". */
export type StopsDatabaseDestinationDisplayViewOrderBy = {
  branding_ref?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name_id?: InputMaybe<OrderBy>;
  public_code?: InputMaybe<OrderBy>;
  short_code?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: destination_display_view */
export type StopsDatabaseDestinationDisplayViewPkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "destination_display_view" */
export enum StopsDatabaseDestinationDisplayViewSelectColumn {
  /** column name */
  BrandingRef = 'branding_ref',
  /** column name */
  Id = 'id',
  /** column name */
  NameId = 'name_id',
  /** column name */
  PublicCode = 'public_code',
  /** column name */
  ShortCode = 'short_code',
}

/** input type for updating data in table "destination_display_view" */
export type StopsDatabaseDestinationDisplayViewSetInput = {
  branding_ref?: InputMaybe<Scalars['bytea']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_id?: InputMaybe<Scalars['bigint']>;
  public_code?: InputMaybe<Scalars['String']>;
  short_code?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseDestinationDisplayViewStddevFields = {
  __typename?: 'stops_database_destination_display_view_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  name_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseDestinationDisplayViewStddevPopFields = {
  __typename?: 'stops_database_destination_display_view_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  name_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseDestinationDisplayViewStddevSampFields = {
  __typename?: 'stops_database_destination_display_view_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  name_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "destination_display_view" */
export type StopsDatabaseDestinationDisplayViewStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseDestinationDisplayViewStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseDestinationDisplayViewStreamCursorValueInput = {
  branding_ref?: InputMaybe<Scalars['bytea']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_id?: InputMaybe<Scalars['bigint']>;
  public_code?: InputMaybe<Scalars['String']>;
  short_code?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseDestinationDisplayViewSumFields = {
  __typename?: 'stops_database_destination_display_view_sum_fields';
  id?: Maybe<Scalars['bigint']>;
  name_id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "destination_display_view" */
export enum StopsDatabaseDestinationDisplayViewUpdateColumn {
  /** column name */
  BrandingRef = 'branding_ref',
  /** column name */
  Id = 'id',
  /** column name */
  NameId = 'name_id',
  /** column name */
  PublicCode = 'public_code',
  /** column name */
  ShortCode = 'short_code',
}

export type StopsDatabaseDestinationDisplayViewUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseDestinationDisplayViewIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseDestinationDisplayViewSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseDestinationDisplayViewBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseDestinationDisplayViewVarPopFields = {
  __typename?: 'stops_database_destination_display_view_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  name_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseDestinationDisplayViewVarSampFields = {
  __typename?: 'stops_database_destination_display_view_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  name_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseDestinationDisplayViewVarianceFields = {
  __typename?: 'stops_database_destination_display_view_variance_fields';
  id?: Maybe<Scalars['Float']>;
  name_id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "equipment_place" */
export type StopsDatabaseEquipmentPlace = {
  __typename?: 'stops_database_equipment_place';
  centroid?: Maybe<Scalars['geometry']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  /** An array relationship */
  equipment_place_equipment_positions: Array<StopsDatabaseEquipmentPlaceEquipmentPositions>;
  /** An aggregate relationship */
  equipment_place_equipment_positions_aggregate: StopsDatabaseEquipmentPlaceEquipmentPositionsAggregate;
  /** An array relationship */
  equipment_place_key_values: Array<StopsDatabaseEquipmentPlaceKeyValues>;
  /** An aggregate relationship */
  equipment_place_key_values_aggregate: StopsDatabaseEquipmentPlaceKeyValuesAggregate;
  from_date?: Maybe<Scalars['timestamp']>;
  id: Scalars['bigint'];
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  /** An object relationship */
  persistable_polygon?: Maybe<StopsDatabasePersistablePolygon>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version: Scalars['bigint'];
  version_comment?: Maybe<Scalars['String']>;
};

/** columns and relationships of "equipment_place" */
export type StopsDatabaseEquipmentPlaceEquipmentPlaceEquipmentPositionsArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseEquipmentPlaceEquipmentPositionsSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<
    Array<StopsDatabaseEquipmentPlaceEquipmentPositionsOrderBy>
  >;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>;
};

/** columns and relationships of "equipment_place" */
export type StopsDatabaseEquipmentPlaceEquipmentPlaceEquipmentPositionsAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseEquipmentPlaceEquipmentPositionsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseEquipmentPlaceEquipmentPositionsOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>;
  };

/** columns and relationships of "equipment_place" */
export type StopsDatabaseEquipmentPlaceEquipmentPlaceKeyValuesArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseEquipmentPlaceKeyValuesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseEquipmentPlaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>;
};

/** columns and relationships of "equipment_place" */
export type StopsDatabaseEquipmentPlaceEquipmentPlaceKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseEquipmentPlaceKeyValuesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseEquipmentPlaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>;
};

/** aggregated selection of "equipment_place" */
export type StopsDatabaseEquipmentPlaceAggregate = {
  __typename?: 'stops_database_equipment_place_aggregate';
  aggregate?: Maybe<StopsDatabaseEquipmentPlaceAggregateFields>;
  nodes: Array<StopsDatabaseEquipmentPlace>;
};

/** aggregate fields of "equipment_place" */
export type StopsDatabaseEquipmentPlaceAggregateFields = {
  __typename?: 'stops_database_equipment_place_aggregate_fields';
  avg?: Maybe<StopsDatabaseEquipmentPlaceAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseEquipmentPlaceMaxFields>;
  min?: Maybe<StopsDatabaseEquipmentPlaceMinFields>;
  stddev?: Maybe<StopsDatabaseEquipmentPlaceStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseEquipmentPlaceStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseEquipmentPlaceStddevSampFields>;
  sum?: Maybe<StopsDatabaseEquipmentPlaceSumFields>;
  var_pop?: Maybe<StopsDatabaseEquipmentPlaceVarPopFields>;
  var_samp?: Maybe<StopsDatabaseEquipmentPlaceVarSampFields>;
  variance?: Maybe<StopsDatabaseEquipmentPlaceVarianceFields>;
};

/** aggregate fields of "equipment_place" */
export type StopsDatabaseEquipmentPlaceAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseEquipmentPlaceSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseEquipmentPlaceAvgFields = {
  __typename?: 'stops_database_equipment_place_avg_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "equipment_place". All fields are combined with a logical 'AND'. */
export type StopsDatabaseEquipmentPlaceBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseEquipmentPlaceBoolExp>>;
  _not?: InputMaybe<StopsDatabaseEquipmentPlaceBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseEquipmentPlaceBoolExp>>;
  centroid?: InputMaybe<GeometryComparisonExp>;
  changed?: InputMaybe<TimestampComparisonExp>;
  changed_by?: InputMaybe<StringComparisonExp>;
  created?: InputMaybe<TimestampComparisonExp>;
  description_lang?: InputMaybe<StringComparisonExp>;
  description_value?: InputMaybe<StringComparisonExp>;
  equipment_place_equipment_positions?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>;
  equipment_place_equipment_positions_aggregate?: InputMaybe<EquipmentPlaceEquipmentPositionsAggregateBoolExp>;
  equipment_place_key_values?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>;
  equipment_place_key_values_aggregate?: InputMaybe<EquipmentPlaceKeyValuesAggregateBoolExp>;
  from_date?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  name_lang?: InputMaybe<StringComparisonExp>;
  name_value?: InputMaybe<StringComparisonExp>;
  netex_id?: InputMaybe<StringComparisonExp>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  polygon_id?: InputMaybe<BigintComparisonExp>;
  private_code_type?: InputMaybe<StringComparisonExp>;
  private_code_value?: InputMaybe<StringComparisonExp>;
  short_name_lang?: InputMaybe<StringComparisonExp>;
  short_name_value?: InputMaybe<StringComparisonExp>;
  to_date?: InputMaybe<TimestampComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
  version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "equipment_place" */
export enum StopsDatabaseEquipmentPlaceConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  EquipmentPlaceNetexIdVersionConstraint = 'equipment_place_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  EquipmentPlacePkey = 'equipment_place_pkey',
}

/** columns and relationships of "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositions = {
  __typename?: 'stops_database_equipment_place_equipment_positions';
  equipment_place_id: Scalars['bigint'];
  /** An object relationship */
  equipment_position: StopsDatabaseEquipmentPosition;
  equipment_positions_id: Scalars['bigint'];
};

/** aggregated selection of "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsAggregate = {
  __typename?: 'stops_database_equipment_place_equipment_positions_aggregate';
  aggregate?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsAggregateFields>;
  nodes: Array<StopsDatabaseEquipmentPlaceEquipmentPositions>;
};

/** aggregate fields of "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsAggregateFields = {
  __typename?: 'stops_database_equipment_place_equipment_positions_aggregate_fields';
  avg?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsMaxFields>;
  min?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsMinFields>;
  stddev?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsStddevSampFields>;
  sum?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsSumFields>;
  var_pop?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsVarPopFields>;
  var_samp?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsVarSampFields>;
  variance?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsVarianceFields>;
};

/** aggregate fields of "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsAggregateFieldsCountArgs =
  {
    columns?: InputMaybe<
      Array<StopsDatabaseEquipmentPlaceEquipmentPositionsSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
  };

/** order by aggregate values of table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsArrRelInsertInput = {
  data: Array<StopsDatabaseEquipmentPlaceEquipmentPositionsInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsAvgFields = {
  __typename?: 'stops_database_equipment_place_equipment_positions_avg_fields';
  equipment_place_id?: Maybe<Scalars['Float']>;
  equipment_positions_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsAvgOrderBy = {
  equipment_place_id?: InputMaybe<OrderBy>;
  equipment_positions_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "equipment_place_equipment_positions". All fields are combined with a logical 'AND'. */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp = {
  _and?: InputMaybe<
    Array<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>
  >;
  _not?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>>;
  equipment_place_id?: InputMaybe<BigintComparisonExp>;
  equipment_position?: InputMaybe<StopsDatabaseEquipmentPositionBoolExp>;
  equipment_positions_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "equipment_place_equipment_positions" */
export enum StopsDatabaseEquipmentPlaceEquipmentPositionsConstraint {
  /** unique or primary key constraint on columns "equipment_positions_id" */
  UkA3yu015il8xu4ty68idmk8csl = 'uk_a3yu015il8xu4ty68idmk8csl',
}

/** input type for incrementing numeric columns in table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsIncInput = {
  equipment_place_id?: InputMaybe<Scalars['bigint']>;
  equipment_positions_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsInsertInput = {
  equipment_place_id?: InputMaybe<Scalars['bigint']>;
  equipment_position?: InputMaybe<StopsDatabaseEquipmentPositionObjRelInsertInput>;
  equipment_positions_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsMaxFields = {
  __typename?: 'stops_database_equipment_place_equipment_positions_max_fields';
  equipment_place_id?: Maybe<Scalars['bigint']>;
  equipment_positions_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsMaxOrderBy = {
  equipment_place_id?: InputMaybe<OrderBy>;
  equipment_positions_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsMinFields = {
  __typename?: 'stops_database_equipment_place_equipment_positions_min_fields';
  equipment_place_id?: Maybe<Scalars['bigint']>;
  equipment_positions_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsMinOrderBy = {
  equipment_place_id?: InputMaybe<OrderBy>;
  equipment_positions_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsMutationResponse = {
  __typename?: 'stops_database_equipment_place_equipment_positions_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseEquipmentPlaceEquipmentPositions>;
};

/** on_conflict condition type for table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsOnConflict = {
  constraint: StopsDatabaseEquipmentPlaceEquipmentPositionsConstraint;
  update_columns?: Array<StopsDatabaseEquipmentPlaceEquipmentPositionsUpdateColumn>;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>;
};

/** Ordering options when selecting data from "equipment_place_equipment_positions". */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsOrderBy = {
  equipment_place_id?: InputMaybe<OrderBy>;
  equipment_position?: InputMaybe<StopsDatabaseEquipmentPositionOrderBy>;
  equipment_positions_id?: InputMaybe<OrderBy>;
};

/** select columns of table "equipment_place_equipment_positions" */
export enum StopsDatabaseEquipmentPlaceEquipmentPositionsSelectColumn {
  /** column name */
  EquipmentPlaceId = 'equipment_place_id',
  /** column name */
  EquipmentPositionsId = 'equipment_positions_id',
}

/** input type for updating data in table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsSetInput = {
  equipment_place_id?: InputMaybe<Scalars['bigint']>;
  equipment_positions_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsStddevFields = {
  __typename?: 'stops_database_equipment_place_equipment_positions_stddev_fields';
  equipment_place_id?: Maybe<Scalars['Float']>;
  equipment_positions_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsStddevOrderBy = {
  equipment_place_id?: InputMaybe<OrderBy>;
  equipment_positions_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsStddevPopFields = {
  __typename?: 'stops_database_equipment_place_equipment_positions_stddev_pop_fields';
  equipment_place_id?: Maybe<Scalars['Float']>;
  equipment_positions_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsStddevPopOrderBy = {
  equipment_place_id?: InputMaybe<OrderBy>;
  equipment_positions_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsStddevSampFields = {
  __typename?: 'stops_database_equipment_place_equipment_positions_stddev_samp_fields';
  equipment_place_id?: Maybe<Scalars['Float']>;
  equipment_positions_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsStddevSampOrderBy = {
  equipment_place_id?: InputMaybe<OrderBy>;
  equipment_positions_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseEquipmentPlaceEquipmentPositionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsStreamCursorValueInput =
  {
    equipment_place_id?: InputMaybe<Scalars['bigint']>;
    equipment_positions_id?: InputMaybe<Scalars['bigint']>;
  };

/** aggregate sum on columns */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsSumFields = {
  __typename?: 'stops_database_equipment_place_equipment_positions_sum_fields';
  equipment_place_id?: Maybe<Scalars['bigint']>;
  equipment_positions_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsSumOrderBy = {
  equipment_place_id?: InputMaybe<OrderBy>;
  equipment_positions_id?: InputMaybe<OrderBy>;
};

/** update columns of table "equipment_place_equipment_positions" */
export enum StopsDatabaseEquipmentPlaceEquipmentPositionsUpdateColumn {
  /** column name */
  EquipmentPlaceId = 'equipment_place_id',
  /** column name */
  EquipmentPositionsId = 'equipment_positions_id',
}

export type StopsDatabaseEquipmentPlaceEquipmentPositionsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsVarPopFields = {
  __typename?: 'stops_database_equipment_place_equipment_positions_var_pop_fields';
  equipment_place_id?: Maybe<Scalars['Float']>;
  equipment_positions_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsVarPopOrderBy = {
  equipment_place_id?: InputMaybe<OrderBy>;
  equipment_positions_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsVarSampFields = {
  __typename?: 'stops_database_equipment_place_equipment_positions_var_samp_fields';
  equipment_place_id?: Maybe<Scalars['Float']>;
  equipment_positions_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsVarSampOrderBy = {
  equipment_place_id?: InputMaybe<OrderBy>;
  equipment_positions_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsVarianceFields = {
  __typename?: 'stops_database_equipment_place_equipment_positions_variance_fields';
  equipment_place_id?: Maybe<Scalars['Float']>;
  equipment_positions_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsVarianceOrderBy = {
  equipment_place_id?: InputMaybe<OrderBy>;
  equipment_positions_id?: InputMaybe<OrderBy>;
};

/** input type for incrementing numeric columns in table "equipment_place" */
export type StopsDatabaseEquipmentPlaceIncInput = {
  id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "equipment_place" */
export type StopsDatabaseEquipmentPlaceInsertInput = {
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  equipment_place_equipment_positions?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsArrRelInsertInput>;
  equipment_place_key_values?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesArrRelInsertInput>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonObjRelInsertInput>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValues = {
  __typename?: 'stops_database_equipment_place_key_values';
  equipment_place_id: Scalars['bigint'];
  key_values_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
  /** An object relationship */
  value: StopsDatabaseValue;
};

/** aggregated selection of "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesAggregate = {
  __typename?: 'stops_database_equipment_place_key_values_aggregate';
  aggregate?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesAggregateFields>;
  nodes: Array<StopsDatabaseEquipmentPlaceKeyValues>;
};

/** aggregate fields of "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesAggregateFields = {
  __typename?: 'stops_database_equipment_place_key_values_aggregate_fields';
  avg?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesMaxFields>;
  min?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesMinFields>;
  stddev?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesStddevSampFields>;
  sum?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesSumFields>;
  var_pop?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesVarSampFields>;
  variance?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesVarianceFields>;
};

/** aggregate fields of "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseEquipmentPlaceKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesArrRelInsertInput = {
  data: Array<StopsDatabaseEquipmentPlaceKeyValuesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseEquipmentPlaceKeyValuesAvgFields = {
  __typename?: 'stops_database_equipment_place_key_values_avg_fields';
  equipment_place_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesAvgOrderBy = {
  equipment_place_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "equipment_place_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseEquipmentPlaceKeyValuesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>>;
  equipment_place_id?: InputMaybe<BigintComparisonExp>;
  key_values_id?: InputMaybe<BigintComparisonExp>;
  key_values_key?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "equipment_place_key_values" */
export enum StopsDatabaseEquipmentPlaceKeyValuesConstraint {
  /** unique or primary key constraint on columns "key_values_key", "equipment_place_id" */
  EquipmentPlaceKeyValuesPkey = 'equipment_place_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkFyyde9f6a3dq1436v1wykpur2 = 'uk_fyyde9f6a3dq1436v1wykpur2',
}

/** input type for incrementing numeric columns in table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesIncInput = {
  equipment_place_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesInsertInput = {
  equipment_place_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseEquipmentPlaceKeyValuesMaxFields = {
  __typename?: 'stops_database_equipment_place_key_values_max_fields';
  equipment_place_id?: Maybe<Scalars['bigint']>;
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesMaxOrderBy = {
  equipment_place_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseEquipmentPlaceKeyValuesMinFields = {
  __typename?: 'stops_database_equipment_place_key_values_min_fields';
  equipment_place_id?: Maybe<Scalars['bigint']>;
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesMinOrderBy = {
  equipment_place_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesMutationResponse = {
  __typename?: 'stops_database_equipment_place_key_values_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseEquipmentPlaceKeyValues>;
};

/** on_conflict condition type for table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesOnConflict = {
  constraint: StopsDatabaseEquipmentPlaceKeyValuesConstraint;
  update_columns?: Array<StopsDatabaseEquipmentPlaceKeyValuesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "equipment_place_key_values". */
export type StopsDatabaseEquipmentPlaceKeyValuesOrderBy = {
  equipment_place_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: equipment_place_key_values */
export type StopsDatabaseEquipmentPlaceKeyValuesPkColumnsInput = {
  equipment_place_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
};

/** select columns of table "equipment_place_key_values" */
export enum StopsDatabaseEquipmentPlaceKeyValuesSelectColumn {
  /** column name */
  EquipmentPlaceId = 'equipment_place_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
}

/** input type for updating data in table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesSetInput = {
  equipment_place_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseEquipmentPlaceKeyValuesStddevFields = {
  __typename?: 'stops_database_equipment_place_key_values_stddev_fields';
  equipment_place_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesStddevOrderBy = {
  equipment_place_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseEquipmentPlaceKeyValuesStddevPopFields = {
  __typename?: 'stops_database_equipment_place_key_values_stddev_pop_fields';
  equipment_place_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesStddevPopOrderBy = {
  equipment_place_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseEquipmentPlaceKeyValuesStddevSampFields = {
  __typename?: 'stops_database_equipment_place_key_values_stddev_samp_fields';
  equipment_place_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesStddevSampOrderBy = {
  equipment_place_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseEquipmentPlaceKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseEquipmentPlaceKeyValuesStreamCursorValueInput = {
  equipment_place_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseEquipmentPlaceKeyValuesSumFields = {
  __typename?: 'stops_database_equipment_place_key_values_sum_fields';
  equipment_place_id?: Maybe<Scalars['bigint']>;
  key_values_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesSumOrderBy = {
  equipment_place_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** update columns of table "equipment_place_key_values" */
export enum StopsDatabaseEquipmentPlaceKeyValuesUpdateColumn {
  /** column name */
  EquipmentPlaceId = 'equipment_place_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
}

export type StopsDatabaseEquipmentPlaceKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseEquipmentPlaceKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseEquipmentPlaceKeyValuesVarPopFields = {
  __typename?: 'stops_database_equipment_place_key_values_var_pop_fields';
  equipment_place_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesVarPopOrderBy = {
  equipment_place_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseEquipmentPlaceKeyValuesVarSampFields = {
  __typename?: 'stops_database_equipment_place_key_values_var_samp_fields';
  equipment_place_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesVarSampOrderBy = {
  equipment_place_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseEquipmentPlaceKeyValuesVarianceFields = {
  __typename?: 'stops_database_equipment_place_key_values_variance_fields';
  equipment_place_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesVarianceOrderBy = {
  equipment_place_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseEquipmentPlaceMaxFields = {
  __typename?: 'stops_database_equipment_place_max_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseEquipmentPlaceMinFields = {
  __typename?: 'stops_database_equipment_place_min_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "equipment_place" */
export type StopsDatabaseEquipmentPlaceMutationResponse = {
  __typename?: 'stops_database_equipment_place_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseEquipmentPlace>;
};

/** input type for inserting object relation for remote table "equipment_place" */
export type StopsDatabaseEquipmentPlaceObjRelInsertInput = {
  data: StopsDatabaseEquipmentPlaceInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseEquipmentPlaceOnConflict>;
};

/** on_conflict condition type for table "equipment_place" */
export type StopsDatabaseEquipmentPlaceOnConflict = {
  constraint: StopsDatabaseEquipmentPlaceConstraint;
  update_columns?: Array<StopsDatabaseEquipmentPlaceUpdateColumn>;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceBoolExp>;
};

/** Ordering options when selecting data from "equipment_place". */
export type StopsDatabaseEquipmentPlaceOrderBy = {
  centroid?: InputMaybe<OrderBy>;
  changed?: InputMaybe<OrderBy>;
  changed_by?: InputMaybe<OrderBy>;
  created?: InputMaybe<OrderBy>;
  description_lang?: InputMaybe<OrderBy>;
  description_value?: InputMaybe<OrderBy>;
  equipment_place_equipment_positions_aggregate?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsAggregateOrderBy>;
  equipment_place_key_values_aggregate?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesAggregateOrderBy>;
  from_date?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name_lang?: InputMaybe<OrderBy>;
  name_value?: InputMaybe<OrderBy>;
  netex_id?: InputMaybe<OrderBy>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonOrderBy>;
  polygon_id?: InputMaybe<OrderBy>;
  private_code_type?: InputMaybe<OrderBy>;
  private_code_value?: InputMaybe<OrderBy>;
  short_name_lang?: InputMaybe<OrderBy>;
  short_name_value?: InputMaybe<OrderBy>;
  to_date?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
  version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: equipment_place */
export type StopsDatabaseEquipmentPlacePkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "equipment_place" */
export enum StopsDatabaseEquipmentPlaceSelectColumn {
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

/** input type for updating data in table "equipment_place" */
export type StopsDatabaseEquipmentPlaceSetInput = {
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseEquipmentPlaceStddevFields = {
  __typename?: 'stops_database_equipment_place_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseEquipmentPlaceStddevPopFields = {
  __typename?: 'stops_database_equipment_place_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseEquipmentPlaceStddevSampFields = {
  __typename?: 'stops_database_equipment_place_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "equipment_place" */
export type StopsDatabaseEquipmentPlaceStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseEquipmentPlaceStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseEquipmentPlaceStreamCursorValueInput = {
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseEquipmentPlaceSumFields = {
  __typename?: 'stops_database_equipment_place_sum_fields';
  id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['bigint']>;
};

/** update columns of table "equipment_place" */
export enum StopsDatabaseEquipmentPlaceUpdateColumn {
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

export type StopsDatabaseEquipmentPlaceUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseEquipmentPlaceIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseEquipmentPlaceSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseEquipmentPlaceBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseEquipmentPlaceVarPopFields = {
  __typename?: 'stops_database_equipment_place_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseEquipmentPlaceVarSampFields = {
  __typename?: 'stops_database_equipment_place_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseEquipmentPlaceVarianceFields = {
  __typename?: 'stops_database_equipment_place_variance_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "equipment_position" */
export type StopsDatabaseEquipmentPosition = {
  __typename?: 'stops_database_equipment_position';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_id?: Maybe<Scalars['bigint']>;
  /** An array relationship */
  equipment_position_key_values: Array<StopsDatabaseEquipmentPositionKeyValues>;
  /** An aggregate relationship */
  equipment_position_key_values_aggregate: StopsDatabaseEquipmentPositionKeyValuesAggregate;
  from_date?: Maybe<Scalars['timestamp']>;
  id: Scalars['bigint'];
  /** An object relationship */
  multilingual_string_entity?: Maybe<StopsDatabaseMultilingualStringEntity>;
  netex_id?: Maybe<Scalars['String']>;
  reference_point_ref?: Maybe<Scalars['String']>;
  reference_point_version?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version: Scalars['bigint'];
  version_comment?: Maybe<Scalars['String']>;
  x_offset?: Maybe<Scalars['numeric']>;
  y_offset?: Maybe<Scalars['numeric']>;
};

/** columns and relationships of "equipment_position" */
export type StopsDatabaseEquipmentPositionEquipmentPositionKeyValuesArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseEquipmentPositionKeyValuesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseEquipmentPositionKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesBoolExp>;
};

/** columns and relationships of "equipment_position" */
export type StopsDatabaseEquipmentPositionEquipmentPositionKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseEquipmentPositionKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseEquipmentPositionKeyValuesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesBoolExp>;
  };

/** aggregated selection of "equipment_position" */
export type StopsDatabaseEquipmentPositionAggregate = {
  __typename?: 'stops_database_equipment_position_aggregate';
  aggregate?: Maybe<StopsDatabaseEquipmentPositionAggregateFields>;
  nodes: Array<StopsDatabaseEquipmentPosition>;
};

/** aggregate fields of "equipment_position" */
export type StopsDatabaseEquipmentPositionAggregateFields = {
  __typename?: 'stops_database_equipment_position_aggregate_fields';
  avg?: Maybe<StopsDatabaseEquipmentPositionAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseEquipmentPositionMaxFields>;
  min?: Maybe<StopsDatabaseEquipmentPositionMinFields>;
  stddev?: Maybe<StopsDatabaseEquipmentPositionStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseEquipmentPositionStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseEquipmentPositionStddevSampFields>;
  sum?: Maybe<StopsDatabaseEquipmentPositionSumFields>;
  var_pop?: Maybe<StopsDatabaseEquipmentPositionVarPopFields>;
  var_samp?: Maybe<StopsDatabaseEquipmentPositionVarSampFields>;
  variance?: Maybe<StopsDatabaseEquipmentPositionVarianceFields>;
};

/** aggregate fields of "equipment_position" */
export type StopsDatabaseEquipmentPositionAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseEquipmentPositionSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseEquipmentPositionAvgFields = {
  __typename?: 'stops_database_equipment_position_avg_fields';
  description_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
  x_offset?: Maybe<Scalars['Float']>;
  y_offset?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "equipment_position". All fields are combined with a logical 'AND'. */
export type StopsDatabaseEquipmentPositionBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseEquipmentPositionBoolExp>>;
  _not?: InputMaybe<StopsDatabaseEquipmentPositionBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseEquipmentPositionBoolExp>>;
  changed?: InputMaybe<TimestampComparisonExp>;
  changed_by?: InputMaybe<StringComparisonExp>;
  created?: InputMaybe<TimestampComparisonExp>;
  description_id?: InputMaybe<BigintComparisonExp>;
  equipment_position_key_values?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesBoolExp>;
  equipment_position_key_values_aggregate?: InputMaybe<EquipmentPositionKeyValuesAggregateBoolExp>;
  from_date?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  multilingual_string_entity?: InputMaybe<StopsDatabaseMultilingualStringEntityBoolExp>;
  netex_id?: InputMaybe<StringComparisonExp>;
  reference_point_ref?: InputMaybe<StringComparisonExp>;
  reference_point_version?: InputMaybe<StringComparisonExp>;
  to_date?: InputMaybe<TimestampComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
  version_comment?: InputMaybe<StringComparisonExp>;
  x_offset?: InputMaybe<NumericComparisonExp>;
  y_offset?: InputMaybe<NumericComparisonExp>;
};

/** unique or primary key constraints on table "equipment_position" */
export enum StopsDatabaseEquipmentPositionConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  EquipmentPositionNetexIdVersionConstraint = 'equipment_position_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  EquipmentPositionPkey = 'equipment_position_pkey',
}

/** input type for incrementing numeric columns in table "equipment_position" */
export type StopsDatabaseEquipmentPositionIncInput = {
  description_id?: InputMaybe<Scalars['bigint']>;
  id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['bigint']>;
  x_offset?: InputMaybe<Scalars['numeric']>;
  y_offset?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "equipment_position" */
export type StopsDatabaseEquipmentPositionInsertInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_id?: InputMaybe<Scalars['bigint']>;
  equipment_position_key_values?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesArrRelInsertInput>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  multilingual_string_entity?: InputMaybe<StopsDatabaseMultilingualStringEntityObjRelInsertInput>;
  netex_id?: InputMaybe<Scalars['String']>;
  reference_point_ref?: InputMaybe<Scalars['String']>;
  reference_point_version?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
  x_offset?: InputMaybe<Scalars['numeric']>;
  y_offset?: InputMaybe<Scalars['numeric']>;
};

/** columns and relationships of "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValues = {
  __typename?: 'stops_database_equipment_position_key_values';
  equipment_position_id: Scalars['bigint'];
  key_values_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
  /** An object relationship */
  value: StopsDatabaseValue;
};

/** aggregated selection of "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesAggregate = {
  __typename?: 'stops_database_equipment_position_key_values_aggregate';
  aggregate?: Maybe<StopsDatabaseEquipmentPositionKeyValuesAggregateFields>;
  nodes: Array<StopsDatabaseEquipmentPositionKeyValues>;
};

/** aggregate fields of "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesAggregateFields = {
  __typename?: 'stops_database_equipment_position_key_values_aggregate_fields';
  avg?: Maybe<StopsDatabaseEquipmentPositionKeyValuesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseEquipmentPositionKeyValuesMaxFields>;
  min?: Maybe<StopsDatabaseEquipmentPositionKeyValuesMinFields>;
  stddev?: Maybe<StopsDatabaseEquipmentPositionKeyValuesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseEquipmentPositionKeyValuesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseEquipmentPositionKeyValuesStddevSampFields>;
  sum?: Maybe<StopsDatabaseEquipmentPositionKeyValuesSumFields>;
  var_pop?: Maybe<StopsDatabaseEquipmentPositionKeyValuesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseEquipmentPositionKeyValuesVarSampFields>;
  variance?: Maybe<StopsDatabaseEquipmentPositionKeyValuesVarianceFields>;
};

/** aggregate fields of "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<
    Array<StopsDatabaseEquipmentPositionKeyValuesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesArrRelInsertInput = {
  data: Array<StopsDatabaseEquipmentPositionKeyValuesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseEquipmentPositionKeyValuesAvgFields = {
  __typename?: 'stops_database_equipment_position_key_values_avg_fields';
  equipment_position_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesAvgOrderBy = {
  equipment_position_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "equipment_position_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseEquipmentPositionKeyValuesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseEquipmentPositionKeyValuesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseEquipmentPositionKeyValuesBoolExp>>;
  equipment_position_id?: InputMaybe<BigintComparisonExp>;
  key_values_id?: InputMaybe<BigintComparisonExp>;
  key_values_key?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "equipment_position_key_values" */
export enum StopsDatabaseEquipmentPositionKeyValuesConstraint {
  /** unique or primary key constraint on columns "equipment_position_id", "key_values_key" */
  EquipmentPositionKeyValuesPkey = 'equipment_position_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkHw9nq847b38qyxa25ide9ltyy = 'uk_hw9nq847b38qyxa25ide9ltyy',
}

/** input type for incrementing numeric columns in table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesIncInput = {
  equipment_position_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesInsertInput = {
  equipment_position_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseEquipmentPositionKeyValuesMaxFields = {
  __typename?: 'stops_database_equipment_position_key_values_max_fields';
  equipment_position_id?: Maybe<Scalars['bigint']>;
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesMaxOrderBy = {
  equipment_position_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseEquipmentPositionKeyValuesMinFields = {
  __typename?: 'stops_database_equipment_position_key_values_min_fields';
  equipment_position_id?: Maybe<Scalars['bigint']>;
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesMinOrderBy = {
  equipment_position_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesMutationResponse = {
  __typename?: 'stops_database_equipment_position_key_values_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseEquipmentPositionKeyValues>;
};

/** on_conflict condition type for table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesOnConflict = {
  constraint: StopsDatabaseEquipmentPositionKeyValuesConstraint;
  update_columns?: Array<StopsDatabaseEquipmentPositionKeyValuesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "equipment_position_key_values". */
export type StopsDatabaseEquipmentPositionKeyValuesOrderBy = {
  equipment_position_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: equipment_position_key_values */
export type StopsDatabaseEquipmentPositionKeyValuesPkColumnsInput = {
  equipment_position_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
};

/** select columns of table "equipment_position_key_values" */
export enum StopsDatabaseEquipmentPositionKeyValuesSelectColumn {
  /** column name */
  EquipmentPositionId = 'equipment_position_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
}

/** input type for updating data in table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesSetInput = {
  equipment_position_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseEquipmentPositionKeyValuesStddevFields = {
  __typename?: 'stops_database_equipment_position_key_values_stddev_fields';
  equipment_position_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesStddevOrderBy = {
  equipment_position_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseEquipmentPositionKeyValuesStddevPopFields = {
  __typename?: 'stops_database_equipment_position_key_values_stddev_pop_fields';
  equipment_position_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesStddevPopOrderBy = {
  equipment_position_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseEquipmentPositionKeyValuesStddevSampFields = {
  __typename?: 'stops_database_equipment_position_key_values_stddev_samp_fields';
  equipment_position_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesStddevSampOrderBy = {
  equipment_position_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseEquipmentPositionKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseEquipmentPositionKeyValuesStreamCursorValueInput = {
  equipment_position_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseEquipmentPositionKeyValuesSumFields = {
  __typename?: 'stops_database_equipment_position_key_values_sum_fields';
  equipment_position_id?: Maybe<Scalars['bigint']>;
  key_values_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesSumOrderBy = {
  equipment_position_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** update columns of table "equipment_position_key_values" */
export enum StopsDatabaseEquipmentPositionKeyValuesUpdateColumn {
  /** column name */
  EquipmentPositionId = 'equipment_position_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
}

export type StopsDatabaseEquipmentPositionKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseEquipmentPositionKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseEquipmentPositionKeyValuesVarPopFields = {
  __typename?: 'stops_database_equipment_position_key_values_var_pop_fields';
  equipment_position_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesVarPopOrderBy = {
  equipment_position_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseEquipmentPositionKeyValuesVarSampFields = {
  __typename?: 'stops_database_equipment_position_key_values_var_samp_fields';
  equipment_position_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesVarSampOrderBy = {
  equipment_position_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseEquipmentPositionKeyValuesVarianceFields = {
  __typename?: 'stops_database_equipment_position_key_values_variance_fields';
  equipment_position_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesVarianceOrderBy = {
  equipment_position_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseEquipmentPositionMaxFields = {
  __typename?: 'stops_database_equipment_position_max_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_id?: Maybe<Scalars['bigint']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  netex_id?: Maybe<Scalars['String']>;
  reference_point_ref?: Maybe<Scalars['String']>;
  reference_point_version?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
  x_offset?: Maybe<Scalars['numeric']>;
  y_offset?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type StopsDatabaseEquipmentPositionMinFields = {
  __typename?: 'stops_database_equipment_position_min_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_id?: Maybe<Scalars['bigint']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  netex_id?: Maybe<Scalars['String']>;
  reference_point_ref?: Maybe<Scalars['String']>;
  reference_point_version?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
  x_offset?: Maybe<Scalars['numeric']>;
  y_offset?: Maybe<Scalars['numeric']>;
};

/** response of any mutation on the table "equipment_position" */
export type StopsDatabaseEquipmentPositionMutationResponse = {
  __typename?: 'stops_database_equipment_position_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseEquipmentPosition>;
};

/** input type for inserting object relation for remote table "equipment_position" */
export type StopsDatabaseEquipmentPositionObjRelInsertInput = {
  data: StopsDatabaseEquipmentPositionInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseEquipmentPositionOnConflict>;
};

/** on_conflict condition type for table "equipment_position" */
export type StopsDatabaseEquipmentPositionOnConflict = {
  constraint: StopsDatabaseEquipmentPositionConstraint;
  update_columns?: Array<StopsDatabaseEquipmentPositionUpdateColumn>;
  where?: InputMaybe<StopsDatabaseEquipmentPositionBoolExp>;
};

/** Ordering options when selecting data from "equipment_position". */
export type StopsDatabaseEquipmentPositionOrderBy = {
  changed?: InputMaybe<OrderBy>;
  changed_by?: InputMaybe<OrderBy>;
  created?: InputMaybe<OrderBy>;
  description_id?: InputMaybe<OrderBy>;
  equipment_position_key_values_aggregate?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesAggregateOrderBy>;
  from_date?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  multilingual_string_entity?: InputMaybe<StopsDatabaseMultilingualStringEntityOrderBy>;
  netex_id?: InputMaybe<OrderBy>;
  reference_point_ref?: InputMaybe<OrderBy>;
  reference_point_version?: InputMaybe<OrderBy>;
  to_date?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
  version_comment?: InputMaybe<OrderBy>;
  x_offset?: InputMaybe<OrderBy>;
  y_offset?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: equipment_position */
export type StopsDatabaseEquipmentPositionPkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "equipment_position" */
export enum StopsDatabaseEquipmentPositionSelectColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionId = 'description_id',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ReferencePointRef = 'reference_point_ref',
  /** column name */
  ReferencePointVersion = 'reference_point_version',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  XOffset = 'x_offset',
  /** column name */
  YOffset = 'y_offset',
}

/** input type for updating data in table "equipment_position" */
export type StopsDatabaseEquipmentPositionSetInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_id?: InputMaybe<Scalars['bigint']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  netex_id?: InputMaybe<Scalars['String']>;
  reference_point_ref?: InputMaybe<Scalars['String']>;
  reference_point_version?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
  x_offset?: InputMaybe<Scalars['numeric']>;
  y_offset?: InputMaybe<Scalars['numeric']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseEquipmentPositionStddevFields = {
  __typename?: 'stops_database_equipment_position_stddev_fields';
  description_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
  x_offset?: Maybe<Scalars['Float']>;
  y_offset?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseEquipmentPositionStddevPopFields = {
  __typename?: 'stops_database_equipment_position_stddev_pop_fields';
  description_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
  x_offset?: Maybe<Scalars['Float']>;
  y_offset?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseEquipmentPositionStddevSampFields = {
  __typename?: 'stops_database_equipment_position_stddev_samp_fields';
  description_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
  x_offset?: Maybe<Scalars['Float']>;
  y_offset?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "equipment_position" */
export type StopsDatabaseEquipmentPositionStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseEquipmentPositionStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseEquipmentPositionStreamCursorValueInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_id?: InputMaybe<Scalars['bigint']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  netex_id?: InputMaybe<Scalars['String']>;
  reference_point_ref?: InputMaybe<Scalars['String']>;
  reference_point_version?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
  x_offset?: InputMaybe<Scalars['numeric']>;
  y_offset?: InputMaybe<Scalars['numeric']>;
};

/** aggregate sum on columns */
export type StopsDatabaseEquipmentPositionSumFields = {
  __typename?: 'stops_database_equipment_position_sum_fields';
  description_id?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['bigint']>;
  x_offset?: Maybe<Scalars['numeric']>;
  y_offset?: Maybe<Scalars['numeric']>;
};

/** update columns of table "equipment_position" */
export enum StopsDatabaseEquipmentPositionUpdateColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionId = 'description_id',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ReferencePointRef = 'reference_point_ref',
  /** column name */
  ReferencePointVersion = 'reference_point_version',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  XOffset = 'x_offset',
  /** column name */
  YOffset = 'y_offset',
}

export type StopsDatabaseEquipmentPositionUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseEquipmentPositionIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseEquipmentPositionSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseEquipmentPositionBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseEquipmentPositionVarPopFields = {
  __typename?: 'stops_database_equipment_position_var_pop_fields';
  description_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
  x_offset?: Maybe<Scalars['Float']>;
  y_offset?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseEquipmentPositionVarSampFields = {
  __typename?: 'stops_database_equipment_position_var_samp_fields';
  description_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
  x_offset?: Maybe<Scalars['Float']>;
  y_offset?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseEquipmentPositionVarianceFields = {
  __typename?: 'stops_database_equipment_position_variance_fields';
  description_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
  x_offset?: Maybe<Scalars['Float']>;
  y_offset?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "export_job" */
export type StopsDatabaseExportJob = {
  __typename?: 'stops_database_export_job';
  file_name?: Maybe<Scalars['String']>;
  finished?: Maybe<Scalars['timestamp']>;
  id: Scalars['bigint'];
  job_url?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  started?: Maybe<Scalars['timestamp']>;
  status?: Maybe<Scalars['Int']>;
  sub_folder?: Maybe<Scalars['String']>;
};

/** aggregated selection of "export_job" */
export type StopsDatabaseExportJobAggregate = {
  __typename?: 'stops_database_export_job_aggregate';
  aggregate?: Maybe<StopsDatabaseExportJobAggregateFields>;
  nodes: Array<StopsDatabaseExportJob>;
};

/** aggregate fields of "export_job" */
export type StopsDatabaseExportJobAggregateFields = {
  __typename?: 'stops_database_export_job_aggregate_fields';
  avg?: Maybe<StopsDatabaseExportJobAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseExportJobMaxFields>;
  min?: Maybe<StopsDatabaseExportJobMinFields>;
  stddev?: Maybe<StopsDatabaseExportJobStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseExportJobStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseExportJobStddevSampFields>;
  sum?: Maybe<StopsDatabaseExportJobSumFields>;
  var_pop?: Maybe<StopsDatabaseExportJobVarPopFields>;
  var_samp?: Maybe<StopsDatabaseExportJobVarSampFields>;
  variance?: Maybe<StopsDatabaseExportJobVarianceFields>;
};

/** aggregate fields of "export_job" */
export type StopsDatabaseExportJobAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseExportJobSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseExportJobAvgFields = {
  __typename?: 'stops_database_export_job_avg_fields';
  id?: Maybe<Scalars['Float']>;
  status?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "export_job". All fields are combined with a logical 'AND'. */
export type StopsDatabaseExportJobBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseExportJobBoolExp>>;
  _not?: InputMaybe<StopsDatabaseExportJobBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseExportJobBoolExp>>;
  file_name?: InputMaybe<StringComparisonExp>;
  finished?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  job_url?: InputMaybe<StringComparisonExp>;
  message?: InputMaybe<StringComparisonExp>;
  started?: InputMaybe<TimestampComparisonExp>;
  status?: InputMaybe<IntComparisonExp>;
  sub_folder?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "export_job" */
export enum StopsDatabaseExportJobConstraint {
  /** unique or primary key constraint on columns "id" */
  ExportJobPkey = 'export_job_pkey',
}

/** input type for incrementing numeric columns in table "export_job" */
export type StopsDatabaseExportJobIncInput = {
  id?: InputMaybe<Scalars['bigint']>;
  status?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "export_job" */
export type StopsDatabaseExportJobInsertInput = {
  file_name?: InputMaybe<Scalars['String']>;
  finished?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  job_url?: InputMaybe<Scalars['String']>;
  message?: InputMaybe<Scalars['String']>;
  started?: InputMaybe<Scalars['timestamp']>;
  status?: InputMaybe<Scalars['Int']>;
  sub_folder?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type StopsDatabaseExportJobMaxFields = {
  __typename?: 'stops_database_export_job_max_fields';
  file_name?: Maybe<Scalars['String']>;
  finished?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  job_url?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  started?: Maybe<Scalars['timestamp']>;
  status?: Maybe<Scalars['Int']>;
  sub_folder?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseExportJobMinFields = {
  __typename?: 'stops_database_export_job_min_fields';
  file_name?: Maybe<Scalars['String']>;
  finished?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  job_url?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  started?: Maybe<Scalars['timestamp']>;
  status?: Maybe<Scalars['Int']>;
  sub_folder?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "export_job" */
export type StopsDatabaseExportJobMutationResponse = {
  __typename?: 'stops_database_export_job_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseExportJob>;
};

/** on_conflict condition type for table "export_job" */
export type StopsDatabaseExportJobOnConflict = {
  constraint: StopsDatabaseExportJobConstraint;
  update_columns?: Array<StopsDatabaseExportJobUpdateColumn>;
  where?: InputMaybe<StopsDatabaseExportJobBoolExp>;
};

/** Ordering options when selecting data from "export_job". */
export type StopsDatabaseExportJobOrderBy = {
  file_name?: InputMaybe<OrderBy>;
  finished?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  job_url?: InputMaybe<OrderBy>;
  message?: InputMaybe<OrderBy>;
  started?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  sub_folder?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: export_job */
export type StopsDatabaseExportJobPkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "export_job" */
export enum StopsDatabaseExportJobSelectColumn {
  /** column name */
  FileName = 'file_name',
  /** column name */
  Finished = 'finished',
  /** column name */
  Id = 'id',
  /** column name */
  JobUrl = 'job_url',
  /** column name */
  Message = 'message',
  /** column name */
  Started = 'started',
  /** column name */
  Status = 'status',
  /** column name */
  SubFolder = 'sub_folder',
}

/** input type for updating data in table "export_job" */
export type StopsDatabaseExportJobSetInput = {
  file_name?: InputMaybe<Scalars['String']>;
  finished?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  job_url?: InputMaybe<Scalars['String']>;
  message?: InputMaybe<Scalars['String']>;
  started?: InputMaybe<Scalars['timestamp']>;
  status?: InputMaybe<Scalars['Int']>;
  sub_folder?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseExportJobStddevFields = {
  __typename?: 'stops_database_export_job_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  status?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseExportJobStddevPopFields = {
  __typename?: 'stops_database_export_job_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  status?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseExportJobStddevSampFields = {
  __typename?: 'stops_database_export_job_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  status?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "export_job" */
export type StopsDatabaseExportJobStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseExportJobStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseExportJobStreamCursorValueInput = {
  file_name?: InputMaybe<Scalars['String']>;
  finished?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  job_url?: InputMaybe<Scalars['String']>;
  message?: InputMaybe<Scalars['String']>;
  started?: InputMaybe<Scalars['timestamp']>;
  status?: InputMaybe<Scalars['Int']>;
  sub_folder?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseExportJobSumFields = {
  __typename?: 'stops_database_export_job_sum_fields';
  id?: Maybe<Scalars['bigint']>;
  status?: Maybe<Scalars['Int']>;
};

/** update columns of table "export_job" */
export enum StopsDatabaseExportJobUpdateColumn {
  /** column name */
  FileName = 'file_name',
  /** column name */
  Finished = 'finished',
  /** column name */
  Id = 'id',
  /** column name */
  JobUrl = 'job_url',
  /** column name */
  Message = 'message',
  /** column name */
  Started = 'started',
  /** column name */
  Status = 'status',
  /** column name */
  SubFolder = 'sub_folder',
}

export type StopsDatabaseExportJobUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseExportJobIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseExportJobSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseExportJobBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseExportJobVarPopFields = {
  __typename?: 'stops_database_export_job_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  status?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseExportJobVarSampFields = {
  __typename?: 'stops_database_export_job_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  status?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseExportJobVarianceFields = {
  __typename?: 'stops_database_export_job_variance_fields';
  id?: Maybe<Scalars['Float']>;
  status?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "fare_zone" */
export type StopsDatabaseFareZone = {
  __typename?: 'stops_database_fare_zone';
  centroid?: Maybe<Scalars['geometry']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  /** An array relationship */
  fare_zone_key_values: Array<StopsDatabaseFareZoneKeyValues>;
  /** An aggregate relationship */
  fare_zone_key_values_aggregate: StopsDatabaseFareZoneKeyValuesAggregate;
  /** An array relationship */
  fare_zone_members: Array<StopsDatabaseFareZoneMembers>;
  /** An aggregate relationship */
  fare_zone_members_aggregate: StopsDatabaseFareZoneMembersAggregate;
  /** An array relationship */
  fare_zone_neighbours: Array<StopsDatabaseFareZoneNeighbours>;
  /** An aggregate relationship */
  fare_zone_neighbours_aggregate: StopsDatabaseFareZoneNeighboursAggregate;
  from_date?: Maybe<Scalars['timestamp']>;
  id: Scalars['bigint'];
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  /** An object relationship */
  persistable_polygon?: Maybe<StopsDatabasePersistablePolygon>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  scoping_method?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  transport_organisation_ref?: Maybe<Scalars['String']>;
  version: Scalars['bigint'];
  version_comment?: Maybe<Scalars['String']>;
  zone_topology?: Maybe<Scalars['String']>;
};

/** columns and relationships of "fare_zone" */
export type StopsDatabaseFareZoneFareZoneKeyValuesArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseFareZoneKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseFareZoneKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneKeyValuesBoolExp>;
};

/** columns and relationships of "fare_zone" */
export type StopsDatabaseFareZoneFareZoneKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseFareZoneKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseFareZoneKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneKeyValuesBoolExp>;
};

/** columns and relationships of "fare_zone" */
export type StopsDatabaseFareZoneFareZoneMembersArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseFareZoneMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseFareZoneMembersOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneMembersBoolExp>;
};

/** columns and relationships of "fare_zone" */
export type StopsDatabaseFareZoneFareZoneMembersAggregateArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseFareZoneMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseFareZoneMembersOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneMembersBoolExp>;
};

/** columns and relationships of "fare_zone" */
export type StopsDatabaseFareZoneFareZoneNeighboursArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseFareZoneNeighboursSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseFareZoneNeighboursOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneNeighboursBoolExp>;
};

/** columns and relationships of "fare_zone" */
export type StopsDatabaseFareZoneFareZoneNeighboursAggregateArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseFareZoneNeighboursSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseFareZoneNeighboursOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneNeighboursBoolExp>;
};

/** aggregated selection of "fare_zone" */
export type StopsDatabaseFareZoneAggregate = {
  __typename?: 'stops_database_fare_zone_aggregate';
  aggregate?: Maybe<StopsDatabaseFareZoneAggregateFields>;
  nodes: Array<StopsDatabaseFareZone>;
};

/** aggregate fields of "fare_zone" */
export type StopsDatabaseFareZoneAggregateFields = {
  __typename?: 'stops_database_fare_zone_aggregate_fields';
  avg?: Maybe<StopsDatabaseFareZoneAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseFareZoneMaxFields>;
  min?: Maybe<StopsDatabaseFareZoneMinFields>;
  stddev?: Maybe<StopsDatabaseFareZoneStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseFareZoneStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseFareZoneStddevSampFields>;
  sum?: Maybe<StopsDatabaseFareZoneSumFields>;
  var_pop?: Maybe<StopsDatabaseFareZoneVarPopFields>;
  var_samp?: Maybe<StopsDatabaseFareZoneVarSampFields>;
  variance?: Maybe<StopsDatabaseFareZoneVarianceFields>;
};

/** aggregate fields of "fare_zone" */
export type StopsDatabaseFareZoneAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseFareZoneSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseFareZoneAvgFields = {
  __typename?: 'stops_database_fare_zone_avg_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "fare_zone". All fields are combined with a logical 'AND'. */
export type StopsDatabaseFareZoneBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseFareZoneBoolExp>>;
  _not?: InputMaybe<StopsDatabaseFareZoneBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseFareZoneBoolExp>>;
  centroid?: InputMaybe<GeometryComparisonExp>;
  changed?: InputMaybe<TimestampComparisonExp>;
  changed_by?: InputMaybe<StringComparisonExp>;
  created?: InputMaybe<TimestampComparisonExp>;
  description_lang?: InputMaybe<StringComparisonExp>;
  description_value?: InputMaybe<StringComparisonExp>;
  fare_zone_key_values?: InputMaybe<StopsDatabaseFareZoneKeyValuesBoolExp>;
  fare_zone_key_values_aggregate?: InputMaybe<FareZoneKeyValuesAggregateBoolExp>;
  fare_zone_members?: InputMaybe<StopsDatabaseFareZoneMembersBoolExp>;
  fare_zone_members_aggregate?: InputMaybe<FareZoneMembersAggregateBoolExp>;
  fare_zone_neighbours?: InputMaybe<StopsDatabaseFareZoneNeighboursBoolExp>;
  fare_zone_neighbours_aggregate?: InputMaybe<FareZoneNeighboursAggregateBoolExp>;
  from_date?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  name_lang?: InputMaybe<StringComparisonExp>;
  name_value?: InputMaybe<StringComparisonExp>;
  netex_id?: InputMaybe<StringComparisonExp>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  polygon_id?: InputMaybe<BigintComparisonExp>;
  private_code_type?: InputMaybe<StringComparisonExp>;
  private_code_value?: InputMaybe<StringComparisonExp>;
  scoping_method?: InputMaybe<StringComparisonExp>;
  short_name_lang?: InputMaybe<StringComparisonExp>;
  short_name_value?: InputMaybe<StringComparisonExp>;
  to_date?: InputMaybe<TimestampComparisonExp>;
  transport_organisation_ref?: InputMaybe<StringComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
  version_comment?: InputMaybe<StringComparisonExp>;
  zone_topology?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "fare_zone" */
export enum StopsDatabaseFareZoneConstraint {
  /** unique or primary key constraint on columns "id" */
  FareZonePkey = 'fare_zone_pkey',
}

/** input type for incrementing numeric columns in table "fare_zone" */
export type StopsDatabaseFareZoneIncInput = {
  id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "fare_zone" */
export type StopsDatabaseFareZoneInsertInput = {
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  fare_zone_key_values?: InputMaybe<StopsDatabaseFareZoneKeyValuesArrRelInsertInput>;
  fare_zone_members?: InputMaybe<StopsDatabaseFareZoneMembersArrRelInsertInput>;
  fare_zone_neighbours?: InputMaybe<StopsDatabaseFareZoneNeighboursArrRelInsertInput>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonObjRelInsertInput>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  scoping_method?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  transport_organisation_ref?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
  zone_topology?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValues = {
  __typename?: 'stops_database_fare_zone_key_values';
  fare_zone_id: Scalars['bigint'];
  key_values_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
  /** An object relationship */
  value: StopsDatabaseValue;
};

/** aggregated selection of "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesAggregate = {
  __typename?: 'stops_database_fare_zone_key_values_aggregate';
  aggregate?: Maybe<StopsDatabaseFareZoneKeyValuesAggregateFields>;
  nodes: Array<StopsDatabaseFareZoneKeyValues>;
};

/** aggregate fields of "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesAggregateFields = {
  __typename?: 'stops_database_fare_zone_key_values_aggregate_fields';
  avg?: Maybe<StopsDatabaseFareZoneKeyValuesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseFareZoneKeyValuesMaxFields>;
  min?: Maybe<StopsDatabaseFareZoneKeyValuesMinFields>;
  stddev?: Maybe<StopsDatabaseFareZoneKeyValuesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseFareZoneKeyValuesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseFareZoneKeyValuesStddevSampFields>;
  sum?: Maybe<StopsDatabaseFareZoneKeyValuesSumFields>;
  var_pop?: Maybe<StopsDatabaseFareZoneKeyValuesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseFareZoneKeyValuesVarSampFields>;
  variance?: Maybe<StopsDatabaseFareZoneKeyValuesVarianceFields>;
};

/** aggregate fields of "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseFareZoneKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseFareZoneKeyValuesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseFareZoneKeyValuesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseFareZoneKeyValuesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseFareZoneKeyValuesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseFareZoneKeyValuesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseFareZoneKeyValuesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseFareZoneKeyValuesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseFareZoneKeyValuesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseFareZoneKeyValuesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseFareZoneKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesArrRelInsertInput = {
  data: Array<StopsDatabaseFareZoneKeyValuesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseFareZoneKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseFareZoneKeyValuesAvgFields = {
  __typename?: 'stops_database_fare_zone_key_values_avg_fields';
  fare_zone_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesAvgOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "fare_zone_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseFareZoneKeyValuesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseFareZoneKeyValuesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseFareZoneKeyValuesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseFareZoneKeyValuesBoolExp>>;
  fare_zone_id?: InputMaybe<BigintComparisonExp>;
  key_values_id?: InputMaybe<BigintComparisonExp>;
  key_values_key?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "fare_zone_key_values" */
export enum StopsDatabaseFareZoneKeyValuesConstraint {
  /** unique or primary key constraint on columns "key_values_key", "fare_zone_id" */
  FareZoneKeyValuesPkey = 'fare_zone_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkOujfy4iyi1cf3fdquir6jsn0n = 'uk_oujfy4iyi1cf3fdquir6jsn0n',
}

/** input type for incrementing numeric columns in table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesIncInput = {
  fare_zone_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesInsertInput = {
  fare_zone_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseFareZoneKeyValuesMaxFields = {
  __typename?: 'stops_database_fare_zone_key_values_max_fields';
  fare_zone_id?: Maybe<Scalars['bigint']>;
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesMaxOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseFareZoneKeyValuesMinFields = {
  __typename?: 'stops_database_fare_zone_key_values_min_fields';
  fare_zone_id?: Maybe<Scalars['bigint']>;
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesMinOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesMutationResponse = {
  __typename?: 'stops_database_fare_zone_key_values_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseFareZoneKeyValues>;
};

/** on_conflict condition type for table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesOnConflict = {
  constraint: StopsDatabaseFareZoneKeyValuesConstraint;
  update_columns?: Array<StopsDatabaseFareZoneKeyValuesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseFareZoneKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "fare_zone_key_values". */
export type StopsDatabaseFareZoneKeyValuesOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: fare_zone_key_values */
export type StopsDatabaseFareZoneKeyValuesPkColumnsInput = {
  fare_zone_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
};

/** select columns of table "fare_zone_key_values" */
export enum StopsDatabaseFareZoneKeyValuesSelectColumn {
  /** column name */
  FareZoneId = 'fare_zone_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
}

/** input type for updating data in table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesSetInput = {
  fare_zone_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseFareZoneKeyValuesStddevFields = {
  __typename?: 'stops_database_fare_zone_key_values_stddev_fields';
  fare_zone_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesStddevOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseFareZoneKeyValuesStddevPopFields = {
  __typename?: 'stops_database_fare_zone_key_values_stddev_pop_fields';
  fare_zone_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesStddevPopOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseFareZoneKeyValuesStddevSampFields = {
  __typename?: 'stops_database_fare_zone_key_values_stddev_samp_fields';
  fare_zone_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesStddevSampOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseFareZoneKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseFareZoneKeyValuesStreamCursorValueInput = {
  fare_zone_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseFareZoneKeyValuesSumFields = {
  __typename?: 'stops_database_fare_zone_key_values_sum_fields';
  fare_zone_id?: Maybe<Scalars['bigint']>;
  key_values_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesSumOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** update columns of table "fare_zone_key_values" */
export enum StopsDatabaseFareZoneKeyValuesUpdateColumn {
  /** column name */
  FareZoneId = 'fare_zone_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
}

export type StopsDatabaseFareZoneKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseFareZoneKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseFareZoneKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseFareZoneKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseFareZoneKeyValuesVarPopFields = {
  __typename?: 'stops_database_fare_zone_key_values_var_pop_fields';
  fare_zone_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesVarPopOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseFareZoneKeyValuesVarSampFields = {
  __typename?: 'stops_database_fare_zone_key_values_var_samp_fields';
  fare_zone_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesVarSampOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseFareZoneKeyValuesVarianceFields = {
  __typename?: 'stops_database_fare_zone_key_values_variance_fields';
  fare_zone_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesVarianceOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseFareZoneMaxFields = {
  __typename?: 'stops_database_fare_zone_max_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  scoping_method?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  transport_organisation_ref?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
  zone_topology?: Maybe<Scalars['String']>;
};

/** columns and relationships of "fare_zone_members" */
export type StopsDatabaseFareZoneMembers = {
  __typename?: 'stops_database_fare_zone_members';
  /** An object relationship */
  fare_zone: StopsDatabaseFareZone;
  fare_zone_id: Scalars['bigint'];
  ref?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['String']>;
};

/** aggregated selection of "fare_zone_members" */
export type StopsDatabaseFareZoneMembersAggregate = {
  __typename?: 'stops_database_fare_zone_members_aggregate';
  aggregate?: Maybe<StopsDatabaseFareZoneMembersAggregateFields>;
  nodes: Array<StopsDatabaseFareZoneMembers>;
};

/** aggregate fields of "fare_zone_members" */
export type StopsDatabaseFareZoneMembersAggregateFields = {
  __typename?: 'stops_database_fare_zone_members_aggregate_fields';
  avg?: Maybe<StopsDatabaseFareZoneMembersAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseFareZoneMembersMaxFields>;
  min?: Maybe<StopsDatabaseFareZoneMembersMinFields>;
  stddev?: Maybe<StopsDatabaseFareZoneMembersStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseFareZoneMembersStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseFareZoneMembersStddevSampFields>;
  sum?: Maybe<StopsDatabaseFareZoneMembersSumFields>;
  var_pop?: Maybe<StopsDatabaseFareZoneMembersVarPopFields>;
  var_samp?: Maybe<StopsDatabaseFareZoneMembersVarSampFields>;
  variance?: Maybe<StopsDatabaseFareZoneMembersVarianceFields>;
};

/** aggregate fields of "fare_zone_members" */
export type StopsDatabaseFareZoneMembersAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseFareZoneMembersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseFareZoneMembersAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseFareZoneMembersMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseFareZoneMembersMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseFareZoneMembersStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseFareZoneMembersStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseFareZoneMembersStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseFareZoneMembersSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseFareZoneMembersVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseFareZoneMembersVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseFareZoneMembersVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersArrRelInsertInput = {
  data: Array<StopsDatabaseFareZoneMembersInsertInput>;
};

/** aggregate avg on columns */
export type StopsDatabaseFareZoneMembersAvgFields = {
  __typename?: 'stops_database_fare_zone_members_avg_fields';
  fare_zone_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersAvgOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "fare_zone_members". All fields are combined with a logical 'AND'. */
export type StopsDatabaseFareZoneMembersBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseFareZoneMembersBoolExp>>;
  _not?: InputMaybe<StopsDatabaseFareZoneMembersBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseFareZoneMembersBoolExp>>;
  fare_zone?: InputMaybe<StopsDatabaseFareZoneBoolExp>;
  fare_zone_id?: InputMaybe<BigintComparisonExp>;
  ref?: InputMaybe<StringComparisonExp>;
  version?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersIncInput = {
  fare_zone_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersInsertInput = {
  fare_zone?: InputMaybe<StopsDatabaseFareZoneObjRelInsertInput>;
  fare_zone_id?: InputMaybe<Scalars['bigint']>;
  ref?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type StopsDatabaseFareZoneMembersMaxFields = {
  __typename?: 'stops_database_fare_zone_members_max_fields';
  fare_zone_id?: Maybe<Scalars['bigint']>;
  ref?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersMaxOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
  ref?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseFareZoneMembersMinFields = {
  __typename?: 'stops_database_fare_zone_members_min_fields';
  fare_zone_id?: Maybe<Scalars['bigint']>;
  ref?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersMinOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
  ref?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersMutationResponse = {
  __typename?: 'stops_database_fare_zone_members_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseFareZoneMembers>;
};

/** Ordering options when selecting data from "fare_zone_members". */
export type StopsDatabaseFareZoneMembersOrderBy = {
  fare_zone?: InputMaybe<StopsDatabaseFareZoneOrderBy>;
  fare_zone_id?: InputMaybe<OrderBy>;
  ref?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
};

/** select columns of table "fare_zone_members" */
export enum StopsDatabaseFareZoneMembersSelectColumn {
  /** column name */
  FareZoneId = 'fare_zone_id',
  /** column name */
  Ref = 'ref',
  /** column name */
  Version = 'version',
}

/** input type for updating data in table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersSetInput = {
  fare_zone_id?: InputMaybe<Scalars['bigint']>;
  ref?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseFareZoneMembersStddevFields = {
  __typename?: 'stops_database_fare_zone_members_stddev_fields';
  fare_zone_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersStddevOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseFareZoneMembersStddevPopFields = {
  __typename?: 'stops_database_fare_zone_members_stddev_pop_fields';
  fare_zone_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersStddevPopOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseFareZoneMembersStddevSampFields = {
  __typename?: 'stops_database_fare_zone_members_stddev_samp_fields';
  fare_zone_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersStddevSampOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseFareZoneMembersStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseFareZoneMembersStreamCursorValueInput = {
  fare_zone_id?: InputMaybe<Scalars['bigint']>;
  ref?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseFareZoneMembersSumFields = {
  __typename?: 'stops_database_fare_zone_members_sum_fields';
  fare_zone_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersSumOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
};

export type StopsDatabaseFareZoneMembersUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseFareZoneMembersIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseFareZoneMembersSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseFareZoneMembersBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseFareZoneMembersVarPopFields = {
  __typename?: 'stops_database_fare_zone_members_var_pop_fields';
  fare_zone_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersVarPopOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseFareZoneMembersVarSampFields = {
  __typename?: 'stops_database_fare_zone_members_var_samp_fields';
  fare_zone_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersVarSampOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseFareZoneMembersVarianceFields = {
  __typename?: 'stops_database_fare_zone_members_variance_fields';
  fare_zone_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersVarianceOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseFareZoneMinFields = {
  __typename?: 'stops_database_fare_zone_min_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  scoping_method?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  transport_organisation_ref?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
  zone_topology?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "fare_zone" */
export type StopsDatabaseFareZoneMutationResponse = {
  __typename?: 'stops_database_fare_zone_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseFareZone>;
};

/** columns and relationships of "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighbours = {
  __typename?: 'stops_database_fare_zone_neighbours';
  /** An object relationship */
  fare_zone: StopsDatabaseFareZone;
  fare_zone_id: Scalars['bigint'];
  ref?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['String']>;
};

/** aggregated selection of "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursAggregate = {
  __typename?: 'stops_database_fare_zone_neighbours_aggregate';
  aggregate?: Maybe<StopsDatabaseFareZoneNeighboursAggregateFields>;
  nodes: Array<StopsDatabaseFareZoneNeighbours>;
};

/** aggregate fields of "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursAggregateFields = {
  __typename?: 'stops_database_fare_zone_neighbours_aggregate_fields';
  avg?: Maybe<StopsDatabaseFareZoneNeighboursAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseFareZoneNeighboursMaxFields>;
  min?: Maybe<StopsDatabaseFareZoneNeighboursMinFields>;
  stddev?: Maybe<StopsDatabaseFareZoneNeighboursStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseFareZoneNeighboursStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseFareZoneNeighboursStddevSampFields>;
  sum?: Maybe<StopsDatabaseFareZoneNeighboursSumFields>;
  var_pop?: Maybe<StopsDatabaseFareZoneNeighboursVarPopFields>;
  var_samp?: Maybe<StopsDatabaseFareZoneNeighboursVarSampFields>;
  variance?: Maybe<StopsDatabaseFareZoneNeighboursVarianceFields>;
};

/** aggregate fields of "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseFareZoneNeighboursSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseFareZoneNeighboursAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseFareZoneNeighboursMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseFareZoneNeighboursMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseFareZoneNeighboursStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseFareZoneNeighboursStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseFareZoneNeighboursStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseFareZoneNeighboursSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseFareZoneNeighboursVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseFareZoneNeighboursVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseFareZoneNeighboursVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursArrRelInsertInput = {
  data: Array<StopsDatabaseFareZoneNeighboursInsertInput>;
};

/** aggregate avg on columns */
export type StopsDatabaseFareZoneNeighboursAvgFields = {
  __typename?: 'stops_database_fare_zone_neighbours_avg_fields';
  fare_zone_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursAvgOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "fare_zone_neighbours". All fields are combined with a logical 'AND'. */
export type StopsDatabaseFareZoneNeighboursBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseFareZoneNeighboursBoolExp>>;
  _not?: InputMaybe<StopsDatabaseFareZoneNeighboursBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseFareZoneNeighboursBoolExp>>;
  fare_zone?: InputMaybe<StopsDatabaseFareZoneBoolExp>;
  fare_zone_id?: InputMaybe<BigintComparisonExp>;
  ref?: InputMaybe<StringComparisonExp>;
  version?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursIncInput = {
  fare_zone_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursInsertInput = {
  fare_zone?: InputMaybe<StopsDatabaseFareZoneObjRelInsertInput>;
  fare_zone_id?: InputMaybe<Scalars['bigint']>;
  ref?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type StopsDatabaseFareZoneNeighboursMaxFields = {
  __typename?: 'stops_database_fare_zone_neighbours_max_fields';
  fare_zone_id?: Maybe<Scalars['bigint']>;
  ref?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursMaxOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
  ref?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseFareZoneNeighboursMinFields = {
  __typename?: 'stops_database_fare_zone_neighbours_min_fields';
  fare_zone_id?: Maybe<Scalars['bigint']>;
  ref?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursMinOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
  ref?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursMutationResponse = {
  __typename?: 'stops_database_fare_zone_neighbours_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseFareZoneNeighbours>;
};

/** Ordering options when selecting data from "fare_zone_neighbours". */
export type StopsDatabaseFareZoneNeighboursOrderBy = {
  fare_zone?: InputMaybe<StopsDatabaseFareZoneOrderBy>;
  fare_zone_id?: InputMaybe<OrderBy>;
  ref?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
};

/** select columns of table "fare_zone_neighbours" */
export enum StopsDatabaseFareZoneNeighboursSelectColumn {
  /** column name */
  FareZoneId = 'fare_zone_id',
  /** column name */
  Ref = 'ref',
  /** column name */
  Version = 'version',
}

/** input type for updating data in table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursSetInput = {
  fare_zone_id?: InputMaybe<Scalars['bigint']>;
  ref?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseFareZoneNeighboursStddevFields = {
  __typename?: 'stops_database_fare_zone_neighbours_stddev_fields';
  fare_zone_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursStddevOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseFareZoneNeighboursStddevPopFields = {
  __typename?: 'stops_database_fare_zone_neighbours_stddev_pop_fields';
  fare_zone_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursStddevPopOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseFareZoneNeighboursStddevSampFields = {
  __typename?: 'stops_database_fare_zone_neighbours_stddev_samp_fields';
  fare_zone_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursStddevSampOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseFareZoneNeighboursStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseFareZoneNeighboursStreamCursorValueInput = {
  fare_zone_id?: InputMaybe<Scalars['bigint']>;
  ref?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseFareZoneNeighboursSumFields = {
  __typename?: 'stops_database_fare_zone_neighbours_sum_fields';
  fare_zone_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursSumOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
};

export type StopsDatabaseFareZoneNeighboursUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseFareZoneNeighboursIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseFareZoneNeighboursSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseFareZoneNeighboursBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseFareZoneNeighboursVarPopFields = {
  __typename?: 'stops_database_fare_zone_neighbours_var_pop_fields';
  fare_zone_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursVarPopOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseFareZoneNeighboursVarSampFields = {
  __typename?: 'stops_database_fare_zone_neighbours_var_samp_fields';
  fare_zone_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursVarSampOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseFareZoneNeighboursVarianceFields = {
  __typename?: 'stops_database_fare_zone_neighbours_variance_fields';
  fare_zone_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursVarianceOrderBy = {
  fare_zone_id?: InputMaybe<OrderBy>;
};

/** input type for inserting object relation for remote table "fare_zone" */
export type StopsDatabaseFareZoneObjRelInsertInput = {
  data: StopsDatabaseFareZoneInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseFareZoneOnConflict>;
};

/** on_conflict condition type for table "fare_zone" */
export type StopsDatabaseFareZoneOnConflict = {
  constraint: StopsDatabaseFareZoneConstraint;
  update_columns?: Array<StopsDatabaseFareZoneUpdateColumn>;
  where?: InputMaybe<StopsDatabaseFareZoneBoolExp>;
};

/** Ordering options when selecting data from "fare_zone". */
export type StopsDatabaseFareZoneOrderBy = {
  centroid?: InputMaybe<OrderBy>;
  changed?: InputMaybe<OrderBy>;
  changed_by?: InputMaybe<OrderBy>;
  created?: InputMaybe<OrderBy>;
  description_lang?: InputMaybe<OrderBy>;
  description_value?: InputMaybe<OrderBy>;
  fare_zone_key_values_aggregate?: InputMaybe<StopsDatabaseFareZoneKeyValuesAggregateOrderBy>;
  fare_zone_members_aggregate?: InputMaybe<StopsDatabaseFareZoneMembersAggregateOrderBy>;
  fare_zone_neighbours_aggregate?: InputMaybe<StopsDatabaseFareZoneNeighboursAggregateOrderBy>;
  from_date?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name_lang?: InputMaybe<OrderBy>;
  name_value?: InputMaybe<OrderBy>;
  netex_id?: InputMaybe<OrderBy>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonOrderBy>;
  polygon_id?: InputMaybe<OrderBy>;
  private_code_type?: InputMaybe<OrderBy>;
  private_code_value?: InputMaybe<OrderBy>;
  scoping_method?: InputMaybe<OrderBy>;
  short_name_lang?: InputMaybe<OrderBy>;
  short_name_value?: InputMaybe<OrderBy>;
  to_date?: InputMaybe<OrderBy>;
  transport_organisation_ref?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
  version_comment?: InputMaybe<OrderBy>;
  zone_topology?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: fare_zone */
export type StopsDatabaseFareZonePkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "fare_zone" */
export enum StopsDatabaseFareZoneSelectColumn {
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ScopingMethod = 'scoping_method',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TransportOrganisationRef = 'transport_organisation_ref',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  ZoneTopology = 'zone_topology',
}

/** input type for updating data in table "fare_zone" */
export type StopsDatabaseFareZoneSetInput = {
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  scoping_method?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  transport_organisation_ref?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
  zone_topology?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseFareZoneStddevFields = {
  __typename?: 'stops_database_fare_zone_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseFareZoneStddevPopFields = {
  __typename?: 'stops_database_fare_zone_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseFareZoneStddevSampFields = {
  __typename?: 'stops_database_fare_zone_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "fare_zone" */
export type StopsDatabaseFareZoneStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseFareZoneStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseFareZoneStreamCursorValueInput = {
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  scoping_method?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  transport_organisation_ref?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
  zone_topology?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseFareZoneSumFields = {
  __typename?: 'stops_database_fare_zone_sum_fields';
  id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['bigint']>;
};

/** update columns of table "fare_zone" */
export enum StopsDatabaseFareZoneUpdateColumn {
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ScopingMethod = 'scoping_method',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TransportOrganisationRef = 'transport_organisation_ref',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  ZoneTopology = 'zone_topology',
}

export type StopsDatabaseFareZoneUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseFareZoneIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseFareZoneSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseFareZoneBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseFareZoneVarPopFields = {
  __typename?: 'stops_database_fare_zone_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseFareZoneVarSampFields = {
  __typename?: 'stops_database_fare_zone_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseFareZoneVarianceFields = {
  __typename?: 'stops_database_fare_zone_variance_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "geography_columns" */
export type StopsDatabaseGeographyColumns = {
  __typename?: 'stops_database_geography_columns';
  coord_dimension?: Maybe<Scalars['Int']>;
  f_geography_column?: Maybe<Scalars['name']>;
  f_table_catalog?: Maybe<Scalars['name']>;
  f_table_name?: Maybe<Scalars['name']>;
  f_table_schema?: Maybe<Scalars['name']>;
  srid?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
};

/** aggregated selection of "geography_columns" */
export type StopsDatabaseGeographyColumnsAggregate = {
  __typename?: 'stops_database_geography_columns_aggregate';
  aggregate?: Maybe<StopsDatabaseGeographyColumnsAggregateFields>;
  nodes: Array<StopsDatabaseGeographyColumns>;
};

/** aggregate fields of "geography_columns" */
export type StopsDatabaseGeographyColumnsAggregateFields = {
  __typename?: 'stops_database_geography_columns_aggregate_fields';
  avg?: Maybe<StopsDatabaseGeographyColumnsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseGeographyColumnsMaxFields>;
  min?: Maybe<StopsDatabaseGeographyColumnsMinFields>;
  stddev?: Maybe<StopsDatabaseGeographyColumnsStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseGeographyColumnsStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseGeographyColumnsStddevSampFields>;
  sum?: Maybe<StopsDatabaseGeographyColumnsSumFields>;
  var_pop?: Maybe<StopsDatabaseGeographyColumnsVarPopFields>;
  var_samp?: Maybe<StopsDatabaseGeographyColumnsVarSampFields>;
  variance?: Maybe<StopsDatabaseGeographyColumnsVarianceFields>;
};

/** aggregate fields of "geography_columns" */
export type StopsDatabaseGeographyColumnsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseGeographyColumnsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseGeographyColumnsAvgFields = {
  __typename?: 'stops_database_geography_columns_avg_fields';
  coord_dimension?: Maybe<Scalars['Float']>;
  srid?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "geography_columns". All fields are combined with a logical 'AND'. */
export type StopsDatabaseGeographyColumnsBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseGeographyColumnsBoolExp>>;
  _not?: InputMaybe<StopsDatabaseGeographyColumnsBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseGeographyColumnsBoolExp>>;
  coord_dimension?: InputMaybe<IntComparisonExp>;
  f_geography_column?: InputMaybe<NameComparisonExp>;
  f_table_catalog?: InputMaybe<NameComparisonExp>;
  f_table_name?: InputMaybe<NameComparisonExp>;
  f_table_schema?: InputMaybe<NameComparisonExp>;
  srid?: InputMaybe<IntComparisonExp>;
  type?: InputMaybe<StringComparisonExp>;
};

/** aggregate max on columns */
export type StopsDatabaseGeographyColumnsMaxFields = {
  __typename?: 'stops_database_geography_columns_max_fields';
  coord_dimension?: Maybe<Scalars['Int']>;
  srid?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseGeographyColumnsMinFields = {
  __typename?: 'stops_database_geography_columns_min_fields';
  coord_dimension?: Maybe<Scalars['Int']>;
  srid?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
};

/** Ordering options when selecting data from "geography_columns". */
export type StopsDatabaseGeographyColumnsOrderBy = {
  coord_dimension?: InputMaybe<OrderBy>;
  f_geography_column?: InputMaybe<OrderBy>;
  f_table_catalog?: InputMaybe<OrderBy>;
  f_table_name?: InputMaybe<OrderBy>;
  f_table_schema?: InputMaybe<OrderBy>;
  srid?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
};

/** select columns of table "geography_columns" */
export enum StopsDatabaseGeographyColumnsSelectColumn {
  /** column name */
  CoordDimension = 'coord_dimension',
  /** column name */
  FGeographyColumn = 'f_geography_column',
  /** column name */
  FTableCatalog = 'f_table_catalog',
  /** column name */
  FTableName = 'f_table_name',
  /** column name */
  FTableSchema = 'f_table_schema',
  /** column name */
  Srid = 'srid',
  /** column name */
  Type = 'type',
}

/** aggregate stddev on columns */
export type StopsDatabaseGeographyColumnsStddevFields = {
  __typename?: 'stops_database_geography_columns_stddev_fields';
  coord_dimension?: Maybe<Scalars['Float']>;
  srid?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseGeographyColumnsStddevPopFields = {
  __typename?: 'stops_database_geography_columns_stddev_pop_fields';
  coord_dimension?: Maybe<Scalars['Float']>;
  srid?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseGeographyColumnsStddevSampFields = {
  __typename?: 'stops_database_geography_columns_stddev_samp_fields';
  coord_dimension?: Maybe<Scalars['Float']>;
  srid?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "geography_columns" */
export type StopsDatabaseGeographyColumnsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseGeographyColumnsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseGeographyColumnsStreamCursorValueInput = {
  coord_dimension?: InputMaybe<Scalars['Int']>;
  f_geography_column?: InputMaybe<Scalars['name']>;
  f_table_catalog?: InputMaybe<Scalars['name']>;
  f_table_name?: InputMaybe<Scalars['name']>;
  f_table_schema?: InputMaybe<Scalars['name']>;
  srid?: InputMaybe<Scalars['Int']>;
  type?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseGeographyColumnsSumFields = {
  __typename?: 'stops_database_geography_columns_sum_fields';
  coord_dimension?: Maybe<Scalars['Int']>;
  srid?: Maybe<Scalars['Int']>;
};

/** aggregate var_pop on columns */
export type StopsDatabaseGeographyColumnsVarPopFields = {
  __typename?: 'stops_database_geography_columns_var_pop_fields';
  coord_dimension?: Maybe<Scalars['Float']>;
  srid?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseGeographyColumnsVarSampFields = {
  __typename?: 'stops_database_geography_columns_var_samp_fields';
  coord_dimension?: Maybe<Scalars['Float']>;
  srid?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseGeographyColumnsVarianceFields = {
  __typename?: 'stops_database_geography_columns_variance_fields';
  coord_dimension?: Maybe<Scalars['Float']>;
  srid?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "geometry_columns" */
export type StopsDatabaseGeometryColumns = {
  __typename?: 'stops_database_geometry_columns';
  coord_dimension?: Maybe<Scalars['Int']>;
  f_geometry_column?: Maybe<Scalars['name']>;
  f_table_catalog?: Maybe<Scalars['String']>;
  f_table_name?: Maybe<Scalars['name']>;
  f_table_schema?: Maybe<Scalars['name']>;
  srid?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
};

/** aggregated selection of "geometry_columns" */
export type StopsDatabaseGeometryColumnsAggregate = {
  __typename?: 'stops_database_geometry_columns_aggregate';
  aggregate?: Maybe<StopsDatabaseGeometryColumnsAggregateFields>;
  nodes: Array<StopsDatabaseGeometryColumns>;
};

/** aggregate fields of "geometry_columns" */
export type StopsDatabaseGeometryColumnsAggregateFields = {
  __typename?: 'stops_database_geometry_columns_aggregate_fields';
  avg?: Maybe<StopsDatabaseGeometryColumnsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseGeometryColumnsMaxFields>;
  min?: Maybe<StopsDatabaseGeometryColumnsMinFields>;
  stddev?: Maybe<StopsDatabaseGeometryColumnsStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseGeometryColumnsStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseGeometryColumnsStddevSampFields>;
  sum?: Maybe<StopsDatabaseGeometryColumnsSumFields>;
  var_pop?: Maybe<StopsDatabaseGeometryColumnsVarPopFields>;
  var_samp?: Maybe<StopsDatabaseGeometryColumnsVarSampFields>;
  variance?: Maybe<StopsDatabaseGeometryColumnsVarianceFields>;
};

/** aggregate fields of "geometry_columns" */
export type StopsDatabaseGeometryColumnsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseGeometryColumnsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseGeometryColumnsAvgFields = {
  __typename?: 'stops_database_geometry_columns_avg_fields';
  coord_dimension?: Maybe<Scalars['Float']>;
  srid?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "geometry_columns". All fields are combined with a logical 'AND'. */
export type StopsDatabaseGeometryColumnsBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseGeometryColumnsBoolExp>>;
  _not?: InputMaybe<StopsDatabaseGeometryColumnsBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseGeometryColumnsBoolExp>>;
  coord_dimension?: InputMaybe<IntComparisonExp>;
  f_geometry_column?: InputMaybe<NameComparisonExp>;
  f_table_catalog?: InputMaybe<StringComparisonExp>;
  f_table_name?: InputMaybe<NameComparisonExp>;
  f_table_schema?: InputMaybe<NameComparisonExp>;
  srid?: InputMaybe<IntComparisonExp>;
  type?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "geometry_columns" */
export type StopsDatabaseGeometryColumnsIncInput = {
  coord_dimension?: InputMaybe<Scalars['Int']>;
  srid?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "geometry_columns" */
export type StopsDatabaseGeometryColumnsInsertInput = {
  coord_dimension?: InputMaybe<Scalars['Int']>;
  f_geometry_column?: InputMaybe<Scalars['name']>;
  f_table_catalog?: InputMaybe<Scalars['String']>;
  f_table_name?: InputMaybe<Scalars['name']>;
  f_table_schema?: InputMaybe<Scalars['name']>;
  srid?: InputMaybe<Scalars['Int']>;
  type?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type StopsDatabaseGeometryColumnsMaxFields = {
  __typename?: 'stops_database_geometry_columns_max_fields';
  coord_dimension?: Maybe<Scalars['Int']>;
  f_table_catalog?: Maybe<Scalars['String']>;
  srid?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseGeometryColumnsMinFields = {
  __typename?: 'stops_database_geometry_columns_min_fields';
  coord_dimension?: Maybe<Scalars['Int']>;
  f_table_catalog?: Maybe<Scalars['String']>;
  srid?: Maybe<Scalars['Int']>;
  type?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "geometry_columns" */
export type StopsDatabaseGeometryColumnsMutationResponse = {
  __typename?: 'stops_database_geometry_columns_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseGeometryColumns>;
};

/** Ordering options when selecting data from "geometry_columns". */
export type StopsDatabaseGeometryColumnsOrderBy = {
  coord_dimension?: InputMaybe<OrderBy>;
  f_geometry_column?: InputMaybe<OrderBy>;
  f_table_catalog?: InputMaybe<OrderBy>;
  f_table_name?: InputMaybe<OrderBy>;
  f_table_schema?: InputMaybe<OrderBy>;
  srid?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
};

/** select columns of table "geometry_columns" */
export enum StopsDatabaseGeometryColumnsSelectColumn {
  /** column name */
  CoordDimension = 'coord_dimension',
  /** column name */
  FGeometryColumn = 'f_geometry_column',
  /** column name */
  FTableCatalog = 'f_table_catalog',
  /** column name */
  FTableName = 'f_table_name',
  /** column name */
  FTableSchema = 'f_table_schema',
  /** column name */
  Srid = 'srid',
  /** column name */
  Type = 'type',
}

/** input type for updating data in table "geometry_columns" */
export type StopsDatabaseGeometryColumnsSetInput = {
  coord_dimension?: InputMaybe<Scalars['Int']>;
  f_geometry_column?: InputMaybe<Scalars['name']>;
  f_table_catalog?: InputMaybe<Scalars['String']>;
  f_table_name?: InputMaybe<Scalars['name']>;
  f_table_schema?: InputMaybe<Scalars['name']>;
  srid?: InputMaybe<Scalars['Int']>;
  type?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseGeometryColumnsStddevFields = {
  __typename?: 'stops_database_geometry_columns_stddev_fields';
  coord_dimension?: Maybe<Scalars['Float']>;
  srid?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseGeometryColumnsStddevPopFields = {
  __typename?: 'stops_database_geometry_columns_stddev_pop_fields';
  coord_dimension?: Maybe<Scalars['Float']>;
  srid?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseGeometryColumnsStddevSampFields = {
  __typename?: 'stops_database_geometry_columns_stddev_samp_fields';
  coord_dimension?: Maybe<Scalars['Float']>;
  srid?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "geometry_columns" */
export type StopsDatabaseGeometryColumnsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseGeometryColumnsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseGeometryColumnsStreamCursorValueInput = {
  coord_dimension?: InputMaybe<Scalars['Int']>;
  f_geometry_column?: InputMaybe<Scalars['name']>;
  f_table_catalog?: InputMaybe<Scalars['String']>;
  f_table_name?: InputMaybe<Scalars['name']>;
  f_table_schema?: InputMaybe<Scalars['name']>;
  srid?: InputMaybe<Scalars['Int']>;
  type?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseGeometryColumnsSumFields = {
  __typename?: 'stops_database_geometry_columns_sum_fields';
  coord_dimension?: Maybe<Scalars['Int']>;
  srid?: Maybe<Scalars['Int']>;
};

export type StopsDatabaseGeometryColumnsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseGeometryColumnsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseGeometryColumnsSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseGeometryColumnsBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseGeometryColumnsVarPopFields = {
  __typename?: 'stops_database_geometry_columns_var_pop_fields';
  coord_dimension?: Maybe<Scalars['Float']>;
  srid?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseGeometryColumnsVarSampFields = {
  __typename?: 'stops_database_geometry_columns_var_samp_fields';
  coord_dimension?: Maybe<Scalars['Float']>;
  srid?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseGeometryColumnsVarianceFields = {
  __typename?: 'stops_database_geometry_columns_variance_fields';
  coord_dimension?: Maybe<Scalars['Float']>;
  srid?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlaces = {
  __typename?: 'stops_database_group_of_stop_places';
  centroid?: Maybe<Scalars['geometry']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  /** An array relationship */
  group_of_stop_places_alternative_names: Array<StopsDatabaseGroupOfStopPlacesAlternativeNames>;
  /** An aggregate relationship */
  group_of_stop_places_alternative_names_aggregate: StopsDatabaseGroupOfStopPlacesAlternativeNamesAggregate;
  /** An array relationship */
  group_of_stop_places_key_values: Array<StopsDatabaseGroupOfStopPlacesKeyValues>;
  /** An aggregate relationship */
  group_of_stop_places_key_values_aggregate: StopsDatabaseGroupOfStopPlacesKeyValuesAggregate;
  /** An array relationship */
  group_of_stop_places_members: Array<StopsDatabaseGroupOfStopPlacesMembers>;
  /** An aggregate relationship */
  group_of_stop_places_members_aggregate: StopsDatabaseGroupOfStopPlacesMembersAggregate;
  id: Scalars['bigint'];
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  purpose_of_grouping_id?: Maybe<Scalars['bigint']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version: Scalars['bigint'];
  version_comment?: Maybe<Scalars['String']>;
};

/** columns and relationships of "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesGroupOfStopPlacesAlternativeNamesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesAlternativeNamesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>;
  };

/** columns and relationships of "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesGroupOfStopPlacesAlternativeNamesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesAlternativeNamesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>;
  };

/** columns and relationships of "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesGroupOfStopPlacesKeyValuesArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseGroupOfStopPlacesKeyValuesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseGroupOfStopPlacesKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>;
};

/** columns and relationships of "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesGroupOfStopPlacesKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesKeyValuesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>;
  };

/** columns and relationships of "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesGroupOfStopPlacesMembersArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseGroupOfStopPlacesMembersSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseGroupOfStopPlacesMembersOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersBoolExp>;
};

/** columns and relationships of "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesGroupOfStopPlacesMembersAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesMembersSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseGroupOfStopPlacesMembersOrderBy>>;
    where?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersBoolExp>;
  };

/** aggregated selection of "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesAggregate = {
  __typename?: 'stops_database_group_of_stop_places_aggregate';
  aggregate?: Maybe<StopsDatabaseGroupOfStopPlacesAggregateFields>;
  nodes: Array<StopsDatabaseGroupOfStopPlaces>;
};

/** aggregate fields of "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesAggregateFields = {
  __typename?: 'stops_database_group_of_stop_places_aggregate_fields';
  avg?: Maybe<StopsDatabaseGroupOfStopPlacesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseGroupOfStopPlacesMaxFields>;
  min?: Maybe<StopsDatabaseGroupOfStopPlacesMinFields>;
  stddev?: Maybe<StopsDatabaseGroupOfStopPlacesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseGroupOfStopPlacesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseGroupOfStopPlacesStddevSampFields>;
  sum?: Maybe<StopsDatabaseGroupOfStopPlacesSumFields>;
  var_pop?: Maybe<StopsDatabaseGroupOfStopPlacesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseGroupOfStopPlacesVarSampFields>;
  variance?: Maybe<StopsDatabaseGroupOfStopPlacesVarianceFields>;
};

/** aggregate fields of "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseGroupOfStopPlacesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** columns and relationships of "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNames = {
  __typename?: 'stops_database_group_of_stop_places_alternative_names';
  /** An object relationship */
  alternative_name: StopsDatabaseAlternativeName;
  alternative_names_id: Scalars['bigint'];
  group_of_stop_places_id: Scalars['bigint'];
};

/** aggregated selection of "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesAggregate = {
  __typename?: 'stops_database_group_of_stop_places_alternative_names_aggregate';
  aggregate?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesAggregateFields>;
  nodes: Array<StopsDatabaseGroupOfStopPlacesAlternativeNames>;
};

/** aggregate fields of "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesAggregateFields = {
  __typename?: 'stops_database_group_of_stop_places_alternative_names_aggregate_fields';
  avg?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesMaxFields>;
  min?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesMinFields>;
  stddev?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesStddevSampFields>;
  sum?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesSumFields>;
  var_pop?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesVarSampFields>;
  variance?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesVarianceFields>;
};

/** aggregate fields of "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesAggregateFieldsCountArgs =
  {
    columns?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesAlternativeNamesSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
  };

/** order by aggregate values of table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesArrRelInsertInput = {
  data: Array<StopsDatabaseGroupOfStopPlacesAlternativeNamesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesAvgFields = {
  __typename?: 'stops_database_group_of_stop_places_alternative_names_avg_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  group_of_stop_places_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesAvgOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "group_of_stop_places_alternative_names". All fields are combined with a logical 'AND'. */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp = {
  _and?: InputMaybe<
    Array<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>
  >;
  _not?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>;
  _or?: InputMaybe<
    Array<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>
  >;
  alternative_name?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
  alternative_names_id?: InputMaybe<BigintComparisonExp>;
  group_of_stop_places_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "group_of_stop_places_alternative_names" */
export enum StopsDatabaseGroupOfStopPlacesAlternativeNamesConstraint {
  /** unique or primary key constraint on columns "alternative_names_id" */
  GroupOfStopPlacesAlternativeNamesIdKey = 'group_of_stop_places_alternative_names_id_key',
}

/** input type for incrementing numeric columns in table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesIncInput = {
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
  group_of_stop_places_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesInsertInput = {
  alternative_name?: InputMaybe<StopsDatabaseAlternativeNameObjRelInsertInput>;
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
  group_of_stop_places_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesMaxFields = {
  __typename?: 'stops_database_group_of_stop_places_alternative_names_max_fields';
  alternative_names_id?: Maybe<Scalars['bigint']>;
  group_of_stop_places_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesMaxOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesMinFields = {
  __typename?: 'stops_database_group_of_stop_places_alternative_names_min_fields';
  alternative_names_id?: Maybe<Scalars['bigint']>;
  group_of_stop_places_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesMinOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesMutationResponse = {
  __typename?: 'stops_database_group_of_stop_places_alternative_names_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseGroupOfStopPlacesAlternativeNames>;
};

/** on_conflict condition type for table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesOnConflict = {
  constraint: StopsDatabaseGroupOfStopPlacesAlternativeNamesConstraint;
  update_columns?: Array<StopsDatabaseGroupOfStopPlacesAlternativeNamesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>;
};

/** Ordering options when selecting data from "group_of_stop_places_alternative_names". */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesOrderBy = {
  alternative_name?: InputMaybe<StopsDatabaseAlternativeNameOrderBy>;
  alternative_names_id?: InputMaybe<OrderBy>;
  group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** select columns of table "group_of_stop_places_alternative_names" */
export enum StopsDatabaseGroupOfStopPlacesAlternativeNamesSelectColumn {
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
  /** column name */
  GroupOfStopPlacesId = 'group_of_stop_places_id',
}

/** input type for updating data in table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesSetInput = {
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
  group_of_stop_places_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesStddevFields = {
  __typename?: 'stops_database_group_of_stop_places_alternative_names_stddev_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  group_of_stop_places_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesStddevOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesStddevPopFields = {
  __typename?: 'stops_database_group_of_stop_places_alternative_names_stddev_pop_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  group_of_stop_places_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesStddevPopOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesStddevSampFields = {
  __typename?: 'stops_database_group_of_stop_places_alternative_names_stddev_samp_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  group_of_stop_places_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesStddevSampOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseGroupOfStopPlacesAlternativeNamesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesStreamCursorValueInput =
  {
    alternative_names_id?: InputMaybe<Scalars['bigint']>;
    group_of_stop_places_id?: InputMaybe<Scalars['bigint']>;
  };

/** aggregate sum on columns */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesSumFields = {
  __typename?: 'stops_database_group_of_stop_places_alternative_names_sum_fields';
  alternative_names_id?: Maybe<Scalars['bigint']>;
  group_of_stop_places_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesSumOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** update columns of table "group_of_stop_places_alternative_names" */
export enum StopsDatabaseGroupOfStopPlacesAlternativeNamesUpdateColumn {
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
  /** column name */
  GroupOfStopPlacesId = 'group_of_stop_places_id',
}

export type StopsDatabaseGroupOfStopPlacesAlternativeNamesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesVarPopFields = {
  __typename?: 'stops_database_group_of_stop_places_alternative_names_var_pop_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  group_of_stop_places_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesVarPopOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesVarSampFields = {
  __typename?: 'stops_database_group_of_stop_places_alternative_names_var_samp_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  group_of_stop_places_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesVarSampOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesVarianceFields = {
  __typename?: 'stops_database_group_of_stop_places_alternative_names_variance_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  group_of_stop_places_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesVarianceOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** aggregate avg on columns */
export type StopsDatabaseGroupOfStopPlacesAvgFields = {
  __typename?: 'stops_database_group_of_stop_places_avg_fields';
  id?: Maybe<Scalars['Float']>;
  purpose_of_grouping_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "group_of_stop_places". All fields are combined with a logical 'AND'. */
export type StopsDatabaseGroupOfStopPlacesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseGroupOfStopPlacesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseGroupOfStopPlacesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseGroupOfStopPlacesBoolExp>>;
  centroid?: InputMaybe<GeometryComparisonExp>;
  changed?: InputMaybe<TimestampComparisonExp>;
  changed_by?: InputMaybe<StringComparisonExp>;
  created?: InputMaybe<TimestampComparisonExp>;
  description_lang?: InputMaybe<StringComparisonExp>;
  description_value?: InputMaybe<StringComparisonExp>;
  from_date?: InputMaybe<TimestampComparisonExp>;
  group_of_stop_places_alternative_names?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>;
  group_of_stop_places_alternative_names_aggregate?: InputMaybe<GroupOfStopPlacesAlternativeNamesAggregateBoolExp>;
  group_of_stop_places_key_values?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>;
  group_of_stop_places_key_values_aggregate?: InputMaybe<GroupOfStopPlacesKeyValuesAggregateBoolExp>;
  group_of_stop_places_members?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersBoolExp>;
  group_of_stop_places_members_aggregate?: InputMaybe<GroupOfStopPlacesMembersAggregateBoolExp>;
  id?: InputMaybe<BigintComparisonExp>;
  name_lang?: InputMaybe<StringComparisonExp>;
  name_value?: InputMaybe<StringComparisonExp>;
  netex_id?: InputMaybe<StringComparisonExp>;
  private_code_type?: InputMaybe<StringComparisonExp>;
  private_code_value?: InputMaybe<StringComparisonExp>;
  purpose_of_grouping_id?: InputMaybe<BigintComparisonExp>;
  short_name_lang?: InputMaybe<StringComparisonExp>;
  short_name_value?: InputMaybe<StringComparisonExp>;
  to_date?: InputMaybe<TimestampComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
  version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "group_of_stop_places" */
export enum StopsDatabaseGroupOfStopPlacesConstraint {
  /** unique or primary key constraint on columns "id" */
  GroupOfStopPlacesPkey = 'group_of_stop_places_pkey',
}

/** input type for incrementing numeric columns in table "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesIncInput = {
  id?: InputMaybe<Scalars['bigint']>;
  purpose_of_grouping_id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesInsertInput = {
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  group_of_stop_places_alternative_names?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesArrRelInsertInput>;
  group_of_stop_places_key_values?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesArrRelInsertInput>;
  group_of_stop_places_members?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersArrRelInsertInput>;
  id?: InputMaybe<Scalars['bigint']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  purpose_of_grouping_id?: InputMaybe<Scalars['bigint']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValues = {
  __typename?: 'stops_database_group_of_stop_places_key_values';
  group_of_stop_places_id: Scalars['bigint'];
  key_values_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
  /** An object relationship */
  value: StopsDatabaseValue;
};

/** aggregated selection of "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesAggregate = {
  __typename?: 'stops_database_group_of_stop_places_key_values_aggregate';
  aggregate?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesAggregateFields>;
  nodes: Array<StopsDatabaseGroupOfStopPlacesKeyValues>;
};

/** aggregate fields of "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesAggregateFields = {
  __typename?: 'stops_database_group_of_stop_places_key_values_aggregate_fields';
  avg?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesMaxFields>;
  min?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesMinFields>;
  stddev?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesStddevSampFields>;
  sum?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesSumFields>;
  var_pop?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesVarSampFields>;
  variance?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesVarianceFields>;
};

/** aggregate fields of "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<
    Array<StopsDatabaseGroupOfStopPlacesKeyValuesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesArrRelInsertInput = {
  data: Array<StopsDatabaseGroupOfStopPlacesKeyValuesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseGroupOfStopPlacesKeyValuesAvgFields = {
  __typename?: 'stops_database_group_of_stop_places_key_values_avg_fields';
  group_of_stop_places_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesAvgOrderBy = {
  group_of_stop_places_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "group_of_stop_places_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>>;
  group_of_stop_places_id?: InputMaybe<BigintComparisonExp>;
  key_values_id?: InputMaybe<BigintComparisonExp>;
  key_values_key?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "group_of_stop_places_key_values" */
export enum StopsDatabaseGroupOfStopPlacesKeyValuesConstraint {
  /** unique or primary key constraint on columns "key_values_id" */
  GroupOfStopPlacesKeyValuesIdKey = 'group_of_stop_places_key_values_id_key',
  /** unique or primary key constraint on columns "key_values_key", "group_of_stop_places_id" */
  GroupOfStopPlacesKeyValuesPkey = 'group_of_stop_places_key_values_pkey',
}

/** input type for incrementing numeric columns in table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesIncInput = {
  group_of_stop_places_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesInsertInput = {
  group_of_stop_places_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseGroupOfStopPlacesKeyValuesMaxFields = {
  __typename?: 'stops_database_group_of_stop_places_key_values_max_fields';
  group_of_stop_places_id?: Maybe<Scalars['bigint']>;
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesMaxOrderBy = {
  group_of_stop_places_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseGroupOfStopPlacesKeyValuesMinFields = {
  __typename?: 'stops_database_group_of_stop_places_key_values_min_fields';
  group_of_stop_places_id?: Maybe<Scalars['bigint']>;
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesMinOrderBy = {
  group_of_stop_places_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesMutationResponse = {
  __typename?: 'stops_database_group_of_stop_places_key_values_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseGroupOfStopPlacesKeyValues>;
};

/** on_conflict condition type for table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesOnConflict = {
  constraint: StopsDatabaseGroupOfStopPlacesKeyValuesConstraint;
  update_columns?: Array<StopsDatabaseGroupOfStopPlacesKeyValuesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "group_of_stop_places_key_values". */
export type StopsDatabaseGroupOfStopPlacesKeyValuesOrderBy = {
  group_of_stop_places_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: group_of_stop_places_key_values */
export type StopsDatabaseGroupOfStopPlacesKeyValuesPkColumnsInput = {
  group_of_stop_places_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
};

/** select columns of table "group_of_stop_places_key_values" */
export enum StopsDatabaseGroupOfStopPlacesKeyValuesSelectColumn {
  /** column name */
  GroupOfStopPlacesId = 'group_of_stop_places_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
}

/** input type for updating data in table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesSetInput = {
  group_of_stop_places_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseGroupOfStopPlacesKeyValuesStddevFields = {
  __typename?: 'stops_database_group_of_stop_places_key_values_stddev_fields';
  group_of_stop_places_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesStddevOrderBy = {
  group_of_stop_places_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseGroupOfStopPlacesKeyValuesStddevPopFields = {
  __typename?: 'stops_database_group_of_stop_places_key_values_stddev_pop_fields';
  group_of_stop_places_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesStddevPopOrderBy = {
  group_of_stop_places_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseGroupOfStopPlacesKeyValuesStddevSampFields = {
  __typename?: 'stops_database_group_of_stop_places_key_values_stddev_samp_fields';
  group_of_stop_places_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesStddevSampOrderBy = {
  group_of_stop_places_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseGroupOfStopPlacesKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseGroupOfStopPlacesKeyValuesStreamCursorValueInput = {
  group_of_stop_places_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseGroupOfStopPlacesKeyValuesSumFields = {
  __typename?: 'stops_database_group_of_stop_places_key_values_sum_fields';
  group_of_stop_places_id?: Maybe<Scalars['bigint']>;
  key_values_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesSumOrderBy = {
  group_of_stop_places_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** update columns of table "group_of_stop_places_key_values" */
export enum StopsDatabaseGroupOfStopPlacesKeyValuesUpdateColumn {
  /** column name */
  GroupOfStopPlacesId = 'group_of_stop_places_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
}

export type StopsDatabaseGroupOfStopPlacesKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseGroupOfStopPlacesKeyValuesVarPopFields = {
  __typename?: 'stops_database_group_of_stop_places_key_values_var_pop_fields';
  group_of_stop_places_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesVarPopOrderBy = {
  group_of_stop_places_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseGroupOfStopPlacesKeyValuesVarSampFields = {
  __typename?: 'stops_database_group_of_stop_places_key_values_var_samp_fields';
  group_of_stop_places_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesVarSampOrderBy = {
  group_of_stop_places_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseGroupOfStopPlacesKeyValuesVarianceFields = {
  __typename?: 'stops_database_group_of_stop_places_key_values_variance_fields';
  group_of_stop_places_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesVarianceOrderBy = {
  group_of_stop_places_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseGroupOfStopPlacesMaxFields = {
  __typename?: 'stops_database_group_of_stop_places_max_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  purpose_of_grouping_id?: Maybe<Scalars['bigint']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** columns and relationships of "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembers = {
  __typename?: 'stops_database_group_of_stop_places_members';
  group_of_stop_places_id: Scalars['bigint'];
  ref?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['String']>;
};

/** aggregated selection of "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersAggregate = {
  __typename?: 'stops_database_group_of_stop_places_members_aggregate';
  aggregate?: Maybe<StopsDatabaseGroupOfStopPlacesMembersAggregateFields>;
  nodes: Array<StopsDatabaseGroupOfStopPlacesMembers>;
};

/** aggregate fields of "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersAggregateFields = {
  __typename?: 'stops_database_group_of_stop_places_members_aggregate_fields';
  avg?: Maybe<StopsDatabaseGroupOfStopPlacesMembersAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseGroupOfStopPlacesMembersMaxFields>;
  min?: Maybe<StopsDatabaseGroupOfStopPlacesMembersMinFields>;
  stddev?: Maybe<StopsDatabaseGroupOfStopPlacesMembersStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseGroupOfStopPlacesMembersStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseGroupOfStopPlacesMembersStddevSampFields>;
  sum?: Maybe<StopsDatabaseGroupOfStopPlacesMembersSumFields>;
  var_pop?: Maybe<StopsDatabaseGroupOfStopPlacesMembersVarPopFields>;
  var_samp?: Maybe<StopsDatabaseGroupOfStopPlacesMembersVarSampFields>;
  variance?: Maybe<StopsDatabaseGroupOfStopPlacesMembersVarianceFields>;
};

/** aggregate fields of "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersAggregateFieldsCountArgs = {
  columns?: InputMaybe<
    Array<StopsDatabaseGroupOfStopPlacesMembersSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersArrRelInsertInput = {
  data: Array<StopsDatabaseGroupOfStopPlacesMembersInsertInput>;
};

/** aggregate avg on columns */
export type StopsDatabaseGroupOfStopPlacesMembersAvgFields = {
  __typename?: 'stops_database_group_of_stop_places_members_avg_fields';
  group_of_stop_places_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersAvgOrderBy = {
  group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "group_of_stop_places_members". All fields are combined with a logical 'AND'. */
export type StopsDatabaseGroupOfStopPlacesMembersBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseGroupOfStopPlacesMembersBoolExp>>;
  _not?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseGroupOfStopPlacesMembersBoolExp>>;
  group_of_stop_places_id?: InputMaybe<BigintComparisonExp>;
  ref?: InputMaybe<StringComparisonExp>;
  version?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersIncInput = {
  group_of_stop_places_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersInsertInput = {
  group_of_stop_places_id?: InputMaybe<Scalars['bigint']>;
  ref?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type StopsDatabaseGroupOfStopPlacesMembersMaxFields = {
  __typename?: 'stops_database_group_of_stop_places_members_max_fields';
  group_of_stop_places_id?: Maybe<Scalars['bigint']>;
  ref?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersMaxOrderBy = {
  group_of_stop_places_id?: InputMaybe<OrderBy>;
  ref?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseGroupOfStopPlacesMembersMinFields = {
  __typename?: 'stops_database_group_of_stop_places_members_min_fields';
  group_of_stop_places_id?: Maybe<Scalars['bigint']>;
  ref?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersMinOrderBy = {
  group_of_stop_places_id?: InputMaybe<OrderBy>;
  ref?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersMutationResponse = {
  __typename?: 'stops_database_group_of_stop_places_members_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseGroupOfStopPlacesMembers>;
};

/** Ordering options when selecting data from "group_of_stop_places_members". */
export type StopsDatabaseGroupOfStopPlacesMembersOrderBy = {
  group_of_stop_places_id?: InputMaybe<OrderBy>;
  ref?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
};

/** select columns of table "group_of_stop_places_members" */
export enum StopsDatabaseGroupOfStopPlacesMembersSelectColumn {
  /** column name */
  GroupOfStopPlacesId = 'group_of_stop_places_id',
  /** column name */
  Ref = 'ref',
  /** column name */
  Version = 'version',
}

/** input type for updating data in table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersSetInput = {
  group_of_stop_places_id?: InputMaybe<Scalars['bigint']>;
  ref?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseGroupOfStopPlacesMembersStddevFields = {
  __typename?: 'stops_database_group_of_stop_places_members_stddev_fields';
  group_of_stop_places_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersStddevOrderBy = {
  group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseGroupOfStopPlacesMembersStddevPopFields = {
  __typename?: 'stops_database_group_of_stop_places_members_stddev_pop_fields';
  group_of_stop_places_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersStddevPopOrderBy = {
  group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseGroupOfStopPlacesMembersStddevSampFields = {
  __typename?: 'stops_database_group_of_stop_places_members_stddev_samp_fields';
  group_of_stop_places_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersStddevSampOrderBy = {
  group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseGroupOfStopPlacesMembersStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseGroupOfStopPlacesMembersStreamCursorValueInput = {
  group_of_stop_places_id?: InputMaybe<Scalars['bigint']>;
  ref?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseGroupOfStopPlacesMembersSumFields = {
  __typename?: 'stops_database_group_of_stop_places_members_sum_fields';
  group_of_stop_places_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersSumOrderBy = {
  group_of_stop_places_id?: InputMaybe<OrderBy>;
};

export type StopsDatabaseGroupOfStopPlacesMembersUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseGroupOfStopPlacesMembersBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseGroupOfStopPlacesMembersVarPopFields = {
  __typename?: 'stops_database_group_of_stop_places_members_var_pop_fields';
  group_of_stop_places_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersVarPopOrderBy = {
  group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseGroupOfStopPlacesMembersVarSampFields = {
  __typename?: 'stops_database_group_of_stop_places_members_var_samp_fields';
  group_of_stop_places_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersVarSampOrderBy = {
  group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseGroupOfStopPlacesMembersVarianceFields = {
  __typename?: 'stops_database_group_of_stop_places_members_variance_fields';
  group_of_stop_places_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersVarianceOrderBy = {
  group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseGroupOfStopPlacesMinFields = {
  __typename?: 'stops_database_group_of_stop_places_min_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  purpose_of_grouping_id?: Maybe<Scalars['bigint']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesMutationResponse = {
  __typename?: 'stops_database_group_of_stop_places_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseGroupOfStopPlaces>;
};

/** on_conflict condition type for table "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesOnConflict = {
  constraint: StopsDatabaseGroupOfStopPlacesConstraint;
  update_columns?: Array<StopsDatabaseGroupOfStopPlacesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesBoolExp>;
};

/** Ordering options when selecting data from "group_of_stop_places". */
export type StopsDatabaseGroupOfStopPlacesOrderBy = {
  centroid?: InputMaybe<OrderBy>;
  changed?: InputMaybe<OrderBy>;
  changed_by?: InputMaybe<OrderBy>;
  created?: InputMaybe<OrderBy>;
  description_lang?: InputMaybe<OrderBy>;
  description_value?: InputMaybe<OrderBy>;
  from_date?: InputMaybe<OrderBy>;
  group_of_stop_places_alternative_names_aggregate?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesAggregateOrderBy>;
  group_of_stop_places_key_values_aggregate?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesAggregateOrderBy>;
  group_of_stop_places_members_aggregate?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersAggregateOrderBy>;
  id?: InputMaybe<OrderBy>;
  name_lang?: InputMaybe<OrderBy>;
  name_value?: InputMaybe<OrderBy>;
  netex_id?: InputMaybe<OrderBy>;
  private_code_type?: InputMaybe<OrderBy>;
  private_code_value?: InputMaybe<OrderBy>;
  purpose_of_grouping_id?: InputMaybe<OrderBy>;
  short_name_lang?: InputMaybe<OrderBy>;
  short_name_value?: InputMaybe<OrderBy>;
  to_date?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
  version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: group_of_stop_places */
export type StopsDatabaseGroupOfStopPlacesPkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "group_of_stop_places" */
export enum StopsDatabaseGroupOfStopPlacesSelectColumn {
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  PurposeOfGroupingId = 'purpose_of_grouping_id',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

/** input type for updating data in table "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesSetInput = {
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  purpose_of_grouping_id?: InputMaybe<Scalars['bigint']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseGroupOfStopPlacesStddevFields = {
  __typename?: 'stops_database_group_of_stop_places_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  purpose_of_grouping_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseGroupOfStopPlacesStddevPopFields = {
  __typename?: 'stops_database_group_of_stop_places_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  purpose_of_grouping_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseGroupOfStopPlacesStddevSampFields = {
  __typename?: 'stops_database_group_of_stop_places_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  purpose_of_grouping_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseGroupOfStopPlacesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseGroupOfStopPlacesStreamCursorValueInput = {
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  purpose_of_grouping_id?: InputMaybe<Scalars['bigint']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseGroupOfStopPlacesSumFields = {
  __typename?: 'stops_database_group_of_stop_places_sum_fields';
  id?: Maybe<Scalars['bigint']>;
  purpose_of_grouping_id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['bigint']>;
};

/** update columns of table "group_of_stop_places" */
export enum StopsDatabaseGroupOfStopPlacesUpdateColumn {
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  PurposeOfGroupingId = 'purpose_of_grouping_id',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

export type StopsDatabaseGroupOfStopPlacesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseGroupOfStopPlacesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseGroupOfStopPlacesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseGroupOfStopPlacesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseGroupOfStopPlacesVarPopFields = {
  __typename?: 'stops_database_group_of_stop_places_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  purpose_of_grouping_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseGroupOfStopPlacesVarSampFields = {
  __typename?: 'stops_database_group_of_stop_places_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  purpose_of_grouping_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseGroupOfStopPlacesVarianceFields = {
  __typename?: 'stops_database_group_of_stop_places_variance_fields';
  id?: Maybe<Scalars['Float']>;
  purpose_of_grouping_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZones = {
  __typename?: 'stops_database_group_of_tariff_zones';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  /** An array relationship */
  group_of_tariff_zones_key_values: Array<StopsDatabaseGroupOfTariffZonesKeyValues>;
  /** An aggregate relationship */
  group_of_tariff_zones_key_values_aggregate: StopsDatabaseGroupOfTariffZonesKeyValuesAggregate;
  /** An array relationship */
  group_of_tariff_zones_members: Array<StopsDatabaseGroupOfTariffZonesMembers>;
  /** An aggregate relationship */
  group_of_tariff_zones_members_aggregate: StopsDatabaseGroupOfTariffZonesMembersAggregate;
  id: Scalars['bigint'];
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  purpose_of_grouping_ref?: Maybe<Scalars['String']>;
  purpose_of_grouping_ref_version?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version: Scalars['bigint'];
  version_comment?: Maybe<Scalars['String']>;
};

/** columns and relationships of "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesGroupOfTariffZonesKeyValuesArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseGroupOfTariffZonesKeyValuesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseGroupOfTariffZonesKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>;
};

/** columns and relationships of "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesGroupOfTariffZonesKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfTariffZonesKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseGroupOfTariffZonesKeyValuesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>;
  };

/** columns and relationships of "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesGroupOfTariffZonesMembersArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseGroupOfTariffZonesMembersSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseGroupOfTariffZonesMembersOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersBoolExp>;
};

/** columns and relationships of "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesGroupOfTariffZonesMembersAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfTariffZonesMembersSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseGroupOfTariffZonesMembersOrderBy>>;
    where?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersBoolExp>;
  };

/** aggregated selection of "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesAggregate = {
  __typename?: 'stops_database_group_of_tariff_zones_aggregate';
  aggregate?: Maybe<StopsDatabaseGroupOfTariffZonesAggregateFields>;
  nodes: Array<StopsDatabaseGroupOfTariffZones>;
};

/** aggregate fields of "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesAggregateFields = {
  __typename?: 'stops_database_group_of_tariff_zones_aggregate_fields';
  avg?: Maybe<StopsDatabaseGroupOfTariffZonesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseGroupOfTariffZonesMaxFields>;
  min?: Maybe<StopsDatabaseGroupOfTariffZonesMinFields>;
  stddev?: Maybe<StopsDatabaseGroupOfTariffZonesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseGroupOfTariffZonesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseGroupOfTariffZonesStddevSampFields>;
  sum?: Maybe<StopsDatabaseGroupOfTariffZonesSumFields>;
  var_pop?: Maybe<StopsDatabaseGroupOfTariffZonesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseGroupOfTariffZonesVarSampFields>;
  variance?: Maybe<StopsDatabaseGroupOfTariffZonesVarianceFields>;
};

/** aggregate fields of "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseGroupOfTariffZonesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseGroupOfTariffZonesAvgFields = {
  __typename?: 'stops_database_group_of_tariff_zones_avg_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "group_of_tariff_zones". All fields are combined with a logical 'AND'. */
export type StopsDatabaseGroupOfTariffZonesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseGroupOfTariffZonesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseGroupOfTariffZonesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseGroupOfTariffZonesBoolExp>>;
  changed?: InputMaybe<TimestampComparisonExp>;
  changed_by?: InputMaybe<StringComparisonExp>;
  created?: InputMaybe<TimestampComparisonExp>;
  description_lang?: InputMaybe<StringComparisonExp>;
  description_value?: InputMaybe<StringComparisonExp>;
  from_date?: InputMaybe<TimestampComparisonExp>;
  group_of_tariff_zones_key_values?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>;
  group_of_tariff_zones_key_values_aggregate?: InputMaybe<GroupOfTariffZonesKeyValuesAggregateBoolExp>;
  group_of_tariff_zones_members?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersBoolExp>;
  group_of_tariff_zones_members_aggregate?: InputMaybe<GroupOfTariffZonesMembersAggregateBoolExp>;
  id?: InputMaybe<BigintComparisonExp>;
  name_lang?: InputMaybe<StringComparisonExp>;
  name_value?: InputMaybe<StringComparisonExp>;
  netex_id?: InputMaybe<StringComparisonExp>;
  private_code_type?: InputMaybe<StringComparisonExp>;
  private_code_value?: InputMaybe<StringComparisonExp>;
  purpose_of_grouping_ref?: InputMaybe<StringComparisonExp>;
  purpose_of_grouping_ref_version?: InputMaybe<StringComparisonExp>;
  to_date?: InputMaybe<TimestampComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
  version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "group_of_tariff_zones" */
export enum StopsDatabaseGroupOfTariffZonesConstraint {
  /** unique or primary key constraint on columns "id" */
  GroupOfTariffZonesPkey = 'group_of_tariff_zones_pkey',
}

/** input type for incrementing numeric columns in table "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesIncInput = {
  id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesInsertInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  group_of_tariff_zones_key_values?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesArrRelInsertInput>;
  group_of_tariff_zones_members?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersArrRelInsertInput>;
  id?: InputMaybe<Scalars['bigint']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  purpose_of_grouping_ref?: InputMaybe<Scalars['String']>;
  purpose_of_grouping_ref_version?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValues = {
  __typename?: 'stops_database_group_of_tariff_zones_key_values';
  group_of_tariff_zones_id: Scalars['bigint'];
  key_values_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
  /** An object relationship */
  value: StopsDatabaseValue;
};

/** aggregated selection of "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesAggregate = {
  __typename?: 'stops_database_group_of_tariff_zones_key_values_aggregate';
  aggregate?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesAggregateFields>;
  nodes: Array<StopsDatabaseGroupOfTariffZonesKeyValues>;
};

/** aggregate fields of "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesAggregateFields = {
  __typename?: 'stops_database_group_of_tariff_zones_key_values_aggregate_fields';
  avg?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesMaxFields>;
  min?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesMinFields>;
  stddev?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesStddevSampFields>;
  sum?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesSumFields>;
  var_pop?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesVarSampFields>;
  variance?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesVarianceFields>;
};

/** aggregate fields of "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<
    Array<StopsDatabaseGroupOfTariffZonesKeyValuesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesArrRelInsertInput = {
  data: Array<StopsDatabaseGroupOfTariffZonesKeyValuesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseGroupOfTariffZonesKeyValuesAvgFields = {
  __typename?: 'stops_database_group_of_tariff_zones_key_values_avg_fields';
  group_of_tariff_zones_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesAvgOrderBy = {
  group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "group_of_tariff_zones_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>>;
  group_of_tariff_zones_id?: InputMaybe<BigintComparisonExp>;
  key_values_id?: InputMaybe<BigintComparisonExp>;
  key_values_key?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "group_of_tariff_zones_key_values" */
export enum StopsDatabaseGroupOfTariffZonesKeyValuesConstraint {
  /** unique or primary key constraint on columns "group_of_tariff_zones_id", "key_values_key" */
  GroupOfTariffZonesKeyValuesPkey = 'group_of_tariff_zones_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkPfy12mpgyt1qevehecnwh5vq2 = 'uk_pfy12mpgyt1qevehecnwh5vq2',
}

/** input type for incrementing numeric columns in table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesIncInput = {
  group_of_tariff_zones_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesInsertInput = {
  group_of_tariff_zones_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseGroupOfTariffZonesKeyValuesMaxFields = {
  __typename?: 'stops_database_group_of_tariff_zones_key_values_max_fields';
  group_of_tariff_zones_id?: Maybe<Scalars['bigint']>;
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesMaxOrderBy = {
  group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseGroupOfTariffZonesKeyValuesMinFields = {
  __typename?: 'stops_database_group_of_tariff_zones_key_values_min_fields';
  group_of_tariff_zones_id?: Maybe<Scalars['bigint']>;
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesMinOrderBy = {
  group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesMutationResponse = {
  __typename?: 'stops_database_group_of_tariff_zones_key_values_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseGroupOfTariffZonesKeyValues>;
};

/** on_conflict condition type for table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesOnConflict = {
  constraint: StopsDatabaseGroupOfTariffZonesKeyValuesConstraint;
  update_columns?: Array<StopsDatabaseGroupOfTariffZonesKeyValuesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "group_of_tariff_zones_key_values". */
export type StopsDatabaseGroupOfTariffZonesKeyValuesOrderBy = {
  group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: group_of_tariff_zones_key_values */
export type StopsDatabaseGroupOfTariffZonesKeyValuesPkColumnsInput = {
  group_of_tariff_zones_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
};

/** select columns of table "group_of_tariff_zones_key_values" */
export enum StopsDatabaseGroupOfTariffZonesKeyValuesSelectColumn {
  /** column name */
  GroupOfTariffZonesId = 'group_of_tariff_zones_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
}

/** input type for updating data in table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesSetInput = {
  group_of_tariff_zones_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseGroupOfTariffZonesKeyValuesStddevFields = {
  __typename?: 'stops_database_group_of_tariff_zones_key_values_stddev_fields';
  group_of_tariff_zones_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesStddevOrderBy = {
  group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseGroupOfTariffZonesKeyValuesStddevPopFields = {
  __typename?: 'stops_database_group_of_tariff_zones_key_values_stddev_pop_fields';
  group_of_tariff_zones_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesStddevPopOrderBy = {
  group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseGroupOfTariffZonesKeyValuesStddevSampFields = {
  __typename?: 'stops_database_group_of_tariff_zones_key_values_stddev_samp_fields';
  group_of_tariff_zones_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesStddevSampOrderBy = {
  group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseGroupOfTariffZonesKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseGroupOfTariffZonesKeyValuesStreamCursorValueInput = {
  group_of_tariff_zones_id?: InputMaybe<Scalars['bigint']>;
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseGroupOfTariffZonesKeyValuesSumFields = {
  __typename?: 'stops_database_group_of_tariff_zones_key_values_sum_fields';
  group_of_tariff_zones_id?: Maybe<Scalars['bigint']>;
  key_values_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesSumOrderBy = {
  group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** update columns of table "group_of_tariff_zones_key_values" */
export enum StopsDatabaseGroupOfTariffZonesKeyValuesUpdateColumn {
  /** column name */
  GroupOfTariffZonesId = 'group_of_tariff_zones_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
}

export type StopsDatabaseGroupOfTariffZonesKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseGroupOfTariffZonesKeyValuesVarPopFields = {
  __typename?: 'stops_database_group_of_tariff_zones_key_values_var_pop_fields';
  group_of_tariff_zones_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesVarPopOrderBy = {
  group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseGroupOfTariffZonesKeyValuesVarSampFields = {
  __typename?: 'stops_database_group_of_tariff_zones_key_values_var_samp_fields';
  group_of_tariff_zones_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesVarSampOrderBy = {
  group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseGroupOfTariffZonesKeyValuesVarianceFields = {
  __typename?: 'stops_database_group_of_tariff_zones_key_values_variance_fields';
  group_of_tariff_zones_id?: Maybe<Scalars['Float']>;
  key_values_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesVarianceOrderBy = {
  group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseGroupOfTariffZonesMaxFields = {
  __typename?: 'stops_database_group_of_tariff_zones_max_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  purpose_of_grouping_ref?: Maybe<Scalars['String']>;
  purpose_of_grouping_ref_version?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** columns and relationships of "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembers = {
  __typename?: 'stops_database_group_of_tariff_zones_members';
  /** An object relationship */
  group_of_tariff_zone: StopsDatabaseGroupOfTariffZones;
  group_of_tariff_zones_id: Scalars['bigint'];
  ref: Scalars['String'];
  version?: Maybe<Scalars['String']>;
};

/** aggregated selection of "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersAggregate = {
  __typename?: 'stops_database_group_of_tariff_zones_members_aggregate';
  aggregate?: Maybe<StopsDatabaseGroupOfTariffZonesMembersAggregateFields>;
  nodes: Array<StopsDatabaseGroupOfTariffZonesMembers>;
};

/** aggregate fields of "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersAggregateFields = {
  __typename?: 'stops_database_group_of_tariff_zones_members_aggregate_fields';
  avg?: Maybe<StopsDatabaseGroupOfTariffZonesMembersAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseGroupOfTariffZonesMembersMaxFields>;
  min?: Maybe<StopsDatabaseGroupOfTariffZonesMembersMinFields>;
  stddev?: Maybe<StopsDatabaseGroupOfTariffZonesMembersStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseGroupOfTariffZonesMembersStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseGroupOfTariffZonesMembersStddevSampFields>;
  sum?: Maybe<StopsDatabaseGroupOfTariffZonesMembersSumFields>;
  var_pop?: Maybe<StopsDatabaseGroupOfTariffZonesMembersVarPopFields>;
  var_samp?: Maybe<StopsDatabaseGroupOfTariffZonesMembersVarSampFields>;
  variance?: Maybe<StopsDatabaseGroupOfTariffZonesMembersVarianceFields>;
};

/** aggregate fields of "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersAggregateFieldsCountArgs = {
  columns?: InputMaybe<
    Array<StopsDatabaseGroupOfTariffZonesMembersSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersArrRelInsertInput = {
  data: Array<StopsDatabaseGroupOfTariffZonesMembersInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseGroupOfTariffZonesMembersAvgFields = {
  __typename?: 'stops_database_group_of_tariff_zones_members_avg_fields';
  group_of_tariff_zones_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersAvgOrderBy = {
  group_of_tariff_zones_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "group_of_tariff_zones_members". All fields are combined with a logical 'AND'. */
export type StopsDatabaseGroupOfTariffZonesMembersBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseGroupOfTariffZonesMembersBoolExp>>;
  _not?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseGroupOfTariffZonesMembersBoolExp>>;
  group_of_tariff_zone?: InputMaybe<StopsDatabaseGroupOfTariffZonesBoolExp>;
  group_of_tariff_zones_id?: InputMaybe<BigintComparisonExp>;
  ref?: InputMaybe<StringComparisonExp>;
  version?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "group_of_tariff_zones_members" */
export enum StopsDatabaseGroupOfTariffZonesMembersConstraint {
  /** unique or primary key constraint on columns "group_of_tariff_zones_id", "ref" */
  GroupOfTariffZonesMembersPkey = 'group_of_tariff_zones_members_pkey',
}

/** input type for incrementing numeric columns in table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersIncInput = {
  group_of_tariff_zones_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersInsertInput = {
  group_of_tariff_zone?: InputMaybe<StopsDatabaseGroupOfTariffZonesObjRelInsertInput>;
  group_of_tariff_zones_id?: InputMaybe<Scalars['bigint']>;
  ref?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type StopsDatabaseGroupOfTariffZonesMembersMaxFields = {
  __typename?: 'stops_database_group_of_tariff_zones_members_max_fields';
  group_of_tariff_zones_id?: Maybe<Scalars['bigint']>;
  ref?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersMaxOrderBy = {
  group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  ref?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseGroupOfTariffZonesMembersMinFields = {
  __typename?: 'stops_database_group_of_tariff_zones_members_min_fields';
  group_of_tariff_zones_id?: Maybe<Scalars['bigint']>;
  ref?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersMinOrderBy = {
  group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  ref?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersMutationResponse = {
  __typename?: 'stops_database_group_of_tariff_zones_members_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseGroupOfTariffZonesMembers>;
};

/** on_conflict condition type for table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersOnConflict = {
  constraint: StopsDatabaseGroupOfTariffZonesMembersConstraint;
  update_columns?: Array<StopsDatabaseGroupOfTariffZonesMembersUpdateColumn>;
  where?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersBoolExp>;
};

/** Ordering options when selecting data from "group_of_tariff_zones_members". */
export type StopsDatabaseGroupOfTariffZonesMembersOrderBy = {
  group_of_tariff_zone?: InputMaybe<StopsDatabaseGroupOfTariffZonesOrderBy>;
  group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  ref?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: group_of_tariff_zones_members */
export type StopsDatabaseGroupOfTariffZonesMembersPkColumnsInput = {
  group_of_tariff_zones_id: Scalars['bigint'];
  ref: Scalars['String'];
};

/** select columns of table "group_of_tariff_zones_members" */
export enum StopsDatabaseGroupOfTariffZonesMembersSelectColumn {
  /** column name */
  GroupOfTariffZonesId = 'group_of_tariff_zones_id',
  /** column name */
  Ref = 'ref',
  /** column name */
  Version = 'version',
}

/** input type for updating data in table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersSetInput = {
  group_of_tariff_zones_id?: InputMaybe<Scalars['bigint']>;
  ref?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseGroupOfTariffZonesMembersStddevFields = {
  __typename?: 'stops_database_group_of_tariff_zones_members_stddev_fields';
  group_of_tariff_zones_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersStddevOrderBy = {
  group_of_tariff_zones_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseGroupOfTariffZonesMembersStddevPopFields = {
  __typename?: 'stops_database_group_of_tariff_zones_members_stddev_pop_fields';
  group_of_tariff_zones_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersStddevPopOrderBy = {
  group_of_tariff_zones_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseGroupOfTariffZonesMembersStddevSampFields = {
  __typename?: 'stops_database_group_of_tariff_zones_members_stddev_samp_fields';
  group_of_tariff_zones_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersStddevSampOrderBy = {
  group_of_tariff_zones_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseGroupOfTariffZonesMembersStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseGroupOfTariffZonesMembersStreamCursorValueInput = {
  group_of_tariff_zones_id?: InputMaybe<Scalars['bigint']>;
  ref?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseGroupOfTariffZonesMembersSumFields = {
  __typename?: 'stops_database_group_of_tariff_zones_members_sum_fields';
  group_of_tariff_zones_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersSumOrderBy = {
  group_of_tariff_zones_id?: InputMaybe<OrderBy>;
};

/** update columns of table "group_of_tariff_zones_members" */
export enum StopsDatabaseGroupOfTariffZonesMembersUpdateColumn {
  /** column name */
  GroupOfTariffZonesId = 'group_of_tariff_zones_id',
  /** column name */
  Ref = 'ref',
  /** column name */
  Version = 'version',
}

export type StopsDatabaseGroupOfTariffZonesMembersUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseGroupOfTariffZonesMembersBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseGroupOfTariffZonesMembersVarPopFields = {
  __typename?: 'stops_database_group_of_tariff_zones_members_var_pop_fields';
  group_of_tariff_zones_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersVarPopOrderBy = {
  group_of_tariff_zones_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseGroupOfTariffZonesMembersVarSampFields = {
  __typename?: 'stops_database_group_of_tariff_zones_members_var_samp_fields';
  group_of_tariff_zones_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersVarSampOrderBy = {
  group_of_tariff_zones_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseGroupOfTariffZonesMembersVarianceFields = {
  __typename?: 'stops_database_group_of_tariff_zones_members_variance_fields';
  group_of_tariff_zones_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersVarianceOrderBy = {
  group_of_tariff_zones_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseGroupOfTariffZonesMinFields = {
  __typename?: 'stops_database_group_of_tariff_zones_min_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  purpose_of_grouping_ref?: Maybe<Scalars['String']>;
  purpose_of_grouping_ref_version?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesMutationResponse = {
  __typename?: 'stops_database_group_of_tariff_zones_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseGroupOfTariffZones>;
};

/** input type for inserting object relation for remote table "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesObjRelInsertInput = {
  data: StopsDatabaseGroupOfTariffZonesInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseGroupOfTariffZonesOnConflict>;
};

/** on_conflict condition type for table "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesOnConflict = {
  constraint: StopsDatabaseGroupOfTariffZonesConstraint;
  update_columns?: Array<StopsDatabaseGroupOfTariffZonesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseGroupOfTariffZonesBoolExp>;
};

/** Ordering options when selecting data from "group_of_tariff_zones". */
export type StopsDatabaseGroupOfTariffZonesOrderBy = {
  changed?: InputMaybe<OrderBy>;
  changed_by?: InputMaybe<OrderBy>;
  created?: InputMaybe<OrderBy>;
  description_lang?: InputMaybe<OrderBy>;
  description_value?: InputMaybe<OrderBy>;
  from_date?: InputMaybe<OrderBy>;
  group_of_tariff_zones_key_values_aggregate?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesAggregateOrderBy>;
  group_of_tariff_zones_members_aggregate?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersAggregateOrderBy>;
  id?: InputMaybe<OrderBy>;
  name_lang?: InputMaybe<OrderBy>;
  name_value?: InputMaybe<OrderBy>;
  netex_id?: InputMaybe<OrderBy>;
  private_code_type?: InputMaybe<OrderBy>;
  private_code_value?: InputMaybe<OrderBy>;
  purpose_of_grouping_ref?: InputMaybe<OrderBy>;
  purpose_of_grouping_ref_version?: InputMaybe<OrderBy>;
  to_date?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
  version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: group_of_tariff_zones */
export type StopsDatabaseGroupOfTariffZonesPkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "group_of_tariff_zones" */
export enum StopsDatabaseGroupOfTariffZonesSelectColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  PurposeOfGroupingRef = 'purpose_of_grouping_ref',
  /** column name */
  PurposeOfGroupingRefVersion = 'purpose_of_grouping_ref_version',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

/** input type for updating data in table "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesSetInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  purpose_of_grouping_ref?: InputMaybe<Scalars['String']>;
  purpose_of_grouping_ref_version?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseGroupOfTariffZonesStddevFields = {
  __typename?: 'stops_database_group_of_tariff_zones_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseGroupOfTariffZonesStddevPopFields = {
  __typename?: 'stops_database_group_of_tariff_zones_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseGroupOfTariffZonesStddevSampFields = {
  __typename?: 'stops_database_group_of_tariff_zones_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseGroupOfTariffZonesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseGroupOfTariffZonesStreamCursorValueInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  purpose_of_grouping_ref?: InputMaybe<Scalars['String']>;
  purpose_of_grouping_ref_version?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseGroupOfTariffZonesSumFields = {
  __typename?: 'stops_database_group_of_tariff_zones_sum_fields';
  id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['bigint']>;
};

/** update columns of table "group_of_tariff_zones" */
export enum StopsDatabaseGroupOfTariffZonesUpdateColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  PurposeOfGroupingRef = 'purpose_of_grouping_ref',
  /** column name */
  PurposeOfGroupingRefVersion = 'purpose_of_grouping_ref_version',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

export type StopsDatabaseGroupOfTariffZonesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseGroupOfTariffZonesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseGroupOfTariffZonesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseGroupOfTariffZonesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseGroupOfTariffZonesVarPopFields = {
  __typename?: 'stops_database_group_of_tariff_zones_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseGroupOfTariffZonesVarSampFields = {
  __typename?: 'stops_database_group_of_tariff_zones_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseGroupOfTariffZonesVarianceFields = {
  __typename?: 'stops_database_group_of_tariff_zones_variance_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "id_generator" */
export type StopsDatabaseIdGenerator = {
  __typename?: 'stops_database_id_generator';
  id_value?: Maybe<Scalars['bigint']>;
  table_name?: Maybe<Scalars['String']>;
};

/** aggregated selection of "id_generator" */
export type StopsDatabaseIdGeneratorAggregate = {
  __typename?: 'stops_database_id_generator_aggregate';
  aggregate?: Maybe<StopsDatabaseIdGeneratorAggregateFields>;
  nodes: Array<StopsDatabaseIdGenerator>;
};

/** aggregate fields of "id_generator" */
export type StopsDatabaseIdGeneratorAggregateFields = {
  __typename?: 'stops_database_id_generator_aggregate_fields';
  avg?: Maybe<StopsDatabaseIdGeneratorAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseIdGeneratorMaxFields>;
  min?: Maybe<StopsDatabaseIdGeneratorMinFields>;
  stddev?: Maybe<StopsDatabaseIdGeneratorStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseIdGeneratorStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseIdGeneratorStddevSampFields>;
  sum?: Maybe<StopsDatabaseIdGeneratorSumFields>;
  var_pop?: Maybe<StopsDatabaseIdGeneratorVarPopFields>;
  var_samp?: Maybe<StopsDatabaseIdGeneratorVarSampFields>;
  variance?: Maybe<StopsDatabaseIdGeneratorVarianceFields>;
};

/** aggregate fields of "id_generator" */
export type StopsDatabaseIdGeneratorAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseIdGeneratorSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseIdGeneratorAvgFields = {
  __typename?: 'stops_database_id_generator_avg_fields';
  id_value?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "id_generator". All fields are combined with a logical 'AND'. */
export type StopsDatabaseIdGeneratorBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseIdGeneratorBoolExp>>;
  _not?: InputMaybe<StopsDatabaseIdGeneratorBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseIdGeneratorBoolExp>>;
  id_value?: InputMaybe<BigintComparisonExp>;
  table_name?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "id_generator" */
export enum StopsDatabaseIdGeneratorConstraint {
  /** unique or primary key constraint on columns "id_value", "table_name" */
  IdConstraint = 'id_constraint',
}

/** input type for incrementing numeric columns in table "id_generator" */
export type StopsDatabaseIdGeneratorIncInput = {
  id_value?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "id_generator" */
export type StopsDatabaseIdGeneratorInsertInput = {
  id_value?: InputMaybe<Scalars['bigint']>;
  table_name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type StopsDatabaseIdGeneratorMaxFields = {
  __typename?: 'stops_database_id_generator_max_fields';
  id_value?: Maybe<Scalars['bigint']>;
  table_name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseIdGeneratorMinFields = {
  __typename?: 'stops_database_id_generator_min_fields';
  id_value?: Maybe<Scalars['bigint']>;
  table_name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "id_generator" */
export type StopsDatabaseIdGeneratorMutationResponse = {
  __typename?: 'stops_database_id_generator_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseIdGenerator>;
};

/** on_conflict condition type for table "id_generator" */
export type StopsDatabaseIdGeneratorOnConflict = {
  constraint: StopsDatabaseIdGeneratorConstraint;
  update_columns?: Array<StopsDatabaseIdGeneratorUpdateColumn>;
  where?: InputMaybe<StopsDatabaseIdGeneratorBoolExp>;
};

/** Ordering options when selecting data from "id_generator". */
export type StopsDatabaseIdGeneratorOrderBy = {
  id_value?: InputMaybe<OrderBy>;
  table_name?: InputMaybe<OrderBy>;
};

/** select columns of table "id_generator" */
export enum StopsDatabaseIdGeneratorSelectColumn {
  /** column name */
  IdValue = 'id_value',
  /** column name */
  TableName = 'table_name',
}

/** input type for updating data in table "id_generator" */
export type StopsDatabaseIdGeneratorSetInput = {
  id_value?: InputMaybe<Scalars['bigint']>;
  table_name?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseIdGeneratorStddevFields = {
  __typename?: 'stops_database_id_generator_stddev_fields';
  id_value?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseIdGeneratorStddevPopFields = {
  __typename?: 'stops_database_id_generator_stddev_pop_fields';
  id_value?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseIdGeneratorStddevSampFields = {
  __typename?: 'stops_database_id_generator_stddev_samp_fields';
  id_value?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "id_generator" */
export type StopsDatabaseIdGeneratorStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseIdGeneratorStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseIdGeneratorStreamCursorValueInput = {
  id_value?: InputMaybe<Scalars['bigint']>;
  table_name?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseIdGeneratorSumFields = {
  __typename?: 'stops_database_id_generator_sum_fields';
  id_value?: Maybe<Scalars['bigint']>;
};

/** update columns of table "id_generator" */
export enum StopsDatabaseIdGeneratorUpdateColumn {
  /** column name */
  IdValue = 'id_value',
  /** column name */
  TableName = 'table_name',
}

export type StopsDatabaseIdGeneratorUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseIdGeneratorIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseIdGeneratorSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseIdGeneratorBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseIdGeneratorVarPopFields = {
  __typename?: 'stops_database_id_generator_var_pop_fields';
  id_value?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseIdGeneratorVarSampFields = {
  __typename?: 'stops_database_id_generator_var_samp_fields';
  id_value?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseIdGeneratorVarianceFields = {
  __typename?: 'stops_database_id_generator_variance_fields';
  id_value?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "installed_equipment" */
export type StopsDatabaseInstalledEquipment = {
  __typename?: 'stops_database_installed_equipment';
  equipment_id: Scalars['Int'];
  id: Scalars['String'];
  item_type?: Maybe<Scalars['String']>;
};

/** aggregated selection of "installed_equipment" */
export type StopsDatabaseInstalledEquipmentAggregate = {
  __typename?: 'stops_database_installed_equipment_aggregate';
  aggregate?: Maybe<StopsDatabaseInstalledEquipmentAggregateFields>;
  nodes: Array<StopsDatabaseInstalledEquipment>;
};

/** aggregate fields of "installed_equipment" */
export type StopsDatabaseInstalledEquipmentAggregateFields = {
  __typename?: 'stops_database_installed_equipment_aggregate_fields';
  avg?: Maybe<StopsDatabaseInstalledEquipmentAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseInstalledEquipmentMaxFields>;
  min?: Maybe<StopsDatabaseInstalledEquipmentMinFields>;
  stddev?: Maybe<StopsDatabaseInstalledEquipmentStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseInstalledEquipmentStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseInstalledEquipmentStddevSampFields>;
  sum?: Maybe<StopsDatabaseInstalledEquipmentSumFields>;
  var_pop?: Maybe<StopsDatabaseInstalledEquipmentVarPopFields>;
  var_samp?: Maybe<StopsDatabaseInstalledEquipmentVarSampFields>;
  variance?: Maybe<StopsDatabaseInstalledEquipmentVarianceFields>;
};

/** aggregate fields of "installed_equipment" */
export type StopsDatabaseInstalledEquipmentAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseInstalledEquipmentSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseInstalledEquipmentAvgFields = {
  __typename?: 'stops_database_installed_equipment_avg_fields';
  equipment_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "installed_equipment". All fields are combined with a logical 'AND'. */
export type StopsDatabaseInstalledEquipmentBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseInstalledEquipmentBoolExp>>;
  _not?: InputMaybe<StopsDatabaseInstalledEquipmentBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseInstalledEquipmentBoolExp>>;
  equipment_id?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<StringComparisonExp>;
  item_type?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "installed_equipment" */
export type StopsDatabaseInstalledEquipmentIncInput = {
  equipment_id?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "installed_equipment" */
export type StopsDatabaseInstalledEquipmentInsertInput = {
  equipment_id?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['String']>;
  item_type?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type StopsDatabaseInstalledEquipmentMaxFields = {
  __typename?: 'stops_database_installed_equipment_max_fields';
  equipment_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['String']>;
  item_type?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseInstalledEquipmentMinFields = {
  __typename?: 'stops_database_installed_equipment_min_fields';
  equipment_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['String']>;
  item_type?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "installed_equipment" */
export type StopsDatabaseInstalledEquipmentMutationResponse = {
  __typename?: 'stops_database_installed_equipment_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseInstalledEquipment>;
};

/** Ordering options when selecting data from "installed_equipment". */
export type StopsDatabaseInstalledEquipmentOrderBy = {
  equipment_id?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  item_type?: InputMaybe<OrderBy>;
};

/** select columns of table "installed_equipment" */
export enum StopsDatabaseInstalledEquipmentSelectColumn {
  /** column name */
  EquipmentId = 'equipment_id',
  /** column name */
  Id = 'id',
  /** column name */
  ItemType = 'item_type',
}

/** input type for updating data in table "installed_equipment" */
export type StopsDatabaseInstalledEquipmentSetInput = {
  equipment_id?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['String']>;
  item_type?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseInstalledEquipmentStddevFields = {
  __typename?: 'stops_database_installed_equipment_stddev_fields';
  equipment_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseInstalledEquipmentStddevPopFields = {
  __typename?: 'stops_database_installed_equipment_stddev_pop_fields';
  equipment_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseInstalledEquipmentStddevSampFields = {
  __typename?: 'stops_database_installed_equipment_stddev_samp_fields';
  equipment_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "installed_equipment" */
export type StopsDatabaseInstalledEquipmentStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseInstalledEquipmentStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseInstalledEquipmentStreamCursorValueInput = {
  equipment_id?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['String']>;
  item_type?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseInstalledEquipmentSumFields = {
  __typename?: 'stops_database_installed_equipment_sum_fields';
  equipment_id?: Maybe<Scalars['Int']>;
};

export type StopsDatabaseInstalledEquipmentUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseInstalledEquipmentIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseInstalledEquipmentSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseInstalledEquipmentBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseInstalledEquipmentVarPopFields = {
  __typename?: 'stops_database_installed_equipment_var_pop_fields';
  equipment_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseInstalledEquipmentVarSampFields = {
  __typename?: 'stops_database_installed_equipment_var_samp_fields';
  equipment_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseInstalledEquipmentVarianceFields = {
  __typename?: 'stops_database_installed_equipment_variance_fields';
  equipment_id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructure = {
  __typename?: 'stops_database_installed_equipment_version_structure';
  air_conditioned?: Maybe<Scalars['Boolean']>;
  brand_graphic?: Maybe<Scalars['String']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  class_of_use_ref?: Maybe<Scalars['bytea']>;
  content_lang?: Maybe<Scalars['String']>;
  content_value?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  cycle_storage_type?: Maybe<Scalars['Int']>;
  dtype: Scalars['String'];
  enclosed?: Maybe<Scalars['Boolean']>;
  from_date?: Maybe<Scalars['timestamp']>;
  gender?: Maybe<Scalars['Int']>;
  heated?: Maybe<Scalars['Boolean']>;
  height?: Maybe<Scalars['numeric']>;
  height_from_floor?: Maybe<Scalars['numeric']>;
  id: Scalars['bigint'];
  /** An array relationship */
  installed_equipment_version_structure_installed_equipments: Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipment>;
  /** An aggregate relationship */
  installed_equipment_version_structure_installed_equipments_aggregate: StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAggregate;
  length?: Maybe<Scalars['numeric']>;
  line_signage?: Maybe<Scalars['Boolean']>;
  machine_readable?: Maybe<Scalars['Boolean']>;
  main_line_sign?: Maybe<Scalars['Boolean']>;
  netex_id?: Maybe<Scalars['String']>;
  note_lang?: Maybe<Scalars['String']>;
  note_value?: Maybe<Scalars['String']>;
  number_of_frames?: Maybe<Scalars['Int']>;
  number_of_machines?: Maybe<Scalars['numeric']>;
  number_of_spaces?: Maybe<Scalars['numeric']>;
  number_of_toilets?: Maybe<Scalars['numeric']>;
  out_of_service?: Maybe<Scalars['Boolean']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  replaces_rail_sign?: Maybe<Scalars['Boolean']>;
  seats?: Maybe<Scalars['numeric']>;
  sign_content_type?: Maybe<Scalars['String']>;
  sign_graphic?: Maybe<Scalars['String']>;
  smoking_allowed?: Maybe<Scalars['Boolean']>;
  step_free?: Maybe<Scalars['Boolean']>;
  ticket_machines?: Maybe<Scalars['Boolean']>;
  ticket_office?: Maybe<Scalars['Boolean']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version: Scalars['bigint'];
  version_comment?: Maybe<Scalars['String']>;
  wheelchair_area_length?: Maybe<Scalars['numeric']>;
  wheelchair_area_width?: Maybe<Scalars['numeric']>;
  width?: Maybe<Scalars['numeric']>;
  women_only?: Maybe<Scalars['Boolean']>;
};

/** columns and relationships of "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVersionStructureInstalledEquipmentsArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>;
  };

/** columns and relationships of "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVersionStructureInstalledEquipmentsAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>;
  };

/** aggregated selection of "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructureAggregate = {
  __typename?: 'stops_database_installed_equipment_version_structure_aggregate';
  aggregate?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureAggregateFields>;
  nodes: Array<StopsDatabaseInstalledEquipmentVersionStructure>;
};

/** aggregate fields of "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructureAggregateFields = {
  __typename?: 'stops_database_installed_equipment_version_structure_aggregate_fields';
  avg?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureMaxFields>;
  min?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureMinFields>;
  stddev?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureStddevSampFields>;
  sum?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureSumFields>;
  var_pop?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureVarPopFields>;
  var_samp?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureVarSampFields>;
  variance?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureVarianceFields>;
};

/** aggregate fields of "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructureAggregateFieldsCountArgs =
  {
    columns?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentVersionStructureSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
  };

/** aggregate avg on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureAvgFields = {
  __typename?: 'stops_database_installed_equipment_version_structure_avg_fields';
  cycle_storage_type?: Maybe<Scalars['Float']>;
  gender?: Maybe<Scalars['Float']>;
  height?: Maybe<Scalars['Float']>;
  height_from_floor?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  number_of_frames?: Maybe<Scalars['Float']>;
  number_of_machines?: Maybe<Scalars['Float']>;
  number_of_spaces?: Maybe<Scalars['Float']>;
  number_of_toilets?: Maybe<Scalars['Float']>;
  seats?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
  wheelchair_area_length?: Maybe<Scalars['Float']>;
  wheelchair_area_width?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "installed_equipment_version_structure". All fields are combined with a logical 'AND'. */
export type StopsDatabaseInstalledEquipmentVersionStructureBoolExp = {
  _and?: InputMaybe<
    Array<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>
  >;
  _not?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
  _or?: InputMaybe<
    Array<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>
  >;
  air_conditioned?: InputMaybe<BooleanComparisonExp>;
  brand_graphic?: InputMaybe<StringComparisonExp>;
  changed?: InputMaybe<TimestampComparisonExp>;
  changed_by?: InputMaybe<StringComparisonExp>;
  class_of_use_ref?: InputMaybe<ByteaComparisonExp>;
  content_lang?: InputMaybe<StringComparisonExp>;
  content_value?: InputMaybe<StringComparisonExp>;
  created?: InputMaybe<TimestampComparisonExp>;
  cycle_storage_type?: InputMaybe<IntComparisonExp>;
  dtype?: InputMaybe<StringComparisonExp>;
  enclosed?: InputMaybe<BooleanComparisonExp>;
  from_date?: InputMaybe<TimestampComparisonExp>;
  gender?: InputMaybe<IntComparisonExp>;
  heated?: InputMaybe<BooleanComparisonExp>;
  height?: InputMaybe<NumericComparisonExp>;
  height_from_floor?: InputMaybe<NumericComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  installed_equipment_version_structure_installed_equipments?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>;
  installed_equipment_version_structure_installed_equipments_aggregate?: InputMaybe<InstalledEquipmentVersionStructureInstalledEquipmentAggregateBoolExp>;
  length?: InputMaybe<NumericComparisonExp>;
  line_signage?: InputMaybe<BooleanComparisonExp>;
  machine_readable?: InputMaybe<BooleanComparisonExp>;
  main_line_sign?: InputMaybe<BooleanComparisonExp>;
  netex_id?: InputMaybe<StringComparisonExp>;
  note_lang?: InputMaybe<StringComparisonExp>;
  note_value?: InputMaybe<StringComparisonExp>;
  number_of_frames?: InputMaybe<IntComparisonExp>;
  number_of_machines?: InputMaybe<NumericComparisonExp>;
  number_of_spaces?: InputMaybe<NumericComparisonExp>;
  number_of_toilets?: InputMaybe<NumericComparisonExp>;
  out_of_service?: InputMaybe<BooleanComparisonExp>;
  private_code_type?: InputMaybe<StringComparisonExp>;
  private_code_value?: InputMaybe<StringComparisonExp>;
  replaces_rail_sign?: InputMaybe<BooleanComparisonExp>;
  seats?: InputMaybe<NumericComparisonExp>;
  sign_content_type?: InputMaybe<StringComparisonExp>;
  sign_graphic?: InputMaybe<StringComparisonExp>;
  smoking_allowed?: InputMaybe<BooleanComparisonExp>;
  step_free?: InputMaybe<BooleanComparisonExp>;
  ticket_machines?: InputMaybe<BooleanComparisonExp>;
  ticket_office?: InputMaybe<BooleanComparisonExp>;
  to_date?: InputMaybe<TimestampComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
  version_comment?: InputMaybe<StringComparisonExp>;
  wheelchair_area_length?: InputMaybe<NumericComparisonExp>;
  wheelchair_area_width?: InputMaybe<NumericComparisonExp>;
  width?: InputMaybe<NumericComparisonExp>;
  women_only?: InputMaybe<BooleanComparisonExp>;
};

/** unique or primary key constraints on table "installed_equipment_version_structure" */
export enum StopsDatabaseInstalledEquipmentVersionStructureConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  InstalledEquipmentNetexIdVersionConstraint = 'installed_equipment_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  InstalledEquipmentVersionStructurePkey = 'installed_equipment_version_structure_pkey',
}

/** input type for incrementing numeric columns in table "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructureIncInput = {
  cycle_storage_type?: InputMaybe<Scalars['Int']>;
  gender?: InputMaybe<Scalars['Int']>;
  height?: InputMaybe<Scalars['numeric']>;
  height_from_floor?: InputMaybe<Scalars['numeric']>;
  id?: InputMaybe<Scalars['bigint']>;
  length?: InputMaybe<Scalars['numeric']>;
  number_of_frames?: InputMaybe<Scalars['Int']>;
  number_of_machines?: InputMaybe<Scalars['numeric']>;
  number_of_spaces?: InputMaybe<Scalars['numeric']>;
  number_of_toilets?: InputMaybe<Scalars['numeric']>;
  seats?: InputMaybe<Scalars['numeric']>;
  version?: InputMaybe<Scalars['bigint']>;
  wheelchair_area_length?: InputMaybe<Scalars['numeric']>;
  wheelchair_area_width?: InputMaybe<Scalars['numeric']>;
  width?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructureInsertInput = {
  air_conditioned?: InputMaybe<Scalars['Boolean']>;
  brand_graphic?: InputMaybe<Scalars['String']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  class_of_use_ref?: InputMaybe<Scalars['bytea']>;
  content_lang?: InputMaybe<Scalars['String']>;
  content_value?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  cycle_storage_type?: InputMaybe<Scalars['Int']>;
  dtype?: InputMaybe<Scalars['String']>;
  enclosed?: InputMaybe<Scalars['Boolean']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  gender?: InputMaybe<Scalars['Int']>;
  heated?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<Scalars['numeric']>;
  height_from_floor?: InputMaybe<Scalars['numeric']>;
  id?: InputMaybe<Scalars['bigint']>;
  installed_equipment_version_structure_installed_equipments?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentArrRelInsertInput>;
  length?: InputMaybe<Scalars['numeric']>;
  line_signage?: InputMaybe<Scalars['Boolean']>;
  machine_readable?: InputMaybe<Scalars['Boolean']>;
  main_line_sign?: InputMaybe<Scalars['Boolean']>;
  netex_id?: InputMaybe<Scalars['String']>;
  note_lang?: InputMaybe<Scalars['String']>;
  note_value?: InputMaybe<Scalars['String']>;
  number_of_frames?: InputMaybe<Scalars['Int']>;
  number_of_machines?: InputMaybe<Scalars['numeric']>;
  number_of_spaces?: InputMaybe<Scalars['numeric']>;
  number_of_toilets?: InputMaybe<Scalars['numeric']>;
  out_of_service?: InputMaybe<Scalars['Boolean']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  replaces_rail_sign?: InputMaybe<Scalars['Boolean']>;
  seats?: InputMaybe<Scalars['numeric']>;
  sign_content_type?: InputMaybe<Scalars['String']>;
  sign_graphic?: InputMaybe<Scalars['String']>;
  smoking_allowed?: InputMaybe<Scalars['Boolean']>;
  step_free?: InputMaybe<Scalars['Boolean']>;
  ticket_machines?: InputMaybe<Scalars['Boolean']>;
  ticket_office?: InputMaybe<Scalars['Boolean']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
  wheelchair_area_length?: InputMaybe<Scalars['numeric']>;
  wheelchair_area_width?: InputMaybe<Scalars['numeric']>;
  width?: InputMaybe<Scalars['numeric']>;
  women_only?: InputMaybe<Scalars['Boolean']>;
};

/** columns and relationships of "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipment =
  {
    __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment';
    /** An object relationship */
    installedEquipmentVersionStructureByPlaceEquipmentId: StopsDatabaseInstalledEquipmentVersionStructure;
    installed_equipment_id: Scalars['bigint'];
    /** An object relationship */
    installed_equipment_version_structure: StopsDatabaseInstalledEquipmentVersionStructure;
    place_equipment_id: Scalars['bigint'];
  };

/** aggregated selection of "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAggregate =
  {
    __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_aggregate';
    aggregate?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAggregateFields>;
    nodes: Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipment>;
  };

/** aggregate fields of "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAggregateFields =
  {
    __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_aggregate_fields';
    avg?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAvgFields>;
    count: Scalars['Int'];
    max?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMaxFields>;
    min?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMinFields>;
    stddev?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStddevFields>;
    stddev_pop?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStddevPopFields>;
    stddev_samp?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStddevSampFields>;
    sum?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSumFields>;
    var_pop?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVarPopFields>;
    var_samp?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVarSampFields>;
    variance?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVarianceFields>;
  };

/** aggregate fields of "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAggregateFieldsCountArgs =
  {
    columns?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
  };

/** order by aggregate values of table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAggregateOrderBy =
  {
    avg?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAvgOrderBy>;
    count?: InputMaybe<OrderBy>;
    max?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMaxOrderBy>;
    min?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMinOrderBy>;
    stddev?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStddevOrderBy>;
    stddev_pop?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStddevPopOrderBy>;
    stddev_samp?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStddevSampOrderBy>;
    sum?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSumOrderBy>;
    var_pop?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVarPopOrderBy>;
    var_samp?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVarSampOrderBy>;
    variance?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVarianceOrderBy>;
  };

/** input type for inserting array relation for remote table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentArrRelInsertInput =
  {
    data: Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentInsertInput>;
    /** upsert condition */
    on_conflict?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentOnConflict>;
  };

/** aggregate avg on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAvgFields =
  {
    __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_avg_fields';
    installed_equipment_id?: Maybe<Scalars['Float']>;
    place_equipment_id?: Maybe<Scalars['Float']>;
  };

/** order by avg() on columns of table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAvgOrderBy =
  {
    installed_equipment_id?: InputMaybe<OrderBy>;
    place_equipment_id?: InputMaybe<OrderBy>;
  };

/** Boolean expression to filter rows from the table "installed_equipment_version_structure_installed_equipment". All fields are combined with a logical 'AND'. */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp =
  {
    _and?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>
    >;
    _not?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>;
    _or?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>
    >;
    installedEquipmentVersionStructureByPlaceEquipmentId?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
    installed_equipment_id?: InputMaybe<BigintComparisonExp>;
    installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
    place_equipment_id?: InputMaybe<BigintComparisonExp>;
  };

/** unique or primary key constraints on table "installed_equipment_version_structure_installed_equipment" */
export enum StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentConstraint {
  /** unique or primary key constraint on columns "installed_equipment_id" */
  UkS4px36fd2jutbf4p8lagcocbd = 'uk_s4px36fd2jutbf4p8lagcocbd',
}

/** input type for incrementing numeric columns in table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentIncInput =
  {
    installed_equipment_id?: InputMaybe<Scalars['bigint']>;
    place_equipment_id?: InputMaybe<Scalars['bigint']>;
  };

/** input type for inserting data into table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentInsertInput =
  {
    installedEquipmentVersionStructureByPlaceEquipmentId?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureObjRelInsertInput>;
    installed_equipment_id?: InputMaybe<Scalars['bigint']>;
    installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureObjRelInsertInput>;
    place_equipment_id?: InputMaybe<Scalars['bigint']>;
  };

/** aggregate max on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMaxFields =
  {
    __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_max_fields';
    installed_equipment_id?: Maybe<Scalars['bigint']>;
    place_equipment_id?: Maybe<Scalars['bigint']>;
  };

/** order by max() on columns of table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMaxOrderBy =
  {
    installed_equipment_id?: InputMaybe<OrderBy>;
    place_equipment_id?: InputMaybe<OrderBy>;
  };

/** aggregate min on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMinFields =
  {
    __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_min_fields';
    installed_equipment_id?: Maybe<Scalars['bigint']>;
    place_equipment_id?: Maybe<Scalars['bigint']>;
  };

/** order by min() on columns of table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMinOrderBy =
  {
    installed_equipment_id?: InputMaybe<OrderBy>;
    place_equipment_id?: InputMaybe<OrderBy>;
  };

/** response of any mutation on the table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMutationResponse =
  {
    __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_mutation_response';
    /** number of rows affected by the mutation */
    affected_rows: Scalars['Int'];
    /** data from the rows affected by the mutation */
    returning: Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipment>;
  };

/** on_conflict condition type for table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentOnConflict =
  {
    constraint: StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentConstraint;
    update_columns?: Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentUpdateColumn>;
    where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>;
  };

/** Ordering options when selecting data from "installed_equipment_version_structure_installed_equipment". */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentOrderBy =
  {
    installedEquipmentVersionStructureByPlaceEquipmentId?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureOrderBy>;
    installed_equipment_id?: InputMaybe<OrderBy>;
    installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureOrderBy>;
    place_equipment_id?: InputMaybe<OrderBy>;
  };

/** select columns of table "installed_equipment_version_structure_installed_equipment" */
export enum StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSelectColumn {
  /** column name */
  InstalledEquipmentId = 'installed_equipment_id',
  /** column name */
  PlaceEquipmentId = 'place_equipment_id',
}

/** input type for updating data in table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSetInput =
  {
    installed_equipment_id?: InputMaybe<Scalars['bigint']>;
    place_equipment_id?: InputMaybe<Scalars['bigint']>;
  };

/** aggregate stddev on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStddevFields =
  {
    __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_stddev_fields';
    installed_equipment_id?: Maybe<Scalars['Float']>;
    place_equipment_id?: Maybe<Scalars['Float']>;
  };

/** order by stddev() on columns of table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStddevOrderBy =
  {
    installed_equipment_id?: InputMaybe<OrderBy>;
    place_equipment_id?: InputMaybe<OrderBy>;
  };

/** aggregate stddev_pop on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStddevPopFields =
  {
    __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_stddev_pop_fields';
    installed_equipment_id?: Maybe<Scalars['Float']>;
    place_equipment_id?: Maybe<Scalars['Float']>;
  };

/** order by stddev_pop() on columns of table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStddevPopOrderBy =
  {
    installed_equipment_id?: InputMaybe<OrderBy>;
    place_equipment_id?: InputMaybe<OrderBy>;
  };

/** aggregate stddev_samp on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStddevSampFields =
  {
    __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_stddev_samp_fields';
    installed_equipment_id?: Maybe<Scalars['Float']>;
    place_equipment_id?: Maybe<Scalars['Float']>;
  };

/** order by stddev_samp() on columns of table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStddevSampOrderBy =
  {
    installed_equipment_id?: InputMaybe<OrderBy>;
    place_equipment_id?: InputMaybe<OrderBy>;
  };

/** Streaming cursor of the table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStreamCursorInput =
  {
    /** Stream column input with initial value */
    initial_value: StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
  };

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStreamCursorValueInput =
  {
    installed_equipment_id?: InputMaybe<Scalars['bigint']>;
    place_equipment_id?: InputMaybe<Scalars['bigint']>;
  };

/** aggregate sum on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSumFields =
  {
    __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_sum_fields';
    installed_equipment_id?: Maybe<Scalars['bigint']>;
    place_equipment_id?: Maybe<Scalars['bigint']>;
  };

/** order by sum() on columns of table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSumOrderBy =
  {
    installed_equipment_id?: InputMaybe<OrderBy>;
    place_equipment_id?: InputMaybe<OrderBy>;
  };

/** update columns of table "installed_equipment_version_structure_installed_equipment" */
export enum StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentUpdateColumn {
  /** column name */
  InstalledEquipmentId = 'installed_equipment_id',
  /** column name */
  PlaceEquipmentId = 'place_equipment_id',
}

export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentUpdates =
  {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSetInput>;
    /** filter the rows which have to be updated */
    where: StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp;
  };

/** aggregate var_pop on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVarPopFields =
  {
    __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_var_pop_fields';
    installed_equipment_id?: Maybe<Scalars['Float']>;
    place_equipment_id?: Maybe<Scalars['Float']>;
  };

/** order by var_pop() on columns of table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVarPopOrderBy =
  {
    installed_equipment_id?: InputMaybe<OrderBy>;
    place_equipment_id?: InputMaybe<OrderBy>;
  };

/** aggregate var_samp on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVarSampFields =
  {
    __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_var_samp_fields';
    installed_equipment_id?: Maybe<Scalars['Float']>;
    place_equipment_id?: Maybe<Scalars['Float']>;
  };

/** order by var_samp() on columns of table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVarSampOrderBy =
  {
    installed_equipment_id?: InputMaybe<OrderBy>;
    place_equipment_id?: InputMaybe<OrderBy>;
  };

/** aggregate variance on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVarianceFields =
  {
    __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_variance_fields';
    installed_equipment_id?: Maybe<Scalars['Float']>;
    place_equipment_id?: Maybe<Scalars['Float']>;
  };

/** order by variance() on columns of table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVarianceOrderBy =
  {
    installed_equipment_id?: InputMaybe<OrderBy>;
    place_equipment_id?: InputMaybe<OrderBy>;
  };

/** aggregate max on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureMaxFields = {
  __typename?: 'stops_database_installed_equipment_version_structure_max_fields';
  brand_graphic?: Maybe<Scalars['String']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  content_lang?: Maybe<Scalars['String']>;
  content_value?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  cycle_storage_type?: Maybe<Scalars['Int']>;
  dtype?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  gender?: Maybe<Scalars['Int']>;
  height?: Maybe<Scalars['numeric']>;
  height_from_floor?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['bigint']>;
  length?: Maybe<Scalars['numeric']>;
  netex_id?: Maybe<Scalars['String']>;
  note_lang?: Maybe<Scalars['String']>;
  note_value?: Maybe<Scalars['String']>;
  number_of_frames?: Maybe<Scalars['Int']>;
  number_of_machines?: Maybe<Scalars['numeric']>;
  number_of_spaces?: Maybe<Scalars['numeric']>;
  number_of_toilets?: Maybe<Scalars['numeric']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  seats?: Maybe<Scalars['numeric']>;
  sign_content_type?: Maybe<Scalars['String']>;
  sign_graphic?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
  wheelchair_area_length?: Maybe<Scalars['numeric']>;
  wheelchair_area_width?: Maybe<Scalars['numeric']>;
  width?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureMinFields = {
  __typename?: 'stops_database_installed_equipment_version_structure_min_fields';
  brand_graphic?: Maybe<Scalars['String']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  content_lang?: Maybe<Scalars['String']>;
  content_value?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  cycle_storage_type?: Maybe<Scalars['Int']>;
  dtype?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  gender?: Maybe<Scalars['Int']>;
  height?: Maybe<Scalars['numeric']>;
  height_from_floor?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['bigint']>;
  length?: Maybe<Scalars['numeric']>;
  netex_id?: Maybe<Scalars['String']>;
  note_lang?: Maybe<Scalars['String']>;
  note_value?: Maybe<Scalars['String']>;
  number_of_frames?: Maybe<Scalars['Int']>;
  number_of_machines?: Maybe<Scalars['numeric']>;
  number_of_spaces?: Maybe<Scalars['numeric']>;
  number_of_toilets?: Maybe<Scalars['numeric']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  seats?: Maybe<Scalars['numeric']>;
  sign_content_type?: Maybe<Scalars['String']>;
  sign_graphic?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
  wheelchair_area_length?: Maybe<Scalars['numeric']>;
  wheelchair_area_width?: Maybe<Scalars['numeric']>;
  width?: Maybe<Scalars['numeric']>;
};

/** response of any mutation on the table "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructureMutationResponse = {
  __typename?: 'stops_database_installed_equipment_version_structure_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseInstalledEquipmentVersionStructure>;
};

/** input type for inserting object relation for remote table "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructureObjRelInsertInput = {
  data: StopsDatabaseInstalledEquipmentVersionStructureInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureOnConflict>;
};

/** on_conflict condition type for table "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructureOnConflict = {
  constraint: StopsDatabaseInstalledEquipmentVersionStructureConstraint;
  update_columns?: Array<StopsDatabaseInstalledEquipmentVersionStructureUpdateColumn>;
  where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
};

/** Ordering options when selecting data from "installed_equipment_version_structure". */
export type StopsDatabaseInstalledEquipmentVersionStructureOrderBy = {
  air_conditioned?: InputMaybe<OrderBy>;
  brand_graphic?: InputMaybe<OrderBy>;
  changed?: InputMaybe<OrderBy>;
  changed_by?: InputMaybe<OrderBy>;
  class_of_use_ref?: InputMaybe<OrderBy>;
  content_lang?: InputMaybe<OrderBy>;
  content_value?: InputMaybe<OrderBy>;
  created?: InputMaybe<OrderBy>;
  cycle_storage_type?: InputMaybe<OrderBy>;
  dtype?: InputMaybe<OrderBy>;
  enclosed?: InputMaybe<OrderBy>;
  from_date?: InputMaybe<OrderBy>;
  gender?: InputMaybe<OrderBy>;
  heated?: InputMaybe<OrderBy>;
  height?: InputMaybe<OrderBy>;
  height_from_floor?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  installed_equipment_version_structure_installed_equipments_aggregate?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAggregateOrderBy>;
  length?: InputMaybe<OrderBy>;
  line_signage?: InputMaybe<OrderBy>;
  machine_readable?: InputMaybe<OrderBy>;
  main_line_sign?: InputMaybe<OrderBy>;
  netex_id?: InputMaybe<OrderBy>;
  note_lang?: InputMaybe<OrderBy>;
  note_value?: InputMaybe<OrderBy>;
  number_of_frames?: InputMaybe<OrderBy>;
  number_of_machines?: InputMaybe<OrderBy>;
  number_of_spaces?: InputMaybe<OrderBy>;
  number_of_toilets?: InputMaybe<OrderBy>;
  out_of_service?: InputMaybe<OrderBy>;
  private_code_type?: InputMaybe<OrderBy>;
  private_code_value?: InputMaybe<OrderBy>;
  replaces_rail_sign?: InputMaybe<OrderBy>;
  seats?: InputMaybe<OrderBy>;
  sign_content_type?: InputMaybe<OrderBy>;
  sign_graphic?: InputMaybe<OrderBy>;
  smoking_allowed?: InputMaybe<OrderBy>;
  step_free?: InputMaybe<OrderBy>;
  ticket_machines?: InputMaybe<OrderBy>;
  ticket_office?: InputMaybe<OrderBy>;
  to_date?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
  version_comment?: InputMaybe<OrderBy>;
  wheelchair_area_length?: InputMaybe<OrderBy>;
  wheelchair_area_width?: InputMaybe<OrderBy>;
  width?: InputMaybe<OrderBy>;
  women_only?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: installed_equipment_version_structure */
export type StopsDatabaseInstalledEquipmentVersionStructurePkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "installed_equipment_version_structure" */
export enum StopsDatabaseInstalledEquipmentVersionStructureSelectColumn {
  /** column name */
  AirConditioned = 'air_conditioned',
  /** column name */
  BrandGraphic = 'brand_graphic',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  ClassOfUseRef = 'class_of_use_ref',
  /** column name */
  ContentLang = 'content_lang',
  /** column name */
  ContentValue = 'content_value',
  /** column name */
  Created = 'created',
  /** column name */
  CycleStorageType = 'cycle_storage_type',
  /** column name */
  Dtype = 'dtype',
  /** column name */
  Enclosed = 'enclosed',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Gender = 'gender',
  /** column name */
  Heated = 'heated',
  /** column name */
  Height = 'height',
  /** column name */
  HeightFromFloor = 'height_from_floor',
  /** column name */
  Id = 'id',
  /** column name */
  Length = 'length',
  /** column name */
  LineSignage = 'line_signage',
  /** column name */
  MachineReadable = 'machine_readable',
  /** column name */
  MainLineSign = 'main_line_sign',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  NoteLang = 'note_lang',
  /** column name */
  NoteValue = 'note_value',
  /** column name */
  NumberOfFrames = 'number_of_frames',
  /** column name */
  NumberOfMachines = 'number_of_machines',
  /** column name */
  NumberOfSpaces = 'number_of_spaces',
  /** column name */
  NumberOfToilets = 'number_of_toilets',
  /** column name */
  OutOfService = 'out_of_service',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ReplacesRailSign = 'replaces_rail_sign',
  /** column name */
  Seats = 'seats',
  /** column name */
  SignContentType = 'sign_content_type',
  /** column name */
  SignGraphic = 'sign_graphic',
  /** column name */
  SmokingAllowed = 'smoking_allowed',
  /** column name */
  StepFree = 'step_free',
  /** column name */
  TicketMachines = 'ticket_machines',
  /** column name */
  TicketOffice = 'ticket_office',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  WheelchairAreaLength = 'wheelchair_area_length',
  /** column name */
  WheelchairAreaWidth = 'wheelchair_area_width',
  /** column name */
  Width = 'width',
  /** column name */
  WomenOnly = 'women_only',
}

/** input type for updating data in table "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructureSetInput = {
  air_conditioned?: InputMaybe<Scalars['Boolean']>;
  brand_graphic?: InputMaybe<Scalars['String']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  class_of_use_ref?: InputMaybe<Scalars['bytea']>;
  content_lang?: InputMaybe<Scalars['String']>;
  content_value?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  cycle_storage_type?: InputMaybe<Scalars['Int']>;
  dtype?: InputMaybe<Scalars['String']>;
  enclosed?: InputMaybe<Scalars['Boolean']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  gender?: InputMaybe<Scalars['Int']>;
  heated?: InputMaybe<Scalars['Boolean']>;
  height?: InputMaybe<Scalars['numeric']>;
  height_from_floor?: InputMaybe<Scalars['numeric']>;
  id?: InputMaybe<Scalars['bigint']>;
  length?: InputMaybe<Scalars['numeric']>;
  line_signage?: InputMaybe<Scalars['Boolean']>;
  machine_readable?: InputMaybe<Scalars['Boolean']>;
  main_line_sign?: InputMaybe<Scalars['Boolean']>;
  netex_id?: InputMaybe<Scalars['String']>;
  note_lang?: InputMaybe<Scalars['String']>;
  note_value?: InputMaybe<Scalars['String']>;
  number_of_frames?: InputMaybe<Scalars['Int']>;
  number_of_machines?: InputMaybe<Scalars['numeric']>;
  number_of_spaces?: InputMaybe<Scalars['numeric']>;
  number_of_toilets?: InputMaybe<Scalars['numeric']>;
  out_of_service?: InputMaybe<Scalars['Boolean']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  replaces_rail_sign?: InputMaybe<Scalars['Boolean']>;
  seats?: InputMaybe<Scalars['numeric']>;
  sign_content_type?: InputMaybe<Scalars['String']>;
  sign_graphic?: InputMaybe<Scalars['String']>;
  smoking_allowed?: InputMaybe<Scalars['Boolean']>;
  step_free?: InputMaybe<Scalars['Boolean']>;
  ticket_machines?: InputMaybe<Scalars['Boolean']>;
  ticket_office?: InputMaybe<Scalars['Boolean']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
  wheelchair_area_length?: InputMaybe<Scalars['numeric']>;
  wheelchair_area_width?: InputMaybe<Scalars['numeric']>;
  width?: InputMaybe<Scalars['numeric']>;
  women_only?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureStddevFields = {
  __typename?: 'stops_database_installed_equipment_version_structure_stddev_fields';
  cycle_storage_type?: Maybe<Scalars['Float']>;
  gender?: Maybe<Scalars['Float']>;
  height?: Maybe<Scalars['Float']>;
  height_from_floor?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  number_of_frames?: Maybe<Scalars['Float']>;
  number_of_machines?: Maybe<Scalars['Float']>;
  number_of_spaces?: Maybe<Scalars['Float']>;
  number_of_toilets?: Maybe<Scalars['Float']>;
  seats?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
  wheelchair_area_length?: Maybe<Scalars['Float']>;
  wheelchair_area_width?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureStddevPopFields = {
  __typename?: 'stops_database_installed_equipment_version_structure_stddev_pop_fields';
  cycle_storage_type?: Maybe<Scalars['Float']>;
  gender?: Maybe<Scalars['Float']>;
  height?: Maybe<Scalars['Float']>;
  height_from_floor?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  number_of_frames?: Maybe<Scalars['Float']>;
  number_of_machines?: Maybe<Scalars['Float']>;
  number_of_spaces?: Maybe<Scalars['Float']>;
  number_of_toilets?: Maybe<Scalars['Float']>;
  seats?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
  wheelchair_area_length?: Maybe<Scalars['Float']>;
  wheelchair_area_width?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureStddevSampFields = {
  __typename?: 'stops_database_installed_equipment_version_structure_stddev_samp_fields';
  cycle_storage_type?: Maybe<Scalars['Float']>;
  gender?: Maybe<Scalars['Float']>;
  height?: Maybe<Scalars['Float']>;
  height_from_floor?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  number_of_frames?: Maybe<Scalars['Float']>;
  number_of_machines?: Maybe<Scalars['Float']>;
  number_of_spaces?: Maybe<Scalars['Float']>;
  number_of_toilets?: Maybe<Scalars['Float']>;
  seats?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
  wheelchair_area_length?: Maybe<Scalars['Float']>;
  wheelchair_area_width?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructureStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseInstalledEquipmentVersionStructureStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseInstalledEquipmentVersionStructureStreamCursorValueInput =
  {
    air_conditioned?: InputMaybe<Scalars['Boolean']>;
    brand_graphic?: InputMaybe<Scalars['String']>;
    changed?: InputMaybe<Scalars['timestamp']>;
    changed_by?: InputMaybe<Scalars['String']>;
    class_of_use_ref?: InputMaybe<Scalars['bytea']>;
    content_lang?: InputMaybe<Scalars['String']>;
    content_value?: InputMaybe<Scalars['String']>;
    created?: InputMaybe<Scalars['timestamp']>;
    cycle_storage_type?: InputMaybe<Scalars['Int']>;
    dtype?: InputMaybe<Scalars['String']>;
    enclosed?: InputMaybe<Scalars['Boolean']>;
    from_date?: InputMaybe<Scalars['timestamp']>;
    gender?: InputMaybe<Scalars['Int']>;
    heated?: InputMaybe<Scalars['Boolean']>;
    height?: InputMaybe<Scalars['numeric']>;
    height_from_floor?: InputMaybe<Scalars['numeric']>;
    id?: InputMaybe<Scalars['bigint']>;
    length?: InputMaybe<Scalars['numeric']>;
    line_signage?: InputMaybe<Scalars['Boolean']>;
    machine_readable?: InputMaybe<Scalars['Boolean']>;
    main_line_sign?: InputMaybe<Scalars['Boolean']>;
    netex_id?: InputMaybe<Scalars['String']>;
    note_lang?: InputMaybe<Scalars['String']>;
    note_value?: InputMaybe<Scalars['String']>;
    number_of_frames?: InputMaybe<Scalars['Int']>;
    number_of_machines?: InputMaybe<Scalars['numeric']>;
    number_of_spaces?: InputMaybe<Scalars['numeric']>;
    number_of_toilets?: InputMaybe<Scalars['numeric']>;
    out_of_service?: InputMaybe<Scalars['Boolean']>;
    private_code_type?: InputMaybe<Scalars['String']>;
    private_code_value?: InputMaybe<Scalars['String']>;
    replaces_rail_sign?: InputMaybe<Scalars['Boolean']>;
    seats?: InputMaybe<Scalars['numeric']>;
    sign_content_type?: InputMaybe<Scalars['String']>;
    sign_graphic?: InputMaybe<Scalars['String']>;
    smoking_allowed?: InputMaybe<Scalars['Boolean']>;
    step_free?: InputMaybe<Scalars['Boolean']>;
    ticket_machines?: InputMaybe<Scalars['Boolean']>;
    ticket_office?: InputMaybe<Scalars['Boolean']>;
    to_date?: InputMaybe<Scalars['timestamp']>;
    version?: InputMaybe<Scalars['bigint']>;
    version_comment?: InputMaybe<Scalars['String']>;
    wheelchair_area_length?: InputMaybe<Scalars['numeric']>;
    wheelchair_area_width?: InputMaybe<Scalars['numeric']>;
    width?: InputMaybe<Scalars['numeric']>;
    women_only?: InputMaybe<Scalars['Boolean']>;
  };

/** aggregate sum on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureSumFields = {
  __typename?: 'stops_database_installed_equipment_version_structure_sum_fields';
  cycle_storage_type?: Maybe<Scalars['Int']>;
  gender?: Maybe<Scalars['Int']>;
  height?: Maybe<Scalars['numeric']>;
  height_from_floor?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['bigint']>;
  length?: Maybe<Scalars['numeric']>;
  number_of_frames?: Maybe<Scalars['Int']>;
  number_of_machines?: Maybe<Scalars['numeric']>;
  number_of_spaces?: Maybe<Scalars['numeric']>;
  number_of_toilets?: Maybe<Scalars['numeric']>;
  seats?: Maybe<Scalars['numeric']>;
  version?: Maybe<Scalars['bigint']>;
  wheelchair_area_length?: Maybe<Scalars['numeric']>;
  wheelchair_area_width?: Maybe<Scalars['numeric']>;
  width?: Maybe<Scalars['numeric']>;
};

/** update columns of table "installed_equipment_version_structure" */
export enum StopsDatabaseInstalledEquipmentVersionStructureUpdateColumn {
  /** column name */
  AirConditioned = 'air_conditioned',
  /** column name */
  BrandGraphic = 'brand_graphic',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  ClassOfUseRef = 'class_of_use_ref',
  /** column name */
  ContentLang = 'content_lang',
  /** column name */
  ContentValue = 'content_value',
  /** column name */
  Created = 'created',
  /** column name */
  CycleStorageType = 'cycle_storage_type',
  /** column name */
  Dtype = 'dtype',
  /** column name */
  Enclosed = 'enclosed',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Gender = 'gender',
  /** column name */
  Heated = 'heated',
  /** column name */
  Height = 'height',
  /** column name */
  HeightFromFloor = 'height_from_floor',
  /** column name */
  Id = 'id',
  /** column name */
  Length = 'length',
  /** column name */
  LineSignage = 'line_signage',
  /** column name */
  MachineReadable = 'machine_readable',
  /** column name */
  MainLineSign = 'main_line_sign',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  NoteLang = 'note_lang',
  /** column name */
  NoteValue = 'note_value',
  /** column name */
  NumberOfFrames = 'number_of_frames',
  /** column name */
  NumberOfMachines = 'number_of_machines',
  /** column name */
  NumberOfSpaces = 'number_of_spaces',
  /** column name */
  NumberOfToilets = 'number_of_toilets',
  /** column name */
  OutOfService = 'out_of_service',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ReplacesRailSign = 'replaces_rail_sign',
  /** column name */
  Seats = 'seats',
  /** column name */
  SignContentType = 'sign_content_type',
  /** column name */
  SignGraphic = 'sign_graphic',
  /** column name */
  SmokingAllowed = 'smoking_allowed',
  /** column name */
  StepFree = 'step_free',
  /** column name */
  TicketMachines = 'ticket_machines',
  /** column name */
  TicketOffice = 'ticket_office',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  WheelchairAreaLength = 'wheelchair_area_length',
  /** column name */
  WheelchairAreaWidth = 'wheelchair_area_width',
  /** column name */
  Width = 'width',
  /** column name */
  WomenOnly = 'women_only',
}

export type StopsDatabaseInstalledEquipmentVersionStructureUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseInstalledEquipmentVersionStructureBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureVarPopFields = {
  __typename?: 'stops_database_installed_equipment_version_structure_var_pop_fields';
  cycle_storage_type?: Maybe<Scalars['Float']>;
  gender?: Maybe<Scalars['Float']>;
  height?: Maybe<Scalars['Float']>;
  height_from_floor?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  number_of_frames?: Maybe<Scalars['Float']>;
  number_of_machines?: Maybe<Scalars['Float']>;
  number_of_spaces?: Maybe<Scalars['Float']>;
  number_of_toilets?: Maybe<Scalars['Float']>;
  seats?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
  wheelchair_area_length?: Maybe<Scalars['Float']>;
  wheelchair_area_width?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureVarSampFields = {
  __typename?: 'stops_database_installed_equipment_version_structure_var_samp_fields';
  cycle_storage_type?: Maybe<Scalars['Float']>;
  gender?: Maybe<Scalars['Float']>;
  height?: Maybe<Scalars['Float']>;
  height_from_floor?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  number_of_frames?: Maybe<Scalars['Float']>;
  number_of_machines?: Maybe<Scalars['Float']>;
  number_of_spaces?: Maybe<Scalars['Float']>;
  number_of_toilets?: Maybe<Scalars['Float']>;
  seats?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
  wheelchair_area_length?: Maybe<Scalars['Float']>;
  wheelchair_area_width?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureVarianceFields = {
  __typename?: 'stops_database_installed_equipment_version_structure_variance_fields';
  cycle_storage_type?: Maybe<Scalars['Float']>;
  gender?: Maybe<Scalars['Float']>;
  height?: Maybe<Scalars['Float']>;
  height_from_floor?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  length?: Maybe<Scalars['Float']>;
  number_of_frames?: Maybe<Scalars['Float']>;
  number_of_machines?: Maybe<Scalars['Float']>;
  number_of_spaces?: Maybe<Scalars['Float']>;
  number_of_toilets?: Maybe<Scalars['Float']>;
  seats?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
  wheelchair_area_length?: Maybe<Scalars['Float']>;
  wheelchair_area_width?: Maybe<Scalars['Float']>;
  width?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "level" */
export type StopsDatabaseLevel = {
  __typename?: 'stops_database_level';
  all_areas_wheelchair_accessible?: Maybe<Scalars['Boolean']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_id?: Maybe<Scalars['bigint']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id: Scalars['bigint'];
  /** An array relationship */
  level_key_values: Array<StopsDatabaseLevelKeyValues>;
  /** An aggregate relationship */
  level_key_values_aggregate: StopsDatabaseLevelKeyValuesAggregate;
  /** An object relationship */
  multilingualStringEntityByNameId?: Maybe<StopsDatabaseMultilingualStringEntity>;
  /** An object relationship */
  multilingualStringEntityByShortNameId?: Maybe<StopsDatabaseMultilingualStringEntity>;
  /** An object relationship */
  multilingual_string_entity?: Maybe<StopsDatabaseMultilingualStringEntity>;
  name_id?: Maybe<Scalars['bigint']>;
  netex_id?: Maybe<Scalars['String']>;
  public_code?: Maybe<Scalars['String']>;
  public_use?: Maybe<Scalars['Boolean']>;
  short_name_id?: Maybe<Scalars['bigint']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version: Scalars['bigint'];
  version_comment?: Maybe<Scalars['String']>;
};

/** columns and relationships of "level" */
export type StopsDatabaseLevelLevelKeyValuesArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseLevelKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseLevelKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseLevelKeyValuesBoolExp>;
};

/** columns and relationships of "level" */
export type StopsDatabaseLevelLevelKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseLevelKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseLevelKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseLevelKeyValuesBoolExp>;
};

/** aggregated selection of "level" */
export type StopsDatabaseLevelAggregate = {
  __typename?: 'stops_database_level_aggregate';
  aggregate?: Maybe<StopsDatabaseLevelAggregateFields>;
  nodes: Array<StopsDatabaseLevel>;
};

/** aggregate fields of "level" */
export type StopsDatabaseLevelAggregateFields = {
  __typename?: 'stops_database_level_aggregate_fields';
  avg?: Maybe<StopsDatabaseLevelAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseLevelMaxFields>;
  min?: Maybe<StopsDatabaseLevelMinFields>;
  stddev?: Maybe<StopsDatabaseLevelStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseLevelStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseLevelStddevSampFields>;
  sum?: Maybe<StopsDatabaseLevelSumFields>;
  var_pop?: Maybe<StopsDatabaseLevelVarPopFields>;
  var_samp?: Maybe<StopsDatabaseLevelVarSampFields>;
  variance?: Maybe<StopsDatabaseLevelVarianceFields>;
};

/** aggregate fields of "level" */
export type StopsDatabaseLevelAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseLevelSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseLevelAvgFields = {
  __typename?: 'stops_database_level_avg_fields';
  description_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  name_id?: Maybe<Scalars['Float']>;
  short_name_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "level". All fields are combined with a logical 'AND'. */
export type StopsDatabaseLevelBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseLevelBoolExp>>;
  _not?: InputMaybe<StopsDatabaseLevelBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseLevelBoolExp>>;
  all_areas_wheelchair_accessible?: InputMaybe<BooleanComparisonExp>;
  changed?: InputMaybe<TimestampComparisonExp>;
  changed_by?: InputMaybe<StringComparisonExp>;
  created?: InputMaybe<TimestampComparisonExp>;
  description_id?: InputMaybe<BigintComparisonExp>;
  from_date?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  level_key_values?: InputMaybe<StopsDatabaseLevelKeyValuesBoolExp>;
  level_key_values_aggregate?: InputMaybe<LevelKeyValuesAggregateBoolExp>;
  multilingualStringEntityByNameId?: InputMaybe<StopsDatabaseMultilingualStringEntityBoolExp>;
  multilingualStringEntityByShortNameId?: InputMaybe<StopsDatabaseMultilingualStringEntityBoolExp>;
  multilingual_string_entity?: InputMaybe<StopsDatabaseMultilingualStringEntityBoolExp>;
  name_id?: InputMaybe<BigintComparisonExp>;
  netex_id?: InputMaybe<StringComparisonExp>;
  public_code?: InputMaybe<StringComparisonExp>;
  public_use?: InputMaybe<BooleanComparisonExp>;
  short_name_id?: InputMaybe<BigintComparisonExp>;
  to_date?: InputMaybe<TimestampComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
  version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "level" */
export enum StopsDatabaseLevelConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  LevelNetexIdVersionConstraint = 'level_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  LevelPkey = 'level_pkey',
}

/** input type for incrementing numeric columns in table "level" */
export type StopsDatabaseLevelIncInput = {
  description_id?: InputMaybe<Scalars['bigint']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_id?: InputMaybe<Scalars['bigint']>;
  short_name_id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "level" */
export type StopsDatabaseLevelInsertInput = {
  all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_id?: InputMaybe<Scalars['bigint']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  level_key_values?: InputMaybe<StopsDatabaseLevelKeyValuesArrRelInsertInput>;
  multilingualStringEntityByNameId?: InputMaybe<StopsDatabaseMultilingualStringEntityObjRelInsertInput>;
  multilingualStringEntityByShortNameId?: InputMaybe<StopsDatabaseMultilingualStringEntityObjRelInsertInput>;
  multilingual_string_entity?: InputMaybe<StopsDatabaseMultilingualStringEntityObjRelInsertInput>;
  name_id?: InputMaybe<Scalars['bigint']>;
  netex_id?: InputMaybe<Scalars['String']>;
  public_code?: InputMaybe<Scalars['String']>;
  public_use?: InputMaybe<Scalars['Boolean']>;
  short_name_id?: InputMaybe<Scalars['bigint']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "level_key_values" */
export type StopsDatabaseLevelKeyValues = {
  __typename?: 'stops_database_level_key_values';
  key_values_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
  level_id: Scalars['bigint'];
  /** An object relationship */
  value: StopsDatabaseValue;
};

/** aggregated selection of "level_key_values" */
export type StopsDatabaseLevelKeyValuesAggregate = {
  __typename?: 'stops_database_level_key_values_aggregate';
  aggregate?: Maybe<StopsDatabaseLevelKeyValuesAggregateFields>;
  nodes: Array<StopsDatabaseLevelKeyValues>;
};

/** aggregate fields of "level_key_values" */
export type StopsDatabaseLevelKeyValuesAggregateFields = {
  __typename?: 'stops_database_level_key_values_aggregate_fields';
  avg?: Maybe<StopsDatabaseLevelKeyValuesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseLevelKeyValuesMaxFields>;
  min?: Maybe<StopsDatabaseLevelKeyValuesMinFields>;
  stddev?: Maybe<StopsDatabaseLevelKeyValuesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseLevelKeyValuesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseLevelKeyValuesStddevSampFields>;
  sum?: Maybe<StopsDatabaseLevelKeyValuesSumFields>;
  var_pop?: Maybe<StopsDatabaseLevelKeyValuesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseLevelKeyValuesVarSampFields>;
  variance?: Maybe<StopsDatabaseLevelKeyValuesVarianceFields>;
};

/** aggregate fields of "level_key_values" */
export type StopsDatabaseLevelKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseLevelKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "level_key_values" */
export type StopsDatabaseLevelKeyValuesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseLevelKeyValuesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseLevelKeyValuesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseLevelKeyValuesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseLevelKeyValuesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseLevelKeyValuesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseLevelKeyValuesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseLevelKeyValuesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseLevelKeyValuesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseLevelKeyValuesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseLevelKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "level_key_values" */
export type StopsDatabaseLevelKeyValuesArrRelInsertInput = {
  data: Array<StopsDatabaseLevelKeyValuesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseLevelKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseLevelKeyValuesAvgFields = {
  __typename?: 'stops_database_level_key_values_avg_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  level_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "level_key_values" */
export type StopsDatabaseLevelKeyValuesAvgOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  level_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "level_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseLevelKeyValuesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseLevelKeyValuesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseLevelKeyValuesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseLevelKeyValuesBoolExp>>;
  key_values_id?: InputMaybe<BigintComparisonExp>;
  key_values_key?: InputMaybe<StringComparisonExp>;
  level_id?: InputMaybe<BigintComparisonExp>;
  value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "level_key_values" */
export enum StopsDatabaseLevelKeyValuesConstraint {
  /** unique or primary key constraint on columns "level_id", "key_values_key" */
  LevelKeyValuesPkey = 'level_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  Uk_4eghmku46yje2lg3f1u6p949e = 'uk_4eghmku46yje2lg3f1u6p949e',
}

/** input type for incrementing numeric columns in table "level_key_values" */
export type StopsDatabaseLevelKeyValuesIncInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  level_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "level_key_values" */
export type StopsDatabaseLevelKeyValuesInsertInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  level_id?: InputMaybe<Scalars['bigint']>;
  value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseLevelKeyValuesMaxFields = {
  __typename?: 'stops_database_level_key_values_max_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
  level_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "level_key_values" */
export type StopsDatabaseLevelKeyValuesMaxOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  level_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseLevelKeyValuesMinFields = {
  __typename?: 'stops_database_level_key_values_min_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
  level_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "level_key_values" */
export type StopsDatabaseLevelKeyValuesMinOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  level_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "level_key_values" */
export type StopsDatabaseLevelKeyValuesMutationResponse = {
  __typename?: 'stops_database_level_key_values_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseLevelKeyValues>;
};

/** on_conflict condition type for table "level_key_values" */
export type StopsDatabaseLevelKeyValuesOnConflict = {
  constraint: StopsDatabaseLevelKeyValuesConstraint;
  update_columns?: Array<StopsDatabaseLevelKeyValuesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseLevelKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "level_key_values". */
export type StopsDatabaseLevelKeyValuesOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  level_id?: InputMaybe<OrderBy>;
  value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: level_key_values */
export type StopsDatabaseLevelKeyValuesPkColumnsInput = {
  key_values_key: Scalars['String'];
  level_id: Scalars['bigint'];
};

/** select columns of table "level_key_values" */
export enum StopsDatabaseLevelKeyValuesSelectColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  LevelId = 'level_id',
}

/** input type for updating data in table "level_key_values" */
export type StopsDatabaseLevelKeyValuesSetInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  level_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseLevelKeyValuesStddevFields = {
  __typename?: 'stops_database_level_key_values_stddev_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  level_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "level_key_values" */
export type StopsDatabaseLevelKeyValuesStddevOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  level_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseLevelKeyValuesStddevPopFields = {
  __typename?: 'stops_database_level_key_values_stddev_pop_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  level_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "level_key_values" */
export type StopsDatabaseLevelKeyValuesStddevPopOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  level_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseLevelKeyValuesStddevSampFields = {
  __typename?: 'stops_database_level_key_values_stddev_samp_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  level_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "level_key_values" */
export type StopsDatabaseLevelKeyValuesStddevSampOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  level_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "level_key_values" */
export type StopsDatabaseLevelKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseLevelKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseLevelKeyValuesStreamCursorValueInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  level_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseLevelKeyValuesSumFields = {
  __typename?: 'stops_database_level_key_values_sum_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  level_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "level_key_values" */
export type StopsDatabaseLevelKeyValuesSumOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  level_id?: InputMaybe<OrderBy>;
};

/** update columns of table "level_key_values" */
export enum StopsDatabaseLevelKeyValuesUpdateColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  LevelId = 'level_id',
}

export type StopsDatabaseLevelKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseLevelKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseLevelKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseLevelKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseLevelKeyValuesVarPopFields = {
  __typename?: 'stops_database_level_key_values_var_pop_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  level_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "level_key_values" */
export type StopsDatabaseLevelKeyValuesVarPopOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  level_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseLevelKeyValuesVarSampFields = {
  __typename?: 'stops_database_level_key_values_var_samp_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  level_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "level_key_values" */
export type StopsDatabaseLevelKeyValuesVarSampOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  level_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseLevelKeyValuesVarianceFields = {
  __typename?: 'stops_database_level_key_values_variance_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  level_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "level_key_values" */
export type StopsDatabaseLevelKeyValuesVarianceOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  level_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseLevelMaxFields = {
  __typename?: 'stops_database_level_max_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_id?: Maybe<Scalars['bigint']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  name_id?: Maybe<Scalars['bigint']>;
  netex_id?: Maybe<Scalars['String']>;
  public_code?: Maybe<Scalars['String']>;
  short_name_id?: Maybe<Scalars['bigint']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseLevelMinFields = {
  __typename?: 'stops_database_level_min_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_id?: Maybe<Scalars['bigint']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  name_id?: Maybe<Scalars['bigint']>;
  netex_id?: Maybe<Scalars['String']>;
  public_code?: Maybe<Scalars['String']>;
  short_name_id?: Maybe<Scalars['bigint']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "level" */
export type StopsDatabaseLevelMutationResponse = {
  __typename?: 'stops_database_level_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseLevel>;
};

/** on_conflict condition type for table "level" */
export type StopsDatabaseLevelOnConflict = {
  constraint: StopsDatabaseLevelConstraint;
  update_columns?: Array<StopsDatabaseLevelUpdateColumn>;
  where?: InputMaybe<StopsDatabaseLevelBoolExp>;
};

/** Ordering options when selecting data from "level". */
export type StopsDatabaseLevelOrderBy = {
  all_areas_wheelchair_accessible?: InputMaybe<OrderBy>;
  changed?: InputMaybe<OrderBy>;
  changed_by?: InputMaybe<OrderBy>;
  created?: InputMaybe<OrderBy>;
  description_id?: InputMaybe<OrderBy>;
  from_date?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  level_key_values_aggregate?: InputMaybe<StopsDatabaseLevelKeyValuesAggregateOrderBy>;
  multilingualStringEntityByNameId?: InputMaybe<StopsDatabaseMultilingualStringEntityOrderBy>;
  multilingualStringEntityByShortNameId?: InputMaybe<StopsDatabaseMultilingualStringEntityOrderBy>;
  multilingual_string_entity?: InputMaybe<StopsDatabaseMultilingualStringEntityOrderBy>;
  name_id?: InputMaybe<OrderBy>;
  netex_id?: InputMaybe<OrderBy>;
  public_code?: InputMaybe<OrderBy>;
  public_use?: InputMaybe<OrderBy>;
  short_name_id?: InputMaybe<OrderBy>;
  to_date?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
  version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: level */
export type StopsDatabaseLevelPkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "level" */
export enum StopsDatabaseLevelSelectColumn {
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionId = 'description_id',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameId = 'name_id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PublicCode = 'public_code',
  /** column name */
  PublicUse = 'public_use',
  /** column name */
  ShortNameId = 'short_name_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

/** input type for updating data in table "level" */
export type StopsDatabaseLevelSetInput = {
  all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_id?: InputMaybe<Scalars['bigint']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_id?: InputMaybe<Scalars['bigint']>;
  netex_id?: InputMaybe<Scalars['String']>;
  public_code?: InputMaybe<Scalars['String']>;
  public_use?: InputMaybe<Scalars['Boolean']>;
  short_name_id?: InputMaybe<Scalars['bigint']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseLevelStddevFields = {
  __typename?: 'stops_database_level_stddev_fields';
  description_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  name_id?: Maybe<Scalars['Float']>;
  short_name_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseLevelStddevPopFields = {
  __typename?: 'stops_database_level_stddev_pop_fields';
  description_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  name_id?: Maybe<Scalars['Float']>;
  short_name_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseLevelStddevSampFields = {
  __typename?: 'stops_database_level_stddev_samp_fields';
  description_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  name_id?: Maybe<Scalars['Float']>;
  short_name_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "level" */
export type StopsDatabaseLevelStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseLevelStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseLevelStreamCursorValueInput = {
  all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_id?: InputMaybe<Scalars['bigint']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_id?: InputMaybe<Scalars['bigint']>;
  netex_id?: InputMaybe<Scalars['String']>;
  public_code?: InputMaybe<Scalars['String']>;
  public_use?: InputMaybe<Scalars['Boolean']>;
  short_name_id?: InputMaybe<Scalars['bigint']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseLevelSumFields = {
  __typename?: 'stops_database_level_sum_fields';
  description_id?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['bigint']>;
  name_id?: Maybe<Scalars['bigint']>;
  short_name_id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['bigint']>;
};

/** update columns of table "level" */
export enum StopsDatabaseLevelUpdateColumn {
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionId = 'description_id',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameId = 'name_id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PublicCode = 'public_code',
  /** column name */
  PublicUse = 'public_use',
  /** column name */
  ShortNameId = 'short_name_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

export type StopsDatabaseLevelUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseLevelIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseLevelSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseLevelBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseLevelVarPopFields = {
  __typename?: 'stops_database_level_var_pop_fields';
  description_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  name_id?: Maybe<Scalars['Float']>;
  short_name_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseLevelVarSampFields = {
  __typename?: 'stops_database_level_var_samp_fields';
  description_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  name_id?: Maybe<Scalars['Float']>;
  short_name_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseLevelVarianceFields = {
  __typename?: 'stops_database_level_variance_fields';
  description_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  name_id?: Maybe<Scalars['Float']>;
  short_name_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "multilingual_string_entity" */
export type StopsDatabaseMultilingualStringEntity = {
  __typename?: 'stops_database_multilingual_string_entity';
  id: Scalars['bigint'];
  lang?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregated selection of "multilingual_string_entity" */
export type StopsDatabaseMultilingualStringEntityAggregate = {
  __typename?: 'stops_database_multilingual_string_entity_aggregate';
  aggregate?: Maybe<StopsDatabaseMultilingualStringEntityAggregateFields>;
  nodes: Array<StopsDatabaseMultilingualStringEntity>;
};

/** aggregate fields of "multilingual_string_entity" */
export type StopsDatabaseMultilingualStringEntityAggregateFields = {
  __typename?: 'stops_database_multilingual_string_entity_aggregate_fields';
  avg?: Maybe<StopsDatabaseMultilingualStringEntityAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseMultilingualStringEntityMaxFields>;
  min?: Maybe<StopsDatabaseMultilingualStringEntityMinFields>;
  stddev?: Maybe<StopsDatabaseMultilingualStringEntityStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseMultilingualStringEntityStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseMultilingualStringEntityStddevSampFields>;
  sum?: Maybe<StopsDatabaseMultilingualStringEntitySumFields>;
  var_pop?: Maybe<StopsDatabaseMultilingualStringEntityVarPopFields>;
  var_samp?: Maybe<StopsDatabaseMultilingualStringEntityVarSampFields>;
  variance?: Maybe<StopsDatabaseMultilingualStringEntityVarianceFields>;
};

/** aggregate fields of "multilingual_string_entity" */
export type StopsDatabaseMultilingualStringEntityAggregateFieldsCountArgs = {
  columns?: InputMaybe<
    Array<StopsDatabaseMultilingualStringEntitySelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseMultilingualStringEntityAvgFields = {
  __typename?: 'stops_database_multilingual_string_entity_avg_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "multilingual_string_entity". All fields are combined with a logical 'AND'. */
export type StopsDatabaseMultilingualStringEntityBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseMultilingualStringEntityBoolExp>>;
  _not?: InputMaybe<StopsDatabaseMultilingualStringEntityBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseMultilingualStringEntityBoolExp>>;
  id?: InputMaybe<BigintComparisonExp>;
  lang?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "multilingual_string_entity" */
export enum StopsDatabaseMultilingualStringEntityConstraint {
  /** unique or primary key constraint on columns "id" */
  MultilingualStringEntityPkey = 'multilingual_string_entity_pkey',
}

/** input type for incrementing numeric columns in table "multilingual_string_entity" */
export type StopsDatabaseMultilingualStringEntityIncInput = {
  id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "multilingual_string_entity" */
export type StopsDatabaseMultilingualStringEntityInsertInput = {
  id?: InputMaybe<Scalars['bigint']>;
  lang?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type StopsDatabaseMultilingualStringEntityMaxFields = {
  __typename?: 'stops_database_multilingual_string_entity_max_fields';
  id?: Maybe<Scalars['bigint']>;
  lang?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseMultilingualStringEntityMinFields = {
  __typename?: 'stops_database_multilingual_string_entity_min_fields';
  id?: Maybe<Scalars['bigint']>;
  lang?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "multilingual_string_entity" */
export type StopsDatabaseMultilingualStringEntityMutationResponse = {
  __typename?: 'stops_database_multilingual_string_entity_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseMultilingualStringEntity>;
};

/** input type for inserting object relation for remote table "multilingual_string_entity" */
export type StopsDatabaseMultilingualStringEntityObjRelInsertInput = {
  data: StopsDatabaseMultilingualStringEntityInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseMultilingualStringEntityOnConflict>;
};

/** on_conflict condition type for table "multilingual_string_entity" */
export type StopsDatabaseMultilingualStringEntityOnConflict = {
  constraint: StopsDatabaseMultilingualStringEntityConstraint;
  update_columns?: Array<StopsDatabaseMultilingualStringEntityUpdateColumn>;
  where?: InputMaybe<StopsDatabaseMultilingualStringEntityBoolExp>;
};

/** Ordering options when selecting data from "multilingual_string_entity". */
export type StopsDatabaseMultilingualStringEntityOrderBy = {
  id?: InputMaybe<OrderBy>;
  lang?: InputMaybe<OrderBy>;
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: multilingual_string_entity */
export type StopsDatabaseMultilingualStringEntityPkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "multilingual_string_entity" */
export enum StopsDatabaseMultilingualStringEntitySelectColumn {
  /** column name */
  Id = 'id',
  /** column name */
  Lang = 'lang',
  /** column name */
  Value = 'value',
}

/** input type for updating data in table "multilingual_string_entity" */
export type StopsDatabaseMultilingualStringEntitySetInput = {
  id?: InputMaybe<Scalars['bigint']>;
  lang?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseMultilingualStringEntityStddevFields = {
  __typename?: 'stops_database_multilingual_string_entity_stddev_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseMultilingualStringEntityStddevPopFields = {
  __typename?: 'stops_database_multilingual_string_entity_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseMultilingualStringEntityStddevSampFields = {
  __typename?: 'stops_database_multilingual_string_entity_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "multilingual_string_entity" */
export type StopsDatabaseMultilingualStringEntityStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseMultilingualStringEntityStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseMultilingualStringEntityStreamCursorValueInput = {
  id?: InputMaybe<Scalars['bigint']>;
  lang?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseMultilingualStringEntitySumFields = {
  __typename?: 'stops_database_multilingual_string_entity_sum_fields';
  id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "multilingual_string_entity" */
export enum StopsDatabaseMultilingualStringEntityUpdateColumn {
  /** column name */
  Id = 'id',
  /** column name */
  Lang = 'lang',
  /** column name */
  Value = 'value',
}

export type StopsDatabaseMultilingualStringEntityUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseMultilingualStringEntityIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseMultilingualStringEntitySetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseMultilingualStringEntityBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseMultilingualStringEntityVarPopFields = {
  __typename?: 'stops_database_multilingual_string_entity_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseMultilingualStringEntityVarSampFields = {
  __typename?: 'stops_database_multilingual_string_entity_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseMultilingualStringEntityVarianceFields = {
  __typename?: 'stops_database_multilingual_string_entity_variance_fields';
  id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "navigation_path" */
export type StopsDatabaseNavigationPath = {
  __typename?: 'stops_database_navigation_path';
  id: Scalars['String'];
  item_type?: Maybe<Scalars['String']>;
  path_id: Scalars['Int'];
};

/** aggregated selection of "navigation_path" */
export type StopsDatabaseNavigationPathAggregate = {
  __typename?: 'stops_database_navigation_path_aggregate';
  aggregate?: Maybe<StopsDatabaseNavigationPathAggregateFields>;
  nodes: Array<StopsDatabaseNavigationPath>;
};

/** aggregate fields of "navigation_path" */
export type StopsDatabaseNavigationPathAggregateFields = {
  __typename?: 'stops_database_navigation_path_aggregate_fields';
  avg?: Maybe<StopsDatabaseNavigationPathAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseNavigationPathMaxFields>;
  min?: Maybe<StopsDatabaseNavigationPathMinFields>;
  stddev?: Maybe<StopsDatabaseNavigationPathStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseNavigationPathStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseNavigationPathStddevSampFields>;
  sum?: Maybe<StopsDatabaseNavigationPathSumFields>;
  var_pop?: Maybe<StopsDatabaseNavigationPathVarPopFields>;
  var_samp?: Maybe<StopsDatabaseNavigationPathVarSampFields>;
  variance?: Maybe<StopsDatabaseNavigationPathVarianceFields>;
};

/** aggregate fields of "navigation_path" */
export type StopsDatabaseNavigationPathAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseNavigationPathSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseNavigationPathAvgFields = {
  __typename?: 'stops_database_navigation_path_avg_fields';
  path_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "navigation_path". All fields are combined with a logical 'AND'. */
export type StopsDatabaseNavigationPathBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseNavigationPathBoolExp>>;
  _not?: InputMaybe<StopsDatabaseNavigationPathBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseNavigationPathBoolExp>>;
  id?: InputMaybe<StringComparisonExp>;
  item_type?: InputMaybe<StringComparisonExp>;
  path_id?: InputMaybe<IntComparisonExp>;
};

/** input type for incrementing numeric columns in table "navigation_path" */
export type StopsDatabaseNavigationPathIncInput = {
  path_id?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "navigation_path" */
export type StopsDatabaseNavigationPathInsertInput = {
  id?: InputMaybe<Scalars['String']>;
  item_type?: InputMaybe<Scalars['String']>;
  path_id?: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type StopsDatabaseNavigationPathMaxFields = {
  __typename?: 'stops_database_navigation_path_max_fields';
  id?: Maybe<Scalars['String']>;
  item_type?: Maybe<Scalars['String']>;
  path_id?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type StopsDatabaseNavigationPathMinFields = {
  __typename?: 'stops_database_navigation_path_min_fields';
  id?: Maybe<Scalars['String']>;
  item_type?: Maybe<Scalars['String']>;
  path_id?: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "navigation_path" */
export type StopsDatabaseNavigationPathMutationResponse = {
  __typename?: 'stops_database_navigation_path_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseNavigationPath>;
};

/** Ordering options when selecting data from "navigation_path". */
export type StopsDatabaseNavigationPathOrderBy = {
  id?: InputMaybe<OrderBy>;
  item_type?: InputMaybe<OrderBy>;
  path_id?: InputMaybe<OrderBy>;
};

/** select columns of table "navigation_path" */
export enum StopsDatabaseNavigationPathSelectColumn {
  /** column name */
  Id = 'id',
  /** column name */
  ItemType = 'item_type',
  /** column name */
  PathId = 'path_id',
}

/** input type for updating data in table "navigation_path" */
export type StopsDatabaseNavigationPathSetInput = {
  id?: InputMaybe<Scalars['String']>;
  item_type?: InputMaybe<Scalars['String']>;
  path_id?: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseNavigationPathStddevFields = {
  __typename?: 'stops_database_navigation_path_stddev_fields';
  path_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseNavigationPathStddevPopFields = {
  __typename?: 'stops_database_navigation_path_stddev_pop_fields';
  path_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseNavigationPathStddevSampFields = {
  __typename?: 'stops_database_navigation_path_stddev_samp_fields';
  path_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "navigation_path" */
export type StopsDatabaseNavigationPathStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseNavigationPathStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseNavigationPathStreamCursorValueInput = {
  id?: InputMaybe<Scalars['String']>;
  item_type?: InputMaybe<Scalars['String']>;
  path_id?: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type StopsDatabaseNavigationPathSumFields = {
  __typename?: 'stops_database_navigation_path_sum_fields';
  path_id?: Maybe<Scalars['Int']>;
};

export type StopsDatabaseNavigationPathUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseNavigationPathIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseNavigationPathSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseNavigationPathBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseNavigationPathVarPopFields = {
  __typename?: 'stops_database_navigation_path_var_pop_fields';
  path_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseNavigationPathVarSampFields = {
  __typename?: 'stops_database_navigation_path_var_samp_fields';
  path_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseNavigationPathVarianceFields = {
  __typename?: 'stops_database_navigation_path_variance_fields';
  path_id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "parking" */
export type StopsDatabaseParking = {
  __typename?: 'stops_database_parking';
  /** An object relationship */
  accessibility_assessment?: Maybe<StopsDatabaseAccessibilityAssessment>;
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  all_areas_wheelchair_accessible?: Maybe<Scalars['Boolean']>;
  booking_url?: Maybe<Scalars['String']>;
  centroid?: Maybe<Scalars['geometry']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  covered?: Maybe<Scalars['Int']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  free_parking_out_of_hours?: Maybe<Scalars['Boolean']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id: Scalars['bigint'];
  /** An object relationship */
  installed_equipment_version_structure?: Maybe<StopsDatabaseInstalledEquipmentVersionStructure>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  number_of_parking_levels?: Maybe<Scalars['numeric']>;
  overnight_parking_permitted?: Maybe<Scalars['Boolean']>;
  parent_site_ref?: Maybe<Scalars['String']>;
  parent_site_ref_version?: Maybe<Scalars['String']>;
  /** An array relationship */
  parking_alternative_names: Array<StopsDatabaseParkingAlternativeNames>;
  /** An aggregate relationship */
  parking_alternative_names_aggregate: StopsDatabaseParkingAlternativeNamesAggregate;
  /** An array relationship */
  parking_equipment_places: Array<StopsDatabaseParkingEquipmentPlaces>;
  /** An aggregate relationship */
  parking_equipment_places_aggregate: StopsDatabaseParkingEquipmentPlacesAggregate;
  /** An array relationship */
  parking_key_values: Array<StopsDatabaseParkingKeyValues>;
  /** An aggregate relationship */
  parking_key_values_aggregate: StopsDatabaseParkingKeyValuesAggregate;
  parking_layout?: Maybe<Scalars['Int']>;
  /** An array relationship */
  parking_parking_areas: Array<StopsDatabaseParkingParkingAreas>;
  /** An aggregate relationship */
  parking_parking_areas_aggregate: StopsDatabaseParkingParkingAreasAggregate;
  /** An array relationship */
  parking_parking_payment_processes: Array<StopsDatabaseParkingParkingPaymentProcess>;
  /** An aggregate relationship */
  parking_parking_payment_processes_aggregate: StopsDatabaseParkingParkingPaymentProcessAggregate;
  /** An array relationship */
  parking_parking_properties: Array<StopsDatabaseParkingParkingProperties>;
  /** An aggregate relationship */
  parking_parking_properties_aggregate: StopsDatabaseParkingParkingPropertiesAggregate;
  /** An array relationship */
  parking_parking_vehicle_types: Array<StopsDatabaseParkingParkingVehicleTypes>;
  /** An aggregate relationship */
  parking_parking_vehicle_types_aggregate: StopsDatabaseParkingParkingVehicleTypesAggregate;
  parking_reservation?: Maybe<Scalars['Int']>;
  parking_type?: Maybe<Scalars['String']>;
  /** An object relationship */
  persistable_polygon?: Maybe<StopsDatabasePersistablePolygon>;
  place_equipments_id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  principal_capacity?: Maybe<Scalars['numeric']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  prohibited_for_hazardous_materials?: Maybe<Scalars['Boolean']>;
  real_time_occupancy_available?: Maybe<Scalars['Boolean']>;
  recharging_available?: Maybe<Scalars['Boolean']>;
  secure?: Maybe<Scalars['Boolean']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  /** An object relationship */
  topographic_place?: Maybe<StopsDatabaseTopographicPlace>;
  topographic_place_id?: Maybe<Scalars['bigint']>;
  total_capacity?: Maybe<Scalars['numeric']>;
  version: Scalars['bigint'];
  version_comment?: Maybe<Scalars['String']>;
};

/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingAlternativeNamesArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseParkingAlternativeNamesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseParkingAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAlternativeNamesBoolExp>;
};

/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseParkingAlternativeNamesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseParkingAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAlternativeNamesBoolExp>;
};

/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingEquipmentPlacesArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseParkingEquipmentPlacesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseParkingEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingEquipmentPlacesBoolExp>;
};

/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingEquipmentPlacesAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseParkingEquipmentPlacesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseParkingEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingEquipmentPlacesBoolExp>;
};

/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingKeyValuesArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseParkingKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseParkingKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingKeyValuesBoolExp>;
};

/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseParkingKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseParkingKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingKeyValuesBoolExp>;
};

/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingParkingAreasArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseParkingParkingAreasSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseParkingParkingAreasOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingAreasBoolExp>;
};

/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingParkingAreasAggregateArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseParkingParkingAreasSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseParkingParkingAreasOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingAreasBoolExp>;
};

/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingParkingPaymentProcessesArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseParkingParkingPaymentProcessSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<
    Array<StopsDatabaseParkingParkingPaymentProcessOrderBy>
  >;
  where?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessBoolExp>;
};

/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingParkingPaymentProcessesAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseParkingParkingPaymentProcessSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<
    Array<StopsDatabaseParkingParkingPaymentProcessOrderBy>
  >;
  where?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessBoolExp>;
};

/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingParkingPropertiesArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseParkingParkingPropertiesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseParkingParkingPropertiesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingPropertiesBoolExp>;
};

/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingParkingPropertiesAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseParkingParkingPropertiesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseParkingParkingPropertiesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingPropertiesBoolExp>;
};

/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingParkingVehicleTypesArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseParkingParkingVehicleTypesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseParkingParkingVehicleTypesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesBoolExp>;
};

/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingParkingVehicleTypesAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseParkingParkingVehicleTypesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseParkingParkingVehicleTypesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesBoolExp>;
};

/** columns and relationships of "parking_adjacent_sites" */
export type StopsDatabaseParkingAdjacentSites = {
  __typename?: 'stops_database_parking_adjacent_sites';
  parking_id: Scalars['bigint'];
  ref?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['String']>;
};

/** aggregated selection of "parking_adjacent_sites" */
export type StopsDatabaseParkingAdjacentSitesAggregate = {
  __typename?: 'stops_database_parking_adjacent_sites_aggregate';
  aggregate?: Maybe<StopsDatabaseParkingAdjacentSitesAggregateFields>;
  nodes: Array<StopsDatabaseParkingAdjacentSites>;
};

/** aggregate fields of "parking_adjacent_sites" */
export type StopsDatabaseParkingAdjacentSitesAggregateFields = {
  __typename?: 'stops_database_parking_adjacent_sites_aggregate_fields';
  avg?: Maybe<StopsDatabaseParkingAdjacentSitesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseParkingAdjacentSitesMaxFields>;
  min?: Maybe<StopsDatabaseParkingAdjacentSitesMinFields>;
  stddev?: Maybe<StopsDatabaseParkingAdjacentSitesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseParkingAdjacentSitesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseParkingAdjacentSitesStddevSampFields>;
  sum?: Maybe<StopsDatabaseParkingAdjacentSitesSumFields>;
  var_pop?: Maybe<StopsDatabaseParkingAdjacentSitesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseParkingAdjacentSitesVarSampFields>;
  variance?: Maybe<StopsDatabaseParkingAdjacentSitesVarianceFields>;
};

/** aggregate fields of "parking_adjacent_sites" */
export type StopsDatabaseParkingAdjacentSitesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseParkingAdjacentSitesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingAdjacentSitesAvgFields = {
  __typename?: 'stops_database_parking_adjacent_sites_avg_fields';
  parking_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "parking_adjacent_sites". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingAdjacentSitesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseParkingAdjacentSitesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseParkingAdjacentSitesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseParkingAdjacentSitesBoolExp>>;
  parking_id?: InputMaybe<BigintComparisonExp>;
  ref?: InputMaybe<StringComparisonExp>;
  version?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "parking_adjacent_sites" */
export type StopsDatabaseParkingAdjacentSitesIncInput = {
  parking_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "parking_adjacent_sites" */
export type StopsDatabaseParkingAdjacentSitesInsertInput = {
  parking_id?: InputMaybe<Scalars['bigint']>;
  ref?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingAdjacentSitesMaxFields = {
  __typename?: 'stops_database_parking_adjacent_sites_max_fields';
  parking_id?: Maybe<Scalars['bigint']>;
  ref?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingAdjacentSitesMinFields = {
  __typename?: 'stops_database_parking_adjacent_sites_min_fields';
  parking_id?: Maybe<Scalars['bigint']>;
  ref?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "parking_adjacent_sites" */
export type StopsDatabaseParkingAdjacentSitesMutationResponse = {
  __typename?: 'stops_database_parking_adjacent_sites_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseParkingAdjacentSites>;
};

/** Ordering options when selecting data from "parking_adjacent_sites". */
export type StopsDatabaseParkingAdjacentSitesOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
  ref?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
};

/** select columns of table "parking_adjacent_sites" */
export enum StopsDatabaseParkingAdjacentSitesSelectColumn {
  /** column name */
  ParkingId = 'parking_id',
  /** column name */
  Ref = 'ref',
  /** column name */
  Version = 'version',
}

/** input type for updating data in table "parking_adjacent_sites" */
export type StopsDatabaseParkingAdjacentSitesSetInput = {
  parking_id?: InputMaybe<Scalars['bigint']>;
  ref?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingAdjacentSitesStddevFields = {
  __typename?: 'stops_database_parking_adjacent_sites_stddev_fields';
  parking_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingAdjacentSitesStddevPopFields = {
  __typename?: 'stops_database_parking_adjacent_sites_stddev_pop_fields';
  parking_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingAdjacentSitesStddevSampFields = {
  __typename?: 'stops_database_parking_adjacent_sites_stddev_samp_fields';
  parking_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "parking_adjacent_sites" */
export type StopsDatabaseParkingAdjacentSitesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseParkingAdjacentSitesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingAdjacentSitesStreamCursorValueInput = {
  parking_id?: InputMaybe<Scalars['bigint']>;
  ref?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingAdjacentSitesSumFields = {
  __typename?: 'stops_database_parking_adjacent_sites_sum_fields';
  parking_id?: Maybe<Scalars['bigint']>;
};

export type StopsDatabaseParkingAdjacentSitesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseParkingAdjacentSitesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseParkingAdjacentSitesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseParkingAdjacentSitesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingAdjacentSitesVarPopFields = {
  __typename?: 'stops_database_parking_adjacent_sites_var_pop_fields';
  parking_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingAdjacentSitesVarSampFields = {
  __typename?: 'stops_database_parking_adjacent_sites_var_samp_fields';
  parking_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingAdjacentSitesVarianceFields = {
  __typename?: 'stops_database_parking_adjacent_sites_variance_fields';
  parking_id?: Maybe<Scalars['Float']>;
};

/** aggregated selection of "parking" */
export type StopsDatabaseParkingAggregate = {
  __typename?: 'stops_database_parking_aggregate';
  aggregate?: Maybe<StopsDatabaseParkingAggregateFields>;
  nodes: Array<StopsDatabaseParking>;
};

/** aggregate fields of "parking" */
export type StopsDatabaseParkingAggregateFields = {
  __typename?: 'stops_database_parking_aggregate_fields';
  avg?: Maybe<StopsDatabaseParkingAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseParkingMaxFields>;
  min?: Maybe<StopsDatabaseParkingMinFields>;
  stddev?: Maybe<StopsDatabaseParkingStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseParkingStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseParkingStddevSampFields>;
  sum?: Maybe<StopsDatabaseParkingSumFields>;
  var_pop?: Maybe<StopsDatabaseParkingVarPopFields>;
  var_samp?: Maybe<StopsDatabaseParkingVarSampFields>;
  variance?: Maybe<StopsDatabaseParkingVarianceFields>;
};

/** aggregate fields of "parking" */
export type StopsDatabaseParkingAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseParkingSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** columns and relationships of "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNames = {
  __typename?: 'stops_database_parking_alternative_names';
  /** An object relationship */
  alternative_name: StopsDatabaseAlternativeName;
  alternative_names_id: Scalars['bigint'];
  parking_id: Scalars['bigint'];
};

/** aggregated selection of "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesAggregate = {
  __typename?: 'stops_database_parking_alternative_names_aggregate';
  aggregate?: Maybe<StopsDatabaseParkingAlternativeNamesAggregateFields>;
  nodes: Array<StopsDatabaseParkingAlternativeNames>;
};

/** aggregate fields of "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesAggregateFields = {
  __typename?: 'stops_database_parking_alternative_names_aggregate_fields';
  avg?: Maybe<StopsDatabaseParkingAlternativeNamesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseParkingAlternativeNamesMaxFields>;
  min?: Maybe<StopsDatabaseParkingAlternativeNamesMinFields>;
  stddev?: Maybe<StopsDatabaseParkingAlternativeNamesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseParkingAlternativeNamesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseParkingAlternativeNamesStddevSampFields>;
  sum?: Maybe<StopsDatabaseParkingAlternativeNamesSumFields>;
  var_pop?: Maybe<StopsDatabaseParkingAlternativeNamesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseParkingAlternativeNamesVarSampFields>;
  variance?: Maybe<StopsDatabaseParkingAlternativeNamesVarianceFields>;
};

/** aggregate fields of "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseParkingAlternativeNamesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseParkingAlternativeNamesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseParkingAlternativeNamesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseParkingAlternativeNamesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseParkingAlternativeNamesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseParkingAlternativeNamesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseParkingAlternativeNamesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseParkingAlternativeNamesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseParkingAlternativeNamesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseParkingAlternativeNamesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseParkingAlternativeNamesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesArrRelInsertInput = {
  data: Array<StopsDatabaseParkingAlternativeNamesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseParkingAlternativeNamesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingAlternativeNamesAvgFields = {
  __typename?: 'stops_database_parking_alternative_names_avg_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesAvgOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "parking_alternative_names". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingAlternativeNamesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseParkingAlternativeNamesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseParkingAlternativeNamesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseParkingAlternativeNamesBoolExp>>;
  alternative_name?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
  alternative_names_id?: InputMaybe<BigintComparisonExp>;
  parking_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "parking_alternative_names" */
export enum StopsDatabaseParkingAlternativeNamesConstraint {
  /** unique or primary key constraint on columns "alternative_names_id" */
  UkRlf4rns9qabhhdins8l3y89fo = 'uk_rlf4rns9qabhhdins8l3y89fo',
}

/** input type for incrementing numeric columns in table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesIncInput = {
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
  parking_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesInsertInput = {
  alternative_name?: InputMaybe<StopsDatabaseAlternativeNameObjRelInsertInput>;
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
  parking_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingAlternativeNamesMaxFields = {
  __typename?: 'stops_database_parking_alternative_names_max_fields';
  alternative_names_id?: Maybe<Scalars['bigint']>;
  parking_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesMaxOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingAlternativeNamesMinFields = {
  __typename?: 'stops_database_parking_alternative_names_min_fields';
  alternative_names_id?: Maybe<Scalars['bigint']>;
  parking_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesMinOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesMutationResponse = {
  __typename?: 'stops_database_parking_alternative_names_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseParkingAlternativeNames>;
};

/** on_conflict condition type for table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesOnConflict = {
  constraint: StopsDatabaseParkingAlternativeNamesConstraint;
  update_columns?: Array<StopsDatabaseParkingAlternativeNamesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseParkingAlternativeNamesBoolExp>;
};

/** Ordering options when selecting data from "parking_alternative_names". */
export type StopsDatabaseParkingAlternativeNamesOrderBy = {
  alternative_name?: InputMaybe<StopsDatabaseAlternativeNameOrderBy>;
  alternative_names_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** select columns of table "parking_alternative_names" */
export enum StopsDatabaseParkingAlternativeNamesSelectColumn {
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
  /** column name */
  ParkingId = 'parking_id',
}

/** input type for updating data in table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesSetInput = {
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
  parking_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingAlternativeNamesStddevFields = {
  __typename?: 'stops_database_parking_alternative_names_stddev_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesStddevOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingAlternativeNamesStddevPopFields = {
  __typename?: 'stops_database_parking_alternative_names_stddev_pop_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesStddevPopOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingAlternativeNamesStddevSampFields = {
  __typename?: 'stops_database_parking_alternative_names_stddev_samp_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesStddevSampOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseParkingAlternativeNamesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingAlternativeNamesStreamCursorValueInput = {
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
  parking_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingAlternativeNamesSumFields = {
  __typename?: 'stops_database_parking_alternative_names_sum_fields';
  alternative_names_id?: Maybe<Scalars['bigint']>;
  parking_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesSumOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** update columns of table "parking_alternative_names" */
export enum StopsDatabaseParkingAlternativeNamesUpdateColumn {
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
  /** column name */
  ParkingId = 'parking_id',
}

export type StopsDatabaseParkingAlternativeNamesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseParkingAlternativeNamesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseParkingAlternativeNamesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseParkingAlternativeNamesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingAlternativeNamesVarPopFields = {
  __typename?: 'stops_database_parking_alternative_names_var_pop_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesVarPopOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingAlternativeNamesVarSampFields = {
  __typename?: 'stops_database_parking_alternative_names_var_samp_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesVarSampOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingAlternativeNamesVarianceFields = {
  __typename?: 'stops_database_parking_alternative_names_variance_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesVarianceOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** columns and relationships of "parking_area" */
export type StopsDatabaseParkingArea = {
  __typename?: 'stops_database_parking_area';
  /** An object relationship */
  accessibility_assessment?: Maybe<StopsDatabaseAccessibilityAssessment>;
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  all_areas_wheelchair_accessible?: Maybe<Scalars['Boolean']>;
  centroid?: Maybe<Scalars['geometry']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  covered?: Maybe<Scalars['Int']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id: Scalars['bigint'];
  /** An object relationship */
  installed_equipment_version_structure?: Maybe<StopsDatabaseInstalledEquipmentVersionStructure>;
  level_ref?: Maybe<Scalars['String']>;
  level_ref_version?: Maybe<Scalars['String']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  /** An array relationship */
  parking_area_alternative_names: Array<StopsDatabaseParkingAreaAlternativeNames>;
  /** An aggregate relationship */
  parking_area_alternative_names_aggregate: StopsDatabaseParkingAreaAlternativeNamesAggregate;
  /** An array relationship */
  parking_area_equipment_places: Array<StopsDatabaseParkingAreaEquipmentPlaces>;
  /** An aggregate relationship */
  parking_area_equipment_places_aggregate: StopsDatabaseParkingAreaEquipmentPlacesAggregate;
  /** An array relationship */
  parking_area_key_values: Array<StopsDatabaseParkingAreaKeyValues>;
  /** An aggregate relationship */
  parking_area_key_values_aggregate: StopsDatabaseParkingAreaKeyValuesAggregate;
  /** An object relationship */
  parking_parking_area?: Maybe<StopsDatabaseParkingParkingAreas>;
  parking_properties_id?: Maybe<Scalars['bigint']>;
  /** An object relationship */
  parking_property?: Maybe<StopsDatabaseParkingProperties>;
  /** An object relationship */
  persistable_polygon?: Maybe<StopsDatabasePersistablePolygon>;
  place_equipments_id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  site_ref?: Maybe<Scalars['String']>;
  site_ref_version?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  total_capacity?: Maybe<Scalars['numeric']>;
  version: Scalars['bigint'];
  version_comment?: Maybe<Scalars['String']>;
};

/** columns and relationships of "parking_area" */
export type StopsDatabaseParkingAreaParkingAreaAlternativeNamesArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseParkingAreaAlternativeNamesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseParkingAreaAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesBoolExp>;
};

/** columns and relationships of "parking_area" */
export type StopsDatabaseParkingAreaParkingAreaAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseParkingAreaAlternativeNamesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseParkingAreaAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesBoolExp>;
};

/** columns and relationships of "parking_area" */
export type StopsDatabaseParkingAreaParkingAreaEquipmentPlacesArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseParkingAreaEquipmentPlacesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseParkingAreaEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>;
};

/** columns and relationships of "parking_area" */
export type StopsDatabaseParkingAreaParkingAreaEquipmentPlacesAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseParkingAreaEquipmentPlacesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseParkingAreaEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>;
};

/** columns and relationships of "parking_area" */
export type StopsDatabaseParkingAreaParkingAreaKeyValuesArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseParkingAreaKeyValuesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseParkingAreaKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaKeyValuesBoolExp>;
};

/** columns and relationships of "parking_area" */
export type StopsDatabaseParkingAreaParkingAreaKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseParkingAreaKeyValuesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseParkingAreaKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaKeyValuesBoolExp>;
};

/** aggregated selection of "parking_area" */
export type StopsDatabaseParkingAreaAggregate = {
  __typename?: 'stops_database_parking_area_aggregate';
  aggregate?: Maybe<StopsDatabaseParkingAreaAggregateFields>;
  nodes: Array<StopsDatabaseParkingArea>;
};

/** aggregate fields of "parking_area" */
export type StopsDatabaseParkingAreaAggregateFields = {
  __typename?: 'stops_database_parking_area_aggregate_fields';
  avg?: Maybe<StopsDatabaseParkingAreaAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseParkingAreaMaxFields>;
  min?: Maybe<StopsDatabaseParkingAreaMinFields>;
  stddev?: Maybe<StopsDatabaseParkingAreaStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseParkingAreaStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseParkingAreaStddevSampFields>;
  sum?: Maybe<StopsDatabaseParkingAreaSumFields>;
  var_pop?: Maybe<StopsDatabaseParkingAreaVarPopFields>;
  var_samp?: Maybe<StopsDatabaseParkingAreaVarSampFields>;
  variance?: Maybe<StopsDatabaseParkingAreaVarianceFields>;
};

/** aggregate fields of "parking_area" */
export type StopsDatabaseParkingAreaAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseParkingAreaSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** columns and relationships of "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNames = {
  __typename?: 'stops_database_parking_area_alternative_names';
  /** An object relationship */
  alternative_name: StopsDatabaseAlternativeName;
  alternative_names_id: Scalars['bigint'];
  parking_area_id: Scalars['bigint'];
};

/** aggregated selection of "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesAggregate = {
  __typename?: 'stops_database_parking_area_alternative_names_aggregate';
  aggregate?: Maybe<StopsDatabaseParkingAreaAlternativeNamesAggregateFields>;
  nodes: Array<StopsDatabaseParkingAreaAlternativeNames>;
};

/** aggregate fields of "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesAggregateFields = {
  __typename?: 'stops_database_parking_area_alternative_names_aggregate_fields';
  avg?: Maybe<StopsDatabaseParkingAreaAlternativeNamesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseParkingAreaAlternativeNamesMaxFields>;
  min?: Maybe<StopsDatabaseParkingAreaAlternativeNamesMinFields>;
  stddev?: Maybe<StopsDatabaseParkingAreaAlternativeNamesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseParkingAreaAlternativeNamesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseParkingAreaAlternativeNamesStddevSampFields>;
  sum?: Maybe<StopsDatabaseParkingAreaAlternativeNamesSumFields>;
  var_pop?: Maybe<StopsDatabaseParkingAreaAlternativeNamesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseParkingAreaAlternativeNamesVarSampFields>;
  variance?: Maybe<StopsDatabaseParkingAreaAlternativeNamesVarianceFields>;
};

/** aggregate fields of "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesAggregateFieldsCountArgs = {
  columns?: InputMaybe<
    Array<StopsDatabaseParkingAreaAlternativeNamesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesArrRelInsertInput = {
  data: Array<StopsDatabaseParkingAreaAlternativeNamesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingAreaAlternativeNamesAvgFields = {
  __typename?: 'stops_database_parking_area_alternative_names_avg_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesAvgOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "parking_area_alternative_names". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingAreaAlternativeNamesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseParkingAreaAlternativeNamesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseParkingAreaAlternativeNamesBoolExp>>;
  alternative_name?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
  alternative_names_id?: InputMaybe<BigintComparisonExp>;
  parking_area_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "parking_area_alternative_names" */
export enum StopsDatabaseParkingAreaAlternativeNamesConstraint {
  /** unique or primary key constraint on columns "alternative_names_id" */
  UkHb8tvxumnj3j12b5i3a161lcm = 'uk_hb8tvxumnj3j12b5i3a161lcm',
}

/** input type for incrementing numeric columns in table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesIncInput = {
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
  parking_area_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesInsertInput = {
  alternative_name?: InputMaybe<StopsDatabaseAlternativeNameObjRelInsertInput>;
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
  parking_area_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingAreaAlternativeNamesMaxFields = {
  __typename?: 'stops_database_parking_area_alternative_names_max_fields';
  alternative_names_id?: Maybe<Scalars['bigint']>;
  parking_area_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesMaxOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingAreaAlternativeNamesMinFields = {
  __typename?: 'stops_database_parking_area_alternative_names_min_fields';
  alternative_names_id?: Maybe<Scalars['bigint']>;
  parking_area_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesMinOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesMutationResponse = {
  __typename?: 'stops_database_parking_area_alternative_names_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseParkingAreaAlternativeNames>;
};

/** on_conflict condition type for table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesOnConflict = {
  constraint: StopsDatabaseParkingAreaAlternativeNamesConstraint;
  update_columns?: Array<StopsDatabaseParkingAreaAlternativeNamesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesBoolExp>;
};

/** Ordering options when selecting data from "parking_area_alternative_names". */
export type StopsDatabaseParkingAreaAlternativeNamesOrderBy = {
  alternative_name?: InputMaybe<StopsDatabaseAlternativeNameOrderBy>;
  alternative_names_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** select columns of table "parking_area_alternative_names" */
export enum StopsDatabaseParkingAreaAlternativeNamesSelectColumn {
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
  /** column name */
  ParkingAreaId = 'parking_area_id',
}

/** input type for updating data in table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesSetInput = {
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
  parking_area_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingAreaAlternativeNamesStddevFields = {
  __typename?: 'stops_database_parking_area_alternative_names_stddev_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesStddevOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingAreaAlternativeNamesStddevPopFields = {
  __typename?: 'stops_database_parking_area_alternative_names_stddev_pop_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesStddevPopOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingAreaAlternativeNamesStddevSampFields = {
  __typename?: 'stops_database_parking_area_alternative_names_stddev_samp_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesStddevSampOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseParkingAreaAlternativeNamesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingAreaAlternativeNamesStreamCursorValueInput = {
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
  parking_area_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingAreaAlternativeNamesSumFields = {
  __typename?: 'stops_database_parking_area_alternative_names_sum_fields';
  alternative_names_id?: Maybe<Scalars['bigint']>;
  parking_area_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesSumOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** update columns of table "parking_area_alternative_names" */
export enum StopsDatabaseParkingAreaAlternativeNamesUpdateColumn {
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
  /** column name */
  ParkingAreaId = 'parking_area_id',
}

export type StopsDatabaseParkingAreaAlternativeNamesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseParkingAreaAlternativeNamesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingAreaAlternativeNamesVarPopFields = {
  __typename?: 'stops_database_parking_area_alternative_names_var_pop_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesVarPopOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingAreaAlternativeNamesVarSampFields = {
  __typename?: 'stops_database_parking_area_alternative_names_var_samp_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesVarSampOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingAreaAlternativeNamesVarianceFields = {
  __typename?: 'stops_database_parking_area_alternative_names_variance_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesVarianceOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingAreaAvgFields = {
  __typename?: 'stops_database_parking_area_avg_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  parking_properties_id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  total_capacity?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "parking_area". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingAreaBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseParkingAreaBoolExp>>;
  _not?: InputMaybe<StopsDatabaseParkingAreaBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseParkingAreaBoolExp>>;
  accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentBoolExp>;
  accessibility_assessment_id?: InputMaybe<BigintComparisonExp>;
  all_areas_wheelchair_accessible?: InputMaybe<BooleanComparisonExp>;
  centroid?: InputMaybe<GeometryComparisonExp>;
  changed?: InputMaybe<TimestampComparisonExp>;
  changed_by?: InputMaybe<StringComparisonExp>;
  covered?: InputMaybe<IntComparisonExp>;
  created?: InputMaybe<TimestampComparisonExp>;
  description_lang?: InputMaybe<StringComparisonExp>;
  description_value?: InputMaybe<StringComparisonExp>;
  from_date?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
  level_ref?: InputMaybe<StringComparisonExp>;
  level_ref_version?: InputMaybe<StringComparisonExp>;
  name_lang?: InputMaybe<StringComparisonExp>;
  name_value?: InputMaybe<StringComparisonExp>;
  netex_id?: InputMaybe<StringComparisonExp>;
  parking_area_alternative_names?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesBoolExp>;
  parking_area_alternative_names_aggregate?: InputMaybe<ParkingAreaAlternativeNamesAggregateBoolExp>;
  parking_area_equipment_places?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>;
  parking_area_equipment_places_aggregate?: InputMaybe<ParkingAreaEquipmentPlacesAggregateBoolExp>;
  parking_area_key_values?: InputMaybe<StopsDatabaseParkingAreaKeyValuesBoolExp>;
  parking_area_key_values_aggregate?: InputMaybe<ParkingAreaKeyValuesAggregateBoolExp>;
  parking_parking_area?: InputMaybe<StopsDatabaseParkingParkingAreasBoolExp>;
  parking_properties_id?: InputMaybe<BigintComparisonExp>;
  parking_property?: InputMaybe<StopsDatabaseParkingPropertiesBoolExp>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  place_equipments_id?: InputMaybe<BigintComparisonExp>;
  polygon_id?: InputMaybe<BigintComparisonExp>;
  private_code_type?: InputMaybe<StringComparisonExp>;
  private_code_value?: InputMaybe<StringComparisonExp>;
  short_name_lang?: InputMaybe<StringComparisonExp>;
  short_name_value?: InputMaybe<StringComparisonExp>;
  site_ref?: InputMaybe<StringComparisonExp>;
  site_ref_version?: InputMaybe<StringComparisonExp>;
  to_date?: InputMaybe<TimestampComparisonExp>;
  total_capacity?: InputMaybe<NumericComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
  version_comment?: InputMaybe<StringComparisonExp>;
};

/** columns and relationships of "parking_area_check_constraints" */
export type StopsDatabaseParkingAreaCheckConstraints = {
  __typename?: 'stops_database_parking_area_check_constraints';
  check_constraints_id: Scalars['bigint'];
  parking_area_id: Scalars['bigint'];
};

/** aggregated selection of "parking_area_check_constraints" */
export type StopsDatabaseParkingAreaCheckConstraintsAggregate = {
  __typename?: 'stops_database_parking_area_check_constraints_aggregate';
  aggregate?: Maybe<StopsDatabaseParkingAreaCheckConstraintsAggregateFields>;
  nodes: Array<StopsDatabaseParkingAreaCheckConstraints>;
};

/** aggregate fields of "parking_area_check_constraints" */
export type StopsDatabaseParkingAreaCheckConstraintsAggregateFields = {
  __typename?: 'stops_database_parking_area_check_constraints_aggregate_fields';
  avg?: Maybe<StopsDatabaseParkingAreaCheckConstraintsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseParkingAreaCheckConstraintsMaxFields>;
  min?: Maybe<StopsDatabaseParkingAreaCheckConstraintsMinFields>;
  stddev?: Maybe<StopsDatabaseParkingAreaCheckConstraintsStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseParkingAreaCheckConstraintsStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseParkingAreaCheckConstraintsStddevSampFields>;
  sum?: Maybe<StopsDatabaseParkingAreaCheckConstraintsSumFields>;
  var_pop?: Maybe<StopsDatabaseParkingAreaCheckConstraintsVarPopFields>;
  var_samp?: Maybe<StopsDatabaseParkingAreaCheckConstraintsVarSampFields>;
  variance?: Maybe<StopsDatabaseParkingAreaCheckConstraintsVarianceFields>;
};

/** aggregate fields of "parking_area_check_constraints" */
export type StopsDatabaseParkingAreaCheckConstraintsAggregateFieldsCountArgs = {
  columns?: InputMaybe<
    Array<StopsDatabaseParkingAreaCheckConstraintsSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingAreaCheckConstraintsAvgFields = {
  __typename?: 'stops_database_parking_area_check_constraints_avg_fields';
  check_constraints_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "parking_area_check_constraints". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingAreaCheckConstraintsBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseParkingAreaCheckConstraintsBoolExp>>;
  _not?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseParkingAreaCheckConstraintsBoolExp>>;
  check_constraints_id?: InputMaybe<BigintComparisonExp>;
  parking_area_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "parking_area_check_constraints" */
export enum StopsDatabaseParkingAreaCheckConstraintsConstraint {
  /** unique or primary key constraint on columns "check_constraints_id" */
  Uk_1vh5s3bg8ag28aip9fbx1l32r = 'uk_1vh5s3bg8ag28aip9fbx1l32r',
}

/** input type for incrementing numeric columns in table "parking_area_check_constraints" */
export type StopsDatabaseParkingAreaCheckConstraintsIncInput = {
  check_constraints_id?: InputMaybe<Scalars['bigint']>;
  parking_area_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "parking_area_check_constraints" */
export type StopsDatabaseParkingAreaCheckConstraintsInsertInput = {
  check_constraints_id?: InputMaybe<Scalars['bigint']>;
  parking_area_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingAreaCheckConstraintsMaxFields = {
  __typename?: 'stops_database_parking_area_check_constraints_max_fields';
  check_constraints_id?: Maybe<Scalars['bigint']>;
  parking_area_id?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingAreaCheckConstraintsMinFields = {
  __typename?: 'stops_database_parking_area_check_constraints_min_fields';
  check_constraints_id?: Maybe<Scalars['bigint']>;
  parking_area_id?: Maybe<Scalars['bigint']>;
};

/** response of any mutation on the table "parking_area_check_constraints" */
export type StopsDatabaseParkingAreaCheckConstraintsMutationResponse = {
  __typename?: 'stops_database_parking_area_check_constraints_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseParkingAreaCheckConstraints>;
};

/** on_conflict condition type for table "parking_area_check_constraints" */
export type StopsDatabaseParkingAreaCheckConstraintsOnConflict = {
  constraint: StopsDatabaseParkingAreaCheckConstraintsConstraint;
  update_columns?: Array<StopsDatabaseParkingAreaCheckConstraintsUpdateColumn>;
  where?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsBoolExp>;
};

/** Ordering options when selecting data from "parking_area_check_constraints". */
export type StopsDatabaseParkingAreaCheckConstraintsOrderBy = {
  check_constraints_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** select columns of table "parking_area_check_constraints" */
export enum StopsDatabaseParkingAreaCheckConstraintsSelectColumn {
  /** column name */
  CheckConstraintsId = 'check_constraints_id',
  /** column name */
  ParkingAreaId = 'parking_area_id',
}

/** input type for updating data in table "parking_area_check_constraints" */
export type StopsDatabaseParkingAreaCheckConstraintsSetInput = {
  check_constraints_id?: InputMaybe<Scalars['bigint']>;
  parking_area_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingAreaCheckConstraintsStddevFields = {
  __typename?: 'stops_database_parking_area_check_constraints_stddev_fields';
  check_constraints_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingAreaCheckConstraintsStddevPopFields = {
  __typename?: 'stops_database_parking_area_check_constraints_stddev_pop_fields';
  check_constraints_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingAreaCheckConstraintsStddevSampFields = {
  __typename?: 'stops_database_parking_area_check_constraints_stddev_samp_fields';
  check_constraints_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "parking_area_check_constraints" */
export type StopsDatabaseParkingAreaCheckConstraintsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseParkingAreaCheckConstraintsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingAreaCheckConstraintsStreamCursorValueInput = {
  check_constraints_id?: InputMaybe<Scalars['bigint']>;
  parking_area_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingAreaCheckConstraintsSumFields = {
  __typename?: 'stops_database_parking_area_check_constraints_sum_fields';
  check_constraints_id?: Maybe<Scalars['bigint']>;
  parking_area_id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "parking_area_check_constraints" */
export enum StopsDatabaseParkingAreaCheckConstraintsUpdateColumn {
  /** column name */
  CheckConstraintsId = 'check_constraints_id',
  /** column name */
  ParkingAreaId = 'parking_area_id',
}

export type StopsDatabaseParkingAreaCheckConstraintsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseParkingAreaCheckConstraintsBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingAreaCheckConstraintsVarPopFields = {
  __typename?: 'stops_database_parking_area_check_constraints_var_pop_fields';
  check_constraints_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingAreaCheckConstraintsVarSampFields = {
  __typename?: 'stops_database_parking_area_check_constraints_var_samp_fields';
  check_constraints_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingAreaCheckConstraintsVarianceFields = {
  __typename?: 'stops_database_parking_area_check_constraints_variance_fields';
  check_constraints_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** unique or primary key constraints on table "parking_area" */
export enum StopsDatabaseParkingAreaConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  ParkingAreaNetexIdVersionConstraint = 'parking_area_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  ParkingAreaPkey = 'parking_area_pkey',
}

/** columns and relationships of "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlaces = {
  __typename?: 'stops_database_parking_area_equipment_places';
  /** An object relationship */
  equipment_place: StopsDatabaseEquipmentPlace;
  equipment_places_id: Scalars['bigint'];
  parking_area_id: Scalars['bigint'];
};

/** aggregated selection of "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesAggregate = {
  __typename?: 'stops_database_parking_area_equipment_places_aggregate';
  aggregate?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesAggregateFields>;
  nodes: Array<StopsDatabaseParkingAreaEquipmentPlaces>;
};

/** aggregate fields of "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesAggregateFields = {
  __typename?: 'stops_database_parking_area_equipment_places_aggregate_fields';
  avg?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesMaxFields>;
  min?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesMinFields>;
  stddev?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesStddevSampFields>;
  sum?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesSumFields>;
  var_pop?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesVarSampFields>;
  variance?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesVarianceFields>;
};

/** aggregate fields of "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesAggregateFieldsCountArgs = {
  columns?: InputMaybe<
    Array<StopsDatabaseParkingAreaEquipmentPlacesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesArrRelInsertInput = {
  data: Array<StopsDatabaseParkingAreaEquipmentPlacesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingAreaEquipmentPlacesAvgFields = {
  __typename?: 'stops_database_parking_area_equipment_places_avg_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesAvgOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "parking_area_equipment_places". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingAreaEquipmentPlacesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>>;
  equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceBoolExp>;
  equipment_places_id?: InputMaybe<BigintComparisonExp>;
  parking_area_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "parking_area_equipment_places" */
export enum StopsDatabaseParkingAreaEquipmentPlacesConstraint {
  /** unique or primary key constraint on columns "equipment_places_id" */
  UkLpu10934dkewquqflehpo95ye = 'uk_lpu10934dkewquqflehpo95ye',
}

/** input type for incrementing numeric columns in table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesIncInput = {
  equipment_places_id?: InputMaybe<Scalars['bigint']>;
  parking_area_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesInsertInput = {
  equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceObjRelInsertInput>;
  equipment_places_id?: InputMaybe<Scalars['bigint']>;
  parking_area_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingAreaEquipmentPlacesMaxFields = {
  __typename?: 'stops_database_parking_area_equipment_places_max_fields';
  equipment_places_id?: Maybe<Scalars['bigint']>;
  parking_area_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesMaxOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingAreaEquipmentPlacesMinFields = {
  __typename?: 'stops_database_parking_area_equipment_places_min_fields';
  equipment_places_id?: Maybe<Scalars['bigint']>;
  parking_area_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesMinOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesMutationResponse = {
  __typename?: 'stops_database_parking_area_equipment_places_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseParkingAreaEquipmentPlaces>;
};

/** on_conflict condition type for table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesOnConflict = {
  constraint: StopsDatabaseParkingAreaEquipmentPlacesConstraint;
  update_columns?: Array<StopsDatabaseParkingAreaEquipmentPlacesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>;
};

/** Ordering options when selecting data from "parking_area_equipment_places". */
export type StopsDatabaseParkingAreaEquipmentPlacesOrderBy = {
  equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceOrderBy>;
  equipment_places_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** select columns of table "parking_area_equipment_places" */
export enum StopsDatabaseParkingAreaEquipmentPlacesSelectColumn {
  /** column name */
  EquipmentPlacesId = 'equipment_places_id',
  /** column name */
  ParkingAreaId = 'parking_area_id',
}

/** input type for updating data in table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesSetInput = {
  equipment_places_id?: InputMaybe<Scalars['bigint']>;
  parking_area_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingAreaEquipmentPlacesStddevFields = {
  __typename?: 'stops_database_parking_area_equipment_places_stddev_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesStddevOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingAreaEquipmentPlacesStddevPopFields = {
  __typename?: 'stops_database_parking_area_equipment_places_stddev_pop_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesStddevPopOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingAreaEquipmentPlacesStddevSampFields = {
  __typename?: 'stops_database_parking_area_equipment_places_stddev_samp_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesStddevSampOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseParkingAreaEquipmentPlacesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingAreaEquipmentPlacesStreamCursorValueInput = {
  equipment_places_id?: InputMaybe<Scalars['bigint']>;
  parking_area_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingAreaEquipmentPlacesSumFields = {
  __typename?: 'stops_database_parking_area_equipment_places_sum_fields';
  equipment_places_id?: Maybe<Scalars['bigint']>;
  parking_area_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesSumOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** update columns of table "parking_area_equipment_places" */
export enum StopsDatabaseParkingAreaEquipmentPlacesUpdateColumn {
  /** column name */
  EquipmentPlacesId = 'equipment_places_id',
  /** column name */
  ParkingAreaId = 'parking_area_id',
}

export type StopsDatabaseParkingAreaEquipmentPlacesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseParkingAreaEquipmentPlacesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingAreaEquipmentPlacesVarPopFields = {
  __typename?: 'stops_database_parking_area_equipment_places_var_pop_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesVarPopOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingAreaEquipmentPlacesVarSampFields = {
  __typename?: 'stops_database_parking_area_equipment_places_var_samp_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesVarSampOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingAreaEquipmentPlacesVarianceFields = {
  __typename?: 'stops_database_parking_area_equipment_places_variance_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesVarianceOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** input type for incrementing numeric columns in table "parking_area" */
export type StopsDatabaseParkingAreaIncInput = {
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  covered?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['bigint']>;
  parking_properties_id?: InputMaybe<Scalars['bigint']>;
  place_equipments_id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  total_capacity?: InputMaybe<Scalars['numeric']>;
  version?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "parking_area" */
export type StopsDatabaseParkingAreaInsertInput = {
  accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentObjRelInsertInput>;
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']>;
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  covered?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureObjRelInsertInput>;
  level_ref?: InputMaybe<Scalars['String']>;
  level_ref_version?: InputMaybe<Scalars['String']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  parking_area_alternative_names?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesArrRelInsertInput>;
  parking_area_equipment_places?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesArrRelInsertInput>;
  parking_area_key_values?: InputMaybe<StopsDatabaseParkingAreaKeyValuesArrRelInsertInput>;
  parking_parking_area?: InputMaybe<StopsDatabaseParkingParkingAreasObjRelInsertInput>;
  parking_properties_id?: InputMaybe<Scalars['bigint']>;
  parking_property?: InputMaybe<StopsDatabaseParkingPropertiesObjRelInsertInput>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonObjRelInsertInput>;
  place_equipments_id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  site_ref?: InputMaybe<Scalars['String']>;
  site_ref_version?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  total_capacity?: InputMaybe<Scalars['numeric']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValues = {
  __typename?: 'stops_database_parking_area_key_values';
  key_values_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
  parking_area_id: Scalars['bigint'];
  /** An object relationship */
  value: StopsDatabaseValue;
};

/** aggregated selection of "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesAggregate = {
  __typename?: 'stops_database_parking_area_key_values_aggregate';
  aggregate?: Maybe<StopsDatabaseParkingAreaKeyValuesAggregateFields>;
  nodes: Array<StopsDatabaseParkingAreaKeyValues>;
};

/** aggregate fields of "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesAggregateFields = {
  __typename?: 'stops_database_parking_area_key_values_aggregate_fields';
  avg?: Maybe<StopsDatabaseParkingAreaKeyValuesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseParkingAreaKeyValuesMaxFields>;
  min?: Maybe<StopsDatabaseParkingAreaKeyValuesMinFields>;
  stddev?: Maybe<StopsDatabaseParkingAreaKeyValuesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseParkingAreaKeyValuesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseParkingAreaKeyValuesStddevSampFields>;
  sum?: Maybe<StopsDatabaseParkingAreaKeyValuesSumFields>;
  var_pop?: Maybe<StopsDatabaseParkingAreaKeyValuesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseParkingAreaKeyValuesVarSampFields>;
  variance?: Maybe<StopsDatabaseParkingAreaKeyValuesVarianceFields>;
};

/** aggregate fields of "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseParkingAreaKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseParkingAreaKeyValuesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseParkingAreaKeyValuesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseParkingAreaKeyValuesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseParkingAreaKeyValuesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseParkingAreaKeyValuesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseParkingAreaKeyValuesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseParkingAreaKeyValuesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseParkingAreaKeyValuesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseParkingAreaKeyValuesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseParkingAreaKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesArrRelInsertInput = {
  data: Array<StopsDatabaseParkingAreaKeyValuesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseParkingAreaKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingAreaKeyValuesAvgFields = {
  __typename?: 'stops_database_parking_area_key_values_avg_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesAvgOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "parking_area_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingAreaKeyValuesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseParkingAreaKeyValuesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseParkingAreaKeyValuesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseParkingAreaKeyValuesBoolExp>>;
  key_values_id?: InputMaybe<BigintComparisonExp>;
  key_values_key?: InputMaybe<StringComparisonExp>;
  parking_area_id?: InputMaybe<BigintComparisonExp>;
  value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "parking_area_key_values" */
export enum StopsDatabaseParkingAreaKeyValuesConstraint {
  /** unique or primary key constraint on columns "parking_area_id", "key_values_key" */
  ParkingAreaKeyValuesPkey = 'parking_area_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkRxv53i59u1pf70kxtdchlxird = 'uk_rxv53i59u1pf70kxtdchlxird',
}

/** input type for incrementing numeric columns in table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesIncInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  parking_area_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesInsertInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  parking_area_id?: InputMaybe<Scalars['bigint']>;
  value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingAreaKeyValuesMaxFields = {
  __typename?: 'stops_database_parking_area_key_values_max_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
  parking_area_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesMaxOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingAreaKeyValuesMinFields = {
  __typename?: 'stops_database_parking_area_key_values_min_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
  parking_area_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesMinOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesMutationResponse = {
  __typename?: 'stops_database_parking_area_key_values_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseParkingAreaKeyValues>;
};

/** on_conflict condition type for table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesOnConflict = {
  constraint: StopsDatabaseParkingAreaKeyValuesConstraint;
  update_columns?: Array<StopsDatabaseParkingAreaKeyValuesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseParkingAreaKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "parking_area_key_values". */
export type StopsDatabaseParkingAreaKeyValuesOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
  value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: parking_area_key_values */
export type StopsDatabaseParkingAreaKeyValuesPkColumnsInput = {
  key_values_key: Scalars['String'];
  parking_area_id: Scalars['bigint'];
};

/** select columns of table "parking_area_key_values" */
export enum StopsDatabaseParkingAreaKeyValuesSelectColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  ParkingAreaId = 'parking_area_id',
}

/** input type for updating data in table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesSetInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  parking_area_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingAreaKeyValuesStddevFields = {
  __typename?: 'stops_database_parking_area_key_values_stddev_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesStddevOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingAreaKeyValuesStddevPopFields = {
  __typename?: 'stops_database_parking_area_key_values_stddev_pop_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesStddevPopOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingAreaKeyValuesStddevSampFields = {
  __typename?: 'stops_database_parking_area_key_values_stddev_samp_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesStddevSampOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseParkingAreaKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingAreaKeyValuesStreamCursorValueInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  parking_area_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingAreaKeyValuesSumFields = {
  __typename?: 'stops_database_parking_area_key_values_sum_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  parking_area_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesSumOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** update columns of table "parking_area_key_values" */
export enum StopsDatabaseParkingAreaKeyValuesUpdateColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  ParkingAreaId = 'parking_area_id',
}

export type StopsDatabaseParkingAreaKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseParkingAreaKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseParkingAreaKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseParkingAreaKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingAreaKeyValuesVarPopFields = {
  __typename?: 'stops_database_parking_area_key_values_var_pop_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesVarPopOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingAreaKeyValuesVarSampFields = {
  __typename?: 'stops_database_parking_area_key_values_var_samp_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesVarSampOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingAreaKeyValuesVarianceFields = {
  __typename?: 'stops_database_parking_area_key_values_variance_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  parking_area_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesVarianceOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingAreaMaxFields = {
  __typename?: 'stops_database_parking_area_max_fields';
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  covered?: Maybe<Scalars['Int']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  level_ref?: Maybe<Scalars['String']>;
  level_ref_version?: Maybe<Scalars['String']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  parking_properties_id?: Maybe<Scalars['bigint']>;
  place_equipments_id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  site_ref?: Maybe<Scalars['String']>;
  site_ref_version?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  total_capacity?: Maybe<Scalars['numeric']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingAreaMinFields = {
  __typename?: 'stops_database_parking_area_min_fields';
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  covered?: Maybe<Scalars['Int']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  level_ref?: Maybe<Scalars['String']>;
  level_ref_version?: Maybe<Scalars['String']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  parking_properties_id?: Maybe<Scalars['bigint']>;
  place_equipments_id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  site_ref?: Maybe<Scalars['String']>;
  site_ref_version?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  total_capacity?: Maybe<Scalars['numeric']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "parking_area" */
export type StopsDatabaseParkingAreaMutationResponse = {
  __typename?: 'stops_database_parking_area_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseParkingArea>;
};

/** on_conflict condition type for table "parking_area" */
export type StopsDatabaseParkingAreaOnConflict = {
  constraint: StopsDatabaseParkingAreaConstraint;
  update_columns?: Array<StopsDatabaseParkingAreaUpdateColumn>;
  where?: InputMaybe<StopsDatabaseParkingAreaBoolExp>;
};

/** Ordering options when selecting data from "parking_area". */
export type StopsDatabaseParkingAreaOrderBy = {
  accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentOrderBy>;
  accessibility_assessment_id?: InputMaybe<OrderBy>;
  all_areas_wheelchair_accessible?: InputMaybe<OrderBy>;
  centroid?: InputMaybe<OrderBy>;
  changed?: InputMaybe<OrderBy>;
  changed_by?: InputMaybe<OrderBy>;
  covered?: InputMaybe<OrderBy>;
  created?: InputMaybe<OrderBy>;
  description_lang?: InputMaybe<OrderBy>;
  description_value?: InputMaybe<OrderBy>;
  from_date?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureOrderBy>;
  level_ref?: InputMaybe<OrderBy>;
  level_ref_version?: InputMaybe<OrderBy>;
  name_lang?: InputMaybe<OrderBy>;
  name_value?: InputMaybe<OrderBy>;
  netex_id?: InputMaybe<OrderBy>;
  parking_area_alternative_names_aggregate?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesAggregateOrderBy>;
  parking_area_equipment_places_aggregate?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesAggregateOrderBy>;
  parking_area_key_values_aggregate?: InputMaybe<StopsDatabaseParkingAreaKeyValuesAggregateOrderBy>;
  parking_parking_area?: InputMaybe<StopsDatabaseParkingParkingAreasOrderBy>;
  parking_properties_id?: InputMaybe<OrderBy>;
  parking_property?: InputMaybe<StopsDatabaseParkingPropertiesOrderBy>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonOrderBy>;
  place_equipments_id?: InputMaybe<OrderBy>;
  polygon_id?: InputMaybe<OrderBy>;
  private_code_type?: InputMaybe<OrderBy>;
  private_code_value?: InputMaybe<OrderBy>;
  short_name_lang?: InputMaybe<OrderBy>;
  short_name_value?: InputMaybe<OrderBy>;
  site_ref?: InputMaybe<OrderBy>;
  site_ref_version?: InputMaybe<OrderBy>;
  to_date?: InputMaybe<OrderBy>;
  total_capacity?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
  version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: parking_area */
export type StopsDatabaseParkingAreaPkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "parking_area" */
export enum StopsDatabaseParkingAreaSelectColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  LevelRef = 'level_ref',
  /** column name */
  LevelRefVersion = 'level_ref_version',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ParkingPropertiesId = 'parking_properties_id',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  SiteRef = 'site_ref',
  /** column name */
  SiteRefVersion = 'site_ref_version',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TotalCapacity = 'total_capacity',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

/** input type for updating data in table "parking_area" */
export type StopsDatabaseParkingAreaSetInput = {
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']>;
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  covered?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  level_ref?: InputMaybe<Scalars['String']>;
  level_ref_version?: InputMaybe<Scalars['String']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  parking_properties_id?: InputMaybe<Scalars['bigint']>;
  place_equipments_id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  site_ref?: InputMaybe<Scalars['String']>;
  site_ref_version?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  total_capacity?: InputMaybe<Scalars['numeric']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingAreaStddevFields = {
  __typename?: 'stops_database_parking_area_stddev_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  parking_properties_id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  total_capacity?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingAreaStddevPopFields = {
  __typename?: 'stops_database_parking_area_stddev_pop_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  parking_properties_id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  total_capacity?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingAreaStddevSampFields = {
  __typename?: 'stops_database_parking_area_stddev_samp_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  parking_properties_id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  total_capacity?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "parking_area" */
export type StopsDatabaseParkingAreaStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseParkingAreaStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingAreaStreamCursorValueInput = {
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']>;
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  covered?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  level_ref?: InputMaybe<Scalars['String']>;
  level_ref_version?: InputMaybe<Scalars['String']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  parking_properties_id?: InputMaybe<Scalars['bigint']>;
  place_equipments_id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  site_ref?: InputMaybe<Scalars['String']>;
  site_ref_version?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  total_capacity?: InputMaybe<Scalars['numeric']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingAreaSumFields = {
  __typename?: 'stops_database_parking_area_sum_fields';
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  covered?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['bigint']>;
  parking_properties_id?: Maybe<Scalars['bigint']>;
  place_equipments_id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  total_capacity?: Maybe<Scalars['numeric']>;
  version?: Maybe<Scalars['bigint']>;
};

/** update columns of table "parking_area" */
export enum StopsDatabaseParkingAreaUpdateColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  LevelRef = 'level_ref',
  /** column name */
  LevelRefVersion = 'level_ref_version',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ParkingPropertiesId = 'parking_properties_id',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  SiteRef = 'site_ref',
  /** column name */
  SiteRefVersion = 'site_ref_version',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TotalCapacity = 'total_capacity',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

export type StopsDatabaseParkingAreaUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseParkingAreaIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseParkingAreaSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseParkingAreaBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingAreaVarPopFields = {
  __typename?: 'stops_database_parking_area_var_pop_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  parking_properties_id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  total_capacity?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingAreaVarSampFields = {
  __typename?: 'stops_database_parking_area_var_samp_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  parking_properties_id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  total_capacity?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingAreaVarianceFields = {
  __typename?: 'stops_database_parking_area_variance_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  parking_properties_id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  total_capacity?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingAvgFields = {
  __typename?: 'stops_database_parking_avg_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  number_of_parking_levels?: Maybe<Scalars['Float']>;
  parking_layout?: Maybe<Scalars['Float']>;
  parking_reservation?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  principal_capacity?: Maybe<Scalars['Float']>;
  topographic_place_id?: Maybe<Scalars['Float']>;
  total_capacity?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "parking". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseParkingBoolExp>>;
  _not?: InputMaybe<StopsDatabaseParkingBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseParkingBoolExp>>;
  accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentBoolExp>;
  accessibility_assessment_id?: InputMaybe<BigintComparisonExp>;
  all_areas_wheelchair_accessible?: InputMaybe<BooleanComparisonExp>;
  booking_url?: InputMaybe<StringComparisonExp>;
  centroid?: InputMaybe<GeometryComparisonExp>;
  changed?: InputMaybe<TimestampComparisonExp>;
  changed_by?: InputMaybe<StringComparisonExp>;
  covered?: InputMaybe<IntComparisonExp>;
  created?: InputMaybe<TimestampComparisonExp>;
  description_lang?: InputMaybe<StringComparisonExp>;
  description_value?: InputMaybe<StringComparisonExp>;
  free_parking_out_of_hours?: InputMaybe<BooleanComparisonExp>;
  from_date?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
  name_lang?: InputMaybe<StringComparisonExp>;
  name_value?: InputMaybe<StringComparisonExp>;
  netex_id?: InputMaybe<StringComparisonExp>;
  number_of_parking_levels?: InputMaybe<NumericComparisonExp>;
  overnight_parking_permitted?: InputMaybe<BooleanComparisonExp>;
  parent_site_ref?: InputMaybe<StringComparisonExp>;
  parent_site_ref_version?: InputMaybe<StringComparisonExp>;
  parking_alternative_names?: InputMaybe<StopsDatabaseParkingAlternativeNamesBoolExp>;
  parking_alternative_names_aggregate?: InputMaybe<ParkingAlternativeNamesAggregateBoolExp>;
  parking_equipment_places?: InputMaybe<StopsDatabaseParkingEquipmentPlacesBoolExp>;
  parking_equipment_places_aggregate?: InputMaybe<ParkingEquipmentPlacesAggregateBoolExp>;
  parking_key_values?: InputMaybe<StopsDatabaseParkingKeyValuesBoolExp>;
  parking_key_values_aggregate?: InputMaybe<ParkingKeyValuesAggregateBoolExp>;
  parking_layout?: InputMaybe<IntComparisonExp>;
  parking_parking_areas?: InputMaybe<StopsDatabaseParkingParkingAreasBoolExp>;
  parking_parking_areas_aggregate?: InputMaybe<ParkingParkingAreasAggregateBoolExp>;
  parking_parking_payment_processes?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessBoolExp>;
  parking_parking_payment_processes_aggregate?: InputMaybe<ParkingParkingPaymentProcessAggregateBoolExp>;
  parking_parking_properties?: InputMaybe<StopsDatabaseParkingParkingPropertiesBoolExp>;
  parking_parking_properties_aggregate?: InputMaybe<ParkingParkingPropertiesAggregateBoolExp>;
  parking_parking_vehicle_types?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesBoolExp>;
  parking_parking_vehicle_types_aggregate?: InputMaybe<ParkingParkingVehicleTypesAggregateBoolExp>;
  parking_reservation?: InputMaybe<IntComparisonExp>;
  parking_type?: InputMaybe<StringComparisonExp>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  place_equipments_id?: InputMaybe<BigintComparisonExp>;
  polygon_id?: InputMaybe<BigintComparisonExp>;
  principal_capacity?: InputMaybe<NumericComparisonExp>;
  private_code_type?: InputMaybe<StringComparisonExp>;
  private_code_value?: InputMaybe<StringComparisonExp>;
  prohibited_for_hazardous_materials?: InputMaybe<BooleanComparisonExp>;
  real_time_occupancy_available?: InputMaybe<BooleanComparisonExp>;
  recharging_available?: InputMaybe<BooleanComparisonExp>;
  secure?: InputMaybe<BooleanComparisonExp>;
  short_name_lang?: InputMaybe<StringComparisonExp>;
  short_name_value?: InputMaybe<StringComparisonExp>;
  to_date?: InputMaybe<TimestampComparisonExp>;
  topographic_place?: InputMaybe<StopsDatabaseTopographicPlaceBoolExp>;
  topographic_place_id?: InputMaybe<BigintComparisonExp>;
  total_capacity?: InputMaybe<NumericComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
  version_comment?: InputMaybe<StringComparisonExp>;
};

/** columns and relationships of "parking_capacity" */
export type StopsDatabaseParkingCapacity = {
  __typename?: 'stops_database_parking_capacity';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id: Scalars['bigint'];
  netex_id?: Maybe<Scalars['String']>;
  number_of_spaces?: Maybe<Scalars['numeric']>;
  number_of_spaces_with_recharge_point?: Maybe<Scalars['numeric']>;
  parent_ref?: Maybe<Scalars['bytea']>;
  parking_stay_type?: Maybe<Scalars['String']>;
  parking_user_type?: Maybe<Scalars['String']>;
  parking_vehicle_type?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version: Scalars['bigint'];
  version_comment?: Maybe<Scalars['String']>;
};

/** aggregated selection of "parking_capacity" */
export type StopsDatabaseParkingCapacityAggregate = {
  __typename?: 'stops_database_parking_capacity_aggregate';
  aggregate?: Maybe<StopsDatabaseParkingCapacityAggregateFields>;
  nodes: Array<StopsDatabaseParkingCapacity>;
};

/** aggregate fields of "parking_capacity" */
export type StopsDatabaseParkingCapacityAggregateFields = {
  __typename?: 'stops_database_parking_capacity_aggregate_fields';
  avg?: Maybe<StopsDatabaseParkingCapacityAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseParkingCapacityMaxFields>;
  min?: Maybe<StopsDatabaseParkingCapacityMinFields>;
  stddev?: Maybe<StopsDatabaseParkingCapacityStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseParkingCapacityStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseParkingCapacityStddevSampFields>;
  sum?: Maybe<StopsDatabaseParkingCapacitySumFields>;
  var_pop?: Maybe<StopsDatabaseParkingCapacityVarPopFields>;
  var_samp?: Maybe<StopsDatabaseParkingCapacityVarSampFields>;
  variance?: Maybe<StopsDatabaseParkingCapacityVarianceFields>;
};

/** aggregate fields of "parking_capacity" */
export type StopsDatabaseParkingCapacityAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseParkingCapacitySelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingCapacityAvgFields = {
  __typename?: 'stops_database_parking_capacity_avg_fields';
  id?: Maybe<Scalars['Float']>;
  number_of_spaces?: Maybe<Scalars['Float']>;
  number_of_spaces_with_recharge_point?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "parking_capacity". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingCapacityBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseParkingCapacityBoolExp>>;
  _not?: InputMaybe<StopsDatabaseParkingCapacityBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseParkingCapacityBoolExp>>;
  changed?: InputMaybe<TimestampComparisonExp>;
  changed_by?: InputMaybe<StringComparisonExp>;
  created?: InputMaybe<TimestampComparisonExp>;
  from_date?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  netex_id?: InputMaybe<StringComparisonExp>;
  number_of_spaces?: InputMaybe<NumericComparisonExp>;
  number_of_spaces_with_recharge_point?: InputMaybe<NumericComparisonExp>;
  parent_ref?: InputMaybe<ByteaComparisonExp>;
  parking_stay_type?: InputMaybe<StringComparisonExp>;
  parking_user_type?: InputMaybe<StringComparisonExp>;
  parking_vehicle_type?: InputMaybe<StringComparisonExp>;
  to_date?: InputMaybe<TimestampComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
  version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "parking_capacity" */
export enum StopsDatabaseParkingCapacityConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  ParkingCapacityNetexIdVersionConstraint = 'parking_capacity_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  ParkingCapacityPkey = 'parking_capacity_pkey',
}

/** input type for incrementing numeric columns in table "parking_capacity" */
export type StopsDatabaseParkingCapacityIncInput = {
  id?: InputMaybe<Scalars['bigint']>;
  number_of_spaces?: InputMaybe<Scalars['numeric']>;
  number_of_spaces_with_recharge_point?: InputMaybe<Scalars['numeric']>;
  version?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "parking_capacity" */
export type StopsDatabaseParkingCapacityInsertInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  netex_id?: InputMaybe<Scalars['String']>;
  number_of_spaces?: InputMaybe<Scalars['numeric']>;
  number_of_spaces_with_recharge_point?: InputMaybe<Scalars['numeric']>;
  parent_ref?: InputMaybe<Scalars['bytea']>;
  parking_stay_type?: InputMaybe<Scalars['String']>;
  parking_user_type?: InputMaybe<Scalars['String']>;
  parking_vehicle_type?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingCapacityMaxFields = {
  __typename?: 'stops_database_parking_capacity_max_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  netex_id?: Maybe<Scalars['String']>;
  number_of_spaces?: Maybe<Scalars['numeric']>;
  number_of_spaces_with_recharge_point?: Maybe<Scalars['numeric']>;
  parking_stay_type?: Maybe<Scalars['String']>;
  parking_user_type?: Maybe<Scalars['String']>;
  parking_vehicle_type?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingCapacityMinFields = {
  __typename?: 'stops_database_parking_capacity_min_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  netex_id?: Maybe<Scalars['String']>;
  number_of_spaces?: Maybe<Scalars['numeric']>;
  number_of_spaces_with_recharge_point?: Maybe<Scalars['numeric']>;
  parking_stay_type?: Maybe<Scalars['String']>;
  parking_user_type?: Maybe<Scalars['String']>;
  parking_vehicle_type?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "parking_capacity" */
export type StopsDatabaseParkingCapacityMutationResponse = {
  __typename?: 'stops_database_parking_capacity_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseParkingCapacity>;
};

/** on_conflict condition type for table "parking_capacity" */
export type StopsDatabaseParkingCapacityOnConflict = {
  constraint: StopsDatabaseParkingCapacityConstraint;
  update_columns?: Array<StopsDatabaseParkingCapacityUpdateColumn>;
  where?: InputMaybe<StopsDatabaseParkingCapacityBoolExp>;
};

/** Ordering options when selecting data from "parking_capacity". */
export type StopsDatabaseParkingCapacityOrderBy = {
  changed?: InputMaybe<OrderBy>;
  changed_by?: InputMaybe<OrderBy>;
  created?: InputMaybe<OrderBy>;
  from_date?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  netex_id?: InputMaybe<OrderBy>;
  number_of_spaces?: InputMaybe<OrderBy>;
  number_of_spaces_with_recharge_point?: InputMaybe<OrderBy>;
  parent_ref?: InputMaybe<OrderBy>;
  parking_stay_type?: InputMaybe<OrderBy>;
  parking_user_type?: InputMaybe<OrderBy>;
  parking_vehicle_type?: InputMaybe<OrderBy>;
  to_date?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
  version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: parking_capacity */
export type StopsDatabaseParkingCapacityPkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "parking_capacity" */
export enum StopsDatabaseParkingCapacitySelectColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  NumberOfSpaces = 'number_of_spaces',
  /** column name */
  NumberOfSpacesWithRechargePoint = 'number_of_spaces_with_recharge_point',
  /** column name */
  ParentRef = 'parent_ref',
  /** column name */
  ParkingStayType = 'parking_stay_type',
  /** column name */
  ParkingUserType = 'parking_user_type',
  /** column name */
  ParkingVehicleType = 'parking_vehicle_type',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

/** input type for updating data in table "parking_capacity" */
export type StopsDatabaseParkingCapacitySetInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  netex_id?: InputMaybe<Scalars['String']>;
  number_of_spaces?: InputMaybe<Scalars['numeric']>;
  number_of_spaces_with_recharge_point?: InputMaybe<Scalars['numeric']>;
  parent_ref?: InputMaybe<Scalars['bytea']>;
  parking_stay_type?: InputMaybe<Scalars['String']>;
  parking_user_type?: InputMaybe<Scalars['String']>;
  parking_vehicle_type?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingCapacityStddevFields = {
  __typename?: 'stops_database_parking_capacity_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  number_of_spaces?: Maybe<Scalars['Float']>;
  number_of_spaces_with_recharge_point?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingCapacityStddevPopFields = {
  __typename?: 'stops_database_parking_capacity_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  number_of_spaces?: Maybe<Scalars['Float']>;
  number_of_spaces_with_recharge_point?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingCapacityStddevSampFields = {
  __typename?: 'stops_database_parking_capacity_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  number_of_spaces?: Maybe<Scalars['Float']>;
  number_of_spaces_with_recharge_point?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "parking_capacity" */
export type StopsDatabaseParkingCapacityStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseParkingCapacityStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingCapacityStreamCursorValueInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  netex_id?: InputMaybe<Scalars['String']>;
  number_of_spaces?: InputMaybe<Scalars['numeric']>;
  number_of_spaces_with_recharge_point?: InputMaybe<Scalars['numeric']>;
  parent_ref?: InputMaybe<Scalars['bytea']>;
  parking_stay_type?: InputMaybe<Scalars['String']>;
  parking_user_type?: InputMaybe<Scalars['String']>;
  parking_vehicle_type?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingCapacitySumFields = {
  __typename?: 'stops_database_parking_capacity_sum_fields';
  id?: Maybe<Scalars['bigint']>;
  number_of_spaces?: Maybe<Scalars['numeric']>;
  number_of_spaces_with_recharge_point?: Maybe<Scalars['numeric']>;
  version?: Maybe<Scalars['bigint']>;
};

/** update columns of table "parking_capacity" */
export enum StopsDatabaseParkingCapacityUpdateColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  NumberOfSpaces = 'number_of_spaces',
  /** column name */
  NumberOfSpacesWithRechargePoint = 'number_of_spaces_with_recharge_point',
  /** column name */
  ParentRef = 'parent_ref',
  /** column name */
  ParkingStayType = 'parking_stay_type',
  /** column name */
  ParkingUserType = 'parking_user_type',
  /** column name */
  ParkingVehicleType = 'parking_vehicle_type',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

export type StopsDatabaseParkingCapacityUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseParkingCapacityIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseParkingCapacitySetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseParkingCapacityBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingCapacityVarPopFields = {
  __typename?: 'stops_database_parking_capacity_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  number_of_spaces?: Maybe<Scalars['Float']>;
  number_of_spaces_with_recharge_point?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingCapacityVarSampFields = {
  __typename?: 'stops_database_parking_capacity_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  number_of_spaces?: Maybe<Scalars['Float']>;
  number_of_spaces_with_recharge_point?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingCapacityVarianceFields = {
  __typename?: 'stops_database_parking_capacity_variance_fields';
  id?: Maybe<Scalars['Float']>;
  number_of_spaces?: Maybe<Scalars['Float']>;
  number_of_spaces_with_recharge_point?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** unique or primary key constraints on table "parking" */
export enum StopsDatabaseParkingConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  ParkingNetexIdVersionConstraint = 'parking_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  ParkingPkey = 'parking_pkey',
}

/** columns and relationships of "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlaces = {
  __typename?: 'stops_database_parking_equipment_places';
  equipment_places_id: Scalars['bigint'];
  parking_id: Scalars['bigint'];
};

/** aggregated selection of "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesAggregate = {
  __typename?: 'stops_database_parking_equipment_places_aggregate';
  aggregate?: Maybe<StopsDatabaseParkingEquipmentPlacesAggregateFields>;
  nodes: Array<StopsDatabaseParkingEquipmentPlaces>;
};

/** aggregate fields of "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesAggregateFields = {
  __typename?: 'stops_database_parking_equipment_places_aggregate_fields';
  avg?: Maybe<StopsDatabaseParkingEquipmentPlacesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseParkingEquipmentPlacesMaxFields>;
  min?: Maybe<StopsDatabaseParkingEquipmentPlacesMinFields>;
  stddev?: Maybe<StopsDatabaseParkingEquipmentPlacesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseParkingEquipmentPlacesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseParkingEquipmentPlacesStddevSampFields>;
  sum?: Maybe<StopsDatabaseParkingEquipmentPlacesSumFields>;
  var_pop?: Maybe<StopsDatabaseParkingEquipmentPlacesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseParkingEquipmentPlacesVarSampFields>;
  variance?: Maybe<StopsDatabaseParkingEquipmentPlacesVarianceFields>;
};

/** aggregate fields of "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseParkingEquipmentPlacesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseParkingEquipmentPlacesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseParkingEquipmentPlacesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseParkingEquipmentPlacesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseParkingEquipmentPlacesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseParkingEquipmentPlacesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseParkingEquipmentPlacesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseParkingEquipmentPlacesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseParkingEquipmentPlacesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseParkingEquipmentPlacesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseParkingEquipmentPlacesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesArrRelInsertInput = {
  data: Array<StopsDatabaseParkingEquipmentPlacesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseParkingEquipmentPlacesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingEquipmentPlacesAvgFields = {
  __typename?: 'stops_database_parking_equipment_places_avg_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesAvgOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "parking_equipment_places". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingEquipmentPlacesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseParkingEquipmentPlacesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseParkingEquipmentPlacesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseParkingEquipmentPlacesBoolExp>>;
  equipment_places_id?: InputMaybe<BigintComparisonExp>;
  parking_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "parking_equipment_places" */
export enum StopsDatabaseParkingEquipmentPlacesConstraint {
  /** unique or primary key constraint on columns "equipment_places_id" */
  Uk_9sg6v3vst7yq7nvli7tt317wg = 'uk_9sg6v3vst7yq7nvli7tt317wg',
}

/** input type for incrementing numeric columns in table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesIncInput = {
  equipment_places_id?: InputMaybe<Scalars['bigint']>;
  parking_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesInsertInput = {
  equipment_places_id?: InputMaybe<Scalars['bigint']>;
  parking_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingEquipmentPlacesMaxFields = {
  __typename?: 'stops_database_parking_equipment_places_max_fields';
  equipment_places_id?: Maybe<Scalars['bigint']>;
  parking_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesMaxOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingEquipmentPlacesMinFields = {
  __typename?: 'stops_database_parking_equipment_places_min_fields';
  equipment_places_id?: Maybe<Scalars['bigint']>;
  parking_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesMinOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesMutationResponse = {
  __typename?: 'stops_database_parking_equipment_places_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseParkingEquipmentPlaces>;
};

/** on_conflict condition type for table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesOnConflict = {
  constraint: StopsDatabaseParkingEquipmentPlacesConstraint;
  update_columns?: Array<StopsDatabaseParkingEquipmentPlacesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseParkingEquipmentPlacesBoolExp>;
};

/** Ordering options when selecting data from "parking_equipment_places". */
export type StopsDatabaseParkingEquipmentPlacesOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** select columns of table "parking_equipment_places" */
export enum StopsDatabaseParkingEquipmentPlacesSelectColumn {
  /** column name */
  EquipmentPlacesId = 'equipment_places_id',
  /** column name */
  ParkingId = 'parking_id',
}

/** input type for updating data in table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesSetInput = {
  equipment_places_id?: InputMaybe<Scalars['bigint']>;
  parking_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingEquipmentPlacesStddevFields = {
  __typename?: 'stops_database_parking_equipment_places_stddev_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesStddevOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingEquipmentPlacesStddevPopFields = {
  __typename?: 'stops_database_parking_equipment_places_stddev_pop_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesStddevPopOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingEquipmentPlacesStddevSampFields = {
  __typename?: 'stops_database_parking_equipment_places_stddev_samp_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesStddevSampOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseParkingEquipmentPlacesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingEquipmentPlacesStreamCursorValueInput = {
  equipment_places_id?: InputMaybe<Scalars['bigint']>;
  parking_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingEquipmentPlacesSumFields = {
  __typename?: 'stops_database_parking_equipment_places_sum_fields';
  equipment_places_id?: Maybe<Scalars['bigint']>;
  parking_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesSumOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** update columns of table "parking_equipment_places" */
export enum StopsDatabaseParkingEquipmentPlacesUpdateColumn {
  /** column name */
  EquipmentPlacesId = 'equipment_places_id',
  /** column name */
  ParkingId = 'parking_id',
}

export type StopsDatabaseParkingEquipmentPlacesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseParkingEquipmentPlacesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseParkingEquipmentPlacesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseParkingEquipmentPlacesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingEquipmentPlacesVarPopFields = {
  __typename?: 'stops_database_parking_equipment_places_var_pop_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesVarPopOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingEquipmentPlacesVarSampFields = {
  __typename?: 'stops_database_parking_equipment_places_var_samp_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesVarSampOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingEquipmentPlacesVarianceFields = {
  __typename?: 'stops_database_parking_equipment_places_variance_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesVarianceOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** input type for incrementing numeric columns in table "parking" */
export type StopsDatabaseParkingIncInput = {
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  covered?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['bigint']>;
  number_of_parking_levels?: InputMaybe<Scalars['numeric']>;
  parking_layout?: InputMaybe<Scalars['Int']>;
  parking_reservation?: InputMaybe<Scalars['Int']>;
  place_equipments_id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  principal_capacity?: InputMaybe<Scalars['numeric']>;
  topographic_place_id?: InputMaybe<Scalars['bigint']>;
  total_capacity?: InputMaybe<Scalars['numeric']>;
  version?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "parking" */
export type StopsDatabaseParkingInsertInput = {
  accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentObjRelInsertInput>;
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']>;
  booking_url?: InputMaybe<Scalars['String']>;
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  covered?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  free_parking_out_of_hours?: InputMaybe<Scalars['Boolean']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureObjRelInsertInput>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  number_of_parking_levels?: InputMaybe<Scalars['numeric']>;
  overnight_parking_permitted?: InputMaybe<Scalars['Boolean']>;
  parent_site_ref?: InputMaybe<Scalars['String']>;
  parent_site_ref_version?: InputMaybe<Scalars['String']>;
  parking_alternative_names?: InputMaybe<StopsDatabaseParkingAlternativeNamesArrRelInsertInput>;
  parking_equipment_places?: InputMaybe<StopsDatabaseParkingEquipmentPlacesArrRelInsertInput>;
  parking_key_values?: InputMaybe<StopsDatabaseParkingKeyValuesArrRelInsertInput>;
  parking_layout?: InputMaybe<Scalars['Int']>;
  parking_parking_areas?: InputMaybe<StopsDatabaseParkingParkingAreasArrRelInsertInput>;
  parking_parking_payment_processes?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessArrRelInsertInput>;
  parking_parking_properties?: InputMaybe<StopsDatabaseParkingParkingPropertiesArrRelInsertInput>;
  parking_parking_vehicle_types?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesArrRelInsertInput>;
  parking_reservation?: InputMaybe<Scalars['Int']>;
  parking_type?: InputMaybe<Scalars['String']>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonObjRelInsertInput>;
  place_equipments_id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  principal_capacity?: InputMaybe<Scalars['numeric']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  prohibited_for_hazardous_materials?: InputMaybe<Scalars['Boolean']>;
  real_time_occupancy_available?: InputMaybe<Scalars['Boolean']>;
  recharging_available?: InputMaybe<Scalars['Boolean']>;
  secure?: InputMaybe<Scalars['Boolean']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  topographic_place?: InputMaybe<StopsDatabaseTopographicPlaceObjRelInsertInput>;
  topographic_place_id?: InputMaybe<Scalars['bigint']>;
  total_capacity?: InputMaybe<Scalars['numeric']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "parking_key_values" */
export type StopsDatabaseParkingKeyValues = {
  __typename?: 'stops_database_parking_key_values';
  key_values_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
  parking_id: Scalars['bigint'];
};

/** aggregated selection of "parking_key_values" */
export type StopsDatabaseParkingKeyValuesAggregate = {
  __typename?: 'stops_database_parking_key_values_aggregate';
  aggregate?: Maybe<StopsDatabaseParkingKeyValuesAggregateFields>;
  nodes: Array<StopsDatabaseParkingKeyValues>;
};

/** aggregate fields of "parking_key_values" */
export type StopsDatabaseParkingKeyValuesAggregateFields = {
  __typename?: 'stops_database_parking_key_values_aggregate_fields';
  avg?: Maybe<StopsDatabaseParkingKeyValuesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseParkingKeyValuesMaxFields>;
  min?: Maybe<StopsDatabaseParkingKeyValuesMinFields>;
  stddev?: Maybe<StopsDatabaseParkingKeyValuesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseParkingKeyValuesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseParkingKeyValuesStddevSampFields>;
  sum?: Maybe<StopsDatabaseParkingKeyValuesSumFields>;
  var_pop?: Maybe<StopsDatabaseParkingKeyValuesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseParkingKeyValuesVarSampFields>;
  variance?: Maybe<StopsDatabaseParkingKeyValuesVarianceFields>;
};

/** aggregate fields of "parking_key_values" */
export type StopsDatabaseParkingKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseParkingKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseParkingKeyValuesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseParkingKeyValuesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseParkingKeyValuesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseParkingKeyValuesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseParkingKeyValuesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseParkingKeyValuesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseParkingKeyValuesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseParkingKeyValuesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseParkingKeyValuesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseParkingKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesArrRelInsertInput = {
  data: Array<StopsDatabaseParkingKeyValuesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseParkingKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingKeyValuesAvgFields = {
  __typename?: 'stops_database_parking_key_values_avg_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesAvgOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "parking_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingKeyValuesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseParkingKeyValuesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseParkingKeyValuesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseParkingKeyValuesBoolExp>>;
  key_values_id?: InputMaybe<BigintComparisonExp>;
  key_values_key?: InputMaybe<StringComparisonExp>;
  parking_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "parking_key_values" */
export enum StopsDatabaseParkingKeyValuesConstraint {
  /** unique or primary key constraint on columns "parking_id", "key_values_key" */
  ParkingKeyValuesPkey = 'parking_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkIteh0to4gqim61p74lq2ugc2k = 'uk_iteh0to4gqim61p74lq2ugc2k',
}

/** input type for incrementing numeric columns in table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesIncInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  parking_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesInsertInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  parking_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingKeyValuesMaxFields = {
  __typename?: 'stops_database_parking_key_values_max_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
  parking_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesMaxOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingKeyValuesMinFields = {
  __typename?: 'stops_database_parking_key_values_min_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
  parking_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesMinOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesMutationResponse = {
  __typename?: 'stops_database_parking_key_values_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseParkingKeyValues>;
};

/** on_conflict condition type for table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesOnConflict = {
  constraint: StopsDatabaseParkingKeyValuesConstraint;
  update_columns?: Array<StopsDatabaseParkingKeyValuesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseParkingKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "parking_key_values". */
export type StopsDatabaseParkingKeyValuesOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: parking_key_values */
export type StopsDatabaseParkingKeyValuesPkColumnsInput = {
  key_values_key: Scalars['String'];
  parking_id: Scalars['bigint'];
};

/** select columns of table "parking_key_values" */
export enum StopsDatabaseParkingKeyValuesSelectColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  ParkingId = 'parking_id',
}

/** input type for updating data in table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesSetInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  parking_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingKeyValuesStddevFields = {
  __typename?: 'stops_database_parking_key_values_stddev_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesStddevOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingKeyValuesStddevPopFields = {
  __typename?: 'stops_database_parking_key_values_stddev_pop_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesStddevPopOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingKeyValuesStddevSampFields = {
  __typename?: 'stops_database_parking_key_values_stddev_samp_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesStddevSampOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseParkingKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingKeyValuesStreamCursorValueInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  parking_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingKeyValuesSumFields = {
  __typename?: 'stops_database_parking_key_values_sum_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  parking_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesSumOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** update columns of table "parking_key_values" */
export enum StopsDatabaseParkingKeyValuesUpdateColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  ParkingId = 'parking_id',
}

export type StopsDatabaseParkingKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseParkingKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseParkingKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseParkingKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingKeyValuesVarPopFields = {
  __typename?: 'stops_database_parking_key_values_var_pop_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesVarPopOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingKeyValuesVarSampFields = {
  __typename?: 'stops_database_parking_key_values_var_samp_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesVarSampOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingKeyValuesVarianceFields = {
  __typename?: 'stops_database_parking_key_values_variance_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesVarianceOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingMaxFields = {
  __typename?: 'stops_database_parking_max_fields';
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  booking_url?: Maybe<Scalars['String']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  covered?: Maybe<Scalars['Int']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  number_of_parking_levels?: Maybe<Scalars['numeric']>;
  parent_site_ref?: Maybe<Scalars['String']>;
  parent_site_ref_version?: Maybe<Scalars['String']>;
  parking_layout?: Maybe<Scalars['Int']>;
  parking_reservation?: Maybe<Scalars['Int']>;
  parking_type?: Maybe<Scalars['String']>;
  place_equipments_id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  principal_capacity?: Maybe<Scalars['numeric']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  topographic_place_id?: Maybe<Scalars['bigint']>;
  total_capacity?: Maybe<Scalars['numeric']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingMinFields = {
  __typename?: 'stops_database_parking_min_fields';
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  booking_url?: Maybe<Scalars['String']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  covered?: Maybe<Scalars['Int']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  number_of_parking_levels?: Maybe<Scalars['numeric']>;
  parent_site_ref?: Maybe<Scalars['String']>;
  parent_site_ref_version?: Maybe<Scalars['String']>;
  parking_layout?: Maybe<Scalars['Int']>;
  parking_reservation?: Maybe<Scalars['Int']>;
  parking_type?: Maybe<Scalars['String']>;
  place_equipments_id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  principal_capacity?: Maybe<Scalars['numeric']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  topographic_place_id?: Maybe<Scalars['bigint']>;
  total_capacity?: Maybe<Scalars['numeric']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "parking" */
export type StopsDatabaseParkingMutationResponse = {
  __typename?: 'stops_database_parking_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseParking>;
};

/** on_conflict condition type for table "parking" */
export type StopsDatabaseParkingOnConflict = {
  constraint: StopsDatabaseParkingConstraint;
  update_columns?: Array<StopsDatabaseParkingUpdateColumn>;
  where?: InputMaybe<StopsDatabaseParkingBoolExp>;
};

/** Ordering options when selecting data from "parking". */
export type StopsDatabaseParkingOrderBy = {
  accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentOrderBy>;
  accessibility_assessment_id?: InputMaybe<OrderBy>;
  all_areas_wheelchair_accessible?: InputMaybe<OrderBy>;
  booking_url?: InputMaybe<OrderBy>;
  centroid?: InputMaybe<OrderBy>;
  changed?: InputMaybe<OrderBy>;
  changed_by?: InputMaybe<OrderBy>;
  covered?: InputMaybe<OrderBy>;
  created?: InputMaybe<OrderBy>;
  description_lang?: InputMaybe<OrderBy>;
  description_value?: InputMaybe<OrderBy>;
  free_parking_out_of_hours?: InputMaybe<OrderBy>;
  from_date?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureOrderBy>;
  name_lang?: InputMaybe<OrderBy>;
  name_value?: InputMaybe<OrderBy>;
  netex_id?: InputMaybe<OrderBy>;
  number_of_parking_levels?: InputMaybe<OrderBy>;
  overnight_parking_permitted?: InputMaybe<OrderBy>;
  parent_site_ref?: InputMaybe<OrderBy>;
  parent_site_ref_version?: InputMaybe<OrderBy>;
  parking_alternative_names_aggregate?: InputMaybe<StopsDatabaseParkingAlternativeNamesAggregateOrderBy>;
  parking_equipment_places_aggregate?: InputMaybe<StopsDatabaseParkingEquipmentPlacesAggregateOrderBy>;
  parking_key_values_aggregate?: InputMaybe<StopsDatabaseParkingKeyValuesAggregateOrderBy>;
  parking_layout?: InputMaybe<OrderBy>;
  parking_parking_areas_aggregate?: InputMaybe<StopsDatabaseParkingParkingAreasAggregateOrderBy>;
  parking_parking_payment_processes_aggregate?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessAggregateOrderBy>;
  parking_parking_properties_aggregate?: InputMaybe<StopsDatabaseParkingParkingPropertiesAggregateOrderBy>;
  parking_parking_vehicle_types_aggregate?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesAggregateOrderBy>;
  parking_reservation?: InputMaybe<OrderBy>;
  parking_type?: InputMaybe<OrderBy>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonOrderBy>;
  place_equipments_id?: InputMaybe<OrderBy>;
  polygon_id?: InputMaybe<OrderBy>;
  principal_capacity?: InputMaybe<OrderBy>;
  private_code_type?: InputMaybe<OrderBy>;
  private_code_value?: InputMaybe<OrderBy>;
  prohibited_for_hazardous_materials?: InputMaybe<OrderBy>;
  real_time_occupancy_available?: InputMaybe<OrderBy>;
  recharging_available?: InputMaybe<OrderBy>;
  secure?: InputMaybe<OrderBy>;
  short_name_lang?: InputMaybe<OrderBy>;
  short_name_value?: InputMaybe<OrderBy>;
  to_date?: InputMaybe<OrderBy>;
  topographic_place?: InputMaybe<StopsDatabaseTopographicPlaceOrderBy>;
  topographic_place_id?: InputMaybe<OrderBy>;
  total_capacity?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
  version_comment?: InputMaybe<OrderBy>;
};

/** columns and relationships of "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreas = {
  __typename?: 'stops_database_parking_parking_areas';
  parking_areas_id: Scalars['bigint'];
  parking_id: Scalars['bigint'];
};

/** aggregated selection of "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasAggregate = {
  __typename?: 'stops_database_parking_parking_areas_aggregate';
  aggregate?: Maybe<StopsDatabaseParkingParkingAreasAggregateFields>;
  nodes: Array<StopsDatabaseParkingParkingAreas>;
};

/** aggregate fields of "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasAggregateFields = {
  __typename?: 'stops_database_parking_parking_areas_aggregate_fields';
  avg?: Maybe<StopsDatabaseParkingParkingAreasAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseParkingParkingAreasMaxFields>;
  min?: Maybe<StopsDatabaseParkingParkingAreasMinFields>;
  stddev?: Maybe<StopsDatabaseParkingParkingAreasStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseParkingParkingAreasStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseParkingParkingAreasStddevSampFields>;
  sum?: Maybe<StopsDatabaseParkingParkingAreasSumFields>;
  var_pop?: Maybe<StopsDatabaseParkingParkingAreasVarPopFields>;
  var_samp?: Maybe<StopsDatabaseParkingParkingAreasVarSampFields>;
  variance?: Maybe<StopsDatabaseParkingParkingAreasVarianceFields>;
};

/** aggregate fields of "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseParkingParkingAreasSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseParkingParkingAreasAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseParkingParkingAreasMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseParkingParkingAreasMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseParkingParkingAreasStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseParkingParkingAreasStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseParkingParkingAreasStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseParkingParkingAreasSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseParkingParkingAreasVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseParkingParkingAreasVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseParkingParkingAreasVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasArrRelInsertInput = {
  data: Array<StopsDatabaseParkingParkingAreasInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseParkingParkingAreasOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingParkingAreasAvgFields = {
  __typename?: 'stops_database_parking_parking_areas_avg_fields';
  parking_areas_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasAvgOrderBy = {
  parking_areas_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "parking_parking_areas". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingParkingAreasBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseParkingParkingAreasBoolExp>>;
  _not?: InputMaybe<StopsDatabaseParkingParkingAreasBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseParkingParkingAreasBoolExp>>;
  parking_areas_id?: InputMaybe<BigintComparisonExp>;
  parking_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "parking_parking_areas" */
export enum StopsDatabaseParkingParkingAreasConstraint {
  /** unique or primary key constraint on columns "parking_areas_id" */
  Uk_66npakygxb5mjymo8x06yf9sj = 'uk_66npakygxb5mjymo8x06yf9sj',
}

/** input type for incrementing numeric columns in table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasIncInput = {
  parking_areas_id?: InputMaybe<Scalars['bigint']>;
  parking_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasInsertInput = {
  parking_areas_id?: InputMaybe<Scalars['bigint']>;
  parking_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingParkingAreasMaxFields = {
  __typename?: 'stops_database_parking_parking_areas_max_fields';
  parking_areas_id?: Maybe<Scalars['bigint']>;
  parking_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasMaxOrderBy = {
  parking_areas_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingParkingAreasMinFields = {
  __typename?: 'stops_database_parking_parking_areas_min_fields';
  parking_areas_id?: Maybe<Scalars['bigint']>;
  parking_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasMinOrderBy = {
  parking_areas_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasMutationResponse = {
  __typename?: 'stops_database_parking_parking_areas_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseParkingParkingAreas>;
};

/** input type for inserting object relation for remote table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasObjRelInsertInput = {
  data: StopsDatabaseParkingParkingAreasInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseParkingParkingAreasOnConflict>;
};

/** on_conflict condition type for table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasOnConflict = {
  constraint: StopsDatabaseParkingParkingAreasConstraint;
  update_columns?: Array<StopsDatabaseParkingParkingAreasUpdateColumn>;
  where?: InputMaybe<StopsDatabaseParkingParkingAreasBoolExp>;
};

/** Ordering options when selecting data from "parking_parking_areas". */
export type StopsDatabaseParkingParkingAreasOrderBy = {
  parking_areas_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** select columns of table "parking_parking_areas" */
export enum StopsDatabaseParkingParkingAreasSelectColumn {
  /** column name */
  ParkingAreasId = 'parking_areas_id',
  /** column name */
  ParkingId = 'parking_id',
}

/** input type for updating data in table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasSetInput = {
  parking_areas_id?: InputMaybe<Scalars['bigint']>;
  parking_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingParkingAreasStddevFields = {
  __typename?: 'stops_database_parking_parking_areas_stddev_fields';
  parking_areas_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasStddevOrderBy = {
  parking_areas_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingParkingAreasStddevPopFields = {
  __typename?: 'stops_database_parking_parking_areas_stddev_pop_fields';
  parking_areas_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasStddevPopOrderBy = {
  parking_areas_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingParkingAreasStddevSampFields = {
  __typename?: 'stops_database_parking_parking_areas_stddev_samp_fields';
  parking_areas_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasStddevSampOrderBy = {
  parking_areas_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseParkingParkingAreasStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingParkingAreasStreamCursorValueInput = {
  parking_areas_id?: InputMaybe<Scalars['bigint']>;
  parking_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingParkingAreasSumFields = {
  __typename?: 'stops_database_parking_parking_areas_sum_fields';
  parking_areas_id?: Maybe<Scalars['bigint']>;
  parking_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasSumOrderBy = {
  parking_areas_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** update columns of table "parking_parking_areas" */
export enum StopsDatabaseParkingParkingAreasUpdateColumn {
  /** column name */
  ParkingAreasId = 'parking_areas_id',
  /** column name */
  ParkingId = 'parking_id',
}

export type StopsDatabaseParkingParkingAreasUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseParkingParkingAreasIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseParkingParkingAreasSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseParkingParkingAreasBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingParkingAreasVarPopFields = {
  __typename?: 'stops_database_parking_parking_areas_var_pop_fields';
  parking_areas_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasVarPopOrderBy = {
  parking_areas_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingParkingAreasVarSampFields = {
  __typename?: 'stops_database_parking_parking_areas_var_samp_fields';
  parking_areas_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasVarSampOrderBy = {
  parking_areas_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingParkingAreasVarianceFields = {
  __typename?: 'stops_database_parking_parking_areas_variance_fields';
  parking_areas_id?: Maybe<Scalars['Float']>;
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasVarianceOrderBy = {
  parking_areas_id?: InputMaybe<OrderBy>;
  parking_id?: InputMaybe<OrderBy>;
};

/** columns and relationships of "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcess = {
  __typename?: 'stops_database_parking_parking_payment_process';
  parking_id: Scalars['bigint'];
  parking_payment_process?: Maybe<Scalars['String']>;
};

/** aggregated selection of "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessAggregate = {
  __typename?: 'stops_database_parking_parking_payment_process_aggregate';
  aggregate?: Maybe<StopsDatabaseParkingParkingPaymentProcessAggregateFields>;
  nodes: Array<StopsDatabaseParkingParkingPaymentProcess>;
};

/** aggregate fields of "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessAggregateFields = {
  __typename?: 'stops_database_parking_parking_payment_process_aggregate_fields';
  avg?: Maybe<StopsDatabaseParkingParkingPaymentProcessAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseParkingParkingPaymentProcessMaxFields>;
  min?: Maybe<StopsDatabaseParkingParkingPaymentProcessMinFields>;
  stddev?: Maybe<StopsDatabaseParkingParkingPaymentProcessStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseParkingParkingPaymentProcessStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseParkingParkingPaymentProcessStddevSampFields>;
  sum?: Maybe<StopsDatabaseParkingParkingPaymentProcessSumFields>;
  var_pop?: Maybe<StopsDatabaseParkingParkingPaymentProcessVarPopFields>;
  var_samp?: Maybe<StopsDatabaseParkingParkingPaymentProcessVarSampFields>;
  variance?: Maybe<StopsDatabaseParkingParkingPaymentProcessVarianceFields>;
};

/** aggregate fields of "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessAggregateFieldsCountArgs =
  {
    columns?: InputMaybe<
      Array<StopsDatabaseParkingParkingPaymentProcessSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
  };

/** order by aggregate values of table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessArrRelInsertInput = {
  data: Array<StopsDatabaseParkingParkingPaymentProcessInsertInput>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingParkingPaymentProcessAvgFields = {
  __typename?: 'stops_database_parking_parking_payment_process_avg_fields';
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessAvgOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "parking_parking_payment_process". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingParkingPaymentProcessBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseParkingParkingPaymentProcessBoolExp>>;
  _not?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseParkingParkingPaymentProcessBoolExp>>;
  parking_id?: InputMaybe<BigintComparisonExp>;
  parking_payment_process?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessIncInput = {
  parking_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessInsertInput = {
  parking_id?: InputMaybe<Scalars['bigint']>;
  parking_payment_process?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingParkingPaymentProcessMaxFields = {
  __typename?: 'stops_database_parking_parking_payment_process_max_fields';
  parking_id?: Maybe<Scalars['bigint']>;
  parking_payment_process?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessMaxOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
  parking_payment_process?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingParkingPaymentProcessMinFields = {
  __typename?: 'stops_database_parking_parking_payment_process_min_fields';
  parking_id?: Maybe<Scalars['bigint']>;
  parking_payment_process?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessMinOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
  parking_payment_process?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessMutationResponse = {
  __typename?: 'stops_database_parking_parking_payment_process_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseParkingParkingPaymentProcess>;
};

/** Ordering options when selecting data from "parking_parking_payment_process". */
export type StopsDatabaseParkingParkingPaymentProcessOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
  parking_payment_process?: InputMaybe<OrderBy>;
};

/** select columns of table "parking_parking_payment_process" */
export enum StopsDatabaseParkingParkingPaymentProcessSelectColumn {
  /** column name */
  ParkingId = 'parking_id',
  /** column name */
  ParkingPaymentProcess = 'parking_payment_process',
}

/** input type for updating data in table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessSetInput = {
  parking_id?: InputMaybe<Scalars['bigint']>;
  parking_payment_process?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingParkingPaymentProcessStddevFields = {
  __typename?: 'stops_database_parking_parking_payment_process_stddev_fields';
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessStddevOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingParkingPaymentProcessStddevPopFields = {
  __typename?: 'stops_database_parking_parking_payment_process_stddev_pop_fields';
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessStddevPopOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingParkingPaymentProcessStddevSampFields = {
  __typename?: 'stops_database_parking_parking_payment_process_stddev_samp_fields';
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessStddevSampOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseParkingParkingPaymentProcessStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingParkingPaymentProcessStreamCursorValueInput = {
  parking_id?: InputMaybe<Scalars['bigint']>;
  parking_payment_process?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingParkingPaymentProcessSumFields = {
  __typename?: 'stops_database_parking_parking_payment_process_sum_fields';
  parking_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessSumOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
};

export type StopsDatabaseParkingParkingPaymentProcessUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseParkingParkingPaymentProcessBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingParkingPaymentProcessVarPopFields = {
  __typename?: 'stops_database_parking_parking_payment_process_var_pop_fields';
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessVarPopOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingParkingPaymentProcessVarSampFields = {
  __typename?: 'stops_database_parking_parking_payment_process_var_samp_fields';
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessVarSampOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingParkingPaymentProcessVarianceFields = {
  __typename?: 'stops_database_parking_parking_payment_process_variance_fields';
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessVarianceOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
};

/** columns and relationships of "parking_parking_properties" */
export type StopsDatabaseParkingParkingProperties = {
  __typename?: 'stops_database_parking_parking_properties';
  parking_id: Scalars['bigint'];
  parking_properties_id: Scalars['bigint'];
};

/** aggregated selection of "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesAggregate = {
  __typename?: 'stops_database_parking_parking_properties_aggregate';
  aggregate?: Maybe<StopsDatabaseParkingParkingPropertiesAggregateFields>;
  nodes: Array<StopsDatabaseParkingParkingProperties>;
};

/** aggregate fields of "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesAggregateFields = {
  __typename?: 'stops_database_parking_parking_properties_aggregate_fields';
  avg?: Maybe<StopsDatabaseParkingParkingPropertiesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseParkingParkingPropertiesMaxFields>;
  min?: Maybe<StopsDatabaseParkingParkingPropertiesMinFields>;
  stddev?: Maybe<StopsDatabaseParkingParkingPropertiesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseParkingParkingPropertiesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseParkingParkingPropertiesStddevSampFields>;
  sum?: Maybe<StopsDatabaseParkingParkingPropertiesSumFields>;
  var_pop?: Maybe<StopsDatabaseParkingParkingPropertiesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseParkingParkingPropertiesVarSampFields>;
  variance?: Maybe<StopsDatabaseParkingParkingPropertiesVarianceFields>;
};

/** aggregate fields of "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesAggregateFieldsCountArgs = {
  columns?: InputMaybe<
    Array<StopsDatabaseParkingParkingPropertiesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseParkingParkingPropertiesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseParkingParkingPropertiesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseParkingParkingPropertiesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseParkingParkingPropertiesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseParkingParkingPropertiesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseParkingParkingPropertiesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseParkingParkingPropertiesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseParkingParkingPropertiesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseParkingParkingPropertiesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseParkingParkingPropertiesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesArrRelInsertInput = {
  data: Array<StopsDatabaseParkingParkingPropertiesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseParkingParkingPropertiesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingParkingPropertiesAvgFields = {
  __typename?: 'stops_database_parking_parking_properties_avg_fields';
  parking_id?: Maybe<Scalars['Float']>;
  parking_properties_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesAvgOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
  parking_properties_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "parking_parking_properties". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingParkingPropertiesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseParkingParkingPropertiesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseParkingParkingPropertiesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseParkingParkingPropertiesBoolExp>>;
  parking_id?: InputMaybe<BigintComparisonExp>;
  parking_properties_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "parking_parking_properties" */
export enum StopsDatabaseParkingParkingPropertiesConstraint {
  /** unique or primary key constraint on columns "parking_properties_id" */
  UkJ9vtca7vmg7ee8588wdseipvv = 'uk_j9vtca7vmg7ee8588wdseipvv',
}

/** input type for incrementing numeric columns in table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesIncInput = {
  parking_id?: InputMaybe<Scalars['bigint']>;
  parking_properties_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesInsertInput = {
  parking_id?: InputMaybe<Scalars['bigint']>;
  parking_properties_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingParkingPropertiesMaxFields = {
  __typename?: 'stops_database_parking_parking_properties_max_fields';
  parking_id?: Maybe<Scalars['bigint']>;
  parking_properties_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesMaxOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
  parking_properties_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingParkingPropertiesMinFields = {
  __typename?: 'stops_database_parking_parking_properties_min_fields';
  parking_id?: Maybe<Scalars['bigint']>;
  parking_properties_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesMinOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
  parking_properties_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesMutationResponse = {
  __typename?: 'stops_database_parking_parking_properties_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseParkingParkingProperties>;
};

/** on_conflict condition type for table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesOnConflict = {
  constraint: StopsDatabaseParkingParkingPropertiesConstraint;
  update_columns?: Array<StopsDatabaseParkingParkingPropertiesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseParkingParkingPropertiesBoolExp>;
};

/** Ordering options when selecting data from "parking_parking_properties". */
export type StopsDatabaseParkingParkingPropertiesOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
  parking_properties_id?: InputMaybe<OrderBy>;
};

/** select columns of table "parking_parking_properties" */
export enum StopsDatabaseParkingParkingPropertiesSelectColumn {
  /** column name */
  ParkingId = 'parking_id',
  /** column name */
  ParkingPropertiesId = 'parking_properties_id',
}

/** input type for updating data in table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesSetInput = {
  parking_id?: InputMaybe<Scalars['bigint']>;
  parking_properties_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingParkingPropertiesStddevFields = {
  __typename?: 'stops_database_parking_parking_properties_stddev_fields';
  parking_id?: Maybe<Scalars['Float']>;
  parking_properties_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesStddevOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
  parking_properties_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingParkingPropertiesStddevPopFields = {
  __typename?: 'stops_database_parking_parking_properties_stddev_pop_fields';
  parking_id?: Maybe<Scalars['Float']>;
  parking_properties_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesStddevPopOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
  parking_properties_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingParkingPropertiesStddevSampFields = {
  __typename?: 'stops_database_parking_parking_properties_stddev_samp_fields';
  parking_id?: Maybe<Scalars['Float']>;
  parking_properties_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesStddevSampOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
  parking_properties_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseParkingParkingPropertiesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingParkingPropertiesStreamCursorValueInput = {
  parking_id?: InputMaybe<Scalars['bigint']>;
  parking_properties_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingParkingPropertiesSumFields = {
  __typename?: 'stops_database_parking_parking_properties_sum_fields';
  parking_id?: Maybe<Scalars['bigint']>;
  parking_properties_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesSumOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
  parking_properties_id?: InputMaybe<OrderBy>;
};

/** update columns of table "parking_parking_properties" */
export enum StopsDatabaseParkingParkingPropertiesUpdateColumn {
  /** column name */
  ParkingId = 'parking_id',
  /** column name */
  ParkingPropertiesId = 'parking_properties_id',
}

export type StopsDatabaseParkingParkingPropertiesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseParkingParkingPropertiesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseParkingParkingPropertiesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseParkingParkingPropertiesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingParkingPropertiesVarPopFields = {
  __typename?: 'stops_database_parking_parking_properties_var_pop_fields';
  parking_id?: Maybe<Scalars['Float']>;
  parking_properties_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesVarPopOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
  parking_properties_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingParkingPropertiesVarSampFields = {
  __typename?: 'stops_database_parking_parking_properties_var_samp_fields';
  parking_id?: Maybe<Scalars['Float']>;
  parking_properties_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesVarSampOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
  parking_properties_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingParkingPropertiesVarianceFields = {
  __typename?: 'stops_database_parking_parking_properties_variance_fields';
  parking_id?: Maybe<Scalars['Float']>;
  parking_properties_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesVarianceOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
  parking_properties_id?: InputMaybe<OrderBy>;
};

/** columns and relationships of "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypes = {
  __typename?: 'stops_database_parking_parking_vehicle_types';
  parking_id: Scalars['bigint'];
  parking_vehicle_types?: Maybe<Scalars['String']>;
};

/** aggregated selection of "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesAggregate = {
  __typename?: 'stops_database_parking_parking_vehicle_types_aggregate';
  aggregate?: Maybe<StopsDatabaseParkingParkingVehicleTypesAggregateFields>;
  nodes: Array<StopsDatabaseParkingParkingVehicleTypes>;
};

/** aggregate fields of "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesAggregateFields = {
  __typename?: 'stops_database_parking_parking_vehicle_types_aggregate_fields';
  avg?: Maybe<StopsDatabaseParkingParkingVehicleTypesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseParkingParkingVehicleTypesMaxFields>;
  min?: Maybe<StopsDatabaseParkingParkingVehicleTypesMinFields>;
  stddev?: Maybe<StopsDatabaseParkingParkingVehicleTypesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseParkingParkingVehicleTypesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseParkingParkingVehicleTypesStddevSampFields>;
  sum?: Maybe<StopsDatabaseParkingParkingVehicleTypesSumFields>;
  var_pop?: Maybe<StopsDatabaseParkingParkingVehicleTypesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseParkingParkingVehicleTypesVarSampFields>;
  variance?: Maybe<StopsDatabaseParkingParkingVehicleTypesVarianceFields>;
};

/** aggregate fields of "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesAggregateFieldsCountArgs = {
  columns?: InputMaybe<
    Array<StopsDatabaseParkingParkingVehicleTypesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesArrRelInsertInput = {
  data: Array<StopsDatabaseParkingParkingVehicleTypesInsertInput>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingParkingVehicleTypesAvgFields = {
  __typename?: 'stops_database_parking_parking_vehicle_types_avg_fields';
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesAvgOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "parking_parking_vehicle_types". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingParkingVehicleTypesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseParkingParkingVehicleTypesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseParkingParkingVehicleTypesBoolExp>>;
  parking_id?: InputMaybe<BigintComparisonExp>;
  parking_vehicle_types?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesIncInput = {
  parking_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesInsertInput = {
  parking_id?: InputMaybe<Scalars['bigint']>;
  parking_vehicle_types?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingParkingVehicleTypesMaxFields = {
  __typename?: 'stops_database_parking_parking_vehicle_types_max_fields';
  parking_id?: Maybe<Scalars['bigint']>;
  parking_vehicle_types?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesMaxOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
  parking_vehicle_types?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingParkingVehicleTypesMinFields = {
  __typename?: 'stops_database_parking_parking_vehicle_types_min_fields';
  parking_id?: Maybe<Scalars['bigint']>;
  parking_vehicle_types?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesMinOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
  parking_vehicle_types?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesMutationResponse = {
  __typename?: 'stops_database_parking_parking_vehicle_types_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseParkingParkingVehicleTypes>;
};

/** Ordering options when selecting data from "parking_parking_vehicle_types". */
export type StopsDatabaseParkingParkingVehicleTypesOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
  parking_vehicle_types?: InputMaybe<OrderBy>;
};

/** select columns of table "parking_parking_vehicle_types" */
export enum StopsDatabaseParkingParkingVehicleTypesSelectColumn {
  /** column name */
  ParkingId = 'parking_id',
  /** column name */
  ParkingVehicleTypes = 'parking_vehicle_types',
}

/** input type for updating data in table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesSetInput = {
  parking_id?: InputMaybe<Scalars['bigint']>;
  parking_vehicle_types?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingParkingVehicleTypesStddevFields = {
  __typename?: 'stops_database_parking_parking_vehicle_types_stddev_fields';
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesStddevOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingParkingVehicleTypesStddevPopFields = {
  __typename?: 'stops_database_parking_parking_vehicle_types_stddev_pop_fields';
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesStddevPopOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingParkingVehicleTypesStddevSampFields = {
  __typename?: 'stops_database_parking_parking_vehicle_types_stddev_samp_fields';
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesStddevSampOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseParkingParkingVehicleTypesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingParkingVehicleTypesStreamCursorValueInput = {
  parking_id?: InputMaybe<Scalars['bigint']>;
  parking_vehicle_types?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingParkingVehicleTypesSumFields = {
  __typename?: 'stops_database_parking_parking_vehicle_types_sum_fields';
  parking_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesSumOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
};

export type StopsDatabaseParkingParkingVehicleTypesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseParkingParkingVehicleTypesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingParkingVehicleTypesVarPopFields = {
  __typename?: 'stops_database_parking_parking_vehicle_types_var_pop_fields';
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesVarPopOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingParkingVehicleTypesVarSampFields = {
  __typename?: 'stops_database_parking_parking_vehicle_types_var_samp_fields';
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesVarSampOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingParkingVehicleTypesVarianceFields = {
  __typename?: 'stops_database_parking_parking_vehicle_types_variance_fields';
  parking_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesVarianceOrderBy = {
  parking_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: parking */
export type StopsDatabaseParkingPkColumnsInput = {
  id: Scalars['bigint'];
};

/** columns and relationships of "parking_properties" */
export type StopsDatabaseParkingProperties = {
  __typename?: 'stops_database_parking_properties';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id: Scalars['bigint'];
  netex_id?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version: Scalars['bigint'];
  version_comment?: Maybe<Scalars['String']>;
};

/** aggregated selection of "parking_properties" */
export type StopsDatabaseParkingPropertiesAggregate = {
  __typename?: 'stops_database_parking_properties_aggregate';
  aggregate?: Maybe<StopsDatabaseParkingPropertiesAggregateFields>;
  nodes: Array<StopsDatabaseParkingProperties>;
};

/** aggregate fields of "parking_properties" */
export type StopsDatabaseParkingPropertiesAggregateFields = {
  __typename?: 'stops_database_parking_properties_aggregate_fields';
  avg?: Maybe<StopsDatabaseParkingPropertiesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseParkingPropertiesMaxFields>;
  min?: Maybe<StopsDatabaseParkingPropertiesMinFields>;
  stddev?: Maybe<StopsDatabaseParkingPropertiesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseParkingPropertiesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseParkingPropertiesStddevSampFields>;
  sum?: Maybe<StopsDatabaseParkingPropertiesSumFields>;
  var_pop?: Maybe<StopsDatabaseParkingPropertiesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseParkingPropertiesVarSampFields>;
  variance?: Maybe<StopsDatabaseParkingPropertiesVarianceFields>;
};

/** aggregate fields of "parking_properties" */
export type StopsDatabaseParkingPropertiesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseParkingPropertiesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingPropertiesAvgFields = {
  __typename?: 'stops_database_parking_properties_avg_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "parking_properties". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingPropertiesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseParkingPropertiesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseParkingPropertiesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseParkingPropertiesBoolExp>>;
  changed?: InputMaybe<TimestampComparisonExp>;
  changed_by?: InputMaybe<StringComparisonExp>;
  created?: InputMaybe<TimestampComparisonExp>;
  from_date?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  netex_id?: InputMaybe<StringComparisonExp>;
  to_date?: InputMaybe<TimestampComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
  version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "parking_properties" */
export enum StopsDatabaseParkingPropertiesConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  ParkingPropertiesNetexIdVersionConstraint = 'parking_properties_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  ParkingPropertiesPkey = 'parking_properties_pkey',
}

/** input type for incrementing numeric columns in table "parking_properties" */
export type StopsDatabaseParkingPropertiesIncInput = {
  id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "parking_properties" */
export type StopsDatabaseParkingPropertiesInsertInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  netex_id?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingPropertiesMaxFields = {
  __typename?: 'stops_database_parking_properties_max_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  netex_id?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingPropertiesMinFields = {
  __typename?: 'stops_database_parking_properties_min_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  netex_id?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "parking_properties" */
export type StopsDatabaseParkingPropertiesMutationResponse = {
  __typename?: 'stops_database_parking_properties_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseParkingProperties>;
};

/** input type for inserting object relation for remote table "parking_properties" */
export type StopsDatabaseParkingPropertiesObjRelInsertInput = {
  data: StopsDatabaseParkingPropertiesInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseParkingPropertiesOnConflict>;
};

/** on_conflict condition type for table "parking_properties" */
export type StopsDatabaseParkingPropertiesOnConflict = {
  constraint: StopsDatabaseParkingPropertiesConstraint;
  update_columns?: Array<StopsDatabaseParkingPropertiesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseParkingPropertiesBoolExp>;
};

/** Ordering options when selecting data from "parking_properties". */
export type StopsDatabaseParkingPropertiesOrderBy = {
  changed?: InputMaybe<OrderBy>;
  changed_by?: InputMaybe<OrderBy>;
  created?: InputMaybe<OrderBy>;
  from_date?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  netex_id?: InputMaybe<OrderBy>;
  to_date?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
  version_comment?: InputMaybe<OrderBy>;
};

/** columns and relationships of "parking_properties_parking_user_types" */
export type StopsDatabaseParkingPropertiesParkingUserTypes = {
  __typename?: 'stops_database_parking_properties_parking_user_types';
  parking_properties_id: Scalars['bigint'];
  parking_user_types?: Maybe<Scalars['String']>;
};

/** aggregated selection of "parking_properties_parking_user_types" */
export type StopsDatabaseParkingPropertiesParkingUserTypesAggregate = {
  __typename?: 'stops_database_parking_properties_parking_user_types_aggregate';
  aggregate?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesAggregateFields>;
  nodes: Array<StopsDatabaseParkingPropertiesParkingUserTypes>;
};

/** aggregate fields of "parking_properties_parking_user_types" */
export type StopsDatabaseParkingPropertiesParkingUserTypesAggregateFields = {
  __typename?: 'stops_database_parking_properties_parking_user_types_aggregate_fields';
  avg?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesMaxFields>;
  min?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesMinFields>;
  stddev?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesStddevSampFields>;
  sum?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesSumFields>;
  var_pop?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesVarSampFields>;
  variance?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesVarianceFields>;
};

/** aggregate fields of "parking_properties_parking_user_types" */
export type StopsDatabaseParkingPropertiesParkingUserTypesAggregateFieldsCountArgs =
  {
    columns?: InputMaybe<
      Array<StopsDatabaseParkingPropertiesParkingUserTypesSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
  };

/** aggregate avg on columns */
export type StopsDatabaseParkingPropertiesParkingUserTypesAvgFields = {
  __typename?: 'stops_database_parking_properties_parking_user_types_avg_fields';
  parking_properties_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "parking_properties_parking_user_types". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingPropertiesParkingUserTypesBoolExp = {
  _and?: InputMaybe<
    Array<StopsDatabaseParkingPropertiesParkingUserTypesBoolExp>
  >;
  _not?: InputMaybe<StopsDatabaseParkingPropertiesParkingUserTypesBoolExp>;
  _or?: InputMaybe<
    Array<StopsDatabaseParkingPropertiesParkingUserTypesBoolExp>
  >;
  parking_properties_id?: InputMaybe<BigintComparisonExp>;
  parking_user_types?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "parking_properties_parking_user_types" */
export type StopsDatabaseParkingPropertiesParkingUserTypesIncInput = {
  parking_properties_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "parking_properties_parking_user_types" */
export type StopsDatabaseParkingPropertiesParkingUserTypesInsertInput = {
  parking_properties_id?: InputMaybe<Scalars['bigint']>;
  parking_user_types?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingPropertiesParkingUserTypesMaxFields = {
  __typename?: 'stops_database_parking_properties_parking_user_types_max_fields';
  parking_properties_id?: Maybe<Scalars['bigint']>;
  parking_user_types?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingPropertiesParkingUserTypesMinFields = {
  __typename?: 'stops_database_parking_properties_parking_user_types_min_fields';
  parking_properties_id?: Maybe<Scalars['bigint']>;
  parking_user_types?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "parking_properties_parking_user_types" */
export type StopsDatabaseParkingPropertiesParkingUserTypesMutationResponse = {
  __typename?: 'stops_database_parking_properties_parking_user_types_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseParkingPropertiesParkingUserTypes>;
};

/** Ordering options when selecting data from "parking_properties_parking_user_types". */
export type StopsDatabaseParkingPropertiesParkingUserTypesOrderBy = {
  parking_properties_id?: InputMaybe<OrderBy>;
  parking_user_types?: InputMaybe<OrderBy>;
};

/** select columns of table "parking_properties_parking_user_types" */
export enum StopsDatabaseParkingPropertiesParkingUserTypesSelectColumn {
  /** column name */
  ParkingPropertiesId = 'parking_properties_id',
  /** column name */
  ParkingUserTypes = 'parking_user_types',
}

/** input type for updating data in table "parking_properties_parking_user_types" */
export type StopsDatabaseParkingPropertiesParkingUserTypesSetInput = {
  parking_properties_id?: InputMaybe<Scalars['bigint']>;
  parking_user_types?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingPropertiesParkingUserTypesStddevFields = {
  __typename?: 'stops_database_parking_properties_parking_user_types_stddev_fields';
  parking_properties_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingPropertiesParkingUserTypesStddevPopFields = {
  __typename?: 'stops_database_parking_properties_parking_user_types_stddev_pop_fields';
  parking_properties_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingPropertiesParkingUserTypesStddevSampFields = {
  __typename?: 'stops_database_parking_properties_parking_user_types_stddev_samp_fields';
  parking_properties_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "parking_properties_parking_user_types" */
export type StopsDatabaseParkingPropertiesParkingUserTypesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseParkingPropertiesParkingUserTypesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingPropertiesParkingUserTypesStreamCursorValueInput =
  {
    parking_properties_id?: InputMaybe<Scalars['bigint']>;
    parking_user_types?: InputMaybe<Scalars['String']>;
  };

/** aggregate sum on columns */
export type StopsDatabaseParkingPropertiesParkingUserTypesSumFields = {
  __typename?: 'stops_database_parking_properties_parking_user_types_sum_fields';
  parking_properties_id?: Maybe<Scalars['bigint']>;
};

export type StopsDatabaseParkingPropertiesParkingUserTypesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseParkingPropertiesParkingUserTypesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseParkingPropertiesParkingUserTypesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseParkingPropertiesParkingUserTypesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingPropertiesParkingUserTypesVarPopFields = {
  __typename?: 'stops_database_parking_properties_parking_user_types_var_pop_fields';
  parking_properties_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingPropertiesParkingUserTypesVarSampFields = {
  __typename?: 'stops_database_parking_properties_parking_user_types_var_samp_fields';
  parking_properties_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingPropertiesParkingUserTypesVarianceFields = {
  __typename?: 'stops_database_parking_properties_parking_user_types_variance_fields';
  parking_properties_id?: Maybe<Scalars['Float']>;
};

/** primary key columns input for table: parking_properties */
export type StopsDatabaseParkingPropertiesPkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "parking_properties" */
export enum StopsDatabaseParkingPropertiesSelectColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

/** input type for updating data in table "parking_properties" */
export type StopsDatabaseParkingPropertiesSetInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  netex_id?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "parking_properties_spaces" */
export type StopsDatabaseParkingPropertiesSpaces = {
  __typename?: 'stops_database_parking_properties_spaces';
  parking_properties_id: Scalars['bigint'];
  spaces_id: Scalars['bigint'];
};

/** aggregated selection of "parking_properties_spaces" */
export type StopsDatabaseParkingPropertiesSpacesAggregate = {
  __typename?: 'stops_database_parking_properties_spaces_aggregate';
  aggregate?: Maybe<StopsDatabaseParkingPropertiesSpacesAggregateFields>;
  nodes: Array<StopsDatabaseParkingPropertiesSpaces>;
};

/** aggregate fields of "parking_properties_spaces" */
export type StopsDatabaseParkingPropertiesSpacesAggregateFields = {
  __typename?: 'stops_database_parking_properties_spaces_aggregate_fields';
  avg?: Maybe<StopsDatabaseParkingPropertiesSpacesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseParkingPropertiesSpacesMaxFields>;
  min?: Maybe<StopsDatabaseParkingPropertiesSpacesMinFields>;
  stddev?: Maybe<StopsDatabaseParkingPropertiesSpacesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseParkingPropertiesSpacesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseParkingPropertiesSpacesStddevSampFields>;
  sum?: Maybe<StopsDatabaseParkingPropertiesSpacesSumFields>;
  var_pop?: Maybe<StopsDatabaseParkingPropertiesSpacesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseParkingPropertiesSpacesVarSampFields>;
  variance?: Maybe<StopsDatabaseParkingPropertiesSpacesVarianceFields>;
};

/** aggregate fields of "parking_properties_spaces" */
export type StopsDatabaseParkingPropertiesSpacesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseParkingPropertiesSpacesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingPropertiesSpacesAvgFields = {
  __typename?: 'stops_database_parking_properties_spaces_avg_fields';
  parking_properties_id?: Maybe<Scalars['Float']>;
  spaces_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "parking_properties_spaces". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingPropertiesSpacesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseParkingPropertiesSpacesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseParkingPropertiesSpacesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseParkingPropertiesSpacesBoolExp>>;
  parking_properties_id?: InputMaybe<BigintComparisonExp>;
  spaces_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "parking_properties_spaces" */
export enum StopsDatabaseParkingPropertiesSpacesConstraint {
  /** unique or primary key constraint on columns "spaces_id" */
  Uk_2rhu1u10q5achulke0kwg4e0o = 'uk_2rhu1u10q5achulke0kwg4e0o',
}

/** input type for incrementing numeric columns in table "parking_properties_spaces" */
export type StopsDatabaseParkingPropertiesSpacesIncInput = {
  parking_properties_id?: InputMaybe<Scalars['bigint']>;
  spaces_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "parking_properties_spaces" */
export type StopsDatabaseParkingPropertiesSpacesInsertInput = {
  parking_properties_id?: InputMaybe<Scalars['bigint']>;
  spaces_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingPropertiesSpacesMaxFields = {
  __typename?: 'stops_database_parking_properties_spaces_max_fields';
  parking_properties_id?: Maybe<Scalars['bigint']>;
  spaces_id?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingPropertiesSpacesMinFields = {
  __typename?: 'stops_database_parking_properties_spaces_min_fields';
  parking_properties_id?: Maybe<Scalars['bigint']>;
  spaces_id?: Maybe<Scalars['bigint']>;
};

/** response of any mutation on the table "parking_properties_spaces" */
export type StopsDatabaseParkingPropertiesSpacesMutationResponse = {
  __typename?: 'stops_database_parking_properties_spaces_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseParkingPropertiesSpaces>;
};

/** on_conflict condition type for table "parking_properties_spaces" */
export type StopsDatabaseParkingPropertiesSpacesOnConflict = {
  constraint: StopsDatabaseParkingPropertiesSpacesConstraint;
  update_columns?: Array<StopsDatabaseParkingPropertiesSpacesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseParkingPropertiesSpacesBoolExp>;
};

/** Ordering options when selecting data from "parking_properties_spaces". */
export type StopsDatabaseParkingPropertiesSpacesOrderBy = {
  parking_properties_id?: InputMaybe<OrderBy>;
  spaces_id?: InputMaybe<OrderBy>;
};

/** select columns of table "parking_properties_spaces" */
export enum StopsDatabaseParkingPropertiesSpacesSelectColumn {
  /** column name */
  ParkingPropertiesId = 'parking_properties_id',
  /** column name */
  SpacesId = 'spaces_id',
}

/** input type for updating data in table "parking_properties_spaces" */
export type StopsDatabaseParkingPropertiesSpacesSetInput = {
  parking_properties_id?: InputMaybe<Scalars['bigint']>;
  spaces_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingPropertiesSpacesStddevFields = {
  __typename?: 'stops_database_parking_properties_spaces_stddev_fields';
  parking_properties_id?: Maybe<Scalars['Float']>;
  spaces_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingPropertiesSpacesStddevPopFields = {
  __typename?: 'stops_database_parking_properties_spaces_stddev_pop_fields';
  parking_properties_id?: Maybe<Scalars['Float']>;
  spaces_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingPropertiesSpacesStddevSampFields = {
  __typename?: 'stops_database_parking_properties_spaces_stddev_samp_fields';
  parking_properties_id?: Maybe<Scalars['Float']>;
  spaces_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "parking_properties_spaces" */
export type StopsDatabaseParkingPropertiesSpacesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseParkingPropertiesSpacesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingPropertiesSpacesStreamCursorValueInput = {
  parking_properties_id?: InputMaybe<Scalars['bigint']>;
  spaces_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingPropertiesSpacesSumFields = {
  __typename?: 'stops_database_parking_properties_spaces_sum_fields';
  parking_properties_id?: Maybe<Scalars['bigint']>;
  spaces_id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "parking_properties_spaces" */
export enum StopsDatabaseParkingPropertiesSpacesUpdateColumn {
  /** column name */
  ParkingPropertiesId = 'parking_properties_id',
  /** column name */
  SpacesId = 'spaces_id',
}

export type StopsDatabaseParkingPropertiesSpacesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseParkingPropertiesSpacesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseParkingPropertiesSpacesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseParkingPropertiesSpacesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingPropertiesSpacesVarPopFields = {
  __typename?: 'stops_database_parking_properties_spaces_var_pop_fields';
  parking_properties_id?: Maybe<Scalars['Float']>;
  spaces_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingPropertiesSpacesVarSampFields = {
  __typename?: 'stops_database_parking_properties_spaces_var_samp_fields';
  parking_properties_id?: Maybe<Scalars['Float']>;
  spaces_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingPropertiesSpacesVarianceFields = {
  __typename?: 'stops_database_parking_properties_spaces_variance_fields';
  parking_properties_id?: Maybe<Scalars['Float']>;
  spaces_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingPropertiesStddevFields = {
  __typename?: 'stops_database_parking_properties_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingPropertiesStddevPopFields = {
  __typename?: 'stops_database_parking_properties_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingPropertiesStddevSampFields = {
  __typename?: 'stops_database_parking_properties_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "parking_properties" */
export type StopsDatabaseParkingPropertiesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseParkingPropertiesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingPropertiesStreamCursorValueInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  netex_id?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingPropertiesSumFields = {
  __typename?: 'stops_database_parking_properties_sum_fields';
  id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['bigint']>;
};

/** update columns of table "parking_properties" */
export enum StopsDatabaseParkingPropertiesUpdateColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

export type StopsDatabaseParkingPropertiesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseParkingPropertiesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseParkingPropertiesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseParkingPropertiesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingPropertiesVarPopFields = {
  __typename?: 'stops_database_parking_properties_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingPropertiesVarSampFields = {
  __typename?: 'stops_database_parking_properties_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingPropertiesVarianceFields = {
  __typename?: 'stops_database_parking_properties_variance_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** select columns of table "parking" */
export enum StopsDatabaseParkingSelectColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  BookingUrl = 'booking_url',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FreeParkingOutOfHours = 'free_parking_out_of_hours',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  NumberOfParkingLevels = 'number_of_parking_levels',
  /** column name */
  OvernightParkingPermitted = 'overnight_parking_permitted',
  /** column name */
  ParentSiteRef = 'parent_site_ref',
  /** column name */
  ParentSiteRefVersion = 'parent_site_ref_version',
  /** column name */
  ParkingLayout = 'parking_layout',
  /** column name */
  ParkingReservation = 'parking_reservation',
  /** column name */
  ParkingType = 'parking_type',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrincipalCapacity = 'principal_capacity',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ProhibitedForHazardousMaterials = 'prohibited_for_hazardous_materials',
  /** column name */
  RealTimeOccupancyAvailable = 'real_time_occupancy_available',
  /** column name */
  RechargingAvailable = 'recharging_available',
  /** column name */
  Secure = 'secure',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TopographicPlaceId = 'topographic_place_id',
  /** column name */
  TotalCapacity = 'total_capacity',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

/** input type for updating data in table "parking" */
export type StopsDatabaseParkingSetInput = {
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']>;
  booking_url?: InputMaybe<Scalars['String']>;
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  covered?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  free_parking_out_of_hours?: InputMaybe<Scalars['Boolean']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  number_of_parking_levels?: InputMaybe<Scalars['numeric']>;
  overnight_parking_permitted?: InputMaybe<Scalars['Boolean']>;
  parent_site_ref?: InputMaybe<Scalars['String']>;
  parent_site_ref_version?: InputMaybe<Scalars['String']>;
  parking_layout?: InputMaybe<Scalars['Int']>;
  parking_reservation?: InputMaybe<Scalars['Int']>;
  parking_type?: InputMaybe<Scalars['String']>;
  place_equipments_id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  principal_capacity?: InputMaybe<Scalars['numeric']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  prohibited_for_hazardous_materials?: InputMaybe<Scalars['Boolean']>;
  real_time_occupancy_available?: InputMaybe<Scalars['Boolean']>;
  recharging_available?: InputMaybe<Scalars['Boolean']>;
  secure?: InputMaybe<Scalars['Boolean']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  topographic_place_id?: InputMaybe<Scalars['bigint']>;
  total_capacity?: InputMaybe<Scalars['numeric']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingStddevFields = {
  __typename?: 'stops_database_parking_stddev_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  number_of_parking_levels?: Maybe<Scalars['Float']>;
  parking_layout?: Maybe<Scalars['Float']>;
  parking_reservation?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  principal_capacity?: Maybe<Scalars['Float']>;
  topographic_place_id?: Maybe<Scalars['Float']>;
  total_capacity?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingStddevPopFields = {
  __typename?: 'stops_database_parking_stddev_pop_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  number_of_parking_levels?: Maybe<Scalars['Float']>;
  parking_layout?: Maybe<Scalars['Float']>;
  parking_reservation?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  principal_capacity?: Maybe<Scalars['Float']>;
  topographic_place_id?: Maybe<Scalars['Float']>;
  total_capacity?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingStddevSampFields = {
  __typename?: 'stops_database_parking_stddev_samp_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  number_of_parking_levels?: Maybe<Scalars['Float']>;
  parking_layout?: Maybe<Scalars['Float']>;
  parking_reservation?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  principal_capacity?: Maybe<Scalars['Float']>;
  topographic_place_id?: Maybe<Scalars['Float']>;
  total_capacity?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "parking" */
export type StopsDatabaseParkingStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseParkingStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingStreamCursorValueInput = {
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']>;
  booking_url?: InputMaybe<Scalars['String']>;
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  covered?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  free_parking_out_of_hours?: InputMaybe<Scalars['Boolean']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  number_of_parking_levels?: InputMaybe<Scalars['numeric']>;
  overnight_parking_permitted?: InputMaybe<Scalars['Boolean']>;
  parent_site_ref?: InputMaybe<Scalars['String']>;
  parent_site_ref_version?: InputMaybe<Scalars['String']>;
  parking_layout?: InputMaybe<Scalars['Int']>;
  parking_reservation?: InputMaybe<Scalars['Int']>;
  parking_type?: InputMaybe<Scalars['String']>;
  place_equipments_id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  principal_capacity?: InputMaybe<Scalars['numeric']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  prohibited_for_hazardous_materials?: InputMaybe<Scalars['Boolean']>;
  real_time_occupancy_available?: InputMaybe<Scalars['Boolean']>;
  recharging_available?: InputMaybe<Scalars['Boolean']>;
  secure?: InputMaybe<Scalars['Boolean']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  topographic_place_id?: InputMaybe<Scalars['bigint']>;
  total_capacity?: InputMaybe<Scalars['numeric']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingSumFields = {
  __typename?: 'stops_database_parking_sum_fields';
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  covered?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['bigint']>;
  number_of_parking_levels?: Maybe<Scalars['numeric']>;
  parking_layout?: Maybe<Scalars['Int']>;
  parking_reservation?: Maybe<Scalars['Int']>;
  place_equipments_id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  principal_capacity?: Maybe<Scalars['numeric']>;
  topographic_place_id?: Maybe<Scalars['bigint']>;
  total_capacity?: Maybe<Scalars['numeric']>;
  version?: Maybe<Scalars['bigint']>;
};

/** update columns of table "parking" */
export enum StopsDatabaseParkingUpdateColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  BookingUrl = 'booking_url',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FreeParkingOutOfHours = 'free_parking_out_of_hours',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  NumberOfParkingLevels = 'number_of_parking_levels',
  /** column name */
  OvernightParkingPermitted = 'overnight_parking_permitted',
  /** column name */
  ParentSiteRef = 'parent_site_ref',
  /** column name */
  ParentSiteRefVersion = 'parent_site_ref_version',
  /** column name */
  ParkingLayout = 'parking_layout',
  /** column name */
  ParkingReservation = 'parking_reservation',
  /** column name */
  ParkingType = 'parking_type',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrincipalCapacity = 'principal_capacity',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ProhibitedForHazardousMaterials = 'prohibited_for_hazardous_materials',
  /** column name */
  RealTimeOccupancyAvailable = 'real_time_occupancy_available',
  /** column name */
  RechargingAvailable = 'recharging_available',
  /** column name */
  Secure = 'secure',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TopographicPlaceId = 'topographic_place_id',
  /** column name */
  TotalCapacity = 'total_capacity',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

export type StopsDatabaseParkingUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseParkingIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseParkingSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseParkingBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingVarPopFields = {
  __typename?: 'stops_database_parking_var_pop_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  number_of_parking_levels?: Maybe<Scalars['Float']>;
  parking_layout?: Maybe<Scalars['Float']>;
  parking_reservation?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  principal_capacity?: Maybe<Scalars['Float']>;
  topographic_place_id?: Maybe<Scalars['Float']>;
  total_capacity?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingVarSampFields = {
  __typename?: 'stops_database_parking_var_samp_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  number_of_parking_levels?: Maybe<Scalars['Float']>;
  parking_layout?: Maybe<Scalars['Float']>;
  parking_reservation?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  principal_capacity?: Maybe<Scalars['Float']>;
  topographic_place_id?: Maybe<Scalars['Float']>;
  total_capacity?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingVarianceFields = {
  __typename?: 'stops_database_parking_variance_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  number_of_parking_levels?: Maybe<Scalars['Float']>;
  parking_layout?: Maybe<Scalars['Float']>;
  parking_reservation?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  principal_capacity?: Maybe<Scalars['Float']>;
  topographic_place_id?: Maybe<Scalars['Float']>;
  total_capacity?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "path_junction" */
export type StopsDatabasePathJunction = {
  __typename?: 'stops_database_path_junction';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id: Scalars['bigint'];
  netex_id?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version: Scalars['bigint'];
  version_comment?: Maybe<Scalars['String']>;
};

/** aggregated selection of "path_junction" */
export type StopsDatabasePathJunctionAggregate = {
  __typename?: 'stops_database_path_junction_aggregate';
  aggregate?: Maybe<StopsDatabasePathJunctionAggregateFields>;
  nodes: Array<StopsDatabasePathJunction>;
};

/** aggregate fields of "path_junction" */
export type StopsDatabasePathJunctionAggregateFields = {
  __typename?: 'stops_database_path_junction_aggregate_fields';
  avg?: Maybe<StopsDatabasePathJunctionAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabasePathJunctionMaxFields>;
  min?: Maybe<StopsDatabasePathJunctionMinFields>;
  stddev?: Maybe<StopsDatabasePathJunctionStddevFields>;
  stddev_pop?: Maybe<StopsDatabasePathJunctionStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabasePathJunctionStddevSampFields>;
  sum?: Maybe<StopsDatabasePathJunctionSumFields>;
  var_pop?: Maybe<StopsDatabasePathJunctionVarPopFields>;
  var_samp?: Maybe<StopsDatabasePathJunctionVarSampFields>;
  variance?: Maybe<StopsDatabasePathJunctionVarianceFields>;
};

/** aggregate fields of "path_junction" */
export type StopsDatabasePathJunctionAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabasePathJunctionSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabasePathJunctionAvgFields = {
  __typename?: 'stops_database_path_junction_avg_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "path_junction". All fields are combined with a logical 'AND'. */
export type StopsDatabasePathJunctionBoolExp = {
  _and?: InputMaybe<Array<StopsDatabasePathJunctionBoolExp>>;
  _not?: InputMaybe<StopsDatabasePathJunctionBoolExp>;
  _or?: InputMaybe<Array<StopsDatabasePathJunctionBoolExp>>;
  changed?: InputMaybe<TimestampComparisonExp>;
  changed_by?: InputMaybe<StringComparisonExp>;
  created?: InputMaybe<TimestampComparisonExp>;
  from_date?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  netex_id?: InputMaybe<StringComparisonExp>;
  to_date?: InputMaybe<TimestampComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
  version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "path_junction" */
export enum StopsDatabasePathJunctionConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  PathJunctionNetexIdVersionConstraint = 'path_junction_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  PathJunctionPkey = 'path_junction_pkey',
}

/** input type for incrementing numeric columns in table "path_junction" */
export type StopsDatabasePathJunctionIncInput = {
  id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "path_junction" */
export type StopsDatabasePathJunctionInsertInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  netex_id?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "path_junction_key_values" */
export type StopsDatabasePathJunctionKeyValues = {
  __typename?: 'stops_database_path_junction_key_values';
  key_values_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
  path_junction_id: Scalars['bigint'];
};

/** aggregated selection of "path_junction_key_values" */
export type StopsDatabasePathJunctionKeyValuesAggregate = {
  __typename?: 'stops_database_path_junction_key_values_aggregate';
  aggregate?: Maybe<StopsDatabasePathJunctionKeyValuesAggregateFields>;
  nodes: Array<StopsDatabasePathJunctionKeyValues>;
};

/** aggregate fields of "path_junction_key_values" */
export type StopsDatabasePathJunctionKeyValuesAggregateFields = {
  __typename?: 'stops_database_path_junction_key_values_aggregate_fields';
  avg?: Maybe<StopsDatabasePathJunctionKeyValuesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabasePathJunctionKeyValuesMaxFields>;
  min?: Maybe<StopsDatabasePathJunctionKeyValuesMinFields>;
  stddev?: Maybe<StopsDatabasePathJunctionKeyValuesStddevFields>;
  stddev_pop?: Maybe<StopsDatabasePathJunctionKeyValuesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabasePathJunctionKeyValuesStddevSampFields>;
  sum?: Maybe<StopsDatabasePathJunctionKeyValuesSumFields>;
  var_pop?: Maybe<StopsDatabasePathJunctionKeyValuesVarPopFields>;
  var_samp?: Maybe<StopsDatabasePathJunctionKeyValuesVarSampFields>;
  variance?: Maybe<StopsDatabasePathJunctionKeyValuesVarianceFields>;
};

/** aggregate fields of "path_junction_key_values" */
export type StopsDatabasePathJunctionKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabasePathJunctionKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabasePathJunctionKeyValuesAvgFields = {
  __typename?: 'stops_database_path_junction_key_values_avg_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  path_junction_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "path_junction_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabasePathJunctionKeyValuesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabasePathJunctionKeyValuesBoolExp>>;
  _not?: InputMaybe<StopsDatabasePathJunctionKeyValuesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabasePathJunctionKeyValuesBoolExp>>;
  key_values_id?: InputMaybe<BigintComparisonExp>;
  key_values_key?: InputMaybe<StringComparisonExp>;
  path_junction_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "path_junction_key_values" */
export enum StopsDatabasePathJunctionKeyValuesConstraint {
  /** unique or primary key constraint on columns "path_junction_id", "key_values_key" */
  PathJunctionKeyValuesPkey = 'path_junction_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  Uk_8au15celles62v9ug5bvq2t4x = 'uk_8au15celles62v9ug5bvq2t4x',
}

/** input type for incrementing numeric columns in table "path_junction_key_values" */
export type StopsDatabasePathJunctionKeyValuesIncInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  path_junction_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "path_junction_key_values" */
export type StopsDatabasePathJunctionKeyValuesInsertInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  path_junction_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabasePathJunctionKeyValuesMaxFields = {
  __typename?: 'stops_database_path_junction_key_values_max_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
  path_junction_id?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type StopsDatabasePathJunctionKeyValuesMinFields = {
  __typename?: 'stops_database_path_junction_key_values_min_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
  path_junction_id?: Maybe<Scalars['bigint']>;
};

/** response of any mutation on the table "path_junction_key_values" */
export type StopsDatabasePathJunctionKeyValuesMutationResponse = {
  __typename?: 'stops_database_path_junction_key_values_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabasePathJunctionKeyValues>;
};

/** on_conflict condition type for table "path_junction_key_values" */
export type StopsDatabasePathJunctionKeyValuesOnConflict = {
  constraint: StopsDatabasePathJunctionKeyValuesConstraint;
  update_columns?: Array<StopsDatabasePathJunctionKeyValuesUpdateColumn>;
  where?: InputMaybe<StopsDatabasePathJunctionKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "path_junction_key_values". */
export type StopsDatabasePathJunctionKeyValuesOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  path_junction_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: path_junction_key_values */
export type StopsDatabasePathJunctionKeyValuesPkColumnsInput = {
  key_values_key: Scalars['String'];
  path_junction_id: Scalars['bigint'];
};

/** select columns of table "path_junction_key_values" */
export enum StopsDatabasePathJunctionKeyValuesSelectColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  PathJunctionId = 'path_junction_id',
}

/** input type for updating data in table "path_junction_key_values" */
export type StopsDatabasePathJunctionKeyValuesSetInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  path_junction_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabasePathJunctionKeyValuesStddevFields = {
  __typename?: 'stops_database_path_junction_key_values_stddev_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  path_junction_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabasePathJunctionKeyValuesStddevPopFields = {
  __typename?: 'stops_database_path_junction_key_values_stddev_pop_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  path_junction_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabasePathJunctionKeyValuesStddevSampFields = {
  __typename?: 'stops_database_path_junction_key_values_stddev_samp_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  path_junction_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "path_junction_key_values" */
export type StopsDatabasePathJunctionKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabasePathJunctionKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabasePathJunctionKeyValuesStreamCursorValueInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  path_junction_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabasePathJunctionKeyValuesSumFields = {
  __typename?: 'stops_database_path_junction_key_values_sum_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  path_junction_id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "path_junction_key_values" */
export enum StopsDatabasePathJunctionKeyValuesUpdateColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  PathJunctionId = 'path_junction_id',
}

export type StopsDatabasePathJunctionKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabasePathJunctionKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabasePathJunctionKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabasePathJunctionKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabasePathJunctionKeyValuesVarPopFields = {
  __typename?: 'stops_database_path_junction_key_values_var_pop_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  path_junction_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabasePathJunctionKeyValuesVarSampFields = {
  __typename?: 'stops_database_path_junction_key_values_var_samp_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  path_junction_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabasePathJunctionKeyValuesVarianceFields = {
  __typename?: 'stops_database_path_junction_key_values_variance_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  path_junction_id?: Maybe<Scalars['Float']>;
};

/** aggregate max on columns */
export type StopsDatabasePathJunctionMaxFields = {
  __typename?: 'stops_database_path_junction_max_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  netex_id?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabasePathJunctionMinFields = {
  __typename?: 'stops_database_path_junction_min_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  netex_id?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "path_junction" */
export type StopsDatabasePathJunctionMutationResponse = {
  __typename?: 'stops_database_path_junction_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabasePathJunction>;
};

/** on_conflict condition type for table "path_junction" */
export type StopsDatabasePathJunctionOnConflict = {
  constraint: StopsDatabasePathJunctionConstraint;
  update_columns?: Array<StopsDatabasePathJunctionUpdateColumn>;
  where?: InputMaybe<StopsDatabasePathJunctionBoolExp>;
};

/** Ordering options when selecting data from "path_junction". */
export type StopsDatabasePathJunctionOrderBy = {
  changed?: InputMaybe<OrderBy>;
  changed_by?: InputMaybe<OrderBy>;
  created?: InputMaybe<OrderBy>;
  from_date?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  netex_id?: InputMaybe<OrderBy>;
  to_date?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
  version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: path_junction */
export type StopsDatabasePathJunctionPkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "path_junction" */
export enum StopsDatabasePathJunctionSelectColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

/** input type for updating data in table "path_junction" */
export type StopsDatabasePathJunctionSetInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  netex_id?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabasePathJunctionStddevFields = {
  __typename?: 'stops_database_path_junction_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabasePathJunctionStddevPopFields = {
  __typename?: 'stops_database_path_junction_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabasePathJunctionStddevSampFields = {
  __typename?: 'stops_database_path_junction_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "path_junction" */
export type StopsDatabasePathJunctionStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabasePathJunctionStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabasePathJunctionStreamCursorValueInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  netex_id?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabasePathJunctionSumFields = {
  __typename?: 'stops_database_path_junction_sum_fields';
  id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['bigint']>;
};

/** update columns of table "path_junction" */
export enum StopsDatabasePathJunctionUpdateColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

export type StopsDatabasePathJunctionUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabasePathJunctionIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabasePathJunctionSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabasePathJunctionBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabasePathJunctionVarPopFields = {
  __typename?: 'stops_database_path_junction_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabasePathJunctionVarSampFields = {
  __typename?: 'stops_database_path_junction_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabasePathJunctionVarianceFields = {
  __typename?: 'stops_database_path_junction_variance_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "path_link" */
export type StopsDatabasePathLink = {
  __typename?: 'stops_database_path_link';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  default_duration?: Maybe<Scalars['bytea']>;
  frequent_traveller_duration?: Maybe<Scalars['bytea']>;
  from_date?: Maybe<Scalars['timestamp']>;
  from_id: Scalars['bigint'];
  id: Scalars['bigint'];
  line_string?: Maybe<Scalars['geometry']>;
  mobility_restricted_traveller_duration?: Maybe<Scalars['bytea']>;
  netex_id?: Maybe<Scalars['String']>;
  occasional_traveller_duration?: Maybe<Scalars['bytea']>;
  to_date?: Maybe<Scalars['timestamp']>;
  to_id: Scalars['bigint'];
  version: Scalars['bigint'];
  version_comment?: Maybe<Scalars['String']>;
};

/** aggregated selection of "path_link" */
export type StopsDatabasePathLinkAggregate = {
  __typename?: 'stops_database_path_link_aggregate';
  aggregate?: Maybe<StopsDatabasePathLinkAggregateFields>;
  nodes: Array<StopsDatabasePathLink>;
};

/** aggregate fields of "path_link" */
export type StopsDatabasePathLinkAggregateFields = {
  __typename?: 'stops_database_path_link_aggregate_fields';
  avg?: Maybe<StopsDatabasePathLinkAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabasePathLinkMaxFields>;
  min?: Maybe<StopsDatabasePathLinkMinFields>;
  stddev?: Maybe<StopsDatabasePathLinkStddevFields>;
  stddev_pop?: Maybe<StopsDatabasePathLinkStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabasePathLinkStddevSampFields>;
  sum?: Maybe<StopsDatabasePathLinkSumFields>;
  var_pop?: Maybe<StopsDatabasePathLinkVarPopFields>;
  var_samp?: Maybe<StopsDatabasePathLinkVarSampFields>;
  variance?: Maybe<StopsDatabasePathLinkVarianceFields>;
};

/** aggregate fields of "path_link" */
export type StopsDatabasePathLinkAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabasePathLinkSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabasePathLinkAvgFields = {
  __typename?: 'stops_database_path_link_avg_fields';
  from_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  to_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "path_link". All fields are combined with a logical 'AND'. */
export type StopsDatabasePathLinkBoolExp = {
  _and?: InputMaybe<Array<StopsDatabasePathLinkBoolExp>>;
  _not?: InputMaybe<StopsDatabasePathLinkBoolExp>;
  _or?: InputMaybe<Array<StopsDatabasePathLinkBoolExp>>;
  changed?: InputMaybe<TimestampComparisonExp>;
  changed_by?: InputMaybe<StringComparisonExp>;
  created?: InputMaybe<TimestampComparisonExp>;
  default_duration?: InputMaybe<ByteaComparisonExp>;
  frequent_traveller_duration?: InputMaybe<ByteaComparisonExp>;
  from_date?: InputMaybe<TimestampComparisonExp>;
  from_id?: InputMaybe<BigintComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  line_string?: InputMaybe<GeometryComparisonExp>;
  mobility_restricted_traveller_duration?: InputMaybe<ByteaComparisonExp>;
  netex_id?: InputMaybe<StringComparisonExp>;
  occasional_traveller_duration?: InputMaybe<ByteaComparisonExp>;
  to_date?: InputMaybe<TimestampComparisonExp>;
  to_id?: InputMaybe<BigintComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
  version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "path_link" */
export enum StopsDatabasePathLinkConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  PathLinkNetexIdVersionConstraint = 'path_link_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  PathLinkPkey = 'path_link_pkey',
}

/** columns and relationships of "path_link_end" */
export type StopsDatabasePathLinkEnd = {
  __typename?: 'stops_database_path_link_end';
  id: Scalars['bigint'];
  netex_id?: Maybe<Scalars['String']>;
  path_junction_id?: Maybe<Scalars['bigint']>;
  place_ref?: Maybe<Scalars['String']>;
  place_version?: Maybe<Scalars['String']>;
};

/** aggregated selection of "path_link_end" */
export type StopsDatabasePathLinkEndAggregate = {
  __typename?: 'stops_database_path_link_end_aggregate';
  aggregate?: Maybe<StopsDatabasePathLinkEndAggregateFields>;
  nodes: Array<StopsDatabasePathLinkEnd>;
};

/** aggregate fields of "path_link_end" */
export type StopsDatabasePathLinkEndAggregateFields = {
  __typename?: 'stops_database_path_link_end_aggregate_fields';
  avg?: Maybe<StopsDatabasePathLinkEndAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabasePathLinkEndMaxFields>;
  min?: Maybe<StopsDatabasePathLinkEndMinFields>;
  stddev?: Maybe<StopsDatabasePathLinkEndStddevFields>;
  stddev_pop?: Maybe<StopsDatabasePathLinkEndStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabasePathLinkEndStddevSampFields>;
  sum?: Maybe<StopsDatabasePathLinkEndSumFields>;
  var_pop?: Maybe<StopsDatabasePathLinkEndVarPopFields>;
  var_samp?: Maybe<StopsDatabasePathLinkEndVarSampFields>;
  variance?: Maybe<StopsDatabasePathLinkEndVarianceFields>;
};

/** aggregate fields of "path_link_end" */
export type StopsDatabasePathLinkEndAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabasePathLinkEndSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabasePathLinkEndAvgFields = {
  __typename?: 'stops_database_path_link_end_avg_fields';
  id?: Maybe<Scalars['Float']>;
  path_junction_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "path_link_end". All fields are combined with a logical 'AND'. */
export type StopsDatabasePathLinkEndBoolExp = {
  _and?: InputMaybe<Array<StopsDatabasePathLinkEndBoolExp>>;
  _not?: InputMaybe<StopsDatabasePathLinkEndBoolExp>;
  _or?: InputMaybe<Array<StopsDatabasePathLinkEndBoolExp>>;
  id?: InputMaybe<BigintComparisonExp>;
  netex_id?: InputMaybe<StringComparisonExp>;
  path_junction_id?: InputMaybe<BigintComparisonExp>;
  place_ref?: InputMaybe<StringComparisonExp>;
  place_version?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "path_link_end" */
export enum StopsDatabasePathLinkEndConstraint {
  /** unique or primary key constraint on columns "netex_id" */
  PathLinkEndNetexIdConstraint = 'path_link_end_netex_id_constraint',
  /** unique or primary key constraint on columns "id" */
  PathLinkEndPkey = 'path_link_end_pkey',
}

/** input type for incrementing numeric columns in table "path_link_end" */
export type StopsDatabasePathLinkEndIncInput = {
  id?: InputMaybe<Scalars['bigint']>;
  path_junction_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "path_link_end" */
export type StopsDatabasePathLinkEndInsertInput = {
  id?: InputMaybe<Scalars['bigint']>;
  netex_id?: InputMaybe<Scalars['String']>;
  path_junction_id?: InputMaybe<Scalars['bigint']>;
  place_ref?: InputMaybe<Scalars['String']>;
  place_version?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type StopsDatabasePathLinkEndMaxFields = {
  __typename?: 'stops_database_path_link_end_max_fields';
  id?: Maybe<Scalars['bigint']>;
  netex_id?: Maybe<Scalars['String']>;
  path_junction_id?: Maybe<Scalars['bigint']>;
  place_ref?: Maybe<Scalars['String']>;
  place_version?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabasePathLinkEndMinFields = {
  __typename?: 'stops_database_path_link_end_min_fields';
  id?: Maybe<Scalars['bigint']>;
  netex_id?: Maybe<Scalars['String']>;
  path_junction_id?: Maybe<Scalars['bigint']>;
  place_ref?: Maybe<Scalars['String']>;
  place_version?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "path_link_end" */
export type StopsDatabasePathLinkEndMutationResponse = {
  __typename?: 'stops_database_path_link_end_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabasePathLinkEnd>;
};

/** on_conflict condition type for table "path_link_end" */
export type StopsDatabasePathLinkEndOnConflict = {
  constraint: StopsDatabasePathLinkEndConstraint;
  update_columns?: Array<StopsDatabasePathLinkEndUpdateColumn>;
  where?: InputMaybe<StopsDatabasePathLinkEndBoolExp>;
};

/** Ordering options when selecting data from "path_link_end". */
export type StopsDatabasePathLinkEndOrderBy = {
  id?: InputMaybe<OrderBy>;
  netex_id?: InputMaybe<OrderBy>;
  path_junction_id?: InputMaybe<OrderBy>;
  place_ref?: InputMaybe<OrderBy>;
  place_version?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: path_link_end */
export type StopsDatabasePathLinkEndPkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "path_link_end" */
export enum StopsDatabasePathLinkEndSelectColumn {
  /** column name */
  Id = 'id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PathJunctionId = 'path_junction_id',
  /** column name */
  PlaceRef = 'place_ref',
  /** column name */
  PlaceVersion = 'place_version',
}

/** input type for updating data in table "path_link_end" */
export type StopsDatabasePathLinkEndSetInput = {
  id?: InputMaybe<Scalars['bigint']>;
  netex_id?: InputMaybe<Scalars['String']>;
  path_junction_id?: InputMaybe<Scalars['bigint']>;
  place_ref?: InputMaybe<Scalars['String']>;
  place_version?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabasePathLinkEndStddevFields = {
  __typename?: 'stops_database_path_link_end_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  path_junction_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabasePathLinkEndStddevPopFields = {
  __typename?: 'stops_database_path_link_end_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  path_junction_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabasePathLinkEndStddevSampFields = {
  __typename?: 'stops_database_path_link_end_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  path_junction_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "path_link_end" */
export type StopsDatabasePathLinkEndStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabasePathLinkEndStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabasePathLinkEndStreamCursorValueInput = {
  id?: InputMaybe<Scalars['bigint']>;
  netex_id?: InputMaybe<Scalars['String']>;
  path_junction_id?: InputMaybe<Scalars['bigint']>;
  place_ref?: InputMaybe<Scalars['String']>;
  place_version?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabasePathLinkEndSumFields = {
  __typename?: 'stops_database_path_link_end_sum_fields';
  id?: Maybe<Scalars['bigint']>;
  path_junction_id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "path_link_end" */
export enum StopsDatabasePathLinkEndUpdateColumn {
  /** column name */
  Id = 'id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PathJunctionId = 'path_junction_id',
  /** column name */
  PlaceRef = 'place_ref',
  /** column name */
  PlaceVersion = 'place_version',
}

export type StopsDatabasePathLinkEndUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabasePathLinkEndIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabasePathLinkEndSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabasePathLinkEndBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabasePathLinkEndVarPopFields = {
  __typename?: 'stops_database_path_link_end_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  path_junction_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabasePathLinkEndVarSampFields = {
  __typename?: 'stops_database_path_link_end_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  path_junction_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabasePathLinkEndVarianceFields = {
  __typename?: 'stops_database_path_link_end_variance_fields';
  id?: Maybe<Scalars['Float']>;
  path_junction_id?: Maybe<Scalars['Float']>;
};

/** input type for incrementing numeric columns in table "path_link" */
export type StopsDatabasePathLinkIncInput = {
  from_id?: InputMaybe<Scalars['bigint']>;
  id?: InputMaybe<Scalars['bigint']>;
  to_id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "path_link" */
export type StopsDatabasePathLinkInsertInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  default_duration?: InputMaybe<Scalars['bytea']>;
  frequent_traveller_duration?: InputMaybe<Scalars['bytea']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  from_id?: InputMaybe<Scalars['bigint']>;
  id?: InputMaybe<Scalars['bigint']>;
  line_string?: InputMaybe<Scalars['geometry']>;
  mobility_restricted_traveller_duration?: InputMaybe<Scalars['bytea']>;
  netex_id?: InputMaybe<Scalars['String']>;
  occasional_traveller_duration?: InputMaybe<Scalars['bytea']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  to_id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "path_link_key_values" */
export type StopsDatabasePathLinkKeyValues = {
  __typename?: 'stops_database_path_link_key_values';
  key_values_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
  path_link_id: Scalars['bigint'];
};

/** aggregated selection of "path_link_key_values" */
export type StopsDatabasePathLinkKeyValuesAggregate = {
  __typename?: 'stops_database_path_link_key_values_aggregate';
  aggregate?: Maybe<StopsDatabasePathLinkKeyValuesAggregateFields>;
  nodes: Array<StopsDatabasePathLinkKeyValues>;
};

/** aggregate fields of "path_link_key_values" */
export type StopsDatabasePathLinkKeyValuesAggregateFields = {
  __typename?: 'stops_database_path_link_key_values_aggregate_fields';
  avg?: Maybe<StopsDatabasePathLinkKeyValuesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabasePathLinkKeyValuesMaxFields>;
  min?: Maybe<StopsDatabasePathLinkKeyValuesMinFields>;
  stddev?: Maybe<StopsDatabasePathLinkKeyValuesStddevFields>;
  stddev_pop?: Maybe<StopsDatabasePathLinkKeyValuesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabasePathLinkKeyValuesStddevSampFields>;
  sum?: Maybe<StopsDatabasePathLinkKeyValuesSumFields>;
  var_pop?: Maybe<StopsDatabasePathLinkKeyValuesVarPopFields>;
  var_samp?: Maybe<StopsDatabasePathLinkKeyValuesVarSampFields>;
  variance?: Maybe<StopsDatabasePathLinkKeyValuesVarianceFields>;
};

/** aggregate fields of "path_link_key_values" */
export type StopsDatabasePathLinkKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabasePathLinkKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabasePathLinkKeyValuesAvgFields = {
  __typename?: 'stops_database_path_link_key_values_avg_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  path_link_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "path_link_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabasePathLinkKeyValuesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabasePathLinkKeyValuesBoolExp>>;
  _not?: InputMaybe<StopsDatabasePathLinkKeyValuesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabasePathLinkKeyValuesBoolExp>>;
  key_values_id?: InputMaybe<BigintComparisonExp>;
  key_values_key?: InputMaybe<StringComparisonExp>;
  path_link_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "path_link_key_values" */
export enum StopsDatabasePathLinkKeyValuesConstraint {
  /** unique or primary key constraint on columns "path_link_id", "key_values_key" */
  PathLinkKeyValuesPkey = 'path_link_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkKn4m9f3l3gdgyg7mdus6qd1r1 = 'uk_kn4m9f3l3gdgyg7mdus6qd1r1',
}

/** input type for incrementing numeric columns in table "path_link_key_values" */
export type StopsDatabasePathLinkKeyValuesIncInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  path_link_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "path_link_key_values" */
export type StopsDatabasePathLinkKeyValuesInsertInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  path_link_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabasePathLinkKeyValuesMaxFields = {
  __typename?: 'stops_database_path_link_key_values_max_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
  path_link_id?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type StopsDatabasePathLinkKeyValuesMinFields = {
  __typename?: 'stops_database_path_link_key_values_min_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
  path_link_id?: Maybe<Scalars['bigint']>;
};

/** response of any mutation on the table "path_link_key_values" */
export type StopsDatabasePathLinkKeyValuesMutationResponse = {
  __typename?: 'stops_database_path_link_key_values_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabasePathLinkKeyValues>;
};

/** on_conflict condition type for table "path_link_key_values" */
export type StopsDatabasePathLinkKeyValuesOnConflict = {
  constraint: StopsDatabasePathLinkKeyValuesConstraint;
  update_columns?: Array<StopsDatabasePathLinkKeyValuesUpdateColumn>;
  where?: InputMaybe<StopsDatabasePathLinkKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "path_link_key_values". */
export type StopsDatabasePathLinkKeyValuesOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  path_link_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: path_link_key_values */
export type StopsDatabasePathLinkKeyValuesPkColumnsInput = {
  key_values_key: Scalars['String'];
  path_link_id: Scalars['bigint'];
};

/** select columns of table "path_link_key_values" */
export enum StopsDatabasePathLinkKeyValuesSelectColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  PathLinkId = 'path_link_id',
}

/** input type for updating data in table "path_link_key_values" */
export type StopsDatabasePathLinkKeyValuesSetInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  path_link_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabasePathLinkKeyValuesStddevFields = {
  __typename?: 'stops_database_path_link_key_values_stddev_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  path_link_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabasePathLinkKeyValuesStddevPopFields = {
  __typename?: 'stops_database_path_link_key_values_stddev_pop_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  path_link_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabasePathLinkKeyValuesStddevSampFields = {
  __typename?: 'stops_database_path_link_key_values_stddev_samp_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  path_link_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "path_link_key_values" */
export type StopsDatabasePathLinkKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabasePathLinkKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabasePathLinkKeyValuesStreamCursorValueInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  path_link_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabasePathLinkKeyValuesSumFields = {
  __typename?: 'stops_database_path_link_key_values_sum_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  path_link_id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "path_link_key_values" */
export enum StopsDatabasePathLinkKeyValuesUpdateColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  PathLinkId = 'path_link_id',
}

export type StopsDatabasePathLinkKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabasePathLinkKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabasePathLinkKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabasePathLinkKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabasePathLinkKeyValuesVarPopFields = {
  __typename?: 'stops_database_path_link_key_values_var_pop_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  path_link_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabasePathLinkKeyValuesVarSampFields = {
  __typename?: 'stops_database_path_link_key_values_var_samp_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  path_link_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabasePathLinkKeyValuesVarianceFields = {
  __typename?: 'stops_database_path_link_key_values_variance_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  path_link_id?: Maybe<Scalars['Float']>;
};

/** aggregate max on columns */
export type StopsDatabasePathLinkMaxFields = {
  __typename?: 'stops_database_path_link_max_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  from_date?: Maybe<Scalars['timestamp']>;
  from_id?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['bigint']>;
  netex_id?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  to_id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabasePathLinkMinFields = {
  __typename?: 'stops_database_path_link_min_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  from_date?: Maybe<Scalars['timestamp']>;
  from_id?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['bigint']>;
  netex_id?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  to_id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "path_link" */
export type StopsDatabasePathLinkMutationResponse = {
  __typename?: 'stops_database_path_link_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabasePathLink>;
};

/** on_conflict condition type for table "path_link" */
export type StopsDatabasePathLinkOnConflict = {
  constraint: StopsDatabasePathLinkConstraint;
  update_columns?: Array<StopsDatabasePathLinkUpdateColumn>;
  where?: InputMaybe<StopsDatabasePathLinkBoolExp>;
};

/** Ordering options when selecting data from "path_link". */
export type StopsDatabasePathLinkOrderBy = {
  changed?: InputMaybe<OrderBy>;
  changed_by?: InputMaybe<OrderBy>;
  created?: InputMaybe<OrderBy>;
  default_duration?: InputMaybe<OrderBy>;
  frequent_traveller_duration?: InputMaybe<OrderBy>;
  from_date?: InputMaybe<OrderBy>;
  from_id?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  line_string?: InputMaybe<OrderBy>;
  mobility_restricted_traveller_duration?: InputMaybe<OrderBy>;
  netex_id?: InputMaybe<OrderBy>;
  occasional_traveller_duration?: InputMaybe<OrderBy>;
  to_date?: InputMaybe<OrderBy>;
  to_id?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
  version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: path_link */
export type StopsDatabasePathLinkPkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "path_link" */
export enum StopsDatabasePathLinkSelectColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DefaultDuration = 'default_duration',
  /** column name */
  FrequentTravellerDuration = 'frequent_traveller_duration',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  FromId = 'from_id',
  /** column name */
  Id = 'id',
  /** column name */
  LineString = 'line_string',
  /** column name */
  MobilityRestrictedTravellerDuration = 'mobility_restricted_traveller_duration',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  OccasionalTravellerDuration = 'occasional_traveller_duration',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  ToId = 'to_id',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

/** input type for updating data in table "path_link" */
export type StopsDatabasePathLinkSetInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  default_duration?: InputMaybe<Scalars['bytea']>;
  frequent_traveller_duration?: InputMaybe<Scalars['bytea']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  from_id?: InputMaybe<Scalars['bigint']>;
  id?: InputMaybe<Scalars['bigint']>;
  line_string?: InputMaybe<Scalars['geometry']>;
  mobility_restricted_traveller_duration?: InputMaybe<Scalars['bytea']>;
  netex_id?: InputMaybe<Scalars['String']>;
  occasional_traveller_duration?: InputMaybe<Scalars['bytea']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  to_id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabasePathLinkStddevFields = {
  __typename?: 'stops_database_path_link_stddev_fields';
  from_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  to_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabasePathLinkStddevPopFields = {
  __typename?: 'stops_database_path_link_stddev_pop_fields';
  from_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  to_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabasePathLinkStddevSampFields = {
  __typename?: 'stops_database_path_link_stddev_samp_fields';
  from_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  to_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "path_link" */
export type StopsDatabasePathLinkStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabasePathLinkStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabasePathLinkStreamCursorValueInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  default_duration?: InputMaybe<Scalars['bytea']>;
  frequent_traveller_duration?: InputMaybe<Scalars['bytea']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  from_id?: InputMaybe<Scalars['bigint']>;
  id?: InputMaybe<Scalars['bigint']>;
  line_string?: InputMaybe<Scalars['geometry']>;
  mobility_restricted_traveller_duration?: InputMaybe<Scalars['bytea']>;
  netex_id?: InputMaybe<Scalars['String']>;
  occasional_traveller_duration?: InputMaybe<Scalars['bytea']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  to_id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabasePathLinkSumFields = {
  __typename?: 'stops_database_path_link_sum_fields';
  from_id?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['bigint']>;
  to_id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['bigint']>;
};

/** update columns of table "path_link" */
export enum StopsDatabasePathLinkUpdateColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DefaultDuration = 'default_duration',
  /** column name */
  FrequentTravellerDuration = 'frequent_traveller_duration',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  FromId = 'from_id',
  /** column name */
  Id = 'id',
  /** column name */
  LineString = 'line_string',
  /** column name */
  MobilityRestrictedTravellerDuration = 'mobility_restricted_traveller_duration',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  OccasionalTravellerDuration = 'occasional_traveller_duration',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  ToId = 'to_id',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

export type StopsDatabasePathLinkUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabasePathLinkIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabasePathLinkSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabasePathLinkBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabasePathLinkVarPopFields = {
  __typename?: 'stops_database_path_link_var_pop_fields';
  from_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  to_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabasePathLinkVarSampFields = {
  __typename?: 'stops_database_path_link_var_samp_fields';
  from_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  to_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabasePathLinkVarianceFields = {
  __typename?: 'stops_database_path_link_variance_fields';
  from_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  to_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "persistable_polygon" */
export type StopsDatabasePersistablePolygon = {
  __typename?: 'stops_database_persistable_polygon';
  id: Scalars['bigint'];
  polygon?: Maybe<Scalars['geometry']>;
};

/** aggregated selection of "persistable_polygon" */
export type StopsDatabasePersistablePolygonAggregate = {
  __typename?: 'stops_database_persistable_polygon_aggregate';
  aggregate?: Maybe<StopsDatabasePersistablePolygonAggregateFields>;
  nodes: Array<StopsDatabasePersistablePolygon>;
};

/** aggregate fields of "persistable_polygon" */
export type StopsDatabasePersistablePolygonAggregateFields = {
  __typename?: 'stops_database_persistable_polygon_aggregate_fields';
  avg?: Maybe<StopsDatabasePersistablePolygonAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabasePersistablePolygonMaxFields>;
  min?: Maybe<StopsDatabasePersistablePolygonMinFields>;
  stddev?: Maybe<StopsDatabasePersistablePolygonStddevFields>;
  stddev_pop?: Maybe<StopsDatabasePersistablePolygonStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabasePersistablePolygonStddevSampFields>;
  sum?: Maybe<StopsDatabasePersistablePolygonSumFields>;
  var_pop?: Maybe<StopsDatabasePersistablePolygonVarPopFields>;
  var_samp?: Maybe<StopsDatabasePersistablePolygonVarSampFields>;
  variance?: Maybe<StopsDatabasePersistablePolygonVarianceFields>;
};

/** aggregate fields of "persistable_polygon" */
export type StopsDatabasePersistablePolygonAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabasePersistablePolygonSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabasePersistablePolygonAvgFields = {
  __typename?: 'stops_database_persistable_polygon_avg_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "persistable_polygon". All fields are combined with a logical 'AND'. */
export type StopsDatabasePersistablePolygonBoolExp = {
  _and?: InputMaybe<Array<StopsDatabasePersistablePolygonBoolExp>>;
  _not?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  _or?: InputMaybe<Array<StopsDatabasePersistablePolygonBoolExp>>;
  id?: InputMaybe<BigintComparisonExp>;
  polygon?: InputMaybe<GeometryComparisonExp>;
};

/** unique or primary key constraints on table "persistable_polygon" */
export enum StopsDatabasePersistablePolygonConstraint {
  /** unique or primary key constraint on columns "id" */
  PersistablePolygonPkey = 'persistable_polygon_pkey',
}

/** input type for incrementing numeric columns in table "persistable_polygon" */
export type StopsDatabasePersistablePolygonIncInput = {
  id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "persistable_polygon" */
export type StopsDatabasePersistablePolygonInsertInput = {
  id?: InputMaybe<Scalars['bigint']>;
  polygon?: InputMaybe<Scalars['geometry']>;
};

/** aggregate max on columns */
export type StopsDatabasePersistablePolygonMaxFields = {
  __typename?: 'stops_database_persistable_polygon_max_fields';
  id?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type StopsDatabasePersistablePolygonMinFields = {
  __typename?: 'stops_database_persistable_polygon_min_fields';
  id?: Maybe<Scalars['bigint']>;
};

/** response of any mutation on the table "persistable_polygon" */
export type StopsDatabasePersistablePolygonMutationResponse = {
  __typename?: 'stops_database_persistable_polygon_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabasePersistablePolygon>;
};

/** input type for inserting object relation for remote table "persistable_polygon" */
export type StopsDatabasePersistablePolygonObjRelInsertInput = {
  data: StopsDatabasePersistablePolygonInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabasePersistablePolygonOnConflict>;
};

/** on_conflict condition type for table "persistable_polygon" */
export type StopsDatabasePersistablePolygonOnConflict = {
  constraint: StopsDatabasePersistablePolygonConstraint;
  update_columns?: Array<StopsDatabasePersistablePolygonUpdateColumn>;
  where?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
};

/** Ordering options when selecting data from "persistable_polygon". */
export type StopsDatabasePersistablePolygonOrderBy = {
  id?: InputMaybe<OrderBy>;
  polygon?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: persistable_polygon */
export type StopsDatabasePersistablePolygonPkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "persistable_polygon" */
export enum StopsDatabasePersistablePolygonSelectColumn {
  /** column name */
  Id = 'id',
  /** column name */
  Polygon = 'polygon',
}

/** input type for updating data in table "persistable_polygon" */
export type StopsDatabasePersistablePolygonSetInput = {
  id?: InputMaybe<Scalars['bigint']>;
  polygon?: InputMaybe<Scalars['geometry']>;
};

/** aggregate stddev on columns */
export type StopsDatabasePersistablePolygonStddevFields = {
  __typename?: 'stops_database_persistable_polygon_stddev_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabasePersistablePolygonStddevPopFields = {
  __typename?: 'stops_database_persistable_polygon_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabasePersistablePolygonStddevSampFields = {
  __typename?: 'stops_database_persistable_polygon_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "persistable_polygon" */
export type StopsDatabasePersistablePolygonStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabasePersistablePolygonStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabasePersistablePolygonStreamCursorValueInput = {
  id?: InputMaybe<Scalars['bigint']>;
  polygon?: InputMaybe<Scalars['geometry']>;
};

/** aggregate sum on columns */
export type StopsDatabasePersistablePolygonSumFields = {
  __typename?: 'stops_database_persistable_polygon_sum_fields';
  id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "persistable_polygon" */
export enum StopsDatabasePersistablePolygonUpdateColumn {
  /** column name */
  Id = 'id',
  /** column name */
  Polygon = 'polygon',
}

export type StopsDatabasePersistablePolygonUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabasePersistablePolygonIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabasePersistablePolygonSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabasePersistablePolygonBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabasePersistablePolygonVarPopFields = {
  __typename?: 'stops_database_persistable_polygon_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabasePersistablePolygonVarSampFields = {
  __typename?: 'stops_database_persistable_polygon_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabasePersistablePolygonVarianceFields = {
  __typename?: 'stops_database_persistable_polygon_variance_fields';
  id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "purpose_of_grouping" */
export type StopsDatabasePurposeOfGrouping = {
  __typename?: 'stops_database_purpose_of_grouping';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id: Scalars['bigint'];
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version: Scalars['bigint'];
  version_comment?: Maybe<Scalars['String']>;
};

/** aggregated selection of "purpose_of_grouping" */
export type StopsDatabasePurposeOfGroupingAggregate = {
  __typename?: 'stops_database_purpose_of_grouping_aggregate';
  aggregate?: Maybe<StopsDatabasePurposeOfGroupingAggregateFields>;
  nodes: Array<StopsDatabasePurposeOfGrouping>;
};

/** aggregate fields of "purpose_of_grouping" */
export type StopsDatabasePurposeOfGroupingAggregateFields = {
  __typename?: 'stops_database_purpose_of_grouping_aggregate_fields';
  avg?: Maybe<StopsDatabasePurposeOfGroupingAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabasePurposeOfGroupingMaxFields>;
  min?: Maybe<StopsDatabasePurposeOfGroupingMinFields>;
  stddev?: Maybe<StopsDatabasePurposeOfGroupingStddevFields>;
  stddev_pop?: Maybe<StopsDatabasePurposeOfGroupingStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabasePurposeOfGroupingStddevSampFields>;
  sum?: Maybe<StopsDatabasePurposeOfGroupingSumFields>;
  var_pop?: Maybe<StopsDatabasePurposeOfGroupingVarPopFields>;
  var_samp?: Maybe<StopsDatabasePurposeOfGroupingVarSampFields>;
  variance?: Maybe<StopsDatabasePurposeOfGroupingVarianceFields>;
};

/** aggregate fields of "purpose_of_grouping" */
export type StopsDatabasePurposeOfGroupingAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabasePurposeOfGroupingSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabasePurposeOfGroupingAvgFields = {
  __typename?: 'stops_database_purpose_of_grouping_avg_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "purpose_of_grouping". All fields are combined with a logical 'AND'. */
export type StopsDatabasePurposeOfGroupingBoolExp = {
  _and?: InputMaybe<Array<StopsDatabasePurposeOfGroupingBoolExp>>;
  _not?: InputMaybe<StopsDatabasePurposeOfGroupingBoolExp>;
  _or?: InputMaybe<Array<StopsDatabasePurposeOfGroupingBoolExp>>;
  changed?: InputMaybe<TimestampComparisonExp>;
  changed_by?: InputMaybe<StringComparisonExp>;
  created?: InputMaybe<TimestampComparisonExp>;
  description_lang?: InputMaybe<StringComparisonExp>;
  description_value?: InputMaybe<StringComparisonExp>;
  from_date?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  name_lang?: InputMaybe<StringComparisonExp>;
  name_value?: InputMaybe<StringComparisonExp>;
  netex_id?: InputMaybe<StringComparisonExp>;
  to_date?: InputMaybe<TimestampComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
  version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "purpose_of_grouping" */
export enum StopsDatabasePurposeOfGroupingConstraint {
  /** unique or primary key constraint on columns "name_value" */
  PurposeOfGroupingNameValueConstraint = 'purpose_of_grouping_name_value_constraint',
  /** unique or primary key constraint on columns "netex_id" */
  PurposeOfGroupingNetexIdVersionConstraint = 'purpose_of_grouping_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  PurposeOfGroupingPkey = 'purpose_of_grouping_pkey',
}

/** input type for incrementing numeric columns in table "purpose_of_grouping" */
export type StopsDatabasePurposeOfGroupingIncInput = {
  id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "purpose_of_grouping" */
export type StopsDatabasePurposeOfGroupingInsertInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "purpose_of_grouping_key_values" */
export type StopsDatabasePurposeOfGroupingKeyValues = {
  __typename?: 'stops_database_purpose_of_grouping_key_values';
  key_values_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
  purpose_of_grouping_id: Scalars['bigint'];
};

/** aggregated selection of "purpose_of_grouping_key_values" */
export type StopsDatabasePurposeOfGroupingKeyValuesAggregate = {
  __typename?: 'stops_database_purpose_of_grouping_key_values_aggregate';
  aggregate?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesAggregateFields>;
  nodes: Array<StopsDatabasePurposeOfGroupingKeyValues>;
};

/** aggregate fields of "purpose_of_grouping_key_values" */
export type StopsDatabasePurposeOfGroupingKeyValuesAggregateFields = {
  __typename?: 'stops_database_purpose_of_grouping_key_values_aggregate_fields';
  avg?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesMaxFields>;
  min?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesMinFields>;
  stddev?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesStddevFields>;
  stddev_pop?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesStddevSampFields>;
  sum?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesSumFields>;
  var_pop?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesVarPopFields>;
  var_samp?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesVarSampFields>;
  variance?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesVarianceFields>;
};

/** aggregate fields of "purpose_of_grouping_key_values" */
export type StopsDatabasePurposeOfGroupingKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<
    Array<StopsDatabasePurposeOfGroupingKeyValuesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabasePurposeOfGroupingKeyValuesAvgFields = {
  __typename?: 'stops_database_purpose_of_grouping_key_values_avg_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  purpose_of_grouping_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "purpose_of_grouping_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabasePurposeOfGroupingKeyValuesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabasePurposeOfGroupingKeyValuesBoolExp>>;
  _not?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabasePurposeOfGroupingKeyValuesBoolExp>>;
  key_values_id?: InputMaybe<BigintComparisonExp>;
  key_values_key?: InputMaybe<StringComparisonExp>;
  purpose_of_grouping_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "purpose_of_grouping_key_values" */
export enum StopsDatabasePurposeOfGroupingKeyValuesConstraint {
  /** unique or primary key constraint on columns "purpose_of_grouping_id", "key_values_key" */
  PurposeOfGroupingKeyValuesPkey = 'purpose_of_grouping_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  PurposeOfGroupingKeyValuesUniqueKey = 'purpose_of_grouping_key_values_unique_key',
}

/** input type for incrementing numeric columns in table "purpose_of_grouping_key_values" */
export type StopsDatabasePurposeOfGroupingKeyValuesIncInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  purpose_of_grouping_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "purpose_of_grouping_key_values" */
export type StopsDatabasePurposeOfGroupingKeyValuesInsertInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  purpose_of_grouping_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabasePurposeOfGroupingKeyValuesMaxFields = {
  __typename?: 'stops_database_purpose_of_grouping_key_values_max_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
  purpose_of_grouping_id?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type StopsDatabasePurposeOfGroupingKeyValuesMinFields = {
  __typename?: 'stops_database_purpose_of_grouping_key_values_min_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
  purpose_of_grouping_id?: Maybe<Scalars['bigint']>;
};

/** response of any mutation on the table "purpose_of_grouping_key_values" */
export type StopsDatabasePurposeOfGroupingKeyValuesMutationResponse = {
  __typename?: 'stops_database_purpose_of_grouping_key_values_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabasePurposeOfGroupingKeyValues>;
};

/** on_conflict condition type for table "purpose_of_grouping_key_values" */
export type StopsDatabasePurposeOfGroupingKeyValuesOnConflict = {
  constraint: StopsDatabasePurposeOfGroupingKeyValuesConstraint;
  update_columns?: Array<StopsDatabasePurposeOfGroupingKeyValuesUpdateColumn>;
  where?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "purpose_of_grouping_key_values". */
export type StopsDatabasePurposeOfGroupingKeyValuesOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  purpose_of_grouping_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: purpose_of_grouping_key_values */
export type StopsDatabasePurposeOfGroupingKeyValuesPkColumnsInput = {
  key_values_key: Scalars['String'];
  purpose_of_grouping_id: Scalars['bigint'];
};

/** select columns of table "purpose_of_grouping_key_values" */
export enum StopsDatabasePurposeOfGroupingKeyValuesSelectColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  PurposeOfGroupingId = 'purpose_of_grouping_id',
}

/** input type for updating data in table "purpose_of_grouping_key_values" */
export type StopsDatabasePurposeOfGroupingKeyValuesSetInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  purpose_of_grouping_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabasePurposeOfGroupingKeyValuesStddevFields = {
  __typename?: 'stops_database_purpose_of_grouping_key_values_stddev_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  purpose_of_grouping_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabasePurposeOfGroupingKeyValuesStddevPopFields = {
  __typename?: 'stops_database_purpose_of_grouping_key_values_stddev_pop_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  purpose_of_grouping_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabasePurposeOfGroupingKeyValuesStddevSampFields = {
  __typename?: 'stops_database_purpose_of_grouping_key_values_stddev_samp_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  purpose_of_grouping_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "purpose_of_grouping_key_values" */
export type StopsDatabasePurposeOfGroupingKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabasePurposeOfGroupingKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabasePurposeOfGroupingKeyValuesStreamCursorValueInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  purpose_of_grouping_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabasePurposeOfGroupingKeyValuesSumFields = {
  __typename?: 'stops_database_purpose_of_grouping_key_values_sum_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  purpose_of_grouping_id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "purpose_of_grouping_key_values" */
export enum StopsDatabasePurposeOfGroupingKeyValuesUpdateColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  PurposeOfGroupingId = 'purpose_of_grouping_id',
}

export type StopsDatabasePurposeOfGroupingKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabasePurposeOfGroupingKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabasePurposeOfGroupingKeyValuesVarPopFields = {
  __typename?: 'stops_database_purpose_of_grouping_key_values_var_pop_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  purpose_of_grouping_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabasePurposeOfGroupingKeyValuesVarSampFields = {
  __typename?: 'stops_database_purpose_of_grouping_key_values_var_samp_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  purpose_of_grouping_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabasePurposeOfGroupingKeyValuesVarianceFields = {
  __typename?: 'stops_database_purpose_of_grouping_key_values_variance_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  purpose_of_grouping_id?: Maybe<Scalars['Float']>;
};

/** aggregate max on columns */
export type StopsDatabasePurposeOfGroupingMaxFields = {
  __typename?: 'stops_database_purpose_of_grouping_max_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabasePurposeOfGroupingMinFields = {
  __typename?: 'stops_database_purpose_of_grouping_min_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "purpose_of_grouping" */
export type StopsDatabasePurposeOfGroupingMutationResponse = {
  __typename?: 'stops_database_purpose_of_grouping_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabasePurposeOfGrouping>;
};

/** on_conflict condition type for table "purpose_of_grouping" */
export type StopsDatabasePurposeOfGroupingOnConflict = {
  constraint: StopsDatabasePurposeOfGroupingConstraint;
  update_columns?: Array<StopsDatabasePurposeOfGroupingUpdateColumn>;
  where?: InputMaybe<StopsDatabasePurposeOfGroupingBoolExp>;
};

/** Ordering options when selecting data from "purpose_of_grouping". */
export type StopsDatabasePurposeOfGroupingOrderBy = {
  changed?: InputMaybe<OrderBy>;
  changed_by?: InputMaybe<OrderBy>;
  created?: InputMaybe<OrderBy>;
  description_lang?: InputMaybe<OrderBy>;
  description_value?: InputMaybe<OrderBy>;
  from_date?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name_lang?: InputMaybe<OrderBy>;
  name_value?: InputMaybe<OrderBy>;
  netex_id?: InputMaybe<OrderBy>;
  to_date?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
  version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: purpose_of_grouping */
export type StopsDatabasePurposeOfGroupingPkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "purpose_of_grouping" */
export enum StopsDatabasePurposeOfGroupingSelectColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

/** input type for updating data in table "purpose_of_grouping" */
export type StopsDatabasePurposeOfGroupingSetInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabasePurposeOfGroupingStddevFields = {
  __typename?: 'stops_database_purpose_of_grouping_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabasePurposeOfGroupingStddevPopFields = {
  __typename?: 'stops_database_purpose_of_grouping_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabasePurposeOfGroupingStddevSampFields = {
  __typename?: 'stops_database_purpose_of_grouping_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "purpose_of_grouping" */
export type StopsDatabasePurposeOfGroupingStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabasePurposeOfGroupingStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabasePurposeOfGroupingStreamCursorValueInput = {
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabasePurposeOfGroupingSumFields = {
  __typename?: 'stops_database_purpose_of_grouping_sum_fields';
  id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['bigint']>;
};

/** update columns of table "purpose_of_grouping" */
export enum StopsDatabasePurposeOfGroupingUpdateColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

export type StopsDatabasePurposeOfGroupingUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabasePurposeOfGroupingIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabasePurposeOfGroupingSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabasePurposeOfGroupingBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabasePurposeOfGroupingVarPopFields = {
  __typename?: 'stops_database_purpose_of_grouping_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabasePurposeOfGroupingVarSampFields = {
  __typename?: 'stops_database_purpose_of_grouping_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabasePurposeOfGroupingVarianceFields = {
  __typename?: 'stops_database_purpose_of_grouping_variance_fields';
  id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "quay" */
export type StopsDatabaseQuay = {
  __typename?: 'stops_database_quay';
  /** An object relationship */
  accessibility_assessment?: Maybe<StopsDatabaseAccessibilityAssessment>;
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  all_areas_wheelchair_accessible?: Maybe<Scalars['Boolean']>;
  centroid?: Maybe<Scalars['geometry']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  compass_bearing?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Int']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id: Scalars['bigint'];
  /** An object relationship */
  installed_equipment_version_structure?: Maybe<StopsDatabaseInstalledEquipmentVersionStructure>;
  label_lang?: Maybe<Scalars['String']>;
  label_value?: Maybe<Scalars['String']>;
  level_ref?: Maybe<Scalars['String']>;
  level_ref_version?: Maybe<Scalars['String']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  /** An object relationship */
  persistable_polygon?: Maybe<StopsDatabasePersistablePolygon>;
  place_equipments_id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  public_code?: Maybe<Scalars['String']>;
  /** An array relationship */
  quay_alternative_names: Array<StopsDatabaseQuayAlternativeNames>;
  /** An aggregate relationship */
  quay_alternative_names_aggregate: StopsDatabaseQuayAlternativeNamesAggregate;
  /** An array relationship */
  quay_boarding_positions: Array<StopsDatabaseQuayBoardingPositions>;
  /** An aggregate relationship */
  quay_boarding_positions_aggregate: StopsDatabaseQuayBoardingPositionsAggregate;
  /** An array relationship */
  quay_equipment_places: Array<StopsDatabaseQuayEquipmentPlaces>;
  /** An aggregate relationship */
  quay_equipment_places_aggregate: StopsDatabaseQuayEquipmentPlacesAggregate;
  /** An array relationship */
  quay_key_values: Array<StopsDatabaseQuayKeyValues>;
  /** An aggregate relationship */
  quay_key_values_aggregate: StopsDatabaseQuayKeyValuesAggregate;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  site_ref?: Maybe<Scalars['String']>;
  site_ref_version?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version: Scalars['bigint'];
  version_comment?: Maybe<Scalars['String']>;
};

/** columns and relationships of "quay" */
export type StopsDatabaseQuayQuayAlternativeNamesArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseQuayAlternativeNamesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseQuayAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayAlternativeNamesBoolExp>;
};

/** columns and relationships of "quay" */
export type StopsDatabaseQuayQuayAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseQuayAlternativeNamesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseQuayAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayAlternativeNamesBoolExp>;
};

/** columns and relationships of "quay" */
export type StopsDatabaseQuayQuayBoardingPositionsArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseQuayBoardingPositionsSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseQuayBoardingPositionsOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayBoardingPositionsBoolExp>;
};

/** columns and relationships of "quay" */
export type StopsDatabaseQuayQuayBoardingPositionsAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseQuayBoardingPositionsSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseQuayBoardingPositionsOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayBoardingPositionsBoolExp>;
};

/** columns and relationships of "quay" */
export type StopsDatabaseQuayQuayEquipmentPlacesArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseQuayEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseQuayEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayEquipmentPlacesBoolExp>;
};

/** columns and relationships of "quay" */
export type StopsDatabaseQuayQuayEquipmentPlacesAggregateArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseQuayEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseQuayEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayEquipmentPlacesBoolExp>;
};

/** columns and relationships of "quay" */
export type StopsDatabaseQuayQuayKeyValuesArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseQuayKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseQuayKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayKeyValuesBoolExp>;
};

/** columns and relationships of "quay" */
export type StopsDatabaseQuayQuayKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseQuayKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseQuayKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayKeyValuesBoolExp>;
};

/** aggregated selection of "quay" */
export type StopsDatabaseQuayAggregate = {
  __typename?: 'stops_database_quay_aggregate';
  aggregate?: Maybe<StopsDatabaseQuayAggregateFields>;
  nodes: Array<StopsDatabaseQuay>;
};

/** aggregate fields of "quay" */
export type StopsDatabaseQuayAggregateFields = {
  __typename?: 'stops_database_quay_aggregate_fields';
  avg?: Maybe<StopsDatabaseQuayAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseQuayMaxFields>;
  min?: Maybe<StopsDatabaseQuayMinFields>;
  stddev?: Maybe<StopsDatabaseQuayStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseQuayStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseQuayStddevSampFields>;
  sum?: Maybe<StopsDatabaseQuaySumFields>;
  var_pop?: Maybe<StopsDatabaseQuayVarPopFields>;
  var_samp?: Maybe<StopsDatabaseQuayVarSampFields>;
  variance?: Maybe<StopsDatabaseQuayVarianceFields>;
};

/** aggregate fields of "quay" */
export type StopsDatabaseQuayAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseQuaySelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** columns and relationships of "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNames = {
  __typename?: 'stops_database_quay_alternative_names';
  /** An object relationship */
  alternative_name: StopsDatabaseAlternativeName;
  alternative_names_id: Scalars['bigint'];
  quay_id: Scalars['bigint'];
};

/** aggregated selection of "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesAggregate = {
  __typename?: 'stops_database_quay_alternative_names_aggregate';
  aggregate?: Maybe<StopsDatabaseQuayAlternativeNamesAggregateFields>;
  nodes: Array<StopsDatabaseQuayAlternativeNames>;
};

/** aggregate fields of "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesAggregateFields = {
  __typename?: 'stops_database_quay_alternative_names_aggregate_fields';
  avg?: Maybe<StopsDatabaseQuayAlternativeNamesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseQuayAlternativeNamesMaxFields>;
  min?: Maybe<StopsDatabaseQuayAlternativeNamesMinFields>;
  stddev?: Maybe<StopsDatabaseQuayAlternativeNamesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseQuayAlternativeNamesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseQuayAlternativeNamesStddevSampFields>;
  sum?: Maybe<StopsDatabaseQuayAlternativeNamesSumFields>;
  var_pop?: Maybe<StopsDatabaseQuayAlternativeNamesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseQuayAlternativeNamesVarSampFields>;
  variance?: Maybe<StopsDatabaseQuayAlternativeNamesVarianceFields>;
};

/** aggregate fields of "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseQuayAlternativeNamesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseQuayAlternativeNamesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseQuayAlternativeNamesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseQuayAlternativeNamesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseQuayAlternativeNamesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseQuayAlternativeNamesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseQuayAlternativeNamesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseQuayAlternativeNamesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseQuayAlternativeNamesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseQuayAlternativeNamesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseQuayAlternativeNamesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesArrRelInsertInput = {
  data: Array<StopsDatabaseQuayAlternativeNamesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseQuayAlternativeNamesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseQuayAlternativeNamesAvgFields = {
  __typename?: 'stops_database_quay_alternative_names_avg_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesAvgOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "quay_alternative_names". All fields are combined with a logical 'AND'. */
export type StopsDatabaseQuayAlternativeNamesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseQuayAlternativeNamesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseQuayAlternativeNamesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseQuayAlternativeNamesBoolExp>>;
  alternative_name?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
  alternative_names_id?: InputMaybe<BigintComparisonExp>;
  quay_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "quay_alternative_names" */
export enum StopsDatabaseQuayAlternativeNamesConstraint {
  /** unique or primary key constraint on columns "alternative_names_id" */
  Uk_6h2bs7xhqq2ca64hjpp8can1w = 'uk_6h2bs7xhqq2ca64hjpp8can1w',
}

/** input type for incrementing numeric columns in table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesIncInput = {
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
  quay_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesInsertInput = {
  alternative_name?: InputMaybe<StopsDatabaseAlternativeNameObjRelInsertInput>;
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
  quay_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseQuayAlternativeNamesMaxFields = {
  __typename?: 'stops_database_quay_alternative_names_max_fields';
  alternative_names_id?: Maybe<Scalars['bigint']>;
  quay_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesMaxOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseQuayAlternativeNamesMinFields = {
  __typename?: 'stops_database_quay_alternative_names_min_fields';
  alternative_names_id?: Maybe<Scalars['bigint']>;
  quay_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesMinOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesMutationResponse = {
  __typename?: 'stops_database_quay_alternative_names_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseQuayAlternativeNames>;
};

/** on_conflict condition type for table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesOnConflict = {
  constraint: StopsDatabaseQuayAlternativeNamesConstraint;
  update_columns?: Array<StopsDatabaseQuayAlternativeNamesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseQuayAlternativeNamesBoolExp>;
};

/** Ordering options when selecting data from "quay_alternative_names". */
export type StopsDatabaseQuayAlternativeNamesOrderBy = {
  alternative_name?: InputMaybe<StopsDatabaseAlternativeNameOrderBy>;
  alternative_names_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** select columns of table "quay_alternative_names" */
export enum StopsDatabaseQuayAlternativeNamesSelectColumn {
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
  /** column name */
  QuayId = 'quay_id',
}

/** input type for updating data in table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesSetInput = {
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
  quay_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseQuayAlternativeNamesStddevFields = {
  __typename?: 'stops_database_quay_alternative_names_stddev_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesStddevOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseQuayAlternativeNamesStddevPopFields = {
  __typename?: 'stops_database_quay_alternative_names_stddev_pop_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesStddevPopOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseQuayAlternativeNamesStddevSampFields = {
  __typename?: 'stops_database_quay_alternative_names_stddev_samp_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesStddevSampOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseQuayAlternativeNamesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseQuayAlternativeNamesStreamCursorValueInput = {
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
  quay_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseQuayAlternativeNamesSumFields = {
  __typename?: 'stops_database_quay_alternative_names_sum_fields';
  alternative_names_id?: Maybe<Scalars['bigint']>;
  quay_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesSumOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** update columns of table "quay_alternative_names" */
export enum StopsDatabaseQuayAlternativeNamesUpdateColumn {
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
  /** column name */
  QuayId = 'quay_id',
}

export type StopsDatabaseQuayAlternativeNamesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseQuayAlternativeNamesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseQuayAlternativeNamesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseQuayAlternativeNamesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseQuayAlternativeNamesVarPopFields = {
  __typename?: 'stops_database_quay_alternative_names_var_pop_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesVarPopOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseQuayAlternativeNamesVarSampFields = {
  __typename?: 'stops_database_quay_alternative_names_var_samp_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesVarSampOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseQuayAlternativeNamesVarianceFields = {
  __typename?: 'stops_database_quay_alternative_names_variance_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesVarianceOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** aggregate avg on columns */
export type StopsDatabaseQuayAvgFields = {
  __typename?: 'stops_database_quay_avg_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  compass_bearing?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositions = {
  __typename?: 'stops_database_quay_boarding_positions';
  /** An object relationship */
  boarding_position: StopsDatabaseBoardingPosition;
  boarding_positions_id: Scalars['bigint'];
  quay_id: Scalars['bigint'];
};

/** aggregated selection of "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsAggregate = {
  __typename?: 'stops_database_quay_boarding_positions_aggregate';
  aggregate?: Maybe<StopsDatabaseQuayBoardingPositionsAggregateFields>;
  nodes: Array<StopsDatabaseQuayBoardingPositions>;
};

/** aggregate fields of "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsAggregateFields = {
  __typename?: 'stops_database_quay_boarding_positions_aggregate_fields';
  avg?: Maybe<StopsDatabaseQuayBoardingPositionsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseQuayBoardingPositionsMaxFields>;
  min?: Maybe<StopsDatabaseQuayBoardingPositionsMinFields>;
  stddev?: Maybe<StopsDatabaseQuayBoardingPositionsStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseQuayBoardingPositionsStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseQuayBoardingPositionsStddevSampFields>;
  sum?: Maybe<StopsDatabaseQuayBoardingPositionsSumFields>;
  var_pop?: Maybe<StopsDatabaseQuayBoardingPositionsVarPopFields>;
  var_samp?: Maybe<StopsDatabaseQuayBoardingPositionsVarSampFields>;
  variance?: Maybe<StopsDatabaseQuayBoardingPositionsVarianceFields>;
};

/** aggregate fields of "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseQuayBoardingPositionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseQuayBoardingPositionsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseQuayBoardingPositionsMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseQuayBoardingPositionsMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseQuayBoardingPositionsStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseQuayBoardingPositionsStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseQuayBoardingPositionsStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseQuayBoardingPositionsSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseQuayBoardingPositionsVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseQuayBoardingPositionsVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseQuayBoardingPositionsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsArrRelInsertInput = {
  data: Array<StopsDatabaseQuayBoardingPositionsInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseQuayBoardingPositionsOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseQuayBoardingPositionsAvgFields = {
  __typename?: 'stops_database_quay_boarding_positions_avg_fields';
  boarding_positions_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsAvgOrderBy = {
  boarding_positions_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "quay_boarding_positions". All fields are combined with a logical 'AND'. */
export type StopsDatabaseQuayBoardingPositionsBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseQuayBoardingPositionsBoolExp>>;
  _not?: InputMaybe<StopsDatabaseQuayBoardingPositionsBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseQuayBoardingPositionsBoolExp>>;
  boarding_position?: InputMaybe<StopsDatabaseBoardingPositionBoolExp>;
  boarding_positions_id?: InputMaybe<BigintComparisonExp>;
  quay_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "quay_boarding_positions" */
export enum StopsDatabaseQuayBoardingPositionsConstraint {
  /** unique or primary key constraint on columns "boarding_positions_id" */
  UkLx6ql0b834b5l0agvouh1w860 = 'uk_lx6ql0b834b5l0agvouh1w860',
}

/** input type for incrementing numeric columns in table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsIncInput = {
  boarding_positions_id?: InputMaybe<Scalars['bigint']>;
  quay_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsInsertInput = {
  boarding_position?: InputMaybe<StopsDatabaseBoardingPositionObjRelInsertInput>;
  boarding_positions_id?: InputMaybe<Scalars['bigint']>;
  quay_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseQuayBoardingPositionsMaxFields = {
  __typename?: 'stops_database_quay_boarding_positions_max_fields';
  boarding_positions_id?: Maybe<Scalars['bigint']>;
  quay_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsMaxOrderBy = {
  boarding_positions_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseQuayBoardingPositionsMinFields = {
  __typename?: 'stops_database_quay_boarding_positions_min_fields';
  boarding_positions_id?: Maybe<Scalars['bigint']>;
  quay_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsMinOrderBy = {
  boarding_positions_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsMutationResponse = {
  __typename?: 'stops_database_quay_boarding_positions_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseQuayBoardingPositions>;
};

/** on_conflict condition type for table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsOnConflict = {
  constraint: StopsDatabaseQuayBoardingPositionsConstraint;
  update_columns?: Array<StopsDatabaseQuayBoardingPositionsUpdateColumn>;
  where?: InputMaybe<StopsDatabaseQuayBoardingPositionsBoolExp>;
};

/** Ordering options when selecting data from "quay_boarding_positions". */
export type StopsDatabaseQuayBoardingPositionsOrderBy = {
  boarding_position?: InputMaybe<StopsDatabaseBoardingPositionOrderBy>;
  boarding_positions_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** select columns of table "quay_boarding_positions" */
export enum StopsDatabaseQuayBoardingPositionsSelectColumn {
  /** column name */
  BoardingPositionsId = 'boarding_positions_id',
  /** column name */
  QuayId = 'quay_id',
}

/** input type for updating data in table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsSetInput = {
  boarding_positions_id?: InputMaybe<Scalars['bigint']>;
  quay_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseQuayBoardingPositionsStddevFields = {
  __typename?: 'stops_database_quay_boarding_positions_stddev_fields';
  boarding_positions_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsStddevOrderBy = {
  boarding_positions_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseQuayBoardingPositionsStddevPopFields = {
  __typename?: 'stops_database_quay_boarding_positions_stddev_pop_fields';
  boarding_positions_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsStddevPopOrderBy = {
  boarding_positions_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseQuayBoardingPositionsStddevSampFields = {
  __typename?: 'stops_database_quay_boarding_positions_stddev_samp_fields';
  boarding_positions_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsStddevSampOrderBy = {
  boarding_positions_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseQuayBoardingPositionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseQuayBoardingPositionsStreamCursorValueInput = {
  boarding_positions_id?: InputMaybe<Scalars['bigint']>;
  quay_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseQuayBoardingPositionsSumFields = {
  __typename?: 'stops_database_quay_boarding_positions_sum_fields';
  boarding_positions_id?: Maybe<Scalars['bigint']>;
  quay_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsSumOrderBy = {
  boarding_positions_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** update columns of table "quay_boarding_positions" */
export enum StopsDatabaseQuayBoardingPositionsUpdateColumn {
  /** column name */
  BoardingPositionsId = 'boarding_positions_id',
  /** column name */
  QuayId = 'quay_id',
}

export type StopsDatabaseQuayBoardingPositionsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseQuayBoardingPositionsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseQuayBoardingPositionsSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseQuayBoardingPositionsBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseQuayBoardingPositionsVarPopFields = {
  __typename?: 'stops_database_quay_boarding_positions_var_pop_fields';
  boarding_positions_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsVarPopOrderBy = {
  boarding_positions_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseQuayBoardingPositionsVarSampFields = {
  __typename?: 'stops_database_quay_boarding_positions_var_samp_fields';
  boarding_positions_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsVarSampOrderBy = {
  boarding_positions_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseQuayBoardingPositionsVarianceFields = {
  __typename?: 'stops_database_quay_boarding_positions_variance_fields';
  boarding_positions_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsVarianceOrderBy = {
  boarding_positions_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "quay". All fields are combined with a logical 'AND'. */
export type StopsDatabaseQuayBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseQuayBoolExp>>;
  _not?: InputMaybe<StopsDatabaseQuayBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseQuayBoolExp>>;
  accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentBoolExp>;
  accessibility_assessment_id?: InputMaybe<BigintComparisonExp>;
  all_areas_wheelchair_accessible?: InputMaybe<BooleanComparisonExp>;
  centroid?: InputMaybe<GeometryComparisonExp>;
  changed?: InputMaybe<TimestampComparisonExp>;
  changed_by?: InputMaybe<StringComparisonExp>;
  compass_bearing?: InputMaybe<FloatComparisonExp>;
  covered?: InputMaybe<IntComparisonExp>;
  created?: InputMaybe<TimestampComparisonExp>;
  description_lang?: InputMaybe<StringComparisonExp>;
  description_value?: InputMaybe<StringComparisonExp>;
  from_date?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
  label_lang?: InputMaybe<StringComparisonExp>;
  label_value?: InputMaybe<StringComparisonExp>;
  level_ref?: InputMaybe<StringComparisonExp>;
  level_ref_version?: InputMaybe<StringComparisonExp>;
  name_lang?: InputMaybe<StringComparisonExp>;
  name_value?: InputMaybe<StringComparisonExp>;
  netex_id?: InputMaybe<StringComparisonExp>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  place_equipments_id?: InputMaybe<BigintComparisonExp>;
  polygon_id?: InputMaybe<BigintComparisonExp>;
  private_code_type?: InputMaybe<StringComparisonExp>;
  private_code_value?: InputMaybe<StringComparisonExp>;
  public_code?: InputMaybe<StringComparisonExp>;
  quay_alternative_names?: InputMaybe<StopsDatabaseQuayAlternativeNamesBoolExp>;
  quay_alternative_names_aggregate?: InputMaybe<QuayAlternativeNamesAggregateBoolExp>;
  quay_boarding_positions?: InputMaybe<StopsDatabaseQuayBoardingPositionsBoolExp>;
  quay_boarding_positions_aggregate?: InputMaybe<QuayBoardingPositionsAggregateBoolExp>;
  quay_equipment_places?: InputMaybe<StopsDatabaseQuayEquipmentPlacesBoolExp>;
  quay_equipment_places_aggregate?: InputMaybe<QuayEquipmentPlacesAggregateBoolExp>;
  quay_key_values?: InputMaybe<StopsDatabaseQuayKeyValuesBoolExp>;
  quay_key_values_aggregate?: InputMaybe<QuayKeyValuesAggregateBoolExp>;
  short_name_lang?: InputMaybe<StringComparisonExp>;
  short_name_value?: InputMaybe<StringComparisonExp>;
  site_ref?: InputMaybe<StringComparisonExp>;
  site_ref_version?: InputMaybe<StringComparisonExp>;
  to_date?: InputMaybe<TimestampComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
  version_comment?: InputMaybe<StringComparisonExp>;
};

/** columns and relationships of "quay_check_constraints" */
export type StopsDatabaseQuayCheckConstraints = {
  __typename?: 'stops_database_quay_check_constraints';
  check_constraints_id: Scalars['bigint'];
  quay_id: Scalars['bigint'];
};

/** aggregated selection of "quay_check_constraints" */
export type StopsDatabaseQuayCheckConstraintsAggregate = {
  __typename?: 'stops_database_quay_check_constraints_aggregate';
  aggregate?: Maybe<StopsDatabaseQuayCheckConstraintsAggregateFields>;
  nodes: Array<StopsDatabaseQuayCheckConstraints>;
};

/** aggregate fields of "quay_check_constraints" */
export type StopsDatabaseQuayCheckConstraintsAggregateFields = {
  __typename?: 'stops_database_quay_check_constraints_aggregate_fields';
  avg?: Maybe<StopsDatabaseQuayCheckConstraintsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseQuayCheckConstraintsMaxFields>;
  min?: Maybe<StopsDatabaseQuayCheckConstraintsMinFields>;
  stddev?: Maybe<StopsDatabaseQuayCheckConstraintsStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseQuayCheckConstraintsStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseQuayCheckConstraintsStddevSampFields>;
  sum?: Maybe<StopsDatabaseQuayCheckConstraintsSumFields>;
  var_pop?: Maybe<StopsDatabaseQuayCheckConstraintsVarPopFields>;
  var_samp?: Maybe<StopsDatabaseQuayCheckConstraintsVarSampFields>;
  variance?: Maybe<StopsDatabaseQuayCheckConstraintsVarianceFields>;
};

/** aggregate fields of "quay_check_constraints" */
export type StopsDatabaseQuayCheckConstraintsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseQuayCheckConstraintsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseQuayCheckConstraintsAvgFields = {
  __typename?: 'stops_database_quay_check_constraints_avg_fields';
  check_constraints_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "quay_check_constraints". All fields are combined with a logical 'AND'. */
export type StopsDatabaseQuayCheckConstraintsBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseQuayCheckConstraintsBoolExp>>;
  _not?: InputMaybe<StopsDatabaseQuayCheckConstraintsBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseQuayCheckConstraintsBoolExp>>;
  check_constraints_id?: InputMaybe<BigintComparisonExp>;
  quay_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "quay_check_constraints" */
export enum StopsDatabaseQuayCheckConstraintsConstraint {
  /** unique or primary key constraint on columns "check_constraints_id" */
  Uk_1tirlnmtpwtd5i69kn8hy05v6 = 'uk_1tirlnmtpwtd5i69kn8hy05v6',
}

/** input type for incrementing numeric columns in table "quay_check_constraints" */
export type StopsDatabaseQuayCheckConstraintsIncInput = {
  check_constraints_id?: InputMaybe<Scalars['bigint']>;
  quay_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "quay_check_constraints" */
export type StopsDatabaseQuayCheckConstraintsInsertInput = {
  check_constraints_id?: InputMaybe<Scalars['bigint']>;
  quay_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseQuayCheckConstraintsMaxFields = {
  __typename?: 'stops_database_quay_check_constraints_max_fields';
  check_constraints_id?: Maybe<Scalars['bigint']>;
  quay_id?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type StopsDatabaseQuayCheckConstraintsMinFields = {
  __typename?: 'stops_database_quay_check_constraints_min_fields';
  check_constraints_id?: Maybe<Scalars['bigint']>;
  quay_id?: Maybe<Scalars['bigint']>;
};

/** response of any mutation on the table "quay_check_constraints" */
export type StopsDatabaseQuayCheckConstraintsMutationResponse = {
  __typename?: 'stops_database_quay_check_constraints_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseQuayCheckConstraints>;
};

/** on_conflict condition type for table "quay_check_constraints" */
export type StopsDatabaseQuayCheckConstraintsOnConflict = {
  constraint: StopsDatabaseQuayCheckConstraintsConstraint;
  update_columns?: Array<StopsDatabaseQuayCheckConstraintsUpdateColumn>;
  where?: InputMaybe<StopsDatabaseQuayCheckConstraintsBoolExp>;
};

/** Ordering options when selecting data from "quay_check_constraints". */
export type StopsDatabaseQuayCheckConstraintsOrderBy = {
  check_constraints_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** select columns of table "quay_check_constraints" */
export enum StopsDatabaseQuayCheckConstraintsSelectColumn {
  /** column name */
  CheckConstraintsId = 'check_constraints_id',
  /** column name */
  QuayId = 'quay_id',
}

/** input type for updating data in table "quay_check_constraints" */
export type StopsDatabaseQuayCheckConstraintsSetInput = {
  check_constraints_id?: InputMaybe<Scalars['bigint']>;
  quay_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseQuayCheckConstraintsStddevFields = {
  __typename?: 'stops_database_quay_check_constraints_stddev_fields';
  check_constraints_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseQuayCheckConstraintsStddevPopFields = {
  __typename?: 'stops_database_quay_check_constraints_stddev_pop_fields';
  check_constraints_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseQuayCheckConstraintsStddevSampFields = {
  __typename?: 'stops_database_quay_check_constraints_stddev_samp_fields';
  check_constraints_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "quay_check_constraints" */
export type StopsDatabaseQuayCheckConstraintsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseQuayCheckConstraintsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseQuayCheckConstraintsStreamCursorValueInput = {
  check_constraints_id?: InputMaybe<Scalars['bigint']>;
  quay_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseQuayCheckConstraintsSumFields = {
  __typename?: 'stops_database_quay_check_constraints_sum_fields';
  check_constraints_id?: Maybe<Scalars['bigint']>;
  quay_id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "quay_check_constraints" */
export enum StopsDatabaseQuayCheckConstraintsUpdateColumn {
  /** column name */
  CheckConstraintsId = 'check_constraints_id',
  /** column name */
  QuayId = 'quay_id',
}

export type StopsDatabaseQuayCheckConstraintsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseQuayCheckConstraintsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseQuayCheckConstraintsSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseQuayCheckConstraintsBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseQuayCheckConstraintsVarPopFields = {
  __typename?: 'stops_database_quay_check_constraints_var_pop_fields';
  check_constraints_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseQuayCheckConstraintsVarSampFields = {
  __typename?: 'stops_database_quay_check_constraints_var_samp_fields';
  check_constraints_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseQuayCheckConstraintsVarianceFields = {
  __typename?: 'stops_database_quay_check_constraints_variance_fields';
  check_constraints_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** unique or primary key constraints on table "quay" */
export enum StopsDatabaseQuayConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  QuayNetexIdVersionConstraint = 'quay_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  QuayPkey = 'quay_pkey',
}

/** columns and relationships of "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlaces = {
  __typename?: 'stops_database_quay_equipment_places';
  /** An object relationship */
  equipment_place: StopsDatabaseEquipmentPlace;
  equipment_places_id: Scalars['bigint'];
  quay_id: Scalars['bigint'];
};

/** aggregated selection of "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesAggregate = {
  __typename?: 'stops_database_quay_equipment_places_aggregate';
  aggregate?: Maybe<StopsDatabaseQuayEquipmentPlacesAggregateFields>;
  nodes: Array<StopsDatabaseQuayEquipmentPlaces>;
};

/** aggregate fields of "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesAggregateFields = {
  __typename?: 'stops_database_quay_equipment_places_aggregate_fields';
  avg?: Maybe<StopsDatabaseQuayEquipmentPlacesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseQuayEquipmentPlacesMaxFields>;
  min?: Maybe<StopsDatabaseQuayEquipmentPlacesMinFields>;
  stddev?: Maybe<StopsDatabaseQuayEquipmentPlacesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseQuayEquipmentPlacesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseQuayEquipmentPlacesStddevSampFields>;
  sum?: Maybe<StopsDatabaseQuayEquipmentPlacesSumFields>;
  var_pop?: Maybe<StopsDatabaseQuayEquipmentPlacesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseQuayEquipmentPlacesVarSampFields>;
  variance?: Maybe<StopsDatabaseQuayEquipmentPlacesVarianceFields>;
};

/** aggregate fields of "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseQuayEquipmentPlacesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseQuayEquipmentPlacesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseQuayEquipmentPlacesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseQuayEquipmentPlacesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseQuayEquipmentPlacesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseQuayEquipmentPlacesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseQuayEquipmentPlacesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseQuayEquipmentPlacesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseQuayEquipmentPlacesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseQuayEquipmentPlacesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseQuayEquipmentPlacesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesArrRelInsertInput = {
  data: Array<StopsDatabaseQuayEquipmentPlacesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseQuayEquipmentPlacesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseQuayEquipmentPlacesAvgFields = {
  __typename?: 'stops_database_quay_equipment_places_avg_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesAvgOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "quay_equipment_places". All fields are combined with a logical 'AND'. */
export type StopsDatabaseQuayEquipmentPlacesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseQuayEquipmentPlacesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseQuayEquipmentPlacesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseQuayEquipmentPlacesBoolExp>>;
  equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceBoolExp>;
  equipment_places_id?: InputMaybe<BigintComparisonExp>;
  quay_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "quay_equipment_places" */
export enum StopsDatabaseQuayEquipmentPlacesConstraint {
  /** unique or primary key constraint on columns "equipment_places_id" */
  Uk_2kygsfeskolk0dcv3580xknh4 = 'uk_2kygsfeskolk0dcv3580xknh4',
}

/** input type for incrementing numeric columns in table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesIncInput = {
  equipment_places_id?: InputMaybe<Scalars['bigint']>;
  quay_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesInsertInput = {
  equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceObjRelInsertInput>;
  equipment_places_id?: InputMaybe<Scalars['bigint']>;
  quay_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseQuayEquipmentPlacesMaxFields = {
  __typename?: 'stops_database_quay_equipment_places_max_fields';
  equipment_places_id?: Maybe<Scalars['bigint']>;
  quay_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesMaxOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseQuayEquipmentPlacesMinFields = {
  __typename?: 'stops_database_quay_equipment_places_min_fields';
  equipment_places_id?: Maybe<Scalars['bigint']>;
  quay_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesMinOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesMutationResponse = {
  __typename?: 'stops_database_quay_equipment_places_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseQuayEquipmentPlaces>;
};

/** on_conflict condition type for table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesOnConflict = {
  constraint: StopsDatabaseQuayEquipmentPlacesConstraint;
  update_columns?: Array<StopsDatabaseQuayEquipmentPlacesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseQuayEquipmentPlacesBoolExp>;
};

/** Ordering options when selecting data from "quay_equipment_places". */
export type StopsDatabaseQuayEquipmentPlacesOrderBy = {
  equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceOrderBy>;
  equipment_places_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** select columns of table "quay_equipment_places" */
export enum StopsDatabaseQuayEquipmentPlacesSelectColumn {
  /** column name */
  EquipmentPlacesId = 'equipment_places_id',
  /** column name */
  QuayId = 'quay_id',
}

/** input type for updating data in table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesSetInput = {
  equipment_places_id?: InputMaybe<Scalars['bigint']>;
  quay_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseQuayEquipmentPlacesStddevFields = {
  __typename?: 'stops_database_quay_equipment_places_stddev_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesStddevOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseQuayEquipmentPlacesStddevPopFields = {
  __typename?: 'stops_database_quay_equipment_places_stddev_pop_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesStddevPopOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseQuayEquipmentPlacesStddevSampFields = {
  __typename?: 'stops_database_quay_equipment_places_stddev_samp_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesStddevSampOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseQuayEquipmentPlacesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseQuayEquipmentPlacesStreamCursorValueInput = {
  equipment_places_id?: InputMaybe<Scalars['bigint']>;
  quay_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseQuayEquipmentPlacesSumFields = {
  __typename?: 'stops_database_quay_equipment_places_sum_fields';
  equipment_places_id?: Maybe<Scalars['bigint']>;
  quay_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesSumOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** update columns of table "quay_equipment_places" */
export enum StopsDatabaseQuayEquipmentPlacesUpdateColumn {
  /** column name */
  EquipmentPlacesId = 'equipment_places_id',
  /** column name */
  QuayId = 'quay_id',
}

export type StopsDatabaseQuayEquipmentPlacesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseQuayEquipmentPlacesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseQuayEquipmentPlacesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseQuayEquipmentPlacesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseQuayEquipmentPlacesVarPopFields = {
  __typename?: 'stops_database_quay_equipment_places_var_pop_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesVarPopOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseQuayEquipmentPlacesVarSampFields = {
  __typename?: 'stops_database_quay_equipment_places_var_samp_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesVarSampOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseQuayEquipmentPlacesVarianceFields = {
  __typename?: 'stops_database_quay_equipment_places_variance_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesVarianceOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** input type for incrementing numeric columns in table "quay" */
export type StopsDatabaseQuayIncInput = {
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  compass_bearing?: InputMaybe<Scalars['Float']>;
  covered?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['bigint']>;
  place_equipments_id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "quay" */
export type StopsDatabaseQuayInsertInput = {
  accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentObjRelInsertInput>;
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']>;
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  compass_bearing?: InputMaybe<Scalars['Float']>;
  covered?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureObjRelInsertInput>;
  label_lang?: InputMaybe<Scalars['String']>;
  label_value?: InputMaybe<Scalars['String']>;
  level_ref?: InputMaybe<Scalars['String']>;
  level_ref_version?: InputMaybe<Scalars['String']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonObjRelInsertInput>;
  place_equipments_id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  public_code?: InputMaybe<Scalars['String']>;
  quay_alternative_names?: InputMaybe<StopsDatabaseQuayAlternativeNamesArrRelInsertInput>;
  quay_boarding_positions?: InputMaybe<StopsDatabaseQuayBoardingPositionsArrRelInsertInput>;
  quay_equipment_places?: InputMaybe<StopsDatabaseQuayEquipmentPlacesArrRelInsertInput>;
  quay_key_values?: InputMaybe<StopsDatabaseQuayKeyValuesArrRelInsertInput>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  site_ref?: InputMaybe<Scalars['String']>;
  site_ref_version?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "quay_key_values" */
export type StopsDatabaseQuayKeyValues = {
  __typename?: 'stops_database_quay_key_values';
  key_values_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
  quay_id: Scalars['bigint'];
  /** An object relationship */
  value: StopsDatabaseValue;
};

/** aggregated selection of "quay_key_values" */
export type StopsDatabaseQuayKeyValuesAggregate = {
  __typename?: 'stops_database_quay_key_values_aggregate';
  aggregate?: Maybe<StopsDatabaseQuayKeyValuesAggregateFields>;
  nodes: Array<StopsDatabaseQuayKeyValues>;
};

/** aggregate fields of "quay_key_values" */
export type StopsDatabaseQuayKeyValuesAggregateFields = {
  __typename?: 'stops_database_quay_key_values_aggregate_fields';
  avg?: Maybe<StopsDatabaseQuayKeyValuesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseQuayKeyValuesMaxFields>;
  min?: Maybe<StopsDatabaseQuayKeyValuesMinFields>;
  stddev?: Maybe<StopsDatabaseQuayKeyValuesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseQuayKeyValuesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseQuayKeyValuesStddevSampFields>;
  sum?: Maybe<StopsDatabaseQuayKeyValuesSumFields>;
  var_pop?: Maybe<StopsDatabaseQuayKeyValuesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseQuayKeyValuesVarSampFields>;
  variance?: Maybe<StopsDatabaseQuayKeyValuesVarianceFields>;
};

/** aggregate fields of "quay_key_values" */
export type StopsDatabaseQuayKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseQuayKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseQuayKeyValuesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseQuayKeyValuesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseQuayKeyValuesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseQuayKeyValuesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseQuayKeyValuesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseQuayKeyValuesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseQuayKeyValuesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseQuayKeyValuesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseQuayKeyValuesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseQuayKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesArrRelInsertInput = {
  data: Array<StopsDatabaseQuayKeyValuesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseQuayKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseQuayKeyValuesAvgFields = {
  __typename?: 'stops_database_quay_key_values_avg_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesAvgOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "quay_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseQuayKeyValuesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseQuayKeyValuesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseQuayKeyValuesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseQuayKeyValuesBoolExp>>;
  key_values_id?: InputMaybe<BigintComparisonExp>;
  key_values_key?: InputMaybe<StringComparisonExp>;
  quay_id?: InputMaybe<BigintComparisonExp>;
  value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "quay_key_values" */
export enum StopsDatabaseQuayKeyValuesConstraint {
  /** unique or primary key constraint on columns "quay_id", "key_values_key" */
  QuayKeyValuesPkey = 'quay_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkPlgcx1aoolr4vngts8ifkrse6 = 'uk_plgcx1aoolr4vngts8ifkrse6',
}

/** input type for incrementing numeric columns in table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesIncInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  quay_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesInsertInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  quay_id?: InputMaybe<Scalars['bigint']>;
  value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseQuayKeyValuesMaxFields = {
  __typename?: 'stops_database_quay_key_values_max_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
  quay_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesMaxOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseQuayKeyValuesMinFields = {
  __typename?: 'stops_database_quay_key_values_min_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
  quay_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesMinOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesMutationResponse = {
  __typename?: 'stops_database_quay_key_values_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseQuayKeyValues>;
};

/** on_conflict condition type for table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesOnConflict = {
  constraint: StopsDatabaseQuayKeyValuesConstraint;
  update_columns?: Array<StopsDatabaseQuayKeyValuesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseQuayKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "quay_key_values". */
export type StopsDatabaseQuayKeyValuesOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
  value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: quay_key_values */
export type StopsDatabaseQuayKeyValuesPkColumnsInput = {
  key_values_key: Scalars['String'];
  quay_id: Scalars['bigint'];
};

/** select columns of table "quay_key_values" */
export enum StopsDatabaseQuayKeyValuesSelectColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  QuayId = 'quay_id',
}

/** input type for updating data in table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesSetInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  quay_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseQuayKeyValuesStddevFields = {
  __typename?: 'stops_database_quay_key_values_stddev_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesStddevOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseQuayKeyValuesStddevPopFields = {
  __typename?: 'stops_database_quay_key_values_stddev_pop_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesStddevPopOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseQuayKeyValuesStddevSampFields = {
  __typename?: 'stops_database_quay_key_values_stddev_samp_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesStddevSampOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseQuayKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseQuayKeyValuesStreamCursorValueInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  quay_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseQuayKeyValuesSumFields = {
  __typename?: 'stops_database_quay_key_values_sum_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  quay_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesSumOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** update columns of table "quay_key_values" */
export enum StopsDatabaseQuayKeyValuesUpdateColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  QuayId = 'quay_id',
}

export type StopsDatabaseQuayKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseQuayKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseQuayKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseQuayKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseQuayKeyValuesVarPopFields = {
  __typename?: 'stops_database_quay_key_values_var_pop_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesVarPopOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseQuayKeyValuesVarSampFields = {
  __typename?: 'stops_database_quay_key_values_var_samp_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesVarSampOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseQuayKeyValuesVarianceFields = {
  __typename?: 'stops_database_quay_key_values_variance_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  quay_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesVarianceOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  quay_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseQuayMaxFields = {
  __typename?: 'stops_database_quay_max_fields';
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  compass_bearing?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Int']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  label_lang?: Maybe<Scalars['String']>;
  label_value?: Maybe<Scalars['String']>;
  level_ref?: Maybe<Scalars['String']>;
  level_ref_version?: Maybe<Scalars['String']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  place_equipments_id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  public_code?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  site_ref?: Maybe<Scalars['String']>;
  site_ref_version?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseQuayMinFields = {
  __typename?: 'stops_database_quay_min_fields';
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  compass_bearing?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Int']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  label_lang?: Maybe<Scalars['String']>;
  label_value?: Maybe<Scalars['String']>;
  level_ref?: Maybe<Scalars['String']>;
  level_ref_version?: Maybe<Scalars['String']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  place_equipments_id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  public_code?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  site_ref?: Maybe<Scalars['String']>;
  site_ref_version?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "quay" */
export type StopsDatabaseQuayMutationResponse = {
  __typename?: 'stops_database_quay_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseQuay>;
};

/** input type for inserting object relation for remote table "quay" */
export type StopsDatabaseQuayObjRelInsertInput = {
  data: StopsDatabaseQuayInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseQuayOnConflict>;
};

/** on_conflict condition type for table "quay" */
export type StopsDatabaseQuayOnConflict = {
  constraint: StopsDatabaseQuayConstraint;
  update_columns?: Array<StopsDatabaseQuayUpdateColumn>;
  where?: InputMaybe<StopsDatabaseQuayBoolExp>;
};

/** Ordering options when selecting data from "quay". */
export type StopsDatabaseQuayOrderBy = {
  accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentOrderBy>;
  accessibility_assessment_id?: InputMaybe<OrderBy>;
  all_areas_wheelchair_accessible?: InputMaybe<OrderBy>;
  centroid?: InputMaybe<OrderBy>;
  changed?: InputMaybe<OrderBy>;
  changed_by?: InputMaybe<OrderBy>;
  compass_bearing?: InputMaybe<OrderBy>;
  covered?: InputMaybe<OrderBy>;
  created?: InputMaybe<OrderBy>;
  description_lang?: InputMaybe<OrderBy>;
  description_value?: InputMaybe<OrderBy>;
  from_date?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureOrderBy>;
  label_lang?: InputMaybe<OrderBy>;
  label_value?: InputMaybe<OrderBy>;
  level_ref?: InputMaybe<OrderBy>;
  level_ref_version?: InputMaybe<OrderBy>;
  name_lang?: InputMaybe<OrderBy>;
  name_value?: InputMaybe<OrderBy>;
  netex_id?: InputMaybe<OrderBy>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonOrderBy>;
  place_equipments_id?: InputMaybe<OrderBy>;
  polygon_id?: InputMaybe<OrderBy>;
  private_code_type?: InputMaybe<OrderBy>;
  private_code_value?: InputMaybe<OrderBy>;
  public_code?: InputMaybe<OrderBy>;
  quay_alternative_names_aggregate?: InputMaybe<StopsDatabaseQuayAlternativeNamesAggregateOrderBy>;
  quay_boarding_positions_aggregate?: InputMaybe<StopsDatabaseQuayBoardingPositionsAggregateOrderBy>;
  quay_equipment_places_aggregate?: InputMaybe<StopsDatabaseQuayEquipmentPlacesAggregateOrderBy>;
  quay_key_values_aggregate?: InputMaybe<StopsDatabaseQuayKeyValuesAggregateOrderBy>;
  short_name_lang?: InputMaybe<OrderBy>;
  short_name_value?: InputMaybe<OrderBy>;
  site_ref?: InputMaybe<OrderBy>;
  site_ref_version?: InputMaybe<OrderBy>;
  to_date?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
  version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: quay */
export type StopsDatabaseQuayPkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "quay" */
export enum StopsDatabaseQuaySelectColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  CompassBearing = 'compass_bearing',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  LabelLang = 'label_lang',
  /** column name */
  LabelValue = 'label_value',
  /** column name */
  LevelRef = 'level_ref',
  /** column name */
  LevelRefVersion = 'level_ref_version',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  PublicCode = 'public_code',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  SiteRef = 'site_ref',
  /** column name */
  SiteRefVersion = 'site_ref_version',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

/** input type for updating data in table "quay" */
export type StopsDatabaseQuaySetInput = {
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']>;
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  compass_bearing?: InputMaybe<Scalars['Float']>;
  covered?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  label_lang?: InputMaybe<Scalars['String']>;
  label_value?: InputMaybe<Scalars['String']>;
  level_ref?: InputMaybe<Scalars['String']>;
  level_ref_version?: InputMaybe<Scalars['String']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  place_equipments_id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  public_code?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  site_ref?: InputMaybe<Scalars['String']>;
  site_ref_version?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseQuayStddevFields = {
  __typename?: 'stops_database_quay_stddev_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  compass_bearing?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseQuayStddevPopFields = {
  __typename?: 'stops_database_quay_stddev_pop_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  compass_bearing?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseQuayStddevSampFields = {
  __typename?: 'stops_database_quay_stddev_samp_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  compass_bearing?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "quay" */
export type StopsDatabaseQuayStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseQuayStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseQuayStreamCursorValueInput = {
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']>;
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  compass_bearing?: InputMaybe<Scalars['Float']>;
  covered?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  label_lang?: InputMaybe<Scalars['String']>;
  label_value?: InputMaybe<Scalars['String']>;
  level_ref?: InputMaybe<Scalars['String']>;
  level_ref_version?: InputMaybe<Scalars['String']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  place_equipments_id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  public_code?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  site_ref?: InputMaybe<Scalars['String']>;
  site_ref_version?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseQuaySumFields = {
  __typename?: 'stops_database_quay_sum_fields';
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  compass_bearing?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['bigint']>;
  place_equipments_id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['bigint']>;
};

/** update columns of table "quay" */
export enum StopsDatabaseQuayUpdateColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  CompassBearing = 'compass_bearing',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  LabelLang = 'label_lang',
  /** column name */
  LabelValue = 'label_value',
  /** column name */
  LevelRef = 'level_ref',
  /** column name */
  LevelRefVersion = 'level_ref_version',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  PublicCode = 'public_code',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  SiteRef = 'site_ref',
  /** column name */
  SiteRefVersion = 'site_ref_version',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

export type StopsDatabaseQuayUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseQuayIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseQuaySetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseQuayBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseQuayVarPopFields = {
  __typename?: 'stops_database_quay_var_pop_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  compass_bearing?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseQuayVarSampFields = {
  __typename?: 'stops_database_quay_var_samp_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  compass_bearing?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseQuayVarianceFields = {
  __typename?: 'stops_database_quay_variance_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  compass_bearing?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "schema_version" */
export type StopsDatabaseSchemaVersion = {
  __typename?: 'stops_database_schema_version';
  checksum?: Maybe<Scalars['Int']>;
  description: Scalars['String'];
  execution_time: Scalars['Int'];
  installed_by: Scalars['String'];
  installed_on: Scalars['timestamp'];
  installed_rank: Scalars['Int'];
  script: Scalars['String'];
  success: Scalars['Boolean'];
  type: Scalars['String'];
  version?: Maybe<Scalars['String']>;
};

/** aggregated selection of "schema_version" */
export type StopsDatabaseSchemaVersionAggregate = {
  __typename?: 'stops_database_schema_version_aggregate';
  aggregate?: Maybe<StopsDatabaseSchemaVersionAggregateFields>;
  nodes: Array<StopsDatabaseSchemaVersion>;
};

/** aggregate fields of "schema_version" */
export type StopsDatabaseSchemaVersionAggregateFields = {
  __typename?: 'stops_database_schema_version_aggregate_fields';
  avg?: Maybe<StopsDatabaseSchemaVersionAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseSchemaVersionMaxFields>;
  min?: Maybe<StopsDatabaseSchemaVersionMinFields>;
  stddev?: Maybe<StopsDatabaseSchemaVersionStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseSchemaVersionStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseSchemaVersionStddevSampFields>;
  sum?: Maybe<StopsDatabaseSchemaVersionSumFields>;
  var_pop?: Maybe<StopsDatabaseSchemaVersionVarPopFields>;
  var_samp?: Maybe<StopsDatabaseSchemaVersionVarSampFields>;
  variance?: Maybe<StopsDatabaseSchemaVersionVarianceFields>;
};

/** aggregate fields of "schema_version" */
export type StopsDatabaseSchemaVersionAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseSchemaVersionSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseSchemaVersionAvgFields = {
  __typename?: 'stops_database_schema_version_avg_fields';
  checksum?: Maybe<Scalars['Float']>;
  execution_time?: Maybe<Scalars['Float']>;
  installed_rank?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "schema_version". All fields are combined with a logical 'AND'. */
export type StopsDatabaseSchemaVersionBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseSchemaVersionBoolExp>>;
  _not?: InputMaybe<StopsDatabaseSchemaVersionBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseSchemaVersionBoolExp>>;
  checksum?: InputMaybe<IntComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  execution_time?: InputMaybe<IntComparisonExp>;
  installed_by?: InputMaybe<StringComparisonExp>;
  installed_on?: InputMaybe<TimestampComparisonExp>;
  installed_rank?: InputMaybe<IntComparisonExp>;
  script?: InputMaybe<StringComparisonExp>;
  success?: InputMaybe<BooleanComparisonExp>;
  type?: InputMaybe<StringComparisonExp>;
  version?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "schema_version" */
export enum StopsDatabaseSchemaVersionConstraint {
  /** unique or primary key constraint on columns "installed_rank" */
  SchemaVersionPk = 'schema_version_pk',
}

/** input type for incrementing numeric columns in table "schema_version" */
export type StopsDatabaseSchemaVersionIncInput = {
  checksum?: InputMaybe<Scalars['Int']>;
  execution_time?: InputMaybe<Scalars['Int']>;
  installed_rank?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "schema_version" */
export type StopsDatabaseSchemaVersionInsertInput = {
  checksum?: InputMaybe<Scalars['Int']>;
  description?: InputMaybe<Scalars['String']>;
  execution_time?: InputMaybe<Scalars['Int']>;
  installed_by?: InputMaybe<Scalars['String']>;
  installed_on?: InputMaybe<Scalars['timestamp']>;
  installed_rank?: InputMaybe<Scalars['Int']>;
  script?: InputMaybe<Scalars['String']>;
  success?: InputMaybe<Scalars['Boolean']>;
  type?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type StopsDatabaseSchemaVersionMaxFields = {
  __typename?: 'stops_database_schema_version_max_fields';
  checksum?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  execution_time?: Maybe<Scalars['Int']>;
  installed_by?: Maybe<Scalars['String']>;
  installed_on?: Maybe<Scalars['timestamp']>;
  installed_rank?: Maybe<Scalars['Int']>;
  script?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseSchemaVersionMinFields = {
  __typename?: 'stops_database_schema_version_min_fields';
  checksum?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  execution_time?: Maybe<Scalars['Int']>;
  installed_by?: Maybe<Scalars['String']>;
  installed_on?: Maybe<Scalars['timestamp']>;
  installed_rank?: Maybe<Scalars['Int']>;
  script?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "schema_version" */
export type StopsDatabaseSchemaVersionMutationResponse = {
  __typename?: 'stops_database_schema_version_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseSchemaVersion>;
};

/** on_conflict condition type for table "schema_version" */
export type StopsDatabaseSchemaVersionOnConflict = {
  constraint: StopsDatabaseSchemaVersionConstraint;
  update_columns?: Array<StopsDatabaseSchemaVersionUpdateColumn>;
  where?: InputMaybe<StopsDatabaseSchemaVersionBoolExp>;
};

/** Ordering options when selecting data from "schema_version". */
export type StopsDatabaseSchemaVersionOrderBy = {
  checksum?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  execution_time?: InputMaybe<OrderBy>;
  installed_by?: InputMaybe<OrderBy>;
  installed_on?: InputMaybe<OrderBy>;
  installed_rank?: InputMaybe<OrderBy>;
  script?: InputMaybe<OrderBy>;
  success?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: schema_version */
export type StopsDatabaseSchemaVersionPkColumnsInput = {
  installed_rank: Scalars['Int'];
};

/** select columns of table "schema_version" */
export enum StopsDatabaseSchemaVersionSelectColumn {
  /** column name */
  Checksum = 'checksum',
  /** column name */
  Description = 'description',
  /** column name */
  ExecutionTime = 'execution_time',
  /** column name */
  InstalledBy = 'installed_by',
  /** column name */
  InstalledOn = 'installed_on',
  /** column name */
  InstalledRank = 'installed_rank',
  /** column name */
  Script = 'script',
  /** column name */
  Success = 'success',
  /** column name */
  Type = 'type',
  /** column name */
  Version = 'version',
}

/** input type for updating data in table "schema_version" */
export type StopsDatabaseSchemaVersionSetInput = {
  checksum?: InputMaybe<Scalars['Int']>;
  description?: InputMaybe<Scalars['String']>;
  execution_time?: InputMaybe<Scalars['Int']>;
  installed_by?: InputMaybe<Scalars['String']>;
  installed_on?: InputMaybe<Scalars['timestamp']>;
  installed_rank?: InputMaybe<Scalars['Int']>;
  script?: InputMaybe<Scalars['String']>;
  success?: InputMaybe<Scalars['Boolean']>;
  type?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseSchemaVersionStddevFields = {
  __typename?: 'stops_database_schema_version_stddev_fields';
  checksum?: Maybe<Scalars['Float']>;
  execution_time?: Maybe<Scalars['Float']>;
  installed_rank?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseSchemaVersionStddevPopFields = {
  __typename?: 'stops_database_schema_version_stddev_pop_fields';
  checksum?: Maybe<Scalars['Float']>;
  execution_time?: Maybe<Scalars['Float']>;
  installed_rank?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseSchemaVersionStddevSampFields = {
  __typename?: 'stops_database_schema_version_stddev_samp_fields';
  checksum?: Maybe<Scalars['Float']>;
  execution_time?: Maybe<Scalars['Float']>;
  installed_rank?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "schema_version" */
export type StopsDatabaseSchemaVersionStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseSchemaVersionStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseSchemaVersionStreamCursorValueInput = {
  checksum?: InputMaybe<Scalars['Int']>;
  description?: InputMaybe<Scalars['String']>;
  execution_time?: InputMaybe<Scalars['Int']>;
  installed_by?: InputMaybe<Scalars['String']>;
  installed_on?: InputMaybe<Scalars['timestamp']>;
  installed_rank?: InputMaybe<Scalars['Int']>;
  script?: InputMaybe<Scalars['String']>;
  success?: InputMaybe<Scalars['Boolean']>;
  type?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseSchemaVersionSumFields = {
  __typename?: 'stops_database_schema_version_sum_fields';
  checksum?: Maybe<Scalars['Int']>;
  execution_time?: Maybe<Scalars['Int']>;
  installed_rank?: Maybe<Scalars['Int']>;
};

/** update columns of table "schema_version" */
export enum StopsDatabaseSchemaVersionUpdateColumn {
  /** column name */
  Checksum = 'checksum',
  /** column name */
  Description = 'description',
  /** column name */
  ExecutionTime = 'execution_time',
  /** column name */
  InstalledBy = 'installed_by',
  /** column name */
  InstalledOn = 'installed_on',
  /** column name */
  InstalledRank = 'installed_rank',
  /** column name */
  Script = 'script',
  /** column name */
  Success = 'success',
  /** column name */
  Type = 'type',
  /** column name */
  Version = 'version',
}

export type StopsDatabaseSchemaVersionUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseSchemaVersionIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseSchemaVersionSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseSchemaVersionBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseSchemaVersionVarPopFields = {
  __typename?: 'stops_database_schema_version_var_pop_fields';
  checksum?: Maybe<Scalars['Float']>;
  execution_time?: Maybe<Scalars['Float']>;
  installed_rank?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseSchemaVersionVarSampFields = {
  __typename?: 'stops_database_schema_version_var_samp_fields';
  checksum?: Maybe<Scalars['Float']>;
  execution_time?: Maybe<Scalars['Float']>;
  installed_rank?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseSchemaVersionVarianceFields = {
  __typename?: 'stops_database_schema_version_variance_fields';
  checksum?: Maybe<Scalars['Float']>;
  execution_time?: Maybe<Scalars['Float']>;
  installed_rank?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "spatial_ref_sys" */
export type StopsDatabaseSpatialRefSys = {
  __typename?: 'stops_database_spatial_ref_sys';
  auth_name?: Maybe<Scalars['String']>;
  auth_srid?: Maybe<Scalars['Int']>;
  proj4text?: Maybe<Scalars['String']>;
  srid: Scalars['Int'];
  srtext?: Maybe<Scalars['String']>;
};

/** aggregated selection of "spatial_ref_sys" */
export type StopsDatabaseSpatialRefSysAggregate = {
  __typename?: 'stops_database_spatial_ref_sys_aggregate';
  aggregate?: Maybe<StopsDatabaseSpatialRefSysAggregateFields>;
  nodes: Array<StopsDatabaseSpatialRefSys>;
};

/** aggregate fields of "spatial_ref_sys" */
export type StopsDatabaseSpatialRefSysAggregateFields = {
  __typename?: 'stops_database_spatial_ref_sys_aggregate_fields';
  avg?: Maybe<StopsDatabaseSpatialRefSysAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseSpatialRefSysMaxFields>;
  min?: Maybe<StopsDatabaseSpatialRefSysMinFields>;
  stddev?: Maybe<StopsDatabaseSpatialRefSysStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseSpatialRefSysStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseSpatialRefSysStddevSampFields>;
  sum?: Maybe<StopsDatabaseSpatialRefSysSumFields>;
  var_pop?: Maybe<StopsDatabaseSpatialRefSysVarPopFields>;
  var_samp?: Maybe<StopsDatabaseSpatialRefSysVarSampFields>;
  variance?: Maybe<StopsDatabaseSpatialRefSysVarianceFields>;
};

/** aggregate fields of "spatial_ref_sys" */
export type StopsDatabaseSpatialRefSysAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseSpatialRefSysSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseSpatialRefSysAvgFields = {
  __typename?: 'stops_database_spatial_ref_sys_avg_fields';
  auth_srid?: Maybe<Scalars['Float']>;
  srid?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "spatial_ref_sys". All fields are combined with a logical 'AND'. */
export type StopsDatabaseSpatialRefSysBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseSpatialRefSysBoolExp>>;
  _not?: InputMaybe<StopsDatabaseSpatialRefSysBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseSpatialRefSysBoolExp>>;
  auth_name?: InputMaybe<StringComparisonExp>;
  auth_srid?: InputMaybe<IntComparisonExp>;
  proj4text?: InputMaybe<StringComparisonExp>;
  srid?: InputMaybe<IntComparisonExp>;
  srtext?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "spatial_ref_sys" */
export enum StopsDatabaseSpatialRefSysConstraint {
  /** unique or primary key constraint on columns "srid" */
  SpatialRefSysPkey = 'spatial_ref_sys_pkey',
}

/** input type for incrementing numeric columns in table "spatial_ref_sys" */
export type StopsDatabaseSpatialRefSysIncInput = {
  auth_srid?: InputMaybe<Scalars['Int']>;
  srid?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "spatial_ref_sys" */
export type StopsDatabaseSpatialRefSysInsertInput = {
  auth_name?: InputMaybe<Scalars['String']>;
  auth_srid?: InputMaybe<Scalars['Int']>;
  proj4text?: InputMaybe<Scalars['String']>;
  srid?: InputMaybe<Scalars['Int']>;
  srtext?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type StopsDatabaseSpatialRefSysMaxFields = {
  __typename?: 'stops_database_spatial_ref_sys_max_fields';
  auth_name?: Maybe<Scalars['String']>;
  auth_srid?: Maybe<Scalars['Int']>;
  proj4text?: Maybe<Scalars['String']>;
  srid?: Maybe<Scalars['Int']>;
  srtext?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseSpatialRefSysMinFields = {
  __typename?: 'stops_database_spatial_ref_sys_min_fields';
  auth_name?: Maybe<Scalars['String']>;
  auth_srid?: Maybe<Scalars['Int']>;
  proj4text?: Maybe<Scalars['String']>;
  srid?: Maybe<Scalars['Int']>;
  srtext?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "spatial_ref_sys" */
export type StopsDatabaseSpatialRefSysMutationResponse = {
  __typename?: 'stops_database_spatial_ref_sys_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseSpatialRefSys>;
};

/** on_conflict condition type for table "spatial_ref_sys" */
export type StopsDatabaseSpatialRefSysOnConflict = {
  constraint: StopsDatabaseSpatialRefSysConstraint;
  update_columns?: Array<StopsDatabaseSpatialRefSysUpdateColumn>;
  where?: InputMaybe<StopsDatabaseSpatialRefSysBoolExp>;
};

/** Ordering options when selecting data from "spatial_ref_sys". */
export type StopsDatabaseSpatialRefSysOrderBy = {
  auth_name?: InputMaybe<OrderBy>;
  auth_srid?: InputMaybe<OrderBy>;
  proj4text?: InputMaybe<OrderBy>;
  srid?: InputMaybe<OrderBy>;
  srtext?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: spatial_ref_sys */
export type StopsDatabaseSpatialRefSysPkColumnsInput = {
  srid: Scalars['Int'];
};

/** select columns of table "spatial_ref_sys" */
export enum StopsDatabaseSpatialRefSysSelectColumn {
  /** column name */
  AuthName = 'auth_name',
  /** column name */
  AuthSrid = 'auth_srid',
  /** column name */
  Proj4text = 'proj4text',
  /** column name */
  Srid = 'srid',
  /** column name */
  Srtext = 'srtext',
}

/** input type for updating data in table "spatial_ref_sys" */
export type StopsDatabaseSpatialRefSysSetInput = {
  auth_name?: InputMaybe<Scalars['String']>;
  auth_srid?: InputMaybe<Scalars['Int']>;
  proj4text?: InputMaybe<Scalars['String']>;
  srid?: InputMaybe<Scalars['Int']>;
  srtext?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseSpatialRefSysStddevFields = {
  __typename?: 'stops_database_spatial_ref_sys_stddev_fields';
  auth_srid?: Maybe<Scalars['Float']>;
  srid?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseSpatialRefSysStddevPopFields = {
  __typename?: 'stops_database_spatial_ref_sys_stddev_pop_fields';
  auth_srid?: Maybe<Scalars['Float']>;
  srid?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseSpatialRefSysStddevSampFields = {
  __typename?: 'stops_database_spatial_ref_sys_stddev_samp_fields';
  auth_srid?: Maybe<Scalars['Float']>;
  srid?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "spatial_ref_sys" */
export type StopsDatabaseSpatialRefSysStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseSpatialRefSysStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseSpatialRefSysStreamCursorValueInput = {
  auth_name?: InputMaybe<Scalars['String']>;
  auth_srid?: InputMaybe<Scalars['Int']>;
  proj4text?: InputMaybe<Scalars['String']>;
  srid?: InputMaybe<Scalars['Int']>;
  srtext?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseSpatialRefSysSumFields = {
  __typename?: 'stops_database_spatial_ref_sys_sum_fields';
  auth_srid?: Maybe<Scalars['Int']>;
  srid?: Maybe<Scalars['Int']>;
};

/** update columns of table "spatial_ref_sys" */
export enum StopsDatabaseSpatialRefSysUpdateColumn {
  /** column name */
  AuthName = 'auth_name',
  /** column name */
  AuthSrid = 'auth_srid',
  /** column name */
  Proj4text = 'proj4text',
  /** column name */
  Srid = 'srid',
  /** column name */
  Srtext = 'srtext',
}

export type StopsDatabaseSpatialRefSysUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseSpatialRefSysIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseSpatialRefSysSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseSpatialRefSysBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseSpatialRefSysVarPopFields = {
  __typename?: 'stops_database_spatial_ref_sys_var_pop_fields';
  auth_srid?: Maybe<Scalars['Float']>;
  srid?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseSpatialRefSysVarSampFields = {
  __typename?: 'stops_database_spatial_ref_sys_var_samp_fields';
  auth_srid?: Maybe<Scalars['Float']>;
  srid?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseSpatialRefSysVarianceFields = {
  __typename?: 'stops_database_spatial_ref_sys_variance_fields';
  auth_srid?: Maybe<Scalars['Float']>;
  srid?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlace = {
  __typename?: 'stops_database_stop_place';
  /** An object relationship */
  accessibility_assessment?: Maybe<StopsDatabaseAccessibilityAssessment>;
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  air_submode?: Maybe<Scalars['String']>;
  all_areas_wheelchair_accessible?: Maybe<Scalars['Boolean']>;
  border_crossing?: Maybe<Scalars['Boolean']>;
  bus_submode?: Maybe<Scalars['String']>;
  centroid?: Maybe<Scalars['geometry']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  coach_submode?: Maybe<Scalars['String']>;
  covered?: Maybe<Scalars['Int']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  funicular_submode?: Maybe<Scalars['String']>;
  id: Scalars['bigint'];
  /** An object relationship */
  installed_equipment_version_structure?: Maybe<StopsDatabaseInstalledEquipmentVersionStructure>;
  metro_submode?: Maybe<Scalars['String']>;
  modification_enumeration?: Maybe<Scalars['String']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  parent_site_ref?: Maybe<Scalars['String']>;
  parent_site_ref_version?: Maybe<Scalars['String']>;
  parent_stop_place: Scalars['Boolean'];
  /** An object relationship */
  persistable_polygon?: Maybe<StopsDatabasePersistablePolygon>;
  place_equipments_id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  public_code?: Maybe<Scalars['String']>;
  rail_submode?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  /** An array relationship */
  stop_place_access_spaces: Array<StopsDatabaseStopPlaceAccessSpaces>;
  /** An aggregate relationship */
  stop_place_access_spaces_aggregate: StopsDatabaseStopPlaceAccessSpacesAggregate;
  /** An array relationship */
  stop_place_alternative_names: Array<StopsDatabaseStopPlaceAlternativeNames>;
  /** An aggregate relationship */
  stop_place_alternative_names_aggregate: StopsDatabaseStopPlaceAlternativeNamesAggregate;
  /** An object relationship */
  stop_place_child?: Maybe<StopsDatabaseStopPlaceChildren>;
  /** An array relationship */
  stop_place_children: Array<StopsDatabaseStopPlaceChildren>;
  /** An aggregate relationship */
  stop_place_children_aggregate: StopsDatabaseStopPlaceChildrenAggregate;
  /** An array relationship */
  stop_place_equipment_places: Array<StopsDatabaseStopPlaceEquipmentPlaces>;
  /** An aggregate relationship */
  stop_place_equipment_places_aggregate: StopsDatabaseStopPlaceEquipmentPlacesAggregate;
  /** An array relationship */
  stop_place_key_values: Array<StopsDatabaseStopPlaceKeyValues>;
  /** An aggregate relationship */
  stop_place_key_values_aggregate: StopsDatabaseStopPlaceKeyValuesAggregate;
  /** An array relationship */
  stop_place_quays: Array<StopsDatabaseStopPlaceQuays>;
  /** An aggregate relationship */
  stop_place_quays_aggregate: StopsDatabaseStopPlaceQuaysAggregate;
  /** An array relationship */
  stop_place_tariff_zones: Array<StopsDatabaseStopPlaceTariffZones>;
  /** An aggregate relationship */
  stop_place_tariff_zones_aggregate: StopsDatabaseStopPlaceTariffZonesAggregate;
  stop_place_type?: Maybe<Scalars['String']>;
  telecabin_submode?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  /** An object relationship */
  topographic_place?: Maybe<StopsDatabaseTopographicPlace>;
  topographic_place_id?: Maybe<Scalars['bigint']>;
  tram_submode?: Maybe<Scalars['String']>;
  transport_mode?: Maybe<Scalars['String']>;
  version: Scalars['bigint'];
  version_comment?: Maybe<Scalars['String']>;
  water_submode?: Maybe<Scalars['String']>;
  weighting?: Maybe<Scalars['String']>;
};

/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceAccessSpacesArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseStopPlaceAccessSpacesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseStopPlaceAccessSpacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesBoolExp>;
};

/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceAccessSpacesAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseStopPlaceAccessSpacesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseStopPlaceAccessSpacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesBoolExp>;
};

/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceAlternativeNamesArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseStopPlaceAlternativeNamesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseStopPlaceAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesBoolExp>;
};

/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseStopPlaceAlternativeNamesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseStopPlaceAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesBoolExp>;
};

/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceChildrenArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseStopPlaceChildrenSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseStopPlaceChildrenOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
};

/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceChildrenAggregateArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseStopPlaceChildrenSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseStopPlaceChildrenOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
};

/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceEquipmentPlacesArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseStopPlaceEquipmentPlacesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseStopPlaceEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>;
};

/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceEquipmentPlacesAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseStopPlaceEquipmentPlacesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseStopPlaceEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>;
};

/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceKeyValuesArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseStopPlaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseStopPlaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceKeyValuesBoolExp>;
};

/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseStopPlaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseStopPlaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceKeyValuesBoolExp>;
};

/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceQuaysArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseStopPlaceQuaysSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseStopPlaceQuaysOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceQuaysBoolExp>;
};

/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceQuaysAggregateArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseStopPlaceQuaysSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseStopPlaceQuaysOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceQuaysBoolExp>;
};

/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceTariffZonesArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseStopPlaceTariffZonesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseStopPlaceTariffZonesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceTariffZonesBoolExp>;
};

/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceTariffZonesAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseStopPlaceTariffZonesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseStopPlaceTariffZonesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceTariffZonesBoolExp>;
};

/** columns and relationships of "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpaces = {
  __typename?: 'stops_database_stop_place_access_spaces';
  /** An object relationship */
  access_space: StopsDatabaseAccessSpace;
  access_spaces_id: Scalars['bigint'];
  stop_place_id: Scalars['bigint'];
};

/** aggregated selection of "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesAggregate = {
  __typename?: 'stops_database_stop_place_access_spaces_aggregate';
  aggregate?: Maybe<StopsDatabaseStopPlaceAccessSpacesAggregateFields>;
  nodes: Array<StopsDatabaseStopPlaceAccessSpaces>;
};

/** aggregate fields of "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesAggregateFields = {
  __typename?: 'stops_database_stop_place_access_spaces_aggregate_fields';
  avg?: Maybe<StopsDatabaseStopPlaceAccessSpacesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseStopPlaceAccessSpacesMaxFields>;
  min?: Maybe<StopsDatabaseStopPlaceAccessSpacesMinFields>;
  stddev?: Maybe<StopsDatabaseStopPlaceAccessSpacesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseStopPlaceAccessSpacesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseStopPlaceAccessSpacesStddevSampFields>;
  sum?: Maybe<StopsDatabaseStopPlaceAccessSpacesSumFields>;
  var_pop?: Maybe<StopsDatabaseStopPlaceAccessSpacesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseStopPlaceAccessSpacesVarSampFields>;
  variance?: Maybe<StopsDatabaseStopPlaceAccessSpacesVarianceFields>;
};

/** aggregate fields of "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseStopPlaceAccessSpacesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesArrRelInsertInput = {
  data: Array<StopsDatabaseStopPlaceAccessSpacesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseStopPlaceAccessSpacesAvgFields = {
  __typename?: 'stops_database_stop_place_access_spaces_avg_fields';
  access_spaces_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesAvgOrderBy = {
  access_spaces_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "stop_place_access_spaces". All fields are combined with a logical 'AND'. */
export type StopsDatabaseStopPlaceAccessSpacesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseStopPlaceAccessSpacesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseStopPlaceAccessSpacesBoolExp>>;
  access_space?: InputMaybe<StopsDatabaseAccessSpaceBoolExp>;
  access_spaces_id?: InputMaybe<BigintComparisonExp>;
  stop_place_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "stop_place_access_spaces" */
export enum StopsDatabaseStopPlaceAccessSpacesConstraint {
  /** unique or primary key constraint on columns "access_spaces_id" */
  UkStiis59w04hmptq2wkpsfjpb8 = 'uk_stiis59w04hmptq2wkpsfjpb8',
}

/** input type for incrementing numeric columns in table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesIncInput = {
  access_spaces_id?: InputMaybe<Scalars['bigint']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesInsertInput = {
  access_space?: InputMaybe<StopsDatabaseAccessSpaceObjRelInsertInput>;
  access_spaces_id?: InputMaybe<Scalars['bigint']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseStopPlaceAccessSpacesMaxFields = {
  __typename?: 'stops_database_stop_place_access_spaces_max_fields';
  access_spaces_id?: Maybe<Scalars['bigint']>;
  stop_place_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesMaxOrderBy = {
  access_spaces_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseStopPlaceAccessSpacesMinFields = {
  __typename?: 'stops_database_stop_place_access_spaces_min_fields';
  access_spaces_id?: Maybe<Scalars['bigint']>;
  stop_place_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesMinOrderBy = {
  access_spaces_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesMutationResponse = {
  __typename?: 'stops_database_stop_place_access_spaces_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseStopPlaceAccessSpaces>;
};

/** on_conflict condition type for table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesOnConflict = {
  constraint: StopsDatabaseStopPlaceAccessSpacesConstraint;
  update_columns?: Array<StopsDatabaseStopPlaceAccessSpacesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesBoolExp>;
};

/** Ordering options when selecting data from "stop_place_access_spaces". */
export type StopsDatabaseStopPlaceAccessSpacesOrderBy = {
  access_space?: InputMaybe<StopsDatabaseAccessSpaceOrderBy>;
  access_spaces_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** select columns of table "stop_place_access_spaces" */
export enum StopsDatabaseStopPlaceAccessSpacesSelectColumn {
  /** column name */
  AccessSpacesId = 'access_spaces_id',
  /** column name */
  StopPlaceId = 'stop_place_id',
}

/** input type for updating data in table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesSetInput = {
  access_spaces_id?: InputMaybe<Scalars['bigint']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseStopPlaceAccessSpacesStddevFields = {
  __typename?: 'stops_database_stop_place_access_spaces_stddev_fields';
  access_spaces_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesStddevOrderBy = {
  access_spaces_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseStopPlaceAccessSpacesStddevPopFields = {
  __typename?: 'stops_database_stop_place_access_spaces_stddev_pop_fields';
  access_spaces_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesStddevPopOrderBy = {
  access_spaces_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseStopPlaceAccessSpacesStddevSampFields = {
  __typename?: 'stops_database_stop_place_access_spaces_stddev_samp_fields';
  access_spaces_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesStddevSampOrderBy = {
  access_spaces_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseStopPlaceAccessSpacesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseStopPlaceAccessSpacesStreamCursorValueInput = {
  access_spaces_id?: InputMaybe<Scalars['bigint']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseStopPlaceAccessSpacesSumFields = {
  __typename?: 'stops_database_stop_place_access_spaces_sum_fields';
  access_spaces_id?: Maybe<Scalars['bigint']>;
  stop_place_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesSumOrderBy = {
  access_spaces_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** update columns of table "stop_place_access_spaces" */
export enum StopsDatabaseStopPlaceAccessSpacesUpdateColumn {
  /** column name */
  AccessSpacesId = 'access_spaces_id',
  /** column name */
  StopPlaceId = 'stop_place_id',
}

export type StopsDatabaseStopPlaceAccessSpacesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseStopPlaceAccessSpacesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseStopPlaceAccessSpacesVarPopFields = {
  __typename?: 'stops_database_stop_place_access_spaces_var_pop_fields';
  access_spaces_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesVarPopOrderBy = {
  access_spaces_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseStopPlaceAccessSpacesVarSampFields = {
  __typename?: 'stops_database_stop_place_access_spaces_var_samp_fields';
  access_spaces_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesVarSampOrderBy = {
  access_spaces_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseStopPlaceAccessSpacesVarianceFields = {
  __typename?: 'stops_database_stop_place_access_spaces_variance_fields';
  access_spaces_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesVarianceOrderBy = {
  access_spaces_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** columns and relationships of "stop_place_adjacent_sites" */
export type StopsDatabaseStopPlaceAdjacentSites = {
  __typename?: 'stops_database_stop_place_adjacent_sites';
  ref?: Maybe<Scalars['String']>;
  stop_place_id: Scalars['bigint'];
  version?: Maybe<Scalars['String']>;
};

/** aggregated selection of "stop_place_adjacent_sites" */
export type StopsDatabaseStopPlaceAdjacentSitesAggregate = {
  __typename?: 'stops_database_stop_place_adjacent_sites_aggregate';
  aggregate?: Maybe<StopsDatabaseStopPlaceAdjacentSitesAggregateFields>;
  nodes: Array<StopsDatabaseStopPlaceAdjacentSites>;
};

/** aggregate fields of "stop_place_adjacent_sites" */
export type StopsDatabaseStopPlaceAdjacentSitesAggregateFields = {
  __typename?: 'stops_database_stop_place_adjacent_sites_aggregate_fields';
  avg?: Maybe<StopsDatabaseStopPlaceAdjacentSitesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseStopPlaceAdjacentSitesMaxFields>;
  min?: Maybe<StopsDatabaseStopPlaceAdjacentSitesMinFields>;
  stddev?: Maybe<StopsDatabaseStopPlaceAdjacentSitesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseStopPlaceAdjacentSitesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseStopPlaceAdjacentSitesStddevSampFields>;
  sum?: Maybe<StopsDatabaseStopPlaceAdjacentSitesSumFields>;
  var_pop?: Maybe<StopsDatabaseStopPlaceAdjacentSitesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseStopPlaceAdjacentSitesVarSampFields>;
  variance?: Maybe<StopsDatabaseStopPlaceAdjacentSitesVarianceFields>;
};

/** aggregate fields of "stop_place_adjacent_sites" */
export type StopsDatabaseStopPlaceAdjacentSitesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseStopPlaceAdjacentSitesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseStopPlaceAdjacentSitesAvgFields = {
  __typename?: 'stops_database_stop_place_adjacent_sites_avg_fields';
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "stop_place_adjacent_sites". All fields are combined with a logical 'AND'. */
export type StopsDatabaseStopPlaceAdjacentSitesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseStopPlaceAdjacentSitesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseStopPlaceAdjacentSitesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseStopPlaceAdjacentSitesBoolExp>>;
  ref?: InputMaybe<StringComparisonExp>;
  stop_place_id?: InputMaybe<BigintComparisonExp>;
  version?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "stop_place_adjacent_sites" */
export type StopsDatabaseStopPlaceAdjacentSitesIncInput = {
  stop_place_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "stop_place_adjacent_sites" */
export type StopsDatabaseStopPlaceAdjacentSitesInsertInput = {
  ref?: InputMaybe<Scalars['String']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type StopsDatabaseStopPlaceAdjacentSitesMaxFields = {
  __typename?: 'stops_database_stop_place_adjacent_sites_max_fields';
  ref?: Maybe<Scalars['String']>;
  stop_place_id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseStopPlaceAdjacentSitesMinFields = {
  __typename?: 'stops_database_stop_place_adjacent_sites_min_fields';
  ref?: Maybe<Scalars['String']>;
  stop_place_id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "stop_place_adjacent_sites" */
export type StopsDatabaseStopPlaceAdjacentSitesMutationResponse = {
  __typename?: 'stops_database_stop_place_adjacent_sites_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseStopPlaceAdjacentSites>;
};

/** Ordering options when selecting data from "stop_place_adjacent_sites". */
export type StopsDatabaseStopPlaceAdjacentSitesOrderBy = {
  ref?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
};

/** select columns of table "stop_place_adjacent_sites" */
export enum StopsDatabaseStopPlaceAdjacentSitesSelectColumn {
  /** column name */
  Ref = 'ref',
  /** column name */
  StopPlaceId = 'stop_place_id',
  /** column name */
  Version = 'version',
}

/** input type for updating data in table "stop_place_adjacent_sites" */
export type StopsDatabaseStopPlaceAdjacentSitesSetInput = {
  ref?: InputMaybe<Scalars['String']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseStopPlaceAdjacentSitesStddevFields = {
  __typename?: 'stops_database_stop_place_adjacent_sites_stddev_fields';
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseStopPlaceAdjacentSitesStddevPopFields = {
  __typename?: 'stops_database_stop_place_adjacent_sites_stddev_pop_fields';
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseStopPlaceAdjacentSitesStddevSampFields = {
  __typename?: 'stops_database_stop_place_adjacent_sites_stddev_samp_fields';
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "stop_place_adjacent_sites" */
export type StopsDatabaseStopPlaceAdjacentSitesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseStopPlaceAdjacentSitesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseStopPlaceAdjacentSitesStreamCursorValueInput = {
  ref?: InputMaybe<Scalars['String']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseStopPlaceAdjacentSitesSumFields = {
  __typename?: 'stops_database_stop_place_adjacent_sites_sum_fields';
  stop_place_id?: Maybe<Scalars['bigint']>;
};

export type StopsDatabaseStopPlaceAdjacentSitesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseStopPlaceAdjacentSitesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseStopPlaceAdjacentSitesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseStopPlaceAdjacentSitesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseStopPlaceAdjacentSitesVarPopFields = {
  __typename?: 'stops_database_stop_place_adjacent_sites_var_pop_fields';
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseStopPlaceAdjacentSitesVarSampFields = {
  __typename?: 'stops_database_stop_place_adjacent_sites_var_samp_fields';
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseStopPlaceAdjacentSitesVarianceFields = {
  __typename?: 'stops_database_stop_place_adjacent_sites_variance_fields';
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** aggregated selection of "stop_place" */
export type StopsDatabaseStopPlaceAggregate = {
  __typename?: 'stops_database_stop_place_aggregate';
  aggregate?: Maybe<StopsDatabaseStopPlaceAggregateFields>;
  nodes: Array<StopsDatabaseStopPlace>;
};

/** aggregate fields of "stop_place" */
export type StopsDatabaseStopPlaceAggregateFields = {
  __typename?: 'stops_database_stop_place_aggregate_fields';
  avg?: Maybe<StopsDatabaseStopPlaceAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseStopPlaceMaxFields>;
  min?: Maybe<StopsDatabaseStopPlaceMinFields>;
  stddev?: Maybe<StopsDatabaseStopPlaceStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseStopPlaceStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseStopPlaceStddevSampFields>;
  sum?: Maybe<StopsDatabaseStopPlaceSumFields>;
  var_pop?: Maybe<StopsDatabaseStopPlaceVarPopFields>;
  var_samp?: Maybe<StopsDatabaseStopPlaceVarSampFields>;
  variance?: Maybe<StopsDatabaseStopPlaceVarianceFields>;
};

/** aggregate fields of "stop_place" */
export type StopsDatabaseStopPlaceAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseStopPlaceSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** columns and relationships of "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNames = {
  __typename?: 'stops_database_stop_place_alternative_names';
  /** An object relationship */
  alternative_name: StopsDatabaseAlternativeName;
  alternative_names_id: Scalars['bigint'];
  stop_place_id: Scalars['bigint'];
};

/** aggregated selection of "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesAggregate = {
  __typename?: 'stops_database_stop_place_alternative_names_aggregate';
  aggregate?: Maybe<StopsDatabaseStopPlaceAlternativeNamesAggregateFields>;
  nodes: Array<StopsDatabaseStopPlaceAlternativeNames>;
};

/** aggregate fields of "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesAggregateFields = {
  __typename?: 'stops_database_stop_place_alternative_names_aggregate_fields';
  avg?: Maybe<StopsDatabaseStopPlaceAlternativeNamesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseStopPlaceAlternativeNamesMaxFields>;
  min?: Maybe<StopsDatabaseStopPlaceAlternativeNamesMinFields>;
  stddev?: Maybe<StopsDatabaseStopPlaceAlternativeNamesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseStopPlaceAlternativeNamesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseStopPlaceAlternativeNamesStddevSampFields>;
  sum?: Maybe<StopsDatabaseStopPlaceAlternativeNamesSumFields>;
  var_pop?: Maybe<StopsDatabaseStopPlaceAlternativeNamesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseStopPlaceAlternativeNamesVarSampFields>;
  variance?: Maybe<StopsDatabaseStopPlaceAlternativeNamesVarianceFields>;
};

/** aggregate fields of "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesAggregateFieldsCountArgs = {
  columns?: InputMaybe<
    Array<StopsDatabaseStopPlaceAlternativeNamesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesArrRelInsertInput = {
  data: Array<StopsDatabaseStopPlaceAlternativeNamesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseStopPlaceAlternativeNamesAvgFields = {
  __typename?: 'stops_database_stop_place_alternative_names_avg_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesAvgOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "stop_place_alternative_names". All fields are combined with a logical 'AND'. */
export type StopsDatabaseStopPlaceAlternativeNamesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseStopPlaceAlternativeNamesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseStopPlaceAlternativeNamesBoolExp>>;
  alternative_name?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
  alternative_names_id?: InputMaybe<BigintComparisonExp>;
  stop_place_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "stop_place_alternative_names" */
export enum StopsDatabaseStopPlaceAlternativeNamesConstraint {
  /** unique or primary key constraint on columns "alternative_names_id" */
  Uk_2mabhvrur7dd4xuqf7be5tq6h = 'uk_2mabhvrur7dd4xuqf7be5tq6h',
}

/** input type for incrementing numeric columns in table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesIncInput = {
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesInsertInput = {
  alternative_name?: InputMaybe<StopsDatabaseAlternativeNameObjRelInsertInput>;
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseStopPlaceAlternativeNamesMaxFields = {
  __typename?: 'stops_database_stop_place_alternative_names_max_fields';
  alternative_names_id?: Maybe<Scalars['bigint']>;
  stop_place_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesMaxOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseStopPlaceAlternativeNamesMinFields = {
  __typename?: 'stops_database_stop_place_alternative_names_min_fields';
  alternative_names_id?: Maybe<Scalars['bigint']>;
  stop_place_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesMinOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesMutationResponse = {
  __typename?: 'stops_database_stop_place_alternative_names_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseStopPlaceAlternativeNames>;
};

/** on_conflict condition type for table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesOnConflict = {
  constraint: StopsDatabaseStopPlaceAlternativeNamesConstraint;
  update_columns?: Array<StopsDatabaseStopPlaceAlternativeNamesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesBoolExp>;
};

/** Ordering options when selecting data from "stop_place_alternative_names". */
export type StopsDatabaseStopPlaceAlternativeNamesOrderBy = {
  alternative_name?: InputMaybe<StopsDatabaseAlternativeNameOrderBy>;
  alternative_names_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** select columns of table "stop_place_alternative_names" */
export enum StopsDatabaseStopPlaceAlternativeNamesSelectColumn {
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
  /** column name */
  StopPlaceId = 'stop_place_id',
}

/** input type for updating data in table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesSetInput = {
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseStopPlaceAlternativeNamesStddevFields = {
  __typename?: 'stops_database_stop_place_alternative_names_stddev_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesStddevOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseStopPlaceAlternativeNamesStddevPopFields = {
  __typename?: 'stops_database_stop_place_alternative_names_stddev_pop_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesStddevPopOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseStopPlaceAlternativeNamesStddevSampFields = {
  __typename?: 'stops_database_stop_place_alternative_names_stddev_samp_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesStddevSampOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseStopPlaceAlternativeNamesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseStopPlaceAlternativeNamesStreamCursorValueInput = {
  alternative_names_id?: InputMaybe<Scalars['bigint']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseStopPlaceAlternativeNamesSumFields = {
  __typename?: 'stops_database_stop_place_alternative_names_sum_fields';
  alternative_names_id?: Maybe<Scalars['bigint']>;
  stop_place_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesSumOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** update columns of table "stop_place_alternative_names" */
export enum StopsDatabaseStopPlaceAlternativeNamesUpdateColumn {
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
  /** column name */
  StopPlaceId = 'stop_place_id',
}

export type StopsDatabaseStopPlaceAlternativeNamesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseStopPlaceAlternativeNamesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseStopPlaceAlternativeNamesVarPopFields = {
  __typename?: 'stops_database_stop_place_alternative_names_var_pop_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesVarPopOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseStopPlaceAlternativeNamesVarSampFields = {
  __typename?: 'stops_database_stop_place_alternative_names_var_samp_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesVarSampOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseStopPlaceAlternativeNamesVarianceFields = {
  __typename?: 'stops_database_stop_place_alternative_names_variance_fields';
  alternative_names_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesVarianceOrderBy = {
  alternative_names_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate avg on columns */
export type StopsDatabaseStopPlaceAvgFields = {
  __typename?: 'stops_database_stop_place_avg_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  topographic_place_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "stop_place". All fields are combined with a logical 'AND'. */
export type StopsDatabaseStopPlaceBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseStopPlaceBoolExp>>;
  _not?: InputMaybe<StopsDatabaseStopPlaceBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseStopPlaceBoolExp>>;
  accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentBoolExp>;
  accessibility_assessment_id?: InputMaybe<BigintComparisonExp>;
  air_submode?: InputMaybe<StringComparisonExp>;
  all_areas_wheelchair_accessible?: InputMaybe<BooleanComparisonExp>;
  border_crossing?: InputMaybe<BooleanComparisonExp>;
  bus_submode?: InputMaybe<StringComparisonExp>;
  centroid?: InputMaybe<GeometryComparisonExp>;
  changed?: InputMaybe<TimestampComparisonExp>;
  changed_by?: InputMaybe<StringComparisonExp>;
  coach_submode?: InputMaybe<StringComparisonExp>;
  covered?: InputMaybe<IntComparisonExp>;
  created?: InputMaybe<TimestampComparisonExp>;
  description_lang?: InputMaybe<StringComparisonExp>;
  description_value?: InputMaybe<StringComparisonExp>;
  from_date?: InputMaybe<TimestampComparisonExp>;
  funicular_submode?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
  metro_submode?: InputMaybe<StringComparisonExp>;
  modification_enumeration?: InputMaybe<StringComparisonExp>;
  name_lang?: InputMaybe<StringComparisonExp>;
  name_value?: InputMaybe<StringComparisonExp>;
  netex_id?: InputMaybe<StringComparisonExp>;
  parent_site_ref?: InputMaybe<StringComparisonExp>;
  parent_site_ref_version?: InputMaybe<StringComparisonExp>;
  parent_stop_place?: InputMaybe<BooleanComparisonExp>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  place_equipments_id?: InputMaybe<BigintComparisonExp>;
  polygon_id?: InputMaybe<BigintComparisonExp>;
  private_code_type?: InputMaybe<StringComparisonExp>;
  private_code_value?: InputMaybe<StringComparisonExp>;
  public_code?: InputMaybe<StringComparisonExp>;
  rail_submode?: InputMaybe<StringComparisonExp>;
  short_name_lang?: InputMaybe<StringComparisonExp>;
  short_name_value?: InputMaybe<StringComparisonExp>;
  stop_place_access_spaces?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesBoolExp>;
  stop_place_access_spaces_aggregate?: InputMaybe<StopPlaceAccessSpacesAggregateBoolExp>;
  stop_place_alternative_names?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesBoolExp>;
  stop_place_alternative_names_aggregate?: InputMaybe<StopPlaceAlternativeNamesAggregateBoolExp>;
  stop_place_child?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
  stop_place_children?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
  stop_place_children_aggregate?: InputMaybe<StopPlaceChildrenAggregateBoolExp>;
  stop_place_equipment_places?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>;
  stop_place_equipment_places_aggregate?: InputMaybe<StopPlaceEquipmentPlacesAggregateBoolExp>;
  stop_place_key_values?: InputMaybe<StopsDatabaseStopPlaceKeyValuesBoolExp>;
  stop_place_key_values_aggregate?: InputMaybe<StopPlaceKeyValuesAggregateBoolExp>;
  stop_place_quays?: InputMaybe<StopsDatabaseStopPlaceQuaysBoolExp>;
  stop_place_quays_aggregate?: InputMaybe<StopPlaceQuaysAggregateBoolExp>;
  stop_place_tariff_zones?: InputMaybe<StopsDatabaseStopPlaceTariffZonesBoolExp>;
  stop_place_tariff_zones_aggregate?: InputMaybe<StopPlaceTariffZonesAggregateBoolExp>;
  stop_place_type?: InputMaybe<StringComparisonExp>;
  telecabin_submode?: InputMaybe<StringComparisonExp>;
  to_date?: InputMaybe<TimestampComparisonExp>;
  topographic_place?: InputMaybe<StopsDatabaseTopographicPlaceBoolExp>;
  topographic_place_id?: InputMaybe<BigintComparisonExp>;
  tram_submode?: InputMaybe<StringComparisonExp>;
  transport_mode?: InputMaybe<StringComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
  version_comment?: InputMaybe<StringComparisonExp>;
  water_submode?: InputMaybe<StringComparisonExp>;
  weighting?: InputMaybe<StringComparisonExp>;
};

/** columns and relationships of "stop_place_children" */
export type StopsDatabaseStopPlaceChildren = {
  __typename?: 'stops_database_stop_place_children';
  children_id: Scalars['bigint'];
  /** An object relationship */
  stop_place: StopsDatabaseStopPlace;
  stop_place_id: Scalars['bigint'];
};

/** aggregated selection of "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenAggregate = {
  __typename?: 'stops_database_stop_place_children_aggregate';
  aggregate?: Maybe<StopsDatabaseStopPlaceChildrenAggregateFields>;
  nodes: Array<StopsDatabaseStopPlaceChildren>;
};

/** aggregate fields of "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenAggregateFields = {
  __typename?: 'stops_database_stop_place_children_aggregate_fields';
  avg?: Maybe<StopsDatabaseStopPlaceChildrenAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseStopPlaceChildrenMaxFields>;
  min?: Maybe<StopsDatabaseStopPlaceChildrenMinFields>;
  stddev?: Maybe<StopsDatabaseStopPlaceChildrenStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseStopPlaceChildrenStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseStopPlaceChildrenStddevSampFields>;
  sum?: Maybe<StopsDatabaseStopPlaceChildrenSumFields>;
  var_pop?: Maybe<StopsDatabaseStopPlaceChildrenVarPopFields>;
  var_samp?: Maybe<StopsDatabaseStopPlaceChildrenVarSampFields>;
  variance?: Maybe<StopsDatabaseStopPlaceChildrenVarianceFields>;
};

/** aggregate fields of "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseStopPlaceChildrenSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseStopPlaceChildrenAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseStopPlaceChildrenMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseStopPlaceChildrenMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseStopPlaceChildrenStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseStopPlaceChildrenStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseStopPlaceChildrenStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseStopPlaceChildrenSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseStopPlaceChildrenVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseStopPlaceChildrenVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseStopPlaceChildrenVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenArrRelInsertInput = {
  data: Array<StopsDatabaseStopPlaceChildrenInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseStopPlaceChildrenOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseStopPlaceChildrenAvgFields = {
  __typename?: 'stops_database_stop_place_children_avg_fields';
  children_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenAvgOrderBy = {
  children_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "stop_place_children". All fields are combined with a logical 'AND'. */
export type StopsDatabaseStopPlaceChildrenBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseStopPlaceChildrenBoolExp>>;
  _not?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseStopPlaceChildrenBoolExp>>;
  children_id?: InputMaybe<BigintComparisonExp>;
  stop_place?: InputMaybe<StopsDatabaseStopPlaceBoolExp>;
  stop_place_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "stop_place_children" */
export enum StopsDatabaseStopPlaceChildrenConstraint {
  /** unique or primary key constraint on columns "stop_place_id", "children_id" */
  StopPlaceChildrenPkey = 'stop_place_children_pkey',
  /** unique or primary key constraint on columns "children_id" */
  UkKj0a7ruk5k2bub2028nbkqwtw = 'uk_kj0a7ruk5k2bub2028nbkqwtw',
}

/** input type for incrementing numeric columns in table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenIncInput = {
  children_id?: InputMaybe<Scalars['bigint']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenInsertInput = {
  children_id?: InputMaybe<Scalars['bigint']>;
  stop_place?: InputMaybe<StopsDatabaseStopPlaceObjRelInsertInput>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseStopPlaceChildrenMaxFields = {
  __typename?: 'stops_database_stop_place_children_max_fields';
  children_id?: Maybe<Scalars['bigint']>;
  stop_place_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenMaxOrderBy = {
  children_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseStopPlaceChildrenMinFields = {
  __typename?: 'stops_database_stop_place_children_min_fields';
  children_id?: Maybe<Scalars['bigint']>;
  stop_place_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenMinOrderBy = {
  children_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenMutationResponse = {
  __typename?: 'stops_database_stop_place_children_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseStopPlaceChildren>;
};

/** input type for inserting object relation for remote table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenObjRelInsertInput = {
  data: StopsDatabaseStopPlaceChildrenInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseStopPlaceChildrenOnConflict>;
};

/** on_conflict condition type for table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenOnConflict = {
  constraint: StopsDatabaseStopPlaceChildrenConstraint;
  update_columns?: Array<StopsDatabaseStopPlaceChildrenUpdateColumn>;
  where?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
};

/** Ordering options when selecting data from "stop_place_children". */
export type StopsDatabaseStopPlaceChildrenOrderBy = {
  children_id?: InputMaybe<OrderBy>;
  stop_place?: InputMaybe<StopsDatabaseStopPlaceOrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: stop_place_children */
export type StopsDatabaseStopPlaceChildrenPkColumnsInput = {
  children_id: Scalars['bigint'];
  stop_place_id: Scalars['bigint'];
};

/** select columns of table "stop_place_children" */
export enum StopsDatabaseStopPlaceChildrenSelectColumn {
  /** column name */
  ChildrenId = 'children_id',
  /** column name */
  StopPlaceId = 'stop_place_id',
}

/** input type for updating data in table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenSetInput = {
  children_id?: InputMaybe<Scalars['bigint']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseStopPlaceChildrenStddevFields = {
  __typename?: 'stops_database_stop_place_children_stddev_fields';
  children_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenStddevOrderBy = {
  children_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseStopPlaceChildrenStddevPopFields = {
  __typename?: 'stops_database_stop_place_children_stddev_pop_fields';
  children_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenStddevPopOrderBy = {
  children_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseStopPlaceChildrenStddevSampFields = {
  __typename?: 'stops_database_stop_place_children_stddev_samp_fields';
  children_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenStddevSampOrderBy = {
  children_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseStopPlaceChildrenStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseStopPlaceChildrenStreamCursorValueInput = {
  children_id?: InputMaybe<Scalars['bigint']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseStopPlaceChildrenSumFields = {
  __typename?: 'stops_database_stop_place_children_sum_fields';
  children_id?: Maybe<Scalars['bigint']>;
  stop_place_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenSumOrderBy = {
  children_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** update columns of table "stop_place_children" */
export enum StopsDatabaseStopPlaceChildrenUpdateColumn {
  /** column name */
  ChildrenId = 'children_id',
  /** column name */
  StopPlaceId = 'stop_place_id',
}

export type StopsDatabaseStopPlaceChildrenUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseStopPlaceChildrenIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseStopPlaceChildrenSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseStopPlaceChildrenBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseStopPlaceChildrenVarPopFields = {
  __typename?: 'stops_database_stop_place_children_var_pop_fields';
  children_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenVarPopOrderBy = {
  children_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseStopPlaceChildrenVarSampFields = {
  __typename?: 'stops_database_stop_place_children_var_samp_fields';
  children_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenVarSampOrderBy = {
  children_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseStopPlaceChildrenVarianceFields = {
  __typename?: 'stops_database_stop_place_children_variance_fields';
  children_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenVarianceOrderBy = {
  children_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** unique or primary key constraints on table "stop_place" */
export enum StopsDatabaseStopPlaceConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  StopPlaceNetexIdVersionConstraint = 'stop_place_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  StopPlacePkey = 'stop_place_pkey',
}

/** columns and relationships of "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlaces = {
  __typename?: 'stops_database_stop_place_equipment_places';
  /** An object relationship */
  equipment_place: StopsDatabaseEquipmentPlace;
  equipment_places_id: Scalars['bigint'];
  stop_place_id: Scalars['bigint'];
};

/** aggregated selection of "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesAggregate = {
  __typename?: 'stops_database_stop_place_equipment_places_aggregate';
  aggregate?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesAggregateFields>;
  nodes: Array<StopsDatabaseStopPlaceEquipmentPlaces>;
};

/** aggregate fields of "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesAggregateFields = {
  __typename?: 'stops_database_stop_place_equipment_places_aggregate_fields';
  avg?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesMaxFields>;
  min?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesMinFields>;
  stddev?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesStddevSampFields>;
  sum?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesSumFields>;
  var_pop?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesVarSampFields>;
  variance?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesVarianceFields>;
};

/** aggregate fields of "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesAggregateFieldsCountArgs = {
  columns?: InputMaybe<
    Array<StopsDatabaseStopPlaceEquipmentPlacesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesArrRelInsertInput = {
  data: Array<StopsDatabaseStopPlaceEquipmentPlacesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseStopPlaceEquipmentPlacesAvgFields = {
  __typename?: 'stops_database_stop_place_equipment_places_avg_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesAvgOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "stop_place_equipment_places". All fields are combined with a logical 'AND'. */
export type StopsDatabaseStopPlaceEquipmentPlacesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>>;
  equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceBoolExp>;
  equipment_places_id?: InputMaybe<BigintComparisonExp>;
  stop_place_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "stop_place_equipment_places" */
export enum StopsDatabaseStopPlaceEquipmentPlacesConstraint {
  /** unique or primary key constraint on columns "equipment_places_id" */
  UkMnksrduwpe1bfxskob1pkbi28 = 'uk_mnksrduwpe1bfxskob1pkbi28',
}

/** input type for incrementing numeric columns in table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesIncInput = {
  equipment_places_id?: InputMaybe<Scalars['bigint']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesInsertInput = {
  equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceObjRelInsertInput>;
  equipment_places_id?: InputMaybe<Scalars['bigint']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseStopPlaceEquipmentPlacesMaxFields = {
  __typename?: 'stops_database_stop_place_equipment_places_max_fields';
  equipment_places_id?: Maybe<Scalars['bigint']>;
  stop_place_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesMaxOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseStopPlaceEquipmentPlacesMinFields = {
  __typename?: 'stops_database_stop_place_equipment_places_min_fields';
  equipment_places_id?: Maybe<Scalars['bigint']>;
  stop_place_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesMinOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesMutationResponse = {
  __typename?: 'stops_database_stop_place_equipment_places_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseStopPlaceEquipmentPlaces>;
};

/** on_conflict condition type for table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesOnConflict = {
  constraint: StopsDatabaseStopPlaceEquipmentPlacesConstraint;
  update_columns?: Array<StopsDatabaseStopPlaceEquipmentPlacesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>;
};

/** Ordering options when selecting data from "stop_place_equipment_places". */
export type StopsDatabaseStopPlaceEquipmentPlacesOrderBy = {
  equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceOrderBy>;
  equipment_places_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** select columns of table "stop_place_equipment_places" */
export enum StopsDatabaseStopPlaceEquipmentPlacesSelectColumn {
  /** column name */
  EquipmentPlacesId = 'equipment_places_id',
  /** column name */
  StopPlaceId = 'stop_place_id',
}

/** input type for updating data in table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesSetInput = {
  equipment_places_id?: InputMaybe<Scalars['bigint']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseStopPlaceEquipmentPlacesStddevFields = {
  __typename?: 'stops_database_stop_place_equipment_places_stddev_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesStddevOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseStopPlaceEquipmentPlacesStddevPopFields = {
  __typename?: 'stops_database_stop_place_equipment_places_stddev_pop_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesStddevPopOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseStopPlaceEquipmentPlacesStddevSampFields = {
  __typename?: 'stops_database_stop_place_equipment_places_stddev_samp_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesStddevSampOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseStopPlaceEquipmentPlacesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseStopPlaceEquipmentPlacesStreamCursorValueInput = {
  equipment_places_id?: InputMaybe<Scalars['bigint']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseStopPlaceEquipmentPlacesSumFields = {
  __typename?: 'stops_database_stop_place_equipment_places_sum_fields';
  equipment_places_id?: Maybe<Scalars['bigint']>;
  stop_place_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesSumOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** update columns of table "stop_place_equipment_places" */
export enum StopsDatabaseStopPlaceEquipmentPlacesUpdateColumn {
  /** column name */
  EquipmentPlacesId = 'equipment_places_id',
  /** column name */
  StopPlaceId = 'stop_place_id',
}

export type StopsDatabaseStopPlaceEquipmentPlacesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseStopPlaceEquipmentPlacesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseStopPlaceEquipmentPlacesVarPopFields = {
  __typename?: 'stops_database_stop_place_equipment_places_var_pop_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesVarPopOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseStopPlaceEquipmentPlacesVarSampFields = {
  __typename?: 'stops_database_stop_place_equipment_places_var_samp_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesVarSampOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseStopPlaceEquipmentPlacesVarianceFields = {
  __typename?: 'stops_database_stop_place_equipment_places_variance_fields';
  equipment_places_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesVarianceOrderBy = {
  equipment_places_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** input type for incrementing numeric columns in table "stop_place" */
export type StopsDatabaseStopPlaceIncInput = {
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  covered?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['bigint']>;
  place_equipments_id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  topographic_place_id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "stop_place" */
export type StopsDatabaseStopPlaceInsertInput = {
  accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentObjRelInsertInput>;
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  air_submode?: InputMaybe<Scalars['String']>;
  all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']>;
  border_crossing?: InputMaybe<Scalars['Boolean']>;
  bus_submode?: InputMaybe<Scalars['String']>;
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  coach_submode?: InputMaybe<Scalars['String']>;
  covered?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  funicular_submode?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['bigint']>;
  installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureObjRelInsertInput>;
  metro_submode?: InputMaybe<Scalars['String']>;
  modification_enumeration?: InputMaybe<Scalars['String']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  parent_site_ref?: InputMaybe<Scalars['String']>;
  parent_site_ref_version?: InputMaybe<Scalars['String']>;
  parent_stop_place?: InputMaybe<Scalars['Boolean']>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonObjRelInsertInput>;
  place_equipments_id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  public_code?: InputMaybe<Scalars['String']>;
  rail_submode?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  stop_place_access_spaces?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesArrRelInsertInput>;
  stop_place_alternative_names?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesArrRelInsertInput>;
  stop_place_child?: InputMaybe<StopsDatabaseStopPlaceChildrenObjRelInsertInput>;
  stop_place_children?: InputMaybe<StopsDatabaseStopPlaceChildrenArrRelInsertInput>;
  stop_place_equipment_places?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesArrRelInsertInput>;
  stop_place_key_values?: InputMaybe<StopsDatabaseStopPlaceKeyValuesArrRelInsertInput>;
  stop_place_quays?: InputMaybe<StopsDatabaseStopPlaceQuaysArrRelInsertInput>;
  stop_place_tariff_zones?: InputMaybe<StopsDatabaseStopPlaceTariffZonesArrRelInsertInput>;
  stop_place_type?: InputMaybe<Scalars['String']>;
  telecabin_submode?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  topographic_place?: InputMaybe<StopsDatabaseTopographicPlaceObjRelInsertInput>;
  topographic_place_id?: InputMaybe<Scalars['bigint']>;
  tram_submode?: InputMaybe<Scalars['String']>;
  transport_mode?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
  water_submode?: InputMaybe<Scalars['String']>;
  weighting?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValues = {
  __typename?: 'stops_database_stop_place_key_values';
  key_values_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
  stop_place_id: Scalars['bigint'];
  /** An object relationship */
  value: StopsDatabaseValue;
};

/** aggregated selection of "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesAggregate = {
  __typename?: 'stops_database_stop_place_key_values_aggregate';
  aggregate?: Maybe<StopsDatabaseStopPlaceKeyValuesAggregateFields>;
  nodes: Array<StopsDatabaseStopPlaceKeyValues>;
};

/** aggregate fields of "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesAggregateFields = {
  __typename?: 'stops_database_stop_place_key_values_aggregate_fields';
  avg?: Maybe<StopsDatabaseStopPlaceKeyValuesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseStopPlaceKeyValuesMaxFields>;
  min?: Maybe<StopsDatabaseStopPlaceKeyValuesMinFields>;
  stddev?: Maybe<StopsDatabaseStopPlaceKeyValuesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseStopPlaceKeyValuesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseStopPlaceKeyValuesStddevSampFields>;
  sum?: Maybe<StopsDatabaseStopPlaceKeyValuesSumFields>;
  var_pop?: Maybe<StopsDatabaseStopPlaceKeyValuesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseStopPlaceKeyValuesVarSampFields>;
  variance?: Maybe<StopsDatabaseStopPlaceKeyValuesVarianceFields>;
};

/** aggregate fields of "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseStopPlaceKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseStopPlaceKeyValuesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseStopPlaceKeyValuesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseStopPlaceKeyValuesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseStopPlaceKeyValuesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseStopPlaceKeyValuesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseStopPlaceKeyValuesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseStopPlaceKeyValuesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseStopPlaceKeyValuesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseStopPlaceKeyValuesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseStopPlaceKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesArrRelInsertInput = {
  data: Array<StopsDatabaseStopPlaceKeyValuesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseStopPlaceKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseStopPlaceKeyValuesAvgFields = {
  __typename?: 'stops_database_stop_place_key_values_avg_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesAvgOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "stop_place_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseStopPlaceKeyValuesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseStopPlaceKeyValuesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseStopPlaceKeyValuesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseStopPlaceKeyValuesBoolExp>>;
  key_values_id?: InputMaybe<BigintComparisonExp>;
  key_values_key?: InputMaybe<StringComparisonExp>;
  stop_place_id?: InputMaybe<BigintComparisonExp>;
  value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "stop_place_key_values" */
export enum StopsDatabaseStopPlaceKeyValuesConstraint {
  /** unique or primary key constraint on columns "stop_place_id", "key_values_key" */
  StopPlaceKeyValuesPkey = 'stop_place_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  Uk_54aj7c8yuc5751x4c7qly6e5t = 'uk_54aj7c8yuc5751x4c7qly6e5t',
}

/** input type for incrementing numeric columns in table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesIncInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesInsertInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
  value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseStopPlaceKeyValuesMaxFields = {
  __typename?: 'stops_database_stop_place_key_values_max_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
  stop_place_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesMaxOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseStopPlaceKeyValuesMinFields = {
  __typename?: 'stops_database_stop_place_key_values_min_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
  stop_place_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesMinOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesMutationResponse = {
  __typename?: 'stops_database_stop_place_key_values_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseStopPlaceKeyValues>;
};

/** on_conflict condition type for table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesOnConflict = {
  constraint: StopsDatabaseStopPlaceKeyValuesConstraint;
  update_columns?: Array<StopsDatabaseStopPlaceKeyValuesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseStopPlaceKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "stop_place_key_values". */
export type StopsDatabaseStopPlaceKeyValuesOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
  value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: stop_place_key_values */
export type StopsDatabaseStopPlaceKeyValuesPkColumnsInput = {
  key_values_key: Scalars['String'];
  stop_place_id: Scalars['bigint'];
};

/** select columns of table "stop_place_key_values" */
export enum StopsDatabaseStopPlaceKeyValuesSelectColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  StopPlaceId = 'stop_place_id',
}

/** input type for updating data in table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesSetInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseStopPlaceKeyValuesStddevFields = {
  __typename?: 'stops_database_stop_place_key_values_stddev_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesStddevOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseStopPlaceKeyValuesStddevPopFields = {
  __typename?: 'stops_database_stop_place_key_values_stddev_pop_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesStddevPopOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseStopPlaceKeyValuesStddevSampFields = {
  __typename?: 'stops_database_stop_place_key_values_stddev_samp_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesStddevSampOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseStopPlaceKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseStopPlaceKeyValuesStreamCursorValueInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseStopPlaceKeyValuesSumFields = {
  __typename?: 'stops_database_stop_place_key_values_sum_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  stop_place_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesSumOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** update columns of table "stop_place_key_values" */
export enum StopsDatabaseStopPlaceKeyValuesUpdateColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  StopPlaceId = 'stop_place_id',
}

export type StopsDatabaseStopPlaceKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseStopPlaceKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseStopPlaceKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseStopPlaceKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseStopPlaceKeyValuesVarPopFields = {
  __typename?: 'stops_database_stop_place_key_values_var_pop_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesVarPopOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseStopPlaceKeyValuesVarSampFields = {
  __typename?: 'stops_database_stop_place_key_values_var_samp_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesVarSampOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseStopPlaceKeyValuesVarianceFields = {
  __typename?: 'stops_database_stop_place_key_values_variance_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesVarianceOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseStopPlaceMaxFields = {
  __typename?: 'stops_database_stop_place_max_fields';
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  air_submode?: Maybe<Scalars['String']>;
  bus_submode?: Maybe<Scalars['String']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  coach_submode?: Maybe<Scalars['String']>;
  covered?: Maybe<Scalars['Int']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  funicular_submode?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  metro_submode?: Maybe<Scalars['String']>;
  modification_enumeration?: Maybe<Scalars['String']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  parent_site_ref?: Maybe<Scalars['String']>;
  parent_site_ref_version?: Maybe<Scalars['String']>;
  place_equipments_id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  public_code?: Maybe<Scalars['String']>;
  rail_submode?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  stop_place_type?: Maybe<Scalars['String']>;
  telecabin_submode?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  topographic_place_id?: Maybe<Scalars['bigint']>;
  tram_submode?: Maybe<Scalars['String']>;
  transport_mode?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
  water_submode?: Maybe<Scalars['String']>;
  weighting?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseStopPlaceMinFields = {
  __typename?: 'stops_database_stop_place_min_fields';
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  air_submode?: Maybe<Scalars['String']>;
  bus_submode?: Maybe<Scalars['String']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  coach_submode?: Maybe<Scalars['String']>;
  covered?: Maybe<Scalars['Int']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  funicular_submode?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  metro_submode?: Maybe<Scalars['String']>;
  modification_enumeration?: Maybe<Scalars['String']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  parent_site_ref?: Maybe<Scalars['String']>;
  parent_site_ref_version?: Maybe<Scalars['String']>;
  place_equipments_id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  public_code?: Maybe<Scalars['String']>;
  rail_submode?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  stop_place_type?: Maybe<Scalars['String']>;
  telecabin_submode?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  topographic_place_id?: Maybe<Scalars['bigint']>;
  tram_submode?: Maybe<Scalars['String']>;
  transport_mode?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
  water_submode?: Maybe<Scalars['String']>;
  weighting?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "stop_place" */
export type StopsDatabaseStopPlaceMutationResponse = {
  __typename?: 'stops_database_stop_place_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseStopPlace>;
};

/** input type for inserting object relation for remote table "stop_place" */
export type StopsDatabaseStopPlaceObjRelInsertInput = {
  data: StopsDatabaseStopPlaceInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseStopPlaceOnConflict>;
};

/** on_conflict condition type for table "stop_place" */
export type StopsDatabaseStopPlaceOnConflict = {
  constraint: StopsDatabaseStopPlaceConstraint;
  update_columns?: Array<StopsDatabaseStopPlaceUpdateColumn>;
  where?: InputMaybe<StopsDatabaseStopPlaceBoolExp>;
};

/** Ordering options when selecting data from "stop_place". */
export type StopsDatabaseStopPlaceOrderBy = {
  accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentOrderBy>;
  accessibility_assessment_id?: InputMaybe<OrderBy>;
  air_submode?: InputMaybe<OrderBy>;
  all_areas_wheelchair_accessible?: InputMaybe<OrderBy>;
  border_crossing?: InputMaybe<OrderBy>;
  bus_submode?: InputMaybe<OrderBy>;
  centroid?: InputMaybe<OrderBy>;
  changed?: InputMaybe<OrderBy>;
  changed_by?: InputMaybe<OrderBy>;
  coach_submode?: InputMaybe<OrderBy>;
  covered?: InputMaybe<OrderBy>;
  created?: InputMaybe<OrderBy>;
  description_lang?: InputMaybe<OrderBy>;
  description_value?: InputMaybe<OrderBy>;
  from_date?: InputMaybe<OrderBy>;
  funicular_submode?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureOrderBy>;
  metro_submode?: InputMaybe<OrderBy>;
  modification_enumeration?: InputMaybe<OrderBy>;
  name_lang?: InputMaybe<OrderBy>;
  name_value?: InputMaybe<OrderBy>;
  netex_id?: InputMaybe<OrderBy>;
  parent_site_ref?: InputMaybe<OrderBy>;
  parent_site_ref_version?: InputMaybe<OrderBy>;
  parent_stop_place?: InputMaybe<OrderBy>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonOrderBy>;
  place_equipments_id?: InputMaybe<OrderBy>;
  polygon_id?: InputMaybe<OrderBy>;
  private_code_type?: InputMaybe<OrderBy>;
  private_code_value?: InputMaybe<OrderBy>;
  public_code?: InputMaybe<OrderBy>;
  rail_submode?: InputMaybe<OrderBy>;
  short_name_lang?: InputMaybe<OrderBy>;
  short_name_value?: InputMaybe<OrderBy>;
  stop_place_access_spaces_aggregate?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesAggregateOrderBy>;
  stop_place_alternative_names_aggregate?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesAggregateOrderBy>;
  stop_place_child?: InputMaybe<StopsDatabaseStopPlaceChildrenOrderBy>;
  stop_place_children_aggregate?: InputMaybe<StopsDatabaseStopPlaceChildrenAggregateOrderBy>;
  stop_place_equipment_places_aggregate?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesAggregateOrderBy>;
  stop_place_key_values_aggregate?: InputMaybe<StopsDatabaseStopPlaceKeyValuesAggregateOrderBy>;
  stop_place_quays_aggregate?: InputMaybe<StopsDatabaseStopPlaceQuaysAggregateOrderBy>;
  stop_place_tariff_zones_aggregate?: InputMaybe<StopsDatabaseStopPlaceTariffZonesAggregateOrderBy>;
  stop_place_type?: InputMaybe<OrderBy>;
  telecabin_submode?: InputMaybe<OrderBy>;
  to_date?: InputMaybe<OrderBy>;
  topographic_place?: InputMaybe<StopsDatabaseTopographicPlaceOrderBy>;
  topographic_place_id?: InputMaybe<OrderBy>;
  tram_submode?: InputMaybe<OrderBy>;
  transport_mode?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
  version_comment?: InputMaybe<OrderBy>;
  water_submode?: InputMaybe<OrderBy>;
  weighting?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: stop_place */
export type StopsDatabaseStopPlacePkColumnsInput = {
  id: Scalars['bigint'];
};

/** columns and relationships of "stop_place_quays" */
export type StopsDatabaseStopPlaceQuays = {
  __typename?: 'stops_database_stop_place_quays';
  /** An object relationship */
  quay: StopsDatabaseQuay;
  quays_id: Scalars['bigint'];
  stop_place_id: Scalars['bigint'];
};

/** aggregated selection of "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysAggregate = {
  __typename?: 'stops_database_stop_place_quays_aggregate';
  aggregate?: Maybe<StopsDatabaseStopPlaceQuaysAggregateFields>;
  nodes: Array<StopsDatabaseStopPlaceQuays>;
};

/** aggregate fields of "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysAggregateFields = {
  __typename?: 'stops_database_stop_place_quays_aggregate_fields';
  avg?: Maybe<StopsDatabaseStopPlaceQuaysAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseStopPlaceQuaysMaxFields>;
  min?: Maybe<StopsDatabaseStopPlaceQuaysMinFields>;
  stddev?: Maybe<StopsDatabaseStopPlaceQuaysStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseStopPlaceQuaysStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseStopPlaceQuaysStddevSampFields>;
  sum?: Maybe<StopsDatabaseStopPlaceQuaysSumFields>;
  var_pop?: Maybe<StopsDatabaseStopPlaceQuaysVarPopFields>;
  var_samp?: Maybe<StopsDatabaseStopPlaceQuaysVarSampFields>;
  variance?: Maybe<StopsDatabaseStopPlaceQuaysVarianceFields>;
};

/** aggregate fields of "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseStopPlaceQuaysSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseStopPlaceQuaysAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseStopPlaceQuaysMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseStopPlaceQuaysMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseStopPlaceQuaysStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseStopPlaceQuaysStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseStopPlaceQuaysStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseStopPlaceQuaysSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseStopPlaceQuaysVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseStopPlaceQuaysVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseStopPlaceQuaysVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysArrRelInsertInput = {
  data: Array<StopsDatabaseStopPlaceQuaysInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseStopPlaceQuaysOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseStopPlaceQuaysAvgFields = {
  __typename?: 'stops_database_stop_place_quays_avg_fields';
  quays_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysAvgOrderBy = {
  quays_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "stop_place_quays". All fields are combined with a logical 'AND'. */
export type StopsDatabaseStopPlaceQuaysBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseStopPlaceQuaysBoolExp>>;
  _not?: InputMaybe<StopsDatabaseStopPlaceQuaysBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseStopPlaceQuaysBoolExp>>;
  quay?: InputMaybe<StopsDatabaseQuayBoolExp>;
  quays_id?: InputMaybe<BigintComparisonExp>;
  stop_place_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "stop_place_quays" */
export enum StopsDatabaseStopPlaceQuaysConstraint {
  /** unique or primary key constraint on columns "stop_place_id", "quays_id" */
  StopPlaceQuaysPkey = 'stop_place_quays_pkey',
  /** unique or primary key constraint on columns "quays_id" */
  UkF684i92mysvn6hqigs0j3m2nr = 'uk_f684i92mysvn6hqigs0j3m2nr',
}

/** input type for incrementing numeric columns in table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysIncInput = {
  quays_id?: InputMaybe<Scalars['bigint']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysInsertInput = {
  quay?: InputMaybe<StopsDatabaseQuayObjRelInsertInput>;
  quays_id?: InputMaybe<Scalars['bigint']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseStopPlaceQuaysMaxFields = {
  __typename?: 'stops_database_stop_place_quays_max_fields';
  quays_id?: Maybe<Scalars['bigint']>;
  stop_place_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysMaxOrderBy = {
  quays_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseStopPlaceQuaysMinFields = {
  __typename?: 'stops_database_stop_place_quays_min_fields';
  quays_id?: Maybe<Scalars['bigint']>;
  stop_place_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysMinOrderBy = {
  quays_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysMutationResponse = {
  __typename?: 'stops_database_stop_place_quays_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseStopPlaceQuays>;
};

/** on_conflict condition type for table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysOnConflict = {
  constraint: StopsDatabaseStopPlaceQuaysConstraint;
  update_columns?: Array<StopsDatabaseStopPlaceQuaysUpdateColumn>;
  where?: InputMaybe<StopsDatabaseStopPlaceQuaysBoolExp>;
};

/** Ordering options when selecting data from "stop_place_quays". */
export type StopsDatabaseStopPlaceQuaysOrderBy = {
  quay?: InputMaybe<StopsDatabaseQuayOrderBy>;
  quays_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: stop_place_quays */
export type StopsDatabaseStopPlaceQuaysPkColumnsInput = {
  quays_id: Scalars['bigint'];
  stop_place_id: Scalars['bigint'];
};

/** select columns of table "stop_place_quays" */
export enum StopsDatabaseStopPlaceQuaysSelectColumn {
  /** column name */
  QuaysId = 'quays_id',
  /** column name */
  StopPlaceId = 'stop_place_id',
}

/** input type for updating data in table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysSetInput = {
  quays_id?: InputMaybe<Scalars['bigint']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseStopPlaceQuaysStddevFields = {
  __typename?: 'stops_database_stop_place_quays_stddev_fields';
  quays_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysStddevOrderBy = {
  quays_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseStopPlaceQuaysStddevPopFields = {
  __typename?: 'stops_database_stop_place_quays_stddev_pop_fields';
  quays_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysStddevPopOrderBy = {
  quays_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseStopPlaceQuaysStddevSampFields = {
  __typename?: 'stops_database_stop_place_quays_stddev_samp_fields';
  quays_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysStddevSampOrderBy = {
  quays_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseStopPlaceQuaysStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseStopPlaceQuaysStreamCursorValueInput = {
  quays_id?: InputMaybe<Scalars['bigint']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseStopPlaceQuaysSumFields = {
  __typename?: 'stops_database_stop_place_quays_sum_fields';
  quays_id?: Maybe<Scalars['bigint']>;
  stop_place_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysSumOrderBy = {
  quays_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** update columns of table "stop_place_quays" */
export enum StopsDatabaseStopPlaceQuaysUpdateColumn {
  /** column name */
  QuaysId = 'quays_id',
  /** column name */
  StopPlaceId = 'stop_place_id',
}

export type StopsDatabaseStopPlaceQuaysUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseStopPlaceQuaysIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseStopPlaceQuaysSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseStopPlaceQuaysBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseStopPlaceQuaysVarPopFields = {
  __typename?: 'stops_database_stop_place_quays_var_pop_fields';
  quays_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysVarPopOrderBy = {
  quays_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseStopPlaceQuaysVarSampFields = {
  __typename?: 'stops_database_stop_place_quays_var_samp_fields';
  quays_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysVarSampOrderBy = {
  quays_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseStopPlaceQuaysVarianceFields = {
  __typename?: 'stops_database_stop_place_quays_variance_fields';
  quays_id?: Maybe<Scalars['Float']>;
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysVarianceOrderBy = {
  quays_id?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
};

/** select columns of table "stop_place" */
export enum StopsDatabaseStopPlaceSelectColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AirSubmode = 'air_submode',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  BorderCrossing = 'border_crossing',
  /** column name */
  BusSubmode = 'bus_submode',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  CoachSubmode = 'coach_submode',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  FunicularSubmode = 'funicular_submode',
  /** column name */
  Id = 'id',
  /** column name */
  MetroSubmode = 'metro_submode',
  /** column name */
  ModificationEnumeration = 'modification_enumeration',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ParentSiteRef = 'parent_site_ref',
  /** column name */
  ParentSiteRefVersion = 'parent_site_ref_version',
  /** column name */
  ParentStopPlace = 'parent_stop_place',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  PublicCode = 'public_code',
  /** column name */
  RailSubmode = 'rail_submode',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  StopPlaceType = 'stop_place_type',
  /** column name */
  TelecabinSubmode = 'telecabin_submode',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TopographicPlaceId = 'topographic_place_id',
  /** column name */
  TramSubmode = 'tram_submode',
  /** column name */
  TransportMode = 'transport_mode',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  WaterSubmode = 'water_submode',
  /** column name */
  Weighting = 'weighting',
}

/** input type for updating data in table "stop_place" */
export type StopsDatabaseStopPlaceSetInput = {
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  air_submode?: InputMaybe<Scalars['String']>;
  all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']>;
  border_crossing?: InputMaybe<Scalars['Boolean']>;
  bus_submode?: InputMaybe<Scalars['String']>;
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  coach_submode?: InputMaybe<Scalars['String']>;
  covered?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  funicular_submode?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['bigint']>;
  metro_submode?: InputMaybe<Scalars['String']>;
  modification_enumeration?: InputMaybe<Scalars['String']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  parent_site_ref?: InputMaybe<Scalars['String']>;
  parent_site_ref_version?: InputMaybe<Scalars['String']>;
  parent_stop_place?: InputMaybe<Scalars['Boolean']>;
  place_equipments_id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  public_code?: InputMaybe<Scalars['String']>;
  rail_submode?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  stop_place_type?: InputMaybe<Scalars['String']>;
  telecabin_submode?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  topographic_place_id?: InputMaybe<Scalars['bigint']>;
  tram_submode?: InputMaybe<Scalars['String']>;
  transport_mode?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
  water_submode?: InputMaybe<Scalars['String']>;
  weighting?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseStopPlaceStddevFields = {
  __typename?: 'stops_database_stop_place_stddev_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  topographic_place_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseStopPlaceStddevPopFields = {
  __typename?: 'stops_database_stop_place_stddev_pop_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  topographic_place_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseStopPlaceStddevSampFields = {
  __typename?: 'stops_database_stop_place_stddev_samp_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  topographic_place_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "stop_place" */
export type StopsDatabaseStopPlaceStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseStopPlaceStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseStopPlaceStreamCursorValueInput = {
  accessibility_assessment_id?: InputMaybe<Scalars['bigint']>;
  air_submode?: InputMaybe<Scalars['String']>;
  all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']>;
  border_crossing?: InputMaybe<Scalars['Boolean']>;
  bus_submode?: InputMaybe<Scalars['String']>;
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  coach_submode?: InputMaybe<Scalars['String']>;
  covered?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  funicular_submode?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['bigint']>;
  metro_submode?: InputMaybe<Scalars['String']>;
  modification_enumeration?: InputMaybe<Scalars['String']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  parent_site_ref?: InputMaybe<Scalars['String']>;
  parent_site_ref_version?: InputMaybe<Scalars['String']>;
  parent_stop_place?: InputMaybe<Scalars['Boolean']>;
  place_equipments_id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  public_code?: InputMaybe<Scalars['String']>;
  rail_submode?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  stop_place_type?: InputMaybe<Scalars['String']>;
  telecabin_submode?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  topographic_place_id?: InputMaybe<Scalars['bigint']>;
  tram_submode?: InputMaybe<Scalars['String']>;
  transport_mode?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
  water_submode?: InputMaybe<Scalars['String']>;
  weighting?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseStopPlaceSumFields = {
  __typename?: 'stops_database_stop_place_sum_fields';
  accessibility_assessment_id?: Maybe<Scalars['bigint']>;
  covered?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['bigint']>;
  place_equipments_id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  topographic_place_id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['bigint']>;
};

/** columns and relationships of "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZones = {
  __typename?: 'stops_database_stop_place_tariff_zones';
  ref?: Maybe<Scalars['String']>;
  stop_place_id: Scalars['bigint'];
  version?: Maybe<Scalars['String']>;
};

/** aggregated selection of "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesAggregate = {
  __typename?: 'stops_database_stop_place_tariff_zones_aggregate';
  aggregate?: Maybe<StopsDatabaseStopPlaceTariffZonesAggregateFields>;
  nodes: Array<StopsDatabaseStopPlaceTariffZones>;
};

/** aggregate fields of "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesAggregateFields = {
  __typename?: 'stops_database_stop_place_tariff_zones_aggregate_fields';
  avg?: Maybe<StopsDatabaseStopPlaceTariffZonesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseStopPlaceTariffZonesMaxFields>;
  min?: Maybe<StopsDatabaseStopPlaceTariffZonesMinFields>;
  stddev?: Maybe<StopsDatabaseStopPlaceTariffZonesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseStopPlaceTariffZonesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseStopPlaceTariffZonesStddevSampFields>;
  sum?: Maybe<StopsDatabaseStopPlaceTariffZonesSumFields>;
  var_pop?: Maybe<StopsDatabaseStopPlaceTariffZonesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseStopPlaceTariffZonesVarSampFields>;
  variance?: Maybe<StopsDatabaseStopPlaceTariffZonesVarianceFields>;
};

/** aggregate fields of "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseStopPlaceTariffZonesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseStopPlaceTariffZonesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseStopPlaceTariffZonesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseStopPlaceTariffZonesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseStopPlaceTariffZonesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseStopPlaceTariffZonesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseStopPlaceTariffZonesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseStopPlaceTariffZonesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseStopPlaceTariffZonesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseStopPlaceTariffZonesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseStopPlaceTariffZonesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesArrRelInsertInput = {
  data: Array<StopsDatabaseStopPlaceTariffZonesInsertInput>;
};

/** aggregate avg on columns */
export type StopsDatabaseStopPlaceTariffZonesAvgFields = {
  __typename?: 'stops_database_stop_place_tariff_zones_avg_fields';
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesAvgOrderBy = {
  stop_place_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "stop_place_tariff_zones". All fields are combined with a logical 'AND'. */
export type StopsDatabaseStopPlaceTariffZonesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseStopPlaceTariffZonesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseStopPlaceTariffZonesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseStopPlaceTariffZonesBoolExp>>;
  ref?: InputMaybe<StringComparisonExp>;
  stop_place_id?: InputMaybe<BigintComparisonExp>;
  version?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesIncInput = {
  stop_place_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesInsertInput = {
  ref?: InputMaybe<Scalars['String']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type StopsDatabaseStopPlaceTariffZonesMaxFields = {
  __typename?: 'stops_database_stop_place_tariff_zones_max_fields';
  ref?: Maybe<Scalars['String']>;
  stop_place_id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesMaxOrderBy = {
  ref?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseStopPlaceTariffZonesMinFields = {
  __typename?: 'stops_database_stop_place_tariff_zones_min_fields';
  ref?: Maybe<Scalars['String']>;
  stop_place_id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesMinOrderBy = {
  ref?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesMutationResponse = {
  __typename?: 'stops_database_stop_place_tariff_zones_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseStopPlaceTariffZones>;
};

/** Ordering options when selecting data from "stop_place_tariff_zones". */
export type StopsDatabaseStopPlaceTariffZonesOrderBy = {
  ref?: InputMaybe<OrderBy>;
  stop_place_id?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
};

/** select columns of table "stop_place_tariff_zones" */
export enum StopsDatabaseStopPlaceTariffZonesSelectColumn {
  /** column name */
  Ref = 'ref',
  /** column name */
  StopPlaceId = 'stop_place_id',
  /** column name */
  Version = 'version',
}

/** input type for updating data in table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesSetInput = {
  ref?: InputMaybe<Scalars['String']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseStopPlaceTariffZonesStddevFields = {
  __typename?: 'stops_database_stop_place_tariff_zones_stddev_fields';
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesStddevOrderBy = {
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseStopPlaceTariffZonesStddevPopFields = {
  __typename?: 'stops_database_stop_place_tariff_zones_stddev_pop_fields';
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesStddevPopOrderBy = {
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseStopPlaceTariffZonesStddevSampFields = {
  __typename?: 'stops_database_stop_place_tariff_zones_stddev_samp_fields';
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesStddevSampOrderBy = {
  stop_place_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseStopPlaceTariffZonesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseStopPlaceTariffZonesStreamCursorValueInput = {
  ref?: InputMaybe<Scalars['String']>;
  stop_place_id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseStopPlaceTariffZonesSumFields = {
  __typename?: 'stops_database_stop_place_tariff_zones_sum_fields';
  stop_place_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesSumOrderBy = {
  stop_place_id?: InputMaybe<OrderBy>;
};

export type StopsDatabaseStopPlaceTariffZonesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseStopPlaceTariffZonesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseStopPlaceTariffZonesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseStopPlaceTariffZonesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseStopPlaceTariffZonesVarPopFields = {
  __typename?: 'stops_database_stop_place_tariff_zones_var_pop_fields';
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesVarPopOrderBy = {
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseStopPlaceTariffZonesVarSampFields = {
  __typename?: 'stops_database_stop_place_tariff_zones_var_samp_fields';
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesVarSampOrderBy = {
  stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseStopPlaceTariffZonesVarianceFields = {
  __typename?: 'stops_database_stop_place_tariff_zones_variance_fields';
  stop_place_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesVarianceOrderBy = {
  stop_place_id?: InputMaybe<OrderBy>;
};

/** update columns of table "stop_place" */
export enum StopsDatabaseStopPlaceUpdateColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AirSubmode = 'air_submode',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  BorderCrossing = 'border_crossing',
  /** column name */
  BusSubmode = 'bus_submode',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  CoachSubmode = 'coach_submode',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  FunicularSubmode = 'funicular_submode',
  /** column name */
  Id = 'id',
  /** column name */
  MetroSubmode = 'metro_submode',
  /** column name */
  ModificationEnumeration = 'modification_enumeration',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ParentSiteRef = 'parent_site_ref',
  /** column name */
  ParentSiteRefVersion = 'parent_site_ref_version',
  /** column name */
  ParentStopPlace = 'parent_stop_place',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  PublicCode = 'public_code',
  /** column name */
  RailSubmode = 'rail_submode',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  StopPlaceType = 'stop_place_type',
  /** column name */
  TelecabinSubmode = 'telecabin_submode',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TopographicPlaceId = 'topographic_place_id',
  /** column name */
  TramSubmode = 'tram_submode',
  /** column name */
  TransportMode = 'transport_mode',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  WaterSubmode = 'water_submode',
  /** column name */
  Weighting = 'weighting',
}

export type StopsDatabaseStopPlaceUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseStopPlaceIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseStopPlaceSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseStopPlaceBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseStopPlaceVarPopFields = {
  __typename?: 'stops_database_stop_place_var_pop_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  topographic_place_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseStopPlaceVarSampFields = {
  __typename?: 'stops_database_stop_place_var_samp_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  topographic_place_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseStopPlaceVarianceFields = {
  __typename?: 'stops_database_stop_place_variance_fields';
  accessibility_assessment_id?: Maybe<Scalars['Float']>;
  covered?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  place_equipments_id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  topographic_place_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

export type StopsDatabaseStopsDatabaseMutationFrontend = {
  __typename?: 'stops_database_stops_database_mutation_frontend';
  /** delete data from the table: "access_space" */
  stops_database_delete_access_space?: Maybe<StopsDatabaseAccessSpaceMutationResponse>;
  /** delete data from the table: "access_space_alternative_names" */
  stops_database_delete_access_space_alternative_names?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesMutationResponse>;
  /** delete single row from the table: "access_space" */
  stops_database_delete_access_space_by_pk?: Maybe<StopsDatabaseAccessSpace>;
  /** delete data from the table: "access_space_check_constraints" */
  stops_database_delete_access_space_check_constraints?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsMutationResponse>;
  /** delete data from the table: "access_space_equipment_places" */
  stops_database_delete_access_space_equipment_places?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesMutationResponse>;
  /** delete data from the table: "access_space_key_values" */
  stops_database_delete_access_space_key_values?: Maybe<StopsDatabaseAccessSpaceKeyValuesMutationResponse>;
  /** delete single row from the table: "access_space_key_values" */
  stops_database_delete_access_space_key_values_by_pk?: Maybe<StopsDatabaseAccessSpaceKeyValues>;
  /** delete data from the table: "accessibility_assessment" */
  stops_database_delete_accessibility_assessment?: Maybe<StopsDatabaseAccessibilityAssessmentMutationResponse>;
  /** delete single row from the table: "accessibility_assessment" */
  stops_database_delete_accessibility_assessment_by_pk?: Maybe<StopsDatabaseAccessibilityAssessment>;
  /** delete data from the table: "accessibility_assessment_limitations" */
  stops_database_delete_accessibility_assessment_limitations?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsMutationResponse>;
  /** delete data from the table: "accessibility_limitation" */
  stops_database_delete_accessibility_limitation?: Maybe<StopsDatabaseAccessibilityLimitationMutationResponse>;
  /** delete single row from the table: "accessibility_limitation" */
  stops_database_delete_accessibility_limitation_by_pk?: Maybe<StopsDatabaseAccessibilityLimitation>;
  /** delete data from the table: "alternative_name" */
  stops_database_delete_alternative_name?: Maybe<StopsDatabaseAlternativeNameMutationResponse>;
  /** delete single row from the table: "alternative_name" */
  stops_database_delete_alternative_name_by_pk?: Maybe<StopsDatabaseAlternativeName>;
  /** delete data from the table: "boarding_position" */
  stops_database_delete_boarding_position?: Maybe<StopsDatabaseBoardingPositionMutationResponse>;
  /** delete data from the table: "boarding_position_alternative_names" */
  stops_database_delete_boarding_position_alternative_names?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesMutationResponse>;
  /** delete single row from the table: "boarding_position" */
  stops_database_delete_boarding_position_by_pk?: Maybe<StopsDatabaseBoardingPosition>;
  /** delete data from the table: "boarding_position_check_constraints" */
  stops_database_delete_boarding_position_check_constraints?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsMutationResponse>;
  /** delete data from the table: "boarding_position_equipment_places" */
  stops_database_delete_boarding_position_equipment_places?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesMutationResponse>;
  /** delete data from the table: "boarding_position_key_values" */
  stops_database_delete_boarding_position_key_values?: Maybe<StopsDatabaseBoardingPositionKeyValuesMutationResponse>;
  /** delete single row from the table: "boarding_position_key_values" */
  stops_database_delete_boarding_position_key_values_by_pk?: Maybe<StopsDatabaseBoardingPositionKeyValues>;
  /** delete data from the table: "check_constraint" */
  stops_database_delete_check_constraint?: Maybe<StopsDatabaseCheckConstraintMutationResponse>;
  /** delete single row from the table: "check_constraint" */
  stops_database_delete_check_constraint_by_pk?: Maybe<StopsDatabaseCheckConstraint>;
  /** delete data from the table: "check_constraint_key_values" */
  stops_database_delete_check_constraint_key_values?: Maybe<StopsDatabaseCheckConstraintKeyValuesMutationResponse>;
  /** delete single row from the table: "check_constraint_key_values" */
  stops_database_delete_check_constraint_key_values_by_pk?: Maybe<StopsDatabaseCheckConstraintKeyValues>;
  /** delete data from the table: "destination_display_view" */
  stops_database_delete_destination_display_view?: Maybe<StopsDatabaseDestinationDisplayViewMutationResponse>;
  /** delete single row from the table: "destination_display_view" */
  stops_database_delete_destination_display_view_by_pk?: Maybe<StopsDatabaseDestinationDisplayView>;
  /** delete data from the table: "equipment_place" */
  stops_database_delete_equipment_place?: Maybe<StopsDatabaseEquipmentPlaceMutationResponse>;
  /** delete single row from the table: "equipment_place" */
  stops_database_delete_equipment_place_by_pk?: Maybe<StopsDatabaseEquipmentPlace>;
  /** delete data from the table: "equipment_place_equipment_positions" */
  stops_database_delete_equipment_place_equipment_positions?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsMutationResponse>;
  /** delete data from the table: "equipment_place_key_values" */
  stops_database_delete_equipment_place_key_values?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesMutationResponse>;
  /** delete single row from the table: "equipment_place_key_values" */
  stops_database_delete_equipment_place_key_values_by_pk?: Maybe<StopsDatabaseEquipmentPlaceKeyValues>;
  /** delete data from the table: "equipment_position" */
  stops_database_delete_equipment_position?: Maybe<StopsDatabaseEquipmentPositionMutationResponse>;
  /** delete single row from the table: "equipment_position" */
  stops_database_delete_equipment_position_by_pk?: Maybe<StopsDatabaseEquipmentPosition>;
  /** delete data from the table: "equipment_position_key_values" */
  stops_database_delete_equipment_position_key_values?: Maybe<StopsDatabaseEquipmentPositionKeyValuesMutationResponse>;
  /** delete single row from the table: "equipment_position_key_values" */
  stops_database_delete_equipment_position_key_values_by_pk?: Maybe<StopsDatabaseEquipmentPositionKeyValues>;
  /** delete data from the table: "export_job" */
  stops_database_delete_export_job?: Maybe<StopsDatabaseExportJobMutationResponse>;
  /** delete single row from the table: "export_job" */
  stops_database_delete_export_job_by_pk?: Maybe<StopsDatabaseExportJob>;
  /** delete data from the table: "fare_zone" */
  stops_database_delete_fare_zone?: Maybe<StopsDatabaseFareZoneMutationResponse>;
  /** delete single row from the table: "fare_zone" */
  stops_database_delete_fare_zone_by_pk?: Maybe<StopsDatabaseFareZone>;
  /** delete data from the table: "fare_zone_key_values" */
  stops_database_delete_fare_zone_key_values?: Maybe<StopsDatabaseFareZoneKeyValuesMutationResponse>;
  /** delete single row from the table: "fare_zone_key_values" */
  stops_database_delete_fare_zone_key_values_by_pk?: Maybe<StopsDatabaseFareZoneKeyValues>;
  /** delete data from the table: "fare_zone_members" */
  stops_database_delete_fare_zone_members?: Maybe<StopsDatabaseFareZoneMembersMutationResponse>;
  /** delete data from the table: "fare_zone_neighbours" */
  stops_database_delete_fare_zone_neighbours?: Maybe<StopsDatabaseFareZoneNeighboursMutationResponse>;
  /** delete data from the table: "geometry_columns" */
  stops_database_delete_geometry_columns?: Maybe<StopsDatabaseGeometryColumnsMutationResponse>;
  /** delete data from the table: "group_of_stop_places" */
  stops_database_delete_group_of_stop_places?: Maybe<StopsDatabaseGroupOfStopPlacesMutationResponse>;
  /** delete data from the table: "group_of_stop_places_alternative_names" */
  stops_database_delete_group_of_stop_places_alternative_names?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesMutationResponse>;
  /** delete single row from the table: "group_of_stop_places" */
  stops_database_delete_group_of_stop_places_by_pk?: Maybe<StopsDatabaseGroupOfStopPlaces>;
  /** delete data from the table: "group_of_stop_places_key_values" */
  stops_database_delete_group_of_stop_places_key_values?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesMutationResponse>;
  /** delete single row from the table: "group_of_stop_places_key_values" */
  stops_database_delete_group_of_stop_places_key_values_by_pk?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValues>;
  /** delete data from the table: "group_of_stop_places_members" */
  stops_database_delete_group_of_stop_places_members?: Maybe<StopsDatabaseGroupOfStopPlacesMembersMutationResponse>;
  /** delete data from the table: "group_of_tariff_zones" */
  stops_database_delete_group_of_tariff_zones?: Maybe<StopsDatabaseGroupOfTariffZonesMutationResponse>;
  /** delete single row from the table: "group_of_tariff_zones" */
  stops_database_delete_group_of_tariff_zones_by_pk?: Maybe<StopsDatabaseGroupOfTariffZones>;
  /** delete data from the table: "group_of_tariff_zones_key_values" */
  stops_database_delete_group_of_tariff_zones_key_values?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesMutationResponse>;
  /** delete single row from the table: "group_of_tariff_zones_key_values" */
  stops_database_delete_group_of_tariff_zones_key_values_by_pk?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValues>;
  /** delete data from the table: "group_of_tariff_zones_members" */
  stops_database_delete_group_of_tariff_zones_members?: Maybe<StopsDatabaseGroupOfTariffZonesMembersMutationResponse>;
  /** delete single row from the table: "group_of_tariff_zones_members" */
  stops_database_delete_group_of_tariff_zones_members_by_pk?: Maybe<StopsDatabaseGroupOfTariffZonesMembers>;
  /** delete data from the table: "id_generator" */
  stops_database_delete_id_generator?: Maybe<StopsDatabaseIdGeneratorMutationResponse>;
  /** delete data from the table: "installed_equipment" */
  stops_database_delete_installed_equipment?: Maybe<StopsDatabaseInstalledEquipmentMutationResponse>;
  /** delete data from the table: "installed_equipment_version_structure" */
  stops_database_delete_installed_equipment_version_structure?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureMutationResponse>;
  /** delete single row from the table: "installed_equipment_version_structure" */
  stops_database_delete_installed_equipment_version_structure_by_pk?: Maybe<StopsDatabaseInstalledEquipmentVersionStructure>;
  /** delete data from the table: "installed_equipment_version_structure_installed_equipment" */
  stops_database_delete_installed_equipment_version_structure_installed_equipment?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMutationResponse>;
  /** delete data from the table: "level" */
  stops_database_delete_level?: Maybe<StopsDatabaseLevelMutationResponse>;
  /** delete single row from the table: "level" */
  stops_database_delete_level_by_pk?: Maybe<StopsDatabaseLevel>;
  /** delete data from the table: "level_key_values" */
  stops_database_delete_level_key_values?: Maybe<StopsDatabaseLevelKeyValuesMutationResponse>;
  /** delete single row from the table: "level_key_values" */
  stops_database_delete_level_key_values_by_pk?: Maybe<StopsDatabaseLevelKeyValues>;
  /** delete data from the table: "multilingual_string_entity" */
  stops_database_delete_multilingual_string_entity?: Maybe<StopsDatabaseMultilingualStringEntityMutationResponse>;
  /** delete single row from the table: "multilingual_string_entity" */
  stops_database_delete_multilingual_string_entity_by_pk?: Maybe<StopsDatabaseMultilingualStringEntity>;
  /** delete data from the table: "navigation_path" */
  stops_database_delete_navigation_path?: Maybe<StopsDatabaseNavigationPathMutationResponse>;
  /** delete data from the table: "parking" */
  stops_database_delete_parking?: Maybe<StopsDatabaseParkingMutationResponse>;
  /** delete data from the table: "parking_adjacent_sites" */
  stops_database_delete_parking_adjacent_sites?: Maybe<StopsDatabaseParkingAdjacentSitesMutationResponse>;
  /** delete data from the table: "parking_alternative_names" */
  stops_database_delete_parking_alternative_names?: Maybe<StopsDatabaseParkingAlternativeNamesMutationResponse>;
  /** delete data from the table: "parking_area" */
  stops_database_delete_parking_area?: Maybe<StopsDatabaseParkingAreaMutationResponse>;
  /** delete data from the table: "parking_area_alternative_names" */
  stops_database_delete_parking_area_alternative_names?: Maybe<StopsDatabaseParkingAreaAlternativeNamesMutationResponse>;
  /** delete single row from the table: "parking_area" */
  stops_database_delete_parking_area_by_pk?: Maybe<StopsDatabaseParkingArea>;
  /** delete data from the table: "parking_area_check_constraints" */
  stops_database_delete_parking_area_check_constraints?: Maybe<StopsDatabaseParkingAreaCheckConstraintsMutationResponse>;
  /** delete data from the table: "parking_area_equipment_places" */
  stops_database_delete_parking_area_equipment_places?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesMutationResponse>;
  /** delete data from the table: "parking_area_key_values" */
  stops_database_delete_parking_area_key_values?: Maybe<StopsDatabaseParkingAreaKeyValuesMutationResponse>;
  /** delete single row from the table: "parking_area_key_values" */
  stops_database_delete_parking_area_key_values_by_pk?: Maybe<StopsDatabaseParkingAreaKeyValues>;
  /** delete single row from the table: "parking" */
  stops_database_delete_parking_by_pk?: Maybe<StopsDatabaseParking>;
  /** delete data from the table: "parking_capacity" */
  stops_database_delete_parking_capacity?: Maybe<StopsDatabaseParkingCapacityMutationResponse>;
  /** delete single row from the table: "parking_capacity" */
  stops_database_delete_parking_capacity_by_pk?: Maybe<StopsDatabaseParkingCapacity>;
  /** delete data from the table: "parking_equipment_places" */
  stops_database_delete_parking_equipment_places?: Maybe<StopsDatabaseParkingEquipmentPlacesMutationResponse>;
  /** delete data from the table: "parking_key_values" */
  stops_database_delete_parking_key_values?: Maybe<StopsDatabaseParkingKeyValuesMutationResponse>;
  /** delete single row from the table: "parking_key_values" */
  stops_database_delete_parking_key_values_by_pk?: Maybe<StopsDatabaseParkingKeyValues>;
  /** delete data from the table: "parking_parking_areas" */
  stops_database_delete_parking_parking_areas?: Maybe<StopsDatabaseParkingParkingAreasMutationResponse>;
  /** delete data from the table: "parking_parking_payment_process" */
  stops_database_delete_parking_parking_payment_process?: Maybe<StopsDatabaseParkingParkingPaymentProcessMutationResponse>;
  /** delete data from the table: "parking_parking_properties" */
  stops_database_delete_parking_parking_properties?: Maybe<StopsDatabaseParkingParkingPropertiesMutationResponse>;
  /** delete data from the table: "parking_parking_vehicle_types" */
  stops_database_delete_parking_parking_vehicle_types?: Maybe<StopsDatabaseParkingParkingVehicleTypesMutationResponse>;
  /** delete data from the table: "parking_properties" */
  stops_database_delete_parking_properties?: Maybe<StopsDatabaseParkingPropertiesMutationResponse>;
  /** delete single row from the table: "parking_properties" */
  stops_database_delete_parking_properties_by_pk?: Maybe<StopsDatabaseParkingProperties>;
  /** delete data from the table: "parking_properties_parking_user_types" */
  stops_database_delete_parking_properties_parking_user_types?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesMutationResponse>;
  /** delete data from the table: "parking_properties_spaces" */
  stops_database_delete_parking_properties_spaces?: Maybe<StopsDatabaseParkingPropertiesSpacesMutationResponse>;
  /** delete data from the table: "path_junction" */
  stops_database_delete_path_junction?: Maybe<StopsDatabasePathJunctionMutationResponse>;
  /** delete single row from the table: "path_junction" */
  stops_database_delete_path_junction_by_pk?: Maybe<StopsDatabasePathJunction>;
  /** delete data from the table: "path_junction_key_values" */
  stops_database_delete_path_junction_key_values?: Maybe<StopsDatabasePathJunctionKeyValuesMutationResponse>;
  /** delete single row from the table: "path_junction_key_values" */
  stops_database_delete_path_junction_key_values_by_pk?: Maybe<StopsDatabasePathJunctionKeyValues>;
  /** delete data from the table: "path_link" */
  stops_database_delete_path_link?: Maybe<StopsDatabasePathLinkMutationResponse>;
  /** delete single row from the table: "path_link" */
  stops_database_delete_path_link_by_pk?: Maybe<StopsDatabasePathLink>;
  /** delete data from the table: "path_link_end" */
  stops_database_delete_path_link_end?: Maybe<StopsDatabasePathLinkEndMutationResponse>;
  /** delete single row from the table: "path_link_end" */
  stops_database_delete_path_link_end_by_pk?: Maybe<StopsDatabasePathLinkEnd>;
  /** delete data from the table: "path_link_key_values" */
  stops_database_delete_path_link_key_values?: Maybe<StopsDatabasePathLinkKeyValuesMutationResponse>;
  /** delete single row from the table: "path_link_key_values" */
  stops_database_delete_path_link_key_values_by_pk?: Maybe<StopsDatabasePathLinkKeyValues>;
  /** delete data from the table: "persistable_polygon" */
  stops_database_delete_persistable_polygon?: Maybe<StopsDatabasePersistablePolygonMutationResponse>;
  /** delete single row from the table: "persistable_polygon" */
  stops_database_delete_persistable_polygon_by_pk?: Maybe<StopsDatabasePersistablePolygon>;
  /** delete data from the table: "purpose_of_grouping" */
  stops_database_delete_purpose_of_grouping?: Maybe<StopsDatabasePurposeOfGroupingMutationResponse>;
  /** delete single row from the table: "purpose_of_grouping" */
  stops_database_delete_purpose_of_grouping_by_pk?: Maybe<StopsDatabasePurposeOfGrouping>;
  /** delete data from the table: "purpose_of_grouping_key_values" */
  stops_database_delete_purpose_of_grouping_key_values?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesMutationResponse>;
  /** delete single row from the table: "purpose_of_grouping_key_values" */
  stops_database_delete_purpose_of_grouping_key_values_by_pk?: Maybe<StopsDatabasePurposeOfGroupingKeyValues>;
  /** delete data from the table: "quay" */
  stops_database_delete_quay?: Maybe<StopsDatabaseQuayMutationResponse>;
  /** delete data from the table: "quay_alternative_names" */
  stops_database_delete_quay_alternative_names?: Maybe<StopsDatabaseQuayAlternativeNamesMutationResponse>;
  /** delete data from the table: "quay_boarding_positions" */
  stops_database_delete_quay_boarding_positions?: Maybe<StopsDatabaseQuayBoardingPositionsMutationResponse>;
  /** delete single row from the table: "quay" */
  stops_database_delete_quay_by_pk?: Maybe<StopsDatabaseQuay>;
  /** delete data from the table: "quay_check_constraints" */
  stops_database_delete_quay_check_constraints?: Maybe<StopsDatabaseQuayCheckConstraintsMutationResponse>;
  /** delete data from the table: "quay_equipment_places" */
  stops_database_delete_quay_equipment_places?: Maybe<StopsDatabaseQuayEquipmentPlacesMutationResponse>;
  /** delete data from the table: "quay_key_values" */
  stops_database_delete_quay_key_values?: Maybe<StopsDatabaseQuayKeyValuesMutationResponse>;
  /** delete single row from the table: "quay_key_values" */
  stops_database_delete_quay_key_values_by_pk?: Maybe<StopsDatabaseQuayKeyValues>;
  /** delete data from the table: "schema_version" */
  stops_database_delete_schema_version?: Maybe<StopsDatabaseSchemaVersionMutationResponse>;
  /** delete single row from the table: "schema_version" */
  stops_database_delete_schema_version_by_pk?: Maybe<StopsDatabaseSchemaVersion>;
  /** delete data from the table: "spatial_ref_sys" */
  stops_database_delete_spatial_ref_sys?: Maybe<StopsDatabaseSpatialRefSysMutationResponse>;
  /** delete single row from the table: "spatial_ref_sys" */
  stops_database_delete_spatial_ref_sys_by_pk?: Maybe<StopsDatabaseSpatialRefSys>;
  /** delete data from the table: "stop_place" */
  stops_database_delete_stop_place?: Maybe<StopsDatabaseStopPlaceMutationResponse>;
  /** delete data from the table: "stop_place_access_spaces" */
  stops_database_delete_stop_place_access_spaces?: Maybe<StopsDatabaseStopPlaceAccessSpacesMutationResponse>;
  /** delete data from the table: "stop_place_adjacent_sites" */
  stops_database_delete_stop_place_adjacent_sites?: Maybe<StopsDatabaseStopPlaceAdjacentSitesMutationResponse>;
  /** delete data from the table: "stop_place_alternative_names" */
  stops_database_delete_stop_place_alternative_names?: Maybe<StopsDatabaseStopPlaceAlternativeNamesMutationResponse>;
  /** delete single row from the table: "stop_place" */
  stops_database_delete_stop_place_by_pk?: Maybe<StopsDatabaseStopPlace>;
  /** delete data from the table: "stop_place_children" */
  stops_database_delete_stop_place_children?: Maybe<StopsDatabaseStopPlaceChildrenMutationResponse>;
  /** delete single row from the table: "stop_place_children" */
  stops_database_delete_stop_place_children_by_pk?: Maybe<StopsDatabaseStopPlaceChildren>;
  /** delete data from the table: "stop_place_equipment_places" */
  stops_database_delete_stop_place_equipment_places?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesMutationResponse>;
  /** delete data from the table: "stop_place_key_values" */
  stops_database_delete_stop_place_key_values?: Maybe<StopsDatabaseStopPlaceKeyValuesMutationResponse>;
  /** delete single row from the table: "stop_place_key_values" */
  stops_database_delete_stop_place_key_values_by_pk?: Maybe<StopsDatabaseStopPlaceKeyValues>;
  /** delete data from the table: "stop_place_quays" */
  stops_database_delete_stop_place_quays?: Maybe<StopsDatabaseStopPlaceQuaysMutationResponse>;
  /** delete single row from the table: "stop_place_quays" */
  stops_database_delete_stop_place_quays_by_pk?: Maybe<StopsDatabaseStopPlaceQuays>;
  /** delete data from the table: "stop_place_tariff_zones" */
  stops_database_delete_stop_place_tariff_zones?: Maybe<StopsDatabaseStopPlaceTariffZonesMutationResponse>;
  /** delete data from the table: "tag" */
  stops_database_delete_tag?: Maybe<StopsDatabaseTagMutationResponse>;
  /** delete single row from the table: "tag" */
  stops_database_delete_tag_by_pk?: Maybe<StopsDatabaseTag>;
  /** delete data from the table: "tariff_zone" */
  stops_database_delete_tariff_zone?: Maybe<StopsDatabaseTariffZoneMutationResponse>;
  /** delete single row from the table: "tariff_zone" */
  stops_database_delete_tariff_zone_by_pk?: Maybe<StopsDatabaseTariffZone>;
  /** delete data from the table: "tariff_zone_key_values" */
  stops_database_delete_tariff_zone_key_values?: Maybe<StopsDatabaseTariffZoneKeyValuesMutationResponse>;
  /** delete single row from the table: "tariff_zone_key_values" */
  stops_database_delete_tariff_zone_key_values_by_pk?: Maybe<StopsDatabaseTariffZoneKeyValues>;
  /** delete data from the table: "topographic_place" */
  stops_database_delete_topographic_place?: Maybe<StopsDatabaseTopographicPlaceMutationResponse>;
  /** delete single row from the table: "topographic_place" */
  stops_database_delete_topographic_place_by_pk?: Maybe<StopsDatabaseTopographicPlace>;
  /** delete data from the table: "topographic_place_key_values" */
  stops_database_delete_topographic_place_key_values?: Maybe<StopsDatabaseTopographicPlaceKeyValuesMutationResponse>;
  /** delete single row from the table: "topographic_place_key_values" */
  stops_database_delete_topographic_place_key_values_by_pk?: Maybe<StopsDatabaseTopographicPlaceKeyValues>;
  /** delete data from the table: "value" */
  stops_database_delete_value?: Maybe<StopsDatabaseValueMutationResponse>;
  /** delete single row from the table: "value" */
  stops_database_delete_value_by_pk?: Maybe<StopsDatabaseValue>;
  /** delete data from the table: "value_items" */
  stops_database_delete_value_items?: Maybe<StopsDatabaseValueItemsMutationResponse>;
  /** insert data into the table: "access_space" */
  stops_database_insert_access_space?: Maybe<StopsDatabaseAccessSpaceMutationResponse>;
  /** insert data into the table: "access_space_alternative_names" */
  stops_database_insert_access_space_alternative_names?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesMutationResponse>;
  /** insert a single row into the table: "access_space_alternative_names" */
  stops_database_insert_access_space_alternative_names_one?: Maybe<StopsDatabaseAccessSpaceAlternativeNames>;
  /** insert data into the table: "access_space_check_constraints" */
  stops_database_insert_access_space_check_constraints?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsMutationResponse>;
  /** insert a single row into the table: "access_space_check_constraints" */
  stops_database_insert_access_space_check_constraints_one?: Maybe<StopsDatabaseAccessSpaceCheckConstraints>;
  /** insert data into the table: "access_space_equipment_places" */
  stops_database_insert_access_space_equipment_places?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesMutationResponse>;
  /** insert a single row into the table: "access_space_equipment_places" */
  stops_database_insert_access_space_equipment_places_one?: Maybe<StopsDatabaseAccessSpaceEquipmentPlaces>;
  /** insert data into the table: "access_space_key_values" */
  stops_database_insert_access_space_key_values?: Maybe<StopsDatabaseAccessSpaceKeyValuesMutationResponse>;
  /** insert a single row into the table: "access_space_key_values" */
  stops_database_insert_access_space_key_values_one?: Maybe<StopsDatabaseAccessSpaceKeyValues>;
  /** insert a single row into the table: "access_space" */
  stops_database_insert_access_space_one?: Maybe<StopsDatabaseAccessSpace>;
  /** insert data into the table: "accessibility_assessment" */
  stops_database_insert_accessibility_assessment?: Maybe<StopsDatabaseAccessibilityAssessmentMutationResponse>;
  /** insert data into the table: "accessibility_assessment_limitations" */
  stops_database_insert_accessibility_assessment_limitations?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsMutationResponse>;
  /** insert a single row into the table: "accessibility_assessment_limitations" */
  stops_database_insert_accessibility_assessment_limitations_one?: Maybe<StopsDatabaseAccessibilityAssessmentLimitations>;
  /** insert a single row into the table: "accessibility_assessment" */
  stops_database_insert_accessibility_assessment_one?: Maybe<StopsDatabaseAccessibilityAssessment>;
  /** insert data into the table: "accessibility_limitation" */
  stops_database_insert_accessibility_limitation?: Maybe<StopsDatabaseAccessibilityLimitationMutationResponse>;
  /** insert a single row into the table: "accessibility_limitation" */
  stops_database_insert_accessibility_limitation_one?: Maybe<StopsDatabaseAccessibilityLimitation>;
  /** insert data into the table: "alternative_name" */
  stops_database_insert_alternative_name?: Maybe<StopsDatabaseAlternativeNameMutationResponse>;
  /** insert a single row into the table: "alternative_name" */
  stops_database_insert_alternative_name_one?: Maybe<StopsDatabaseAlternativeName>;
  /** insert data into the table: "boarding_position" */
  stops_database_insert_boarding_position?: Maybe<StopsDatabaseBoardingPositionMutationResponse>;
  /** insert data into the table: "boarding_position_alternative_names" */
  stops_database_insert_boarding_position_alternative_names?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesMutationResponse>;
  /** insert a single row into the table: "boarding_position_alternative_names" */
  stops_database_insert_boarding_position_alternative_names_one?: Maybe<StopsDatabaseBoardingPositionAlternativeNames>;
  /** insert data into the table: "boarding_position_check_constraints" */
  stops_database_insert_boarding_position_check_constraints?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsMutationResponse>;
  /** insert a single row into the table: "boarding_position_check_constraints" */
  stops_database_insert_boarding_position_check_constraints_one?: Maybe<StopsDatabaseBoardingPositionCheckConstraints>;
  /** insert data into the table: "boarding_position_equipment_places" */
  stops_database_insert_boarding_position_equipment_places?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesMutationResponse>;
  /** insert a single row into the table: "boarding_position_equipment_places" */
  stops_database_insert_boarding_position_equipment_places_one?: Maybe<StopsDatabaseBoardingPositionEquipmentPlaces>;
  /** insert data into the table: "boarding_position_key_values" */
  stops_database_insert_boarding_position_key_values?: Maybe<StopsDatabaseBoardingPositionKeyValuesMutationResponse>;
  /** insert a single row into the table: "boarding_position_key_values" */
  stops_database_insert_boarding_position_key_values_one?: Maybe<StopsDatabaseBoardingPositionKeyValues>;
  /** insert a single row into the table: "boarding_position" */
  stops_database_insert_boarding_position_one?: Maybe<StopsDatabaseBoardingPosition>;
  /** insert data into the table: "check_constraint" */
  stops_database_insert_check_constraint?: Maybe<StopsDatabaseCheckConstraintMutationResponse>;
  /** insert data into the table: "check_constraint_key_values" */
  stops_database_insert_check_constraint_key_values?: Maybe<StopsDatabaseCheckConstraintKeyValuesMutationResponse>;
  /** insert a single row into the table: "check_constraint_key_values" */
  stops_database_insert_check_constraint_key_values_one?: Maybe<StopsDatabaseCheckConstraintKeyValues>;
  /** insert a single row into the table: "check_constraint" */
  stops_database_insert_check_constraint_one?: Maybe<StopsDatabaseCheckConstraint>;
  /** insert data into the table: "destination_display_view" */
  stops_database_insert_destination_display_view?: Maybe<StopsDatabaseDestinationDisplayViewMutationResponse>;
  /** insert a single row into the table: "destination_display_view" */
  stops_database_insert_destination_display_view_one?: Maybe<StopsDatabaseDestinationDisplayView>;
  /** insert data into the table: "equipment_place" */
  stops_database_insert_equipment_place?: Maybe<StopsDatabaseEquipmentPlaceMutationResponse>;
  /** insert data into the table: "equipment_place_equipment_positions" */
  stops_database_insert_equipment_place_equipment_positions?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsMutationResponse>;
  /** insert a single row into the table: "equipment_place_equipment_positions" */
  stops_database_insert_equipment_place_equipment_positions_one?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositions>;
  /** insert data into the table: "equipment_place_key_values" */
  stops_database_insert_equipment_place_key_values?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesMutationResponse>;
  /** insert a single row into the table: "equipment_place_key_values" */
  stops_database_insert_equipment_place_key_values_one?: Maybe<StopsDatabaseEquipmentPlaceKeyValues>;
  /** insert a single row into the table: "equipment_place" */
  stops_database_insert_equipment_place_one?: Maybe<StopsDatabaseEquipmentPlace>;
  /** insert data into the table: "equipment_position" */
  stops_database_insert_equipment_position?: Maybe<StopsDatabaseEquipmentPositionMutationResponse>;
  /** insert data into the table: "equipment_position_key_values" */
  stops_database_insert_equipment_position_key_values?: Maybe<StopsDatabaseEquipmentPositionKeyValuesMutationResponse>;
  /** insert a single row into the table: "equipment_position_key_values" */
  stops_database_insert_equipment_position_key_values_one?: Maybe<StopsDatabaseEquipmentPositionKeyValues>;
  /** insert a single row into the table: "equipment_position" */
  stops_database_insert_equipment_position_one?: Maybe<StopsDatabaseEquipmentPosition>;
  /** insert data into the table: "export_job" */
  stops_database_insert_export_job?: Maybe<StopsDatabaseExportJobMutationResponse>;
  /** insert a single row into the table: "export_job" */
  stops_database_insert_export_job_one?: Maybe<StopsDatabaseExportJob>;
  /** insert data into the table: "fare_zone" */
  stops_database_insert_fare_zone?: Maybe<StopsDatabaseFareZoneMutationResponse>;
  /** insert data into the table: "fare_zone_key_values" */
  stops_database_insert_fare_zone_key_values?: Maybe<StopsDatabaseFareZoneKeyValuesMutationResponse>;
  /** insert a single row into the table: "fare_zone_key_values" */
  stops_database_insert_fare_zone_key_values_one?: Maybe<StopsDatabaseFareZoneKeyValues>;
  /** insert data into the table: "fare_zone_members" */
  stops_database_insert_fare_zone_members?: Maybe<StopsDatabaseFareZoneMembersMutationResponse>;
  /** insert a single row into the table: "fare_zone_members" */
  stops_database_insert_fare_zone_members_one?: Maybe<StopsDatabaseFareZoneMembers>;
  /** insert data into the table: "fare_zone_neighbours" */
  stops_database_insert_fare_zone_neighbours?: Maybe<StopsDatabaseFareZoneNeighboursMutationResponse>;
  /** insert a single row into the table: "fare_zone_neighbours" */
  stops_database_insert_fare_zone_neighbours_one?: Maybe<StopsDatabaseFareZoneNeighbours>;
  /** insert a single row into the table: "fare_zone" */
  stops_database_insert_fare_zone_one?: Maybe<StopsDatabaseFareZone>;
  /** insert data into the table: "geometry_columns" */
  stops_database_insert_geometry_columns?: Maybe<StopsDatabaseGeometryColumnsMutationResponse>;
  /** insert a single row into the table: "geometry_columns" */
  stops_database_insert_geometry_columns_one?: Maybe<StopsDatabaseGeometryColumns>;
  /** insert data into the table: "group_of_stop_places" */
  stops_database_insert_group_of_stop_places?: Maybe<StopsDatabaseGroupOfStopPlacesMutationResponse>;
  /** insert data into the table: "group_of_stop_places_alternative_names" */
  stops_database_insert_group_of_stop_places_alternative_names?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesMutationResponse>;
  /** insert a single row into the table: "group_of_stop_places_alternative_names" */
  stops_database_insert_group_of_stop_places_alternative_names_one?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNames>;
  /** insert data into the table: "group_of_stop_places_key_values" */
  stops_database_insert_group_of_stop_places_key_values?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesMutationResponse>;
  /** insert a single row into the table: "group_of_stop_places_key_values" */
  stops_database_insert_group_of_stop_places_key_values_one?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValues>;
  /** insert data into the table: "group_of_stop_places_members" */
  stops_database_insert_group_of_stop_places_members?: Maybe<StopsDatabaseGroupOfStopPlacesMembersMutationResponse>;
  /** insert a single row into the table: "group_of_stop_places_members" */
  stops_database_insert_group_of_stop_places_members_one?: Maybe<StopsDatabaseGroupOfStopPlacesMembers>;
  /** insert a single row into the table: "group_of_stop_places" */
  stops_database_insert_group_of_stop_places_one?: Maybe<StopsDatabaseGroupOfStopPlaces>;
  /** insert data into the table: "group_of_tariff_zones" */
  stops_database_insert_group_of_tariff_zones?: Maybe<StopsDatabaseGroupOfTariffZonesMutationResponse>;
  /** insert data into the table: "group_of_tariff_zones_key_values" */
  stops_database_insert_group_of_tariff_zones_key_values?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesMutationResponse>;
  /** insert a single row into the table: "group_of_tariff_zones_key_values" */
  stops_database_insert_group_of_tariff_zones_key_values_one?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValues>;
  /** insert data into the table: "group_of_tariff_zones_members" */
  stops_database_insert_group_of_tariff_zones_members?: Maybe<StopsDatabaseGroupOfTariffZonesMembersMutationResponse>;
  /** insert a single row into the table: "group_of_tariff_zones_members" */
  stops_database_insert_group_of_tariff_zones_members_one?: Maybe<StopsDatabaseGroupOfTariffZonesMembers>;
  /** insert a single row into the table: "group_of_tariff_zones" */
  stops_database_insert_group_of_tariff_zones_one?: Maybe<StopsDatabaseGroupOfTariffZones>;
  /** insert data into the table: "id_generator" */
  stops_database_insert_id_generator?: Maybe<StopsDatabaseIdGeneratorMutationResponse>;
  /** insert a single row into the table: "id_generator" */
  stops_database_insert_id_generator_one?: Maybe<StopsDatabaseIdGenerator>;
  /** insert data into the table: "installed_equipment" */
  stops_database_insert_installed_equipment?: Maybe<StopsDatabaseInstalledEquipmentMutationResponse>;
  /** insert a single row into the table: "installed_equipment" */
  stops_database_insert_installed_equipment_one?: Maybe<StopsDatabaseInstalledEquipment>;
  /** insert data into the table: "installed_equipment_version_structure" */
  stops_database_insert_installed_equipment_version_structure?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureMutationResponse>;
  /** insert data into the table: "installed_equipment_version_structure_installed_equipment" */
  stops_database_insert_installed_equipment_version_structure_installed_equipment?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMutationResponse>;
  /** insert a single row into the table: "installed_equipment_version_structure_installed_equipment" */
  stops_database_insert_installed_equipment_version_structure_installed_equipment_one?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipment>;
  /** insert a single row into the table: "installed_equipment_version_structure" */
  stops_database_insert_installed_equipment_version_structure_one?: Maybe<StopsDatabaseInstalledEquipmentVersionStructure>;
  /** insert data into the table: "level" */
  stops_database_insert_level?: Maybe<StopsDatabaseLevelMutationResponse>;
  /** insert data into the table: "level_key_values" */
  stops_database_insert_level_key_values?: Maybe<StopsDatabaseLevelKeyValuesMutationResponse>;
  /** insert a single row into the table: "level_key_values" */
  stops_database_insert_level_key_values_one?: Maybe<StopsDatabaseLevelKeyValues>;
  /** insert a single row into the table: "level" */
  stops_database_insert_level_one?: Maybe<StopsDatabaseLevel>;
  /** insert data into the table: "multilingual_string_entity" */
  stops_database_insert_multilingual_string_entity?: Maybe<StopsDatabaseMultilingualStringEntityMutationResponse>;
  /** insert a single row into the table: "multilingual_string_entity" */
  stops_database_insert_multilingual_string_entity_one?: Maybe<StopsDatabaseMultilingualStringEntity>;
  /** insert data into the table: "navigation_path" */
  stops_database_insert_navigation_path?: Maybe<StopsDatabaseNavigationPathMutationResponse>;
  /** insert a single row into the table: "navigation_path" */
  stops_database_insert_navigation_path_one?: Maybe<StopsDatabaseNavigationPath>;
  /** insert data into the table: "parking" */
  stops_database_insert_parking?: Maybe<StopsDatabaseParkingMutationResponse>;
  /** insert data into the table: "parking_adjacent_sites" */
  stops_database_insert_parking_adjacent_sites?: Maybe<StopsDatabaseParkingAdjacentSitesMutationResponse>;
  /** insert a single row into the table: "parking_adjacent_sites" */
  stops_database_insert_parking_adjacent_sites_one?: Maybe<StopsDatabaseParkingAdjacentSites>;
  /** insert data into the table: "parking_alternative_names" */
  stops_database_insert_parking_alternative_names?: Maybe<StopsDatabaseParkingAlternativeNamesMutationResponse>;
  /** insert a single row into the table: "parking_alternative_names" */
  stops_database_insert_parking_alternative_names_one?: Maybe<StopsDatabaseParkingAlternativeNames>;
  /** insert data into the table: "parking_area" */
  stops_database_insert_parking_area?: Maybe<StopsDatabaseParkingAreaMutationResponse>;
  /** insert data into the table: "parking_area_alternative_names" */
  stops_database_insert_parking_area_alternative_names?: Maybe<StopsDatabaseParkingAreaAlternativeNamesMutationResponse>;
  /** insert a single row into the table: "parking_area_alternative_names" */
  stops_database_insert_parking_area_alternative_names_one?: Maybe<StopsDatabaseParkingAreaAlternativeNames>;
  /** insert data into the table: "parking_area_check_constraints" */
  stops_database_insert_parking_area_check_constraints?: Maybe<StopsDatabaseParkingAreaCheckConstraintsMutationResponse>;
  /** insert a single row into the table: "parking_area_check_constraints" */
  stops_database_insert_parking_area_check_constraints_one?: Maybe<StopsDatabaseParkingAreaCheckConstraints>;
  /** insert data into the table: "parking_area_equipment_places" */
  stops_database_insert_parking_area_equipment_places?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesMutationResponse>;
  /** insert a single row into the table: "parking_area_equipment_places" */
  stops_database_insert_parking_area_equipment_places_one?: Maybe<StopsDatabaseParkingAreaEquipmentPlaces>;
  /** insert data into the table: "parking_area_key_values" */
  stops_database_insert_parking_area_key_values?: Maybe<StopsDatabaseParkingAreaKeyValuesMutationResponse>;
  /** insert a single row into the table: "parking_area_key_values" */
  stops_database_insert_parking_area_key_values_one?: Maybe<StopsDatabaseParkingAreaKeyValues>;
  /** insert a single row into the table: "parking_area" */
  stops_database_insert_parking_area_one?: Maybe<StopsDatabaseParkingArea>;
  /** insert data into the table: "parking_capacity" */
  stops_database_insert_parking_capacity?: Maybe<StopsDatabaseParkingCapacityMutationResponse>;
  /** insert a single row into the table: "parking_capacity" */
  stops_database_insert_parking_capacity_one?: Maybe<StopsDatabaseParkingCapacity>;
  /** insert data into the table: "parking_equipment_places" */
  stops_database_insert_parking_equipment_places?: Maybe<StopsDatabaseParkingEquipmentPlacesMutationResponse>;
  /** insert a single row into the table: "parking_equipment_places" */
  stops_database_insert_parking_equipment_places_one?: Maybe<StopsDatabaseParkingEquipmentPlaces>;
  /** insert data into the table: "parking_key_values" */
  stops_database_insert_parking_key_values?: Maybe<StopsDatabaseParkingKeyValuesMutationResponse>;
  /** insert a single row into the table: "parking_key_values" */
  stops_database_insert_parking_key_values_one?: Maybe<StopsDatabaseParkingKeyValues>;
  /** insert a single row into the table: "parking" */
  stops_database_insert_parking_one?: Maybe<StopsDatabaseParking>;
  /** insert data into the table: "parking_parking_areas" */
  stops_database_insert_parking_parking_areas?: Maybe<StopsDatabaseParkingParkingAreasMutationResponse>;
  /** insert a single row into the table: "parking_parking_areas" */
  stops_database_insert_parking_parking_areas_one?: Maybe<StopsDatabaseParkingParkingAreas>;
  /** insert data into the table: "parking_parking_payment_process" */
  stops_database_insert_parking_parking_payment_process?: Maybe<StopsDatabaseParkingParkingPaymentProcessMutationResponse>;
  /** insert a single row into the table: "parking_parking_payment_process" */
  stops_database_insert_parking_parking_payment_process_one?: Maybe<StopsDatabaseParkingParkingPaymentProcess>;
  /** insert data into the table: "parking_parking_properties" */
  stops_database_insert_parking_parking_properties?: Maybe<StopsDatabaseParkingParkingPropertiesMutationResponse>;
  /** insert a single row into the table: "parking_parking_properties" */
  stops_database_insert_parking_parking_properties_one?: Maybe<StopsDatabaseParkingParkingProperties>;
  /** insert data into the table: "parking_parking_vehicle_types" */
  stops_database_insert_parking_parking_vehicle_types?: Maybe<StopsDatabaseParkingParkingVehicleTypesMutationResponse>;
  /** insert a single row into the table: "parking_parking_vehicle_types" */
  stops_database_insert_parking_parking_vehicle_types_one?: Maybe<StopsDatabaseParkingParkingVehicleTypes>;
  /** insert data into the table: "parking_properties" */
  stops_database_insert_parking_properties?: Maybe<StopsDatabaseParkingPropertiesMutationResponse>;
  /** insert a single row into the table: "parking_properties" */
  stops_database_insert_parking_properties_one?: Maybe<StopsDatabaseParkingProperties>;
  /** insert data into the table: "parking_properties_parking_user_types" */
  stops_database_insert_parking_properties_parking_user_types?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesMutationResponse>;
  /** insert a single row into the table: "parking_properties_parking_user_types" */
  stops_database_insert_parking_properties_parking_user_types_one?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypes>;
  /** insert data into the table: "parking_properties_spaces" */
  stops_database_insert_parking_properties_spaces?: Maybe<StopsDatabaseParkingPropertiesSpacesMutationResponse>;
  /** insert a single row into the table: "parking_properties_spaces" */
  stops_database_insert_parking_properties_spaces_one?: Maybe<StopsDatabaseParkingPropertiesSpaces>;
  /** insert data into the table: "path_junction" */
  stops_database_insert_path_junction?: Maybe<StopsDatabasePathJunctionMutationResponse>;
  /** insert data into the table: "path_junction_key_values" */
  stops_database_insert_path_junction_key_values?: Maybe<StopsDatabasePathJunctionKeyValuesMutationResponse>;
  /** insert a single row into the table: "path_junction_key_values" */
  stops_database_insert_path_junction_key_values_one?: Maybe<StopsDatabasePathJunctionKeyValues>;
  /** insert a single row into the table: "path_junction" */
  stops_database_insert_path_junction_one?: Maybe<StopsDatabasePathJunction>;
  /** insert data into the table: "path_link" */
  stops_database_insert_path_link?: Maybe<StopsDatabasePathLinkMutationResponse>;
  /** insert data into the table: "path_link_end" */
  stops_database_insert_path_link_end?: Maybe<StopsDatabasePathLinkEndMutationResponse>;
  /** insert a single row into the table: "path_link_end" */
  stops_database_insert_path_link_end_one?: Maybe<StopsDatabasePathLinkEnd>;
  /** insert data into the table: "path_link_key_values" */
  stops_database_insert_path_link_key_values?: Maybe<StopsDatabasePathLinkKeyValuesMutationResponse>;
  /** insert a single row into the table: "path_link_key_values" */
  stops_database_insert_path_link_key_values_one?: Maybe<StopsDatabasePathLinkKeyValues>;
  /** insert a single row into the table: "path_link" */
  stops_database_insert_path_link_one?: Maybe<StopsDatabasePathLink>;
  /** insert data into the table: "persistable_polygon" */
  stops_database_insert_persistable_polygon?: Maybe<StopsDatabasePersistablePolygonMutationResponse>;
  /** insert a single row into the table: "persistable_polygon" */
  stops_database_insert_persistable_polygon_one?: Maybe<StopsDatabasePersistablePolygon>;
  /** insert data into the table: "purpose_of_grouping" */
  stops_database_insert_purpose_of_grouping?: Maybe<StopsDatabasePurposeOfGroupingMutationResponse>;
  /** insert data into the table: "purpose_of_grouping_key_values" */
  stops_database_insert_purpose_of_grouping_key_values?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesMutationResponse>;
  /** insert a single row into the table: "purpose_of_grouping_key_values" */
  stops_database_insert_purpose_of_grouping_key_values_one?: Maybe<StopsDatabasePurposeOfGroupingKeyValues>;
  /** insert a single row into the table: "purpose_of_grouping" */
  stops_database_insert_purpose_of_grouping_one?: Maybe<StopsDatabasePurposeOfGrouping>;
  /** insert data into the table: "quay" */
  stops_database_insert_quay?: Maybe<StopsDatabaseQuayMutationResponse>;
  /** insert data into the table: "quay_alternative_names" */
  stops_database_insert_quay_alternative_names?: Maybe<StopsDatabaseQuayAlternativeNamesMutationResponse>;
  /** insert a single row into the table: "quay_alternative_names" */
  stops_database_insert_quay_alternative_names_one?: Maybe<StopsDatabaseQuayAlternativeNames>;
  /** insert data into the table: "quay_boarding_positions" */
  stops_database_insert_quay_boarding_positions?: Maybe<StopsDatabaseQuayBoardingPositionsMutationResponse>;
  /** insert a single row into the table: "quay_boarding_positions" */
  stops_database_insert_quay_boarding_positions_one?: Maybe<StopsDatabaseQuayBoardingPositions>;
  /** insert data into the table: "quay_check_constraints" */
  stops_database_insert_quay_check_constraints?: Maybe<StopsDatabaseQuayCheckConstraintsMutationResponse>;
  /** insert a single row into the table: "quay_check_constraints" */
  stops_database_insert_quay_check_constraints_one?: Maybe<StopsDatabaseQuayCheckConstraints>;
  /** insert data into the table: "quay_equipment_places" */
  stops_database_insert_quay_equipment_places?: Maybe<StopsDatabaseQuayEquipmentPlacesMutationResponse>;
  /** insert a single row into the table: "quay_equipment_places" */
  stops_database_insert_quay_equipment_places_one?: Maybe<StopsDatabaseQuayEquipmentPlaces>;
  /** insert data into the table: "quay_key_values" */
  stops_database_insert_quay_key_values?: Maybe<StopsDatabaseQuayKeyValuesMutationResponse>;
  /** insert a single row into the table: "quay_key_values" */
  stops_database_insert_quay_key_values_one?: Maybe<StopsDatabaseQuayKeyValues>;
  /** insert a single row into the table: "quay" */
  stops_database_insert_quay_one?: Maybe<StopsDatabaseQuay>;
  /** insert data into the table: "schema_version" */
  stops_database_insert_schema_version?: Maybe<StopsDatabaseSchemaVersionMutationResponse>;
  /** insert a single row into the table: "schema_version" */
  stops_database_insert_schema_version_one?: Maybe<StopsDatabaseSchemaVersion>;
  /** insert data into the table: "spatial_ref_sys" */
  stops_database_insert_spatial_ref_sys?: Maybe<StopsDatabaseSpatialRefSysMutationResponse>;
  /** insert a single row into the table: "spatial_ref_sys" */
  stops_database_insert_spatial_ref_sys_one?: Maybe<StopsDatabaseSpatialRefSys>;
  /** insert data into the table: "stop_place" */
  stops_database_insert_stop_place?: Maybe<StopsDatabaseStopPlaceMutationResponse>;
  /** insert data into the table: "stop_place_access_spaces" */
  stops_database_insert_stop_place_access_spaces?: Maybe<StopsDatabaseStopPlaceAccessSpacesMutationResponse>;
  /** insert a single row into the table: "stop_place_access_spaces" */
  stops_database_insert_stop_place_access_spaces_one?: Maybe<StopsDatabaseStopPlaceAccessSpaces>;
  /** insert data into the table: "stop_place_adjacent_sites" */
  stops_database_insert_stop_place_adjacent_sites?: Maybe<StopsDatabaseStopPlaceAdjacentSitesMutationResponse>;
  /** insert a single row into the table: "stop_place_adjacent_sites" */
  stops_database_insert_stop_place_adjacent_sites_one?: Maybe<StopsDatabaseStopPlaceAdjacentSites>;
  /** insert data into the table: "stop_place_alternative_names" */
  stops_database_insert_stop_place_alternative_names?: Maybe<StopsDatabaseStopPlaceAlternativeNamesMutationResponse>;
  /** insert a single row into the table: "stop_place_alternative_names" */
  stops_database_insert_stop_place_alternative_names_one?: Maybe<StopsDatabaseStopPlaceAlternativeNames>;
  /** insert data into the table: "stop_place_children" */
  stops_database_insert_stop_place_children?: Maybe<StopsDatabaseStopPlaceChildrenMutationResponse>;
  /** insert a single row into the table: "stop_place_children" */
  stops_database_insert_stop_place_children_one?: Maybe<StopsDatabaseStopPlaceChildren>;
  /** insert data into the table: "stop_place_equipment_places" */
  stops_database_insert_stop_place_equipment_places?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesMutationResponse>;
  /** insert a single row into the table: "stop_place_equipment_places" */
  stops_database_insert_stop_place_equipment_places_one?: Maybe<StopsDatabaseStopPlaceEquipmentPlaces>;
  /** insert data into the table: "stop_place_key_values" */
  stops_database_insert_stop_place_key_values?: Maybe<StopsDatabaseStopPlaceKeyValuesMutationResponse>;
  /** insert a single row into the table: "stop_place_key_values" */
  stops_database_insert_stop_place_key_values_one?: Maybe<StopsDatabaseStopPlaceKeyValues>;
  /** insert a single row into the table: "stop_place" */
  stops_database_insert_stop_place_one?: Maybe<StopsDatabaseStopPlace>;
  /** insert data into the table: "stop_place_quays" */
  stops_database_insert_stop_place_quays?: Maybe<StopsDatabaseStopPlaceQuaysMutationResponse>;
  /** insert a single row into the table: "stop_place_quays" */
  stops_database_insert_stop_place_quays_one?: Maybe<StopsDatabaseStopPlaceQuays>;
  /** insert data into the table: "stop_place_tariff_zones" */
  stops_database_insert_stop_place_tariff_zones?: Maybe<StopsDatabaseStopPlaceTariffZonesMutationResponse>;
  /** insert a single row into the table: "stop_place_tariff_zones" */
  stops_database_insert_stop_place_tariff_zones_one?: Maybe<StopsDatabaseStopPlaceTariffZones>;
  /** insert data into the table: "tag" */
  stops_database_insert_tag?: Maybe<StopsDatabaseTagMutationResponse>;
  /** insert a single row into the table: "tag" */
  stops_database_insert_tag_one?: Maybe<StopsDatabaseTag>;
  /** insert data into the table: "tariff_zone" */
  stops_database_insert_tariff_zone?: Maybe<StopsDatabaseTariffZoneMutationResponse>;
  /** insert data into the table: "tariff_zone_key_values" */
  stops_database_insert_tariff_zone_key_values?: Maybe<StopsDatabaseTariffZoneKeyValuesMutationResponse>;
  /** insert a single row into the table: "tariff_zone_key_values" */
  stops_database_insert_tariff_zone_key_values_one?: Maybe<StopsDatabaseTariffZoneKeyValues>;
  /** insert a single row into the table: "tariff_zone" */
  stops_database_insert_tariff_zone_one?: Maybe<StopsDatabaseTariffZone>;
  /** insert data into the table: "topographic_place" */
  stops_database_insert_topographic_place?: Maybe<StopsDatabaseTopographicPlaceMutationResponse>;
  /** insert data into the table: "topographic_place_key_values" */
  stops_database_insert_topographic_place_key_values?: Maybe<StopsDatabaseTopographicPlaceKeyValuesMutationResponse>;
  /** insert a single row into the table: "topographic_place_key_values" */
  stops_database_insert_topographic_place_key_values_one?: Maybe<StopsDatabaseTopographicPlaceKeyValues>;
  /** insert a single row into the table: "topographic_place" */
  stops_database_insert_topographic_place_one?: Maybe<StopsDatabaseTopographicPlace>;
  /** insert data into the table: "value" */
  stops_database_insert_value?: Maybe<StopsDatabaseValueMutationResponse>;
  /** insert data into the table: "value_items" */
  stops_database_insert_value_items?: Maybe<StopsDatabaseValueItemsMutationResponse>;
  /** insert a single row into the table: "value_items" */
  stops_database_insert_value_items_one?: Maybe<StopsDatabaseValueItems>;
  /** insert a single row into the table: "value" */
  stops_database_insert_value_one?: Maybe<StopsDatabaseValue>;
  /** update data of the table: "access_space" */
  stops_database_update_access_space?: Maybe<StopsDatabaseAccessSpaceMutationResponse>;
  /** update data of the table: "access_space_alternative_names" */
  stops_database_update_access_space_alternative_names?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesMutationResponse>;
  /** update multiples rows of table: "access_space_alternative_names" */
  stops_database_update_access_space_alternative_names_many?: Maybe<
    Array<Maybe<StopsDatabaseAccessSpaceAlternativeNamesMutationResponse>>
  >;
  /** update single row of the table: "access_space" */
  stops_database_update_access_space_by_pk?: Maybe<StopsDatabaseAccessSpace>;
  /** update data of the table: "access_space_check_constraints" */
  stops_database_update_access_space_check_constraints?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsMutationResponse>;
  /** update multiples rows of table: "access_space_check_constraints" */
  stops_database_update_access_space_check_constraints_many?: Maybe<
    Array<Maybe<StopsDatabaseAccessSpaceCheckConstraintsMutationResponse>>
  >;
  /** update data of the table: "access_space_equipment_places" */
  stops_database_update_access_space_equipment_places?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesMutationResponse>;
  /** update multiples rows of table: "access_space_equipment_places" */
  stops_database_update_access_space_equipment_places_many?: Maybe<
    Array<Maybe<StopsDatabaseAccessSpaceEquipmentPlacesMutationResponse>>
  >;
  /** update data of the table: "access_space_key_values" */
  stops_database_update_access_space_key_values?: Maybe<StopsDatabaseAccessSpaceKeyValuesMutationResponse>;
  /** update single row of the table: "access_space_key_values" */
  stops_database_update_access_space_key_values_by_pk?: Maybe<StopsDatabaseAccessSpaceKeyValues>;
  /** update multiples rows of table: "access_space_key_values" */
  stops_database_update_access_space_key_values_many?: Maybe<
    Array<Maybe<StopsDatabaseAccessSpaceKeyValuesMutationResponse>>
  >;
  /** update multiples rows of table: "access_space" */
  stops_database_update_access_space_many?: Maybe<
    Array<Maybe<StopsDatabaseAccessSpaceMutationResponse>>
  >;
  /** update data of the table: "accessibility_assessment" */
  stops_database_update_accessibility_assessment?: Maybe<StopsDatabaseAccessibilityAssessmentMutationResponse>;
  /** update single row of the table: "accessibility_assessment" */
  stops_database_update_accessibility_assessment_by_pk?: Maybe<StopsDatabaseAccessibilityAssessment>;
  /** update data of the table: "accessibility_assessment_limitations" */
  stops_database_update_accessibility_assessment_limitations?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsMutationResponse>;
  /** update multiples rows of table: "accessibility_assessment_limitations" */
  stops_database_update_accessibility_assessment_limitations_many?: Maybe<
    Array<
      Maybe<StopsDatabaseAccessibilityAssessmentLimitationsMutationResponse>
    >
  >;
  /** update multiples rows of table: "accessibility_assessment" */
  stops_database_update_accessibility_assessment_many?: Maybe<
    Array<Maybe<StopsDatabaseAccessibilityAssessmentMutationResponse>>
  >;
  /** update data of the table: "accessibility_limitation" */
  stops_database_update_accessibility_limitation?: Maybe<StopsDatabaseAccessibilityLimitationMutationResponse>;
  /** update single row of the table: "accessibility_limitation" */
  stops_database_update_accessibility_limitation_by_pk?: Maybe<StopsDatabaseAccessibilityLimitation>;
  /** update multiples rows of table: "accessibility_limitation" */
  stops_database_update_accessibility_limitation_many?: Maybe<
    Array<Maybe<StopsDatabaseAccessibilityLimitationMutationResponse>>
  >;
  /** update data of the table: "alternative_name" */
  stops_database_update_alternative_name?: Maybe<StopsDatabaseAlternativeNameMutationResponse>;
  /** update single row of the table: "alternative_name" */
  stops_database_update_alternative_name_by_pk?: Maybe<StopsDatabaseAlternativeName>;
  /** update multiples rows of table: "alternative_name" */
  stops_database_update_alternative_name_many?: Maybe<
    Array<Maybe<StopsDatabaseAlternativeNameMutationResponse>>
  >;
  /** update data of the table: "boarding_position" */
  stops_database_update_boarding_position?: Maybe<StopsDatabaseBoardingPositionMutationResponse>;
  /** update data of the table: "boarding_position_alternative_names" */
  stops_database_update_boarding_position_alternative_names?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesMutationResponse>;
  /** update multiples rows of table: "boarding_position_alternative_names" */
  stops_database_update_boarding_position_alternative_names_many?: Maybe<
    Array<Maybe<StopsDatabaseBoardingPositionAlternativeNamesMutationResponse>>
  >;
  /** update single row of the table: "boarding_position" */
  stops_database_update_boarding_position_by_pk?: Maybe<StopsDatabaseBoardingPosition>;
  /** update data of the table: "boarding_position_check_constraints" */
  stops_database_update_boarding_position_check_constraints?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsMutationResponse>;
  /** update multiples rows of table: "boarding_position_check_constraints" */
  stops_database_update_boarding_position_check_constraints_many?: Maybe<
    Array<Maybe<StopsDatabaseBoardingPositionCheckConstraintsMutationResponse>>
  >;
  /** update data of the table: "boarding_position_equipment_places" */
  stops_database_update_boarding_position_equipment_places?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesMutationResponse>;
  /** update multiples rows of table: "boarding_position_equipment_places" */
  stops_database_update_boarding_position_equipment_places_many?: Maybe<
    Array<Maybe<StopsDatabaseBoardingPositionEquipmentPlacesMutationResponse>>
  >;
  /** update data of the table: "boarding_position_key_values" */
  stops_database_update_boarding_position_key_values?: Maybe<StopsDatabaseBoardingPositionKeyValuesMutationResponse>;
  /** update single row of the table: "boarding_position_key_values" */
  stops_database_update_boarding_position_key_values_by_pk?: Maybe<StopsDatabaseBoardingPositionKeyValues>;
  /** update multiples rows of table: "boarding_position_key_values" */
  stops_database_update_boarding_position_key_values_many?: Maybe<
    Array<Maybe<StopsDatabaseBoardingPositionKeyValuesMutationResponse>>
  >;
  /** update multiples rows of table: "boarding_position" */
  stops_database_update_boarding_position_many?: Maybe<
    Array<Maybe<StopsDatabaseBoardingPositionMutationResponse>>
  >;
  /** update data of the table: "check_constraint" */
  stops_database_update_check_constraint?: Maybe<StopsDatabaseCheckConstraintMutationResponse>;
  /** update single row of the table: "check_constraint" */
  stops_database_update_check_constraint_by_pk?: Maybe<StopsDatabaseCheckConstraint>;
  /** update data of the table: "check_constraint_key_values" */
  stops_database_update_check_constraint_key_values?: Maybe<StopsDatabaseCheckConstraintKeyValuesMutationResponse>;
  /** update single row of the table: "check_constraint_key_values" */
  stops_database_update_check_constraint_key_values_by_pk?: Maybe<StopsDatabaseCheckConstraintKeyValues>;
  /** update multiples rows of table: "check_constraint_key_values" */
  stops_database_update_check_constraint_key_values_many?: Maybe<
    Array<Maybe<StopsDatabaseCheckConstraintKeyValuesMutationResponse>>
  >;
  /** update multiples rows of table: "check_constraint" */
  stops_database_update_check_constraint_many?: Maybe<
    Array<Maybe<StopsDatabaseCheckConstraintMutationResponse>>
  >;
  /** update data of the table: "destination_display_view" */
  stops_database_update_destination_display_view?: Maybe<StopsDatabaseDestinationDisplayViewMutationResponse>;
  /** update single row of the table: "destination_display_view" */
  stops_database_update_destination_display_view_by_pk?: Maybe<StopsDatabaseDestinationDisplayView>;
  /** update multiples rows of table: "destination_display_view" */
  stops_database_update_destination_display_view_many?: Maybe<
    Array<Maybe<StopsDatabaseDestinationDisplayViewMutationResponse>>
  >;
  /** update data of the table: "equipment_place" */
  stops_database_update_equipment_place?: Maybe<StopsDatabaseEquipmentPlaceMutationResponse>;
  /** update single row of the table: "equipment_place" */
  stops_database_update_equipment_place_by_pk?: Maybe<StopsDatabaseEquipmentPlace>;
  /** update data of the table: "equipment_place_equipment_positions" */
  stops_database_update_equipment_place_equipment_positions?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsMutationResponse>;
  /** update multiples rows of table: "equipment_place_equipment_positions" */
  stops_database_update_equipment_place_equipment_positions_many?: Maybe<
    Array<Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsMutationResponse>>
  >;
  /** update data of the table: "equipment_place_key_values" */
  stops_database_update_equipment_place_key_values?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesMutationResponse>;
  /** update single row of the table: "equipment_place_key_values" */
  stops_database_update_equipment_place_key_values_by_pk?: Maybe<StopsDatabaseEquipmentPlaceKeyValues>;
  /** update multiples rows of table: "equipment_place_key_values" */
  stops_database_update_equipment_place_key_values_many?: Maybe<
    Array<Maybe<StopsDatabaseEquipmentPlaceKeyValuesMutationResponse>>
  >;
  /** update multiples rows of table: "equipment_place" */
  stops_database_update_equipment_place_many?: Maybe<
    Array<Maybe<StopsDatabaseEquipmentPlaceMutationResponse>>
  >;
  /** update data of the table: "equipment_position" */
  stops_database_update_equipment_position?: Maybe<StopsDatabaseEquipmentPositionMutationResponse>;
  /** update single row of the table: "equipment_position" */
  stops_database_update_equipment_position_by_pk?: Maybe<StopsDatabaseEquipmentPosition>;
  /** update data of the table: "equipment_position_key_values" */
  stops_database_update_equipment_position_key_values?: Maybe<StopsDatabaseEquipmentPositionKeyValuesMutationResponse>;
  /** update single row of the table: "equipment_position_key_values" */
  stops_database_update_equipment_position_key_values_by_pk?: Maybe<StopsDatabaseEquipmentPositionKeyValues>;
  /** update multiples rows of table: "equipment_position_key_values" */
  stops_database_update_equipment_position_key_values_many?: Maybe<
    Array<Maybe<StopsDatabaseEquipmentPositionKeyValuesMutationResponse>>
  >;
  /** update multiples rows of table: "equipment_position" */
  stops_database_update_equipment_position_many?: Maybe<
    Array<Maybe<StopsDatabaseEquipmentPositionMutationResponse>>
  >;
  /** update data of the table: "export_job" */
  stops_database_update_export_job?: Maybe<StopsDatabaseExportJobMutationResponse>;
  /** update single row of the table: "export_job" */
  stops_database_update_export_job_by_pk?: Maybe<StopsDatabaseExportJob>;
  /** update multiples rows of table: "export_job" */
  stops_database_update_export_job_many?: Maybe<
    Array<Maybe<StopsDatabaseExportJobMutationResponse>>
  >;
  /** update data of the table: "fare_zone" */
  stops_database_update_fare_zone?: Maybe<StopsDatabaseFareZoneMutationResponse>;
  /** update single row of the table: "fare_zone" */
  stops_database_update_fare_zone_by_pk?: Maybe<StopsDatabaseFareZone>;
  /** update data of the table: "fare_zone_key_values" */
  stops_database_update_fare_zone_key_values?: Maybe<StopsDatabaseFareZoneKeyValuesMutationResponse>;
  /** update single row of the table: "fare_zone_key_values" */
  stops_database_update_fare_zone_key_values_by_pk?: Maybe<StopsDatabaseFareZoneKeyValues>;
  /** update multiples rows of table: "fare_zone_key_values" */
  stops_database_update_fare_zone_key_values_many?: Maybe<
    Array<Maybe<StopsDatabaseFareZoneKeyValuesMutationResponse>>
  >;
  /** update multiples rows of table: "fare_zone" */
  stops_database_update_fare_zone_many?: Maybe<
    Array<Maybe<StopsDatabaseFareZoneMutationResponse>>
  >;
  /** update data of the table: "fare_zone_members" */
  stops_database_update_fare_zone_members?: Maybe<StopsDatabaseFareZoneMembersMutationResponse>;
  /** update multiples rows of table: "fare_zone_members" */
  stops_database_update_fare_zone_members_many?: Maybe<
    Array<Maybe<StopsDatabaseFareZoneMembersMutationResponse>>
  >;
  /** update data of the table: "fare_zone_neighbours" */
  stops_database_update_fare_zone_neighbours?: Maybe<StopsDatabaseFareZoneNeighboursMutationResponse>;
  /** update multiples rows of table: "fare_zone_neighbours" */
  stops_database_update_fare_zone_neighbours_many?: Maybe<
    Array<Maybe<StopsDatabaseFareZoneNeighboursMutationResponse>>
  >;
  /** update data of the table: "geometry_columns" */
  stops_database_update_geometry_columns?: Maybe<StopsDatabaseGeometryColumnsMutationResponse>;
  /** update multiples rows of table: "geometry_columns" */
  stops_database_update_geometry_columns_many?: Maybe<
    Array<Maybe<StopsDatabaseGeometryColumnsMutationResponse>>
  >;
  /** update data of the table: "group_of_stop_places" */
  stops_database_update_group_of_stop_places?: Maybe<StopsDatabaseGroupOfStopPlacesMutationResponse>;
  /** update data of the table: "group_of_stop_places_alternative_names" */
  stops_database_update_group_of_stop_places_alternative_names?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesMutationResponse>;
  /** update multiples rows of table: "group_of_stop_places_alternative_names" */
  stops_database_update_group_of_stop_places_alternative_names_many?: Maybe<
    Array<Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesMutationResponse>>
  >;
  /** update single row of the table: "group_of_stop_places" */
  stops_database_update_group_of_stop_places_by_pk?: Maybe<StopsDatabaseGroupOfStopPlaces>;
  /** update data of the table: "group_of_stop_places_key_values" */
  stops_database_update_group_of_stop_places_key_values?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesMutationResponse>;
  /** update single row of the table: "group_of_stop_places_key_values" */
  stops_database_update_group_of_stop_places_key_values_by_pk?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValues>;
  /** update multiples rows of table: "group_of_stop_places_key_values" */
  stops_database_update_group_of_stop_places_key_values_many?: Maybe<
    Array<Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesMutationResponse>>
  >;
  /** update multiples rows of table: "group_of_stop_places" */
  stops_database_update_group_of_stop_places_many?: Maybe<
    Array<Maybe<StopsDatabaseGroupOfStopPlacesMutationResponse>>
  >;
  /** update data of the table: "group_of_stop_places_members" */
  stops_database_update_group_of_stop_places_members?: Maybe<StopsDatabaseGroupOfStopPlacesMembersMutationResponse>;
  /** update multiples rows of table: "group_of_stop_places_members" */
  stops_database_update_group_of_stop_places_members_many?: Maybe<
    Array<Maybe<StopsDatabaseGroupOfStopPlacesMembersMutationResponse>>
  >;
  /** update data of the table: "group_of_tariff_zones" */
  stops_database_update_group_of_tariff_zones?: Maybe<StopsDatabaseGroupOfTariffZonesMutationResponse>;
  /** update single row of the table: "group_of_tariff_zones" */
  stops_database_update_group_of_tariff_zones_by_pk?: Maybe<StopsDatabaseGroupOfTariffZones>;
  /** update data of the table: "group_of_tariff_zones_key_values" */
  stops_database_update_group_of_tariff_zones_key_values?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesMutationResponse>;
  /** update single row of the table: "group_of_tariff_zones_key_values" */
  stops_database_update_group_of_tariff_zones_key_values_by_pk?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValues>;
  /** update multiples rows of table: "group_of_tariff_zones_key_values" */
  stops_database_update_group_of_tariff_zones_key_values_many?: Maybe<
    Array<Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesMutationResponse>>
  >;
  /** update multiples rows of table: "group_of_tariff_zones" */
  stops_database_update_group_of_tariff_zones_many?: Maybe<
    Array<Maybe<StopsDatabaseGroupOfTariffZonesMutationResponse>>
  >;
  /** update data of the table: "group_of_tariff_zones_members" */
  stops_database_update_group_of_tariff_zones_members?: Maybe<StopsDatabaseGroupOfTariffZonesMembersMutationResponse>;
  /** update single row of the table: "group_of_tariff_zones_members" */
  stops_database_update_group_of_tariff_zones_members_by_pk?: Maybe<StopsDatabaseGroupOfTariffZonesMembers>;
  /** update multiples rows of table: "group_of_tariff_zones_members" */
  stops_database_update_group_of_tariff_zones_members_many?: Maybe<
    Array<Maybe<StopsDatabaseGroupOfTariffZonesMembersMutationResponse>>
  >;
  /** update data of the table: "id_generator" */
  stops_database_update_id_generator?: Maybe<StopsDatabaseIdGeneratorMutationResponse>;
  /** update multiples rows of table: "id_generator" */
  stops_database_update_id_generator_many?: Maybe<
    Array<Maybe<StopsDatabaseIdGeneratorMutationResponse>>
  >;
  /** update data of the table: "installed_equipment" */
  stops_database_update_installed_equipment?: Maybe<StopsDatabaseInstalledEquipmentMutationResponse>;
  /** update multiples rows of table: "installed_equipment" */
  stops_database_update_installed_equipment_many?: Maybe<
    Array<Maybe<StopsDatabaseInstalledEquipmentMutationResponse>>
  >;
  /** update data of the table: "installed_equipment_version_structure" */
  stops_database_update_installed_equipment_version_structure?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureMutationResponse>;
  /** update single row of the table: "installed_equipment_version_structure" */
  stops_database_update_installed_equipment_version_structure_by_pk?: Maybe<StopsDatabaseInstalledEquipmentVersionStructure>;
  /** update data of the table: "installed_equipment_version_structure_installed_equipment" */
  stops_database_update_installed_equipment_version_structure_installed_equipment?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMutationResponse>;
  /** update multiples rows of table: "installed_equipment_version_structure_installed_equipment" */
  stops_database_update_installed_equipment_version_structure_installed_equipment_many?: Maybe<
    Array<
      Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMutationResponse>
    >
  >;
  /** update multiples rows of table: "installed_equipment_version_structure" */
  stops_database_update_installed_equipment_version_structure_many?: Maybe<
    Array<
      Maybe<StopsDatabaseInstalledEquipmentVersionStructureMutationResponse>
    >
  >;
  /** update data of the table: "level" */
  stops_database_update_level?: Maybe<StopsDatabaseLevelMutationResponse>;
  /** update single row of the table: "level" */
  stops_database_update_level_by_pk?: Maybe<StopsDatabaseLevel>;
  /** update data of the table: "level_key_values" */
  stops_database_update_level_key_values?: Maybe<StopsDatabaseLevelKeyValuesMutationResponse>;
  /** update single row of the table: "level_key_values" */
  stops_database_update_level_key_values_by_pk?: Maybe<StopsDatabaseLevelKeyValues>;
  /** update multiples rows of table: "level_key_values" */
  stops_database_update_level_key_values_many?: Maybe<
    Array<Maybe<StopsDatabaseLevelKeyValuesMutationResponse>>
  >;
  /** update multiples rows of table: "level" */
  stops_database_update_level_many?: Maybe<
    Array<Maybe<StopsDatabaseLevelMutationResponse>>
  >;
  /** update data of the table: "multilingual_string_entity" */
  stops_database_update_multilingual_string_entity?: Maybe<StopsDatabaseMultilingualStringEntityMutationResponse>;
  /** update single row of the table: "multilingual_string_entity" */
  stops_database_update_multilingual_string_entity_by_pk?: Maybe<StopsDatabaseMultilingualStringEntity>;
  /** update multiples rows of table: "multilingual_string_entity" */
  stops_database_update_multilingual_string_entity_many?: Maybe<
    Array<Maybe<StopsDatabaseMultilingualStringEntityMutationResponse>>
  >;
  /** update data of the table: "navigation_path" */
  stops_database_update_navigation_path?: Maybe<StopsDatabaseNavigationPathMutationResponse>;
  /** update multiples rows of table: "navigation_path" */
  stops_database_update_navigation_path_many?: Maybe<
    Array<Maybe<StopsDatabaseNavigationPathMutationResponse>>
  >;
  /** update data of the table: "parking" */
  stops_database_update_parking?: Maybe<StopsDatabaseParkingMutationResponse>;
  /** update data of the table: "parking_adjacent_sites" */
  stops_database_update_parking_adjacent_sites?: Maybe<StopsDatabaseParkingAdjacentSitesMutationResponse>;
  /** update multiples rows of table: "parking_adjacent_sites" */
  stops_database_update_parking_adjacent_sites_many?: Maybe<
    Array<Maybe<StopsDatabaseParkingAdjacentSitesMutationResponse>>
  >;
  /** update data of the table: "parking_alternative_names" */
  stops_database_update_parking_alternative_names?: Maybe<StopsDatabaseParkingAlternativeNamesMutationResponse>;
  /** update multiples rows of table: "parking_alternative_names" */
  stops_database_update_parking_alternative_names_many?: Maybe<
    Array<Maybe<StopsDatabaseParkingAlternativeNamesMutationResponse>>
  >;
  /** update data of the table: "parking_area" */
  stops_database_update_parking_area?: Maybe<StopsDatabaseParkingAreaMutationResponse>;
  /** update data of the table: "parking_area_alternative_names" */
  stops_database_update_parking_area_alternative_names?: Maybe<StopsDatabaseParkingAreaAlternativeNamesMutationResponse>;
  /** update multiples rows of table: "parking_area_alternative_names" */
  stops_database_update_parking_area_alternative_names_many?: Maybe<
    Array<Maybe<StopsDatabaseParkingAreaAlternativeNamesMutationResponse>>
  >;
  /** update single row of the table: "parking_area" */
  stops_database_update_parking_area_by_pk?: Maybe<StopsDatabaseParkingArea>;
  /** update data of the table: "parking_area_check_constraints" */
  stops_database_update_parking_area_check_constraints?: Maybe<StopsDatabaseParkingAreaCheckConstraintsMutationResponse>;
  /** update multiples rows of table: "parking_area_check_constraints" */
  stops_database_update_parking_area_check_constraints_many?: Maybe<
    Array<Maybe<StopsDatabaseParkingAreaCheckConstraintsMutationResponse>>
  >;
  /** update data of the table: "parking_area_equipment_places" */
  stops_database_update_parking_area_equipment_places?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesMutationResponse>;
  /** update multiples rows of table: "parking_area_equipment_places" */
  stops_database_update_parking_area_equipment_places_many?: Maybe<
    Array<Maybe<StopsDatabaseParkingAreaEquipmentPlacesMutationResponse>>
  >;
  /** update data of the table: "parking_area_key_values" */
  stops_database_update_parking_area_key_values?: Maybe<StopsDatabaseParkingAreaKeyValuesMutationResponse>;
  /** update single row of the table: "parking_area_key_values" */
  stops_database_update_parking_area_key_values_by_pk?: Maybe<StopsDatabaseParkingAreaKeyValues>;
  /** update multiples rows of table: "parking_area_key_values" */
  stops_database_update_parking_area_key_values_many?: Maybe<
    Array<Maybe<StopsDatabaseParkingAreaKeyValuesMutationResponse>>
  >;
  /** update multiples rows of table: "parking_area" */
  stops_database_update_parking_area_many?: Maybe<
    Array<Maybe<StopsDatabaseParkingAreaMutationResponse>>
  >;
  /** update single row of the table: "parking" */
  stops_database_update_parking_by_pk?: Maybe<StopsDatabaseParking>;
  /** update data of the table: "parking_capacity" */
  stops_database_update_parking_capacity?: Maybe<StopsDatabaseParkingCapacityMutationResponse>;
  /** update single row of the table: "parking_capacity" */
  stops_database_update_parking_capacity_by_pk?: Maybe<StopsDatabaseParkingCapacity>;
  /** update multiples rows of table: "parking_capacity" */
  stops_database_update_parking_capacity_many?: Maybe<
    Array<Maybe<StopsDatabaseParkingCapacityMutationResponse>>
  >;
  /** update data of the table: "parking_equipment_places" */
  stops_database_update_parking_equipment_places?: Maybe<StopsDatabaseParkingEquipmentPlacesMutationResponse>;
  /** update multiples rows of table: "parking_equipment_places" */
  stops_database_update_parking_equipment_places_many?: Maybe<
    Array<Maybe<StopsDatabaseParkingEquipmentPlacesMutationResponse>>
  >;
  /** update data of the table: "parking_key_values" */
  stops_database_update_parking_key_values?: Maybe<StopsDatabaseParkingKeyValuesMutationResponse>;
  /** update single row of the table: "parking_key_values" */
  stops_database_update_parking_key_values_by_pk?: Maybe<StopsDatabaseParkingKeyValues>;
  /** update multiples rows of table: "parking_key_values" */
  stops_database_update_parking_key_values_many?: Maybe<
    Array<Maybe<StopsDatabaseParkingKeyValuesMutationResponse>>
  >;
  /** update multiples rows of table: "parking" */
  stops_database_update_parking_many?: Maybe<
    Array<Maybe<StopsDatabaseParkingMutationResponse>>
  >;
  /** update data of the table: "parking_parking_areas" */
  stops_database_update_parking_parking_areas?: Maybe<StopsDatabaseParkingParkingAreasMutationResponse>;
  /** update multiples rows of table: "parking_parking_areas" */
  stops_database_update_parking_parking_areas_many?: Maybe<
    Array<Maybe<StopsDatabaseParkingParkingAreasMutationResponse>>
  >;
  /** update data of the table: "parking_parking_payment_process" */
  stops_database_update_parking_parking_payment_process?: Maybe<StopsDatabaseParkingParkingPaymentProcessMutationResponse>;
  /** update multiples rows of table: "parking_parking_payment_process" */
  stops_database_update_parking_parking_payment_process_many?: Maybe<
    Array<Maybe<StopsDatabaseParkingParkingPaymentProcessMutationResponse>>
  >;
  /** update data of the table: "parking_parking_properties" */
  stops_database_update_parking_parking_properties?: Maybe<StopsDatabaseParkingParkingPropertiesMutationResponse>;
  /** update multiples rows of table: "parking_parking_properties" */
  stops_database_update_parking_parking_properties_many?: Maybe<
    Array<Maybe<StopsDatabaseParkingParkingPropertiesMutationResponse>>
  >;
  /** update data of the table: "parking_parking_vehicle_types" */
  stops_database_update_parking_parking_vehicle_types?: Maybe<StopsDatabaseParkingParkingVehicleTypesMutationResponse>;
  /** update multiples rows of table: "parking_parking_vehicle_types" */
  stops_database_update_parking_parking_vehicle_types_many?: Maybe<
    Array<Maybe<StopsDatabaseParkingParkingVehicleTypesMutationResponse>>
  >;
  /** update data of the table: "parking_properties" */
  stops_database_update_parking_properties?: Maybe<StopsDatabaseParkingPropertiesMutationResponse>;
  /** update single row of the table: "parking_properties" */
  stops_database_update_parking_properties_by_pk?: Maybe<StopsDatabaseParkingProperties>;
  /** update multiples rows of table: "parking_properties" */
  stops_database_update_parking_properties_many?: Maybe<
    Array<Maybe<StopsDatabaseParkingPropertiesMutationResponse>>
  >;
  /** update data of the table: "parking_properties_parking_user_types" */
  stops_database_update_parking_properties_parking_user_types?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesMutationResponse>;
  /** update multiples rows of table: "parking_properties_parking_user_types" */
  stops_database_update_parking_properties_parking_user_types_many?: Maybe<
    Array<Maybe<StopsDatabaseParkingPropertiesParkingUserTypesMutationResponse>>
  >;
  /** update data of the table: "parking_properties_spaces" */
  stops_database_update_parking_properties_spaces?: Maybe<StopsDatabaseParkingPropertiesSpacesMutationResponse>;
  /** update multiples rows of table: "parking_properties_spaces" */
  stops_database_update_parking_properties_spaces_many?: Maybe<
    Array<Maybe<StopsDatabaseParkingPropertiesSpacesMutationResponse>>
  >;
  /** update data of the table: "path_junction" */
  stops_database_update_path_junction?: Maybe<StopsDatabasePathJunctionMutationResponse>;
  /** update single row of the table: "path_junction" */
  stops_database_update_path_junction_by_pk?: Maybe<StopsDatabasePathJunction>;
  /** update data of the table: "path_junction_key_values" */
  stops_database_update_path_junction_key_values?: Maybe<StopsDatabasePathJunctionKeyValuesMutationResponse>;
  /** update single row of the table: "path_junction_key_values" */
  stops_database_update_path_junction_key_values_by_pk?: Maybe<StopsDatabasePathJunctionKeyValues>;
  /** update multiples rows of table: "path_junction_key_values" */
  stops_database_update_path_junction_key_values_many?: Maybe<
    Array<Maybe<StopsDatabasePathJunctionKeyValuesMutationResponse>>
  >;
  /** update multiples rows of table: "path_junction" */
  stops_database_update_path_junction_many?: Maybe<
    Array<Maybe<StopsDatabasePathJunctionMutationResponse>>
  >;
  /** update data of the table: "path_link" */
  stops_database_update_path_link?: Maybe<StopsDatabasePathLinkMutationResponse>;
  /** update single row of the table: "path_link" */
  stops_database_update_path_link_by_pk?: Maybe<StopsDatabasePathLink>;
  /** update data of the table: "path_link_end" */
  stops_database_update_path_link_end?: Maybe<StopsDatabasePathLinkEndMutationResponse>;
  /** update single row of the table: "path_link_end" */
  stops_database_update_path_link_end_by_pk?: Maybe<StopsDatabasePathLinkEnd>;
  /** update multiples rows of table: "path_link_end" */
  stops_database_update_path_link_end_many?: Maybe<
    Array<Maybe<StopsDatabasePathLinkEndMutationResponse>>
  >;
  /** update data of the table: "path_link_key_values" */
  stops_database_update_path_link_key_values?: Maybe<StopsDatabasePathLinkKeyValuesMutationResponse>;
  /** update single row of the table: "path_link_key_values" */
  stops_database_update_path_link_key_values_by_pk?: Maybe<StopsDatabasePathLinkKeyValues>;
  /** update multiples rows of table: "path_link_key_values" */
  stops_database_update_path_link_key_values_many?: Maybe<
    Array<Maybe<StopsDatabasePathLinkKeyValuesMutationResponse>>
  >;
  /** update multiples rows of table: "path_link" */
  stops_database_update_path_link_many?: Maybe<
    Array<Maybe<StopsDatabasePathLinkMutationResponse>>
  >;
  /** update data of the table: "persistable_polygon" */
  stops_database_update_persistable_polygon?: Maybe<StopsDatabasePersistablePolygonMutationResponse>;
  /** update single row of the table: "persistable_polygon" */
  stops_database_update_persistable_polygon_by_pk?: Maybe<StopsDatabasePersistablePolygon>;
  /** update multiples rows of table: "persistable_polygon" */
  stops_database_update_persistable_polygon_many?: Maybe<
    Array<Maybe<StopsDatabasePersistablePolygonMutationResponse>>
  >;
  /** update data of the table: "purpose_of_grouping" */
  stops_database_update_purpose_of_grouping?: Maybe<StopsDatabasePurposeOfGroupingMutationResponse>;
  /** update single row of the table: "purpose_of_grouping" */
  stops_database_update_purpose_of_grouping_by_pk?: Maybe<StopsDatabasePurposeOfGrouping>;
  /** update data of the table: "purpose_of_grouping_key_values" */
  stops_database_update_purpose_of_grouping_key_values?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesMutationResponse>;
  /** update single row of the table: "purpose_of_grouping_key_values" */
  stops_database_update_purpose_of_grouping_key_values_by_pk?: Maybe<StopsDatabasePurposeOfGroupingKeyValues>;
  /** update multiples rows of table: "purpose_of_grouping_key_values" */
  stops_database_update_purpose_of_grouping_key_values_many?: Maybe<
    Array<Maybe<StopsDatabasePurposeOfGroupingKeyValuesMutationResponse>>
  >;
  /** update multiples rows of table: "purpose_of_grouping" */
  stops_database_update_purpose_of_grouping_many?: Maybe<
    Array<Maybe<StopsDatabasePurposeOfGroupingMutationResponse>>
  >;
  /** update data of the table: "quay" */
  stops_database_update_quay?: Maybe<StopsDatabaseQuayMutationResponse>;
  /** update data of the table: "quay_alternative_names" */
  stops_database_update_quay_alternative_names?: Maybe<StopsDatabaseQuayAlternativeNamesMutationResponse>;
  /** update multiples rows of table: "quay_alternative_names" */
  stops_database_update_quay_alternative_names_many?: Maybe<
    Array<Maybe<StopsDatabaseQuayAlternativeNamesMutationResponse>>
  >;
  /** update data of the table: "quay_boarding_positions" */
  stops_database_update_quay_boarding_positions?: Maybe<StopsDatabaseQuayBoardingPositionsMutationResponse>;
  /** update multiples rows of table: "quay_boarding_positions" */
  stops_database_update_quay_boarding_positions_many?: Maybe<
    Array<Maybe<StopsDatabaseQuayBoardingPositionsMutationResponse>>
  >;
  /** update single row of the table: "quay" */
  stops_database_update_quay_by_pk?: Maybe<StopsDatabaseQuay>;
  /** update data of the table: "quay_check_constraints" */
  stops_database_update_quay_check_constraints?: Maybe<StopsDatabaseQuayCheckConstraintsMutationResponse>;
  /** update multiples rows of table: "quay_check_constraints" */
  stops_database_update_quay_check_constraints_many?: Maybe<
    Array<Maybe<StopsDatabaseQuayCheckConstraintsMutationResponse>>
  >;
  /** update data of the table: "quay_equipment_places" */
  stops_database_update_quay_equipment_places?: Maybe<StopsDatabaseQuayEquipmentPlacesMutationResponse>;
  /** update multiples rows of table: "quay_equipment_places" */
  stops_database_update_quay_equipment_places_many?: Maybe<
    Array<Maybe<StopsDatabaseQuayEquipmentPlacesMutationResponse>>
  >;
  /** update data of the table: "quay_key_values" */
  stops_database_update_quay_key_values?: Maybe<StopsDatabaseQuayKeyValuesMutationResponse>;
  /** update single row of the table: "quay_key_values" */
  stops_database_update_quay_key_values_by_pk?: Maybe<StopsDatabaseQuayKeyValues>;
  /** update multiples rows of table: "quay_key_values" */
  stops_database_update_quay_key_values_many?: Maybe<
    Array<Maybe<StopsDatabaseQuayKeyValuesMutationResponse>>
  >;
  /** update multiples rows of table: "quay" */
  stops_database_update_quay_many?: Maybe<
    Array<Maybe<StopsDatabaseQuayMutationResponse>>
  >;
  /** update data of the table: "schema_version" */
  stops_database_update_schema_version?: Maybe<StopsDatabaseSchemaVersionMutationResponse>;
  /** update single row of the table: "schema_version" */
  stops_database_update_schema_version_by_pk?: Maybe<StopsDatabaseSchemaVersion>;
  /** update multiples rows of table: "schema_version" */
  stops_database_update_schema_version_many?: Maybe<
    Array<Maybe<StopsDatabaseSchemaVersionMutationResponse>>
  >;
  /** update data of the table: "spatial_ref_sys" */
  stops_database_update_spatial_ref_sys?: Maybe<StopsDatabaseSpatialRefSysMutationResponse>;
  /** update single row of the table: "spatial_ref_sys" */
  stops_database_update_spatial_ref_sys_by_pk?: Maybe<StopsDatabaseSpatialRefSys>;
  /** update multiples rows of table: "spatial_ref_sys" */
  stops_database_update_spatial_ref_sys_many?: Maybe<
    Array<Maybe<StopsDatabaseSpatialRefSysMutationResponse>>
  >;
  /** update data of the table: "stop_place" */
  stops_database_update_stop_place?: Maybe<StopsDatabaseStopPlaceMutationResponse>;
  /** update data of the table: "stop_place_access_spaces" */
  stops_database_update_stop_place_access_spaces?: Maybe<StopsDatabaseStopPlaceAccessSpacesMutationResponse>;
  /** update multiples rows of table: "stop_place_access_spaces" */
  stops_database_update_stop_place_access_spaces_many?: Maybe<
    Array<Maybe<StopsDatabaseStopPlaceAccessSpacesMutationResponse>>
  >;
  /** update data of the table: "stop_place_adjacent_sites" */
  stops_database_update_stop_place_adjacent_sites?: Maybe<StopsDatabaseStopPlaceAdjacentSitesMutationResponse>;
  /** update multiples rows of table: "stop_place_adjacent_sites" */
  stops_database_update_stop_place_adjacent_sites_many?: Maybe<
    Array<Maybe<StopsDatabaseStopPlaceAdjacentSitesMutationResponse>>
  >;
  /** update data of the table: "stop_place_alternative_names" */
  stops_database_update_stop_place_alternative_names?: Maybe<StopsDatabaseStopPlaceAlternativeNamesMutationResponse>;
  /** update multiples rows of table: "stop_place_alternative_names" */
  stops_database_update_stop_place_alternative_names_many?: Maybe<
    Array<Maybe<StopsDatabaseStopPlaceAlternativeNamesMutationResponse>>
  >;
  /** update single row of the table: "stop_place" */
  stops_database_update_stop_place_by_pk?: Maybe<StopsDatabaseStopPlace>;
  /** update data of the table: "stop_place_children" */
  stops_database_update_stop_place_children?: Maybe<StopsDatabaseStopPlaceChildrenMutationResponse>;
  /** update single row of the table: "stop_place_children" */
  stops_database_update_stop_place_children_by_pk?: Maybe<StopsDatabaseStopPlaceChildren>;
  /** update multiples rows of table: "stop_place_children" */
  stops_database_update_stop_place_children_many?: Maybe<
    Array<Maybe<StopsDatabaseStopPlaceChildrenMutationResponse>>
  >;
  /** update data of the table: "stop_place_equipment_places" */
  stops_database_update_stop_place_equipment_places?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesMutationResponse>;
  /** update multiples rows of table: "stop_place_equipment_places" */
  stops_database_update_stop_place_equipment_places_many?: Maybe<
    Array<Maybe<StopsDatabaseStopPlaceEquipmentPlacesMutationResponse>>
  >;
  /** update data of the table: "stop_place_key_values" */
  stops_database_update_stop_place_key_values?: Maybe<StopsDatabaseStopPlaceKeyValuesMutationResponse>;
  /** update single row of the table: "stop_place_key_values" */
  stops_database_update_stop_place_key_values_by_pk?: Maybe<StopsDatabaseStopPlaceKeyValues>;
  /** update multiples rows of table: "stop_place_key_values" */
  stops_database_update_stop_place_key_values_many?: Maybe<
    Array<Maybe<StopsDatabaseStopPlaceKeyValuesMutationResponse>>
  >;
  /** update multiples rows of table: "stop_place" */
  stops_database_update_stop_place_many?: Maybe<
    Array<Maybe<StopsDatabaseStopPlaceMutationResponse>>
  >;
  /** update data of the table: "stop_place_quays" */
  stops_database_update_stop_place_quays?: Maybe<StopsDatabaseStopPlaceQuaysMutationResponse>;
  /** update single row of the table: "stop_place_quays" */
  stops_database_update_stop_place_quays_by_pk?: Maybe<StopsDatabaseStopPlaceQuays>;
  /** update multiples rows of table: "stop_place_quays" */
  stops_database_update_stop_place_quays_many?: Maybe<
    Array<Maybe<StopsDatabaseStopPlaceQuaysMutationResponse>>
  >;
  /** update data of the table: "stop_place_tariff_zones" */
  stops_database_update_stop_place_tariff_zones?: Maybe<StopsDatabaseStopPlaceTariffZonesMutationResponse>;
  /** update multiples rows of table: "stop_place_tariff_zones" */
  stops_database_update_stop_place_tariff_zones_many?: Maybe<
    Array<Maybe<StopsDatabaseStopPlaceTariffZonesMutationResponse>>
  >;
  /** update data of the table: "tag" */
  stops_database_update_tag?: Maybe<StopsDatabaseTagMutationResponse>;
  /** update single row of the table: "tag" */
  stops_database_update_tag_by_pk?: Maybe<StopsDatabaseTag>;
  /** update multiples rows of table: "tag" */
  stops_database_update_tag_many?: Maybe<
    Array<Maybe<StopsDatabaseTagMutationResponse>>
  >;
  /** update data of the table: "tariff_zone" */
  stops_database_update_tariff_zone?: Maybe<StopsDatabaseTariffZoneMutationResponse>;
  /** update single row of the table: "tariff_zone" */
  stops_database_update_tariff_zone_by_pk?: Maybe<StopsDatabaseTariffZone>;
  /** update data of the table: "tariff_zone_key_values" */
  stops_database_update_tariff_zone_key_values?: Maybe<StopsDatabaseTariffZoneKeyValuesMutationResponse>;
  /** update single row of the table: "tariff_zone_key_values" */
  stops_database_update_tariff_zone_key_values_by_pk?: Maybe<StopsDatabaseTariffZoneKeyValues>;
  /** update multiples rows of table: "tariff_zone_key_values" */
  stops_database_update_tariff_zone_key_values_many?: Maybe<
    Array<Maybe<StopsDatabaseTariffZoneKeyValuesMutationResponse>>
  >;
  /** update multiples rows of table: "tariff_zone" */
  stops_database_update_tariff_zone_many?: Maybe<
    Array<Maybe<StopsDatabaseTariffZoneMutationResponse>>
  >;
  /** update data of the table: "topographic_place" */
  stops_database_update_topographic_place?: Maybe<StopsDatabaseTopographicPlaceMutationResponse>;
  /** update single row of the table: "topographic_place" */
  stops_database_update_topographic_place_by_pk?: Maybe<StopsDatabaseTopographicPlace>;
  /** update data of the table: "topographic_place_key_values" */
  stops_database_update_topographic_place_key_values?: Maybe<StopsDatabaseTopographicPlaceKeyValuesMutationResponse>;
  /** update single row of the table: "topographic_place_key_values" */
  stops_database_update_topographic_place_key_values_by_pk?: Maybe<StopsDatabaseTopographicPlaceKeyValues>;
  /** update multiples rows of table: "topographic_place_key_values" */
  stops_database_update_topographic_place_key_values_many?: Maybe<
    Array<Maybe<StopsDatabaseTopographicPlaceKeyValuesMutationResponse>>
  >;
  /** update multiples rows of table: "topographic_place" */
  stops_database_update_topographic_place_many?: Maybe<
    Array<Maybe<StopsDatabaseTopographicPlaceMutationResponse>>
  >;
  /** update data of the table: "value" */
  stops_database_update_value?: Maybe<StopsDatabaseValueMutationResponse>;
  /** update single row of the table: "value" */
  stops_database_update_value_by_pk?: Maybe<StopsDatabaseValue>;
  /** update data of the table: "value_items" */
  stops_database_update_value_items?: Maybe<StopsDatabaseValueItemsMutationResponse>;
  /** update multiples rows of table: "value_items" */
  stops_database_update_value_items_many?: Maybe<
    Array<Maybe<StopsDatabaseValueItemsMutationResponse>>
  >;
  /** update multiples rows of table: "value" */
  stops_database_update_value_many?: Maybe<
    Array<Maybe<StopsDatabaseValueMutationResponse>>
  >;
};

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAccessSpaceArgs =
  {
    where: StopsDatabaseAccessSpaceBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAccessSpaceAlternativeNamesArgs =
  {
    where: StopsDatabaseAccessSpaceAlternativeNamesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAccessSpaceByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAccessSpaceCheckConstraintsArgs =
  {
    where: StopsDatabaseAccessSpaceCheckConstraintsBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAccessSpaceEquipmentPlacesArgs =
  {
    where: StopsDatabaseAccessSpaceEquipmentPlacesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAccessSpaceKeyValuesArgs =
  {
    where: StopsDatabaseAccessSpaceKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAccessSpaceKeyValuesByPkArgs =
  {
    access_space_id: Scalars['bigint'];
    key_values_key: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAccessibilityAssessmentArgs =
  {
    where: StopsDatabaseAccessibilityAssessmentBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAccessibilityAssessmentByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAccessibilityAssessmentLimitationsArgs =
  {
    where: StopsDatabaseAccessibilityAssessmentLimitationsBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAccessibilityLimitationArgs =
  {
    where: StopsDatabaseAccessibilityLimitationBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAccessibilityLimitationByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAlternativeNameArgs =
  {
    where: StopsDatabaseAlternativeNameBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAlternativeNameByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteBoardingPositionArgs =
  {
    where: StopsDatabaseBoardingPositionBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteBoardingPositionAlternativeNamesArgs =
  {
    where: StopsDatabaseBoardingPositionAlternativeNamesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteBoardingPositionByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteBoardingPositionCheckConstraintsArgs =
  {
    where: StopsDatabaseBoardingPositionCheckConstraintsBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteBoardingPositionEquipmentPlacesArgs =
  {
    where: StopsDatabaseBoardingPositionEquipmentPlacesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteBoardingPositionKeyValuesArgs =
  {
    where: StopsDatabaseBoardingPositionKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteBoardingPositionKeyValuesByPkArgs =
  {
    boarding_position_id: Scalars['bigint'];
    key_values_key: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteCheckConstraintArgs =
  {
    where: StopsDatabaseCheckConstraintBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteCheckConstraintByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteCheckConstraintKeyValuesArgs =
  {
    where: StopsDatabaseCheckConstraintKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteCheckConstraintKeyValuesByPkArgs =
  {
    check_constraint_id: Scalars['bigint'];
    key_values_key: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteDestinationDisplayViewArgs =
  {
    where: StopsDatabaseDestinationDisplayViewBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteDestinationDisplayViewByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteEquipmentPlaceArgs =
  {
    where: StopsDatabaseEquipmentPlaceBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteEquipmentPlaceByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteEquipmentPlaceEquipmentPositionsArgs =
  {
    where: StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteEquipmentPlaceKeyValuesArgs =
  {
    where: StopsDatabaseEquipmentPlaceKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteEquipmentPlaceKeyValuesByPkArgs =
  {
    equipment_place_id: Scalars['bigint'];
    key_values_key: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteEquipmentPositionArgs =
  {
    where: StopsDatabaseEquipmentPositionBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteEquipmentPositionByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteEquipmentPositionKeyValuesArgs =
  {
    where: StopsDatabaseEquipmentPositionKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteEquipmentPositionKeyValuesByPkArgs =
  {
    equipment_position_id: Scalars['bigint'];
    key_values_key: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteExportJobArgs =
  {
    where: StopsDatabaseExportJobBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteExportJobByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteFareZoneArgs =
  {
    where: StopsDatabaseFareZoneBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteFareZoneByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteFareZoneKeyValuesArgs =
  {
    where: StopsDatabaseFareZoneKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteFareZoneKeyValuesByPkArgs =
  {
    fare_zone_id: Scalars['bigint'];
    key_values_key: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteFareZoneMembersArgs =
  {
    where: StopsDatabaseFareZoneMembersBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteFareZoneNeighboursArgs =
  {
    where: StopsDatabaseFareZoneNeighboursBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGeometryColumnsArgs =
  {
    where: StopsDatabaseGeometryColumnsBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGroupOfStopPlacesArgs =
  {
    where: StopsDatabaseGroupOfStopPlacesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGroupOfStopPlacesAlternativeNamesArgs =
  {
    where: StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGroupOfStopPlacesByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGroupOfStopPlacesKeyValuesArgs =
  {
    where: StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGroupOfStopPlacesKeyValuesByPkArgs =
  {
    group_of_stop_places_id: Scalars['bigint'];
    key_values_key: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGroupOfStopPlacesMembersArgs =
  {
    where: StopsDatabaseGroupOfStopPlacesMembersBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGroupOfTariffZonesArgs =
  {
    where: StopsDatabaseGroupOfTariffZonesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGroupOfTariffZonesByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGroupOfTariffZonesKeyValuesArgs =
  {
    where: StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGroupOfTariffZonesKeyValuesByPkArgs =
  {
    group_of_tariff_zones_id: Scalars['bigint'];
    key_values_key: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGroupOfTariffZonesMembersArgs =
  {
    where: StopsDatabaseGroupOfTariffZonesMembersBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGroupOfTariffZonesMembersByPkArgs =
  {
    group_of_tariff_zones_id: Scalars['bigint'];
    ref: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteIdGeneratorArgs =
  {
    where: StopsDatabaseIdGeneratorBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteInstalledEquipmentArgs =
  {
    where: StopsDatabaseInstalledEquipmentBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteInstalledEquipmentVersionStructureArgs =
  {
    where: StopsDatabaseInstalledEquipmentVersionStructureBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteInstalledEquipmentVersionStructureByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteInstalledEquipmentVersionStructureInstalledEquipmentArgs =
  {
    where: StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteLevelArgs =
  {
    where: StopsDatabaseLevelBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteLevelByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteLevelKeyValuesArgs =
  {
    where: StopsDatabaseLevelKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteLevelKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    level_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteMultilingualStringEntityArgs =
  {
    where: StopsDatabaseMultilingualStringEntityBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteMultilingualStringEntityByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteNavigationPathArgs =
  {
    where: StopsDatabaseNavigationPathBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingArgs =
  {
    where: StopsDatabaseParkingBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingAdjacentSitesArgs =
  {
    where: StopsDatabaseParkingAdjacentSitesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingAlternativeNamesArgs =
  {
    where: StopsDatabaseParkingAlternativeNamesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingAreaArgs =
  {
    where: StopsDatabaseParkingAreaBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingAreaAlternativeNamesArgs =
  {
    where: StopsDatabaseParkingAreaAlternativeNamesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingAreaByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingAreaCheckConstraintsArgs =
  {
    where: StopsDatabaseParkingAreaCheckConstraintsBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingAreaEquipmentPlacesArgs =
  {
    where: StopsDatabaseParkingAreaEquipmentPlacesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingAreaKeyValuesArgs =
  {
    where: StopsDatabaseParkingAreaKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingAreaKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    parking_area_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingCapacityArgs =
  {
    where: StopsDatabaseParkingCapacityBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingCapacityByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingEquipmentPlacesArgs =
  {
    where: StopsDatabaseParkingEquipmentPlacesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingKeyValuesArgs =
  {
    where: StopsDatabaseParkingKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    parking_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingParkingAreasArgs =
  {
    where: StopsDatabaseParkingParkingAreasBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingParkingPaymentProcessArgs =
  {
    where: StopsDatabaseParkingParkingPaymentProcessBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingParkingPropertiesArgs =
  {
    where: StopsDatabaseParkingParkingPropertiesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingParkingVehicleTypesArgs =
  {
    where: StopsDatabaseParkingParkingVehicleTypesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingPropertiesArgs =
  {
    where: StopsDatabaseParkingPropertiesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingPropertiesByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingPropertiesParkingUserTypesArgs =
  {
    where: StopsDatabaseParkingPropertiesParkingUserTypesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingPropertiesSpacesArgs =
  {
    where: StopsDatabaseParkingPropertiesSpacesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePathJunctionArgs =
  {
    where: StopsDatabasePathJunctionBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePathJunctionByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePathJunctionKeyValuesArgs =
  {
    where: StopsDatabasePathJunctionKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePathJunctionKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    path_junction_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePathLinkArgs =
  {
    where: StopsDatabasePathLinkBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePathLinkByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePathLinkEndArgs =
  {
    where: StopsDatabasePathLinkEndBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePathLinkEndByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePathLinkKeyValuesArgs =
  {
    where: StopsDatabasePathLinkKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePathLinkKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    path_link_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePersistablePolygonArgs =
  {
    where: StopsDatabasePersistablePolygonBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePersistablePolygonByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePurposeOfGroupingArgs =
  {
    where: StopsDatabasePurposeOfGroupingBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePurposeOfGroupingByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePurposeOfGroupingKeyValuesArgs =
  {
    where: StopsDatabasePurposeOfGroupingKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePurposeOfGroupingKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    purpose_of_grouping_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteQuayArgs =
  {
    where: StopsDatabaseQuayBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteQuayAlternativeNamesArgs =
  {
    where: StopsDatabaseQuayAlternativeNamesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteQuayBoardingPositionsArgs =
  {
    where: StopsDatabaseQuayBoardingPositionsBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteQuayByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteQuayCheckConstraintsArgs =
  {
    where: StopsDatabaseQuayCheckConstraintsBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteQuayEquipmentPlacesArgs =
  {
    where: StopsDatabaseQuayEquipmentPlacesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteQuayKeyValuesArgs =
  {
    where: StopsDatabaseQuayKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteQuayKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    quay_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteSchemaVersionArgs =
  {
    where: StopsDatabaseSchemaVersionBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteSchemaVersionByPkArgs =
  {
    installed_rank: Scalars['Int'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteSpatialRefSysArgs =
  {
    where: StopsDatabaseSpatialRefSysBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteSpatialRefSysByPkArgs =
  {
    srid: Scalars['Int'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceArgs =
  {
    where: StopsDatabaseStopPlaceBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceAccessSpacesArgs =
  {
    where: StopsDatabaseStopPlaceAccessSpacesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceAdjacentSitesArgs =
  {
    where: StopsDatabaseStopPlaceAdjacentSitesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceAlternativeNamesArgs =
  {
    where: StopsDatabaseStopPlaceAlternativeNamesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceChildrenArgs =
  {
    where: StopsDatabaseStopPlaceChildrenBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceChildrenByPkArgs =
  {
    children_id: Scalars['bigint'];
    stop_place_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceEquipmentPlacesArgs =
  {
    where: StopsDatabaseStopPlaceEquipmentPlacesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceKeyValuesArgs =
  {
    where: StopsDatabaseStopPlaceKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    stop_place_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceQuaysArgs =
  {
    where: StopsDatabaseStopPlaceQuaysBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceQuaysByPkArgs =
  {
    quays_id: Scalars['bigint'];
    stop_place_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceTariffZonesArgs =
  {
    where: StopsDatabaseStopPlaceTariffZonesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteTagArgs =
  {
    where: StopsDatabaseTagBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteTagByPkArgs =
  {
    name: Scalars['String'];
    netex_reference: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteTariffZoneArgs =
  {
    where: StopsDatabaseTariffZoneBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteTariffZoneByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteTariffZoneKeyValuesArgs =
  {
    where: StopsDatabaseTariffZoneKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteTariffZoneKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    tariff_zone_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteTopographicPlaceArgs =
  {
    where: StopsDatabaseTopographicPlaceBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteTopographicPlaceByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteTopographicPlaceKeyValuesArgs =
  {
    where: StopsDatabaseTopographicPlaceKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteTopographicPlaceKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    topographic_place_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteValueArgs =
  {
    where: StopsDatabaseValueBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteValueByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteValueItemsArgs =
  {
    where: StopsDatabaseValueItemsBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessSpaceArgs =
  {
    objects: Array<StopsDatabaseAccessSpaceInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseAccessSpaceOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessSpaceAlternativeNamesArgs =
  {
    objects: Array<StopsDatabaseAccessSpaceAlternativeNamesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessSpaceAlternativeNamesOneArgs =
  {
    object: StopsDatabaseAccessSpaceAlternativeNamesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessSpaceCheckConstraintsArgs =
  {
    objects: Array<StopsDatabaseAccessSpaceCheckConstraintsInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessSpaceCheckConstraintsOneArgs =
  {
    object: StopsDatabaseAccessSpaceCheckConstraintsInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessSpaceEquipmentPlacesArgs =
  {
    objects: Array<StopsDatabaseAccessSpaceEquipmentPlacesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessSpaceEquipmentPlacesOneArgs =
  {
    object: StopsDatabaseAccessSpaceEquipmentPlacesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessSpaceKeyValuesArgs =
  {
    objects: Array<StopsDatabaseAccessSpaceKeyValuesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessSpaceKeyValuesOneArgs =
  {
    object: StopsDatabaseAccessSpaceKeyValuesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessSpaceOneArgs =
  {
    object: StopsDatabaseAccessSpaceInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseAccessSpaceOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessibilityAssessmentArgs =
  {
    objects: Array<StopsDatabaseAccessibilityAssessmentInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseAccessibilityAssessmentOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessibilityAssessmentLimitationsArgs =
  {
    objects: Array<StopsDatabaseAccessibilityAssessmentLimitationsInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessibilityAssessmentLimitationsOneArgs =
  {
    object: StopsDatabaseAccessibilityAssessmentLimitationsInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessibilityAssessmentOneArgs =
  {
    object: StopsDatabaseAccessibilityAssessmentInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseAccessibilityAssessmentOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessibilityLimitationArgs =
  {
    objects: Array<StopsDatabaseAccessibilityLimitationInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseAccessibilityLimitationOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessibilityLimitationOneArgs =
  {
    object: StopsDatabaseAccessibilityLimitationInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseAccessibilityLimitationOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAlternativeNameArgs =
  {
    objects: Array<StopsDatabaseAlternativeNameInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseAlternativeNameOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAlternativeNameOneArgs =
  {
    object: StopsDatabaseAlternativeNameInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseAlternativeNameOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertBoardingPositionArgs =
  {
    objects: Array<StopsDatabaseBoardingPositionInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseBoardingPositionOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertBoardingPositionAlternativeNamesArgs =
  {
    objects: Array<StopsDatabaseBoardingPositionAlternativeNamesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertBoardingPositionAlternativeNamesOneArgs =
  {
    object: StopsDatabaseBoardingPositionAlternativeNamesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertBoardingPositionCheckConstraintsArgs =
  {
    objects: Array<StopsDatabaseBoardingPositionCheckConstraintsInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertBoardingPositionCheckConstraintsOneArgs =
  {
    object: StopsDatabaseBoardingPositionCheckConstraintsInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertBoardingPositionEquipmentPlacesArgs =
  {
    objects: Array<StopsDatabaseBoardingPositionEquipmentPlacesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertBoardingPositionEquipmentPlacesOneArgs =
  {
    object: StopsDatabaseBoardingPositionEquipmentPlacesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertBoardingPositionKeyValuesArgs =
  {
    objects: Array<StopsDatabaseBoardingPositionKeyValuesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertBoardingPositionKeyValuesOneArgs =
  {
    object: StopsDatabaseBoardingPositionKeyValuesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertBoardingPositionOneArgs =
  {
    object: StopsDatabaseBoardingPositionInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseBoardingPositionOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertCheckConstraintArgs =
  {
    objects: Array<StopsDatabaseCheckConstraintInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseCheckConstraintOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertCheckConstraintKeyValuesArgs =
  {
    objects: Array<StopsDatabaseCheckConstraintKeyValuesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertCheckConstraintKeyValuesOneArgs =
  {
    object: StopsDatabaseCheckConstraintKeyValuesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertCheckConstraintOneArgs =
  {
    object: StopsDatabaseCheckConstraintInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseCheckConstraintOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertDestinationDisplayViewArgs =
  {
    objects: Array<StopsDatabaseDestinationDisplayViewInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseDestinationDisplayViewOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertDestinationDisplayViewOneArgs =
  {
    object: StopsDatabaseDestinationDisplayViewInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseDestinationDisplayViewOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertEquipmentPlaceArgs =
  {
    objects: Array<StopsDatabaseEquipmentPlaceInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseEquipmentPlaceOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertEquipmentPlaceEquipmentPositionsArgs =
  {
    objects: Array<StopsDatabaseEquipmentPlaceEquipmentPositionsInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertEquipmentPlaceEquipmentPositionsOneArgs =
  {
    object: StopsDatabaseEquipmentPlaceEquipmentPositionsInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertEquipmentPlaceKeyValuesArgs =
  {
    objects: Array<StopsDatabaseEquipmentPlaceKeyValuesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertEquipmentPlaceKeyValuesOneArgs =
  {
    object: StopsDatabaseEquipmentPlaceKeyValuesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertEquipmentPlaceOneArgs =
  {
    object: StopsDatabaseEquipmentPlaceInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseEquipmentPlaceOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertEquipmentPositionArgs =
  {
    objects: Array<StopsDatabaseEquipmentPositionInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseEquipmentPositionOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertEquipmentPositionKeyValuesArgs =
  {
    objects: Array<StopsDatabaseEquipmentPositionKeyValuesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertEquipmentPositionKeyValuesOneArgs =
  {
    object: StopsDatabaseEquipmentPositionKeyValuesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertEquipmentPositionOneArgs =
  {
    object: StopsDatabaseEquipmentPositionInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseEquipmentPositionOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertExportJobArgs =
  {
    objects: Array<StopsDatabaseExportJobInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseExportJobOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertExportJobOneArgs =
  {
    object: StopsDatabaseExportJobInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseExportJobOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertFareZoneArgs =
  {
    objects: Array<StopsDatabaseFareZoneInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseFareZoneOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertFareZoneKeyValuesArgs =
  {
    objects: Array<StopsDatabaseFareZoneKeyValuesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseFareZoneKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertFareZoneKeyValuesOneArgs =
  {
    object: StopsDatabaseFareZoneKeyValuesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseFareZoneKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertFareZoneMembersArgs =
  {
    objects: Array<StopsDatabaseFareZoneMembersInsertInput>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertFareZoneMembersOneArgs =
  {
    object: StopsDatabaseFareZoneMembersInsertInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertFareZoneNeighboursArgs =
  {
    objects: Array<StopsDatabaseFareZoneNeighboursInsertInput>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertFareZoneNeighboursOneArgs =
  {
    object: StopsDatabaseFareZoneNeighboursInsertInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertFareZoneOneArgs =
  {
    object: StopsDatabaseFareZoneInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseFareZoneOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGeometryColumnsArgs =
  {
    objects: Array<StopsDatabaseGeometryColumnsInsertInput>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGeometryColumnsOneArgs =
  {
    object: StopsDatabaseGeometryColumnsInsertInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfStopPlacesArgs =
  {
    objects: Array<StopsDatabaseGroupOfStopPlacesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseGroupOfStopPlacesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfStopPlacesAlternativeNamesArgs =
  {
    objects: Array<StopsDatabaseGroupOfStopPlacesAlternativeNamesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfStopPlacesAlternativeNamesOneArgs =
  {
    object: StopsDatabaseGroupOfStopPlacesAlternativeNamesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfStopPlacesKeyValuesArgs =
  {
    objects: Array<StopsDatabaseGroupOfStopPlacesKeyValuesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfStopPlacesKeyValuesOneArgs =
  {
    object: StopsDatabaseGroupOfStopPlacesKeyValuesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfStopPlacesMembersArgs =
  {
    objects: Array<StopsDatabaseGroupOfStopPlacesMembersInsertInput>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfStopPlacesMembersOneArgs =
  {
    object: StopsDatabaseGroupOfStopPlacesMembersInsertInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfStopPlacesOneArgs =
  {
    object: StopsDatabaseGroupOfStopPlacesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseGroupOfStopPlacesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfTariffZonesArgs =
  {
    objects: Array<StopsDatabaseGroupOfTariffZonesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseGroupOfTariffZonesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfTariffZonesKeyValuesArgs =
  {
    objects: Array<StopsDatabaseGroupOfTariffZonesKeyValuesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfTariffZonesKeyValuesOneArgs =
  {
    object: StopsDatabaseGroupOfTariffZonesKeyValuesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfTariffZonesMembersArgs =
  {
    objects: Array<StopsDatabaseGroupOfTariffZonesMembersInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfTariffZonesMembersOneArgs =
  {
    object: StopsDatabaseGroupOfTariffZonesMembersInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfTariffZonesOneArgs =
  {
    object: StopsDatabaseGroupOfTariffZonesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseGroupOfTariffZonesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertIdGeneratorArgs =
  {
    objects: Array<StopsDatabaseIdGeneratorInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseIdGeneratorOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertIdGeneratorOneArgs =
  {
    object: StopsDatabaseIdGeneratorInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseIdGeneratorOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertInstalledEquipmentArgs =
  {
    objects: Array<StopsDatabaseInstalledEquipmentInsertInput>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertInstalledEquipmentOneArgs =
  {
    object: StopsDatabaseInstalledEquipmentInsertInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertInstalledEquipmentVersionStructureArgs =
  {
    objects: Array<StopsDatabaseInstalledEquipmentVersionStructureInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertInstalledEquipmentVersionStructureInstalledEquipmentArgs =
  {
    objects: Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertInstalledEquipmentVersionStructureInstalledEquipmentOneArgs =
  {
    object: StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertInstalledEquipmentVersionStructureOneArgs =
  {
    object: StopsDatabaseInstalledEquipmentVersionStructureInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertLevelArgs =
  {
    objects: Array<StopsDatabaseLevelInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseLevelOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertLevelKeyValuesArgs =
  {
    objects: Array<StopsDatabaseLevelKeyValuesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseLevelKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertLevelKeyValuesOneArgs =
  {
    object: StopsDatabaseLevelKeyValuesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseLevelKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertLevelOneArgs =
  {
    object: StopsDatabaseLevelInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseLevelOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertMultilingualStringEntityArgs =
  {
    objects: Array<StopsDatabaseMultilingualStringEntityInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseMultilingualStringEntityOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertMultilingualStringEntityOneArgs =
  {
    object: StopsDatabaseMultilingualStringEntityInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseMultilingualStringEntityOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertNavigationPathArgs =
  {
    objects: Array<StopsDatabaseNavigationPathInsertInput>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertNavigationPathOneArgs =
  {
    object: StopsDatabaseNavigationPathInsertInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingArgs =
  {
    objects: Array<StopsDatabaseParkingInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseParkingOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAdjacentSitesArgs =
  {
    objects: Array<StopsDatabaseParkingAdjacentSitesInsertInput>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAdjacentSitesOneArgs =
  {
    object: StopsDatabaseParkingAdjacentSitesInsertInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAlternativeNamesArgs =
  {
    objects: Array<StopsDatabaseParkingAlternativeNamesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseParkingAlternativeNamesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAlternativeNamesOneArgs =
  {
    object: StopsDatabaseParkingAlternativeNamesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseParkingAlternativeNamesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAreaArgs =
  {
    objects: Array<StopsDatabaseParkingAreaInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseParkingAreaOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAreaAlternativeNamesArgs =
  {
    objects: Array<StopsDatabaseParkingAreaAlternativeNamesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAreaAlternativeNamesOneArgs =
  {
    object: StopsDatabaseParkingAreaAlternativeNamesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAreaCheckConstraintsArgs =
  {
    objects: Array<StopsDatabaseParkingAreaCheckConstraintsInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAreaCheckConstraintsOneArgs =
  {
    object: StopsDatabaseParkingAreaCheckConstraintsInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAreaEquipmentPlacesArgs =
  {
    objects: Array<StopsDatabaseParkingAreaEquipmentPlacesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAreaEquipmentPlacesOneArgs =
  {
    object: StopsDatabaseParkingAreaEquipmentPlacesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAreaKeyValuesArgs =
  {
    objects: Array<StopsDatabaseParkingAreaKeyValuesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseParkingAreaKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAreaKeyValuesOneArgs =
  {
    object: StopsDatabaseParkingAreaKeyValuesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseParkingAreaKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAreaOneArgs =
  {
    object: StopsDatabaseParkingAreaInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseParkingAreaOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingCapacityArgs =
  {
    objects: Array<StopsDatabaseParkingCapacityInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseParkingCapacityOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingCapacityOneArgs =
  {
    object: StopsDatabaseParkingCapacityInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseParkingCapacityOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingEquipmentPlacesArgs =
  {
    objects: Array<StopsDatabaseParkingEquipmentPlacesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseParkingEquipmentPlacesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingEquipmentPlacesOneArgs =
  {
    object: StopsDatabaseParkingEquipmentPlacesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseParkingEquipmentPlacesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingKeyValuesArgs =
  {
    objects: Array<StopsDatabaseParkingKeyValuesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseParkingKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingKeyValuesOneArgs =
  {
    object: StopsDatabaseParkingKeyValuesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseParkingKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingOneArgs =
  {
    object: StopsDatabaseParkingInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseParkingOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingParkingAreasArgs =
  {
    objects: Array<StopsDatabaseParkingParkingAreasInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseParkingParkingAreasOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingParkingAreasOneArgs =
  {
    object: StopsDatabaseParkingParkingAreasInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseParkingParkingAreasOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingParkingPaymentProcessArgs =
  {
    objects: Array<StopsDatabaseParkingParkingPaymentProcessInsertInput>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingParkingPaymentProcessOneArgs =
  {
    object: StopsDatabaseParkingParkingPaymentProcessInsertInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingParkingPropertiesArgs =
  {
    objects: Array<StopsDatabaseParkingParkingPropertiesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseParkingParkingPropertiesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingParkingPropertiesOneArgs =
  {
    object: StopsDatabaseParkingParkingPropertiesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseParkingParkingPropertiesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingParkingVehicleTypesArgs =
  {
    objects: Array<StopsDatabaseParkingParkingVehicleTypesInsertInput>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingParkingVehicleTypesOneArgs =
  {
    object: StopsDatabaseParkingParkingVehicleTypesInsertInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingPropertiesArgs =
  {
    objects: Array<StopsDatabaseParkingPropertiesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseParkingPropertiesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingPropertiesOneArgs =
  {
    object: StopsDatabaseParkingPropertiesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseParkingPropertiesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingPropertiesParkingUserTypesArgs =
  {
    objects: Array<StopsDatabaseParkingPropertiesParkingUserTypesInsertInput>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingPropertiesParkingUserTypesOneArgs =
  {
    object: StopsDatabaseParkingPropertiesParkingUserTypesInsertInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingPropertiesSpacesArgs =
  {
    objects: Array<StopsDatabaseParkingPropertiesSpacesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseParkingPropertiesSpacesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingPropertiesSpacesOneArgs =
  {
    object: StopsDatabaseParkingPropertiesSpacesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseParkingPropertiesSpacesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPathJunctionArgs =
  {
    objects: Array<StopsDatabasePathJunctionInsertInput>;
    on_conflict?: InputMaybe<StopsDatabasePathJunctionOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPathJunctionKeyValuesArgs =
  {
    objects: Array<StopsDatabasePathJunctionKeyValuesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabasePathJunctionKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPathJunctionKeyValuesOneArgs =
  {
    object: StopsDatabasePathJunctionKeyValuesInsertInput;
    on_conflict?: InputMaybe<StopsDatabasePathJunctionKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPathJunctionOneArgs =
  {
    object: StopsDatabasePathJunctionInsertInput;
    on_conflict?: InputMaybe<StopsDatabasePathJunctionOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPathLinkArgs =
  {
    objects: Array<StopsDatabasePathLinkInsertInput>;
    on_conflict?: InputMaybe<StopsDatabasePathLinkOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPathLinkEndArgs =
  {
    objects: Array<StopsDatabasePathLinkEndInsertInput>;
    on_conflict?: InputMaybe<StopsDatabasePathLinkEndOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPathLinkEndOneArgs =
  {
    object: StopsDatabasePathLinkEndInsertInput;
    on_conflict?: InputMaybe<StopsDatabasePathLinkEndOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPathLinkKeyValuesArgs =
  {
    objects: Array<StopsDatabasePathLinkKeyValuesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabasePathLinkKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPathLinkKeyValuesOneArgs =
  {
    object: StopsDatabasePathLinkKeyValuesInsertInput;
    on_conflict?: InputMaybe<StopsDatabasePathLinkKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPathLinkOneArgs =
  {
    object: StopsDatabasePathLinkInsertInput;
    on_conflict?: InputMaybe<StopsDatabasePathLinkOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPersistablePolygonArgs =
  {
    objects: Array<StopsDatabasePersistablePolygonInsertInput>;
    on_conflict?: InputMaybe<StopsDatabasePersistablePolygonOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPersistablePolygonOneArgs =
  {
    object: StopsDatabasePersistablePolygonInsertInput;
    on_conflict?: InputMaybe<StopsDatabasePersistablePolygonOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPurposeOfGroupingArgs =
  {
    objects: Array<StopsDatabasePurposeOfGroupingInsertInput>;
    on_conflict?: InputMaybe<StopsDatabasePurposeOfGroupingOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPurposeOfGroupingKeyValuesArgs =
  {
    objects: Array<StopsDatabasePurposeOfGroupingKeyValuesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPurposeOfGroupingKeyValuesOneArgs =
  {
    object: StopsDatabasePurposeOfGroupingKeyValuesInsertInput;
    on_conflict?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPurposeOfGroupingOneArgs =
  {
    object: StopsDatabasePurposeOfGroupingInsertInput;
    on_conflict?: InputMaybe<StopsDatabasePurposeOfGroupingOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertQuayArgs =
  {
    objects: Array<StopsDatabaseQuayInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseQuayOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertQuayAlternativeNamesArgs =
  {
    objects: Array<StopsDatabaseQuayAlternativeNamesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseQuayAlternativeNamesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertQuayAlternativeNamesOneArgs =
  {
    object: StopsDatabaseQuayAlternativeNamesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseQuayAlternativeNamesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertQuayBoardingPositionsArgs =
  {
    objects: Array<StopsDatabaseQuayBoardingPositionsInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseQuayBoardingPositionsOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertQuayBoardingPositionsOneArgs =
  {
    object: StopsDatabaseQuayBoardingPositionsInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseQuayBoardingPositionsOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertQuayCheckConstraintsArgs =
  {
    objects: Array<StopsDatabaseQuayCheckConstraintsInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseQuayCheckConstraintsOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertQuayCheckConstraintsOneArgs =
  {
    object: StopsDatabaseQuayCheckConstraintsInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseQuayCheckConstraintsOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertQuayEquipmentPlacesArgs =
  {
    objects: Array<StopsDatabaseQuayEquipmentPlacesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseQuayEquipmentPlacesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertQuayEquipmentPlacesOneArgs =
  {
    object: StopsDatabaseQuayEquipmentPlacesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseQuayEquipmentPlacesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertQuayKeyValuesArgs =
  {
    objects: Array<StopsDatabaseQuayKeyValuesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseQuayKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertQuayKeyValuesOneArgs =
  {
    object: StopsDatabaseQuayKeyValuesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseQuayKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertQuayOneArgs =
  {
    object: StopsDatabaseQuayInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseQuayOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertSchemaVersionArgs =
  {
    objects: Array<StopsDatabaseSchemaVersionInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseSchemaVersionOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertSchemaVersionOneArgs =
  {
    object: StopsDatabaseSchemaVersionInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseSchemaVersionOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertSpatialRefSysArgs =
  {
    objects: Array<StopsDatabaseSpatialRefSysInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseSpatialRefSysOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertSpatialRefSysOneArgs =
  {
    object: StopsDatabaseSpatialRefSysInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseSpatialRefSysOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceArgs =
  {
    objects: Array<StopsDatabaseStopPlaceInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseStopPlaceOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceAccessSpacesArgs =
  {
    objects: Array<StopsDatabaseStopPlaceAccessSpacesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceAccessSpacesOneArgs =
  {
    object: StopsDatabaseStopPlaceAccessSpacesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceAdjacentSitesArgs =
  {
    objects: Array<StopsDatabaseStopPlaceAdjacentSitesInsertInput>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceAdjacentSitesOneArgs =
  {
    object: StopsDatabaseStopPlaceAdjacentSitesInsertInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceAlternativeNamesArgs =
  {
    objects: Array<StopsDatabaseStopPlaceAlternativeNamesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceAlternativeNamesOneArgs =
  {
    object: StopsDatabaseStopPlaceAlternativeNamesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceChildrenArgs =
  {
    objects: Array<StopsDatabaseStopPlaceChildrenInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseStopPlaceChildrenOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceChildrenOneArgs =
  {
    object: StopsDatabaseStopPlaceChildrenInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseStopPlaceChildrenOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceEquipmentPlacesArgs =
  {
    objects: Array<StopsDatabaseStopPlaceEquipmentPlacesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceEquipmentPlacesOneArgs =
  {
    object: StopsDatabaseStopPlaceEquipmentPlacesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceKeyValuesArgs =
  {
    objects: Array<StopsDatabaseStopPlaceKeyValuesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseStopPlaceKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceKeyValuesOneArgs =
  {
    object: StopsDatabaseStopPlaceKeyValuesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseStopPlaceKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceOneArgs =
  {
    object: StopsDatabaseStopPlaceInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseStopPlaceOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceQuaysArgs =
  {
    objects: Array<StopsDatabaseStopPlaceQuaysInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseStopPlaceQuaysOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceQuaysOneArgs =
  {
    object: StopsDatabaseStopPlaceQuaysInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseStopPlaceQuaysOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceTariffZonesArgs =
  {
    objects: Array<StopsDatabaseStopPlaceTariffZonesInsertInput>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceTariffZonesOneArgs =
  {
    object: StopsDatabaseStopPlaceTariffZonesInsertInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertTagArgs =
  {
    objects: Array<StopsDatabaseTagInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseTagOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertTagOneArgs =
  {
    object: StopsDatabaseTagInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseTagOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertTariffZoneArgs =
  {
    objects: Array<StopsDatabaseTariffZoneInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseTariffZoneOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertTariffZoneKeyValuesArgs =
  {
    objects: Array<StopsDatabaseTariffZoneKeyValuesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseTariffZoneKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertTariffZoneKeyValuesOneArgs =
  {
    object: StopsDatabaseTariffZoneKeyValuesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseTariffZoneKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertTariffZoneOneArgs =
  {
    object: StopsDatabaseTariffZoneInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseTariffZoneOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertTopographicPlaceArgs =
  {
    objects: Array<StopsDatabaseTopographicPlaceInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseTopographicPlaceOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertTopographicPlaceKeyValuesArgs =
  {
    objects: Array<StopsDatabaseTopographicPlaceKeyValuesInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertTopographicPlaceKeyValuesOneArgs =
  {
    object: StopsDatabaseTopographicPlaceKeyValuesInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertTopographicPlaceOneArgs =
  {
    object: StopsDatabaseTopographicPlaceInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseTopographicPlaceOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertValueArgs =
  {
    objects: Array<StopsDatabaseValueInsertInput>;
    on_conflict?: InputMaybe<StopsDatabaseValueOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertValueItemsArgs =
  {
    objects: Array<StopsDatabaseValueItemsInsertInput>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertValueItemsOneArgs =
  {
    object: StopsDatabaseValueItemsInsertInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertValueOneArgs =
  {
    object: StopsDatabaseValueInsertInput;
    on_conflict?: InputMaybe<StopsDatabaseValueOnConflict>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessSpaceArgs =
  {
    _inc?: InputMaybe<StopsDatabaseAccessSpaceIncInput>;
    _set?: InputMaybe<StopsDatabaseAccessSpaceSetInput>;
    where: StopsDatabaseAccessSpaceBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessSpaceAlternativeNamesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesIncInput>;
    _set?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesSetInput>;
    where: StopsDatabaseAccessSpaceAlternativeNamesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessSpaceAlternativeNamesManyArgs =
  {
    updates: Array<StopsDatabaseAccessSpaceAlternativeNamesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessSpaceByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseAccessSpaceIncInput>;
    _set?: InputMaybe<StopsDatabaseAccessSpaceSetInput>;
    pk_columns: StopsDatabaseAccessSpacePkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessSpaceCheckConstraintsArgs =
  {
    _inc?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsIncInput>;
    _set?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsSetInput>;
    where: StopsDatabaseAccessSpaceCheckConstraintsBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessSpaceCheckConstraintsManyArgs =
  {
    updates: Array<StopsDatabaseAccessSpaceCheckConstraintsUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessSpaceEquipmentPlacesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesIncInput>;
    _set?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesSetInput>;
    where: StopsDatabaseAccessSpaceEquipmentPlacesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessSpaceEquipmentPlacesManyArgs =
  {
    updates: Array<StopsDatabaseAccessSpaceEquipmentPlacesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessSpaceKeyValuesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesSetInput>;
    where: StopsDatabaseAccessSpaceKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessSpaceKeyValuesByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesSetInput>;
    pk_columns: StopsDatabaseAccessSpaceKeyValuesPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessSpaceKeyValuesManyArgs =
  {
    updates: Array<StopsDatabaseAccessSpaceKeyValuesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessSpaceManyArgs =
  {
    updates: Array<StopsDatabaseAccessSpaceUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessibilityAssessmentArgs =
  {
    _inc?: InputMaybe<StopsDatabaseAccessibilityAssessmentIncInput>;
    _set?: InputMaybe<StopsDatabaseAccessibilityAssessmentSetInput>;
    where: StopsDatabaseAccessibilityAssessmentBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessibilityAssessmentByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseAccessibilityAssessmentIncInput>;
    _set?: InputMaybe<StopsDatabaseAccessibilityAssessmentSetInput>;
    pk_columns: StopsDatabaseAccessibilityAssessmentPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessibilityAssessmentLimitationsArgs =
  {
    _inc?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsIncInput>;
    _set?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsSetInput>;
    where: StopsDatabaseAccessibilityAssessmentLimitationsBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessibilityAssessmentLimitationsManyArgs =
  {
    updates: Array<StopsDatabaseAccessibilityAssessmentLimitationsUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessibilityAssessmentManyArgs =
  {
    updates: Array<StopsDatabaseAccessibilityAssessmentUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessibilityLimitationArgs =
  {
    _inc?: InputMaybe<StopsDatabaseAccessibilityLimitationIncInput>;
    _set?: InputMaybe<StopsDatabaseAccessibilityLimitationSetInput>;
    where: StopsDatabaseAccessibilityLimitationBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessibilityLimitationByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseAccessibilityLimitationIncInput>;
    _set?: InputMaybe<StopsDatabaseAccessibilityLimitationSetInput>;
    pk_columns: StopsDatabaseAccessibilityLimitationPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessibilityLimitationManyArgs =
  {
    updates: Array<StopsDatabaseAccessibilityLimitationUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAlternativeNameArgs =
  {
    _inc?: InputMaybe<StopsDatabaseAlternativeNameIncInput>;
    _set?: InputMaybe<StopsDatabaseAlternativeNameSetInput>;
    where: StopsDatabaseAlternativeNameBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAlternativeNameByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseAlternativeNameIncInput>;
    _set?: InputMaybe<StopsDatabaseAlternativeNameSetInput>;
    pk_columns: StopsDatabaseAlternativeNamePkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAlternativeNameManyArgs =
  {
    updates: Array<StopsDatabaseAlternativeNameUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateBoardingPositionArgs =
  {
    _inc?: InputMaybe<StopsDatabaseBoardingPositionIncInput>;
    _set?: InputMaybe<StopsDatabaseBoardingPositionSetInput>;
    where: StopsDatabaseBoardingPositionBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateBoardingPositionAlternativeNamesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesIncInput>;
    _set?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesSetInput>;
    where: StopsDatabaseBoardingPositionAlternativeNamesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateBoardingPositionAlternativeNamesManyArgs =
  {
    updates: Array<StopsDatabaseBoardingPositionAlternativeNamesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateBoardingPositionByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseBoardingPositionIncInput>;
    _set?: InputMaybe<StopsDatabaseBoardingPositionSetInput>;
    pk_columns: StopsDatabaseBoardingPositionPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateBoardingPositionCheckConstraintsArgs =
  {
    _inc?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsIncInput>;
    _set?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsSetInput>;
    where: StopsDatabaseBoardingPositionCheckConstraintsBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateBoardingPositionCheckConstraintsManyArgs =
  {
    updates: Array<StopsDatabaseBoardingPositionCheckConstraintsUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateBoardingPositionEquipmentPlacesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesIncInput>;
    _set?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesSetInput>;
    where: StopsDatabaseBoardingPositionEquipmentPlacesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateBoardingPositionEquipmentPlacesManyArgs =
  {
    updates: Array<StopsDatabaseBoardingPositionEquipmentPlacesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateBoardingPositionKeyValuesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesSetInput>;
    where: StopsDatabaseBoardingPositionKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateBoardingPositionKeyValuesByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesSetInput>;
    pk_columns: StopsDatabaseBoardingPositionKeyValuesPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateBoardingPositionKeyValuesManyArgs =
  {
    updates: Array<StopsDatabaseBoardingPositionKeyValuesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateBoardingPositionManyArgs =
  {
    updates: Array<StopsDatabaseBoardingPositionUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateCheckConstraintArgs =
  {
    _inc?: InputMaybe<StopsDatabaseCheckConstraintIncInput>;
    _set?: InputMaybe<StopsDatabaseCheckConstraintSetInput>;
    where: StopsDatabaseCheckConstraintBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateCheckConstraintByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseCheckConstraintIncInput>;
    _set?: InputMaybe<StopsDatabaseCheckConstraintSetInput>;
    pk_columns: StopsDatabaseCheckConstraintPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateCheckConstraintKeyValuesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesSetInput>;
    where: StopsDatabaseCheckConstraintKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateCheckConstraintKeyValuesByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesSetInput>;
    pk_columns: StopsDatabaseCheckConstraintKeyValuesPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateCheckConstraintKeyValuesManyArgs =
  {
    updates: Array<StopsDatabaseCheckConstraintKeyValuesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateCheckConstraintManyArgs =
  {
    updates: Array<StopsDatabaseCheckConstraintUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateDestinationDisplayViewArgs =
  {
    _inc?: InputMaybe<StopsDatabaseDestinationDisplayViewIncInput>;
    _set?: InputMaybe<StopsDatabaseDestinationDisplayViewSetInput>;
    where: StopsDatabaseDestinationDisplayViewBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateDestinationDisplayViewByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseDestinationDisplayViewIncInput>;
    _set?: InputMaybe<StopsDatabaseDestinationDisplayViewSetInput>;
    pk_columns: StopsDatabaseDestinationDisplayViewPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateDestinationDisplayViewManyArgs =
  {
    updates: Array<StopsDatabaseDestinationDisplayViewUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPlaceArgs =
  {
    _inc?: InputMaybe<StopsDatabaseEquipmentPlaceIncInput>;
    _set?: InputMaybe<StopsDatabaseEquipmentPlaceSetInput>;
    where: StopsDatabaseEquipmentPlaceBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPlaceByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseEquipmentPlaceIncInput>;
    _set?: InputMaybe<StopsDatabaseEquipmentPlaceSetInput>;
    pk_columns: StopsDatabaseEquipmentPlacePkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPlaceEquipmentPositionsArgs =
  {
    _inc?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsIncInput>;
    _set?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsSetInput>;
    where: StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPlaceEquipmentPositionsManyArgs =
  {
    updates: Array<StopsDatabaseEquipmentPlaceEquipmentPositionsUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPlaceKeyValuesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesSetInput>;
    where: StopsDatabaseEquipmentPlaceKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPlaceKeyValuesByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesSetInput>;
    pk_columns: StopsDatabaseEquipmentPlaceKeyValuesPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPlaceKeyValuesManyArgs =
  {
    updates: Array<StopsDatabaseEquipmentPlaceKeyValuesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPlaceManyArgs =
  {
    updates: Array<StopsDatabaseEquipmentPlaceUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPositionArgs =
  {
    _inc?: InputMaybe<StopsDatabaseEquipmentPositionIncInput>;
    _set?: InputMaybe<StopsDatabaseEquipmentPositionSetInput>;
    where: StopsDatabaseEquipmentPositionBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPositionByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseEquipmentPositionIncInput>;
    _set?: InputMaybe<StopsDatabaseEquipmentPositionSetInput>;
    pk_columns: StopsDatabaseEquipmentPositionPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPositionKeyValuesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesSetInput>;
    where: StopsDatabaseEquipmentPositionKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPositionKeyValuesByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesSetInput>;
    pk_columns: StopsDatabaseEquipmentPositionKeyValuesPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPositionKeyValuesManyArgs =
  {
    updates: Array<StopsDatabaseEquipmentPositionKeyValuesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPositionManyArgs =
  {
    updates: Array<StopsDatabaseEquipmentPositionUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateExportJobArgs =
  {
    _inc?: InputMaybe<StopsDatabaseExportJobIncInput>;
    _set?: InputMaybe<StopsDatabaseExportJobSetInput>;
    where: StopsDatabaseExportJobBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateExportJobByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseExportJobIncInput>;
    _set?: InputMaybe<StopsDatabaseExportJobSetInput>;
    pk_columns: StopsDatabaseExportJobPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateExportJobManyArgs =
  {
    updates: Array<StopsDatabaseExportJobUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateFareZoneArgs =
  {
    _inc?: InputMaybe<StopsDatabaseFareZoneIncInput>;
    _set?: InputMaybe<StopsDatabaseFareZoneSetInput>;
    where: StopsDatabaseFareZoneBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateFareZoneByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseFareZoneIncInput>;
    _set?: InputMaybe<StopsDatabaseFareZoneSetInput>;
    pk_columns: StopsDatabaseFareZonePkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateFareZoneKeyValuesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseFareZoneKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseFareZoneKeyValuesSetInput>;
    where: StopsDatabaseFareZoneKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateFareZoneKeyValuesByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseFareZoneKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseFareZoneKeyValuesSetInput>;
    pk_columns: StopsDatabaseFareZoneKeyValuesPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateFareZoneKeyValuesManyArgs =
  {
    updates: Array<StopsDatabaseFareZoneKeyValuesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateFareZoneManyArgs =
  {
    updates: Array<StopsDatabaseFareZoneUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateFareZoneMembersArgs =
  {
    _inc?: InputMaybe<StopsDatabaseFareZoneMembersIncInput>;
    _set?: InputMaybe<StopsDatabaseFareZoneMembersSetInput>;
    where: StopsDatabaseFareZoneMembersBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateFareZoneMembersManyArgs =
  {
    updates: Array<StopsDatabaseFareZoneMembersUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateFareZoneNeighboursArgs =
  {
    _inc?: InputMaybe<StopsDatabaseFareZoneNeighboursIncInput>;
    _set?: InputMaybe<StopsDatabaseFareZoneNeighboursSetInput>;
    where: StopsDatabaseFareZoneNeighboursBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateFareZoneNeighboursManyArgs =
  {
    updates: Array<StopsDatabaseFareZoneNeighboursUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGeometryColumnsArgs =
  {
    _inc?: InputMaybe<StopsDatabaseGeometryColumnsIncInput>;
    _set?: InputMaybe<StopsDatabaseGeometryColumnsSetInput>;
    where: StopsDatabaseGeometryColumnsBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGeometryColumnsManyArgs =
  {
    updates: Array<StopsDatabaseGeometryColumnsUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfStopPlacesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseGroupOfStopPlacesIncInput>;
    _set?: InputMaybe<StopsDatabaseGroupOfStopPlacesSetInput>;
    where: StopsDatabaseGroupOfStopPlacesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfStopPlacesAlternativeNamesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesIncInput>;
    _set?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesSetInput>;
    where: StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfStopPlacesAlternativeNamesManyArgs =
  {
    updates: Array<StopsDatabaseGroupOfStopPlacesAlternativeNamesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfStopPlacesByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseGroupOfStopPlacesIncInput>;
    _set?: InputMaybe<StopsDatabaseGroupOfStopPlacesSetInput>;
    pk_columns: StopsDatabaseGroupOfStopPlacesPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfStopPlacesKeyValuesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesSetInput>;
    where: StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfStopPlacesKeyValuesByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesSetInput>;
    pk_columns: StopsDatabaseGroupOfStopPlacesKeyValuesPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfStopPlacesKeyValuesManyArgs =
  {
    updates: Array<StopsDatabaseGroupOfStopPlacesKeyValuesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfStopPlacesManyArgs =
  {
    updates: Array<StopsDatabaseGroupOfStopPlacesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfStopPlacesMembersArgs =
  {
    _inc?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersIncInput>;
    _set?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersSetInput>;
    where: StopsDatabaseGroupOfStopPlacesMembersBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfStopPlacesMembersManyArgs =
  {
    updates: Array<StopsDatabaseGroupOfStopPlacesMembersUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfTariffZonesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseGroupOfTariffZonesIncInput>;
    _set?: InputMaybe<StopsDatabaseGroupOfTariffZonesSetInput>;
    where: StopsDatabaseGroupOfTariffZonesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfTariffZonesByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseGroupOfTariffZonesIncInput>;
    _set?: InputMaybe<StopsDatabaseGroupOfTariffZonesSetInput>;
    pk_columns: StopsDatabaseGroupOfTariffZonesPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfTariffZonesKeyValuesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesSetInput>;
    where: StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfTariffZonesKeyValuesByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesSetInput>;
    pk_columns: StopsDatabaseGroupOfTariffZonesKeyValuesPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfTariffZonesKeyValuesManyArgs =
  {
    updates: Array<StopsDatabaseGroupOfTariffZonesKeyValuesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfTariffZonesManyArgs =
  {
    updates: Array<StopsDatabaseGroupOfTariffZonesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfTariffZonesMembersArgs =
  {
    _inc?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersIncInput>;
    _set?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersSetInput>;
    where: StopsDatabaseGroupOfTariffZonesMembersBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfTariffZonesMembersByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersIncInput>;
    _set?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersSetInput>;
    pk_columns: StopsDatabaseGroupOfTariffZonesMembersPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfTariffZonesMembersManyArgs =
  {
    updates: Array<StopsDatabaseGroupOfTariffZonesMembersUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateIdGeneratorArgs =
  {
    _inc?: InputMaybe<StopsDatabaseIdGeneratorIncInput>;
    _set?: InputMaybe<StopsDatabaseIdGeneratorSetInput>;
    where: StopsDatabaseIdGeneratorBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateIdGeneratorManyArgs =
  {
    updates: Array<StopsDatabaseIdGeneratorUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateInstalledEquipmentArgs =
  {
    _inc?: InputMaybe<StopsDatabaseInstalledEquipmentIncInput>;
    _set?: InputMaybe<StopsDatabaseInstalledEquipmentSetInput>;
    where: StopsDatabaseInstalledEquipmentBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateInstalledEquipmentManyArgs =
  {
    updates: Array<StopsDatabaseInstalledEquipmentUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateInstalledEquipmentVersionStructureArgs =
  {
    _inc?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureIncInput>;
    _set?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureSetInput>;
    where: StopsDatabaseInstalledEquipmentVersionStructureBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateInstalledEquipmentVersionStructureByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureIncInput>;
    _set?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureSetInput>;
    pk_columns: StopsDatabaseInstalledEquipmentVersionStructurePkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateInstalledEquipmentVersionStructureInstalledEquipmentArgs =
  {
    _inc?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentIncInput>;
    _set?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSetInput>;
    where: StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateInstalledEquipmentVersionStructureInstalledEquipmentManyArgs =
  {
    updates: Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateInstalledEquipmentVersionStructureManyArgs =
  {
    updates: Array<StopsDatabaseInstalledEquipmentVersionStructureUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateLevelArgs =
  {
    _inc?: InputMaybe<StopsDatabaseLevelIncInput>;
    _set?: InputMaybe<StopsDatabaseLevelSetInput>;
    where: StopsDatabaseLevelBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateLevelByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseLevelIncInput>;
    _set?: InputMaybe<StopsDatabaseLevelSetInput>;
    pk_columns: StopsDatabaseLevelPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateLevelKeyValuesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseLevelKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseLevelKeyValuesSetInput>;
    where: StopsDatabaseLevelKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateLevelKeyValuesByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseLevelKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseLevelKeyValuesSetInput>;
    pk_columns: StopsDatabaseLevelKeyValuesPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateLevelKeyValuesManyArgs =
  {
    updates: Array<StopsDatabaseLevelKeyValuesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateLevelManyArgs =
  {
    updates: Array<StopsDatabaseLevelUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateMultilingualStringEntityArgs =
  {
    _inc?: InputMaybe<StopsDatabaseMultilingualStringEntityIncInput>;
    _set?: InputMaybe<StopsDatabaseMultilingualStringEntitySetInput>;
    where: StopsDatabaseMultilingualStringEntityBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateMultilingualStringEntityByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseMultilingualStringEntityIncInput>;
    _set?: InputMaybe<StopsDatabaseMultilingualStringEntitySetInput>;
    pk_columns: StopsDatabaseMultilingualStringEntityPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateMultilingualStringEntityManyArgs =
  {
    updates: Array<StopsDatabaseMultilingualStringEntityUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateNavigationPathArgs =
  {
    _inc?: InputMaybe<StopsDatabaseNavigationPathIncInput>;
    _set?: InputMaybe<StopsDatabaseNavigationPathSetInput>;
    where: StopsDatabaseNavigationPathBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateNavigationPathManyArgs =
  {
    updates: Array<StopsDatabaseNavigationPathUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingArgs =
  {
    _inc?: InputMaybe<StopsDatabaseParkingIncInput>;
    _set?: InputMaybe<StopsDatabaseParkingSetInput>;
    where: StopsDatabaseParkingBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAdjacentSitesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseParkingAdjacentSitesIncInput>;
    _set?: InputMaybe<StopsDatabaseParkingAdjacentSitesSetInput>;
    where: StopsDatabaseParkingAdjacentSitesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAdjacentSitesManyArgs =
  {
    updates: Array<StopsDatabaseParkingAdjacentSitesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAlternativeNamesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseParkingAlternativeNamesIncInput>;
    _set?: InputMaybe<StopsDatabaseParkingAlternativeNamesSetInput>;
    where: StopsDatabaseParkingAlternativeNamesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAlternativeNamesManyArgs =
  {
    updates: Array<StopsDatabaseParkingAlternativeNamesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAreaArgs =
  {
    _inc?: InputMaybe<StopsDatabaseParkingAreaIncInput>;
    _set?: InputMaybe<StopsDatabaseParkingAreaSetInput>;
    where: StopsDatabaseParkingAreaBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAreaAlternativeNamesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesIncInput>;
    _set?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesSetInput>;
    where: StopsDatabaseParkingAreaAlternativeNamesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAreaAlternativeNamesManyArgs =
  {
    updates: Array<StopsDatabaseParkingAreaAlternativeNamesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAreaByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseParkingAreaIncInput>;
    _set?: InputMaybe<StopsDatabaseParkingAreaSetInput>;
    pk_columns: StopsDatabaseParkingAreaPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAreaCheckConstraintsArgs =
  {
    _inc?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsIncInput>;
    _set?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsSetInput>;
    where: StopsDatabaseParkingAreaCheckConstraintsBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAreaCheckConstraintsManyArgs =
  {
    updates: Array<StopsDatabaseParkingAreaCheckConstraintsUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAreaEquipmentPlacesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesIncInput>;
    _set?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesSetInput>;
    where: StopsDatabaseParkingAreaEquipmentPlacesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAreaEquipmentPlacesManyArgs =
  {
    updates: Array<StopsDatabaseParkingAreaEquipmentPlacesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAreaKeyValuesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseParkingAreaKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseParkingAreaKeyValuesSetInput>;
    where: StopsDatabaseParkingAreaKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAreaKeyValuesByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseParkingAreaKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseParkingAreaKeyValuesSetInput>;
    pk_columns: StopsDatabaseParkingAreaKeyValuesPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAreaKeyValuesManyArgs =
  {
    updates: Array<StopsDatabaseParkingAreaKeyValuesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAreaManyArgs =
  {
    updates: Array<StopsDatabaseParkingAreaUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseParkingIncInput>;
    _set?: InputMaybe<StopsDatabaseParkingSetInput>;
    pk_columns: StopsDatabaseParkingPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingCapacityArgs =
  {
    _inc?: InputMaybe<StopsDatabaseParkingCapacityIncInput>;
    _set?: InputMaybe<StopsDatabaseParkingCapacitySetInput>;
    where: StopsDatabaseParkingCapacityBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingCapacityByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseParkingCapacityIncInput>;
    _set?: InputMaybe<StopsDatabaseParkingCapacitySetInput>;
    pk_columns: StopsDatabaseParkingCapacityPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingCapacityManyArgs =
  {
    updates: Array<StopsDatabaseParkingCapacityUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingEquipmentPlacesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseParkingEquipmentPlacesIncInput>;
    _set?: InputMaybe<StopsDatabaseParkingEquipmentPlacesSetInput>;
    where: StopsDatabaseParkingEquipmentPlacesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingEquipmentPlacesManyArgs =
  {
    updates: Array<StopsDatabaseParkingEquipmentPlacesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingKeyValuesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseParkingKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseParkingKeyValuesSetInput>;
    where: StopsDatabaseParkingKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingKeyValuesByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseParkingKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseParkingKeyValuesSetInput>;
    pk_columns: StopsDatabaseParkingKeyValuesPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingKeyValuesManyArgs =
  {
    updates: Array<StopsDatabaseParkingKeyValuesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingManyArgs =
  {
    updates: Array<StopsDatabaseParkingUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingParkingAreasArgs =
  {
    _inc?: InputMaybe<StopsDatabaseParkingParkingAreasIncInput>;
    _set?: InputMaybe<StopsDatabaseParkingParkingAreasSetInput>;
    where: StopsDatabaseParkingParkingAreasBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingParkingAreasManyArgs =
  {
    updates: Array<StopsDatabaseParkingParkingAreasUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingParkingPaymentProcessArgs =
  {
    _inc?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessIncInput>;
    _set?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessSetInput>;
    where: StopsDatabaseParkingParkingPaymentProcessBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingParkingPaymentProcessManyArgs =
  {
    updates: Array<StopsDatabaseParkingParkingPaymentProcessUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingParkingPropertiesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseParkingParkingPropertiesIncInput>;
    _set?: InputMaybe<StopsDatabaseParkingParkingPropertiesSetInput>;
    where: StopsDatabaseParkingParkingPropertiesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingParkingPropertiesManyArgs =
  {
    updates: Array<StopsDatabaseParkingParkingPropertiesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingParkingVehicleTypesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesIncInput>;
    _set?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesSetInput>;
    where: StopsDatabaseParkingParkingVehicleTypesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingParkingVehicleTypesManyArgs =
  {
    updates: Array<StopsDatabaseParkingParkingVehicleTypesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingPropertiesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseParkingPropertiesIncInput>;
    _set?: InputMaybe<StopsDatabaseParkingPropertiesSetInput>;
    where: StopsDatabaseParkingPropertiesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingPropertiesByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseParkingPropertiesIncInput>;
    _set?: InputMaybe<StopsDatabaseParkingPropertiesSetInput>;
    pk_columns: StopsDatabaseParkingPropertiesPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingPropertiesManyArgs =
  {
    updates: Array<StopsDatabaseParkingPropertiesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingPropertiesParkingUserTypesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseParkingPropertiesParkingUserTypesIncInput>;
    _set?: InputMaybe<StopsDatabaseParkingPropertiesParkingUserTypesSetInput>;
    where: StopsDatabaseParkingPropertiesParkingUserTypesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingPropertiesParkingUserTypesManyArgs =
  {
    updates: Array<StopsDatabaseParkingPropertiesParkingUserTypesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingPropertiesSpacesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseParkingPropertiesSpacesIncInput>;
    _set?: InputMaybe<StopsDatabaseParkingPropertiesSpacesSetInput>;
    where: StopsDatabaseParkingPropertiesSpacesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingPropertiesSpacesManyArgs =
  {
    updates: Array<StopsDatabaseParkingPropertiesSpacesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathJunctionArgs =
  {
    _inc?: InputMaybe<StopsDatabasePathJunctionIncInput>;
    _set?: InputMaybe<StopsDatabasePathJunctionSetInput>;
    where: StopsDatabasePathJunctionBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathJunctionByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabasePathJunctionIncInput>;
    _set?: InputMaybe<StopsDatabasePathJunctionSetInput>;
    pk_columns: StopsDatabasePathJunctionPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathJunctionKeyValuesArgs =
  {
    _inc?: InputMaybe<StopsDatabasePathJunctionKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabasePathJunctionKeyValuesSetInput>;
    where: StopsDatabasePathJunctionKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathJunctionKeyValuesByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabasePathJunctionKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabasePathJunctionKeyValuesSetInput>;
    pk_columns: StopsDatabasePathJunctionKeyValuesPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathJunctionKeyValuesManyArgs =
  {
    updates: Array<StopsDatabasePathJunctionKeyValuesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathJunctionManyArgs =
  {
    updates: Array<StopsDatabasePathJunctionUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathLinkArgs =
  {
    _inc?: InputMaybe<StopsDatabasePathLinkIncInput>;
    _set?: InputMaybe<StopsDatabasePathLinkSetInput>;
    where: StopsDatabasePathLinkBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathLinkByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabasePathLinkIncInput>;
    _set?: InputMaybe<StopsDatabasePathLinkSetInput>;
    pk_columns: StopsDatabasePathLinkPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathLinkEndArgs =
  {
    _inc?: InputMaybe<StopsDatabasePathLinkEndIncInput>;
    _set?: InputMaybe<StopsDatabasePathLinkEndSetInput>;
    where: StopsDatabasePathLinkEndBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathLinkEndByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabasePathLinkEndIncInput>;
    _set?: InputMaybe<StopsDatabasePathLinkEndSetInput>;
    pk_columns: StopsDatabasePathLinkEndPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathLinkEndManyArgs =
  {
    updates: Array<StopsDatabasePathLinkEndUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathLinkKeyValuesArgs =
  {
    _inc?: InputMaybe<StopsDatabasePathLinkKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabasePathLinkKeyValuesSetInput>;
    where: StopsDatabasePathLinkKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathLinkKeyValuesByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabasePathLinkKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabasePathLinkKeyValuesSetInput>;
    pk_columns: StopsDatabasePathLinkKeyValuesPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathLinkKeyValuesManyArgs =
  {
    updates: Array<StopsDatabasePathLinkKeyValuesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathLinkManyArgs =
  {
    updates: Array<StopsDatabasePathLinkUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePersistablePolygonArgs =
  {
    _inc?: InputMaybe<StopsDatabasePersistablePolygonIncInput>;
    _set?: InputMaybe<StopsDatabasePersistablePolygonSetInput>;
    where: StopsDatabasePersistablePolygonBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePersistablePolygonByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabasePersistablePolygonIncInput>;
    _set?: InputMaybe<StopsDatabasePersistablePolygonSetInput>;
    pk_columns: StopsDatabasePersistablePolygonPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePersistablePolygonManyArgs =
  {
    updates: Array<StopsDatabasePersistablePolygonUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePurposeOfGroupingArgs =
  {
    _inc?: InputMaybe<StopsDatabasePurposeOfGroupingIncInput>;
    _set?: InputMaybe<StopsDatabasePurposeOfGroupingSetInput>;
    where: StopsDatabasePurposeOfGroupingBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePurposeOfGroupingByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabasePurposeOfGroupingIncInput>;
    _set?: InputMaybe<StopsDatabasePurposeOfGroupingSetInput>;
    pk_columns: StopsDatabasePurposeOfGroupingPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePurposeOfGroupingKeyValuesArgs =
  {
    _inc?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesSetInput>;
    where: StopsDatabasePurposeOfGroupingKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePurposeOfGroupingKeyValuesByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesSetInput>;
    pk_columns: StopsDatabasePurposeOfGroupingKeyValuesPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePurposeOfGroupingKeyValuesManyArgs =
  {
    updates: Array<StopsDatabasePurposeOfGroupingKeyValuesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePurposeOfGroupingManyArgs =
  {
    updates: Array<StopsDatabasePurposeOfGroupingUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayArgs =
  {
    _inc?: InputMaybe<StopsDatabaseQuayIncInput>;
    _set?: InputMaybe<StopsDatabaseQuaySetInput>;
    where: StopsDatabaseQuayBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayAlternativeNamesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseQuayAlternativeNamesIncInput>;
    _set?: InputMaybe<StopsDatabaseQuayAlternativeNamesSetInput>;
    where: StopsDatabaseQuayAlternativeNamesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayAlternativeNamesManyArgs =
  {
    updates: Array<StopsDatabaseQuayAlternativeNamesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayBoardingPositionsArgs =
  {
    _inc?: InputMaybe<StopsDatabaseQuayBoardingPositionsIncInput>;
    _set?: InputMaybe<StopsDatabaseQuayBoardingPositionsSetInput>;
    where: StopsDatabaseQuayBoardingPositionsBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayBoardingPositionsManyArgs =
  {
    updates: Array<StopsDatabaseQuayBoardingPositionsUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseQuayIncInput>;
    _set?: InputMaybe<StopsDatabaseQuaySetInput>;
    pk_columns: StopsDatabaseQuayPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayCheckConstraintsArgs =
  {
    _inc?: InputMaybe<StopsDatabaseQuayCheckConstraintsIncInput>;
    _set?: InputMaybe<StopsDatabaseQuayCheckConstraintsSetInput>;
    where: StopsDatabaseQuayCheckConstraintsBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayCheckConstraintsManyArgs =
  {
    updates: Array<StopsDatabaseQuayCheckConstraintsUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayEquipmentPlacesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseQuayEquipmentPlacesIncInput>;
    _set?: InputMaybe<StopsDatabaseQuayEquipmentPlacesSetInput>;
    where: StopsDatabaseQuayEquipmentPlacesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayEquipmentPlacesManyArgs =
  {
    updates: Array<StopsDatabaseQuayEquipmentPlacesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayKeyValuesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseQuayKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseQuayKeyValuesSetInput>;
    where: StopsDatabaseQuayKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayKeyValuesByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseQuayKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseQuayKeyValuesSetInput>;
    pk_columns: StopsDatabaseQuayKeyValuesPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayKeyValuesManyArgs =
  {
    updates: Array<StopsDatabaseQuayKeyValuesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayManyArgs =
  {
    updates: Array<StopsDatabaseQuayUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateSchemaVersionArgs =
  {
    _inc?: InputMaybe<StopsDatabaseSchemaVersionIncInput>;
    _set?: InputMaybe<StopsDatabaseSchemaVersionSetInput>;
    where: StopsDatabaseSchemaVersionBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateSchemaVersionByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseSchemaVersionIncInput>;
    _set?: InputMaybe<StopsDatabaseSchemaVersionSetInput>;
    pk_columns: StopsDatabaseSchemaVersionPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateSchemaVersionManyArgs =
  {
    updates: Array<StopsDatabaseSchemaVersionUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateSpatialRefSysArgs =
  {
    _inc?: InputMaybe<StopsDatabaseSpatialRefSysIncInput>;
    _set?: InputMaybe<StopsDatabaseSpatialRefSysSetInput>;
    where: StopsDatabaseSpatialRefSysBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateSpatialRefSysByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseSpatialRefSysIncInput>;
    _set?: InputMaybe<StopsDatabaseSpatialRefSysSetInput>;
    pk_columns: StopsDatabaseSpatialRefSysPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateSpatialRefSysManyArgs =
  {
    updates: Array<StopsDatabaseSpatialRefSysUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceArgs =
  {
    _inc?: InputMaybe<StopsDatabaseStopPlaceIncInput>;
    _set?: InputMaybe<StopsDatabaseStopPlaceSetInput>;
    where: StopsDatabaseStopPlaceBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceAccessSpacesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesIncInput>;
    _set?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesSetInput>;
    where: StopsDatabaseStopPlaceAccessSpacesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceAccessSpacesManyArgs =
  {
    updates: Array<StopsDatabaseStopPlaceAccessSpacesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceAdjacentSitesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseStopPlaceAdjacentSitesIncInput>;
    _set?: InputMaybe<StopsDatabaseStopPlaceAdjacentSitesSetInput>;
    where: StopsDatabaseStopPlaceAdjacentSitesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceAdjacentSitesManyArgs =
  {
    updates: Array<StopsDatabaseStopPlaceAdjacentSitesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceAlternativeNamesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesIncInput>;
    _set?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesSetInput>;
    where: StopsDatabaseStopPlaceAlternativeNamesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceAlternativeNamesManyArgs =
  {
    updates: Array<StopsDatabaseStopPlaceAlternativeNamesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseStopPlaceIncInput>;
    _set?: InputMaybe<StopsDatabaseStopPlaceSetInput>;
    pk_columns: StopsDatabaseStopPlacePkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceChildrenArgs =
  {
    _inc?: InputMaybe<StopsDatabaseStopPlaceChildrenIncInput>;
    _set?: InputMaybe<StopsDatabaseStopPlaceChildrenSetInput>;
    where: StopsDatabaseStopPlaceChildrenBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceChildrenByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseStopPlaceChildrenIncInput>;
    _set?: InputMaybe<StopsDatabaseStopPlaceChildrenSetInput>;
    pk_columns: StopsDatabaseStopPlaceChildrenPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceChildrenManyArgs =
  {
    updates: Array<StopsDatabaseStopPlaceChildrenUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceEquipmentPlacesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesIncInput>;
    _set?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesSetInput>;
    where: StopsDatabaseStopPlaceEquipmentPlacesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceEquipmentPlacesManyArgs =
  {
    updates: Array<StopsDatabaseStopPlaceEquipmentPlacesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceKeyValuesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseStopPlaceKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseStopPlaceKeyValuesSetInput>;
    where: StopsDatabaseStopPlaceKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceKeyValuesByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseStopPlaceKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseStopPlaceKeyValuesSetInput>;
    pk_columns: StopsDatabaseStopPlaceKeyValuesPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceKeyValuesManyArgs =
  {
    updates: Array<StopsDatabaseStopPlaceKeyValuesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceManyArgs =
  {
    updates: Array<StopsDatabaseStopPlaceUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceQuaysArgs =
  {
    _inc?: InputMaybe<StopsDatabaseStopPlaceQuaysIncInput>;
    _set?: InputMaybe<StopsDatabaseStopPlaceQuaysSetInput>;
    where: StopsDatabaseStopPlaceQuaysBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceQuaysByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseStopPlaceQuaysIncInput>;
    _set?: InputMaybe<StopsDatabaseStopPlaceQuaysSetInput>;
    pk_columns: StopsDatabaseStopPlaceQuaysPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceQuaysManyArgs =
  {
    updates: Array<StopsDatabaseStopPlaceQuaysUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceTariffZonesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseStopPlaceTariffZonesIncInput>;
    _set?: InputMaybe<StopsDatabaseStopPlaceTariffZonesSetInput>;
    where: StopsDatabaseStopPlaceTariffZonesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceTariffZonesManyArgs =
  {
    updates: Array<StopsDatabaseStopPlaceTariffZonesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTagArgs =
  {
    _set?: InputMaybe<StopsDatabaseTagSetInput>;
    where: StopsDatabaseTagBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTagByPkArgs =
  {
    _set?: InputMaybe<StopsDatabaseTagSetInput>;
    pk_columns: StopsDatabaseTagPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTagManyArgs =
  {
    updates: Array<StopsDatabaseTagUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTariffZoneArgs =
  {
    _inc?: InputMaybe<StopsDatabaseTariffZoneIncInput>;
    _set?: InputMaybe<StopsDatabaseTariffZoneSetInput>;
    where: StopsDatabaseTariffZoneBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTariffZoneByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseTariffZoneIncInput>;
    _set?: InputMaybe<StopsDatabaseTariffZoneSetInput>;
    pk_columns: StopsDatabaseTariffZonePkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTariffZoneKeyValuesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseTariffZoneKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseTariffZoneKeyValuesSetInput>;
    where: StopsDatabaseTariffZoneKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTariffZoneKeyValuesByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseTariffZoneKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseTariffZoneKeyValuesSetInput>;
    pk_columns: StopsDatabaseTariffZoneKeyValuesPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTariffZoneKeyValuesManyArgs =
  {
    updates: Array<StopsDatabaseTariffZoneKeyValuesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTariffZoneManyArgs =
  {
    updates: Array<StopsDatabaseTariffZoneUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTopographicPlaceArgs =
  {
    _inc?: InputMaybe<StopsDatabaseTopographicPlaceIncInput>;
    _set?: InputMaybe<StopsDatabaseTopographicPlaceSetInput>;
    where: StopsDatabaseTopographicPlaceBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTopographicPlaceByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseTopographicPlaceIncInput>;
    _set?: InputMaybe<StopsDatabaseTopographicPlaceSetInput>;
    pk_columns: StopsDatabaseTopographicPlacePkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTopographicPlaceKeyValuesArgs =
  {
    _inc?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesSetInput>;
    where: StopsDatabaseTopographicPlaceKeyValuesBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTopographicPlaceKeyValuesByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesIncInput>;
    _set?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesSetInput>;
    pk_columns: StopsDatabaseTopographicPlaceKeyValuesPkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTopographicPlaceKeyValuesManyArgs =
  {
    updates: Array<StopsDatabaseTopographicPlaceKeyValuesUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTopographicPlaceManyArgs =
  {
    updates: Array<StopsDatabaseTopographicPlaceUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateValueArgs =
  {
    _inc?: InputMaybe<StopsDatabaseValueIncInput>;
    _set?: InputMaybe<StopsDatabaseValueSetInput>;
    where: StopsDatabaseValueBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateValueByPkArgs =
  {
    _inc?: InputMaybe<StopsDatabaseValueIncInput>;
    _set?: InputMaybe<StopsDatabaseValueSetInput>;
    pk_columns: StopsDatabaseValuePkColumnsInput;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateValueItemsArgs =
  {
    _inc?: InputMaybe<StopsDatabaseValueItemsIncInput>;
    _set?: InputMaybe<StopsDatabaseValueItemsSetInput>;
    where: StopsDatabaseValueItemsBoolExp;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateValueItemsManyArgs =
  {
    updates: Array<StopsDatabaseValueItemsUpdates>;
  };

export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateValueManyArgs =
  {
    updates: Array<StopsDatabaseValueUpdates>;
  };

export type StopsDatabaseStopsDatabaseQuery = {
  __typename?: 'stops_database_stops_database_query';
  /** fetch data from the table: "access_space" */
  stops_database_access_space: Array<StopsDatabaseAccessSpace>;
  /** fetch aggregated fields from the table: "access_space" */
  stops_database_access_space_aggregate: StopsDatabaseAccessSpaceAggregate;
  /** fetch data from the table: "access_space_alternative_names" */
  stops_database_access_space_alternative_names: Array<StopsDatabaseAccessSpaceAlternativeNames>;
  /** fetch aggregated fields from the table: "access_space_alternative_names" */
  stops_database_access_space_alternative_names_aggregate: StopsDatabaseAccessSpaceAlternativeNamesAggregate;
  /** fetch data from the table: "access_space" using primary key columns */
  stops_database_access_space_by_pk?: Maybe<StopsDatabaseAccessSpace>;
  /** fetch data from the table: "access_space_check_constraints" */
  stops_database_access_space_check_constraints: Array<StopsDatabaseAccessSpaceCheckConstraints>;
  /** fetch aggregated fields from the table: "access_space_check_constraints" */
  stops_database_access_space_check_constraints_aggregate: StopsDatabaseAccessSpaceCheckConstraintsAggregate;
  /** fetch data from the table: "access_space_equipment_places" */
  stops_database_access_space_equipment_places: Array<StopsDatabaseAccessSpaceEquipmentPlaces>;
  /** fetch aggregated fields from the table: "access_space_equipment_places" */
  stops_database_access_space_equipment_places_aggregate: StopsDatabaseAccessSpaceEquipmentPlacesAggregate;
  /** fetch data from the table: "access_space_key_values" */
  stops_database_access_space_key_values: Array<StopsDatabaseAccessSpaceKeyValues>;
  /** fetch aggregated fields from the table: "access_space_key_values" */
  stops_database_access_space_key_values_aggregate: StopsDatabaseAccessSpaceKeyValuesAggregate;
  /** fetch data from the table: "access_space_key_values" using primary key columns */
  stops_database_access_space_key_values_by_pk?: Maybe<StopsDatabaseAccessSpaceKeyValues>;
  /** fetch data from the table: "accessibility_assessment" */
  stops_database_accessibility_assessment: Array<StopsDatabaseAccessibilityAssessment>;
  /** fetch aggregated fields from the table: "accessibility_assessment" */
  stops_database_accessibility_assessment_aggregate: StopsDatabaseAccessibilityAssessmentAggregate;
  /** fetch data from the table: "accessibility_assessment" using primary key columns */
  stops_database_accessibility_assessment_by_pk?: Maybe<StopsDatabaseAccessibilityAssessment>;
  /** fetch data from the table: "accessibility_assessment_limitations" */
  stops_database_accessibility_assessment_limitations: Array<StopsDatabaseAccessibilityAssessmentLimitations>;
  /** fetch aggregated fields from the table: "accessibility_assessment_limitations" */
  stops_database_accessibility_assessment_limitations_aggregate: StopsDatabaseAccessibilityAssessmentLimitationsAggregate;
  /** fetch data from the table: "accessibility_limitation" */
  stops_database_accessibility_limitation: Array<StopsDatabaseAccessibilityLimitation>;
  /** fetch aggregated fields from the table: "accessibility_limitation" */
  stops_database_accessibility_limitation_aggregate: StopsDatabaseAccessibilityLimitationAggregate;
  /** fetch data from the table: "accessibility_limitation" using primary key columns */
  stops_database_accessibility_limitation_by_pk?: Maybe<StopsDatabaseAccessibilityLimitation>;
  /** fetch data from the table: "alternative_name" */
  stops_database_alternative_name: Array<StopsDatabaseAlternativeName>;
  /** fetch aggregated fields from the table: "alternative_name" */
  stops_database_alternative_name_aggregate: StopsDatabaseAlternativeNameAggregate;
  /** fetch data from the table: "alternative_name" using primary key columns */
  stops_database_alternative_name_by_pk?: Maybe<StopsDatabaseAlternativeName>;
  /** fetch data from the table: "boarding_position" */
  stops_database_boarding_position: Array<StopsDatabaseBoardingPosition>;
  /** fetch aggregated fields from the table: "boarding_position" */
  stops_database_boarding_position_aggregate: StopsDatabaseBoardingPositionAggregate;
  /** fetch data from the table: "boarding_position_alternative_names" */
  stops_database_boarding_position_alternative_names: Array<StopsDatabaseBoardingPositionAlternativeNames>;
  /** fetch aggregated fields from the table: "boarding_position_alternative_names" */
  stops_database_boarding_position_alternative_names_aggregate: StopsDatabaseBoardingPositionAlternativeNamesAggregate;
  /** fetch data from the table: "boarding_position" using primary key columns */
  stops_database_boarding_position_by_pk?: Maybe<StopsDatabaseBoardingPosition>;
  /** fetch data from the table: "boarding_position_check_constraints" */
  stops_database_boarding_position_check_constraints: Array<StopsDatabaseBoardingPositionCheckConstraints>;
  /** fetch aggregated fields from the table: "boarding_position_check_constraints" */
  stops_database_boarding_position_check_constraints_aggregate: StopsDatabaseBoardingPositionCheckConstraintsAggregate;
  /** fetch data from the table: "boarding_position_equipment_places" */
  stops_database_boarding_position_equipment_places: Array<StopsDatabaseBoardingPositionEquipmentPlaces>;
  /** fetch aggregated fields from the table: "boarding_position_equipment_places" */
  stops_database_boarding_position_equipment_places_aggregate: StopsDatabaseBoardingPositionEquipmentPlacesAggregate;
  /** fetch data from the table: "boarding_position_key_values" */
  stops_database_boarding_position_key_values: Array<StopsDatabaseBoardingPositionKeyValues>;
  /** fetch aggregated fields from the table: "boarding_position_key_values" */
  stops_database_boarding_position_key_values_aggregate: StopsDatabaseBoardingPositionKeyValuesAggregate;
  /** fetch data from the table: "boarding_position_key_values" using primary key columns */
  stops_database_boarding_position_key_values_by_pk?: Maybe<StopsDatabaseBoardingPositionKeyValues>;
  /** fetch data from the table: "check_constraint" */
  stops_database_check_constraint: Array<StopsDatabaseCheckConstraint>;
  /** fetch aggregated fields from the table: "check_constraint" */
  stops_database_check_constraint_aggregate: StopsDatabaseCheckConstraintAggregate;
  /** fetch data from the table: "check_constraint" using primary key columns */
  stops_database_check_constraint_by_pk?: Maybe<StopsDatabaseCheckConstraint>;
  /** fetch data from the table: "check_constraint_key_values" */
  stops_database_check_constraint_key_values: Array<StopsDatabaseCheckConstraintKeyValues>;
  /** fetch aggregated fields from the table: "check_constraint_key_values" */
  stops_database_check_constraint_key_values_aggregate: StopsDatabaseCheckConstraintKeyValuesAggregate;
  /** fetch data from the table: "check_constraint_key_values" using primary key columns */
  stops_database_check_constraint_key_values_by_pk?: Maybe<StopsDatabaseCheckConstraintKeyValues>;
  /** fetch data from the table: "destination_display_view" */
  stops_database_destination_display_view: Array<StopsDatabaseDestinationDisplayView>;
  /** fetch aggregated fields from the table: "destination_display_view" */
  stops_database_destination_display_view_aggregate: StopsDatabaseDestinationDisplayViewAggregate;
  /** fetch data from the table: "destination_display_view" using primary key columns */
  stops_database_destination_display_view_by_pk?: Maybe<StopsDatabaseDestinationDisplayView>;
  /** fetch data from the table: "equipment_place" */
  stops_database_equipment_place: Array<StopsDatabaseEquipmentPlace>;
  /** fetch aggregated fields from the table: "equipment_place" */
  stops_database_equipment_place_aggregate: StopsDatabaseEquipmentPlaceAggregate;
  /** fetch data from the table: "equipment_place" using primary key columns */
  stops_database_equipment_place_by_pk?: Maybe<StopsDatabaseEquipmentPlace>;
  /** fetch data from the table: "equipment_place_equipment_positions" */
  stops_database_equipment_place_equipment_positions: Array<StopsDatabaseEquipmentPlaceEquipmentPositions>;
  /** fetch aggregated fields from the table: "equipment_place_equipment_positions" */
  stops_database_equipment_place_equipment_positions_aggregate: StopsDatabaseEquipmentPlaceEquipmentPositionsAggregate;
  /** fetch data from the table: "equipment_place_key_values" */
  stops_database_equipment_place_key_values: Array<StopsDatabaseEquipmentPlaceKeyValues>;
  /** fetch aggregated fields from the table: "equipment_place_key_values" */
  stops_database_equipment_place_key_values_aggregate: StopsDatabaseEquipmentPlaceKeyValuesAggregate;
  /** fetch data from the table: "equipment_place_key_values" using primary key columns */
  stops_database_equipment_place_key_values_by_pk?: Maybe<StopsDatabaseEquipmentPlaceKeyValues>;
  /** fetch data from the table: "equipment_position" */
  stops_database_equipment_position: Array<StopsDatabaseEquipmentPosition>;
  /** fetch aggregated fields from the table: "equipment_position" */
  stops_database_equipment_position_aggregate: StopsDatabaseEquipmentPositionAggregate;
  /** fetch data from the table: "equipment_position" using primary key columns */
  stops_database_equipment_position_by_pk?: Maybe<StopsDatabaseEquipmentPosition>;
  /** fetch data from the table: "equipment_position_key_values" */
  stops_database_equipment_position_key_values: Array<StopsDatabaseEquipmentPositionKeyValues>;
  /** fetch aggregated fields from the table: "equipment_position_key_values" */
  stops_database_equipment_position_key_values_aggregate: StopsDatabaseEquipmentPositionKeyValuesAggregate;
  /** fetch data from the table: "equipment_position_key_values" using primary key columns */
  stops_database_equipment_position_key_values_by_pk?: Maybe<StopsDatabaseEquipmentPositionKeyValues>;
  /** fetch data from the table: "export_job" */
  stops_database_export_job: Array<StopsDatabaseExportJob>;
  /** fetch aggregated fields from the table: "export_job" */
  stops_database_export_job_aggregate: StopsDatabaseExportJobAggregate;
  /** fetch data from the table: "export_job" using primary key columns */
  stops_database_export_job_by_pk?: Maybe<StopsDatabaseExportJob>;
  /** fetch data from the table: "fare_zone" */
  stops_database_fare_zone: Array<StopsDatabaseFareZone>;
  /** fetch aggregated fields from the table: "fare_zone" */
  stops_database_fare_zone_aggregate: StopsDatabaseFareZoneAggregate;
  /** fetch data from the table: "fare_zone" using primary key columns */
  stops_database_fare_zone_by_pk?: Maybe<StopsDatabaseFareZone>;
  /** fetch data from the table: "fare_zone_key_values" */
  stops_database_fare_zone_key_values: Array<StopsDatabaseFareZoneKeyValues>;
  /** fetch aggregated fields from the table: "fare_zone_key_values" */
  stops_database_fare_zone_key_values_aggregate: StopsDatabaseFareZoneKeyValuesAggregate;
  /** fetch data from the table: "fare_zone_key_values" using primary key columns */
  stops_database_fare_zone_key_values_by_pk?: Maybe<StopsDatabaseFareZoneKeyValues>;
  /** fetch data from the table: "fare_zone_members" */
  stops_database_fare_zone_members: Array<StopsDatabaseFareZoneMembers>;
  /** fetch aggregated fields from the table: "fare_zone_members" */
  stops_database_fare_zone_members_aggregate: StopsDatabaseFareZoneMembersAggregate;
  /** fetch data from the table: "fare_zone_neighbours" */
  stops_database_fare_zone_neighbours: Array<StopsDatabaseFareZoneNeighbours>;
  /** fetch aggregated fields from the table: "fare_zone_neighbours" */
  stops_database_fare_zone_neighbours_aggregate: StopsDatabaseFareZoneNeighboursAggregate;
  /** fetch data from the table: "geography_columns" */
  stops_database_geography_columns: Array<StopsDatabaseGeographyColumns>;
  /** fetch aggregated fields from the table: "geography_columns" */
  stops_database_geography_columns_aggregate: StopsDatabaseGeographyColumnsAggregate;
  /** fetch data from the table: "geometry_columns" */
  stops_database_geometry_columns: Array<StopsDatabaseGeometryColumns>;
  /** fetch aggregated fields from the table: "geometry_columns" */
  stops_database_geometry_columns_aggregate: StopsDatabaseGeometryColumnsAggregate;
  /** fetch data from the table: "group_of_stop_places" */
  stops_database_group_of_stop_places: Array<StopsDatabaseGroupOfStopPlaces>;
  /** fetch aggregated fields from the table: "group_of_stop_places" */
  stops_database_group_of_stop_places_aggregate: StopsDatabaseGroupOfStopPlacesAggregate;
  /** fetch data from the table: "group_of_stop_places_alternative_names" */
  stops_database_group_of_stop_places_alternative_names: Array<StopsDatabaseGroupOfStopPlacesAlternativeNames>;
  /** fetch aggregated fields from the table: "group_of_stop_places_alternative_names" */
  stops_database_group_of_stop_places_alternative_names_aggregate: StopsDatabaseGroupOfStopPlacesAlternativeNamesAggregate;
  /** fetch data from the table: "group_of_stop_places" using primary key columns */
  stops_database_group_of_stop_places_by_pk?: Maybe<StopsDatabaseGroupOfStopPlaces>;
  /** fetch data from the table: "group_of_stop_places_key_values" */
  stops_database_group_of_stop_places_key_values: Array<StopsDatabaseGroupOfStopPlacesKeyValues>;
  /** fetch aggregated fields from the table: "group_of_stop_places_key_values" */
  stops_database_group_of_stop_places_key_values_aggregate: StopsDatabaseGroupOfStopPlacesKeyValuesAggregate;
  /** fetch data from the table: "group_of_stop_places_key_values" using primary key columns */
  stops_database_group_of_stop_places_key_values_by_pk?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValues>;
  /** fetch data from the table: "group_of_stop_places_members" */
  stops_database_group_of_stop_places_members: Array<StopsDatabaseGroupOfStopPlacesMembers>;
  /** fetch aggregated fields from the table: "group_of_stop_places_members" */
  stops_database_group_of_stop_places_members_aggregate: StopsDatabaseGroupOfStopPlacesMembersAggregate;
  /** fetch data from the table: "group_of_tariff_zones" */
  stops_database_group_of_tariff_zones: Array<StopsDatabaseGroupOfTariffZones>;
  /** fetch aggregated fields from the table: "group_of_tariff_zones" */
  stops_database_group_of_tariff_zones_aggregate: StopsDatabaseGroupOfTariffZonesAggregate;
  /** fetch data from the table: "group_of_tariff_zones" using primary key columns */
  stops_database_group_of_tariff_zones_by_pk?: Maybe<StopsDatabaseGroupOfTariffZones>;
  /** fetch data from the table: "group_of_tariff_zones_key_values" */
  stops_database_group_of_tariff_zones_key_values: Array<StopsDatabaseGroupOfTariffZonesKeyValues>;
  /** fetch aggregated fields from the table: "group_of_tariff_zones_key_values" */
  stops_database_group_of_tariff_zones_key_values_aggregate: StopsDatabaseGroupOfTariffZonesKeyValuesAggregate;
  /** fetch data from the table: "group_of_tariff_zones_key_values" using primary key columns */
  stops_database_group_of_tariff_zones_key_values_by_pk?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValues>;
  /** fetch data from the table: "group_of_tariff_zones_members" */
  stops_database_group_of_tariff_zones_members: Array<StopsDatabaseGroupOfTariffZonesMembers>;
  /** fetch aggregated fields from the table: "group_of_tariff_zones_members" */
  stops_database_group_of_tariff_zones_members_aggregate: StopsDatabaseGroupOfTariffZonesMembersAggregate;
  /** fetch data from the table: "group_of_tariff_zones_members" using primary key columns */
  stops_database_group_of_tariff_zones_members_by_pk?: Maybe<StopsDatabaseGroupOfTariffZonesMembers>;
  /** fetch data from the table: "id_generator" */
  stops_database_id_generator: Array<StopsDatabaseIdGenerator>;
  /** fetch aggregated fields from the table: "id_generator" */
  stops_database_id_generator_aggregate: StopsDatabaseIdGeneratorAggregate;
  /** fetch data from the table: "installed_equipment" */
  stops_database_installed_equipment: Array<StopsDatabaseInstalledEquipment>;
  /** fetch aggregated fields from the table: "installed_equipment" */
  stops_database_installed_equipment_aggregate: StopsDatabaseInstalledEquipmentAggregate;
  /** fetch data from the table: "installed_equipment_version_structure" */
  stops_database_installed_equipment_version_structure: Array<StopsDatabaseInstalledEquipmentVersionStructure>;
  /** fetch aggregated fields from the table: "installed_equipment_version_structure" */
  stops_database_installed_equipment_version_structure_aggregate: StopsDatabaseInstalledEquipmentVersionStructureAggregate;
  /** fetch data from the table: "installed_equipment_version_structure" using primary key columns */
  stops_database_installed_equipment_version_structure_by_pk?: Maybe<StopsDatabaseInstalledEquipmentVersionStructure>;
  /** fetch data from the table: "installed_equipment_version_structure_installed_equipment" */
  stops_database_installed_equipment_version_structure_installed_equipment: Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipment>;
  /** fetch aggregated fields from the table: "installed_equipment_version_structure_installed_equipment" */
  stops_database_installed_equipment_version_structure_installed_equipment_aggregate: StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAggregate;
  /** fetch data from the table: "level" */
  stops_database_level: Array<StopsDatabaseLevel>;
  /** fetch aggregated fields from the table: "level" */
  stops_database_level_aggregate: StopsDatabaseLevelAggregate;
  /** fetch data from the table: "level" using primary key columns */
  stops_database_level_by_pk?: Maybe<StopsDatabaseLevel>;
  /** fetch data from the table: "level_key_values" */
  stops_database_level_key_values: Array<StopsDatabaseLevelKeyValues>;
  /** fetch aggregated fields from the table: "level_key_values" */
  stops_database_level_key_values_aggregate: StopsDatabaseLevelKeyValuesAggregate;
  /** fetch data from the table: "level_key_values" using primary key columns */
  stops_database_level_key_values_by_pk?: Maybe<StopsDatabaseLevelKeyValues>;
  /** fetch data from the table: "multilingual_string_entity" */
  stops_database_multilingual_string_entity: Array<StopsDatabaseMultilingualStringEntity>;
  /** fetch aggregated fields from the table: "multilingual_string_entity" */
  stops_database_multilingual_string_entity_aggregate: StopsDatabaseMultilingualStringEntityAggregate;
  /** fetch data from the table: "multilingual_string_entity" using primary key columns */
  stops_database_multilingual_string_entity_by_pk?: Maybe<StopsDatabaseMultilingualStringEntity>;
  /** fetch data from the table: "navigation_path" */
  stops_database_navigation_path: Array<StopsDatabaseNavigationPath>;
  /** fetch aggregated fields from the table: "navigation_path" */
  stops_database_navigation_path_aggregate: StopsDatabaseNavigationPathAggregate;
  /** fetch data from the table: "parking" */
  stops_database_parking: Array<StopsDatabaseParking>;
  /** fetch data from the table: "parking_adjacent_sites" */
  stops_database_parking_adjacent_sites: Array<StopsDatabaseParkingAdjacentSites>;
  /** fetch aggregated fields from the table: "parking_adjacent_sites" */
  stops_database_parking_adjacent_sites_aggregate: StopsDatabaseParkingAdjacentSitesAggregate;
  /** fetch aggregated fields from the table: "parking" */
  stops_database_parking_aggregate: StopsDatabaseParkingAggregate;
  /** fetch data from the table: "parking_alternative_names" */
  stops_database_parking_alternative_names: Array<StopsDatabaseParkingAlternativeNames>;
  /** fetch aggregated fields from the table: "parking_alternative_names" */
  stops_database_parking_alternative_names_aggregate: StopsDatabaseParkingAlternativeNamesAggregate;
  /** fetch data from the table: "parking_area" */
  stops_database_parking_area: Array<StopsDatabaseParkingArea>;
  /** fetch aggregated fields from the table: "parking_area" */
  stops_database_parking_area_aggregate: StopsDatabaseParkingAreaAggregate;
  /** fetch data from the table: "parking_area_alternative_names" */
  stops_database_parking_area_alternative_names: Array<StopsDatabaseParkingAreaAlternativeNames>;
  /** fetch aggregated fields from the table: "parking_area_alternative_names" */
  stops_database_parking_area_alternative_names_aggregate: StopsDatabaseParkingAreaAlternativeNamesAggregate;
  /** fetch data from the table: "parking_area" using primary key columns */
  stops_database_parking_area_by_pk?: Maybe<StopsDatabaseParkingArea>;
  /** fetch data from the table: "parking_area_check_constraints" */
  stops_database_parking_area_check_constraints: Array<StopsDatabaseParkingAreaCheckConstraints>;
  /** fetch aggregated fields from the table: "parking_area_check_constraints" */
  stops_database_parking_area_check_constraints_aggregate: StopsDatabaseParkingAreaCheckConstraintsAggregate;
  /** fetch data from the table: "parking_area_equipment_places" */
  stops_database_parking_area_equipment_places: Array<StopsDatabaseParkingAreaEquipmentPlaces>;
  /** fetch aggregated fields from the table: "parking_area_equipment_places" */
  stops_database_parking_area_equipment_places_aggregate: StopsDatabaseParkingAreaEquipmentPlacesAggregate;
  /** fetch data from the table: "parking_area_key_values" */
  stops_database_parking_area_key_values: Array<StopsDatabaseParkingAreaKeyValues>;
  /** fetch aggregated fields from the table: "parking_area_key_values" */
  stops_database_parking_area_key_values_aggregate: StopsDatabaseParkingAreaKeyValuesAggregate;
  /** fetch data from the table: "parking_area_key_values" using primary key columns */
  stops_database_parking_area_key_values_by_pk?: Maybe<StopsDatabaseParkingAreaKeyValues>;
  /** fetch data from the table: "parking" using primary key columns */
  stops_database_parking_by_pk?: Maybe<StopsDatabaseParking>;
  /** fetch data from the table: "parking_capacity" */
  stops_database_parking_capacity: Array<StopsDatabaseParkingCapacity>;
  /** fetch aggregated fields from the table: "parking_capacity" */
  stops_database_parking_capacity_aggregate: StopsDatabaseParkingCapacityAggregate;
  /** fetch data from the table: "parking_capacity" using primary key columns */
  stops_database_parking_capacity_by_pk?: Maybe<StopsDatabaseParkingCapacity>;
  /** fetch data from the table: "parking_equipment_places" */
  stops_database_parking_equipment_places: Array<StopsDatabaseParkingEquipmentPlaces>;
  /** fetch aggregated fields from the table: "parking_equipment_places" */
  stops_database_parking_equipment_places_aggregate: StopsDatabaseParkingEquipmentPlacesAggregate;
  /** fetch data from the table: "parking_key_values" */
  stops_database_parking_key_values: Array<StopsDatabaseParkingKeyValues>;
  /** fetch aggregated fields from the table: "parking_key_values" */
  stops_database_parking_key_values_aggregate: StopsDatabaseParkingKeyValuesAggregate;
  /** fetch data from the table: "parking_key_values" using primary key columns */
  stops_database_parking_key_values_by_pk?: Maybe<StopsDatabaseParkingKeyValues>;
  /** fetch data from the table: "parking_parking_areas" */
  stops_database_parking_parking_areas: Array<StopsDatabaseParkingParkingAreas>;
  /** fetch aggregated fields from the table: "parking_parking_areas" */
  stops_database_parking_parking_areas_aggregate: StopsDatabaseParkingParkingAreasAggregate;
  /** fetch data from the table: "parking_parking_payment_process" */
  stops_database_parking_parking_payment_process: Array<StopsDatabaseParkingParkingPaymentProcess>;
  /** fetch aggregated fields from the table: "parking_parking_payment_process" */
  stops_database_parking_parking_payment_process_aggregate: StopsDatabaseParkingParkingPaymentProcessAggregate;
  /** fetch data from the table: "parking_parking_properties" */
  stops_database_parking_parking_properties: Array<StopsDatabaseParkingParkingProperties>;
  /** fetch aggregated fields from the table: "parking_parking_properties" */
  stops_database_parking_parking_properties_aggregate: StopsDatabaseParkingParkingPropertiesAggregate;
  /** fetch data from the table: "parking_parking_vehicle_types" */
  stops_database_parking_parking_vehicle_types: Array<StopsDatabaseParkingParkingVehicleTypes>;
  /** fetch aggregated fields from the table: "parking_parking_vehicle_types" */
  stops_database_parking_parking_vehicle_types_aggregate: StopsDatabaseParkingParkingVehicleTypesAggregate;
  /** fetch data from the table: "parking_properties" */
  stops_database_parking_properties: Array<StopsDatabaseParkingProperties>;
  /** fetch aggregated fields from the table: "parking_properties" */
  stops_database_parking_properties_aggregate: StopsDatabaseParkingPropertiesAggregate;
  /** fetch data from the table: "parking_properties" using primary key columns */
  stops_database_parking_properties_by_pk?: Maybe<StopsDatabaseParkingProperties>;
  /** fetch data from the table: "parking_properties_parking_user_types" */
  stops_database_parking_properties_parking_user_types: Array<StopsDatabaseParkingPropertiesParkingUserTypes>;
  /** fetch aggregated fields from the table: "parking_properties_parking_user_types" */
  stops_database_parking_properties_parking_user_types_aggregate: StopsDatabaseParkingPropertiesParkingUserTypesAggregate;
  /** fetch data from the table: "parking_properties_spaces" */
  stops_database_parking_properties_spaces: Array<StopsDatabaseParkingPropertiesSpaces>;
  /** fetch aggregated fields from the table: "parking_properties_spaces" */
  stops_database_parking_properties_spaces_aggregate: StopsDatabaseParkingPropertiesSpacesAggregate;
  /** fetch data from the table: "path_junction" */
  stops_database_path_junction: Array<StopsDatabasePathJunction>;
  /** fetch aggregated fields from the table: "path_junction" */
  stops_database_path_junction_aggregate: StopsDatabasePathJunctionAggregate;
  /** fetch data from the table: "path_junction" using primary key columns */
  stops_database_path_junction_by_pk?: Maybe<StopsDatabasePathJunction>;
  /** fetch data from the table: "path_junction_key_values" */
  stops_database_path_junction_key_values: Array<StopsDatabasePathJunctionKeyValues>;
  /** fetch aggregated fields from the table: "path_junction_key_values" */
  stops_database_path_junction_key_values_aggregate: StopsDatabasePathJunctionKeyValuesAggregate;
  /** fetch data from the table: "path_junction_key_values" using primary key columns */
  stops_database_path_junction_key_values_by_pk?: Maybe<StopsDatabasePathJunctionKeyValues>;
  /** fetch data from the table: "path_link" */
  stops_database_path_link: Array<StopsDatabasePathLink>;
  /** fetch aggregated fields from the table: "path_link" */
  stops_database_path_link_aggregate: StopsDatabasePathLinkAggregate;
  /** fetch data from the table: "path_link" using primary key columns */
  stops_database_path_link_by_pk?: Maybe<StopsDatabasePathLink>;
  /** fetch data from the table: "path_link_end" */
  stops_database_path_link_end: Array<StopsDatabasePathLinkEnd>;
  /** fetch aggregated fields from the table: "path_link_end" */
  stops_database_path_link_end_aggregate: StopsDatabasePathLinkEndAggregate;
  /** fetch data from the table: "path_link_end" using primary key columns */
  stops_database_path_link_end_by_pk?: Maybe<StopsDatabasePathLinkEnd>;
  /** fetch data from the table: "path_link_key_values" */
  stops_database_path_link_key_values: Array<StopsDatabasePathLinkKeyValues>;
  /** fetch aggregated fields from the table: "path_link_key_values" */
  stops_database_path_link_key_values_aggregate: StopsDatabasePathLinkKeyValuesAggregate;
  /** fetch data from the table: "path_link_key_values" using primary key columns */
  stops_database_path_link_key_values_by_pk?: Maybe<StopsDatabasePathLinkKeyValues>;
  /** fetch data from the table: "persistable_polygon" */
  stops_database_persistable_polygon: Array<StopsDatabasePersistablePolygon>;
  /** fetch aggregated fields from the table: "persistable_polygon" */
  stops_database_persistable_polygon_aggregate: StopsDatabasePersistablePolygonAggregate;
  /** fetch data from the table: "persistable_polygon" using primary key columns */
  stops_database_persistable_polygon_by_pk?: Maybe<StopsDatabasePersistablePolygon>;
  /** fetch data from the table: "purpose_of_grouping" */
  stops_database_purpose_of_grouping: Array<StopsDatabasePurposeOfGrouping>;
  /** fetch aggregated fields from the table: "purpose_of_grouping" */
  stops_database_purpose_of_grouping_aggregate: StopsDatabasePurposeOfGroupingAggregate;
  /** fetch data from the table: "purpose_of_grouping" using primary key columns */
  stops_database_purpose_of_grouping_by_pk?: Maybe<StopsDatabasePurposeOfGrouping>;
  /** fetch data from the table: "purpose_of_grouping_key_values" */
  stops_database_purpose_of_grouping_key_values: Array<StopsDatabasePurposeOfGroupingKeyValues>;
  /** fetch aggregated fields from the table: "purpose_of_grouping_key_values" */
  stops_database_purpose_of_grouping_key_values_aggregate: StopsDatabasePurposeOfGroupingKeyValuesAggregate;
  /** fetch data from the table: "purpose_of_grouping_key_values" using primary key columns */
  stops_database_purpose_of_grouping_key_values_by_pk?: Maybe<StopsDatabasePurposeOfGroupingKeyValues>;
  /** fetch data from the table: "quay" */
  stops_database_quay: Array<StopsDatabaseQuay>;
  /** fetch aggregated fields from the table: "quay" */
  stops_database_quay_aggregate: StopsDatabaseQuayAggregate;
  /** fetch data from the table: "quay_alternative_names" */
  stops_database_quay_alternative_names: Array<StopsDatabaseQuayAlternativeNames>;
  /** fetch aggregated fields from the table: "quay_alternative_names" */
  stops_database_quay_alternative_names_aggregate: StopsDatabaseQuayAlternativeNamesAggregate;
  /** fetch data from the table: "quay_boarding_positions" */
  stops_database_quay_boarding_positions: Array<StopsDatabaseQuayBoardingPositions>;
  /** fetch aggregated fields from the table: "quay_boarding_positions" */
  stops_database_quay_boarding_positions_aggregate: StopsDatabaseQuayBoardingPositionsAggregate;
  /** fetch data from the table: "quay" using primary key columns */
  stops_database_quay_by_pk?: Maybe<StopsDatabaseQuay>;
  /** fetch data from the table: "quay_check_constraints" */
  stops_database_quay_check_constraints: Array<StopsDatabaseQuayCheckConstraints>;
  /** fetch aggregated fields from the table: "quay_check_constraints" */
  stops_database_quay_check_constraints_aggregate: StopsDatabaseQuayCheckConstraintsAggregate;
  /** fetch data from the table: "quay_equipment_places" */
  stops_database_quay_equipment_places: Array<StopsDatabaseQuayEquipmentPlaces>;
  /** fetch aggregated fields from the table: "quay_equipment_places" */
  stops_database_quay_equipment_places_aggregate: StopsDatabaseQuayEquipmentPlacesAggregate;
  /** fetch data from the table: "quay_key_values" */
  stops_database_quay_key_values: Array<StopsDatabaseQuayKeyValues>;
  /** fetch aggregated fields from the table: "quay_key_values" */
  stops_database_quay_key_values_aggregate: StopsDatabaseQuayKeyValuesAggregate;
  /** fetch data from the table: "quay_key_values" using primary key columns */
  stops_database_quay_key_values_by_pk?: Maybe<StopsDatabaseQuayKeyValues>;
  /** fetch data from the table: "schema_version" */
  stops_database_schema_version: Array<StopsDatabaseSchemaVersion>;
  /** fetch aggregated fields from the table: "schema_version" */
  stops_database_schema_version_aggregate: StopsDatabaseSchemaVersionAggregate;
  /** fetch data from the table: "schema_version" using primary key columns */
  stops_database_schema_version_by_pk?: Maybe<StopsDatabaseSchemaVersion>;
  /** fetch data from the table: "spatial_ref_sys" */
  stops_database_spatial_ref_sys: Array<StopsDatabaseSpatialRefSys>;
  /** fetch aggregated fields from the table: "spatial_ref_sys" */
  stops_database_spatial_ref_sys_aggregate: StopsDatabaseSpatialRefSysAggregate;
  /** fetch data from the table: "spatial_ref_sys" using primary key columns */
  stops_database_spatial_ref_sys_by_pk?: Maybe<StopsDatabaseSpatialRefSys>;
  /** fetch data from the table: "stop_place" */
  stops_database_stop_place: Array<StopsDatabaseStopPlace>;
  /** fetch data from the table: "stop_place_access_spaces" */
  stops_database_stop_place_access_spaces: Array<StopsDatabaseStopPlaceAccessSpaces>;
  /** fetch aggregated fields from the table: "stop_place_access_spaces" */
  stops_database_stop_place_access_spaces_aggregate: StopsDatabaseStopPlaceAccessSpacesAggregate;
  /** fetch data from the table: "stop_place_adjacent_sites" */
  stops_database_stop_place_adjacent_sites: Array<StopsDatabaseStopPlaceAdjacentSites>;
  /** fetch aggregated fields from the table: "stop_place_adjacent_sites" */
  stops_database_stop_place_adjacent_sites_aggregate: StopsDatabaseStopPlaceAdjacentSitesAggregate;
  /** fetch aggregated fields from the table: "stop_place" */
  stops_database_stop_place_aggregate: StopsDatabaseStopPlaceAggregate;
  /** fetch data from the table: "stop_place_alternative_names" */
  stops_database_stop_place_alternative_names: Array<StopsDatabaseStopPlaceAlternativeNames>;
  /** fetch aggregated fields from the table: "stop_place_alternative_names" */
  stops_database_stop_place_alternative_names_aggregate: StopsDatabaseStopPlaceAlternativeNamesAggregate;
  /** fetch data from the table: "stop_place" using primary key columns */
  stops_database_stop_place_by_pk?: Maybe<StopsDatabaseStopPlace>;
  /** fetch data from the table: "stop_place_children" */
  stops_database_stop_place_children: Array<StopsDatabaseStopPlaceChildren>;
  /** fetch aggregated fields from the table: "stop_place_children" */
  stops_database_stop_place_children_aggregate: StopsDatabaseStopPlaceChildrenAggregate;
  /** fetch data from the table: "stop_place_children" using primary key columns */
  stops_database_stop_place_children_by_pk?: Maybe<StopsDatabaseStopPlaceChildren>;
  /** fetch data from the table: "stop_place_equipment_places" */
  stops_database_stop_place_equipment_places: Array<StopsDatabaseStopPlaceEquipmentPlaces>;
  /** fetch aggregated fields from the table: "stop_place_equipment_places" */
  stops_database_stop_place_equipment_places_aggregate: StopsDatabaseStopPlaceEquipmentPlacesAggregate;
  /** fetch data from the table: "stop_place_key_values" */
  stops_database_stop_place_key_values: Array<StopsDatabaseStopPlaceKeyValues>;
  /** fetch aggregated fields from the table: "stop_place_key_values" */
  stops_database_stop_place_key_values_aggregate: StopsDatabaseStopPlaceKeyValuesAggregate;
  /** fetch data from the table: "stop_place_key_values" using primary key columns */
  stops_database_stop_place_key_values_by_pk?: Maybe<StopsDatabaseStopPlaceKeyValues>;
  /** fetch data from the table: "stop_place_quays" */
  stops_database_stop_place_quays: Array<StopsDatabaseStopPlaceQuays>;
  /** fetch aggregated fields from the table: "stop_place_quays" */
  stops_database_stop_place_quays_aggregate: StopsDatabaseStopPlaceQuaysAggregate;
  /** fetch data from the table: "stop_place_quays" using primary key columns */
  stops_database_stop_place_quays_by_pk?: Maybe<StopsDatabaseStopPlaceQuays>;
  /** fetch data from the table: "stop_place_tariff_zones" */
  stops_database_stop_place_tariff_zones: Array<StopsDatabaseStopPlaceTariffZones>;
  /** fetch aggregated fields from the table: "stop_place_tariff_zones" */
  stops_database_stop_place_tariff_zones_aggregate: StopsDatabaseStopPlaceTariffZonesAggregate;
  /** fetch data from the table: "tag" */
  stops_database_tag: Array<StopsDatabaseTag>;
  /** fetch aggregated fields from the table: "tag" */
  stops_database_tag_aggregate: StopsDatabaseTagAggregate;
  /** fetch data from the table: "tag" using primary key columns */
  stops_database_tag_by_pk?: Maybe<StopsDatabaseTag>;
  /** fetch data from the table: "tariff_zone" */
  stops_database_tariff_zone: Array<StopsDatabaseTariffZone>;
  /** fetch aggregated fields from the table: "tariff_zone" */
  stops_database_tariff_zone_aggregate: StopsDatabaseTariffZoneAggregate;
  /** fetch data from the table: "tariff_zone" using primary key columns */
  stops_database_tariff_zone_by_pk?: Maybe<StopsDatabaseTariffZone>;
  /** fetch data from the table: "tariff_zone_key_values" */
  stops_database_tariff_zone_key_values: Array<StopsDatabaseTariffZoneKeyValues>;
  /** fetch aggregated fields from the table: "tariff_zone_key_values" */
  stops_database_tariff_zone_key_values_aggregate: StopsDatabaseTariffZoneKeyValuesAggregate;
  /** fetch data from the table: "tariff_zone_key_values" using primary key columns */
  stops_database_tariff_zone_key_values_by_pk?: Maybe<StopsDatabaseTariffZoneKeyValues>;
  /** fetch data from the table: "topographic_place" */
  stops_database_topographic_place: Array<StopsDatabaseTopographicPlace>;
  /** fetch aggregated fields from the table: "topographic_place" */
  stops_database_topographic_place_aggregate: StopsDatabaseTopographicPlaceAggregate;
  /** fetch data from the table: "topographic_place" using primary key columns */
  stops_database_topographic_place_by_pk?: Maybe<StopsDatabaseTopographicPlace>;
  /** fetch data from the table: "topographic_place_key_values" */
  stops_database_topographic_place_key_values: Array<StopsDatabaseTopographicPlaceKeyValues>;
  /** fetch aggregated fields from the table: "topographic_place_key_values" */
  stops_database_topographic_place_key_values_aggregate: StopsDatabaseTopographicPlaceKeyValuesAggregate;
  /** fetch data from the table: "topographic_place_key_values" using primary key columns */
  stops_database_topographic_place_key_values_by_pk?: Maybe<StopsDatabaseTopographicPlaceKeyValues>;
  /** fetch data from the table: "value" */
  stops_database_value: Array<StopsDatabaseValue>;
  /** fetch aggregated fields from the table: "value" */
  stops_database_value_aggregate: StopsDatabaseValueAggregate;
  /** fetch data from the table: "value" using primary key columns */
  stops_database_value_by_pk?: Maybe<StopsDatabaseValue>;
  /** fetch data from the table: "value_items" */
  stops_database_value_items: Array<StopsDatabaseValueItems>;
  /** fetch aggregated fields from the table: "value_items" */
  stops_database_value_items_aggregate: StopsDatabaseValueItemsAggregate;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessSpaceArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseAccessSpaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseAccessSpaceOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessSpaceAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseAccessSpaceSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseAccessSpaceOrderBy>>;
    where?: InputMaybe<StopsDatabaseAccessSpaceBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessSpaceAlternativeNamesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessSpaceAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseAccessSpaceAlternativeNamesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessSpaceAlternativeNamesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessSpaceAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseAccessSpaceAlternativeNamesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessSpaceByPkArgs = {
  id: Scalars['bigint'];
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessSpaceCheckConstraintsArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessSpaceCheckConstraintsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseAccessSpaceCheckConstraintsOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessSpaceCheckConstraintsAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessSpaceCheckConstraintsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseAccessSpaceCheckConstraintsOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessSpaceEquipmentPlacesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessSpaceEquipmentPlacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseAccessSpaceEquipmentPlacesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessSpaceEquipmentPlacesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessSpaceEquipmentPlacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseAccessSpaceEquipmentPlacesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessSpaceKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessSpaceKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseAccessSpaceKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessSpaceKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessSpaceKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseAccessSpaceKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessSpaceKeyValuesByPkArgs =
  {
    access_space_id: Scalars['bigint'];
    key_values_key: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessibilityAssessmentArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessibilityAssessmentSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseAccessibilityAssessmentOrderBy>>;
    where?: InputMaybe<StopsDatabaseAccessibilityAssessmentBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessibilityAssessmentAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessibilityAssessmentSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseAccessibilityAssessmentOrderBy>>;
    where?: InputMaybe<StopsDatabaseAccessibilityAssessmentBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessibilityAssessmentByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessibilityAssessmentLimitationsArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessibilityAssessmentLimitationsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseAccessibilityAssessmentLimitationsOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessibilityAssessmentLimitationsAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessibilityAssessmentLimitationsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseAccessibilityAssessmentLimitationsOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessibilityLimitationArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessibilityLimitationSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseAccessibilityLimitationOrderBy>>;
    where?: InputMaybe<StopsDatabaseAccessibilityLimitationBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessibilityLimitationAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessibilityLimitationSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseAccessibilityLimitationOrderBy>>;
    where?: InputMaybe<StopsDatabaseAccessibilityLimitationBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessibilityLimitationByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAlternativeNameArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseAlternativeNameSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseAlternativeNameOrderBy>>;
  where?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAlternativeNameAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseAlternativeNameSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseAlternativeNameOrderBy>>;
    where?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAlternativeNameByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseBoardingPositionArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseBoardingPositionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseBoardingPositionOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseBoardingPositionAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseBoardingPositionSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseBoardingPositionOrderBy>>;
    where?: InputMaybe<StopsDatabaseBoardingPositionBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseBoardingPositionAlternativeNamesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseBoardingPositionAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseBoardingPositionAlternativeNamesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseBoardingPositionAlternativeNamesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseBoardingPositionAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseBoardingPositionAlternativeNamesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseBoardingPositionByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseBoardingPositionCheckConstraintsArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseBoardingPositionCheckConstraintsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseBoardingPositionCheckConstraintsOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseBoardingPositionCheckConstraintsAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseBoardingPositionCheckConstraintsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseBoardingPositionCheckConstraintsOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseBoardingPositionEquipmentPlacesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseBoardingPositionEquipmentPlacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseBoardingPositionEquipmentPlacesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseBoardingPositionEquipmentPlacesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseBoardingPositionEquipmentPlacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseBoardingPositionEquipmentPlacesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseBoardingPositionKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseBoardingPositionKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseBoardingPositionKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseBoardingPositionKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseBoardingPositionKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseBoardingPositionKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseBoardingPositionKeyValuesByPkArgs =
  {
    boarding_position_id: Scalars['bigint'];
    key_values_key: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseCheckConstraintArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseCheckConstraintSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseCheckConstraintOrderBy>>;
  where?: InputMaybe<StopsDatabaseCheckConstraintBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseCheckConstraintAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseCheckConstraintSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseCheckConstraintOrderBy>>;
    where?: InputMaybe<StopsDatabaseCheckConstraintBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseCheckConstraintByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseCheckConstraintKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseCheckConstraintKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseCheckConstraintKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseCheckConstraintKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseCheckConstraintKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseCheckConstraintKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseCheckConstraintKeyValuesByPkArgs =
  {
    check_constraint_id: Scalars['bigint'];
    key_values_key: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseDestinationDisplayViewArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseDestinationDisplayViewSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseDestinationDisplayViewOrderBy>>;
    where?: InputMaybe<StopsDatabaseDestinationDisplayViewBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseDestinationDisplayViewAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseDestinationDisplayViewSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseDestinationDisplayViewOrderBy>>;
    where?: InputMaybe<StopsDatabaseDestinationDisplayViewBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseDestinationDisplayViewByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPlaceArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseEquipmentPlaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseEquipmentPlaceOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPlaceAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseEquipmentPlaceSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseEquipmentPlaceOrderBy>>;
    where?: InputMaybe<StopsDatabaseEquipmentPlaceBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPlaceByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPlaceEquipmentPositionsArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseEquipmentPlaceEquipmentPositionsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseEquipmentPlaceEquipmentPositionsOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPlaceEquipmentPositionsAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseEquipmentPlaceEquipmentPositionsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseEquipmentPlaceEquipmentPositionsOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPlaceKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseEquipmentPlaceKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseEquipmentPlaceKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPlaceKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseEquipmentPlaceKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseEquipmentPlaceKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPlaceKeyValuesByPkArgs =
  {
    equipment_place_id: Scalars['bigint'];
    key_values_key: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPositionArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseEquipmentPositionSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseEquipmentPositionOrderBy>>;
    where?: InputMaybe<StopsDatabaseEquipmentPositionBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPositionAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseEquipmentPositionSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseEquipmentPositionOrderBy>>;
    where?: InputMaybe<StopsDatabaseEquipmentPositionBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPositionByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPositionKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseEquipmentPositionKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseEquipmentPositionKeyValuesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPositionKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseEquipmentPositionKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseEquipmentPositionKeyValuesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPositionKeyValuesByPkArgs =
  {
    equipment_position_id: Scalars['bigint'];
    key_values_key: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseExportJobArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseExportJobSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseExportJobOrderBy>>;
  where?: InputMaybe<StopsDatabaseExportJobBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseExportJobAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseExportJobSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseExportJobOrderBy>>;
    where?: InputMaybe<StopsDatabaseExportJobBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseExportJobByPkArgs = {
  id: Scalars['bigint'];
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseFareZoneArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseFareZoneSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseFareZoneOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseFareZoneAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseFareZoneSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseFareZoneOrderBy>>;
    where?: InputMaybe<StopsDatabaseFareZoneBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseFareZoneByPkArgs = {
  id: Scalars['bigint'];
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseFareZoneKeyValuesArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseFareZoneKeyValuesSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseFareZoneKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseFareZoneKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseFareZoneKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseFareZoneKeyValuesSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseFareZoneKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseFareZoneKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseFareZoneKeyValuesByPkArgs =
  {
    fare_zone_id: Scalars['bigint'];
    key_values_key: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseFareZoneMembersArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseFareZoneMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseFareZoneMembersOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneMembersBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseFareZoneMembersAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseFareZoneMembersSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseFareZoneMembersOrderBy>>;
    where?: InputMaybe<StopsDatabaseFareZoneMembersBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseFareZoneNeighboursArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseFareZoneNeighboursSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseFareZoneNeighboursOrderBy>>;
    where?: InputMaybe<StopsDatabaseFareZoneNeighboursBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseFareZoneNeighboursAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseFareZoneNeighboursSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseFareZoneNeighboursOrderBy>>;
    where?: InputMaybe<StopsDatabaseFareZoneNeighboursBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGeographyColumnsArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseGeographyColumnsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseGeographyColumnsOrderBy>>;
  where?: InputMaybe<StopsDatabaseGeographyColumnsBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGeographyColumnsAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseGeographyColumnsSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseGeographyColumnsOrderBy>>;
    where?: InputMaybe<StopsDatabaseGeographyColumnsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGeometryColumnsArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseGeometryColumnsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseGeometryColumnsOrderBy>>;
  where?: InputMaybe<StopsDatabaseGeometryColumnsBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGeometryColumnsAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseGeometryColumnsSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseGeometryColumnsOrderBy>>;
    where?: InputMaybe<StopsDatabaseGeometryColumnsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfStopPlacesArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseGroupOfStopPlacesSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseGroupOfStopPlacesOrderBy>>;
    where?: InputMaybe<StopsDatabaseGroupOfStopPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfStopPlacesAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseGroupOfStopPlacesSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseGroupOfStopPlacesOrderBy>>;
    where?: InputMaybe<StopsDatabaseGroupOfStopPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfStopPlacesAlternativeNamesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesAlternativeNamesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfStopPlacesAlternativeNamesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesAlternativeNamesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfStopPlacesByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfStopPlacesKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesKeyValuesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfStopPlacesKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesKeyValuesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfStopPlacesKeyValuesByPkArgs =
  {
    group_of_stop_places_id: Scalars['bigint'];
    key_values_key: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfStopPlacesMembersArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesMembersSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseGroupOfStopPlacesMembersOrderBy>>;
    where?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfStopPlacesMembersAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesMembersSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseGroupOfStopPlacesMembersOrderBy>>;
    where?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfTariffZonesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfTariffZonesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseGroupOfTariffZonesOrderBy>>;
    where?: InputMaybe<StopsDatabaseGroupOfTariffZonesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfTariffZonesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfTariffZonesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseGroupOfTariffZonesOrderBy>>;
    where?: InputMaybe<StopsDatabaseGroupOfTariffZonesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfTariffZonesByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfTariffZonesKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfTariffZonesKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseGroupOfTariffZonesKeyValuesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfTariffZonesKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfTariffZonesKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseGroupOfTariffZonesKeyValuesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfTariffZonesKeyValuesByPkArgs =
  {
    group_of_tariff_zones_id: Scalars['bigint'];
    key_values_key: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfTariffZonesMembersArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfTariffZonesMembersSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseGroupOfTariffZonesMembersOrderBy>>;
    where?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfTariffZonesMembersAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfTariffZonesMembersSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseGroupOfTariffZonesMembersOrderBy>>;
    where?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfTariffZonesMembersByPkArgs =
  {
    group_of_tariff_zones_id: Scalars['bigint'];
    ref: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseIdGeneratorArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseIdGeneratorSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseIdGeneratorOrderBy>>;
  where?: InputMaybe<StopsDatabaseIdGeneratorBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseIdGeneratorAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseIdGeneratorSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseIdGeneratorOrderBy>>;
    where?: InputMaybe<StopsDatabaseIdGeneratorBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseInstalledEquipmentArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseInstalledEquipmentOrderBy>>;
    where?: InputMaybe<StopsDatabaseInstalledEquipmentBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseInstalledEquipmentAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseInstalledEquipmentOrderBy>>;
    where?: InputMaybe<StopsDatabaseInstalledEquipmentBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseInstalledEquipmentVersionStructureArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentVersionStructureSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentVersionStructureOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseInstalledEquipmentVersionStructureAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentVersionStructureSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentVersionStructureOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseInstalledEquipmentVersionStructureByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseLevelArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseLevelSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseLevelOrderBy>>;
  where?: InputMaybe<StopsDatabaseLevelBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseLevelAggregateArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseLevelSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseLevelOrderBy>>;
  where?: InputMaybe<StopsDatabaseLevelBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseLevelByPkArgs = {
  id: Scalars['bigint'];
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseLevelKeyValuesArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseLevelKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseLevelKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseLevelKeyValuesBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseLevelKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseLevelKeyValuesSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseLevelKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseLevelKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseLevelKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    level_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseMultilingualStringEntityArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseMultilingualStringEntitySelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseMultilingualStringEntityOrderBy>>;
    where?: InputMaybe<StopsDatabaseMultilingualStringEntityBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseMultilingualStringEntityAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseMultilingualStringEntitySelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseMultilingualStringEntityOrderBy>>;
    where?: InputMaybe<StopsDatabaseMultilingualStringEntityBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseMultilingualStringEntityByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseNavigationPathArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseNavigationPathSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseNavigationPathOrderBy>>;
  where?: InputMaybe<StopsDatabaseNavigationPathBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseNavigationPathAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseNavigationPathSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseNavigationPathOrderBy>>;
    where?: InputMaybe<StopsDatabaseNavigationPathBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseParkingSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseParkingOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAdjacentSitesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingAdjacentSitesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingAdjacentSitesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingAdjacentSitesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAdjacentSitesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingAdjacentSitesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingAdjacentSitesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingAdjacentSitesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAggregateArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseParkingSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseParkingOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAlternativeNamesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingAlternativeNamesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAlternativeNamesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingAlternativeNamesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAreaArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseParkingAreaSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseParkingAreaOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAreaAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseParkingAreaSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingAreaOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingAreaBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAreaAlternativeNamesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingAreaAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseParkingAreaAlternativeNamesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAreaAlternativeNamesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingAreaAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseParkingAreaAlternativeNamesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAreaByPkArgs = {
  id: Scalars['bigint'];
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAreaCheckConstraintsArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingAreaCheckConstraintsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseParkingAreaCheckConstraintsOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAreaCheckConstraintsAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingAreaCheckConstraintsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseParkingAreaCheckConstraintsOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAreaEquipmentPlacesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingAreaEquipmentPlacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseParkingAreaEquipmentPlacesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAreaEquipmentPlacesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingAreaEquipmentPlacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseParkingAreaEquipmentPlacesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAreaKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingAreaKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingAreaKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingAreaKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAreaKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingAreaKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingAreaKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingAreaKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAreaKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    parking_area_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingByPkArgs = {
  id: Scalars['bigint'];
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingCapacityArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseParkingCapacitySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseParkingCapacityOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingCapacityBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingCapacityAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseParkingCapacitySelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingCapacityOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingCapacityBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingCapacityByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingEquipmentPlacesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingEquipmentPlacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingEquipmentPlacesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingEquipmentPlacesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingEquipmentPlacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingEquipmentPlacesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingKeyValuesArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseParkingKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseParkingKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingKeyValuesBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseParkingKeyValuesSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    parking_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingParkingAreasArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingParkingAreasSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingParkingAreasOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingParkingAreasBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingParkingAreasAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingParkingAreasSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingParkingAreasOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingParkingAreasBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingParkingPaymentProcessArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingParkingPaymentProcessSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseParkingParkingPaymentProcessOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingParkingPaymentProcessAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingParkingPaymentProcessSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseParkingParkingPaymentProcessOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingParkingPropertiesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingParkingPropertiesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingParkingPropertiesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingParkingPropertiesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingParkingPropertiesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingParkingPropertiesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingParkingPropertiesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingParkingPropertiesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingParkingVehicleTypesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingParkingVehicleTypesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseParkingParkingVehicleTypesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingParkingVehicleTypesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingParkingVehicleTypesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseParkingParkingVehicleTypesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingPropertiesArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseParkingPropertiesSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingPropertiesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingPropertiesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingPropertiesAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseParkingPropertiesSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingPropertiesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingPropertiesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingPropertiesByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingPropertiesParkingUserTypesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingPropertiesParkingUserTypesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseParkingPropertiesParkingUserTypesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseParkingPropertiesParkingUserTypesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingPropertiesParkingUserTypesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingPropertiesParkingUserTypesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseParkingPropertiesParkingUserTypesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseParkingPropertiesParkingUserTypesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingPropertiesSpacesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingPropertiesSpacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingPropertiesSpacesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingPropertiesSpacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingPropertiesSpacesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingPropertiesSpacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingPropertiesSpacesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingPropertiesSpacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathJunctionArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabasePathJunctionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabasePathJunctionOrderBy>>;
  where?: InputMaybe<StopsDatabasePathJunctionBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathJunctionAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabasePathJunctionSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabasePathJunctionOrderBy>>;
    where?: InputMaybe<StopsDatabasePathJunctionBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathJunctionByPkArgs = {
  id: Scalars['bigint'];
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathJunctionKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabasePathJunctionKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabasePathJunctionKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabasePathJunctionKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathJunctionKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabasePathJunctionKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabasePathJunctionKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabasePathJunctionKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathJunctionKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    path_junction_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathLinkArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabasePathLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabasePathLinkOrderBy>>;
  where?: InputMaybe<StopsDatabasePathLinkBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathLinkAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabasePathLinkSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabasePathLinkOrderBy>>;
    where?: InputMaybe<StopsDatabasePathLinkBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathLinkByPkArgs = {
  id: Scalars['bigint'];
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathLinkEndArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabasePathLinkEndSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabasePathLinkEndOrderBy>>;
  where?: InputMaybe<StopsDatabasePathLinkEndBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathLinkEndAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabasePathLinkEndSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabasePathLinkEndOrderBy>>;
    where?: InputMaybe<StopsDatabasePathLinkEndBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathLinkEndByPkArgs = {
  id: Scalars['bigint'];
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathLinkKeyValuesArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabasePathLinkKeyValuesSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabasePathLinkKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabasePathLinkKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathLinkKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabasePathLinkKeyValuesSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabasePathLinkKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabasePathLinkKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathLinkKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    path_link_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabasePersistablePolygonArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabasePersistablePolygonSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabasePersistablePolygonOrderBy>>;
    where?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabasePersistablePolygonAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabasePersistablePolygonSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabasePersistablePolygonOrderBy>>;
    where?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabasePersistablePolygonByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabasePurposeOfGroupingArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabasePurposeOfGroupingSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabasePurposeOfGroupingOrderBy>>;
    where?: InputMaybe<StopsDatabasePurposeOfGroupingBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabasePurposeOfGroupingAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabasePurposeOfGroupingSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabasePurposeOfGroupingOrderBy>>;
    where?: InputMaybe<StopsDatabasePurposeOfGroupingBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabasePurposeOfGroupingByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabasePurposeOfGroupingKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabasePurposeOfGroupingKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabasePurposeOfGroupingKeyValuesOrderBy>
    >;
    where?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabasePurposeOfGroupingKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabasePurposeOfGroupingKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabasePurposeOfGroupingKeyValuesOrderBy>
    >;
    where?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabasePurposeOfGroupingKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    purpose_of_grouping_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseQuaySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseQuayOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayAggregateArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseQuaySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseQuayOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayAlternativeNamesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseQuayAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseQuayAlternativeNamesOrderBy>>;
    where?: InputMaybe<StopsDatabaseQuayAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayAlternativeNamesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseQuayAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseQuayAlternativeNamesOrderBy>>;
    where?: InputMaybe<StopsDatabaseQuayAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayBoardingPositionsArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseQuayBoardingPositionsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseQuayBoardingPositionsOrderBy>>;
    where?: InputMaybe<StopsDatabaseQuayBoardingPositionsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayBoardingPositionsAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseQuayBoardingPositionsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseQuayBoardingPositionsOrderBy>>;
    where?: InputMaybe<StopsDatabaseQuayBoardingPositionsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayByPkArgs = {
  id: Scalars['bigint'];
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayCheckConstraintsArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseQuayCheckConstraintsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseQuayCheckConstraintsOrderBy>>;
    where?: InputMaybe<StopsDatabaseQuayCheckConstraintsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayCheckConstraintsAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseQuayCheckConstraintsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseQuayCheckConstraintsOrderBy>>;
    where?: InputMaybe<StopsDatabaseQuayCheckConstraintsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayEquipmentPlacesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseQuayEquipmentPlacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseQuayEquipmentPlacesOrderBy>>;
    where?: InputMaybe<StopsDatabaseQuayEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayEquipmentPlacesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseQuayEquipmentPlacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseQuayEquipmentPlacesOrderBy>>;
    where?: InputMaybe<StopsDatabaseQuayEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayKeyValuesArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseQuayKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseQuayKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayKeyValuesBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseQuayKeyValuesSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseQuayKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseQuayKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    quay_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseSchemaVersionArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseSchemaVersionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseSchemaVersionOrderBy>>;
  where?: InputMaybe<StopsDatabaseSchemaVersionBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseSchemaVersionAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseSchemaVersionSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseSchemaVersionOrderBy>>;
    where?: InputMaybe<StopsDatabaseSchemaVersionBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseSchemaVersionByPkArgs =
  {
    installed_rank: Scalars['Int'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseSpatialRefSysArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseSpatialRefSysSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseSpatialRefSysOrderBy>>;
  where?: InputMaybe<StopsDatabaseSpatialRefSysBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseSpatialRefSysAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseSpatialRefSysSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseSpatialRefSysOrderBy>>;
    where?: InputMaybe<StopsDatabaseSpatialRefSysBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseSpatialRefSysByPkArgs =
  {
    srid: Scalars['Int'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseStopPlaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseStopPlaceOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceAccessSpacesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseStopPlaceAccessSpacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceAccessSpacesOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceAccessSpacesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseStopPlaceAccessSpacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceAccessSpacesOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceAdjacentSitesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseStopPlaceAdjacentSitesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceAdjacentSitesOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceAdjacentSitesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceAdjacentSitesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseStopPlaceAdjacentSitesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceAdjacentSitesOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceAdjacentSitesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseStopPlaceSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceAlternativeNamesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseStopPlaceAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceAlternativeNamesOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceAlternativeNamesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseStopPlaceAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceAlternativeNamesOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceByPkArgs = {
  id: Scalars['bigint'];
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceChildrenArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseStopPlaceChildrenSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceChildrenOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceChildrenAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseStopPlaceChildrenSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceChildrenOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceChildrenByPkArgs =
  {
    children_id: Scalars['bigint'];
    stop_place_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceEquipmentPlacesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseStopPlaceEquipmentPlacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceEquipmentPlacesOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceEquipmentPlacesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseStopPlaceEquipmentPlacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceEquipmentPlacesOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseStopPlaceKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseStopPlaceKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    stop_place_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceQuaysArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseStopPlaceQuaysSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseStopPlaceQuaysOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceQuaysBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceQuaysAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseStopPlaceQuaysSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceQuaysOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceQuaysBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceQuaysByPkArgs =
  {
    quays_id: Scalars['bigint'];
    stop_place_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceTariffZonesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseStopPlaceTariffZonesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceTariffZonesOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceTariffZonesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceTariffZonesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseStopPlaceTariffZonesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceTariffZonesOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceTariffZonesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTagArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseTagSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseTagOrderBy>>;
  where?: InputMaybe<StopsDatabaseTagBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTagAggregateArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseTagSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseTagOrderBy>>;
  where?: InputMaybe<StopsDatabaseTagBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTagByPkArgs = {
  name: Scalars['String'];
  netex_reference: Scalars['String'];
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTariffZoneArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseTariffZoneSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseTariffZoneOrderBy>>;
  where?: InputMaybe<StopsDatabaseTariffZoneBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTariffZoneAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseTariffZoneSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseTariffZoneOrderBy>>;
    where?: InputMaybe<StopsDatabaseTariffZoneBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTariffZoneByPkArgs = {
  id: Scalars['bigint'];
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTariffZoneKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseTariffZoneKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseTariffZoneKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseTariffZoneKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTariffZoneKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseTariffZoneKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseTariffZoneKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseTariffZoneKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTariffZoneKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    tariff_zone_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTopographicPlaceArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseTopographicPlaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseTopographicPlaceOrderBy>>;
  where?: InputMaybe<StopsDatabaseTopographicPlaceBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTopographicPlaceAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseTopographicPlaceSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseTopographicPlaceOrderBy>>;
    where?: InputMaybe<StopsDatabaseTopographicPlaceBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTopographicPlaceByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTopographicPlaceKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseTopographicPlaceKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseTopographicPlaceKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTopographicPlaceKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseTopographicPlaceKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseTopographicPlaceKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTopographicPlaceKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    topographic_place_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseValueArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseValueSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseValueOrderBy>>;
  where?: InputMaybe<StopsDatabaseValueBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseValueAggregateArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseValueSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseValueOrderBy>>;
  where?: InputMaybe<StopsDatabaseValueBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseValueByPkArgs = {
  id: Scalars['bigint'];
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseValueItemsArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseValueItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseValueItemsOrderBy>>;
  where?: InputMaybe<StopsDatabaseValueItemsBoolExp>;
};

export type StopsDatabaseStopsDatabaseQueryStopsDatabaseValueItemsAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseValueItemsSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseValueItemsOrderBy>>;
    where?: InputMaybe<StopsDatabaseValueItemsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscription = {
  __typename?: 'stops_database_stops_database_subscription';
  /** fetch data from the table: "access_space" */
  stops_database_access_space: Array<StopsDatabaseAccessSpace>;
  /** fetch aggregated fields from the table: "access_space" */
  stops_database_access_space_aggregate: StopsDatabaseAccessSpaceAggregate;
  /** fetch data from the table: "access_space_alternative_names" */
  stops_database_access_space_alternative_names: Array<StopsDatabaseAccessSpaceAlternativeNames>;
  /** fetch aggregated fields from the table: "access_space_alternative_names" */
  stops_database_access_space_alternative_names_aggregate: StopsDatabaseAccessSpaceAlternativeNamesAggregate;
  /** fetch data from the table in a streaming manner: "access_space_alternative_names" */
  stops_database_access_space_alternative_names_stream: Array<StopsDatabaseAccessSpaceAlternativeNames>;
  /** fetch data from the table: "access_space" using primary key columns */
  stops_database_access_space_by_pk?: Maybe<StopsDatabaseAccessSpace>;
  /** fetch data from the table: "access_space_check_constraints" */
  stops_database_access_space_check_constraints: Array<StopsDatabaseAccessSpaceCheckConstraints>;
  /** fetch aggregated fields from the table: "access_space_check_constraints" */
  stops_database_access_space_check_constraints_aggregate: StopsDatabaseAccessSpaceCheckConstraintsAggregate;
  /** fetch data from the table in a streaming manner: "access_space_check_constraints" */
  stops_database_access_space_check_constraints_stream: Array<StopsDatabaseAccessSpaceCheckConstraints>;
  /** fetch data from the table: "access_space_equipment_places" */
  stops_database_access_space_equipment_places: Array<StopsDatabaseAccessSpaceEquipmentPlaces>;
  /** fetch aggregated fields from the table: "access_space_equipment_places" */
  stops_database_access_space_equipment_places_aggregate: StopsDatabaseAccessSpaceEquipmentPlacesAggregate;
  /** fetch data from the table in a streaming manner: "access_space_equipment_places" */
  stops_database_access_space_equipment_places_stream: Array<StopsDatabaseAccessSpaceEquipmentPlaces>;
  /** fetch data from the table: "access_space_key_values" */
  stops_database_access_space_key_values: Array<StopsDatabaseAccessSpaceKeyValues>;
  /** fetch aggregated fields from the table: "access_space_key_values" */
  stops_database_access_space_key_values_aggregate: StopsDatabaseAccessSpaceKeyValuesAggregate;
  /** fetch data from the table: "access_space_key_values" using primary key columns */
  stops_database_access_space_key_values_by_pk?: Maybe<StopsDatabaseAccessSpaceKeyValues>;
  /** fetch data from the table in a streaming manner: "access_space_key_values" */
  stops_database_access_space_key_values_stream: Array<StopsDatabaseAccessSpaceKeyValues>;
  /** fetch data from the table in a streaming manner: "access_space" */
  stops_database_access_space_stream: Array<StopsDatabaseAccessSpace>;
  /** fetch data from the table: "accessibility_assessment" */
  stops_database_accessibility_assessment: Array<StopsDatabaseAccessibilityAssessment>;
  /** fetch aggregated fields from the table: "accessibility_assessment" */
  stops_database_accessibility_assessment_aggregate: StopsDatabaseAccessibilityAssessmentAggregate;
  /** fetch data from the table: "accessibility_assessment" using primary key columns */
  stops_database_accessibility_assessment_by_pk?: Maybe<StopsDatabaseAccessibilityAssessment>;
  /** fetch data from the table: "accessibility_assessment_limitations" */
  stops_database_accessibility_assessment_limitations: Array<StopsDatabaseAccessibilityAssessmentLimitations>;
  /** fetch aggregated fields from the table: "accessibility_assessment_limitations" */
  stops_database_accessibility_assessment_limitations_aggregate: StopsDatabaseAccessibilityAssessmentLimitationsAggregate;
  /** fetch data from the table in a streaming manner: "accessibility_assessment_limitations" */
  stops_database_accessibility_assessment_limitations_stream: Array<StopsDatabaseAccessibilityAssessmentLimitations>;
  /** fetch data from the table in a streaming manner: "accessibility_assessment" */
  stops_database_accessibility_assessment_stream: Array<StopsDatabaseAccessibilityAssessment>;
  /** fetch data from the table: "accessibility_limitation" */
  stops_database_accessibility_limitation: Array<StopsDatabaseAccessibilityLimitation>;
  /** fetch aggregated fields from the table: "accessibility_limitation" */
  stops_database_accessibility_limitation_aggregate: StopsDatabaseAccessibilityLimitationAggregate;
  /** fetch data from the table: "accessibility_limitation" using primary key columns */
  stops_database_accessibility_limitation_by_pk?: Maybe<StopsDatabaseAccessibilityLimitation>;
  /** fetch data from the table in a streaming manner: "accessibility_limitation" */
  stops_database_accessibility_limitation_stream: Array<StopsDatabaseAccessibilityLimitation>;
  /** fetch data from the table: "alternative_name" */
  stops_database_alternative_name: Array<StopsDatabaseAlternativeName>;
  /** fetch aggregated fields from the table: "alternative_name" */
  stops_database_alternative_name_aggregate: StopsDatabaseAlternativeNameAggregate;
  /** fetch data from the table: "alternative_name" using primary key columns */
  stops_database_alternative_name_by_pk?: Maybe<StopsDatabaseAlternativeName>;
  /** fetch data from the table in a streaming manner: "alternative_name" */
  stops_database_alternative_name_stream: Array<StopsDatabaseAlternativeName>;
  /** fetch data from the table: "boarding_position" */
  stops_database_boarding_position: Array<StopsDatabaseBoardingPosition>;
  /** fetch aggregated fields from the table: "boarding_position" */
  stops_database_boarding_position_aggregate: StopsDatabaseBoardingPositionAggregate;
  /** fetch data from the table: "boarding_position_alternative_names" */
  stops_database_boarding_position_alternative_names: Array<StopsDatabaseBoardingPositionAlternativeNames>;
  /** fetch aggregated fields from the table: "boarding_position_alternative_names" */
  stops_database_boarding_position_alternative_names_aggregate: StopsDatabaseBoardingPositionAlternativeNamesAggregate;
  /** fetch data from the table in a streaming manner: "boarding_position_alternative_names" */
  stops_database_boarding_position_alternative_names_stream: Array<StopsDatabaseBoardingPositionAlternativeNames>;
  /** fetch data from the table: "boarding_position" using primary key columns */
  stops_database_boarding_position_by_pk?: Maybe<StopsDatabaseBoardingPosition>;
  /** fetch data from the table: "boarding_position_check_constraints" */
  stops_database_boarding_position_check_constraints: Array<StopsDatabaseBoardingPositionCheckConstraints>;
  /** fetch aggregated fields from the table: "boarding_position_check_constraints" */
  stops_database_boarding_position_check_constraints_aggregate: StopsDatabaseBoardingPositionCheckConstraintsAggregate;
  /** fetch data from the table in a streaming manner: "boarding_position_check_constraints" */
  stops_database_boarding_position_check_constraints_stream: Array<StopsDatabaseBoardingPositionCheckConstraints>;
  /** fetch data from the table: "boarding_position_equipment_places" */
  stops_database_boarding_position_equipment_places: Array<StopsDatabaseBoardingPositionEquipmentPlaces>;
  /** fetch aggregated fields from the table: "boarding_position_equipment_places" */
  stops_database_boarding_position_equipment_places_aggregate: StopsDatabaseBoardingPositionEquipmentPlacesAggregate;
  /** fetch data from the table in a streaming manner: "boarding_position_equipment_places" */
  stops_database_boarding_position_equipment_places_stream: Array<StopsDatabaseBoardingPositionEquipmentPlaces>;
  /** fetch data from the table: "boarding_position_key_values" */
  stops_database_boarding_position_key_values: Array<StopsDatabaseBoardingPositionKeyValues>;
  /** fetch aggregated fields from the table: "boarding_position_key_values" */
  stops_database_boarding_position_key_values_aggregate: StopsDatabaseBoardingPositionKeyValuesAggregate;
  /** fetch data from the table: "boarding_position_key_values" using primary key columns */
  stops_database_boarding_position_key_values_by_pk?: Maybe<StopsDatabaseBoardingPositionKeyValues>;
  /** fetch data from the table in a streaming manner: "boarding_position_key_values" */
  stops_database_boarding_position_key_values_stream: Array<StopsDatabaseBoardingPositionKeyValues>;
  /** fetch data from the table in a streaming manner: "boarding_position" */
  stops_database_boarding_position_stream: Array<StopsDatabaseBoardingPosition>;
  /** fetch data from the table: "check_constraint" */
  stops_database_check_constraint: Array<StopsDatabaseCheckConstraint>;
  /** fetch aggregated fields from the table: "check_constraint" */
  stops_database_check_constraint_aggregate: StopsDatabaseCheckConstraintAggregate;
  /** fetch data from the table: "check_constraint" using primary key columns */
  stops_database_check_constraint_by_pk?: Maybe<StopsDatabaseCheckConstraint>;
  /** fetch data from the table: "check_constraint_key_values" */
  stops_database_check_constraint_key_values: Array<StopsDatabaseCheckConstraintKeyValues>;
  /** fetch aggregated fields from the table: "check_constraint_key_values" */
  stops_database_check_constraint_key_values_aggregate: StopsDatabaseCheckConstraintKeyValuesAggregate;
  /** fetch data from the table: "check_constraint_key_values" using primary key columns */
  stops_database_check_constraint_key_values_by_pk?: Maybe<StopsDatabaseCheckConstraintKeyValues>;
  /** fetch data from the table in a streaming manner: "check_constraint_key_values" */
  stops_database_check_constraint_key_values_stream: Array<StopsDatabaseCheckConstraintKeyValues>;
  /** fetch data from the table in a streaming manner: "check_constraint" */
  stops_database_check_constraint_stream: Array<StopsDatabaseCheckConstraint>;
  /** fetch data from the table: "destination_display_view" */
  stops_database_destination_display_view: Array<StopsDatabaseDestinationDisplayView>;
  /** fetch aggregated fields from the table: "destination_display_view" */
  stops_database_destination_display_view_aggregate: StopsDatabaseDestinationDisplayViewAggregate;
  /** fetch data from the table: "destination_display_view" using primary key columns */
  stops_database_destination_display_view_by_pk?: Maybe<StopsDatabaseDestinationDisplayView>;
  /** fetch data from the table in a streaming manner: "destination_display_view" */
  stops_database_destination_display_view_stream: Array<StopsDatabaseDestinationDisplayView>;
  /** fetch data from the table: "equipment_place" */
  stops_database_equipment_place: Array<StopsDatabaseEquipmentPlace>;
  /** fetch aggregated fields from the table: "equipment_place" */
  stops_database_equipment_place_aggregate: StopsDatabaseEquipmentPlaceAggregate;
  /** fetch data from the table: "equipment_place" using primary key columns */
  stops_database_equipment_place_by_pk?: Maybe<StopsDatabaseEquipmentPlace>;
  /** fetch data from the table: "equipment_place_equipment_positions" */
  stops_database_equipment_place_equipment_positions: Array<StopsDatabaseEquipmentPlaceEquipmentPositions>;
  /** fetch aggregated fields from the table: "equipment_place_equipment_positions" */
  stops_database_equipment_place_equipment_positions_aggregate: StopsDatabaseEquipmentPlaceEquipmentPositionsAggregate;
  /** fetch data from the table in a streaming manner: "equipment_place_equipment_positions" */
  stops_database_equipment_place_equipment_positions_stream: Array<StopsDatabaseEquipmentPlaceEquipmentPositions>;
  /** fetch data from the table: "equipment_place_key_values" */
  stops_database_equipment_place_key_values: Array<StopsDatabaseEquipmentPlaceKeyValues>;
  /** fetch aggregated fields from the table: "equipment_place_key_values" */
  stops_database_equipment_place_key_values_aggregate: StopsDatabaseEquipmentPlaceKeyValuesAggregate;
  /** fetch data from the table: "equipment_place_key_values" using primary key columns */
  stops_database_equipment_place_key_values_by_pk?: Maybe<StopsDatabaseEquipmentPlaceKeyValues>;
  /** fetch data from the table in a streaming manner: "equipment_place_key_values" */
  stops_database_equipment_place_key_values_stream: Array<StopsDatabaseEquipmentPlaceKeyValues>;
  /** fetch data from the table in a streaming manner: "equipment_place" */
  stops_database_equipment_place_stream: Array<StopsDatabaseEquipmentPlace>;
  /** fetch data from the table: "equipment_position" */
  stops_database_equipment_position: Array<StopsDatabaseEquipmentPosition>;
  /** fetch aggregated fields from the table: "equipment_position" */
  stops_database_equipment_position_aggregate: StopsDatabaseEquipmentPositionAggregate;
  /** fetch data from the table: "equipment_position" using primary key columns */
  stops_database_equipment_position_by_pk?: Maybe<StopsDatabaseEquipmentPosition>;
  /** fetch data from the table: "equipment_position_key_values" */
  stops_database_equipment_position_key_values: Array<StopsDatabaseEquipmentPositionKeyValues>;
  /** fetch aggregated fields from the table: "equipment_position_key_values" */
  stops_database_equipment_position_key_values_aggregate: StopsDatabaseEquipmentPositionKeyValuesAggregate;
  /** fetch data from the table: "equipment_position_key_values" using primary key columns */
  stops_database_equipment_position_key_values_by_pk?: Maybe<StopsDatabaseEquipmentPositionKeyValues>;
  /** fetch data from the table in a streaming manner: "equipment_position_key_values" */
  stops_database_equipment_position_key_values_stream: Array<StopsDatabaseEquipmentPositionKeyValues>;
  /** fetch data from the table in a streaming manner: "equipment_position" */
  stops_database_equipment_position_stream: Array<StopsDatabaseEquipmentPosition>;
  /** fetch data from the table: "export_job" */
  stops_database_export_job: Array<StopsDatabaseExportJob>;
  /** fetch aggregated fields from the table: "export_job" */
  stops_database_export_job_aggregate: StopsDatabaseExportJobAggregate;
  /** fetch data from the table: "export_job" using primary key columns */
  stops_database_export_job_by_pk?: Maybe<StopsDatabaseExportJob>;
  /** fetch data from the table in a streaming manner: "export_job" */
  stops_database_export_job_stream: Array<StopsDatabaseExportJob>;
  /** fetch data from the table: "fare_zone" */
  stops_database_fare_zone: Array<StopsDatabaseFareZone>;
  /** fetch aggregated fields from the table: "fare_zone" */
  stops_database_fare_zone_aggregate: StopsDatabaseFareZoneAggregate;
  /** fetch data from the table: "fare_zone" using primary key columns */
  stops_database_fare_zone_by_pk?: Maybe<StopsDatabaseFareZone>;
  /** fetch data from the table: "fare_zone_key_values" */
  stops_database_fare_zone_key_values: Array<StopsDatabaseFareZoneKeyValues>;
  /** fetch aggregated fields from the table: "fare_zone_key_values" */
  stops_database_fare_zone_key_values_aggregate: StopsDatabaseFareZoneKeyValuesAggregate;
  /** fetch data from the table: "fare_zone_key_values" using primary key columns */
  stops_database_fare_zone_key_values_by_pk?: Maybe<StopsDatabaseFareZoneKeyValues>;
  /** fetch data from the table in a streaming manner: "fare_zone_key_values" */
  stops_database_fare_zone_key_values_stream: Array<StopsDatabaseFareZoneKeyValues>;
  /** fetch data from the table: "fare_zone_members" */
  stops_database_fare_zone_members: Array<StopsDatabaseFareZoneMembers>;
  /** fetch aggregated fields from the table: "fare_zone_members" */
  stops_database_fare_zone_members_aggregate: StopsDatabaseFareZoneMembersAggregate;
  /** fetch data from the table in a streaming manner: "fare_zone_members" */
  stops_database_fare_zone_members_stream: Array<StopsDatabaseFareZoneMembers>;
  /** fetch data from the table: "fare_zone_neighbours" */
  stops_database_fare_zone_neighbours: Array<StopsDatabaseFareZoneNeighbours>;
  /** fetch aggregated fields from the table: "fare_zone_neighbours" */
  stops_database_fare_zone_neighbours_aggregate: StopsDatabaseFareZoneNeighboursAggregate;
  /** fetch data from the table in a streaming manner: "fare_zone_neighbours" */
  stops_database_fare_zone_neighbours_stream: Array<StopsDatabaseFareZoneNeighbours>;
  /** fetch data from the table in a streaming manner: "fare_zone" */
  stops_database_fare_zone_stream: Array<StopsDatabaseFareZone>;
  /** fetch data from the table: "geography_columns" */
  stops_database_geography_columns: Array<StopsDatabaseGeographyColumns>;
  /** fetch aggregated fields from the table: "geography_columns" */
  stops_database_geography_columns_aggregate: StopsDatabaseGeographyColumnsAggregate;
  /** fetch data from the table in a streaming manner: "geography_columns" */
  stops_database_geography_columns_stream: Array<StopsDatabaseGeographyColumns>;
  /** fetch data from the table: "geometry_columns" */
  stops_database_geometry_columns: Array<StopsDatabaseGeometryColumns>;
  /** fetch aggregated fields from the table: "geometry_columns" */
  stops_database_geometry_columns_aggregate: StopsDatabaseGeometryColumnsAggregate;
  /** fetch data from the table in a streaming manner: "geometry_columns" */
  stops_database_geometry_columns_stream: Array<StopsDatabaseGeometryColumns>;
  /** fetch data from the table: "group_of_stop_places" */
  stops_database_group_of_stop_places: Array<StopsDatabaseGroupOfStopPlaces>;
  /** fetch aggregated fields from the table: "group_of_stop_places" */
  stops_database_group_of_stop_places_aggregate: StopsDatabaseGroupOfStopPlacesAggregate;
  /** fetch data from the table: "group_of_stop_places_alternative_names" */
  stops_database_group_of_stop_places_alternative_names: Array<StopsDatabaseGroupOfStopPlacesAlternativeNames>;
  /** fetch aggregated fields from the table: "group_of_stop_places_alternative_names" */
  stops_database_group_of_stop_places_alternative_names_aggregate: StopsDatabaseGroupOfStopPlacesAlternativeNamesAggregate;
  /** fetch data from the table in a streaming manner: "group_of_stop_places_alternative_names" */
  stops_database_group_of_stop_places_alternative_names_stream: Array<StopsDatabaseGroupOfStopPlacesAlternativeNames>;
  /** fetch data from the table: "group_of_stop_places" using primary key columns */
  stops_database_group_of_stop_places_by_pk?: Maybe<StopsDatabaseGroupOfStopPlaces>;
  /** fetch data from the table: "group_of_stop_places_key_values" */
  stops_database_group_of_stop_places_key_values: Array<StopsDatabaseGroupOfStopPlacesKeyValues>;
  /** fetch aggregated fields from the table: "group_of_stop_places_key_values" */
  stops_database_group_of_stop_places_key_values_aggregate: StopsDatabaseGroupOfStopPlacesKeyValuesAggregate;
  /** fetch data from the table: "group_of_stop_places_key_values" using primary key columns */
  stops_database_group_of_stop_places_key_values_by_pk?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValues>;
  /** fetch data from the table in a streaming manner: "group_of_stop_places_key_values" */
  stops_database_group_of_stop_places_key_values_stream: Array<StopsDatabaseGroupOfStopPlacesKeyValues>;
  /** fetch data from the table: "group_of_stop_places_members" */
  stops_database_group_of_stop_places_members: Array<StopsDatabaseGroupOfStopPlacesMembers>;
  /** fetch aggregated fields from the table: "group_of_stop_places_members" */
  stops_database_group_of_stop_places_members_aggregate: StopsDatabaseGroupOfStopPlacesMembersAggregate;
  /** fetch data from the table in a streaming manner: "group_of_stop_places_members" */
  stops_database_group_of_stop_places_members_stream: Array<StopsDatabaseGroupOfStopPlacesMembers>;
  /** fetch data from the table in a streaming manner: "group_of_stop_places" */
  stops_database_group_of_stop_places_stream: Array<StopsDatabaseGroupOfStopPlaces>;
  /** fetch data from the table: "group_of_tariff_zones" */
  stops_database_group_of_tariff_zones: Array<StopsDatabaseGroupOfTariffZones>;
  /** fetch aggregated fields from the table: "group_of_tariff_zones" */
  stops_database_group_of_tariff_zones_aggregate: StopsDatabaseGroupOfTariffZonesAggregate;
  /** fetch data from the table: "group_of_tariff_zones" using primary key columns */
  stops_database_group_of_tariff_zones_by_pk?: Maybe<StopsDatabaseGroupOfTariffZones>;
  /** fetch data from the table: "group_of_tariff_zones_key_values" */
  stops_database_group_of_tariff_zones_key_values: Array<StopsDatabaseGroupOfTariffZonesKeyValues>;
  /** fetch aggregated fields from the table: "group_of_tariff_zones_key_values" */
  stops_database_group_of_tariff_zones_key_values_aggregate: StopsDatabaseGroupOfTariffZonesKeyValuesAggregate;
  /** fetch data from the table: "group_of_tariff_zones_key_values" using primary key columns */
  stops_database_group_of_tariff_zones_key_values_by_pk?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValues>;
  /** fetch data from the table in a streaming manner: "group_of_tariff_zones_key_values" */
  stops_database_group_of_tariff_zones_key_values_stream: Array<StopsDatabaseGroupOfTariffZonesKeyValues>;
  /** fetch data from the table: "group_of_tariff_zones_members" */
  stops_database_group_of_tariff_zones_members: Array<StopsDatabaseGroupOfTariffZonesMembers>;
  /** fetch aggregated fields from the table: "group_of_tariff_zones_members" */
  stops_database_group_of_tariff_zones_members_aggregate: StopsDatabaseGroupOfTariffZonesMembersAggregate;
  /** fetch data from the table: "group_of_tariff_zones_members" using primary key columns */
  stops_database_group_of_tariff_zones_members_by_pk?: Maybe<StopsDatabaseGroupOfTariffZonesMembers>;
  /** fetch data from the table in a streaming manner: "group_of_tariff_zones_members" */
  stops_database_group_of_tariff_zones_members_stream: Array<StopsDatabaseGroupOfTariffZonesMembers>;
  /** fetch data from the table in a streaming manner: "group_of_tariff_zones" */
  stops_database_group_of_tariff_zones_stream: Array<StopsDatabaseGroupOfTariffZones>;
  /** fetch data from the table: "id_generator" */
  stops_database_id_generator: Array<StopsDatabaseIdGenerator>;
  /** fetch aggregated fields from the table: "id_generator" */
  stops_database_id_generator_aggregate: StopsDatabaseIdGeneratorAggregate;
  /** fetch data from the table in a streaming manner: "id_generator" */
  stops_database_id_generator_stream: Array<StopsDatabaseIdGenerator>;
  /** fetch data from the table: "installed_equipment" */
  stops_database_installed_equipment: Array<StopsDatabaseInstalledEquipment>;
  /** fetch aggregated fields from the table: "installed_equipment" */
  stops_database_installed_equipment_aggregate: StopsDatabaseInstalledEquipmentAggregate;
  /** fetch data from the table in a streaming manner: "installed_equipment" */
  stops_database_installed_equipment_stream: Array<StopsDatabaseInstalledEquipment>;
  /** fetch data from the table: "installed_equipment_version_structure" */
  stops_database_installed_equipment_version_structure: Array<StopsDatabaseInstalledEquipmentVersionStructure>;
  /** fetch aggregated fields from the table: "installed_equipment_version_structure" */
  stops_database_installed_equipment_version_structure_aggregate: StopsDatabaseInstalledEquipmentVersionStructureAggregate;
  /** fetch data from the table: "installed_equipment_version_structure" using primary key columns */
  stops_database_installed_equipment_version_structure_by_pk?: Maybe<StopsDatabaseInstalledEquipmentVersionStructure>;
  /** fetch data from the table: "installed_equipment_version_structure_installed_equipment" */
  stops_database_installed_equipment_version_structure_installed_equipment: Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipment>;
  /** fetch aggregated fields from the table: "installed_equipment_version_structure_installed_equipment" */
  stops_database_installed_equipment_version_structure_installed_equipment_aggregate: StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAggregate;
  /** fetch data from the table in a streaming manner: "installed_equipment_version_structure_installed_equipment" */
  stops_database_installed_equipment_version_structure_installed_equipment_stream: Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipment>;
  /** fetch data from the table in a streaming manner: "installed_equipment_version_structure" */
  stops_database_installed_equipment_version_structure_stream: Array<StopsDatabaseInstalledEquipmentVersionStructure>;
  /** fetch data from the table: "level" */
  stops_database_level: Array<StopsDatabaseLevel>;
  /** fetch aggregated fields from the table: "level" */
  stops_database_level_aggregate: StopsDatabaseLevelAggregate;
  /** fetch data from the table: "level" using primary key columns */
  stops_database_level_by_pk?: Maybe<StopsDatabaseLevel>;
  /** fetch data from the table: "level_key_values" */
  stops_database_level_key_values: Array<StopsDatabaseLevelKeyValues>;
  /** fetch aggregated fields from the table: "level_key_values" */
  stops_database_level_key_values_aggregate: StopsDatabaseLevelKeyValuesAggregate;
  /** fetch data from the table: "level_key_values" using primary key columns */
  stops_database_level_key_values_by_pk?: Maybe<StopsDatabaseLevelKeyValues>;
  /** fetch data from the table in a streaming manner: "level_key_values" */
  stops_database_level_key_values_stream: Array<StopsDatabaseLevelKeyValues>;
  /** fetch data from the table in a streaming manner: "level" */
  stops_database_level_stream: Array<StopsDatabaseLevel>;
  /** fetch data from the table: "multilingual_string_entity" */
  stops_database_multilingual_string_entity: Array<StopsDatabaseMultilingualStringEntity>;
  /** fetch aggregated fields from the table: "multilingual_string_entity" */
  stops_database_multilingual_string_entity_aggregate: StopsDatabaseMultilingualStringEntityAggregate;
  /** fetch data from the table: "multilingual_string_entity" using primary key columns */
  stops_database_multilingual_string_entity_by_pk?: Maybe<StopsDatabaseMultilingualStringEntity>;
  /** fetch data from the table in a streaming manner: "multilingual_string_entity" */
  stops_database_multilingual_string_entity_stream: Array<StopsDatabaseMultilingualStringEntity>;
  /** fetch data from the table: "navigation_path" */
  stops_database_navigation_path: Array<StopsDatabaseNavigationPath>;
  /** fetch aggregated fields from the table: "navigation_path" */
  stops_database_navigation_path_aggregate: StopsDatabaseNavigationPathAggregate;
  /** fetch data from the table in a streaming manner: "navigation_path" */
  stops_database_navigation_path_stream: Array<StopsDatabaseNavigationPath>;
  /** fetch data from the table: "parking" */
  stops_database_parking: Array<StopsDatabaseParking>;
  /** fetch data from the table: "parking_adjacent_sites" */
  stops_database_parking_adjacent_sites: Array<StopsDatabaseParkingAdjacentSites>;
  /** fetch aggregated fields from the table: "parking_adjacent_sites" */
  stops_database_parking_adjacent_sites_aggregate: StopsDatabaseParkingAdjacentSitesAggregate;
  /** fetch data from the table in a streaming manner: "parking_adjacent_sites" */
  stops_database_parking_adjacent_sites_stream: Array<StopsDatabaseParkingAdjacentSites>;
  /** fetch aggregated fields from the table: "parking" */
  stops_database_parking_aggregate: StopsDatabaseParkingAggregate;
  /** fetch data from the table: "parking_alternative_names" */
  stops_database_parking_alternative_names: Array<StopsDatabaseParkingAlternativeNames>;
  /** fetch aggregated fields from the table: "parking_alternative_names" */
  stops_database_parking_alternative_names_aggregate: StopsDatabaseParkingAlternativeNamesAggregate;
  /** fetch data from the table in a streaming manner: "parking_alternative_names" */
  stops_database_parking_alternative_names_stream: Array<StopsDatabaseParkingAlternativeNames>;
  /** fetch data from the table: "parking_area" */
  stops_database_parking_area: Array<StopsDatabaseParkingArea>;
  /** fetch aggregated fields from the table: "parking_area" */
  stops_database_parking_area_aggregate: StopsDatabaseParkingAreaAggregate;
  /** fetch data from the table: "parking_area_alternative_names" */
  stops_database_parking_area_alternative_names: Array<StopsDatabaseParkingAreaAlternativeNames>;
  /** fetch aggregated fields from the table: "parking_area_alternative_names" */
  stops_database_parking_area_alternative_names_aggregate: StopsDatabaseParkingAreaAlternativeNamesAggregate;
  /** fetch data from the table in a streaming manner: "parking_area_alternative_names" */
  stops_database_parking_area_alternative_names_stream: Array<StopsDatabaseParkingAreaAlternativeNames>;
  /** fetch data from the table: "parking_area" using primary key columns */
  stops_database_parking_area_by_pk?: Maybe<StopsDatabaseParkingArea>;
  /** fetch data from the table: "parking_area_check_constraints" */
  stops_database_parking_area_check_constraints: Array<StopsDatabaseParkingAreaCheckConstraints>;
  /** fetch aggregated fields from the table: "parking_area_check_constraints" */
  stops_database_parking_area_check_constraints_aggregate: StopsDatabaseParkingAreaCheckConstraintsAggregate;
  /** fetch data from the table in a streaming manner: "parking_area_check_constraints" */
  stops_database_parking_area_check_constraints_stream: Array<StopsDatabaseParkingAreaCheckConstraints>;
  /** fetch data from the table: "parking_area_equipment_places" */
  stops_database_parking_area_equipment_places: Array<StopsDatabaseParkingAreaEquipmentPlaces>;
  /** fetch aggregated fields from the table: "parking_area_equipment_places" */
  stops_database_parking_area_equipment_places_aggregate: StopsDatabaseParkingAreaEquipmentPlacesAggregate;
  /** fetch data from the table in a streaming manner: "parking_area_equipment_places" */
  stops_database_parking_area_equipment_places_stream: Array<StopsDatabaseParkingAreaEquipmentPlaces>;
  /** fetch data from the table: "parking_area_key_values" */
  stops_database_parking_area_key_values: Array<StopsDatabaseParkingAreaKeyValues>;
  /** fetch aggregated fields from the table: "parking_area_key_values" */
  stops_database_parking_area_key_values_aggregate: StopsDatabaseParkingAreaKeyValuesAggregate;
  /** fetch data from the table: "parking_area_key_values" using primary key columns */
  stops_database_parking_area_key_values_by_pk?: Maybe<StopsDatabaseParkingAreaKeyValues>;
  /** fetch data from the table in a streaming manner: "parking_area_key_values" */
  stops_database_parking_area_key_values_stream: Array<StopsDatabaseParkingAreaKeyValues>;
  /** fetch data from the table in a streaming manner: "parking_area" */
  stops_database_parking_area_stream: Array<StopsDatabaseParkingArea>;
  /** fetch data from the table: "parking" using primary key columns */
  stops_database_parking_by_pk?: Maybe<StopsDatabaseParking>;
  /** fetch data from the table: "parking_capacity" */
  stops_database_parking_capacity: Array<StopsDatabaseParkingCapacity>;
  /** fetch aggregated fields from the table: "parking_capacity" */
  stops_database_parking_capacity_aggregate: StopsDatabaseParkingCapacityAggregate;
  /** fetch data from the table: "parking_capacity" using primary key columns */
  stops_database_parking_capacity_by_pk?: Maybe<StopsDatabaseParkingCapacity>;
  /** fetch data from the table in a streaming manner: "parking_capacity" */
  stops_database_parking_capacity_stream: Array<StopsDatabaseParkingCapacity>;
  /** fetch data from the table: "parking_equipment_places" */
  stops_database_parking_equipment_places: Array<StopsDatabaseParkingEquipmentPlaces>;
  /** fetch aggregated fields from the table: "parking_equipment_places" */
  stops_database_parking_equipment_places_aggregate: StopsDatabaseParkingEquipmentPlacesAggregate;
  /** fetch data from the table in a streaming manner: "parking_equipment_places" */
  stops_database_parking_equipment_places_stream: Array<StopsDatabaseParkingEquipmentPlaces>;
  /** fetch data from the table: "parking_key_values" */
  stops_database_parking_key_values: Array<StopsDatabaseParkingKeyValues>;
  /** fetch aggregated fields from the table: "parking_key_values" */
  stops_database_parking_key_values_aggregate: StopsDatabaseParkingKeyValuesAggregate;
  /** fetch data from the table: "parking_key_values" using primary key columns */
  stops_database_parking_key_values_by_pk?: Maybe<StopsDatabaseParkingKeyValues>;
  /** fetch data from the table in a streaming manner: "parking_key_values" */
  stops_database_parking_key_values_stream: Array<StopsDatabaseParkingKeyValues>;
  /** fetch data from the table: "parking_parking_areas" */
  stops_database_parking_parking_areas: Array<StopsDatabaseParkingParkingAreas>;
  /** fetch aggregated fields from the table: "parking_parking_areas" */
  stops_database_parking_parking_areas_aggregate: StopsDatabaseParkingParkingAreasAggregate;
  /** fetch data from the table in a streaming manner: "parking_parking_areas" */
  stops_database_parking_parking_areas_stream: Array<StopsDatabaseParkingParkingAreas>;
  /** fetch data from the table: "parking_parking_payment_process" */
  stops_database_parking_parking_payment_process: Array<StopsDatabaseParkingParkingPaymentProcess>;
  /** fetch aggregated fields from the table: "parking_parking_payment_process" */
  stops_database_parking_parking_payment_process_aggregate: StopsDatabaseParkingParkingPaymentProcessAggregate;
  /** fetch data from the table in a streaming manner: "parking_parking_payment_process" */
  stops_database_parking_parking_payment_process_stream: Array<StopsDatabaseParkingParkingPaymentProcess>;
  /** fetch data from the table: "parking_parking_properties" */
  stops_database_parking_parking_properties: Array<StopsDatabaseParkingParkingProperties>;
  /** fetch aggregated fields from the table: "parking_parking_properties" */
  stops_database_parking_parking_properties_aggregate: StopsDatabaseParkingParkingPropertiesAggregate;
  /** fetch data from the table in a streaming manner: "parking_parking_properties" */
  stops_database_parking_parking_properties_stream: Array<StopsDatabaseParkingParkingProperties>;
  /** fetch data from the table: "parking_parking_vehicle_types" */
  stops_database_parking_parking_vehicle_types: Array<StopsDatabaseParkingParkingVehicleTypes>;
  /** fetch aggregated fields from the table: "parking_parking_vehicle_types" */
  stops_database_parking_parking_vehicle_types_aggregate: StopsDatabaseParkingParkingVehicleTypesAggregate;
  /** fetch data from the table in a streaming manner: "parking_parking_vehicle_types" */
  stops_database_parking_parking_vehicle_types_stream: Array<StopsDatabaseParkingParkingVehicleTypes>;
  /** fetch data from the table: "parking_properties" */
  stops_database_parking_properties: Array<StopsDatabaseParkingProperties>;
  /** fetch aggregated fields from the table: "parking_properties" */
  stops_database_parking_properties_aggregate: StopsDatabaseParkingPropertiesAggregate;
  /** fetch data from the table: "parking_properties" using primary key columns */
  stops_database_parking_properties_by_pk?: Maybe<StopsDatabaseParkingProperties>;
  /** fetch data from the table: "parking_properties_parking_user_types" */
  stops_database_parking_properties_parking_user_types: Array<StopsDatabaseParkingPropertiesParkingUserTypes>;
  /** fetch aggregated fields from the table: "parking_properties_parking_user_types" */
  stops_database_parking_properties_parking_user_types_aggregate: StopsDatabaseParkingPropertiesParkingUserTypesAggregate;
  /** fetch data from the table in a streaming manner: "parking_properties_parking_user_types" */
  stops_database_parking_properties_parking_user_types_stream: Array<StopsDatabaseParkingPropertiesParkingUserTypes>;
  /** fetch data from the table: "parking_properties_spaces" */
  stops_database_parking_properties_spaces: Array<StopsDatabaseParkingPropertiesSpaces>;
  /** fetch aggregated fields from the table: "parking_properties_spaces" */
  stops_database_parking_properties_spaces_aggregate: StopsDatabaseParkingPropertiesSpacesAggregate;
  /** fetch data from the table in a streaming manner: "parking_properties_spaces" */
  stops_database_parking_properties_spaces_stream: Array<StopsDatabaseParkingPropertiesSpaces>;
  /** fetch data from the table in a streaming manner: "parking_properties" */
  stops_database_parking_properties_stream: Array<StopsDatabaseParkingProperties>;
  /** fetch data from the table in a streaming manner: "parking" */
  stops_database_parking_stream: Array<StopsDatabaseParking>;
  /** fetch data from the table: "path_junction" */
  stops_database_path_junction: Array<StopsDatabasePathJunction>;
  /** fetch aggregated fields from the table: "path_junction" */
  stops_database_path_junction_aggregate: StopsDatabasePathJunctionAggregate;
  /** fetch data from the table: "path_junction" using primary key columns */
  stops_database_path_junction_by_pk?: Maybe<StopsDatabasePathJunction>;
  /** fetch data from the table: "path_junction_key_values" */
  stops_database_path_junction_key_values: Array<StopsDatabasePathJunctionKeyValues>;
  /** fetch aggregated fields from the table: "path_junction_key_values" */
  stops_database_path_junction_key_values_aggregate: StopsDatabasePathJunctionKeyValuesAggregate;
  /** fetch data from the table: "path_junction_key_values" using primary key columns */
  stops_database_path_junction_key_values_by_pk?: Maybe<StopsDatabasePathJunctionKeyValues>;
  /** fetch data from the table in a streaming manner: "path_junction_key_values" */
  stops_database_path_junction_key_values_stream: Array<StopsDatabasePathJunctionKeyValues>;
  /** fetch data from the table in a streaming manner: "path_junction" */
  stops_database_path_junction_stream: Array<StopsDatabasePathJunction>;
  /** fetch data from the table: "path_link" */
  stops_database_path_link: Array<StopsDatabasePathLink>;
  /** fetch aggregated fields from the table: "path_link" */
  stops_database_path_link_aggregate: StopsDatabasePathLinkAggregate;
  /** fetch data from the table: "path_link" using primary key columns */
  stops_database_path_link_by_pk?: Maybe<StopsDatabasePathLink>;
  /** fetch data from the table: "path_link_end" */
  stops_database_path_link_end: Array<StopsDatabasePathLinkEnd>;
  /** fetch aggregated fields from the table: "path_link_end" */
  stops_database_path_link_end_aggregate: StopsDatabasePathLinkEndAggregate;
  /** fetch data from the table: "path_link_end" using primary key columns */
  stops_database_path_link_end_by_pk?: Maybe<StopsDatabasePathLinkEnd>;
  /** fetch data from the table in a streaming manner: "path_link_end" */
  stops_database_path_link_end_stream: Array<StopsDatabasePathLinkEnd>;
  /** fetch data from the table: "path_link_key_values" */
  stops_database_path_link_key_values: Array<StopsDatabasePathLinkKeyValues>;
  /** fetch aggregated fields from the table: "path_link_key_values" */
  stops_database_path_link_key_values_aggregate: StopsDatabasePathLinkKeyValuesAggregate;
  /** fetch data from the table: "path_link_key_values" using primary key columns */
  stops_database_path_link_key_values_by_pk?: Maybe<StopsDatabasePathLinkKeyValues>;
  /** fetch data from the table in a streaming manner: "path_link_key_values" */
  stops_database_path_link_key_values_stream: Array<StopsDatabasePathLinkKeyValues>;
  /** fetch data from the table in a streaming manner: "path_link" */
  stops_database_path_link_stream: Array<StopsDatabasePathLink>;
  /** fetch data from the table: "persistable_polygon" */
  stops_database_persistable_polygon: Array<StopsDatabasePersistablePolygon>;
  /** fetch aggregated fields from the table: "persistable_polygon" */
  stops_database_persistable_polygon_aggregate: StopsDatabasePersistablePolygonAggregate;
  /** fetch data from the table: "persistable_polygon" using primary key columns */
  stops_database_persistable_polygon_by_pk?: Maybe<StopsDatabasePersistablePolygon>;
  /** fetch data from the table in a streaming manner: "persistable_polygon" */
  stops_database_persistable_polygon_stream: Array<StopsDatabasePersistablePolygon>;
  /** fetch data from the table: "purpose_of_grouping" */
  stops_database_purpose_of_grouping: Array<StopsDatabasePurposeOfGrouping>;
  /** fetch aggregated fields from the table: "purpose_of_grouping" */
  stops_database_purpose_of_grouping_aggregate: StopsDatabasePurposeOfGroupingAggregate;
  /** fetch data from the table: "purpose_of_grouping" using primary key columns */
  stops_database_purpose_of_grouping_by_pk?: Maybe<StopsDatabasePurposeOfGrouping>;
  /** fetch data from the table: "purpose_of_grouping_key_values" */
  stops_database_purpose_of_grouping_key_values: Array<StopsDatabasePurposeOfGroupingKeyValues>;
  /** fetch aggregated fields from the table: "purpose_of_grouping_key_values" */
  stops_database_purpose_of_grouping_key_values_aggregate: StopsDatabasePurposeOfGroupingKeyValuesAggregate;
  /** fetch data from the table: "purpose_of_grouping_key_values" using primary key columns */
  stops_database_purpose_of_grouping_key_values_by_pk?: Maybe<StopsDatabasePurposeOfGroupingKeyValues>;
  /** fetch data from the table in a streaming manner: "purpose_of_grouping_key_values" */
  stops_database_purpose_of_grouping_key_values_stream: Array<StopsDatabasePurposeOfGroupingKeyValues>;
  /** fetch data from the table in a streaming manner: "purpose_of_grouping" */
  stops_database_purpose_of_grouping_stream: Array<StopsDatabasePurposeOfGrouping>;
  /** fetch data from the table: "quay" */
  stops_database_quay: Array<StopsDatabaseQuay>;
  /** fetch aggregated fields from the table: "quay" */
  stops_database_quay_aggregate: StopsDatabaseQuayAggregate;
  /** fetch data from the table: "quay_alternative_names" */
  stops_database_quay_alternative_names: Array<StopsDatabaseQuayAlternativeNames>;
  /** fetch aggregated fields from the table: "quay_alternative_names" */
  stops_database_quay_alternative_names_aggregate: StopsDatabaseQuayAlternativeNamesAggregate;
  /** fetch data from the table in a streaming manner: "quay_alternative_names" */
  stops_database_quay_alternative_names_stream: Array<StopsDatabaseQuayAlternativeNames>;
  /** fetch data from the table: "quay_boarding_positions" */
  stops_database_quay_boarding_positions: Array<StopsDatabaseQuayBoardingPositions>;
  /** fetch aggregated fields from the table: "quay_boarding_positions" */
  stops_database_quay_boarding_positions_aggregate: StopsDatabaseQuayBoardingPositionsAggregate;
  /** fetch data from the table in a streaming manner: "quay_boarding_positions" */
  stops_database_quay_boarding_positions_stream: Array<StopsDatabaseQuayBoardingPositions>;
  /** fetch data from the table: "quay" using primary key columns */
  stops_database_quay_by_pk?: Maybe<StopsDatabaseQuay>;
  /** fetch data from the table: "quay_check_constraints" */
  stops_database_quay_check_constraints: Array<StopsDatabaseQuayCheckConstraints>;
  /** fetch aggregated fields from the table: "quay_check_constraints" */
  stops_database_quay_check_constraints_aggregate: StopsDatabaseQuayCheckConstraintsAggregate;
  /** fetch data from the table in a streaming manner: "quay_check_constraints" */
  stops_database_quay_check_constraints_stream: Array<StopsDatabaseQuayCheckConstraints>;
  /** fetch data from the table: "quay_equipment_places" */
  stops_database_quay_equipment_places: Array<StopsDatabaseQuayEquipmentPlaces>;
  /** fetch aggregated fields from the table: "quay_equipment_places" */
  stops_database_quay_equipment_places_aggregate: StopsDatabaseQuayEquipmentPlacesAggregate;
  /** fetch data from the table in a streaming manner: "quay_equipment_places" */
  stops_database_quay_equipment_places_stream: Array<StopsDatabaseQuayEquipmentPlaces>;
  /** fetch data from the table: "quay_key_values" */
  stops_database_quay_key_values: Array<StopsDatabaseQuayKeyValues>;
  /** fetch aggregated fields from the table: "quay_key_values" */
  stops_database_quay_key_values_aggregate: StopsDatabaseQuayKeyValuesAggregate;
  /** fetch data from the table: "quay_key_values" using primary key columns */
  stops_database_quay_key_values_by_pk?: Maybe<StopsDatabaseQuayKeyValues>;
  /** fetch data from the table in a streaming manner: "quay_key_values" */
  stops_database_quay_key_values_stream: Array<StopsDatabaseQuayKeyValues>;
  /** fetch data from the table in a streaming manner: "quay" */
  stops_database_quay_stream: Array<StopsDatabaseQuay>;
  /** fetch data from the table: "schema_version" */
  stops_database_schema_version: Array<StopsDatabaseSchemaVersion>;
  /** fetch aggregated fields from the table: "schema_version" */
  stops_database_schema_version_aggregate: StopsDatabaseSchemaVersionAggregate;
  /** fetch data from the table: "schema_version" using primary key columns */
  stops_database_schema_version_by_pk?: Maybe<StopsDatabaseSchemaVersion>;
  /** fetch data from the table in a streaming manner: "schema_version" */
  stops_database_schema_version_stream: Array<StopsDatabaseSchemaVersion>;
  /** fetch data from the table: "spatial_ref_sys" */
  stops_database_spatial_ref_sys: Array<StopsDatabaseSpatialRefSys>;
  /** fetch aggregated fields from the table: "spatial_ref_sys" */
  stops_database_spatial_ref_sys_aggregate: StopsDatabaseSpatialRefSysAggregate;
  /** fetch data from the table: "spatial_ref_sys" using primary key columns */
  stops_database_spatial_ref_sys_by_pk?: Maybe<StopsDatabaseSpatialRefSys>;
  /** fetch data from the table in a streaming manner: "spatial_ref_sys" */
  stops_database_spatial_ref_sys_stream: Array<StopsDatabaseSpatialRefSys>;
  /** fetch data from the table: "stop_place" */
  stops_database_stop_place: Array<StopsDatabaseStopPlace>;
  /** fetch data from the table: "stop_place_access_spaces" */
  stops_database_stop_place_access_spaces: Array<StopsDatabaseStopPlaceAccessSpaces>;
  /** fetch aggregated fields from the table: "stop_place_access_spaces" */
  stops_database_stop_place_access_spaces_aggregate: StopsDatabaseStopPlaceAccessSpacesAggregate;
  /** fetch data from the table in a streaming manner: "stop_place_access_spaces" */
  stops_database_stop_place_access_spaces_stream: Array<StopsDatabaseStopPlaceAccessSpaces>;
  /** fetch data from the table: "stop_place_adjacent_sites" */
  stops_database_stop_place_adjacent_sites: Array<StopsDatabaseStopPlaceAdjacentSites>;
  /** fetch aggregated fields from the table: "stop_place_adjacent_sites" */
  stops_database_stop_place_adjacent_sites_aggregate: StopsDatabaseStopPlaceAdjacentSitesAggregate;
  /** fetch data from the table in a streaming manner: "stop_place_adjacent_sites" */
  stops_database_stop_place_adjacent_sites_stream: Array<StopsDatabaseStopPlaceAdjacentSites>;
  /** fetch aggregated fields from the table: "stop_place" */
  stops_database_stop_place_aggregate: StopsDatabaseStopPlaceAggregate;
  /** fetch data from the table: "stop_place_alternative_names" */
  stops_database_stop_place_alternative_names: Array<StopsDatabaseStopPlaceAlternativeNames>;
  /** fetch aggregated fields from the table: "stop_place_alternative_names" */
  stops_database_stop_place_alternative_names_aggregate: StopsDatabaseStopPlaceAlternativeNamesAggregate;
  /** fetch data from the table in a streaming manner: "stop_place_alternative_names" */
  stops_database_stop_place_alternative_names_stream: Array<StopsDatabaseStopPlaceAlternativeNames>;
  /** fetch data from the table: "stop_place" using primary key columns */
  stops_database_stop_place_by_pk?: Maybe<StopsDatabaseStopPlace>;
  /** fetch data from the table: "stop_place_children" */
  stops_database_stop_place_children: Array<StopsDatabaseStopPlaceChildren>;
  /** fetch aggregated fields from the table: "stop_place_children" */
  stops_database_stop_place_children_aggregate: StopsDatabaseStopPlaceChildrenAggregate;
  /** fetch data from the table: "stop_place_children" using primary key columns */
  stops_database_stop_place_children_by_pk?: Maybe<StopsDatabaseStopPlaceChildren>;
  /** fetch data from the table in a streaming manner: "stop_place_children" */
  stops_database_stop_place_children_stream: Array<StopsDatabaseStopPlaceChildren>;
  /** fetch data from the table: "stop_place_equipment_places" */
  stops_database_stop_place_equipment_places: Array<StopsDatabaseStopPlaceEquipmentPlaces>;
  /** fetch aggregated fields from the table: "stop_place_equipment_places" */
  stops_database_stop_place_equipment_places_aggregate: StopsDatabaseStopPlaceEquipmentPlacesAggregate;
  /** fetch data from the table in a streaming manner: "stop_place_equipment_places" */
  stops_database_stop_place_equipment_places_stream: Array<StopsDatabaseStopPlaceEquipmentPlaces>;
  /** fetch data from the table: "stop_place_key_values" */
  stops_database_stop_place_key_values: Array<StopsDatabaseStopPlaceKeyValues>;
  /** fetch aggregated fields from the table: "stop_place_key_values" */
  stops_database_stop_place_key_values_aggregate: StopsDatabaseStopPlaceKeyValuesAggregate;
  /** fetch data from the table: "stop_place_key_values" using primary key columns */
  stops_database_stop_place_key_values_by_pk?: Maybe<StopsDatabaseStopPlaceKeyValues>;
  /** fetch data from the table in a streaming manner: "stop_place_key_values" */
  stops_database_stop_place_key_values_stream: Array<StopsDatabaseStopPlaceKeyValues>;
  /** fetch data from the table: "stop_place_quays" */
  stops_database_stop_place_quays: Array<StopsDatabaseStopPlaceQuays>;
  /** fetch aggregated fields from the table: "stop_place_quays" */
  stops_database_stop_place_quays_aggregate: StopsDatabaseStopPlaceQuaysAggregate;
  /** fetch data from the table: "stop_place_quays" using primary key columns */
  stops_database_stop_place_quays_by_pk?: Maybe<StopsDatabaseStopPlaceQuays>;
  /** fetch data from the table in a streaming manner: "stop_place_quays" */
  stops_database_stop_place_quays_stream: Array<StopsDatabaseStopPlaceQuays>;
  /** fetch data from the table in a streaming manner: "stop_place" */
  stops_database_stop_place_stream: Array<StopsDatabaseStopPlace>;
  /** fetch data from the table: "stop_place_tariff_zones" */
  stops_database_stop_place_tariff_zones: Array<StopsDatabaseStopPlaceTariffZones>;
  /** fetch aggregated fields from the table: "stop_place_tariff_zones" */
  stops_database_stop_place_tariff_zones_aggregate: StopsDatabaseStopPlaceTariffZonesAggregate;
  /** fetch data from the table in a streaming manner: "stop_place_tariff_zones" */
  stops_database_stop_place_tariff_zones_stream: Array<StopsDatabaseStopPlaceTariffZones>;
  /** fetch data from the table: "tag" */
  stops_database_tag: Array<StopsDatabaseTag>;
  /** fetch aggregated fields from the table: "tag" */
  stops_database_tag_aggregate: StopsDatabaseTagAggregate;
  /** fetch data from the table: "tag" using primary key columns */
  stops_database_tag_by_pk?: Maybe<StopsDatabaseTag>;
  /** fetch data from the table in a streaming manner: "tag" */
  stops_database_tag_stream: Array<StopsDatabaseTag>;
  /** fetch data from the table: "tariff_zone" */
  stops_database_tariff_zone: Array<StopsDatabaseTariffZone>;
  /** fetch aggregated fields from the table: "tariff_zone" */
  stops_database_tariff_zone_aggregate: StopsDatabaseTariffZoneAggregate;
  /** fetch data from the table: "tariff_zone" using primary key columns */
  stops_database_tariff_zone_by_pk?: Maybe<StopsDatabaseTariffZone>;
  /** fetch data from the table: "tariff_zone_key_values" */
  stops_database_tariff_zone_key_values: Array<StopsDatabaseTariffZoneKeyValues>;
  /** fetch aggregated fields from the table: "tariff_zone_key_values" */
  stops_database_tariff_zone_key_values_aggregate: StopsDatabaseTariffZoneKeyValuesAggregate;
  /** fetch data from the table: "tariff_zone_key_values" using primary key columns */
  stops_database_tariff_zone_key_values_by_pk?: Maybe<StopsDatabaseTariffZoneKeyValues>;
  /** fetch data from the table in a streaming manner: "tariff_zone_key_values" */
  stops_database_tariff_zone_key_values_stream: Array<StopsDatabaseTariffZoneKeyValues>;
  /** fetch data from the table in a streaming manner: "tariff_zone" */
  stops_database_tariff_zone_stream: Array<StopsDatabaseTariffZone>;
  /** fetch data from the table: "topographic_place" */
  stops_database_topographic_place: Array<StopsDatabaseTopographicPlace>;
  /** fetch aggregated fields from the table: "topographic_place" */
  stops_database_topographic_place_aggregate: StopsDatabaseTopographicPlaceAggregate;
  /** fetch data from the table: "topographic_place" using primary key columns */
  stops_database_topographic_place_by_pk?: Maybe<StopsDatabaseTopographicPlace>;
  /** fetch data from the table: "topographic_place_key_values" */
  stops_database_topographic_place_key_values: Array<StopsDatabaseTopographicPlaceKeyValues>;
  /** fetch aggregated fields from the table: "topographic_place_key_values" */
  stops_database_topographic_place_key_values_aggregate: StopsDatabaseTopographicPlaceKeyValuesAggregate;
  /** fetch data from the table: "topographic_place_key_values" using primary key columns */
  stops_database_topographic_place_key_values_by_pk?: Maybe<StopsDatabaseTopographicPlaceKeyValues>;
  /** fetch data from the table in a streaming manner: "topographic_place_key_values" */
  stops_database_topographic_place_key_values_stream: Array<StopsDatabaseTopographicPlaceKeyValues>;
  /** fetch data from the table in a streaming manner: "topographic_place" */
  stops_database_topographic_place_stream: Array<StopsDatabaseTopographicPlace>;
  /** fetch data from the table: "value" */
  stops_database_value: Array<StopsDatabaseValue>;
  /** fetch aggregated fields from the table: "value" */
  stops_database_value_aggregate: StopsDatabaseValueAggregate;
  /** fetch data from the table: "value" using primary key columns */
  stops_database_value_by_pk?: Maybe<StopsDatabaseValue>;
  /** fetch data from the table: "value_items" */
  stops_database_value_items: Array<StopsDatabaseValueItems>;
  /** fetch aggregated fields from the table: "value_items" */
  stops_database_value_items_aggregate: StopsDatabaseValueItemsAggregate;
  /** fetch data from the table in a streaming manner: "value_items" */
  stops_database_value_items_stream: Array<StopsDatabaseValueItems>;
  /** fetch data from the table in a streaming manner: "value" */
  stops_database_value_stream: Array<StopsDatabaseValue>;
};

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseAccessSpaceSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseAccessSpaceOrderBy>>;
    where?: InputMaybe<StopsDatabaseAccessSpaceBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseAccessSpaceSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseAccessSpaceOrderBy>>;
    where?: InputMaybe<StopsDatabaseAccessSpaceBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceAlternativeNamesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessSpaceAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseAccessSpaceAlternativeNamesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceAlternativeNamesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessSpaceAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseAccessSpaceAlternativeNamesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceAlternativeNamesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceCheckConstraintsArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessSpaceCheckConstraintsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseAccessSpaceCheckConstraintsOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceCheckConstraintsAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessSpaceCheckConstraintsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseAccessSpaceCheckConstraintsOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceCheckConstraintsStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceEquipmentPlacesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessSpaceEquipmentPlacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseAccessSpaceEquipmentPlacesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceEquipmentPlacesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessSpaceEquipmentPlacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseAccessSpaceEquipmentPlacesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceEquipmentPlacesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessSpaceKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseAccessSpaceKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessSpaceKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseAccessSpaceKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceKeyValuesByPkArgs =
  {
    access_space_id: Scalars['bigint'];
    key_values_key: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceKeyValuesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseAccessSpaceKeyValuesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseAccessSpaceStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseAccessSpaceBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessibilityAssessmentArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessibilityAssessmentSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseAccessibilityAssessmentOrderBy>>;
    where?: InputMaybe<StopsDatabaseAccessibilityAssessmentBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessibilityAssessmentAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessibilityAssessmentSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseAccessibilityAssessmentOrderBy>>;
    where?: InputMaybe<StopsDatabaseAccessibilityAssessmentBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessibilityAssessmentByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessibilityAssessmentLimitationsArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessibilityAssessmentLimitationsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseAccessibilityAssessmentLimitationsOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessibilityAssessmentLimitationsAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessibilityAssessmentLimitationsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseAccessibilityAssessmentLimitationsOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessibilityAssessmentLimitationsStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessibilityAssessmentStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseAccessibilityAssessmentStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseAccessibilityAssessmentBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessibilityLimitationArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessibilityLimitationSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseAccessibilityLimitationOrderBy>>;
    where?: InputMaybe<StopsDatabaseAccessibilityLimitationBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessibilityLimitationAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseAccessibilityLimitationSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseAccessibilityLimitationOrderBy>>;
    where?: InputMaybe<StopsDatabaseAccessibilityLimitationBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessibilityLimitationByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessibilityLimitationStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseAccessibilityLimitationStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseAccessibilityLimitationBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAlternativeNameArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseAlternativeNameSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseAlternativeNameOrderBy>>;
    where?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAlternativeNameAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseAlternativeNameSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseAlternativeNameOrderBy>>;
    where?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAlternativeNameByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAlternativeNameStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseAlternativeNameStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseBoardingPositionSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseBoardingPositionOrderBy>>;
    where?: InputMaybe<StopsDatabaseBoardingPositionBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseBoardingPositionSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseBoardingPositionOrderBy>>;
    where?: InputMaybe<StopsDatabaseBoardingPositionBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionAlternativeNamesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseBoardingPositionAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseBoardingPositionAlternativeNamesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionAlternativeNamesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseBoardingPositionAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseBoardingPositionAlternativeNamesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionAlternativeNamesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionCheckConstraintsArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseBoardingPositionCheckConstraintsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseBoardingPositionCheckConstraintsOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionCheckConstraintsAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseBoardingPositionCheckConstraintsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseBoardingPositionCheckConstraintsOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionCheckConstraintsStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionEquipmentPlacesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseBoardingPositionEquipmentPlacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseBoardingPositionEquipmentPlacesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionEquipmentPlacesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseBoardingPositionEquipmentPlacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseBoardingPositionEquipmentPlacesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionEquipmentPlacesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseBoardingPositionKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseBoardingPositionKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseBoardingPositionKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseBoardingPositionKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionKeyValuesByPkArgs =
  {
    boarding_position_id: Scalars['bigint'];
    key_values_key: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionKeyValuesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseBoardingPositionKeyValuesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseBoardingPositionStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseBoardingPositionBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseCheckConstraintArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseCheckConstraintSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseCheckConstraintOrderBy>>;
    where?: InputMaybe<StopsDatabaseCheckConstraintBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseCheckConstraintAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseCheckConstraintSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseCheckConstraintOrderBy>>;
    where?: InputMaybe<StopsDatabaseCheckConstraintBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseCheckConstraintByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseCheckConstraintKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseCheckConstraintKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseCheckConstraintKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseCheckConstraintKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseCheckConstraintKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseCheckConstraintKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseCheckConstraintKeyValuesByPkArgs =
  {
    check_constraint_id: Scalars['bigint'];
    key_values_key: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseCheckConstraintKeyValuesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseCheckConstraintKeyValuesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseCheckConstraintStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseCheckConstraintStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseCheckConstraintBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseDestinationDisplayViewArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseDestinationDisplayViewSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseDestinationDisplayViewOrderBy>>;
    where?: InputMaybe<StopsDatabaseDestinationDisplayViewBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseDestinationDisplayViewAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseDestinationDisplayViewSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseDestinationDisplayViewOrderBy>>;
    where?: InputMaybe<StopsDatabaseDestinationDisplayViewBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseDestinationDisplayViewByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseDestinationDisplayViewStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseDestinationDisplayViewStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseDestinationDisplayViewBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPlaceArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseEquipmentPlaceSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseEquipmentPlaceOrderBy>>;
    where?: InputMaybe<StopsDatabaseEquipmentPlaceBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPlaceAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseEquipmentPlaceSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseEquipmentPlaceOrderBy>>;
    where?: InputMaybe<StopsDatabaseEquipmentPlaceBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPlaceByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPlaceEquipmentPositionsArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseEquipmentPlaceEquipmentPositionsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseEquipmentPlaceEquipmentPositionsOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPlaceEquipmentPositionsAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseEquipmentPlaceEquipmentPositionsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseEquipmentPlaceEquipmentPositionsOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPlaceEquipmentPositionsStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPlaceKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseEquipmentPlaceKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseEquipmentPlaceKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPlaceKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseEquipmentPlaceKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseEquipmentPlaceKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPlaceKeyValuesByPkArgs =
  {
    equipment_place_id: Scalars['bigint'];
    key_values_key: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPlaceKeyValuesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPlaceStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseEquipmentPlaceStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseEquipmentPlaceBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPositionArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseEquipmentPositionSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseEquipmentPositionOrderBy>>;
    where?: InputMaybe<StopsDatabaseEquipmentPositionBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPositionAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseEquipmentPositionSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseEquipmentPositionOrderBy>>;
    where?: InputMaybe<StopsDatabaseEquipmentPositionBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPositionByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPositionKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseEquipmentPositionKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseEquipmentPositionKeyValuesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPositionKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseEquipmentPositionKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseEquipmentPositionKeyValuesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPositionKeyValuesByPkArgs =
  {
    equipment_position_id: Scalars['bigint'];
    key_values_key: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPositionKeyValuesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseEquipmentPositionKeyValuesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPositionStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseEquipmentPositionStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseEquipmentPositionBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseExportJobArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseExportJobSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseExportJobOrderBy>>;
  where?: InputMaybe<StopsDatabaseExportJobBoolExp>;
};

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseExportJobAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseExportJobSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseExportJobOrderBy>>;
    where?: InputMaybe<StopsDatabaseExportJobBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseExportJobByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseExportJobStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseExportJobStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseExportJobBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseFareZoneSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseFareZoneOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneBoolExp>;
};

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseFareZoneSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseFareZoneOrderBy>>;
    where?: InputMaybe<StopsDatabaseFareZoneBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneKeyValuesArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseFareZoneKeyValuesSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseFareZoneKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseFareZoneKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseFareZoneKeyValuesSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseFareZoneKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseFareZoneKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneKeyValuesByPkArgs =
  {
    fare_zone_id: Scalars['bigint'];
    key_values_key: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneKeyValuesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseFareZoneKeyValuesStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseFareZoneKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneMembersArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseFareZoneMembersSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseFareZoneMembersOrderBy>>;
    where?: InputMaybe<StopsDatabaseFareZoneMembersBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneMembersAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseFareZoneMembersSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseFareZoneMembersOrderBy>>;
    where?: InputMaybe<StopsDatabaseFareZoneMembersBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneMembersStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseFareZoneMembersStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseFareZoneMembersBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneNeighboursArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseFareZoneNeighboursSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseFareZoneNeighboursOrderBy>>;
    where?: InputMaybe<StopsDatabaseFareZoneNeighboursBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneNeighboursAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseFareZoneNeighboursSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseFareZoneNeighboursOrderBy>>;
    where?: InputMaybe<StopsDatabaseFareZoneNeighboursBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneNeighboursStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseFareZoneNeighboursStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseFareZoneNeighboursBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseFareZoneStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseFareZoneBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGeographyColumnsArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseGeographyColumnsSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseGeographyColumnsOrderBy>>;
    where?: InputMaybe<StopsDatabaseGeographyColumnsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGeographyColumnsAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseGeographyColumnsSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseGeographyColumnsOrderBy>>;
    where?: InputMaybe<StopsDatabaseGeographyColumnsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGeographyColumnsStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseGeographyColumnsStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseGeographyColumnsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGeometryColumnsArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseGeometryColumnsSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseGeometryColumnsOrderBy>>;
    where?: InputMaybe<StopsDatabaseGeometryColumnsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGeometryColumnsAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseGeometryColumnsSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseGeometryColumnsOrderBy>>;
    where?: InputMaybe<StopsDatabaseGeometryColumnsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGeometryColumnsStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseGeometryColumnsStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseGeometryColumnsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseGroupOfStopPlacesSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseGroupOfStopPlacesOrderBy>>;
    where?: InputMaybe<StopsDatabaseGroupOfStopPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseGroupOfStopPlacesSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseGroupOfStopPlacesOrderBy>>;
    where?: InputMaybe<StopsDatabaseGroupOfStopPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesAlternativeNamesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesAlternativeNamesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesAlternativeNamesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesAlternativeNamesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesAlternativeNamesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesKeyValuesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesKeyValuesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesKeyValuesByPkArgs =
  {
    group_of_stop_places_id: Scalars['bigint'];
    key_values_key: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesKeyValuesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesMembersArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesMembersSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseGroupOfStopPlacesMembersOrderBy>>;
    where?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesMembersAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfStopPlacesMembersSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseGroupOfStopPlacesMembersOrderBy>>;
    where?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesMembersStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseGroupOfStopPlacesMembersStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseGroupOfStopPlacesStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseGroupOfStopPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfTariffZonesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfTariffZonesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseGroupOfTariffZonesOrderBy>>;
    where?: InputMaybe<StopsDatabaseGroupOfTariffZonesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfTariffZonesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfTariffZonesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseGroupOfTariffZonesOrderBy>>;
    where?: InputMaybe<StopsDatabaseGroupOfTariffZonesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfTariffZonesByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfTariffZonesKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfTariffZonesKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseGroupOfTariffZonesKeyValuesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfTariffZonesKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfTariffZonesKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseGroupOfTariffZonesKeyValuesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfTariffZonesKeyValuesByPkArgs =
  {
    group_of_tariff_zones_id: Scalars['bigint'];
    key_values_key: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfTariffZonesKeyValuesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfTariffZonesMembersArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfTariffZonesMembersSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseGroupOfTariffZonesMembersOrderBy>>;
    where?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfTariffZonesMembersAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseGroupOfTariffZonesMembersSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseGroupOfTariffZonesMembersOrderBy>>;
    where?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfTariffZonesMembersByPkArgs =
  {
    group_of_tariff_zones_id: Scalars['bigint'];
    ref: Scalars['String'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfTariffZonesMembersStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseGroupOfTariffZonesMembersStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfTariffZonesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseGroupOfTariffZonesStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseGroupOfTariffZonesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseIdGeneratorArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseIdGeneratorSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseIdGeneratorOrderBy>>;
    where?: InputMaybe<StopsDatabaseIdGeneratorBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseIdGeneratorAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseIdGeneratorSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseIdGeneratorOrderBy>>;
    where?: InputMaybe<StopsDatabaseIdGeneratorBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseIdGeneratorStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseIdGeneratorStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseIdGeneratorBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInstalledEquipmentArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseInstalledEquipmentOrderBy>>;
    where?: InputMaybe<StopsDatabaseInstalledEquipmentBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInstalledEquipmentAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseInstalledEquipmentOrderBy>>;
    where?: InputMaybe<StopsDatabaseInstalledEquipmentBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInstalledEquipmentStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseInstalledEquipmentStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseInstalledEquipmentBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInstalledEquipmentVersionStructureArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentVersionStructureSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentVersionStructureOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInstalledEquipmentVersionStructureAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentVersionStructureSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentVersionStructureOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInstalledEquipmentVersionStructureByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInstalledEquipmentVersionStructureStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseLevelArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseLevelSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseLevelOrderBy>>;
  where?: InputMaybe<StopsDatabaseLevelBoolExp>;
};

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseLevelAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseLevelSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseLevelOrderBy>>;
    where?: InputMaybe<StopsDatabaseLevelBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseLevelByPkArgs = {
  id: Scalars['bigint'];
};

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseLevelKeyValuesArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseLevelKeyValuesSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseLevelKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseLevelKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseLevelKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseLevelKeyValuesSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseLevelKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseLevelKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseLevelKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    level_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseLevelKeyValuesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseLevelKeyValuesStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseLevelKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseLevelStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseLevelStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseLevelBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseMultilingualStringEntityArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseMultilingualStringEntitySelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseMultilingualStringEntityOrderBy>>;
    where?: InputMaybe<StopsDatabaseMultilingualStringEntityBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseMultilingualStringEntityAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseMultilingualStringEntitySelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseMultilingualStringEntityOrderBy>>;
    where?: InputMaybe<StopsDatabaseMultilingualStringEntityBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseMultilingualStringEntityByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseMultilingualStringEntityStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseMultilingualStringEntityStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseMultilingualStringEntityBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseNavigationPathArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseNavigationPathSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseNavigationPathOrderBy>>;
    where?: InputMaybe<StopsDatabaseNavigationPathBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseNavigationPathAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseNavigationPathSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseNavigationPathOrderBy>>;
    where?: InputMaybe<StopsDatabaseNavigationPathBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseNavigationPathStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseNavigationPathStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseNavigationPathBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseParkingSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseParkingOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingBoolExp>;
};

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAdjacentSitesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingAdjacentSitesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingAdjacentSitesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingAdjacentSitesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAdjacentSitesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingAdjacentSitesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingAdjacentSitesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingAdjacentSitesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAdjacentSitesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseParkingAdjacentSitesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseParkingAdjacentSitesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseParkingSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAlternativeNamesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingAlternativeNamesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAlternativeNamesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingAlternativeNamesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAlternativeNamesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseParkingAlternativeNamesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseParkingAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseParkingAreaSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingAreaOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingAreaBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseParkingAreaSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingAreaOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingAreaBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaAlternativeNamesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingAreaAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseParkingAreaAlternativeNamesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaAlternativeNamesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingAreaAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseParkingAreaAlternativeNamesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaAlternativeNamesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseParkingAreaAlternativeNamesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaCheckConstraintsArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingAreaCheckConstraintsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseParkingAreaCheckConstraintsOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaCheckConstraintsAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingAreaCheckConstraintsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseParkingAreaCheckConstraintsOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaCheckConstraintsStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseParkingAreaCheckConstraintsStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaEquipmentPlacesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingAreaEquipmentPlacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseParkingAreaEquipmentPlacesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaEquipmentPlacesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingAreaEquipmentPlacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseParkingAreaEquipmentPlacesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaEquipmentPlacesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingAreaKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingAreaKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingAreaKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingAreaKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingAreaKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingAreaKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    parking_area_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaKeyValuesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseParkingAreaKeyValuesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseParkingAreaKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseParkingAreaStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseParkingAreaBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingCapacityArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseParkingCapacitySelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingCapacityOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingCapacityBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingCapacityAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseParkingCapacitySelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingCapacityOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingCapacityBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingCapacityByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingCapacityStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseParkingCapacityStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseParkingCapacityBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingEquipmentPlacesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingEquipmentPlacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingEquipmentPlacesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingEquipmentPlacesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingEquipmentPlacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingEquipmentPlacesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingEquipmentPlacesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseParkingEquipmentPlacesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseParkingEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingKeyValuesArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseParkingKeyValuesSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseParkingKeyValuesSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    parking_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingKeyValuesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseParkingKeyValuesStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseParkingKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingParkingAreasArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingParkingAreasSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingParkingAreasOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingParkingAreasBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingParkingAreasAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingParkingAreasSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingParkingAreasOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingParkingAreasBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingParkingAreasStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseParkingParkingAreasStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseParkingParkingAreasBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingParkingPaymentProcessArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingParkingPaymentProcessSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseParkingParkingPaymentProcessOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingParkingPaymentProcessAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingParkingPaymentProcessSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseParkingParkingPaymentProcessOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingParkingPaymentProcessStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseParkingParkingPaymentProcessStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingParkingPropertiesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingParkingPropertiesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingParkingPropertiesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingParkingPropertiesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingParkingPropertiesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingParkingPropertiesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingParkingPropertiesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingParkingPropertiesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingParkingPropertiesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseParkingParkingPropertiesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseParkingParkingPropertiesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingParkingVehicleTypesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingParkingVehicleTypesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseParkingParkingVehicleTypesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingParkingVehicleTypesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingParkingVehicleTypesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseParkingParkingVehicleTypesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingParkingVehicleTypesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseParkingParkingVehicleTypesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingPropertiesArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseParkingPropertiesSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingPropertiesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingPropertiesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingPropertiesAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseParkingPropertiesSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingPropertiesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingPropertiesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingPropertiesByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingPropertiesParkingUserTypesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingPropertiesParkingUserTypesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseParkingPropertiesParkingUserTypesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseParkingPropertiesParkingUserTypesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingPropertiesParkingUserTypesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingPropertiesParkingUserTypesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabaseParkingPropertiesParkingUserTypesOrderBy>
    >;
    where?: InputMaybe<StopsDatabaseParkingPropertiesParkingUserTypesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingPropertiesParkingUserTypesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseParkingPropertiesParkingUserTypesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseParkingPropertiesParkingUserTypesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingPropertiesSpacesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingPropertiesSpacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingPropertiesSpacesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingPropertiesSpacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingPropertiesSpacesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseParkingPropertiesSpacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseParkingPropertiesSpacesOrderBy>>;
    where?: InputMaybe<StopsDatabaseParkingPropertiesSpacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingPropertiesSpacesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseParkingPropertiesSpacesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseParkingPropertiesSpacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingPropertiesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseParkingPropertiesStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseParkingPropertiesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseParkingStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseParkingBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathJunctionArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabasePathJunctionSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabasePathJunctionOrderBy>>;
    where?: InputMaybe<StopsDatabasePathJunctionBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathJunctionAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabasePathJunctionSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabasePathJunctionOrderBy>>;
    where?: InputMaybe<StopsDatabasePathJunctionBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathJunctionByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathJunctionKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabasePathJunctionKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabasePathJunctionKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabasePathJunctionKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathJunctionKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabasePathJunctionKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabasePathJunctionKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabasePathJunctionKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathJunctionKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    path_junction_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathJunctionKeyValuesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabasePathJunctionKeyValuesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabasePathJunctionKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathJunctionStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabasePathJunctionStreamCursorInput>>;
    where?: InputMaybe<StopsDatabasePathJunctionBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathLinkArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabasePathLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabasePathLinkOrderBy>>;
  where?: InputMaybe<StopsDatabasePathLinkBoolExp>;
};

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathLinkAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabasePathLinkSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabasePathLinkOrderBy>>;
    where?: InputMaybe<StopsDatabasePathLinkBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathLinkByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathLinkEndArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabasePathLinkEndSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabasePathLinkEndOrderBy>>;
    where?: InputMaybe<StopsDatabasePathLinkEndBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathLinkEndAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabasePathLinkEndSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabasePathLinkEndOrderBy>>;
    where?: InputMaybe<StopsDatabasePathLinkEndBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathLinkEndByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathLinkEndStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabasePathLinkEndStreamCursorInput>>;
    where?: InputMaybe<StopsDatabasePathLinkEndBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathLinkKeyValuesArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabasePathLinkKeyValuesSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabasePathLinkKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabasePathLinkKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathLinkKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabasePathLinkKeyValuesSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabasePathLinkKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabasePathLinkKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathLinkKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    path_link_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathLinkKeyValuesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabasePathLinkKeyValuesStreamCursorInput>>;
    where?: InputMaybe<StopsDatabasePathLinkKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathLinkStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabasePathLinkStreamCursorInput>>;
    where?: InputMaybe<StopsDatabasePathLinkBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePersistablePolygonArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabasePersistablePolygonSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabasePersistablePolygonOrderBy>>;
    where?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePersistablePolygonAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabasePersistablePolygonSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabasePersistablePolygonOrderBy>>;
    where?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePersistablePolygonByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePersistablePolygonStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabasePersistablePolygonStreamCursorInput>>;
    where?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePurposeOfGroupingArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabasePurposeOfGroupingSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabasePurposeOfGroupingOrderBy>>;
    where?: InputMaybe<StopsDatabasePurposeOfGroupingBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePurposeOfGroupingAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabasePurposeOfGroupingSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabasePurposeOfGroupingOrderBy>>;
    where?: InputMaybe<StopsDatabasePurposeOfGroupingBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePurposeOfGroupingByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePurposeOfGroupingKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabasePurposeOfGroupingKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabasePurposeOfGroupingKeyValuesOrderBy>
    >;
    where?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePurposeOfGroupingKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabasePurposeOfGroupingKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<StopsDatabasePurposeOfGroupingKeyValuesOrderBy>
    >;
    where?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePurposeOfGroupingKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    purpose_of_grouping_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePurposeOfGroupingKeyValuesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePurposeOfGroupingStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabasePurposeOfGroupingStreamCursorInput>>;
    where?: InputMaybe<StopsDatabasePurposeOfGroupingBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseQuaySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseQuayOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayBoolExp>;
};

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseQuaySelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseQuayOrderBy>>;
    where?: InputMaybe<StopsDatabaseQuayBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayAlternativeNamesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseQuayAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseQuayAlternativeNamesOrderBy>>;
    where?: InputMaybe<StopsDatabaseQuayAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayAlternativeNamesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseQuayAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseQuayAlternativeNamesOrderBy>>;
    where?: InputMaybe<StopsDatabaseQuayAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayAlternativeNamesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseQuayAlternativeNamesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseQuayAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayBoardingPositionsArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseQuayBoardingPositionsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseQuayBoardingPositionsOrderBy>>;
    where?: InputMaybe<StopsDatabaseQuayBoardingPositionsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayBoardingPositionsAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseQuayBoardingPositionsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseQuayBoardingPositionsOrderBy>>;
    where?: InputMaybe<StopsDatabaseQuayBoardingPositionsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayBoardingPositionsStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseQuayBoardingPositionsStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseQuayBoardingPositionsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayByPkArgs = {
  id: Scalars['bigint'];
};

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayCheckConstraintsArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseQuayCheckConstraintsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseQuayCheckConstraintsOrderBy>>;
    where?: InputMaybe<StopsDatabaseQuayCheckConstraintsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayCheckConstraintsAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseQuayCheckConstraintsSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseQuayCheckConstraintsOrderBy>>;
    where?: InputMaybe<StopsDatabaseQuayCheckConstraintsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayCheckConstraintsStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseQuayCheckConstraintsStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseQuayCheckConstraintsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayEquipmentPlacesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseQuayEquipmentPlacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseQuayEquipmentPlacesOrderBy>>;
    where?: InputMaybe<StopsDatabaseQuayEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayEquipmentPlacesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseQuayEquipmentPlacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseQuayEquipmentPlacesOrderBy>>;
    where?: InputMaybe<StopsDatabaseQuayEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayEquipmentPlacesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseQuayEquipmentPlacesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseQuayEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayKeyValuesArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseQuayKeyValuesSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseQuayKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseQuayKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseQuayKeyValuesSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseQuayKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseQuayKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    quay_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayKeyValuesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseQuayKeyValuesStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseQuayKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseQuayStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseQuayBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseSchemaVersionArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseSchemaVersionSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseSchemaVersionOrderBy>>;
    where?: InputMaybe<StopsDatabaseSchemaVersionBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseSchemaVersionAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseSchemaVersionSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseSchemaVersionOrderBy>>;
    where?: InputMaybe<StopsDatabaseSchemaVersionBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseSchemaVersionByPkArgs =
  {
    installed_rank: Scalars['Int'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseSchemaVersionStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseSchemaVersionStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseSchemaVersionBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseSpatialRefSysArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseSpatialRefSysSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseSpatialRefSysOrderBy>>;
    where?: InputMaybe<StopsDatabaseSpatialRefSysBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseSpatialRefSysAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseSpatialRefSysSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseSpatialRefSysOrderBy>>;
    where?: InputMaybe<StopsDatabaseSpatialRefSysBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseSpatialRefSysByPkArgs =
  {
    srid: Scalars['Int'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseSpatialRefSysStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseSpatialRefSysStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseSpatialRefSysBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseStopPlaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseStopPlaceOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceBoolExp>;
};

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceAccessSpacesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseStopPlaceAccessSpacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceAccessSpacesOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceAccessSpacesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseStopPlaceAccessSpacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceAccessSpacesOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceAccessSpacesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseStopPlaceAccessSpacesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceAdjacentSitesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseStopPlaceAdjacentSitesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceAdjacentSitesOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceAdjacentSitesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceAdjacentSitesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseStopPlaceAdjacentSitesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceAdjacentSitesOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceAdjacentSitesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceAdjacentSitesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseStopPlaceAdjacentSitesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseStopPlaceAdjacentSitesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseStopPlaceSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceAlternativeNamesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseStopPlaceAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceAlternativeNamesOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceAlternativeNamesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseStopPlaceAlternativeNamesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceAlternativeNamesOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceAlternativeNamesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseStopPlaceAlternativeNamesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceChildrenArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseStopPlaceChildrenSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceChildrenOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceChildrenAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseStopPlaceChildrenSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceChildrenOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceChildrenByPkArgs =
  {
    children_id: Scalars['bigint'];
    stop_place_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceChildrenStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseStopPlaceChildrenStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceEquipmentPlacesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseStopPlaceEquipmentPlacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceEquipmentPlacesOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceEquipmentPlacesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseStopPlaceEquipmentPlacesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceEquipmentPlacesOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceEquipmentPlacesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseStopPlaceKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseStopPlaceKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    stop_place_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceKeyValuesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseStopPlaceKeyValuesStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseStopPlaceKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceQuaysArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseStopPlaceQuaysSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceQuaysOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceQuaysBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceQuaysAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseStopPlaceQuaysSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceQuaysOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceQuaysBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceQuaysByPkArgs =
  {
    quays_id: Scalars['bigint'];
    stop_place_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceQuaysStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseStopPlaceQuaysStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseStopPlaceQuaysBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseStopPlaceStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseStopPlaceBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceTariffZonesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseStopPlaceTariffZonesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceTariffZonesOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceTariffZonesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceTariffZonesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseStopPlaceTariffZonesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseStopPlaceTariffZonesOrderBy>>;
    where?: InputMaybe<StopsDatabaseStopPlaceTariffZonesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceTariffZonesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseStopPlaceTariffZonesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseStopPlaceTariffZonesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTagArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseTagSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseTagOrderBy>>;
  where?: InputMaybe<StopsDatabaseTagBoolExp>;
};

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTagAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseTagSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseTagOrderBy>>;
    where?: InputMaybe<StopsDatabaseTagBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTagByPkArgs = {
  name: Scalars['String'];
  netex_reference: Scalars['String'];
};

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTagStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<StopsDatabaseTagStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseTagBoolExp>;
};

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTariffZoneArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseTariffZoneSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseTariffZoneOrderBy>>;
    where?: InputMaybe<StopsDatabaseTariffZoneBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTariffZoneAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseTariffZoneSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseTariffZoneOrderBy>>;
    where?: InputMaybe<StopsDatabaseTariffZoneBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTariffZoneByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTariffZoneKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseTariffZoneKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseTariffZoneKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseTariffZoneKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTariffZoneKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseTariffZoneKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseTariffZoneKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseTariffZoneKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTariffZoneKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    tariff_zone_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTariffZoneKeyValuesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseTariffZoneKeyValuesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseTariffZoneKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTariffZoneStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseTariffZoneStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseTariffZoneBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTopographicPlaceArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseTopographicPlaceSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseTopographicPlaceOrderBy>>;
    where?: InputMaybe<StopsDatabaseTopographicPlaceBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTopographicPlaceAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseTopographicPlaceSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseTopographicPlaceOrderBy>>;
    where?: InputMaybe<StopsDatabaseTopographicPlaceBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTopographicPlaceByPkArgs =
  {
    id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTopographicPlaceKeyValuesArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseTopographicPlaceKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseTopographicPlaceKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTopographicPlaceKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseTopographicPlaceKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseTopographicPlaceKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTopographicPlaceKeyValuesByPkArgs =
  {
    key_values_key: Scalars['String'];
    topographic_place_id: Scalars['bigint'];
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTopographicPlaceKeyValuesStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<StopsDatabaseTopographicPlaceKeyValuesStreamCursorInput>
    >;
    where?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTopographicPlaceStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseTopographicPlaceStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseTopographicPlaceBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseValueArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseValueSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseValueOrderBy>>;
  where?: InputMaybe<StopsDatabaseValueBoolExp>;
};

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseValueAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseValueSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseValueOrderBy>>;
    where?: InputMaybe<StopsDatabaseValueBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseValueByPkArgs = {
  id: Scalars['bigint'];
};

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseValueItemsArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseValueItemsSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseValueItemsOrderBy>>;
    where?: InputMaybe<StopsDatabaseValueItemsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseValueItemsAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<StopsDatabaseValueItemsSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseValueItemsOrderBy>>;
    where?: InputMaybe<StopsDatabaseValueItemsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseValueItemsStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseValueItemsStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseValueItemsBoolExp>;
  };

export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseValueStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<StopsDatabaseValueStreamCursorInput>>;
    where?: InputMaybe<StopsDatabaseValueBoolExp>;
  };

/** columns and relationships of "tag" */
export type StopsDatabaseTag = {
  __typename?: 'stops_database_tag';
  comment?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  created_by?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  netex_reference: Scalars['String'];
  removed?: Maybe<Scalars['timestamp']>;
  removed_by?: Maybe<Scalars['String']>;
};

/** aggregated selection of "tag" */
export type StopsDatabaseTagAggregate = {
  __typename?: 'stops_database_tag_aggregate';
  aggregate?: Maybe<StopsDatabaseTagAggregateFields>;
  nodes: Array<StopsDatabaseTag>;
};

/** aggregate fields of "tag" */
export type StopsDatabaseTagAggregateFields = {
  __typename?: 'stops_database_tag_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseTagMaxFields>;
  min?: Maybe<StopsDatabaseTagMinFields>;
};

/** aggregate fields of "tag" */
export type StopsDatabaseTagAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseTagSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "tag". All fields are combined with a logical 'AND'. */
export type StopsDatabaseTagBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseTagBoolExp>>;
  _not?: InputMaybe<StopsDatabaseTagBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseTagBoolExp>>;
  comment?: InputMaybe<StringComparisonExp>;
  created?: InputMaybe<TimestampComparisonExp>;
  created_by?: InputMaybe<StringComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  netex_reference?: InputMaybe<StringComparisonExp>;
  removed?: InputMaybe<TimestampComparisonExp>;
  removed_by?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "tag" */
export enum StopsDatabaseTagConstraint {
  /** unique or primary key constraint on columns "netex_reference", "name" */
  TagPkey = 'tag_pkey',
}

/** input type for inserting data into table "tag" */
export type StopsDatabaseTagInsertInput = {
  comment?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  created_by?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  netex_reference?: InputMaybe<Scalars['String']>;
  removed?: InputMaybe<Scalars['timestamp']>;
  removed_by?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type StopsDatabaseTagMaxFields = {
  __typename?: 'stops_database_tag_max_fields';
  comment?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  created_by?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  netex_reference?: Maybe<Scalars['String']>;
  removed?: Maybe<Scalars['timestamp']>;
  removed_by?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseTagMinFields = {
  __typename?: 'stops_database_tag_min_fields';
  comment?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  created_by?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  netex_reference?: Maybe<Scalars['String']>;
  removed?: Maybe<Scalars['timestamp']>;
  removed_by?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "tag" */
export type StopsDatabaseTagMutationResponse = {
  __typename?: 'stops_database_tag_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseTag>;
};

/** on_conflict condition type for table "tag" */
export type StopsDatabaseTagOnConflict = {
  constraint: StopsDatabaseTagConstraint;
  update_columns?: Array<StopsDatabaseTagUpdateColumn>;
  where?: InputMaybe<StopsDatabaseTagBoolExp>;
};

/** Ordering options when selecting data from "tag". */
export type StopsDatabaseTagOrderBy = {
  comment?: InputMaybe<OrderBy>;
  created?: InputMaybe<OrderBy>;
  created_by?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  netex_reference?: InputMaybe<OrderBy>;
  removed?: InputMaybe<OrderBy>;
  removed_by?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: tag */
export type StopsDatabaseTagPkColumnsInput = {
  name: Scalars['String'];
  netex_reference: Scalars['String'];
};

/** select columns of table "tag" */
export enum StopsDatabaseTagSelectColumn {
  /** column name */
  Comment = 'comment',
  /** column name */
  Created = 'created',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Name = 'name',
  /** column name */
  NetexReference = 'netex_reference',
  /** column name */
  Removed = 'removed',
  /** column name */
  RemovedBy = 'removed_by',
}

/** input type for updating data in table "tag" */
export type StopsDatabaseTagSetInput = {
  comment?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  created_by?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  netex_reference?: InputMaybe<Scalars['String']>;
  removed?: InputMaybe<Scalars['timestamp']>;
  removed_by?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "tag" */
export type StopsDatabaseTagStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseTagStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseTagStreamCursorValueInput = {
  comment?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  created_by?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  netex_reference?: InputMaybe<Scalars['String']>;
  removed?: InputMaybe<Scalars['timestamp']>;
  removed_by?: InputMaybe<Scalars['String']>;
};

/** update columns of table "tag" */
export enum StopsDatabaseTagUpdateColumn {
  /** column name */
  Comment = 'comment',
  /** column name */
  Created = 'created',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Name = 'name',
  /** column name */
  NetexReference = 'netex_reference',
  /** column name */
  Removed = 'removed',
  /** column name */
  RemovedBy = 'removed_by',
}

export type StopsDatabaseTagUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseTagSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseTagBoolExp;
};

/** columns and relationships of "tariff_zone" */
export type StopsDatabaseTariffZone = {
  __typename?: 'stops_database_tariff_zone';
  centroid?: Maybe<Scalars['geometry']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id: Scalars['bigint'];
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  /** An object relationship */
  persistable_polygon?: Maybe<StopsDatabasePersistablePolygon>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  /** An array relationship */
  tariff_zone_key_values: Array<StopsDatabaseTariffZoneKeyValues>;
  /** An aggregate relationship */
  tariff_zone_key_values_aggregate: StopsDatabaseTariffZoneKeyValuesAggregate;
  to_date?: Maybe<Scalars['timestamp']>;
  version: Scalars['bigint'];
  version_comment?: Maybe<Scalars['String']>;
};

/** columns and relationships of "tariff_zone" */
export type StopsDatabaseTariffZoneTariffZoneKeyValuesArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseTariffZoneKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseTariffZoneKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseTariffZoneKeyValuesBoolExp>;
};

/** columns and relationships of "tariff_zone" */
export type StopsDatabaseTariffZoneTariffZoneKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseTariffZoneKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseTariffZoneKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseTariffZoneKeyValuesBoolExp>;
};

/** aggregated selection of "tariff_zone" */
export type StopsDatabaseTariffZoneAggregate = {
  __typename?: 'stops_database_tariff_zone_aggregate';
  aggregate?: Maybe<StopsDatabaseTariffZoneAggregateFields>;
  nodes: Array<StopsDatabaseTariffZone>;
};

/** aggregate fields of "tariff_zone" */
export type StopsDatabaseTariffZoneAggregateFields = {
  __typename?: 'stops_database_tariff_zone_aggregate_fields';
  avg?: Maybe<StopsDatabaseTariffZoneAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseTariffZoneMaxFields>;
  min?: Maybe<StopsDatabaseTariffZoneMinFields>;
  stddev?: Maybe<StopsDatabaseTariffZoneStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseTariffZoneStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseTariffZoneStddevSampFields>;
  sum?: Maybe<StopsDatabaseTariffZoneSumFields>;
  var_pop?: Maybe<StopsDatabaseTariffZoneVarPopFields>;
  var_samp?: Maybe<StopsDatabaseTariffZoneVarSampFields>;
  variance?: Maybe<StopsDatabaseTariffZoneVarianceFields>;
};

/** aggregate fields of "tariff_zone" */
export type StopsDatabaseTariffZoneAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseTariffZoneSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseTariffZoneAvgFields = {
  __typename?: 'stops_database_tariff_zone_avg_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "tariff_zone". All fields are combined with a logical 'AND'. */
export type StopsDatabaseTariffZoneBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseTariffZoneBoolExp>>;
  _not?: InputMaybe<StopsDatabaseTariffZoneBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseTariffZoneBoolExp>>;
  centroid?: InputMaybe<GeometryComparisonExp>;
  changed?: InputMaybe<TimestampComparisonExp>;
  changed_by?: InputMaybe<StringComparisonExp>;
  created?: InputMaybe<TimestampComparisonExp>;
  description_lang?: InputMaybe<StringComparisonExp>;
  description_value?: InputMaybe<StringComparisonExp>;
  from_date?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  name_lang?: InputMaybe<StringComparisonExp>;
  name_value?: InputMaybe<StringComparisonExp>;
  netex_id?: InputMaybe<StringComparisonExp>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  polygon_id?: InputMaybe<BigintComparisonExp>;
  private_code_type?: InputMaybe<StringComparisonExp>;
  private_code_value?: InputMaybe<StringComparisonExp>;
  short_name_lang?: InputMaybe<StringComparisonExp>;
  short_name_value?: InputMaybe<StringComparisonExp>;
  tariff_zone_key_values?: InputMaybe<StopsDatabaseTariffZoneKeyValuesBoolExp>;
  tariff_zone_key_values_aggregate?: InputMaybe<TariffZoneKeyValuesAggregateBoolExp>;
  to_date?: InputMaybe<TimestampComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
  version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "tariff_zone" */
export enum StopsDatabaseTariffZoneConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  TariffZoneNetexIdVersionConstraint = 'tariff_zone_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  TariffZonePkey = 'tariff_zone_pkey',
}

/** input type for incrementing numeric columns in table "tariff_zone" */
export type StopsDatabaseTariffZoneIncInput = {
  id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "tariff_zone" */
export type StopsDatabaseTariffZoneInsertInput = {
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonObjRelInsertInput>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  tariff_zone_key_values?: InputMaybe<StopsDatabaseTariffZoneKeyValuesArrRelInsertInput>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValues = {
  __typename?: 'stops_database_tariff_zone_key_values';
  key_values_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
  tariff_zone_id: Scalars['bigint'];
  /** An object relationship */
  value: StopsDatabaseValue;
};

/** aggregated selection of "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesAggregate = {
  __typename?: 'stops_database_tariff_zone_key_values_aggregate';
  aggregate?: Maybe<StopsDatabaseTariffZoneKeyValuesAggregateFields>;
  nodes: Array<StopsDatabaseTariffZoneKeyValues>;
};

/** aggregate fields of "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesAggregateFields = {
  __typename?: 'stops_database_tariff_zone_key_values_aggregate_fields';
  avg?: Maybe<StopsDatabaseTariffZoneKeyValuesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseTariffZoneKeyValuesMaxFields>;
  min?: Maybe<StopsDatabaseTariffZoneKeyValuesMinFields>;
  stddev?: Maybe<StopsDatabaseTariffZoneKeyValuesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseTariffZoneKeyValuesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseTariffZoneKeyValuesStddevSampFields>;
  sum?: Maybe<StopsDatabaseTariffZoneKeyValuesSumFields>;
  var_pop?: Maybe<StopsDatabaseTariffZoneKeyValuesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseTariffZoneKeyValuesVarSampFields>;
  variance?: Maybe<StopsDatabaseTariffZoneKeyValuesVarianceFields>;
};

/** aggregate fields of "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseTariffZoneKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseTariffZoneKeyValuesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseTariffZoneKeyValuesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseTariffZoneKeyValuesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseTariffZoneKeyValuesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseTariffZoneKeyValuesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseTariffZoneKeyValuesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseTariffZoneKeyValuesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseTariffZoneKeyValuesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseTariffZoneKeyValuesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseTariffZoneKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesArrRelInsertInput = {
  data: Array<StopsDatabaseTariffZoneKeyValuesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseTariffZoneKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseTariffZoneKeyValuesAvgFields = {
  __typename?: 'stops_database_tariff_zone_key_values_avg_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  tariff_zone_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesAvgOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  tariff_zone_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "tariff_zone_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseTariffZoneKeyValuesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseTariffZoneKeyValuesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseTariffZoneKeyValuesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseTariffZoneKeyValuesBoolExp>>;
  key_values_id?: InputMaybe<BigintComparisonExp>;
  key_values_key?: InputMaybe<StringComparisonExp>;
  tariff_zone_id?: InputMaybe<BigintComparisonExp>;
  value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "tariff_zone_key_values" */
export enum StopsDatabaseTariffZoneKeyValuesConstraint {
  /** unique or primary key constraint on columns "tariff_zone_id", "key_values_key" */
  TariffZoneKeyValuesPkey = 'tariff_zone_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkN3n61qrmgry87uoc7sho0nphm = 'uk_n3n61qrmgry87uoc7sho0nphm',
}

/** input type for incrementing numeric columns in table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesIncInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  tariff_zone_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesInsertInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  tariff_zone_id?: InputMaybe<Scalars['bigint']>;
  value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseTariffZoneKeyValuesMaxFields = {
  __typename?: 'stops_database_tariff_zone_key_values_max_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
  tariff_zone_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesMaxOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  tariff_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseTariffZoneKeyValuesMinFields = {
  __typename?: 'stops_database_tariff_zone_key_values_min_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
  tariff_zone_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesMinOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  tariff_zone_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesMutationResponse = {
  __typename?: 'stops_database_tariff_zone_key_values_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseTariffZoneKeyValues>;
};

/** on_conflict condition type for table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesOnConflict = {
  constraint: StopsDatabaseTariffZoneKeyValuesConstraint;
  update_columns?: Array<StopsDatabaseTariffZoneKeyValuesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseTariffZoneKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "tariff_zone_key_values". */
export type StopsDatabaseTariffZoneKeyValuesOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  tariff_zone_id?: InputMaybe<OrderBy>;
  value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: tariff_zone_key_values */
export type StopsDatabaseTariffZoneKeyValuesPkColumnsInput = {
  key_values_key: Scalars['String'];
  tariff_zone_id: Scalars['bigint'];
};

/** select columns of table "tariff_zone_key_values" */
export enum StopsDatabaseTariffZoneKeyValuesSelectColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  TariffZoneId = 'tariff_zone_id',
}

/** input type for updating data in table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesSetInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  tariff_zone_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseTariffZoneKeyValuesStddevFields = {
  __typename?: 'stops_database_tariff_zone_key_values_stddev_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  tariff_zone_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesStddevOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  tariff_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseTariffZoneKeyValuesStddevPopFields = {
  __typename?: 'stops_database_tariff_zone_key_values_stddev_pop_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  tariff_zone_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesStddevPopOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  tariff_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseTariffZoneKeyValuesStddevSampFields = {
  __typename?: 'stops_database_tariff_zone_key_values_stddev_samp_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  tariff_zone_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesStddevSampOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  tariff_zone_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseTariffZoneKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseTariffZoneKeyValuesStreamCursorValueInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  tariff_zone_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseTariffZoneKeyValuesSumFields = {
  __typename?: 'stops_database_tariff_zone_key_values_sum_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  tariff_zone_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesSumOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  tariff_zone_id?: InputMaybe<OrderBy>;
};

/** update columns of table "tariff_zone_key_values" */
export enum StopsDatabaseTariffZoneKeyValuesUpdateColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  TariffZoneId = 'tariff_zone_id',
}

export type StopsDatabaseTariffZoneKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseTariffZoneKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseTariffZoneKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseTariffZoneKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseTariffZoneKeyValuesVarPopFields = {
  __typename?: 'stops_database_tariff_zone_key_values_var_pop_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  tariff_zone_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesVarPopOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  tariff_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseTariffZoneKeyValuesVarSampFields = {
  __typename?: 'stops_database_tariff_zone_key_values_var_samp_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  tariff_zone_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesVarSampOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  tariff_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseTariffZoneKeyValuesVarianceFields = {
  __typename?: 'stops_database_tariff_zone_key_values_variance_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  tariff_zone_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesVarianceOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  tariff_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseTariffZoneMaxFields = {
  __typename?: 'stops_database_tariff_zone_max_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseTariffZoneMinFields = {
  __typename?: 'stops_database_tariff_zone_min_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "tariff_zone" */
export type StopsDatabaseTariffZoneMutationResponse = {
  __typename?: 'stops_database_tariff_zone_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseTariffZone>;
};

/** on_conflict condition type for table "tariff_zone" */
export type StopsDatabaseTariffZoneOnConflict = {
  constraint: StopsDatabaseTariffZoneConstraint;
  update_columns?: Array<StopsDatabaseTariffZoneUpdateColumn>;
  where?: InputMaybe<StopsDatabaseTariffZoneBoolExp>;
};

/** Ordering options when selecting data from "tariff_zone". */
export type StopsDatabaseTariffZoneOrderBy = {
  centroid?: InputMaybe<OrderBy>;
  changed?: InputMaybe<OrderBy>;
  changed_by?: InputMaybe<OrderBy>;
  created?: InputMaybe<OrderBy>;
  description_lang?: InputMaybe<OrderBy>;
  description_value?: InputMaybe<OrderBy>;
  from_date?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name_lang?: InputMaybe<OrderBy>;
  name_value?: InputMaybe<OrderBy>;
  netex_id?: InputMaybe<OrderBy>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonOrderBy>;
  polygon_id?: InputMaybe<OrderBy>;
  private_code_type?: InputMaybe<OrderBy>;
  private_code_value?: InputMaybe<OrderBy>;
  short_name_lang?: InputMaybe<OrderBy>;
  short_name_value?: InputMaybe<OrderBy>;
  tariff_zone_key_values_aggregate?: InputMaybe<StopsDatabaseTariffZoneKeyValuesAggregateOrderBy>;
  to_date?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
  version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: tariff_zone */
export type StopsDatabaseTariffZonePkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "tariff_zone" */
export enum StopsDatabaseTariffZoneSelectColumn {
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

/** input type for updating data in table "tariff_zone" */
export type StopsDatabaseTariffZoneSetInput = {
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseTariffZoneStddevFields = {
  __typename?: 'stops_database_tariff_zone_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseTariffZoneStddevPopFields = {
  __typename?: 'stops_database_tariff_zone_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseTariffZoneStddevSampFields = {
  __typename?: 'stops_database_tariff_zone_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "tariff_zone" */
export type StopsDatabaseTariffZoneStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseTariffZoneStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseTariffZoneStreamCursorValueInput = {
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseTariffZoneSumFields = {
  __typename?: 'stops_database_tariff_zone_sum_fields';
  id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['bigint']>;
};

/** update columns of table "tariff_zone" */
export enum StopsDatabaseTariffZoneUpdateColumn {
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

export type StopsDatabaseTariffZoneUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseTariffZoneIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseTariffZoneSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseTariffZoneBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseTariffZoneVarPopFields = {
  __typename?: 'stops_database_tariff_zone_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseTariffZoneVarSampFields = {
  __typename?: 'stops_database_tariff_zone_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseTariffZoneVarianceFields = {
  __typename?: 'stops_database_tariff_zone_variance_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "topographic_place" */
export type StopsDatabaseTopographicPlace = {
  __typename?: 'stops_database_topographic_place';
  centroid?: Maybe<Scalars['geometry']>;
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  country_ref?: Maybe<Scalars['String']>;
  country_ref_value?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id: Scalars['bigint'];
  iso_code?: Maybe<Scalars['String']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  parent_ref?: Maybe<Scalars['String']>;
  parent_ref_version?: Maybe<Scalars['String']>;
  /** An object relationship */
  persistable_polygon?: Maybe<StopsDatabasePersistablePolygon>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  /** An array relationship */
  topographic_place_key_values: Array<StopsDatabaseTopographicPlaceKeyValues>;
  /** An aggregate relationship */
  topographic_place_key_values_aggregate: StopsDatabaseTopographicPlaceKeyValuesAggregate;
  topographic_place_type?: Maybe<Scalars['String']>;
  version: Scalars['bigint'];
  version_comment?: Maybe<Scalars['String']>;
};

/** columns and relationships of "topographic_place" */
export type StopsDatabaseTopographicPlaceTopographicPlaceKeyValuesArgs = {
  distinct_on?: InputMaybe<
    Array<StopsDatabaseTopographicPlaceKeyValuesSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseTopographicPlaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesBoolExp>;
};

/** columns and relationships of "topographic_place" */
export type StopsDatabaseTopographicPlaceTopographicPlaceKeyValuesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<StopsDatabaseTopographicPlaceKeyValuesSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<StopsDatabaseTopographicPlaceKeyValuesOrderBy>>;
    where?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesBoolExp>;
  };

/** aggregated selection of "topographic_place" */
export type StopsDatabaseTopographicPlaceAggregate = {
  __typename?: 'stops_database_topographic_place_aggregate';
  aggregate?: Maybe<StopsDatabaseTopographicPlaceAggregateFields>;
  nodes: Array<StopsDatabaseTopographicPlace>;
};

/** aggregate fields of "topographic_place" */
export type StopsDatabaseTopographicPlaceAggregateFields = {
  __typename?: 'stops_database_topographic_place_aggregate_fields';
  avg?: Maybe<StopsDatabaseTopographicPlaceAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseTopographicPlaceMaxFields>;
  min?: Maybe<StopsDatabaseTopographicPlaceMinFields>;
  stddev?: Maybe<StopsDatabaseTopographicPlaceStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseTopographicPlaceStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseTopographicPlaceStddevSampFields>;
  sum?: Maybe<StopsDatabaseTopographicPlaceSumFields>;
  var_pop?: Maybe<StopsDatabaseTopographicPlaceVarPopFields>;
  var_samp?: Maybe<StopsDatabaseTopographicPlaceVarSampFields>;
  variance?: Maybe<StopsDatabaseTopographicPlaceVarianceFields>;
};

/** aggregate fields of "topographic_place" */
export type StopsDatabaseTopographicPlaceAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseTopographicPlaceSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseTopographicPlaceAvgFields = {
  __typename?: 'stops_database_topographic_place_avg_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "topographic_place". All fields are combined with a logical 'AND'. */
export type StopsDatabaseTopographicPlaceBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseTopographicPlaceBoolExp>>;
  _not?: InputMaybe<StopsDatabaseTopographicPlaceBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseTopographicPlaceBoolExp>>;
  centroid?: InputMaybe<GeometryComparisonExp>;
  changed?: InputMaybe<TimestampComparisonExp>;
  changed_by?: InputMaybe<StringComparisonExp>;
  country_ref?: InputMaybe<StringComparisonExp>;
  country_ref_value?: InputMaybe<StringComparisonExp>;
  created?: InputMaybe<TimestampComparisonExp>;
  description_lang?: InputMaybe<StringComparisonExp>;
  description_value?: InputMaybe<StringComparisonExp>;
  from_date?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  iso_code?: InputMaybe<StringComparisonExp>;
  name_lang?: InputMaybe<StringComparisonExp>;
  name_value?: InputMaybe<StringComparisonExp>;
  netex_id?: InputMaybe<StringComparisonExp>;
  parent_ref?: InputMaybe<StringComparisonExp>;
  parent_ref_version?: InputMaybe<StringComparisonExp>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  polygon_id?: InputMaybe<BigintComparisonExp>;
  private_code_type?: InputMaybe<StringComparisonExp>;
  private_code_value?: InputMaybe<StringComparisonExp>;
  short_name_lang?: InputMaybe<StringComparisonExp>;
  short_name_value?: InputMaybe<StringComparisonExp>;
  to_date?: InputMaybe<TimestampComparisonExp>;
  topographic_place_key_values?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesBoolExp>;
  topographic_place_key_values_aggregate?: InputMaybe<TopographicPlaceKeyValuesAggregateBoolExp>;
  topographic_place_type?: InputMaybe<StringComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
  version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "topographic_place" */
export enum StopsDatabaseTopographicPlaceConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  TopographicPlaceNetexIdVersionConstraint = 'topographic_place_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  TopographicPlacePkey = 'topographic_place_pkey',
}

/** input type for incrementing numeric columns in table "topographic_place" */
export type StopsDatabaseTopographicPlaceIncInput = {
  id?: InputMaybe<Scalars['bigint']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  version?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "topographic_place" */
export type StopsDatabaseTopographicPlaceInsertInput = {
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  country_ref?: InputMaybe<Scalars['String']>;
  country_ref_value?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  iso_code?: InputMaybe<Scalars['String']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  parent_ref?: InputMaybe<Scalars['String']>;
  parent_ref_version?: InputMaybe<Scalars['String']>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonObjRelInsertInput>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  topographic_place_key_values?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesArrRelInsertInput>;
  topographic_place_type?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValues = {
  __typename?: 'stops_database_topographic_place_key_values';
  key_values_id: Scalars['bigint'];
  key_values_key: Scalars['String'];
  topographic_place_id: Scalars['bigint'];
  /** An object relationship */
  value: StopsDatabaseValue;
};

/** aggregated selection of "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesAggregate = {
  __typename?: 'stops_database_topographic_place_key_values_aggregate';
  aggregate?: Maybe<StopsDatabaseTopographicPlaceKeyValuesAggregateFields>;
  nodes: Array<StopsDatabaseTopographicPlaceKeyValues>;
};

/** aggregate fields of "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesAggregateFields = {
  __typename?: 'stops_database_topographic_place_key_values_aggregate_fields';
  avg?: Maybe<StopsDatabaseTopographicPlaceKeyValuesAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseTopographicPlaceKeyValuesMaxFields>;
  min?: Maybe<StopsDatabaseTopographicPlaceKeyValuesMinFields>;
  stddev?: Maybe<StopsDatabaseTopographicPlaceKeyValuesStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseTopographicPlaceKeyValuesStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseTopographicPlaceKeyValuesStddevSampFields>;
  sum?: Maybe<StopsDatabaseTopographicPlaceKeyValuesSumFields>;
  var_pop?: Maybe<StopsDatabaseTopographicPlaceKeyValuesVarPopFields>;
  var_samp?: Maybe<StopsDatabaseTopographicPlaceKeyValuesVarSampFields>;
  variance?: Maybe<StopsDatabaseTopographicPlaceKeyValuesVarianceFields>;
};

/** aggregate fields of "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<
    Array<StopsDatabaseTopographicPlaceKeyValuesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesArrRelInsertInput = {
  data: Array<StopsDatabaseTopographicPlaceKeyValuesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseTopographicPlaceKeyValuesAvgFields = {
  __typename?: 'stops_database_topographic_place_key_values_avg_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  topographic_place_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesAvgOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  topographic_place_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "topographic_place_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseTopographicPlaceKeyValuesBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseTopographicPlaceKeyValuesBoolExp>>;
  _not?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseTopographicPlaceKeyValuesBoolExp>>;
  key_values_id?: InputMaybe<BigintComparisonExp>;
  key_values_key?: InputMaybe<StringComparisonExp>;
  topographic_place_id?: InputMaybe<BigintComparisonExp>;
  value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "topographic_place_key_values" */
export enum StopsDatabaseTopographicPlaceKeyValuesConstraint {
  /** unique or primary key constraint on columns "topographic_place_id", "key_values_key" */
  TopographicPlaceKeyValuesPkey = 'topographic_place_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkTq5dgj811w1k4w86m4x66iwso = 'uk_tq5dgj811w1k4w86m4x66iwso',
}

/** input type for incrementing numeric columns in table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesIncInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  topographic_place_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesInsertInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  topographic_place_id?: InputMaybe<Scalars['bigint']>;
  value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseTopographicPlaceKeyValuesMaxFields = {
  __typename?: 'stops_database_topographic_place_key_values_max_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
  topographic_place_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesMaxOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  topographic_place_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseTopographicPlaceKeyValuesMinFields = {
  __typename?: 'stops_database_topographic_place_key_values_min_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  key_values_key?: Maybe<Scalars['String']>;
  topographic_place_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesMinOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  topographic_place_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesMutationResponse = {
  __typename?: 'stops_database_topographic_place_key_values_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseTopographicPlaceKeyValues>;
};

/** on_conflict condition type for table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesOnConflict = {
  constraint: StopsDatabaseTopographicPlaceKeyValuesConstraint;
  update_columns?: Array<StopsDatabaseTopographicPlaceKeyValuesUpdateColumn>;
  where?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "topographic_place_key_values". */
export type StopsDatabaseTopographicPlaceKeyValuesOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  key_values_key?: InputMaybe<OrderBy>;
  topographic_place_id?: InputMaybe<OrderBy>;
  value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: topographic_place_key_values */
export type StopsDatabaseTopographicPlaceKeyValuesPkColumnsInput = {
  key_values_key: Scalars['String'];
  topographic_place_id: Scalars['bigint'];
};

/** select columns of table "topographic_place_key_values" */
export enum StopsDatabaseTopographicPlaceKeyValuesSelectColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  TopographicPlaceId = 'topographic_place_id',
}

/** input type for updating data in table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesSetInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  topographic_place_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseTopographicPlaceKeyValuesStddevFields = {
  __typename?: 'stops_database_topographic_place_key_values_stddev_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  topographic_place_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesStddevOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  topographic_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseTopographicPlaceKeyValuesStddevPopFields = {
  __typename?: 'stops_database_topographic_place_key_values_stddev_pop_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  topographic_place_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesStddevPopOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  topographic_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseTopographicPlaceKeyValuesStddevSampFields = {
  __typename?: 'stops_database_topographic_place_key_values_stddev_samp_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  topographic_place_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesStddevSampOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  topographic_place_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseTopographicPlaceKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseTopographicPlaceKeyValuesStreamCursorValueInput = {
  key_values_id?: InputMaybe<Scalars['bigint']>;
  key_values_key?: InputMaybe<Scalars['String']>;
  topographic_place_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseTopographicPlaceKeyValuesSumFields = {
  __typename?: 'stops_database_topographic_place_key_values_sum_fields';
  key_values_id?: Maybe<Scalars['bigint']>;
  topographic_place_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesSumOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  topographic_place_id?: InputMaybe<OrderBy>;
};

/** update columns of table "topographic_place_key_values" */
export enum StopsDatabaseTopographicPlaceKeyValuesUpdateColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  TopographicPlaceId = 'topographic_place_id',
}

export type StopsDatabaseTopographicPlaceKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseTopographicPlaceKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseTopographicPlaceKeyValuesVarPopFields = {
  __typename?: 'stops_database_topographic_place_key_values_var_pop_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  topographic_place_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesVarPopOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  topographic_place_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseTopographicPlaceKeyValuesVarSampFields = {
  __typename?: 'stops_database_topographic_place_key_values_var_samp_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  topographic_place_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesVarSampOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  topographic_place_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseTopographicPlaceKeyValuesVarianceFields = {
  __typename?: 'stops_database_topographic_place_key_values_variance_fields';
  key_values_id?: Maybe<Scalars['Float']>;
  topographic_place_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesVarianceOrderBy = {
  key_values_id?: InputMaybe<OrderBy>;
  topographic_place_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseTopographicPlaceMaxFields = {
  __typename?: 'stops_database_topographic_place_max_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  country_ref?: Maybe<Scalars['String']>;
  country_ref_value?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  iso_code?: Maybe<Scalars['String']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  parent_ref?: Maybe<Scalars['String']>;
  parent_ref_version?: Maybe<Scalars['String']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  topographic_place_type?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type StopsDatabaseTopographicPlaceMinFields = {
  __typename?: 'stops_database_topographic_place_min_fields';
  changed?: Maybe<Scalars['timestamp']>;
  changed_by?: Maybe<Scalars['String']>;
  country_ref?: Maybe<Scalars['String']>;
  country_ref_value?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['timestamp']>;
  description_lang?: Maybe<Scalars['String']>;
  description_value?: Maybe<Scalars['String']>;
  from_date?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  iso_code?: Maybe<Scalars['String']>;
  name_lang?: Maybe<Scalars['String']>;
  name_value?: Maybe<Scalars['String']>;
  netex_id?: Maybe<Scalars['String']>;
  parent_ref?: Maybe<Scalars['String']>;
  parent_ref_version?: Maybe<Scalars['String']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  private_code_type?: Maybe<Scalars['String']>;
  private_code_value?: Maybe<Scalars['String']>;
  short_name_lang?: Maybe<Scalars['String']>;
  short_name_value?: Maybe<Scalars['String']>;
  to_date?: Maybe<Scalars['timestamp']>;
  topographic_place_type?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['bigint']>;
  version_comment?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "topographic_place" */
export type StopsDatabaseTopographicPlaceMutationResponse = {
  __typename?: 'stops_database_topographic_place_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseTopographicPlace>;
};

/** input type for inserting object relation for remote table "topographic_place" */
export type StopsDatabaseTopographicPlaceObjRelInsertInput = {
  data: StopsDatabaseTopographicPlaceInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseTopographicPlaceOnConflict>;
};

/** on_conflict condition type for table "topographic_place" */
export type StopsDatabaseTopographicPlaceOnConflict = {
  constraint: StopsDatabaseTopographicPlaceConstraint;
  update_columns?: Array<StopsDatabaseTopographicPlaceUpdateColumn>;
  where?: InputMaybe<StopsDatabaseTopographicPlaceBoolExp>;
};

/** Ordering options when selecting data from "topographic_place". */
export type StopsDatabaseTopographicPlaceOrderBy = {
  centroid?: InputMaybe<OrderBy>;
  changed?: InputMaybe<OrderBy>;
  changed_by?: InputMaybe<OrderBy>;
  country_ref?: InputMaybe<OrderBy>;
  country_ref_value?: InputMaybe<OrderBy>;
  created?: InputMaybe<OrderBy>;
  description_lang?: InputMaybe<OrderBy>;
  description_value?: InputMaybe<OrderBy>;
  from_date?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  iso_code?: InputMaybe<OrderBy>;
  name_lang?: InputMaybe<OrderBy>;
  name_value?: InputMaybe<OrderBy>;
  netex_id?: InputMaybe<OrderBy>;
  parent_ref?: InputMaybe<OrderBy>;
  parent_ref_version?: InputMaybe<OrderBy>;
  persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonOrderBy>;
  polygon_id?: InputMaybe<OrderBy>;
  private_code_type?: InputMaybe<OrderBy>;
  private_code_value?: InputMaybe<OrderBy>;
  short_name_lang?: InputMaybe<OrderBy>;
  short_name_value?: InputMaybe<OrderBy>;
  to_date?: InputMaybe<OrderBy>;
  topographic_place_key_values_aggregate?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesAggregateOrderBy>;
  topographic_place_type?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
  version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: topographic_place */
export type StopsDatabaseTopographicPlacePkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "topographic_place" */
export enum StopsDatabaseTopographicPlaceSelectColumn {
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  CountryRef = 'country_ref',
  /** column name */
  CountryRefValue = 'country_ref_value',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  IsoCode = 'iso_code',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ParentRef = 'parent_ref',
  /** column name */
  ParentRefVersion = 'parent_ref_version',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TopographicPlaceType = 'topographic_place_type',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

/** input type for updating data in table "topographic_place" */
export type StopsDatabaseTopographicPlaceSetInput = {
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  country_ref?: InputMaybe<Scalars['String']>;
  country_ref_value?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  iso_code?: InputMaybe<Scalars['String']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  parent_ref?: InputMaybe<Scalars['String']>;
  parent_ref_version?: InputMaybe<Scalars['String']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  topographic_place_type?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseTopographicPlaceStddevFields = {
  __typename?: 'stops_database_topographic_place_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseTopographicPlaceStddevPopFields = {
  __typename?: 'stops_database_topographic_place_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseTopographicPlaceStddevSampFields = {
  __typename?: 'stops_database_topographic_place_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "topographic_place" */
export type StopsDatabaseTopographicPlaceStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseTopographicPlaceStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseTopographicPlaceStreamCursorValueInput = {
  centroid?: InputMaybe<Scalars['geometry']>;
  changed?: InputMaybe<Scalars['timestamp']>;
  changed_by?: InputMaybe<Scalars['String']>;
  country_ref?: InputMaybe<Scalars['String']>;
  country_ref_value?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['timestamp']>;
  description_lang?: InputMaybe<Scalars['String']>;
  description_value?: InputMaybe<Scalars['String']>;
  from_date?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  iso_code?: InputMaybe<Scalars['String']>;
  name_lang?: InputMaybe<Scalars['String']>;
  name_value?: InputMaybe<Scalars['String']>;
  netex_id?: InputMaybe<Scalars['String']>;
  parent_ref?: InputMaybe<Scalars['String']>;
  parent_ref_version?: InputMaybe<Scalars['String']>;
  polygon_id?: InputMaybe<Scalars['bigint']>;
  private_code_type?: InputMaybe<Scalars['String']>;
  private_code_value?: InputMaybe<Scalars['String']>;
  short_name_lang?: InputMaybe<Scalars['String']>;
  short_name_value?: InputMaybe<Scalars['String']>;
  to_date?: InputMaybe<Scalars['timestamp']>;
  topographic_place_type?: InputMaybe<Scalars['String']>;
  version?: InputMaybe<Scalars['bigint']>;
  version_comment?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type StopsDatabaseTopographicPlaceSumFields = {
  __typename?: 'stops_database_topographic_place_sum_fields';
  id?: Maybe<Scalars['bigint']>;
  polygon_id?: Maybe<Scalars['bigint']>;
  version?: Maybe<Scalars['bigint']>;
};

/** update columns of table "topographic_place" */
export enum StopsDatabaseTopographicPlaceUpdateColumn {
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  CountryRef = 'country_ref',
  /** column name */
  CountryRefValue = 'country_ref_value',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  IsoCode = 'iso_code',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ParentRef = 'parent_ref',
  /** column name */
  ParentRefVersion = 'parent_ref_version',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TopographicPlaceType = 'topographic_place_type',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
}

export type StopsDatabaseTopographicPlaceUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseTopographicPlaceIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseTopographicPlaceSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseTopographicPlaceBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseTopographicPlaceVarPopFields = {
  __typename?: 'stops_database_topographic_place_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseTopographicPlaceVarSampFields = {
  __typename?: 'stops_database_topographic_place_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseTopographicPlaceVarianceFields = {
  __typename?: 'stops_database_topographic_place_variance_fields';
  id?: Maybe<Scalars['Float']>;
  polygon_id?: Maybe<Scalars['Float']>;
  version?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "value" */
export type StopsDatabaseValue = {
  __typename?: 'stops_database_value';
  id: Scalars['bigint'];
  /** An array relationship */
  value_items: Array<StopsDatabaseValueItems>;
  /** An aggregate relationship */
  value_items_aggregate: StopsDatabaseValueItemsAggregate;
};

/** columns and relationships of "value" */
export type StopsDatabaseValueValueItemsArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseValueItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseValueItemsOrderBy>>;
  where?: InputMaybe<StopsDatabaseValueItemsBoolExp>;
};

/** columns and relationships of "value" */
export type StopsDatabaseValueValueItemsAggregateArgs = {
  distinct_on?: InputMaybe<Array<StopsDatabaseValueItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<StopsDatabaseValueItemsOrderBy>>;
  where?: InputMaybe<StopsDatabaseValueItemsBoolExp>;
};

/** aggregated selection of "value" */
export type StopsDatabaseValueAggregate = {
  __typename?: 'stops_database_value_aggregate';
  aggregate?: Maybe<StopsDatabaseValueAggregateFields>;
  nodes: Array<StopsDatabaseValue>;
};

/** aggregate fields of "value" */
export type StopsDatabaseValueAggregateFields = {
  __typename?: 'stops_database_value_aggregate_fields';
  avg?: Maybe<StopsDatabaseValueAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseValueMaxFields>;
  min?: Maybe<StopsDatabaseValueMinFields>;
  stddev?: Maybe<StopsDatabaseValueStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseValueStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseValueStddevSampFields>;
  sum?: Maybe<StopsDatabaseValueSumFields>;
  var_pop?: Maybe<StopsDatabaseValueVarPopFields>;
  var_samp?: Maybe<StopsDatabaseValueVarSampFields>;
  variance?: Maybe<StopsDatabaseValueVarianceFields>;
};

/** aggregate fields of "value" */
export type StopsDatabaseValueAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseValueSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type StopsDatabaseValueAvgFields = {
  __typename?: 'stops_database_value_avg_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "value". All fields are combined with a logical 'AND'. */
export type StopsDatabaseValueBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseValueBoolExp>>;
  _not?: InputMaybe<StopsDatabaseValueBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseValueBoolExp>>;
  id?: InputMaybe<BigintComparisonExp>;
  value_items?: InputMaybe<StopsDatabaseValueItemsBoolExp>;
  value_items_aggregate?: InputMaybe<ValueItemsAggregateBoolExp>;
};

/** unique or primary key constraints on table "value" */
export enum StopsDatabaseValueConstraint {
  /** unique or primary key constraint on columns "id" */
  ValuePkey = 'value_pkey',
}

/** input type for incrementing numeric columns in table "value" */
export type StopsDatabaseValueIncInput = {
  id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "value" */
export type StopsDatabaseValueInsertInput = {
  id?: InputMaybe<Scalars['bigint']>;
  value_items?: InputMaybe<StopsDatabaseValueItemsArrRelInsertInput>;
};

/** columns and relationships of "value_items" */
export type StopsDatabaseValueItems = {
  __typename?: 'stops_database_value_items';
  items?: Maybe<Scalars['String']>;
  /** An object relationship */
  value: StopsDatabaseValue;
  value_id: Scalars['bigint'];
};

/** aggregated selection of "value_items" */
export type StopsDatabaseValueItemsAggregate = {
  __typename?: 'stops_database_value_items_aggregate';
  aggregate?: Maybe<StopsDatabaseValueItemsAggregateFields>;
  nodes: Array<StopsDatabaseValueItems>;
};

/** aggregate fields of "value_items" */
export type StopsDatabaseValueItemsAggregateFields = {
  __typename?: 'stops_database_value_items_aggregate_fields';
  avg?: Maybe<StopsDatabaseValueItemsAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<StopsDatabaseValueItemsMaxFields>;
  min?: Maybe<StopsDatabaseValueItemsMinFields>;
  stddev?: Maybe<StopsDatabaseValueItemsStddevFields>;
  stddev_pop?: Maybe<StopsDatabaseValueItemsStddevPopFields>;
  stddev_samp?: Maybe<StopsDatabaseValueItemsStddevSampFields>;
  sum?: Maybe<StopsDatabaseValueItemsSumFields>;
  var_pop?: Maybe<StopsDatabaseValueItemsVarPopFields>;
  var_samp?: Maybe<StopsDatabaseValueItemsVarSampFields>;
  variance?: Maybe<StopsDatabaseValueItemsVarianceFields>;
};

/** aggregate fields of "value_items" */
export type StopsDatabaseValueItemsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StopsDatabaseValueItemsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "value_items" */
export type StopsDatabaseValueItemsAggregateOrderBy = {
  avg?: InputMaybe<StopsDatabaseValueItemsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<StopsDatabaseValueItemsMaxOrderBy>;
  min?: InputMaybe<StopsDatabaseValueItemsMinOrderBy>;
  stddev?: InputMaybe<StopsDatabaseValueItemsStddevOrderBy>;
  stddev_pop?: InputMaybe<StopsDatabaseValueItemsStddevPopOrderBy>;
  stddev_samp?: InputMaybe<StopsDatabaseValueItemsStddevSampOrderBy>;
  sum?: InputMaybe<StopsDatabaseValueItemsSumOrderBy>;
  var_pop?: InputMaybe<StopsDatabaseValueItemsVarPopOrderBy>;
  var_samp?: InputMaybe<StopsDatabaseValueItemsVarSampOrderBy>;
  variance?: InputMaybe<StopsDatabaseValueItemsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "value_items" */
export type StopsDatabaseValueItemsArrRelInsertInput = {
  data: Array<StopsDatabaseValueItemsInsertInput>;
};

/** aggregate avg on columns */
export type StopsDatabaseValueItemsAvgFields = {
  __typename?: 'stops_database_value_items_avg_fields';
  value_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "value_items" */
export type StopsDatabaseValueItemsAvgOrderBy = {
  value_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "value_items". All fields are combined with a logical 'AND'. */
export type StopsDatabaseValueItemsBoolExp = {
  _and?: InputMaybe<Array<StopsDatabaseValueItemsBoolExp>>;
  _not?: InputMaybe<StopsDatabaseValueItemsBoolExp>;
  _or?: InputMaybe<Array<StopsDatabaseValueItemsBoolExp>>;
  items?: InputMaybe<StringComparisonExp>;
  value?: InputMaybe<StopsDatabaseValueBoolExp>;
  value_id?: InputMaybe<BigintComparisonExp>;
};

/** input type for incrementing numeric columns in table "value_items" */
export type StopsDatabaseValueItemsIncInput = {
  value_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "value_items" */
export type StopsDatabaseValueItemsInsertInput = {
  items?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
  value_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type StopsDatabaseValueItemsMaxFields = {
  __typename?: 'stops_database_value_items_max_fields';
  items?: Maybe<Scalars['String']>;
  value_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "value_items" */
export type StopsDatabaseValueItemsMaxOrderBy = {
  items?: InputMaybe<OrderBy>;
  value_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseValueItemsMinFields = {
  __typename?: 'stops_database_value_items_min_fields';
  items?: Maybe<Scalars['String']>;
  value_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "value_items" */
export type StopsDatabaseValueItemsMinOrderBy = {
  items?: InputMaybe<OrderBy>;
  value_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "value_items" */
export type StopsDatabaseValueItemsMutationResponse = {
  __typename?: 'stops_database_value_items_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseValueItems>;
};

/** Ordering options when selecting data from "value_items". */
export type StopsDatabaseValueItemsOrderBy = {
  items?: InputMaybe<OrderBy>;
  value?: InputMaybe<StopsDatabaseValueOrderBy>;
  value_id?: InputMaybe<OrderBy>;
};

/** select columns of table "value_items" */
export enum StopsDatabaseValueItemsSelectColumn {
  /** column name */
  Items = 'items',
  /** column name */
  ValueId = 'value_id',
}

/** input type for updating data in table "value_items" */
export type StopsDatabaseValueItemsSetInput = {
  items?: InputMaybe<Scalars['String']>;
  value_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseValueItemsStddevFields = {
  __typename?: 'stops_database_value_items_stddev_fields';
  value_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "value_items" */
export type StopsDatabaseValueItemsStddevOrderBy = {
  value_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseValueItemsStddevPopFields = {
  __typename?: 'stops_database_value_items_stddev_pop_fields';
  value_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "value_items" */
export type StopsDatabaseValueItemsStddevPopOrderBy = {
  value_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseValueItemsStddevSampFields = {
  __typename?: 'stops_database_value_items_stddev_samp_fields';
  value_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "value_items" */
export type StopsDatabaseValueItemsStddevSampOrderBy = {
  value_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "value_items" */
export type StopsDatabaseValueItemsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseValueItemsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseValueItemsStreamCursorValueInput = {
  items?: InputMaybe<Scalars['String']>;
  value_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseValueItemsSumFields = {
  __typename?: 'stops_database_value_items_sum_fields';
  value_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "value_items" */
export type StopsDatabaseValueItemsSumOrderBy = {
  value_id?: InputMaybe<OrderBy>;
};

export type StopsDatabaseValueItemsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseValueItemsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseValueItemsSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseValueItemsBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseValueItemsVarPopFields = {
  __typename?: 'stops_database_value_items_var_pop_fields';
  value_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "value_items" */
export type StopsDatabaseValueItemsVarPopOrderBy = {
  value_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseValueItemsVarSampFields = {
  __typename?: 'stops_database_value_items_var_samp_fields';
  value_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "value_items" */
export type StopsDatabaseValueItemsVarSampOrderBy = {
  value_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseValueItemsVarianceFields = {
  __typename?: 'stops_database_value_items_variance_fields';
  value_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "value_items" */
export type StopsDatabaseValueItemsVarianceOrderBy = {
  value_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseValueMaxFields = {
  __typename?: 'stops_database_value_max_fields';
  id?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type StopsDatabaseValueMinFields = {
  __typename?: 'stops_database_value_min_fields';
  id?: Maybe<Scalars['bigint']>;
};

/** response of any mutation on the table "value" */
export type StopsDatabaseValueMutationResponse = {
  __typename?: 'stops_database_value_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<StopsDatabaseValue>;
};

/** input type for inserting object relation for remote table "value" */
export type StopsDatabaseValueObjRelInsertInput = {
  data: StopsDatabaseValueInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<StopsDatabaseValueOnConflict>;
};

/** on_conflict condition type for table "value" */
export type StopsDatabaseValueOnConflict = {
  constraint: StopsDatabaseValueConstraint;
  update_columns?: Array<StopsDatabaseValueUpdateColumn>;
  where?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** Ordering options when selecting data from "value". */
export type StopsDatabaseValueOrderBy = {
  id?: InputMaybe<OrderBy>;
  value_items_aggregate?: InputMaybe<StopsDatabaseValueItemsAggregateOrderBy>;
};

/** primary key columns input for table: value */
export type StopsDatabaseValuePkColumnsInput = {
  id: Scalars['bigint'];
};

/** select columns of table "value" */
export enum StopsDatabaseValueSelectColumn {
  /** column name */
  Id = 'id',
}

/** input type for updating data in table "value" */
export type StopsDatabaseValueSetInput = {
  id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseValueStddevFields = {
  __typename?: 'stops_database_value_stddev_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseValueStddevPopFields = {
  __typename?: 'stops_database_value_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseValueStddevSampFields = {
  __typename?: 'stops_database_value_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "value" */
export type StopsDatabaseValueStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: StopsDatabaseValueStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseValueStreamCursorValueInput = {
  id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type StopsDatabaseValueSumFields = {
  __typename?: 'stops_database_value_sum_fields';
  id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "value" */
export enum StopsDatabaseValueUpdateColumn {
  /** column name */
  Id = 'id',
}

export type StopsDatabaseValueUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StopsDatabaseValueIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StopsDatabaseValueSetInput>;
  /** filter the rows which have to be updated */
  where: StopsDatabaseValueBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseValueVarPopFields = {
  __typename?: 'stops_database_value_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseValueVarSampFields = {
  __typename?: 'stops_database_value_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type StopsDatabaseValueVarianceFields = {
  __typename?: 'stops_database_value_variance_fields';
  id?: Maybe<Scalars['Float']>;
};

export type SubscriptionRoot = {
  __typename?: 'subscription_root';
  /** fetch data from the table: "hsl_route.legacy_hsl_municipality_code" */
  hsl_route_legacy_hsl_municipality_code: Array<HslRouteLegacyHslMunicipalityCode>;
  /** fetch aggregated fields from the table: "hsl_route.legacy_hsl_municipality_code" */
  hsl_route_legacy_hsl_municipality_code_aggregate: HslRouteLegacyHslMunicipalityCodeAggregate;
  /** fetch data from the table: "hsl_route.legacy_hsl_municipality_code" using primary key columns */
  hsl_route_legacy_hsl_municipality_code_by_pk?: Maybe<HslRouteLegacyHslMunicipalityCode>;
  /** fetch data from the table in a streaming manner: "hsl_route.legacy_hsl_municipality_code" */
  hsl_route_legacy_hsl_municipality_code_stream: Array<HslRouteLegacyHslMunicipalityCode>;
  /** fetch data from the table: "hsl_route.transport_target" */
  hsl_route_transport_target: Array<HslRouteTransportTarget>;
  /** fetch aggregated fields from the table: "hsl_route.transport_target" */
  hsl_route_transport_target_aggregate: HslRouteTransportTargetAggregate;
  /** fetch data from the table: "hsl_route.transport_target" using primary key columns */
  hsl_route_transport_target_by_pk?: Maybe<HslRouteTransportTarget>;
  /** fetch data from the table in a streaming manner: "hsl_route.transport_target" */
  hsl_route_transport_target_stream: Array<HslRouteTransportTarget>;
  /** fetch data from the table: "infrastructure_network.direction" */
  infrastructure_network_direction: Array<InfrastructureNetworkDirection>;
  /** fetch aggregated fields from the table: "infrastructure_network.direction" */
  infrastructure_network_direction_aggregate: InfrastructureNetworkDirectionAggregate;
  /** fetch data from the table: "infrastructure_network.direction" using primary key columns */
  infrastructure_network_direction_by_pk?: Maybe<InfrastructureNetworkDirection>;
  /** fetch data from the table in a streaming manner: "infrastructure_network.direction" */
  infrastructure_network_direction_stream: Array<InfrastructureNetworkDirection>;
  /** fetch data from the table: "infrastructure_network.external_source" */
  infrastructure_network_external_source: Array<InfrastructureNetworkExternalSource>;
  /** fetch aggregated fields from the table: "infrastructure_network.external_source" */
  infrastructure_network_external_source_aggregate: InfrastructureNetworkExternalSourceAggregate;
  /** fetch data from the table: "infrastructure_network.external_source" using primary key columns */
  infrastructure_network_external_source_by_pk?: Maybe<InfrastructureNetworkExternalSource>;
  /** fetch data from the table in a streaming manner: "infrastructure_network.external_source" */
  infrastructure_network_external_source_stream: Array<InfrastructureNetworkExternalSource>;
  /** execute function "infrastructure_network.find_point_direction_on_link" which returns "infrastructure_network.direction" */
  infrastructure_network_find_point_direction_on_link: Array<InfrastructureNetworkDirection>;
  /** execute function "infrastructure_network.find_point_direction_on_link" and query aggregates on result of table type "infrastructure_network.direction" */
  infrastructure_network_find_point_direction_on_link_aggregate: InfrastructureNetworkDirectionAggregate;
  /** fetch data from the table: "infrastructure_network.infrastructure_link" */
  infrastructure_network_infrastructure_link: Array<InfrastructureNetworkInfrastructureLink>;
  /** fetch aggregated fields from the table: "infrastructure_network.infrastructure_link" */
  infrastructure_network_infrastructure_link_aggregate: InfrastructureNetworkInfrastructureLinkAggregate;
  /** fetch data from the table: "infrastructure_network.infrastructure_link" using primary key columns */
  infrastructure_network_infrastructure_link_by_pk?: Maybe<InfrastructureNetworkInfrastructureLink>;
  /** fetch data from the table in a streaming manner: "infrastructure_network.infrastructure_link" */
  infrastructure_network_infrastructure_link_stream: Array<InfrastructureNetworkInfrastructureLink>;
  /** execute function "infrastructure_network.resolve_point_to_closest_link" which returns "infrastructure_network.infrastructure_link" */
  infrastructure_network_resolve_point_to_closest_link: Array<InfrastructureNetworkInfrastructureLink>;
  /** execute function "infrastructure_network.resolve_point_to_closest_link" and query aggregates on result of table type "infrastructure_network.infrastructure_link" */
  infrastructure_network_resolve_point_to_closest_link_aggregate: InfrastructureNetworkInfrastructureLinkAggregate;
  /** fetch data from the table: "infrastructure_network.vehicle_submode_on_infrastructure_link" */
  infrastructure_network_vehicle_submode_on_infrastructure_link: Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
  /** fetch aggregated fields from the table: "infrastructure_network.vehicle_submode_on_infrastructure_link" */
  infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate: InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregate;
  /** fetch data from the table: "infrastructure_network.vehicle_submode_on_infrastructure_link" using primary key columns */
  infrastructure_network_vehicle_submode_on_infrastructure_link_by_pk?: Maybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
  /** fetch data from the table in a streaming manner: "infrastructure_network.vehicle_submode_on_infrastructure_link" */
  infrastructure_network_vehicle_submode_on_infrastructure_link_stream: Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
  /** execute function "journey_pattern.check_infra_link_stop_refs_with_new_scheduled_stop_point" which returns "journey_pattern.journey_pattern" */
  journey_pattern_check_infra_link_stop_refs_with_new_scheduled_stop_point: Array<JourneyPatternJourneyPattern>;
  /** execute function "journey_pattern.check_infra_link_stop_refs_with_new_scheduled_stop_point" and query aggregates on result of table type "journey_pattern.journey_pattern" */
  journey_pattern_check_infra_link_stop_refs_with_new_scheduled_stop_point_aggregate: JourneyPatternJourneyPatternAggregate;
  /** fetch data from the table: "journey_pattern.journey_pattern" */
  journey_pattern_journey_pattern: Array<JourneyPatternJourneyPattern>;
  /** fetch aggregated fields from the table: "journey_pattern.journey_pattern" */
  journey_pattern_journey_pattern_aggregate: JourneyPatternJourneyPatternAggregate;
  /** fetch data from the table: "journey_pattern.journey_pattern" using primary key columns */
  journey_pattern_journey_pattern_by_pk?: Maybe<JourneyPatternJourneyPattern>;
  /** fetch data from the table in a streaming manner: "journey_pattern.journey_pattern" */
  journey_pattern_journey_pattern_stream: Array<JourneyPatternJourneyPattern>;
  /** fetch data from the table: "journey_pattern.scheduled_stop_point_in_journey_pattern" */
  journey_pattern_scheduled_stop_point_in_journey_pattern: Array<JourneyPatternScheduledStopPointInJourneyPattern>;
  /** fetch aggregated fields from the table: "journey_pattern.scheduled_stop_point_in_journey_pattern" */
  journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate: JourneyPatternScheduledStopPointInJourneyPatternAggregate;
  /** fetch data from the table: "journey_pattern.scheduled_stop_point_in_journey_pattern" using primary key columns */
  journey_pattern_scheduled_stop_point_in_journey_pattern_by_pk?: Maybe<JourneyPatternScheduledStopPointInJourneyPattern>;
  /** fetch data from the table in a streaming manner: "journey_pattern.scheduled_stop_point_in_journey_pattern" */
  journey_pattern_scheduled_stop_point_in_journey_pattern_stream: Array<JourneyPatternScheduledStopPointInJourneyPattern>;
  /** fetch data from the table: "reusable_components.vehicle_mode" */
  reusable_components_vehicle_mode: Array<ReusableComponentsVehicleMode>;
  /** fetch aggregated fields from the table: "reusable_components.vehicle_mode" */
  reusable_components_vehicle_mode_aggregate: ReusableComponentsVehicleModeAggregate;
  /** fetch data from the table: "reusable_components.vehicle_mode" using primary key columns */
  reusable_components_vehicle_mode_by_pk?: Maybe<ReusableComponentsVehicleMode>;
  /** fetch data from the table in a streaming manner: "reusable_components.vehicle_mode" */
  reusable_components_vehicle_mode_stream: Array<ReusableComponentsVehicleMode>;
  /** fetch data from the table: "reusable_components.vehicle_submode" */
  reusable_components_vehicle_submode: Array<ReusableComponentsVehicleSubmode>;
  /** fetch aggregated fields from the table: "reusable_components.vehicle_submode" */
  reusable_components_vehicle_submode_aggregate: ReusableComponentsVehicleSubmodeAggregate;
  /** fetch data from the table: "reusable_components.vehicle_submode" using primary key columns */
  reusable_components_vehicle_submode_by_pk?: Maybe<ReusableComponentsVehicleSubmode>;
  /** fetch data from the table in a streaming manner: "reusable_components.vehicle_submode" */
  reusable_components_vehicle_submode_stream: Array<ReusableComponentsVehicleSubmode>;
  /** fetch data from the table: "route.direction" */
  route_direction: Array<RouteDirection>;
  /** fetch aggregated fields from the table: "route.direction" */
  route_direction_aggregate: RouteDirectionAggregate;
  /** fetch data from the table: "route.direction" using primary key columns */
  route_direction_by_pk?: Maybe<RouteDirection>;
  /** fetch data from the table in a streaming manner: "route.direction" */
  route_direction_stream: Array<RouteDirection>;
  /** fetch data from the table: "route.infrastructure_link_along_route" */
  route_infrastructure_link_along_route: Array<RouteInfrastructureLinkAlongRoute>;
  /** fetch aggregated fields from the table: "route.infrastructure_link_along_route" */
  route_infrastructure_link_along_route_aggregate: RouteInfrastructureLinkAlongRouteAggregate;
  /** fetch data from the table: "route.infrastructure_link_along_route" using primary key columns */
  route_infrastructure_link_along_route_by_pk?: Maybe<RouteInfrastructureLinkAlongRoute>;
  /** fetch data from the table in a streaming manner: "route.infrastructure_link_along_route" */
  route_infrastructure_link_along_route_stream: Array<RouteInfrastructureLinkAlongRoute>;
  /** fetch data from the table: "route.line" */
  route_line: Array<RouteLine>;
  /** fetch aggregated fields from the table: "route.line" */
  route_line_aggregate: RouteLineAggregate;
  /** fetch data from the table: "route.line" using primary key columns */
  route_line_by_pk?: Maybe<RouteLine>;
  /** fetch data from the table in a streaming manner: "route.line" */
  route_line_stream: Array<RouteLine>;
  /** fetch data from the table: "route.route" */
  route_route: Array<RouteRoute>;
  /** fetch aggregated fields from the table: "route.route" */
  route_route_aggregate: RouteRouteAggregate;
  /** fetch data from the table: "route.route" using primary key columns */
  route_route_by_pk?: Maybe<RouteRoute>;
  /** fetch data from the table in a streaming manner: "route.route" */
  route_route_stream: Array<RouteRoute>;
  /** fetch data from the table: "route.type_of_line" */
  route_type_of_line: Array<RouteTypeOfLine>;
  /** fetch aggregated fields from the table: "route.type_of_line" */
  route_type_of_line_aggregate: RouteTypeOfLineAggregate;
  /** fetch data from the table: "route.type_of_line" using primary key columns */
  route_type_of_line_by_pk?: Maybe<RouteTypeOfLine>;
  /** fetch data from the table in a streaming manner: "route.type_of_line" */
  route_type_of_line_stream: Array<RouteTypeOfLine>;
  /** fetch data from the table: "service_pattern.distance_between_stops_calculation" */
  service_pattern_distance_between_stops_calculation: Array<ServicePatternDistanceBetweenStopsCalculation>;
  /** fetch aggregated fields from the table: "service_pattern.distance_between_stops_calculation" */
  service_pattern_distance_between_stops_calculation_aggregate: ServicePatternDistanceBetweenStopsCalculationAggregate;
  /** fetch data from the table: "service_pattern.distance_between_stops_calculation" using primary key columns */
  service_pattern_distance_between_stops_calculation_by_pk?: Maybe<ServicePatternDistanceBetweenStopsCalculation>;
  /** fetch data from the table in a streaming manner: "service_pattern.distance_between_stops_calculation" */
  service_pattern_distance_between_stops_calculation_stream: Array<ServicePatternDistanceBetweenStopsCalculation>;
  /** execute function "service_pattern.get_distances_between_stop_points_by_routes" which returns "service_pattern.distance_between_stops_calculation" */
  service_pattern_get_distances_between_stop_points_by_routes: Array<ServicePatternDistanceBetweenStopsCalculation>;
  /** execute function "service_pattern.get_distances_between_stop_points_by_routes" and query aggregates on result of table type "service_pattern.distance_between_stops_calculation" */
  service_pattern_get_distances_between_stop_points_by_routes_aggregate: ServicePatternDistanceBetweenStopsCalculationAggregate;
  /** execute function "service_pattern.get_distances_between_stop_points_in_journey_patterns" which returns "service_pattern.distance_between_stops_calculation" */
  service_pattern_get_distances_between_stop_points_in_journey_patterns: Array<ServicePatternDistanceBetweenStopsCalculation>;
  /** execute function "service_pattern.get_distances_between_stop_points_in_journey_patterns" and query aggregates on result of table type "service_pattern.distance_between_stops_calculation" */
  service_pattern_get_distances_between_stop_points_in_journey_patterns_aggregate: ServicePatternDistanceBetweenStopsCalculationAggregate;
  /** fetch data from the table: "service_pattern.scheduled_stop_point" */
  service_pattern_scheduled_stop_point: Array<ServicePatternScheduledStopPoint>;
  /** fetch aggregated fields from the table: "service_pattern.scheduled_stop_point" */
  service_pattern_scheduled_stop_point_aggregate: ServicePatternScheduledStopPointAggregate;
  /** fetch data from the table: "service_pattern.scheduled_stop_point" using primary key columns */
  service_pattern_scheduled_stop_point_by_pk?: Maybe<ServicePatternScheduledStopPoint>;
  /** fetch data from the table in a streaming manner: "service_pattern.scheduled_stop_point" */
  service_pattern_scheduled_stop_point_stream: Array<ServicePatternScheduledStopPoint>;
  /** fetch data from the table: "service_pattern.vehicle_mode_on_scheduled_stop_point" */
  service_pattern_vehicle_mode_on_scheduled_stop_point: Array<ServicePatternVehicleModeOnScheduledStopPoint>;
  /** fetch aggregated fields from the table: "service_pattern.vehicle_mode_on_scheduled_stop_point" */
  service_pattern_vehicle_mode_on_scheduled_stop_point_aggregate: ServicePatternVehicleModeOnScheduledStopPointAggregate;
  /** fetch data from the table: "service_pattern.vehicle_mode_on_scheduled_stop_point" using primary key columns */
  service_pattern_vehicle_mode_on_scheduled_stop_point_by_pk?: Maybe<ServicePatternVehicleModeOnScheduledStopPoint>;
  /** fetch data from the table in a streaming manner: "service_pattern.vehicle_mode_on_scheduled_stop_point" */
  service_pattern_vehicle_mode_on_scheduled_stop_point_stream: Array<ServicePatternVehicleModeOnScheduledStopPoint>;
  stops_database?: Maybe<StopsDatabaseStopsDatabaseSubscription>;
  timetables?: Maybe<TimetablesTimetablesSubscription>;
  /** fetch data from the table: "timing_pattern.timing_place" */
  timing_pattern_timing_place: Array<TimingPatternTimingPlace>;
  /** fetch aggregated fields from the table: "timing_pattern.timing_place" */
  timing_pattern_timing_place_aggregate: TimingPatternTimingPlaceAggregate;
  /** fetch data from the table: "timing_pattern.timing_place" using primary key columns */
  timing_pattern_timing_place_by_pk?: Maybe<TimingPatternTimingPlace>;
  /** fetch data from the table in a streaming manner: "timing_pattern.timing_place" */
  timing_pattern_timing_place_stream: Array<TimingPatternTimingPlace>;
};

export type SubscriptionRootHslRouteLegacyHslMunicipalityCodeArgs = {
  distinct_on?: InputMaybe<
    Array<HslRouteLegacyHslMunicipalityCodeSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<HslRouteLegacyHslMunicipalityCodeOrderBy>>;
  where?: InputMaybe<HslRouteLegacyHslMunicipalityCodeBoolExp>;
};

export type SubscriptionRootHslRouteLegacyHslMunicipalityCodeAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<HslRouteLegacyHslMunicipalityCodeSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<HslRouteLegacyHslMunicipalityCodeOrderBy>>;
  where?: InputMaybe<HslRouteLegacyHslMunicipalityCodeBoolExp>;
};

export type SubscriptionRootHslRouteLegacyHslMunicipalityCodeByPkArgs = {
  hsl_municipality: Scalars['String'];
};

export type SubscriptionRootHslRouteLegacyHslMunicipalityCodeStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<HslRouteLegacyHslMunicipalityCodeStreamCursorInput>>;
  where?: InputMaybe<HslRouteLegacyHslMunicipalityCodeBoolExp>;
};

export type SubscriptionRootHslRouteTransportTargetArgs = {
  distinct_on?: InputMaybe<Array<HslRouteTransportTargetSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<HslRouteTransportTargetOrderBy>>;
  where?: InputMaybe<HslRouteTransportTargetBoolExp>;
};

export type SubscriptionRootHslRouteTransportTargetAggregateArgs = {
  distinct_on?: InputMaybe<Array<HslRouteTransportTargetSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<HslRouteTransportTargetOrderBy>>;
  where?: InputMaybe<HslRouteTransportTargetBoolExp>;
};

export type SubscriptionRootHslRouteTransportTargetByPkArgs = {
  transport_target: Scalars['String'];
};

export type SubscriptionRootHslRouteTransportTargetStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<HslRouteTransportTargetStreamCursorInput>>;
  where?: InputMaybe<HslRouteTransportTargetBoolExp>;
};

export type SubscriptionRootInfrastructureNetworkDirectionArgs = {
  distinct_on?: InputMaybe<Array<InfrastructureNetworkDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<InfrastructureNetworkDirectionOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkDirectionBoolExp>;
};

export type SubscriptionRootInfrastructureNetworkDirectionAggregateArgs = {
  distinct_on?: InputMaybe<Array<InfrastructureNetworkDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<InfrastructureNetworkDirectionOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkDirectionBoolExp>;
};

export type SubscriptionRootInfrastructureNetworkDirectionByPkArgs = {
  value: Scalars['String'];
};

export type SubscriptionRootInfrastructureNetworkDirectionStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<InfrastructureNetworkDirectionStreamCursorInput>>;
  where?: InputMaybe<InfrastructureNetworkDirectionBoolExp>;
};

export type SubscriptionRootInfrastructureNetworkExternalSourceArgs = {
  distinct_on?: InputMaybe<
    Array<InfrastructureNetworkExternalSourceSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<InfrastructureNetworkExternalSourceOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkExternalSourceBoolExp>;
};

export type SubscriptionRootInfrastructureNetworkExternalSourceAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<InfrastructureNetworkExternalSourceSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<InfrastructureNetworkExternalSourceOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkExternalSourceBoolExp>;
};

export type SubscriptionRootInfrastructureNetworkExternalSourceByPkArgs = {
  value: Scalars['String'];
};

export type SubscriptionRootInfrastructureNetworkExternalSourceStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<
    InputMaybe<InfrastructureNetworkExternalSourceStreamCursorInput>
  >;
  where?: InputMaybe<InfrastructureNetworkExternalSourceBoolExp>;
};

export type SubscriptionRootInfrastructureNetworkFindPointDirectionOnLinkArgs =
  {
    args: InfrastructureNetworkFindPointDirectionOnLinkArgs;
    distinct_on?: InputMaybe<Array<InfrastructureNetworkDirectionSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<InfrastructureNetworkDirectionOrderBy>>;
    where?: InputMaybe<InfrastructureNetworkDirectionBoolExp>;
  };

export type SubscriptionRootInfrastructureNetworkFindPointDirectionOnLinkAggregateArgs =
  {
    args: InfrastructureNetworkFindPointDirectionOnLinkArgs;
    distinct_on?: InputMaybe<Array<InfrastructureNetworkDirectionSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<InfrastructureNetworkDirectionOrderBy>>;
    where?: InputMaybe<InfrastructureNetworkDirectionBoolExp>;
  };

export type SubscriptionRootInfrastructureNetworkInfrastructureLinkArgs = {
  distinct_on?: InputMaybe<
    Array<InfrastructureNetworkInfrastructureLinkSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<InfrastructureNetworkInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
};

export type SubscriptionRootInfrastructureNetworkInfrastructureLinkAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<InfrastructureNetworkInfrastructureLinkSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<InfrastructureNetworkInfrastructureLinkOrderBy>
    >;
    where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  };

export type SubscriptionRootInfrastructureNetworkInfrastructureLinkByPkArgs = {
  infrastructure_link_id: Scalars['uuid'];
};

export type SubscriptionRootInfrastructureNetworkInfrastructureLinkStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<InfrastructureNetworkInfrastructureLinkStreamCursorInput>
    >;
    where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  };

export type SubscriptionRootInfrastructureNetworkResolvePointToClosestLinkArgs =
  {
    args: InfrastructureNetworkResolvePointToClosestLinkArgs;
    distinct_on?: InputMaybe<
      Array<InfrastructureNetworkInfrastructureLinkSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<InfrastructureNetworkInfrastructureLinkOrderBy>
    >;
    where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  };

export type SubscriptionRootInfrastructureNetworkResolvePointToClosestLinkAggregateArgs =
  {
    args: InfrastructureNetworkResolvePointToClosestLinkArgs;
    distinct_on?: InputMaybe<
      Array<InfrastructureNetworkInfrastructureLinkSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<InfrastructureNetworkInfrastructureLinkOrderBy>
    >;
    where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  };

export type SubscriptionRootInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkArgs =
  {
    distinct_on?: InputMaybe<
      Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOrderBy>
    >;
    where?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
  };

export type SubscriptionRootInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOrderBy>
    >;
    where?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
  };

export type SubscriptionRootInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkByPkArgs =
  {
    infrastructure_link_id: Scalars['uuid'];
    vehicle_submode: ReusableComponentsVehicleSubmodeEnum;
  };

export type SubscriptionRootInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkStreamCursorInput>
    >;
    where?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
  };

export type SubscriptionRootJourneyPatternCheckInfraLinkStopRefsWithNewScheduledStopPointArgs =
  {
    args: JourneyPatternCheckInfraLinkStopRefsWithNewScheduledStopPointArgs;
    distinct_on?: InputMaybe<Array<JourneyPatternJourneyPatternSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<JourneyPatternJourneyPatternOrderBy>>;
    where?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
  };

export type SubscriptionRootJourneyPatternCheckInfraLinkStopRefsWithNewScheduledStopPointAggregateArgs =
  {
    args: JourneyPatternCheckInfraLinkStopRefsWithNewScheduledStopPointArgs;
    distinct_on?: InputMaybe<Array<JourneyPatternJourneyPatternSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<JourneyPatternJourneyPatternOrderBy>>;
    where?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
  };

export type SubscriptionRootJourneyPatternJourneyPatternArgs = {
  distinct_on?: InputMaybe<Array<JourneyPatternJourneyPatternSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<JourneyPatternJourneyPatternOrderBy>>;
  where?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
};

export type SubscriptionRootJourneyPatternJourneyPatternAggregateArgs = {
  distinct_on?: InputMaybe<Array<JourneyPatternJourneyPatternSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<JourneyPatternJourneyPatternOrderBy>>;
  where?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
};

export type SubscriptionRootJourneyPatternJourneyPatternByPkArgs = {
  journey_pattern_id: Scalars['uuid'];
};

export type SubscriptionRootJourneyPatternJourneyPatternStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<JourneyPatternJourneyPatternStreamCursorInput>>;
  where?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
};

export type SubscriptionRootJourneyPatternScheduledStopPointInJourneyPatternArgs =
  {
    distinct_on?: InputMaybe<
      Array<JourneyPatternScheduledStopPointInJourneyPatternSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<JourneyPatternScheduledStopPointInJourneyPatternOrderBy>
    >;
    where?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
  };

export type SubscriptionRootJourneyPatternScheduledStopPointInJourneyPatternAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<JourneyPatternScheduledStopPointInJourneyPatternSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<JourneyPatternScheduledStopPointInJourneyPatternOrderBy>
    >;
    where?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
  };

export type SubscriptionRootJourneyPatternScheduledStopPointInJourneyPatternByPkArgs =
  {
    journey_pattern_id: Scalars['uuid'];
    scheduled_stop_point_sequence: Scalars['Int'];
  };

export type SubscriptionRootJourneyPatternScheduledStopPointInJourneyPatternStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternStreamCursorInput>
    >;
    where?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
  };

export type SubscriptionRootReusableComponentsVehicleModeArgs = {
  distinct_on?: InputMaybe<Array<ReusableComponentsVehicleModeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<ReusableComponentsVehicleModeOrderBy>>;
  where?: InputMaybe<ReusableComponentsVehicleModeBoolExp>;
};

export type SubscriptionRootReusableComponentsVehicleModeAggregateArgs = {
  distinct_on?: InputMaybe<Array<ReusableComponentsVehicleModeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<ReusableComponentsVehicleModeOrderBy>>;
  where?: InputMaybe<ReusableComponentsVehicleModeBoolExp>;
};

export type SubscriptionRootReusableComponentsVehicleModeByPkArgs = {
  vehicle_mode: Scalars['String'];
};

export type SubscriptionRootReusableComponentsVehicleModeStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<ReusableComponentsVehicleModeStreamCursorInput>>;
  where?: InputMaybe<ReusableComponentsVehicleModeBoolExp>;
};

export type SubscriptionRootReusableComponentsVehicleSubmodeArgs = {
  distinct_on?: InputMaybe<Array<ReusableComponentsVehicleSubmodeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<ReusableComponentsVehicleSubmodeOrderBy>>;
  where?: InputMaybe<ReusableComponentsVehicleSubmodeBoolExp>;
};

export type SubscriptionRootReusableComponentsVehicleSubmodeAggregateArgs = {
  distinct_on?: InputMaybe<Array<ReusableComponentsVehicleSubmodeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<ReusableComponentsVehicleSubmodeOrderBy>>;
  where?: InputMaybe<ReusableComponentsVehicleSubmodeBoolExp>;
};

export type SubscriptionRootReusableComponentsVehicleSubmodeByPkArgs = {
  vehicle_submode: Scalars['String'];
};

export type SubscriptionRootReusableComponentsVehicleSubmodeStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<ReusableComponentsVehicleSubmodeStreamCursorInput>>;
  where?: InputMaybe<ReusableComponentsVehicleSubmodeBoolExp>;
};

export type SubscriptionRootRouteDirectionArgs = {
  distinct_on?: InputMaybe<Array<RouteDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteDirectionOrderBy>>;
  where?: InputMaybe<RouteDirectionBoolExp>;
};

export type SubscriptionRootRouteDirectionAggregateArgs = {
  distinct_on?: InputMaybe<Array<RouteDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteDirectionOrderBy>>;
  where?: InputMaybe<RouteDirectionBoolExp>;
};

export type SubscriptionRootRouteDirectionByPkArgs = {
  direction: Scalars['String'];
};

export type SubscriptionRootRouteDirectionStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<RouteDirectionStreamCursorInput>>;
  where?: InputMaybe<RouteDirectionBoolExp>;
};

export type SubscriptionRootRouteInfrastructureLinkAlongRouteArgs = {
  distinct_on?: InputMaybe<
    Array<RouteInfrastructureLinkAlongRouteSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteInfrastructureLinkAlongRouteOrderBy>>;
  where?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
};

export type SubscriptionRootRouteInfrastructureLinkAlongRouteAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<RouteInfrastructureLinkAlongRouteSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteInfrastructureLinkAlongRouteOrderBy>>;
  where?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
};

export type SubscriptionRootRouteInfrastructureLinkAlongRouteByPkArgs = {
  infrastructure_link_sequence: Scalars['Int'];
  route_id: Scalars['uuid'];
};

export type SubscriptionRootRouteInfrastructureLinkAlongRouteStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<RouteInfrastructureLinkAlongRouteStreamCursorInput>>;
  where?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
};

export type SubscriptionRootRouteLineArgs = {
  distinct_on?: InputMaybe<Array<RouteLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteLineOrderBy>>;
  where?: InputMaybe<RouteLineBoolExp>;
};

export type SubscriptionRootRouteLineAggregateArgs = {
  distinct_on?: InputMaybe<Array<RouteLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteLineOrderBy>>;
  where?: InputMaybe<RouteLineBoolExp>;
};

export type SubscriptionRootRouteLineByPkArgs = {
  line_id: Scalars['uuid'];
};

export type SubscriptionRootRouteLineStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<RouteLineStreamCursorInput>>;
  where?: InputMaybe<RouteLineBoolExp>;
};

export type SubscriptionRootRouteRouteArgs = {
  distinct_on?: InputMaybe<Array<RouteRouteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteRouteOrderBy>>;
  where?: InputMaybe<RouteRouteBoolExp>;
};

export type SubscriptionRootRouteRouteAggregateArgs = {
  distinct_on?: InputMaybe<Array<RouteRouteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteRouteOrderBy>>;
  where?: InputMaybe<RouteRouteBoolExp>;
};

export type SubscriptionRootRouteRouteByPkArgs = {
  route_id: Scalars['uuid'];
};

export type SubscriptionRootRouteRouteStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<RouteRouteStreamCursorInput>>;
  where?: InputMaybe<RouteRouteBoolExp>;
};

export type SubscriptionRootRouteTypeOfLineArgs = {
  distinct_on?: InputMaybe<Array<RouteTypeOfLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteTypeOfLineOrderBy>>;
  where?: InputMaybe<RouteTypeOfLineBoolExp>;
};

export type SubscriptionRootRouteTypeOfLineAggregateArgs = {
  distinct_on?: InputMaybe<Array<RouteTypeOfLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<RouteTypeOfLineOrderBy>>;
  where?: InputMaybe<RouteTypeOfLineBoolExp>;
};

export type SubscriptionRootRouteTypeOfLineByPkArgs = {
  type_of_line: Scalars['String'];
};

export type SubscriptionRootRouteTypeOfLineStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<RouteTypeOfLineStreamCursorInput>>;
  where?: InputMaybe<RouteTypeOfLineBoolExp>;
};

export type SubscriptionRootServicePatternDistanceBetweenStopsCalculationArgs =
  {
    distinct_on?: InputMaybe<
      Array<ServicePatternDistanceBetweenStopsCalculationSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<ServicePatternDistanceBetweenStopsCalculationOrderBy>
    >;
    where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
  };

export type SubscriptionRootServicePatternDistanceBetweenStopsCalculationAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<ServicePatternDistanceBetweenStopsCalculationSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<ServicePatternDistanceBetweenStopsCalculationOrderBy>
    >;
    where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
  };

export type SubscriptionRootServicePatternDistanceBetweenStopsCalculationByPkArgs =
  {
    journey_pattern_id: Scalars['uuid'];
    observation_date: Scalars['date'];
    route_priority: Scalars['Int'];
    stop_interval_sequence: Scalars['Int'];
  };

export type SubscriptionRootServicePatternDistanceBetweenStopsCalculationStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<ServicePatternDistanceBetweenStopsCalculationStreamCursorInput>
    >;
    where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
  };

export type SubscriptionRootServicePatternGetDistancesBetweenStopPointsByRoutesArgs =
  {
    args: ServicePatternGetDistancesBetweenStopPointsByRoutesArgs;
    distinct_on?: InputMaybe<
      Array<ServicePatternDistanceBetweenStopsCalculationSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<ServicePatternDistanceBetweenStopsCalculationOrderBy>
    >;
    where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
  };

export type SubscriptionRootServicePatternGetDistancesBetweenStopPointsByRoutesAggregateArgs =
  {
    args: ServicePatternGetDistancesBetweenStopPointsByRoutesArgs;
    distinct_on?: InputMaybe<
      Array<ServicePatternDistanceBetweenStopsCalculationSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<ServicePatternDistanceBetweenStopsCalculationOrderBy>
    >;
    where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
  };

export type SubscriptionRootServicePatternGetDistancesBetweenStopPointsInJourneyPatternsArgs =
  {
    args: ServicePatternGetDistancesBetweenStopPointsInJourneyPatternsArgs;
    distinct_on?: InputMaybe<
      Array<ServicePatternDistanceBetweenStopsCalculationSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<ServicePatternDistanceBetweenStopsCalculationOrderBy>
    >;
    where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
  };

export type SubscriptionRootServicePatternGetDistancesBetweenStopPointsInJourneyPatternsAggregateArgs =
  {
    args: ServicePatternGetDistancesBetweenStopPointsInJourneyPatternsArgs;
    distinct_on?: InputMaybe<
      Array<ServicePatternDistanceBetweenStopsCalculationSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<ServicePatternDistanceBetweenStopsCalculationOrderBy>
    >;
    where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
  };

export type SubscriptionRootServicePatternScheduledStopPointArgs = {
  distinct_on?: InputMaybe<Array<ServicePatternScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<ServicePatternScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};

export type SubscriptionRootServicePatternScheduledStopPointAggregateArgs = {
  distinct_on?: InputMaybe<Array<ServicePatternScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<ServicePatternScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};

export type SubscriptionRootServicePatternScheduledStopPointByPkArgs = {
  scheduled_stop_point_id: Scalars['uuid'];
};

export type SubscriptionRootServicePatternScheduledStopPointStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<ServicePatternScheduledStopPointStreamCursorInput>>;
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};

export type SubscriptionRootServicePatternVehicleModeOnScheduledStopPointArgs =
  {
    distinct_on?: InputMaybe<
      Array<ServicePatternVehicleModeOnScheduledStopPointSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<ServicePatternVehicleModeOnScheduledStopPointOrderBy>
    >;
    where?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointBoolExp>;
  };

export type SubscriptionRootServicePatternVehicleModeOnScheduledStopPointAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<ServicePatternVehicleModeOnScheduledStopPointSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<ServicePatternVehicleModeOnScheduledStopPointOrderBy>
    >;
    where?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointBoolExp>;
  };

export type SubscriptionRootServicePatternVehicleModeOnScheduledStopPointByPkArgs =
  {
    scheduled_stop_point_id: Scalars['uuid'];
    vehicle_mode: ReusableComponentsVehicleModeEnum;
  };

export type SubscriptionRootServicePatternVehicleModeOnScheduledStopPointStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<ServicePatternVehicleModeOnScheduledStopPointStreamCursorInput>
    >;
    where?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointBoolExp>;
  };

export type SubscriptionRootTimingPatternTimingPlaceArgs = {
  distinct_on?: InputMaybe<Array<TimingPatternTimingPlaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<TimingPatternTimingPlaceOrderBy>>;
  where?: InputMaybe<TimingPatternTimingPlaceBoolExp>;
};

export type SubscriptionRootTimingPatternTimingPlaceAggregateArgs = {
  distinct_on?: InputMaybe<Array<TimingPatternTimingPlaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<TimingPatternTimingPlaceOrderBy>>;
  where?: InputMaybe<TimingPatternTimingPlaceBoolExp>;
};

export type SubscriptionRootTimingPatternTimingPlaceByPkArgs = {
  timing_place_id: Scalars['uuid'];
};

export type SubscriptionRootTimingPatternTimingPlaceStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<TimingPatternTimingPlaceStreamCursorInput>>;
  where?: InputMaybe<TimingPatternTimingPlaceBoolExp>;
};

export type TariffZoneKeyValuesAggregateBoolExp = {
  count?: InputMaybe<TariffZoneKeyValuesAggregateBoolExpCount>;
};

export type TariffZoneKeyValuesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<StopsDatabaseTariffZoneKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseTariffZoneKeyValuesBoolExp>;
  predicate: IntComparisonExp;
};

/** Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'. */
export type TimestampComparisonExp = {
  _eq?: InputMaybe<Scalars['timestamp']>;
  _gt?: InputMaybe<Scalars['timestamp']>;
  _gte?: InputMaybe<Scalars['timestamp']>;
  _in?: InputMaybe<Array<Scalars['timestamp']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['timestamp']>;
  _lte?: InputMaybe<Scalars['timestamp']>;
  _neq?: InputMaybe<Scalars['timestamp']>;
  _nin?: InputMaybe<Array<Scalars['timestamp']>>;
};

/** Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'. */
export type TimestamptzComparisonExp = {
  _eq?: InputMaybe<Scalars['timestamptz']>;
  _gt?: InputMaybe<Scalars['timestamptz']>;
  _gte?: InputMaybe<Scalars['timestamptz']>;
  _in?: InputMaybe<Array<Scalars['timestamptz']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['timestamptz']>;
  _lte?: InputMaybe<Scalars['timestamptz']>;
  _neq?: InputMaybe<Scalars['timestamptz']>;
  _nin?: InputMaybe<Array<Scalars['timestamptz']>>;
};

/** ordering argument of a cursor */
export enum TimetablesCursorOrdering {
  /** ascending ordering of the cursor */
  Asc = 'ASC',
  /** descending ordering of the cursor */
  Desc = 'DESC',
}

/** Reference to a given snapshot of a JOURNEY PATTERN for a given operating day. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:729  */
export type TimetablesJourneyPatternJourneyPatternRef = {
  __typename?: 'timetables_journey_pattern_journey_pattern_ref';
  /** The ID of the referenced JOURNEY PATTERN */
  journey_pattern_id: Scalars['uuid'];
  journey_pattern_instance?: Maybe<JourneyPatternJourneyPattern>;
  journey_pattern_ref_id: Scalars['uuid'];
  /** The user-given point of time used to pick one journey pattern (with route and scheduled stop points) among possibly many variants. The selected, unambiguous journey pattern variant is used as a basis for schedule planning. */
  observation_timestamp: Scalars['timestamptz'];
  /** The direction of the route associated with the referenced journey pattern */
  route_direction: TimetablesRouteDirectionEnum;
  /** The label of the route associated with the referenced journey pattern */
  route_label: Scalars['String'];
  /** The end date of the validity period of the route associated with the referenced journey pattern. If NULL, then the end of the validity period is unbounded (infinity). */
  route_validity_end?: Maybe<Scalars['date']>;
  /** The start date of the validity period of the route associated with the referenced journey pattern. If NULL, then the start of the validity period is unbounded (-infinity). */
  route_validity_start?: Maybe<Scalars['date']>;
  /** An array relationship */
  scheduled_stop_point_in_journey_pattern_refs: Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRef>;
  /** An aggregate relationship */
  scheduled_stop_point_in_journey_pattern_refs_aggregate: TimetablesServicePatternScheduledStopPointInJourneyPatternRefAggregate;
  /** The timestamp when the snapshot was taken */
  snapshot_timestamp: Scalars['timestamptz'];
  /** The type of line (GTFS route type): https://developers.google.com/transit/gtfs/reference/extended-route-types */
  type_of_line: Scalars['String'];
  /** An array relationship */
  vehicle_journeys: Array<TimetablesVehicleJourneyVehicleJourney>;
  /** An aggregate relationship */
  vehicle_journeys_aggregate: TimetablesVehicleJourneyVehicleJourneyAggregate;
};

/** Reference to a given snapshot of a JOURNEY PATTERN for a given operating day. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:729  */
export type TimetablesJourneyPatternJourneyPatternRefScheduledStopPointInJourneyPatternRefsArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRefOrderBy>
    >;
    where?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>;
  };

/** Reference to a given snapshot of a JOURNEY PATTERN for a given operating day. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:729  */
export type TimetablesJourneyPatternJourneyPatternRefScheduledStopPointInJourneyPatternRefsAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRefOrderBy>
    >;
    where?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>;
  };

/** Reference to a given snapshot of a JOURNEY PATTERN for a given operating day. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:729  */
export type TimetablesJourneyPatternJourneyPatternRefVehicleJourneysArgs = {
  distinct_on?: InputMaybe<
    Array<TimetablesVehicleJourneyVehicleJourneySelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<TimetablesVehicleJourneyVehicleJourneyOrderBy>>;
  where?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
};

/** Reference to a given snapshot of a JOURNEY PATTERN for a given operating day. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:729  */
export type TimetablesJourneyPatternJourneyPatternRefVehicleJourneysAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesVehicleJourneyVehicleJourneySelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesVehicleJourneyVehicleJourneyOrderBy>>;
    where?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
  };

/** aggregated selection of "journey_pattern.journey_pattern_ref" */
export type TimetablesJourneyPatternJourneyPatternRefAggregate = {
  __typename?: 'timetables_journey_pattern_journey_pattern_ref_aggregate';
  aggregate?: Maybe<TimetablesJourneyPatternJourneyPatternRefAggregateFields>;
  nodes: Array<TimetablesJourneyPatternJourneyPatternRef>;
};

/** aggregate fields of "journey_pattern.journey_pattern_ref" */
export type TimetablesJourneyPatternJourneyPatternRefAggregateFields = {
  __typename?: 'timetables_journey_pattern_journey_pattern_ref_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<TimetablesJourneyPatternJourneyPatternRefMaxFields>;
  min?: Maybe<TimetablesJourneyPatternJourneyPatternRefMinFields>;
};

/** aggregate fields of "journey_pattern.journey_pattern_ref" */
export type TimetablesJourneyPatternJourneyPatternRefAggregateFieldsCountArgs =
  {
    columns?: InputMaybe<
      Array<TimetablesJourneyPatternJourneyPatternRefSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
  };

/** Boolean expression to filter rows from the table "journey_pattern.journey_pattern_ref". All fields are combined with a logical 'AND'. */
export type TimetablesJourneyPatternJourneyPatternRefBoolExp = {
  _and?: InputMaybe<Array<TimetablesJourneyPatternJourneyPatternRefBoolExp>>;
  _not?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefBoolExp>;
  _or?: InputMaybe<Array<TimetablesJourneyPatternJourneyPatternRefBoolExp>>;
  journey_pattern_id?: InputMaybe<UuidComparisonExp>;
  journey_pattern_ref_id?: InputMaybe<UuidComparisonExp>;
  observation_timestamp?: InputMaybe<TimestamptzComparisonExp>;
  route_direction?: InputMaybe<RouteDirectionEnumComparisonExp>;
  route_label?: InputMaybe<StringComparisonExp>;
  route_validity_end?: InputMaybe<DateComparisonExp>;
  route_validity_start?: InputMaybe<DateComparisonExp>;
  scheduled_stop_point_in_journey_pattern_refs?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>;
  scheduled_stop_point_in_journey_pattern_refs_aggregate?: InputMaybe<ServicePatternScheduledStopPointInJourneyPatternRefAggregateBoolExp>;
  snapshot_timestamp?: InputMaybe<TimestamptzComparisonExp>;
  type_of_line?: InputMaybe<StringComparisonExp>;
  vehicle_journeys?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
  vehicle_journeys_aggregate?: InputMaybe<VehicleJourneyVehicleJourneyAggregateBoolExp>;
};

/** unique or primary key constraints on table "journey_pattern.journey_pattern_ref" */
export enum TimetablesJourneyPatternJourneyPatternRefConstraint {
  /** unique or primary key constraint on columns "journey_pattern_ref_id" */
  JourneyPatternRefPkey = 'journey_pattern_ref_pkey',
}

/** input type for inserting data into table "journey_pattern.journey_pattern_ref" */
export type TimetablesJourneyPatternJourneyPatternRefInsertInput = {
  /** The ID of the referenced JOURNEY PATTERN */
  journey_pattern_id?: InputMaybe<Scalars['uuid']>;
  journey_pattern_ref_id?: InputMaybe<Scalars['uuid']>;
  /** The user-given point of time used to pick one journey pattern (with route and scheduled stop points) among possibly many variants. The selected, unambiguous journey pattern variant is used as a basis for schedule planning. */
  observation_timestamp?: InputMaybe<Scalars['timestamptz']>;
  /** The direction of the route associated with the referenced journey pattern */
  route_direction?: InputMaybe<TimetablesRouteDirectionEnum>;
  /** The label of the route associated with the referenced journey pattern */
  route_label?: InputMaybe<Scalars['String']>;
  /** The end date of the validity period of the route associated with the referenced journey pattern. If NULL, then the end of the validity period is unbounded (infinity). */
  route_validity_end?: InputMaybe<Scalars['date']>;
  /** The start date of the validity period of the route associated with the referenced journey pattern. If NULL, then the start of the validity period is unbounded (-infinity). */
  route_validity_start?: InputMaybe<Scalars['date']>;
  scheduled_stop_point_in_journey_pattern_refs?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefArrRelInsertInput>;
  /** The timestamp when the snapshot was taken */
  snapshot_timestamp?: InputMaybe<Scalars['timestamptz']>;
  /** The type of line (GTFS route type): https://developers.google.com/transit/gtfs/reference/extended-route-types */
  type_of_line?: InputMaybe<Scalars['String']>;
  vehicle_journeys?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyArrRelInsertInput>;
};

/** aggregate max on columns */
export type TimetablesJourneyPatternJourneyPatternRefMaxFields = {
  __typename?: 'timetables_journey_pattern_journey_pattern_ref_max_fields';
  /** The ID of the referenced JOURNEY PATTERN */
  journey_pattern_id?: Maybe<Scalars['uuid']>;
  journey_pattern_ref_id?: Maybe<Scalars['uuid']>;
  /** The user-given point of time used to pick one journey pattern (with route and scheduled stop points) among possibly many variants. The selected, unambiguous journey pattern variant is used as a basis for schedule planning. */
  observation_timestamp?: Maybe<Scalars['timestamptz']>;
  /** The label of the route associated with the referenced journey pattern */
  route_label?: Maybe<Scalars['String']>;
  /** The end date of the validity period of the route associated with the referenced journey pattern. If NULL, then the end of the validity period is unbounded (infinity). */
  route_validity_end?: Maybe<Scalars['date']>;
  /** The start date of the validity period of the route associated with the referenced journey pattern. If NULL, then the start of the validity period is unbounded (-infinity). */
  route_validity_start?: Maybe<Scalars['date']>;
  /** The timestamp when the snapshot was taken */
  snapshot_timestamp?: Maybe<Scalars['timestamptz']>;
  /** The type of line (GTFS route type): https://developers.google.com/transit/gtfs/reference/extended-route-types */
  type_of_line?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type TimetablesJourneyPatternJourneyPatternRefMinFields = {
  __typename?: 'timetables_journey_pattern_journey_pattern_ref_min_fields';
  /** The ID of the referenced JOURNEY PATTERN */
  journey_pattern_id?: Maybe<Scalars['uuid']>;
  journey_pattern_ref_id?: Maybe<Scalars['uuid']>;
  /** The user-given point of time used to pick one journey pattern (with route and scheduled stop points) among possibly many variants. The selected, unambiguous journey pattern variant is used as a basis for schedule planning. */
  observation_timestamp?: Maybe<Scalars['timestamptz']>;
  /** The label of the route associated with the referenced journey pattern */
  route_label?: Maybe<Scalars['String']>;
  /** The end date of the validity period of the route associated with the referenced journey pattern. If NULL, then the end of the validity period is unbounded (infinity). */
  route_validity_end?: Maybe<Scalars['date']>;
  /** The start date of the validity period of the route associated with the referenced journey pattern. If NULL, then the start of the validity period is unbounded (-infinity). */
  route_validity_start?: Maybe<Scalars['date']>;
  /** The timestamp when the snapshot was taken */
  snapshot_timestamp?: Maybe<Scalars['timestamptz']>;
  /** The type of line (GTFS route type): https://developers.google.com/transit/gtfs/reference/extended-route-types */
  type_of_line?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "journey_pattern.journey_pattern_ref" */
export type TimetablesJourneyPatternJourneyPatternRefMutationResponse = {
  __typename?: 'timetables_journey_pattern_journey_pattern_ref_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<TimetablesJourneyPatternJourneyPatternRef>;
};

/** input type for inserting object relation for remote table "journey_pattern.journey_pattern_ref" */
export type TimetablesJourneyPatternJourneyPatternRefObjRelInsertInput = {
  data: TimetablesJourneyPatternJourneyPatternRefInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefOnConflict>;
};

/** on_conflict condition type for table "journey_pattern.journey_pattern_ref" */
export type TimetablesJourneyPatternJourneyPatternRefOnConflict = {
  constraint: TimetablesJourneyPatternJourneyPatternRefConstraint;
  update_columns?: Array<TimetablesJourneyPatternJourneyPatternRefUpdateColumn>;
  where?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefBoolExp>;
};

/** Ordering options when selecting data from "journey_pattern.journey_pattern_ref". */
export type TimetablesJourneyPatternJourneyPatternRefOrderBy = {
  journey_pattern_id?: InputMaybe<OrderBy>;
  journey_pattern_ref_id?: InputMaybe<OrderBy>;
  observation_timestamp?: InputMaybe<OrderBy>;
  route_direction?: InputMaybe<OrderBy>;
  route_label?: InputMaybe<OrderBy>;
  route_validity_end?: InputMaybe<OrderBy>;
  route_validity_start?: InputMaybe<OrderBy>;
  scheduled_stop_point_in_journey_pattern_refs_aggregate?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefAggregateOrderBy>;
  snapshot_timestamp?: InputMaybe<OrderBy>;
  type_of_line?: InputMaybe<OrderBy>;
  vehicle_journeys_aggregate?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyAggregateOrderBy>;
};

/** primary key columns input for table: journey_pattern.journey_pattern_ref */
export type TimetablesJourneyPatternJourneyPatternRefPkColumnsInput = {
  journey_pattern_ref_id: Scalars['uuid'];
};

/** select columns of table "journey_pattern.journey_pattern_ref" */
export enum TimetablesJourneyPatternJourneyPatternRefSelectColumn {
  /** column name */
  JourneyPatternId = 'journey_pattern_id',
  /** column name */
  JourneyPatternRefId = 'journey_pattern_ref_id',
  /** column name */
  ObservationTimestamp = 'observation_timestamp',
  /** column name */
  RouteDirection = 'route_direction',
  /** column name */
  RouteLabel = 'route_label',
  /** column name */
  RouteValidityEnd = 'route_validity_end',
  /** column name */
  RouteValidityStart = 'route_validity_start',
  /** column name */
  SnapshotTimestamp = 'snapshot_timestamp',
  /** column name */
  TypeOfLine = 'type_of_line',
}

/** input type for updating data in table "journey_pattern.journey_pattern_ref" */
export type TimetablesJourneyPatternJourneyPatternRefSetInput = {
  /** The ID of the referenced JOURNEY PATTERN */
  journey_pattern_id?: InputMaybe<Scalars['uuid']>;
  journey_pattern_ref_id?: InputMaybe<Scalars['uuid']>;
  /** The user-given point of time used to pick one journey pattern (with route and scheduled stop points) among possibly many variants. The selected, unambiguous journey pattern variant is used as a basis for schedule planning. */
  observation_timestamp?: InputMaybe<Scalars['timestamptz']>;
  /** The direction of the route associated with the referenced journey pattern */
  route_direction?: InputMaybe<TimetablesRouteDirectionEnum>;
  /** The label of the route associated with the referenced journey pattern */
  route_label?: InputMaybe<Scalars['String']>;
  /** The end date of the validity period of the route associated with the referenced journey pattern. If NULL, then the end of the validity period is unbounded (infinity). */
  route_validity_end?: InputMaybe<Scalars['date']>;
  /** The start date of the validity period of the route associated with the referenced journey pattern. If NULL, then the start of the validity period is unbounded (-infinity). */
  route_validity_start?: InputMaybe<Scalars['date']>;
  /** The timestamp when the snapshot was taken */
  snapshot_timestamp?: InputMaybe<Scalars['timestamptz']>;
  /** The type of line (GTFS route type): https://developers.google.com/transit/gtfs/reference/extended-route-types */
  type_of_line?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "journey_pattern_journey_pattern_ref" */
export type TimetablesJourneyPatternJourneyPatternRefStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TimetablesJourneyPatternJourneyPatternRefStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesJourneyPatternJourneyPatternRefStreamCursorValueInput = {
  /** The ID of the referenced JOURNEY PATTERN */
  journey_pattern_id?: InputMaybe<Scalars['uuid']>;
  journey_pattern_ref_id?: InputMaybe<Scalars['uuid']>;
  /** The user-given point of time used to pick one journey pattern (with route and scheduled stop points) among possibly many variants. The selected, unambiguous journey pattern variant is used as a basis for schedule planning. */
  observation_timestamp?: InputMaybe<Scalars['timestamptz']>;
  /** The direction of the route associated with the referenced journey pattern */
  route_direction?: InputMaybe<TimetablesRouteDirectionEnum>;
  /** The label of the route associated with the referenced journey pattern */
  route_label?: InputMaybe<Scalars['String']>;
  /** The end date of the validity period of the route associated with the referenced journey pattern. If NULL, then the end of the validity period is unbounded (infinity). */
  route_validity_end?: InputMaybe<Scalars['date']>;
  /** The start date of the validity period of the route associated with the referenced journey pattern. If NULL, then the start of the validity period is unbounded (-infinity). */
  route_validity_start?: InputMaybe<Scalars['date']>;
  /** The timestamp when the snapshot was taken */
  snapshot_timestamp?: InputMaybe<Scalars['timestamptz']>;
  /** The type of line (GTFS route type): https://developers.google.com/transit/gtfs/reference/extended-route-types */
  type_of_line?: InputMaybe<Scalars['String']>;
};

/** update columns of table "journey_pattern.journey_pattern_ref" */
export enum TimetablesJourneyPatternJourneyPatternRefUpdateColumn {
  /** column name */
  JourneyPatternId = 'journey_pattern_id',
  /** column name */
  JourneyPatternRefId = 'journey_pattern_ref_id',
  /** column name */
  ObservationTimestamp = 'observation_timestamp',
  /** column name */
  RouteDirection = 'route_direction',
  /** column name */
  RouteLabel = 'route_label',
  /** column name */
  RouteValidityEnd = 'route_validity_end',
  /** column name */
  RouteValidityStart = 'route_validity_start',
  /** column name */
  SnapshotTimestamp = 'snapshot_timestamp',
  /** column name */
  TypeOfLine = 'type_of_line',
}

export type TimetablesJourneyPatternJourneyPatternRefUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefSetInput>;
  /** filter the rows which have to be updated */
  where: TimetablesJourneyPatternJourneyPatternRefBoolExp;
};

/** Long-term planned time data concerning public transport vehicles passing a particular POINT IN JOURNEY PATTERN on a specified VEHICLE JOURNEY for a certain DAY TYPE. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:4:946  */
export type TimetablesPassingTimesTimetabledPassingTime = {
  __typename?: 'timetables_passing_times_timetabled_passing_time';
  /** The time when the vehicle arrives to the SCHEDULED STOP POINT. Measured as interval counted from the midnight of the OPERATING DAY. When NULL, only the departure time is defined for the passing time. E.g. in case this is the first SCHEDULED STOP POINT of the journey. */
  arrival_time?: Maybe<Scalars['interval']>;
  /** The time when the vehicle departs from the SCHEDULED STOP POINT. Measured as interval counted from the midnight of the OPERATING DAY. When NULL, only the arrival time is defined for the passing time. E.g. in case this is the last SCHEDULED STOP POINT of the journey. */
  departure_time?: Maybe<Scalars['interval']>;
  /** The time when the vehicle can be considered as passing a SCHEDULED STOP POINT. Computed field to ease development; it can never be NULL. */
  passing_time: Scalars['interval'];
  /** An object relationship */
  scheduled_stop_point_in_journey_pattern_ref: TimetablesServicePatternScheduledStopPointInJourneyPatternRef;
  /** The SCHEDULED STOP POINT of the JOURNEY PATTERN where the vehicle passes */
  scheduled_stop_point_in_journey_pattern_ref_id: Scalars['uuid'];
  timetabled_passing_time_id: Scalars['uuid'];
  /** An object relationship */
  vehicle_journey: TimetablesVehicleJourneyVehicleJourney;
  /** The VEHICLE JOURNEY to which this TIMETABLED PASSING TIME belongs */
  vehicle_journey_id: Scalars['uuid'];
};

/** aggregated selection of "passing_times.timetabled_passing_time" */
export type TimetablesPassingTimesTimetabledPassingTimeAggregate = {
  __typename?: 'timetables_passing_times_timetabled_passing_time_aggregate';
  aggregate?: Maybe<TimetablesPassingTimesTimetabledPassingTimeAggregateFields>;
  nodes: Array<TimetablesPassingTimesTimetabledPassingTime>;
};

/** aggregate fields of "passing_times.timetabled_passing_time" */
export type TimetablesPassingTimesTimetabledPassingTimeAggregateFields = {
  __typename?: 'timetables_passing_times_timetabled_passing_time_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<TimetablesPassingTimesTimetabledPassingTimeMaxFields>;
  min?: Maybe<TimetablesPassingTimesTimetabledPassingTimeMinFields>;
};

/** aggregate fields of "passing_times.timetabled_passing_time" */
export type TimetablesPassingTimesTimetabledPassingTimeAggregateFieldsCountArgs =
  {
    columns?: InputMaybe<
      Array<TimetablesPassingTimesTimetabledPassingTimeSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
  };

/** order by aggregate values of table "passing_times.timetabled_passing_time" */
export type TimetablesPassingTimesTimetabledPassingTimeAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeMaxOrderBy>;
  min?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeMinOrderBy>;
};

/** input type for inserting array relation for remote table "passing_times.timetabled_passing_time" */
export type TimetablesPassingTimesTimetabledPassingTimeArrRelInsertInput = {
  data: Array<TimetablesPassingTimesTimetabledPassingTimeInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeOnConflict>;
};

/** Boolean expression to filter rows from the table "passing_times.timetabled_passing_time". All fields are combined with a logical 'AND'. */
export type TimetablesPassingTimesTimetabledPassingTimeBoolExp = {
  _and?: InputMaybe<Array<TimetablesPassingTimesTimetabledPassingTimeBoolExp>>;
  _not?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
  _or?: InputMaybe<Array<TimetablesPassingTimesTimetabledPassingTimeBoolExp>>;
  arrival_time?: InputMaybe<IntervalComparisonExp>;
  departure_time?: InputMaybe<IntervalComparisonExp>;
  passing_time?: InputMaybe<IntervalComparisonExp>;
  scheduled_stop_point_in_journey_pattern_ref?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>;
  scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<UuidComparisonExp>;
  timetabled_passing_time_id?: InputMaybe<UuidComparisonExp>;
  vehicle_journey?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
  vehicle_journey_id?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "passing_times.timetabled_passing_time" */
export enum TimetablesPassingTimesTimetabledPassingTimeConstraint {
  /** unique or primary key constraint on columns "timetabled_passing_time_id" */
  TimetabledPassingTimePkey = 'timetabled_passing_time_pkey',
  /** unique or primary key constraint on columns "scheduled_stop_point_in_journey_pattern_ref_id", "vehicle_journey_id" */
  TimetabledPassingTimeStopPointUniqueIdx = 'timetabled_passing_time_stop_point_unique_idx',
}

/** input type for inserting data into table "passing_times.timetabled_passing_time" */
export type TimetablesPassingTimesTimetabledPassingTimeInsertInput = {
  /** The time when the vehicle arrives to the SCHEDULED STOP POINT. Measured as interval counted from the midnight of the OPERATING DAY. When NULL, only the departure time is defined for the passing time. E.g. in case this is the first SCHEDULED STOP POINT of the journey. */
  arrival_time?: InputMaybe<Scalars['interval']>;
  /** The time when the vehicle departs from the SCHEDULED STOP POINT. Measured as interval counted from the midnight of the OPERATING DAY. When NULL, only the arrival time is defined for the passing time. E.g. in case this is the last SCHEDULED STOP POINT of the journey. */
  departure_time?: InputMaybe<Scalars['interval']>;
  scheduled_stop_point_in_journey_pattern_ref?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefObjRelInsertInput>;
  /** The SCHEDULED STOP POINT of the JOURNEY PATTERN where the vehicle passes */
  scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<Scalars['uuid']>;
  timetabled_passing_time_id?: InputMaybe<Scalars['uuid']>;
  vehicle_journey?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyObjRelInsertInput>;
  /** The VEHICLE JOURNEY to which this TIMETABLED PASSING TIME belongs */
  vehicle_journey_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type TimetablesPassingTimesTimetabledPassingTimeMaxFields = {
  __typename?: 'timetables_passing_times_timetabled_passing_time_max_fields';
  /** The SCHEDULED STOP POINT of the JOURNEY PATTERN where the vehicle passes */
  scheduled_stop_point_in_journey_pattern_ref_id?: Maybe<Scalars['uuid']>;
  timetabled_passing_time_id?: Maybe<Scalars['uuid']>;
  /** The VEHICLE JOURNEY to which this TIMETABLED PASSING TIME belongs */
  vehicle_journey_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "passing_times.timetabled_passing_time" */
export type TimetablesPassingTimesTimetabledPassingTimeMaxOrderBy = {
  /** The SCHEDULED STOP POINT of the JOURNEY PATTERN where the vehicle passes */
  scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<OrderBy>;
  timetabled_passing_time_id?: InputMaybe<OrderBy>;
  /** The VEHICLE JOURNEY to which this TIMETABLED PASSING TIME belongs */
  vehicle_journey_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type TimetablesPassingTimesTimetabledPassingTimeMinFields = {
  __typename?: 'timetables_passing_times_timetabled_passing_time_min_fields';
  /** The SCHEDULED STOP POINT of the JOURNEY PATTERN where the vehicle passes */
  scheduled_stop_point_in_journey_pattern_ref_id?: Maybe<Scalars['uuid']>;
  timetabled_passing_time_id?: Maybe<Scalars['uuid']>;
  /** The VEHICLE JOURNEY to which this TIMETABLED PASSING TIME belongs */
  vehicle_journey_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "passing_times.timetabled_passing_time" */
export type TimetablesPassingTimesTimetabledPassingTimeMinOrderBy = {
  /** The SCHEDULED STOP POINT of the JOURNEY PATTERN where the vehicle passes */
  scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<OrderBy>;
  timetabled_passing_time_id?: InputMaybe<OrderBy>;
  /** The VEHICLE JOURNEY to which this TIMETABLED PASSING TIME belongs */
  vehicle_journey_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "passing_times.timetabled_passing_time" */
export type TimetablesPassingTimesTimetabledPassingTimeMutationResponse = {
  __typename?: 'timetables_passing_times_timetabled_passing_time_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<TimetablesPassingTimesTimetabledPassingTime>;
};

/** on_conflict condition type for table "passing_times.timetabled_passing_time" */
export type TimetablesPassingTimesTimetabledPassingTimeOnConflict = {
  constraint: TimetablesPassingTimesTimetabledPassingTimeConstraint;
  update_columns?: Array<TimetablesPassingTimesTimetabledPassingTimeUpdateColumn>;
  where?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
};

/** Ordering options when selecting data from "passing_times.timetabled_passing_time". */
export type TimetablesPassingTimesTimetabledPassingTimeOrderBy = {
  arrival_time?: InputMaybe<OrderBy>;
  departure_time?: InputMaybe<OrderBy>;
  passing_time?: InputMaybe<OrderBy>;
  scheduled_stop_point_in_journey_pattern_ref?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefOrderBy>;
  scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<OrderBy>;
  timetabled_passing_time_id?: InputMaybe<OrderBy>;
  vehicle_journey?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyOrderBy>;
  vehicle_journey_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: passing_times.timetabled_passing_time */
export type TimetablesPassingTimesTimetabledPassingTimePkColumnsInput = {
  timetabled_passing_time_id: Scalars['uuid'];
};

/** select columns of table "passing_times.timetabled_passing_time" */
export enum TimetablesPassingTimesTimetabledPassingTimeSelectColumn {
  /** column name */
  ArrivalTime = 'arrival_time',
  /** column name */
  DepartureTime = 'departure_time',
  /** column name */
  PassingTime = 'passing_time',
  /** column name */
  ScheduledStopPointInJourneyPatternRefId = 'scheduled_stop_point_in_journey_pattern_ref_id',
  /** column name */
  TimetabledPassingTimeId = 'timetabled_passing_time_id',
  /** column name */
  VehicleJourneyId = 'vehicle_journey_id',
}

/** input type for updating data in table "passing_times.timetabled_passing_time" */
export type TimetablesPassingTimesTimetabledPassingTimeSetInput = {
  /** The time when the vehicle arrives to the SCHEDULED STOP POINT. Measured as interval counted from the midnight of the OPERATING DAY. When NULL, only the departure time is defined for the passing time. E.g. in case this is the first SCHEDULED STOP POINT of the journey. */
  arrival_time?: InputMaybe<Scalars['interval']>;
  /** The time when the vehicle departs from the SCHEDULED STOP POINT. Measured as interval counted from the midnight of the OPERATING DAY. When NULL, only the arrival time is defined for the passing time. E.g. in case this is the last SCHEDULED STOP POINT of the journey. */
  departure_time?: InputMaybe<Scalars['interval']>;
  /** The SCHEDULED STOP POINT of the JOURNEY PATTERN where the vehicle passes */
  scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<Scalars['uuid']>;
  timetabled_passing_time_id?: InputMaybe<Scalars['uuid']>;
  /** The VEHICLE JOURNEY to which this TIMETABLED PASSING TIME belongs */
  vehicle_journey_id?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "passing_times_timetabled_passing_time" */
export type TimetablesPassingTimesTimetabledPassingTimeStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TimetablesPassingTimesTimetabledPassingTimeStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesPassingTimesTimetabledPassingTimeStreamCursorValueInput =
  {
    /** The time when the vehicle arrives to the SCHEDULED STOP POINT. Measured as interval counted from the midnight of the OPERATING DAY. When NULL, only the departure time is defined for the passing time. E.g. in case this is the first SCHEDULED STOP POINT of the journey. */
    arrival_time?: InputMaybe<Scalars['interval']>;
    /** The time when the vehicle departs from the SCHEDULED STOP POINT. Measured as interval counted from the midnight of the OPERATING DAY. When NULL, only the arrival time is defined for the passing time. E.g. in case this is the last SCHEDULED STOP POINT of the journey. */
    departure_time?: InputMaybe<Scalars['interval']>;
    /** The time when the vehicle can be considered as passing a SCHEDULED STOP POINT. Computed field to ease development; it can never be NULL. */
    passing_time?: InputMaybe<Scalars['interval']>;
    /** The SCHEDULED STOP POINT of the JOURNEY PATTERN where the vehicle passes */
    scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<
      Scalars['uuid']
    >;
    timetabled_passing_time_id?: InputMaybe<Scalars['uuid']>;
    /** The VEHICLE JOURNEY to which this TIMETABLED PASSING TIME belongs */
    vehicle_journey_id?: InputMaybe<Scalars['uuid']>;
  };

/** update columns of table "passing_times.timetabled_passing_time" */
export enum TimetablesPassingTimesTimetabledPassingTimeUpdateColumn {
  /** column name */
  ArrivalTime = 'arrival_time',
  /** column name */
  DepartureTime = 'departure_time',
  /** column name */
  ScheduledStopPointInJourneyPatternRefId = 'scheduled_stop_point_in_journey_pattern_ref_id',
  /** column name */
  TimetabledPassingTimeId = 'timetabled_passing_time_id',
  /** column name */
  VehicleJourneyId = 'vehicle_journey_id',
}

export type TimetablesPassingTimesTimetabledPassingTimeUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeSetInput>;
  /** filter the rows which have to be updated */
  where: TimetablesPassingTimesTimetabledPassingTimeBoolExp;
};

/**
 * This return value is used for functions that determine what timetable versions are in effect. In effect will be true for all the timetable version rows that
 * are valid on given observation day and are the highest priority of that day type. As an example if we have:
 * Saturday Standard priority valid for 1.1.2023 - 30.6.2023
 * Saturday Temporary priority valid for 1.5.2023 - 31.5.2023
 * Saturday Special priority valid for 20.5.2023 - 20.5.2023
 *
 * If we check the timetable versions for the date 1.2.2023, for Saturday we only get the Standard priority, beacuse it is the only one valid on that time. So that
 * row would have in_effect = true.
 * If we check the timetable versions for the date 1.5.2023, for Saturday we would get the Standard and the Temporary priority for this date, as they are both valid.
 * But only the higher priority is in effect on this date. So the Saturday Temporary priority would have in_effect = true, and the Saturday Standard priority would
 * have in_effect = false.
 * If we check the timetable versions for the date 20.5.2023, for Saturday we have all three valid, but only one can be in_effect, and that would be the Special
 * priority in this case.
 *
 */
export type TimetablesReturnValueTimetableVersion = {
  __typename?: 'timetables_return_value_timetable_version';
  /** An object relationship */
  day_type?: Maybe<TimetablesServiceCalendarDayType>;
  day_type_id: Scalars['uuid'];
  in_effect: Scalars['Boolean'];
  priority: Scalars['Int'];
  /** An object relationship */
  substitute_operating_day_by_line_type?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineType>;
  substitute_operating_day_by_line_type_id?: Maybe<Scalars['uuid']>;
  validity_end: Scalars['date'];
  validity_start: Scalars['date'];
  /** An object relationship */
  vehicle_schedule_frame?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrame>;
  vehicle_schedule_frame_id?: Maybe<Scalars['uuid']>;
};

/** aggregated selection of "return_value.timetable_version" */
export type TimetablesReturnValueTimetableVersionAggregate = {
  __typename?: 'timetables_return_value_timetable_version_aggregate';
  aggregate?: Maybe<TimetablesReturnValueTimetableVersionAggregateFields>;
  nodes: Array<TimetablesReturnValueTimetableVersion>;
};

/** aggregate fields of "return_value.timetable_version" */
export type TimetablesReturnValueTimetableVersionAggregateFields = {
  __typename?: 'timetables_return_value_timetable_version_aggregate_fields';
  avg?: Maybe<TimetablesReturnValueTimetableVersionAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<TimetablesReturnValueTimetableVersionMaxFields>;
  min?: Maybe<TimetablesReturnValueTimetableVersionMinFields>;
  stddev?: Maybe<TimetablesReturnValueTimetableVersionStddevFields>;
  stddev_pop?: Maybe<TimetablesReturnValueTimetableVersionStddevPopFields>;
  stddev_samp?: Maybe<TimetablesReturnValueTimetableVersionStddevSampFields>;
  sum?: Maybe<TimetablesReturnValueTimetableVersionSumFields>;
  var_pop?: Maybe<TimetablesReturnValueTimetableVersionVarPopFields>;
  var_samp?: Maybe<TimetablesReturnValueTimetableVersionVarSampFields>;
  variance?: Maybe<TimetablesReturnValueTimetableVersionVarianceFields>;
};

/** aggregate fields of "return_value.timetable_version" */
export type TimetablesReturnValueTimetableVersionAggregateFieldsCountArgs = {
  columns?: InputMaybe<
    Array<TimetablesReturnValueTimetableVersionSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type TimetablesReturnValueTimetableVersionAvgFields = {
  __typename?: 'timetables_return_value_timetable_version_avg_fields';
  priority?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "return_value.timetable_version". All fields are combined with a logical 'AND'. */
export type TimetablesReturnValueTimetableVersionBoolExp = {
  _and?: InputMaybe<Array<TimetablesReturnValueTimetableVersionBoolExp>>;
  _not?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
  _or?: InputMaybe<Array<TimetablesReturnValueTimetableVersionBoolExp>>;
  day_type?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
  day_type_id?: InputMaybe<UuidComparisonExp>;
  in_effect?: InputMaybe<BooleanComparisonExp>;
  priority?: InputMaybe<IntComparisonExp>;
  substitute_operating_day_by_line_type?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>;
  substitute_operating_day_by_line_type_id?: InputMaybe<UuidComparisonExp>;
  validity_end?: InputMaybe<DateComparisonExp>;
  validity_start?: InputMaybe<DateComparisonExp>;
  vehicle_schedule_frame?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameBoolExp>;
  vehicle_schedule_frame_id?: InputMaybe<UuidComparisonExp>;
};

/** input type for incrementing numeric columns in table "return_value.timetable_version" */
export type TimetablesReturnValueTimetableVersionIncInput = {
  priority?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "return_value.timetable_version" */
export type TimetablesReturnValueTimetableVersionInsertInput = {
  day_type?: InputMaybe<TimetablesServiceCalendarDayTypeObjRelInsertInput>;
  day_type_id?: InputMaybe<Scalars['uuid']>;
  in_effect?: InputMaybe<Scalars['Boolean']>;
  priority?: InputMaybe<Scalars['Int']>;
  substitute_operating_day_by_line_type?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeObjRelInsertInput>;
  substitute_operating_day_by_line_type_id?: InputMaybe<Scalars['uuid']>;
  validity_end?: InputMaybe<Scalars['date']>;
  validity_start?: InputMaybe<Scalars['date']>;
  vehicle_schedule_frame?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameObjRelInsertInput>;
  vehicle_schedule_frame_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type TimetablesReturnValueTimetableVersionMaxFields = {
  __typename?: 'timetables_return_value_timetable_version_max_fields';
  day_type_id?: Maybe<Scalars['uuid']>;
  priority?: Maybe<Scalars['Int']>;
  substitute_operating_day_by_line_type_id?: Maybe<Scalars['uuid']>;
  validity_end?: Maybe<Scalars['date']>;
  validity_start?: Maybe<Scalars['date']>;
  vehicle_schedule_frame_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type TimetablesReturnValueTimetableVersionMinFields = {
  __typename?: 'timetables_return_value_timetable_version_min_fields';
  day_type_id?: Maybe<Scalars['uuid']>;
  priority?: Maybe<Scalars['Int']>;
  substitute_operating_day_by_line_type_id?: Maybe<Scalars['uuid']>;
  validity_end?: Maybe<Scalars['date']>;
  validity_start?: Maybe<Scalars['date']>;
  vehicle_schedule_frame_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "return_value.timetable_version" */
export type TimetablesReturnValueTimetableVersionMutationResponse = {
  __typename?: 'timetables_return_value_timetable_version_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<TimetablesReturnValueTimetableVersion>;
};

/** Ordering options when selecting data from "return_value.timetable_version". */
export type TimetablesReturnValueTimetableVersionOrderBy = {
  day_type?: InputMaybe<TimetablesServiceCalendarDayTypeOrderBy>;
  day_type_id?: InputMaybe<OrderBy>;
  in_effect?: InputMaybe<OrderBy>;
  priority?: InputMaybe<OrderBy>;
  substitute_operating_day_by_line_type?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOrderBy>;
  substitute_operating_day_by_line_type_id?: InputMaybe<OrderBy>;
  validity_end?: InputMaybe<OrderBy>;
  validity_start?: InputMaybe<OrderBy>;
  vehicle_schedule_frame?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameOrderBy>;
  vehicle_schedule_frame_id?: InputMaybe<OrderBy>;
};

/** select columns of table "return_value.timetable_version" */
export enum TimetablesReturnValueTimetableVersionSelectColumn {
  /** column name */
  DayTypeId = 'day_type_id',
  /** column name */
  InEffect = 'in_effect',
  /** column name */
  Priority = 'priority',
  /** column name */
  SubstituteOperatingDayByLineTypeId = 'substitute_operating_day_by_line_type_id',
  /** column name */
  ValidityEnd = 'validity_end',
  /** column name */
  ValidityStart = 'validity_start',
  /** column name */
  VehicleScheduleFrameId = 'vehicle_schedule_frame_id',
}

/** input type for updating data in table "return_value.timetable_version" */
export type TimetablesReturnValueTimetableVersionSetInput = {
  day_type_id?: InputMaybe<Scalars['uuid']>;
  in_effect?: InputMaybe<Scalars['Boolean']>;
  priority?: InputMaybe<Scalars['Int']>;
  substitute_operating_day_by_line_type_id?: InputMaybe<Scalars['uuid']>;
  validity_end?: InputMaybe<Scalars['date']>;
  validity_start?: InputMaybe<Scalars['date']>;
  vehicle_schedule_frame_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type TimetablesReturnValueTimetableVersionStddevFields = {
  __typename?: 'timetables_return_value_timetable_version_stddev_fields';
  priority?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type TimetablesReturnValueTimetableVersionStddevPopFields = {
  __typename?: 'timetables_return_value_timetable_version_stddev_pop_fields';
  priority?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type TimetablesReturnValueTimetableVersionStddevSampFields = {
  __typename?: 'timetables_return_value_timetable_version_stddev_samp_fields';
  priority?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "return_value_timetable_version" */
export type TimetablesReturnValueTimetableVersionStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TimetablesReturnValueTimetableVersionStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesReturnValueTimetableVersionStreamCursorValueInput = {
  day_type_id?: InputMaybe<Scalars['uuid']>;
  in_effect?: InputMaybe<Scalars['Boolean']>;
  priority?: InputMaybe<Scalars['Int']>;
  substitute_operating_day_by_line_type_id?: InputMaybe<Scalars['uuid']>;
  validity_end?: InputMaybe<Scalars['date']>;
  validity_start?: InputMaybe<Scalars['date']>;
  vehicle_schedule_frame_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type TimetablesReturnValueTimetableVersionSumFields = {
  __typename?: 'timetables_return_value_timetable_version_sum_fields';
  priority?: Maybe<Scalars['Int']>;
};

export type TimetablesReturnValueTimetableVersionUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TimetablesReturnValueTimetableVersionIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TimetablesReturnValueTimetableVersionSetInput>;
  /** filter the rows which have to be updated */
  where: TimetablesReturnValueTimetableVersionBoolExp;
};

/** aggregate var_pop on columns */
export type TimetablesReturnValueTimetableVersionVarPopFields = {
  __typename?: 'timetables_return_value_timetable_version_var_pop_fields';
  priority?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type TimetablesReturnValueTimetableVersionVarSampFields = {
  __typename?: 'timetables_return_value_timetable_version_var_samp_fields';
  priority?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type TimetablesReturnValueTimetableVersionVarianceFields = {
  __typename?: 'timetables_return_value_timetable_version_variance_fields';
  priority?: Maybe<Scalars['Float']>;
};

/**
 * This return value table is used in function vehicle_journey.get_vehicle_schedules_on_date. It consists of vehicle_journey_id, vehicle_schedule_frame_id or
 * substitute_operating_day_by_line_type_id and also enriched with data, which are used in the UI side.
 */
export type TimetablesReturnValueVehicleSchedule = {
  __typename?: 'timetables_return_value_vehicle_schedule';
  created_at?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  day_type?: Maybe<TimetablesServiceCalendarDayType>;
  day_type_id: Scalars['uuid'];
  priority: Scalars['Int'];
  substitute_operating_day_by_line_type_id?: Maybe<Scalars['uuid']>;
  validity_end: Scalars['date'];
  validity_start: Scalars['date'];
  /** An object relationship */
  vehicle_journey?: Maybe<TimetablesVehicleJourneyVehicleJourney>;
  vehicle_journey_id?: Maybe<Scalars['uuid']>;
  vehicle_schedule_frame_id?: Maybe<Scalars['uuid']>;
};

/** aggregated selection of "return_value.vehicle_schedule" */
export type TimetablesReturnValueVehicleScheduleAggregate = {
  __typename?: 'timetables_return_value_vehicle_schedule_aggregate';
  aggregate?: Maybe<TimetablesReturnValueVehicleScheduleAggregateFields>;
  nodes: Array<TimetablesReturnValueVehicleSchedule>;
};

/** aggregate fields of "return_value.vehicle_schedule" */
export type TimetablesReturnValueVehicleScheduleAggregateFields = {
  __typename?: 'timetables_return_value_vehicle_schedule_aggregate_fields';
  avg?: Maybe<TimetablesReturnValueVehicleScheduleAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<TimetablesReturnValueVehicleScheduleMaxFields>;
  min?: Maybe<TimetablesReturnValueVehicleScheduleMinFields>;
  stddev?: Maybe<TimetablesReturnValueVehicleScheduleStddevFields>;
  stddev_pop?: Maybe<TimetablesReturnValueVehicleScheduleStddevPopFields>;
  stddev_samp?: Maybe<TimetablesReturnValueVehicleScheduleStddevSampFields>;
  sum?: Maybe<TimetablesReturnValueVehicleScheduleSumFields>;
  var_pop?: Maybe<TimetablesReturnValueVehicleScheduleVarPopFields>;
  var_samp?: Maybe<TimetablesReturnValueVehicleScheduleVarSampFields>;
  variance?: Maybe<TimetablesReturnValueVehicleScheduleVarianceFields>;
};

/** aggregate fields of "return_value.vehicle_schedule" */
export type TimetablesReturnValueVehicleScheduleAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TimetablesReturnValueVehicleScheduleSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type TimetablesReturnValueVehicleScheduleAvgFields = {
  __typename?: 'timetables_return_value_vehicle_schedule_avg_fields';
  priority?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "return_value.vehicle_schedule". All fields are combined with a logical 'AND'. */
export type TimetablesReturnValueVehicleScheduleBoolExp = {
  _and?: InputMaybe<Array<TimetablesReturnValueVehicleScheduleBoolExp>>;
  _not?: InputMaybe<TimetablesReturnValueVehicleScheduleBoolExp>;
  _or?: InputMaybe<Array<TimetablesReturnValueVehicleScheduleBoolExp>>;
  created_at?: InputMaybe<TimestamptzComparisonExp>;
  day_type?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
  day_type_id?: InputMaybe<UuidComparisonExp>;
  priority?: InputMaybe<IntComparisonExp>;
  substitute_operating_day_by_line_type_id?: InputMaybe<UuidComparisonExp>;
  validity_end?: InputMaybe<DateComparisonExp>;
  validity_start?: InputMaybe<DateComparisonExp>;
  vehicle_journey?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
  vehicle_journey_id?: InputMaybe<UuidComparisonExp>;
  vehicle_schedule_frame_id?: InputMaybe<UuidComparisonExp>;
};

/** input type for incrementing numeric columns in table "return_value.vehicle_schedule" */
export type TimetablesReturnValueVehicleScheduleIncInput = {
  priority?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "return_value.vehicle_schedule" */
export type TimetablesReturnValueVehicleScheduleInsertInput = {
  created_at?: InputMaybe<Scalars['timestamptz']>;
  day_type?: InputMaybe<TimetablesServiceCalendarDayTypeObjRelInsertInput>;
  day_type_id?: InputMaybe<Scalars['uuid']>;
  priority?: InputMaybe<Scalars['Int']>;
  substitute_operating_day_by_line_type_id?: InputMaybe<Scalars['uuid']>;
  validity_end?: InputMaybe<Scalars['date']>;
  validity_start?: InputMaybe<Scalars['date']>;
  vehicle_journey?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyObjRelInsertInput>;
  vehicle_journey_id?: InputMaybe<Scalars['uuid']>;
  vehicle_schedule_frame_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type TimetablesReturnValueVehicleScheduleMaxFields = {
  __typename?: 'timetables_return_value_vehicle_schedule_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  day_type_id?: Maybe<Scalars['uuid']>;
  priority?: Maybe<Scalars['Int']>;
  substitute_operating_day_by_line_type_id?: Maybe<Scalars['uuid']>;
  validity_end?: Maybe<Scalars['date']>;
  validity_start?: Maybe<Scalars['date']>;
  vehicle_journey_id?: Maybe<Scalars['uuid']>;
  vehicle_schedule_frame_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type TimetablesReturnValueVehicleScheduleMinFields = {
  __typename?: 'timetables_return_value_vehicle_schedule_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  day_type_id?: Maybe<Scalars['uuid']>;
  priority?: Maybe<Scalars['Int']>;
  substitute_operating_day_by_line_type_id?: Maybe<Scalars['uuid']>;
  validity_end?: Maybe<Scalars['date']>;
  validity_start?: Maybe<Scalars['date']>;
  vehicle_journey_id?: Maybe<Scalars['uuid']>;
  vehicle_schedule_frame_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "return_value.vehicle_schedule" */
export type TimetablesReturnValueVehicleScheduleMutationResponse = {
  __typename?: 'timetables_return_value_vehicle_schedule_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<TimetablesReturnValueVehicleSchedule>;
};

/** Ordering options when selecting data from "return_value.vehicle_schedule". */
export type TimetablesReturnValueVehicleScheduleOrderBy = {
  created_at?: InputMaybe<OrderBy>;
  day_type?: InputMaybe<TimetablesServiceCalendarDayTypeOrderBy>;
  day_type_id?: InputMaybe<OrderBy>;
  priority?: InputMaybe<OrderBy>;
  substitute_operating_day_by_line_type_id?: InputMaybe<OrderBy>;
  validity_end?: InputMaybe<OrderBy>;
  validity_start?: InputMaybe<OrderBy>;
  vehicle_journey?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyOrderBy>;
  vehicle_journey_id?: InputMaybe<OrderBy>;
  vehicle_schedule_frame_id?: InputMaybe<OrderBy>;
};

/** select columns of table "return_value.vehicle_schedule" */
export enum TimetablesReturnValueVehicleScheduleSelectColumn {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DayTypeId = 'day_type_id',
  /** column name */
  Priority = 'priority',
  /** column name */
  SubstituteOperatingDayByLineTypeId = 'substitute_operating_day_by_line_type_id',
  /** column name */
  ValidityEnd = 'validity_end',
  /** column name */
  ValidityStart = 'validity_start',
  /** column name */
  VehicleJourneyId = 'vehicle_journey_id',
  /** column name */
  VehicleScheduleFrameId = 'vehicle_schedule_frame_id',
}

/** input type for updating data in table "return_value.vehicle_schedule" */
export type TimetablesReturnValueVehicleScheduleSetInput = {
  created_at?: InputMaybe<Scalars['timestamptz']>;
  day_type_id?: InputMaybe<Scalars['uuid']>;
  priority?: InputMaybe<Scalars['Int']>;
  substitute_operating_day_by_line_type_id?: InputMaybe<Scalars['uuid']>;
  validity_end?: InputMaybe<Scalars['date']>;
  validity_start?: InputMaybe<Scalars['date']>;
  vehicle_journey_id?: InputMaybe<Scalars['uuid']>;
  vehicle_schedule_frame_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type TimetablesReturnValueVehicleScheduleStddevFields = {
  __typename?: 'timetables_return_value_vehicle_schedule_stddev_fields';
  priority?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type TimetablesReturnValueVehicleScheduleStddevPopFields = {
  __typename?: 'timetables_return_value_vehicle_schedule_stddev_pop_fields';
  priority?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type TimetablesReturnValueVehicleScheduleStddevSampFields = {
  __typename?: 'timetables_return_value_vehicle_schedule_stddev_samp_fields';
  priority?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "return_value_vehicle_schedule" */
export type TimetablesReturnValueVehicleScheduleStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TimetablesReturnValueVehicleScheduleStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesReturnValueVehicleScheduleStreamCursorValueInput = {
  created_at?: InputMaybe<Scalars['timestamptz']>;
  day_type_id?: InputMaybe<Scalars['uuid']>;
  priority?: InputMaybe<Scalars['Int']>;
  substitute_operating_day_by_line_type_id?: InputMaybe<Scalars['uuid']>;
  validity_end?: InputMaybe<Scalars['date']>;
  validity_start?: InputMaybe<Scalars['date']>;
  vehicle_journey_id?: InputMaybe<Scalars['uuid']>;
  vehicle_schedule_frame_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type TimetablesReturnValueVehicleScheduleSumFields = {
  __typename?: 'timetables_return_value_vehicle_schedule_sum_fields';
  priority?: Maybe<Scalars['Int']>;
};

export type TimetablesReturnValueVehicleScheduleUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TimetablesReturnValueVehicleScheduleIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TimetablesReturnValueVehicleScheduleSetInput>;
  /** filter the rows which have to be updated */
  where: TimetablesReturnValueVehicleScheduleBoolExp;
};

/** aggregate var_pop on columns */
export type TimetablesReturnValueVehicleScheduleVarPopFields = {
  __typename?: 'timetables_return_value_vehicle_schedule_var_pop_fields';
  priority?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type TimetablesReturnValueVehicleScheduleVarSampFields = {
  __typename?: 'timetables_return_value_vehicle_schedule_var_samp_fields';
  priority?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type TimetablesReturnValueVehicleScheduleVarianceFields = {
  __typename?: 'timetables_return_value_vehicle_schedule_variance_fields';
  priority?: Maybe<Scalars['Float']>;
};

/** The route directions from Transmodel */
export type TimetablesRouteDirection = {
  __typename?: 'timetables_route_direction';
  /** The name of the route direction */
  direction: Scalars['String'];
  /** The opposite direction */
  the_opposite_of_direction?: Maybe<TimetablesRouteDirectionEnum>;
};

/** aggregated selection of "route.direction" */
export type TimetablesRouteDirectionAggregate = {
  __typename?: 'timetables_route_direction_aggregate';
  aggregate?: Maybe<TimetablesRouteDirectionAggregateFields>;
  nodes: Array<TimetablesRouteDirection>;
};

/** aggregate fields of "route.direction" */
export type TimetablesRouteDirectionAggregateFields = {
  __typename?: 'timetables_route_direction_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<TimetablesRouteDirectionMaxFields>;
  min?: Maybe<TimetablesRouteDirectionMinFields>;
};

/** aggregate fields of "route.direction" */
export type TimetablesRouteDirectionAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TimetablesRouteDirectionSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "route.direction". All fields are combined with a logical 'AND'. */
export type TimetablesRouteDirectionBoolExp = {
  _and?: InputMaybe<Array<TimetablesRouteDirectionBoolExp>>;
  _not?: InputMaybe<TimetablesRouteDirectionBoolExp>;
  _or?: InputMaybe<Array<TimetablesRouteDirectionBoolExp>>;
  direction?: InputMaybe<StringComparisonExp>;
  the_opposite_of_direction?: InputMaybe<RouteDirectionEnumComparisonExp>;
};

/** unique or primary key constraints on table "route.direction" */
export enum TimetablesRouteDirectionConstraint {
  /** unique or primary key constraint on columns "direction" */
  DirectionPkey = 'direction_pkey',
}

export enum TimetablesRouteDirectionEnum {
  /** clockwise */
  Anticlockwise = 'anticlockwise',
  /** anticlockwise */
  Clockwise = 'clockwise',
  /** westbound */
  Eastbound = 'eastbound',
  /** outbound */
  Inbound = 'inbound',
  /** southbound */
  Northbound = 'northbound',
  /** inbound */
  Outbound = 'outbound',
  /** northbound */
  Southbound = 'southbound',
  /** eastbound */
  Westbound = 'westbound',
}

/** input type for inserting data into table "route.direction" */
export type TimetablesRouteDirectionInsertInput = {
  /** The name of the route direction */
  direction?: InputMaybe<Scalars['String']>;
  /** The opposite direction */
  the_opposite_of_direction?: InputMaybe<TimetablesRouteDirectionEnum>;
};

/** aggregate max on columns */
export type TimetablesRouteDirectionMaxFields = {
  __typename?: 'timetables_route_direction_max_fields';
  /** The name of the route direction */
  direction?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type TimetablesRouteDirectionMinFields = {
  __typename?: 'timetables_route_direction_min_fields';
  /** The name of the route direction */
  direction?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "route.direction" */
export type TimetablesRouteDirectionMutationResponse = {
  __typename?: 'timetables_route_direction_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<TimetablesRouteDirection>;
};

/** on_conflict condition type for table "route.direction" */
export type TimetablesRouteDirectionOnConflict = {
  constraint: TimetablesRouteDirectionConstraint;
  update_columns?: Array<TimetablesRouteDirectionUpdateColumn>;
  where?: InputMaybe<TimetablesRouteDirectionBoolExp>;
};

/** Ordering options when selecting data from "route.direction". */
export type TimetablesRouteDirectionOrderBy = {
  direction?: InputMaybe<OrderBy>;
  the_opposite_of_direction?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: route.direction */
export type TimetablesRouteDirectionPkColumnsInput = {
  /** The name of the route direction */
  direction: Scalars['String'];
};

/** select columns of table "route.direction" */
export enum TimetablesRouteDirectionSelectColumn {
  /** column name */
  Direction = 'direction',
  /** column name */
  TheOppositeOfDirection = 'the_opposite_of_direction',
}

/** input type for updating data in table "route.direction" */
export type TimetablesRouteDirectionSetInput = {
  /** The name of the route direction */
  direction?: InputMaybe<Scalars['String']>;
  /** The opposite direction */
  the_opposite_of_direction?: InputMaybe<TimetablesRouteDirectionEnum>;
};

/** Streaming cursor of the table "route_direction" */
export type TimetablesRouteDirectionStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TimetablesRouteDirectionStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesRouteDirectionStreamCursorValueInput = {
  /** The name of the route direction */
  direction?: InputMaybe<Scalars['String']>;
  /** The opposite direction */
  the_opposite_of_direction?: InputMaybe<TimetablesRouteDirectionEnum>;
};

/** update columns of table "route.direction" */
export enum TimetablesRouteDirectionUpdateColumn {
  /** column name */
  Direction = 'direction',
  /** column name */
  TheOppositeOfDirection = 'the_opposite_of_direction',
}

export type TimetablesRouteDirectionUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TimetablesRouteDirectionSetInput>;
  /** filter the rows which have to be updated */
  where: TimetablesRouteDirectionBoolExp;
};

/** Type of line. https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:424 */
export type TimetablesRouteTypeOfLine = {
  __typename?: 'timetables_route_type_of_line';
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  type_of_line: Scalars['String'];
};

/** aggregated selection of "route.type_of_line" */
export type TimetablesRouteTypeOfLineAggregate = {
  __typename?: 'timetables_route_type_of_line_aggregate';
  aggregate?: Maybe<TimetablesRouteTypeOfLineAggregateFields>;
  nodes: Array<TimetablesRouteTypeOfLine>;
};

/** aggregate fields of "route.type_of_line" */
export type TimetablesRouteTypeOfLineAggregateFields = {
  __typename?: 'timetables_route_type_of_line_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<TimetablesRouteTypeOfLineMaxFields>;
  min?: Maybe<TimetablesRouteTypeOfLineMinFields>;
};

/** aggregate fields of "route.type_of_line" */
export type TimetablesRouteTypeOfLineAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TimetablesRouteTypeOfLineSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "route.type_of_line". All fields are combined with a logical 'AND'. */
export type TimetablesRouteTypeOfLineBoolExp = {
  _and?: InputMaybe<Array<TimetablesRouteTypeOfLineBoolExp>>;
  _not?: InputMaybe<TimetablesRouteTypeOfLineBoolExp>;
  _or?: InputMaybe<Array<TimetablesRouteTypeOfLineBoolExp>>;
  type_of_line?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "route.type_of_line" */
export enum TimetablesRouteTypeOfLineConstraint {
  /** unique or primary key constraint on columns "type_of_line" */
  TypeOfLinePkey = 'type_of_line_pkey',
}

/** input type for inserting data into table "route.type_of_line" */
export type TimetablesRouteTypeOfLineInsertInput = {
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  type_of_line?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type TimetablesRouteTypeOfLineMaxFields = {
  __typename?: 'timetables_route_type_of_line_max_fields';
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  type_of_line?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type TimetablesRouteTypeOfLineMinFields = {
  __typename?: 'timetables_route_type_of_line_min_fields';
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  type_of_line?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "route.type_of_line" */
export type TimetablesRouteTypeOfLineMutationResponse = {
  __typename?: 'timetables_route_type_of_line_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<TimetablesRouteTypeOfLine>;
};

/** on_conflict condition type for table "route.type_of_line" */
export type TimetablesRouteTypeOfLineOnConflict = {
  constraint: TimetablesRouteTypeOfLineConstraint;
  update_columns?: Array<TimetablesRouteTypeOfLineUpdateColumn>;
  where?: InputMaybe<TimetablesRouteTypeOfLineBoolExp>;
};

/** Ordering options when selecting data from "route.type_of_line". */
export type TimetablesRouteTypeOfLineOrderBy = {
  type_of_line?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: route.type_of_line */
export type TimetablesRouteTypeOfLinePkColumnsInput = {
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  type_of_line: Scalars['String'];
};

/** select columns of table "route.type_of_line" */
export enum TimetablesRouteTypeOfLineSelectColumn {
  /** column name */
  TypeOfLine = 'type_of_line',
}

/** input type for updating data in table "route.type_of_line" */
export type TimetablesRouteTypeOfLineSetInput = {
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  type_of_line?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "route_type_of_line" */
export type TimetablesRouteTypeOfLineStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TimetablesRouteTypeOfLineStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesRouteTypeOfLineStreamCursorValueInput = {
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  type_of_line?: InputMaybe<Scalars['String']>;
};

/** update columns of table "route.type_of_line" */
export enum TimetablesRouteTypeOfLineUpdateColumn {
  /** column name */
  TypeOfLine = 'type_of_line',
}

export type TimetablesRouteTypeOfLineUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TimetablesRouteTypeOfLineSetInput>;
  /** filter the rows which have to be updated */
  where: TimetablesRouteTypeOfLineBoolExp;
};

/** A type of day characterised by one or more properties which affect public transport operation. For example: weekday in school holidays. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:3:299  */
export type TimetablesServiceCalendarDayType = {
  __typename?: 'timetables_service_calendar_day_type';
  /** An array relationship */
  active_on_days_of_week: Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeek>;
  /** An aggregate relationship */
  active_on_days_of_week_aggregate: TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAggregate;
  day_type_id: Scalars['uuid'];
  /** The label for the DAY TYPE. Used for identifying the DAY TYPE when importing data from Hastus. Includes both basic (e.g. "Monday-Thursday") and special ("Easter Sunday") day types */
  label: Scalars['String'];
  /** Human-readable name for the DAY TYPE */
  name_i18n: Scalars['jsonb'];
  /** An array relationship */
  vehicle_services: Array<TimetablesVehicleServiceVehicleService>;
  /** An aggregate relationship */
  vehicle_services_aggregate: TimetablesVehicleServiceVehicleServiceAggregate;
};

/** A type of day characterised by one or more properties which affect public transport operation. For example: weekday in school holidays. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:3:299  */
export type TimetablesServiceCalendarDayTypeActiveOnDaysOfWeekArgs = {
  distinct_on?: InputMaybe<
    Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<
    Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekOrderBy>
  >;
  where?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>;
};

/** A type of day characterised by one or more properties which affect public transport operation. For example: weekday in school holidays. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:3:299  */
export type TimetablesServiceCalendarDayTypeActiveOnDaysOfWeekAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<
    Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekOrderBy>
  >;
  where?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>;
};

/** A type of day characterised by one or more properties which affect public transport operation. For example: weekday in school holidays. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:3:299  */
export type TimetablesServiceCalendarDayTypeNameI18nArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** A type of day characterised by one or more properties which affect public transport operation. For example: weekday in school holidays. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:3:299  */
export type TimetablesServiceCalendarDayTypeVehicleServicesArgs = {
  distinct_on?: InputMaybe<
    Array<TimetablesVehicleServiceVehicleServiceSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<TimetablesVehicleServiceVehicleServiceOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
};

/** A type of day characterised by one or more properties which affect public transport operation. For example: weekday in school holidays. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:3:299  */
export type TimetablesServiceCalendarDayTypeVehicleServicesAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<TimetablesVehicleServiceVehicleServiceSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<TimetablesVehicleServiceVehicleServiceOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
};

/** Tells on which days of week a particular DAY TYPE is active */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeek = {
  __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week';
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  day_of_week: Scalars['Int'];
  /** An object relationship */
  day_type: TimetablesServiceCalendarDayType;
  /** The DAY TYPE for which we define the activeness */
  day_type_id: Scalars['uuid'];
};

/** aggregated selection of "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAggregate = {
  __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_aggregate';
  aggregate?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAggregateFields>;
  nodes: Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeek>;
};

/** aggregate fields of "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAggregateFields = {
  __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_aggregate_fields';
  avg?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMaxFields>;
  min?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMinFields>;
  stddev?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStddevFields>;
  stddev_pop?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStddevPopFields>;
  stddev_samp?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStddevSampFields>;
  sum?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSumFields>;
  var_pop?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekVarPopFields>;
  var_samp?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekVarSampFields>;
  variance?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekVarianceFields>;
};

/** aggregate fields of "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAggregateFieldsCountArgs =
  {
    columns?: InputMaybe<
      Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
  };

/** order by aggregate values of table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAggregateOrderBy =
  {
    avg?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAvgOrderBy>;
    count?: InputMaybe<OrderBy>;
    max?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMaxOrderBy>;
    min?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMinOrderBy>;
    stddev?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStddevOrderBy>;
    stddev_pop?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStddevPopOrderBy>;
    stddev_samp?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStddevSampOrderBy>;
    sum?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSumOrderBy>;
    var_pop?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekVarPopOrderBy>;
    var_samp?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekVarSampOrderBy>;
    variance?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekVarianceOrderBy>;
  };

/** input type for inserting array relation for remote table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekArrRelInsertInput =
  {
    data: Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekInsertInput>;
    /** upsert condition */
    on_conflict?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekOnConflict>;
  };

/** aggregate avg on columns */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAvgFields = {
  __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_avg_fields';
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  day_of_week?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAvgOrderBy = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  day_of_week?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "service_calendar.day_type_active_on_day_of_week". All fields are combined with a logical 'AND'. */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp = {
  _and?: InputMaybe<
    Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>
  >;
  _not?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>;
  _or?: InputMaybe<
    Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>
  >;
  day_of_week?: InputMaybe<IntComparisonExp>;
  day_type?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
  day_type_id?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "service_calendar.day_type_active_on_day_of_week" */
export enum TimetablesServiceCalendarDayTypeActiveOnDayOfWeekConstraint {
  /** unique or primary key constraint on columns "day_of_week", "day_type_id" */
  DayTypeActiveOnDayOfWeekPkey = 'day_type_active_on_day_of_week_pkey',
}

/** input type for incrementing numeric columns in table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekIncInput = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  day_of_week?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekInsertInput = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  day_of_week?: InputMaybe<Scalars['Int']>;
  day_type?: InputMaybe<TimetablesServiceCalendarDayTypeObjRelInsertInput>;
  /** The DAY TYPE for which we define the activeness */
  day_type_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMaxFields = {
  __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_max_fields';
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  day_of_week?: Maybe<Scalars['Int']>;
  /** The DAY TYPE for which we define the activeness */
  day_type_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMaxOrderBy = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  day_of_week?: InputMaybe<OrderBy>;
  /** The DAY TYPE for which we define the activeness */
  day_type_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMinFields = {
  __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_min_fields';
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  day_of_week?: Maybe<Scalars['Int']>;
  /** The DAY TYPE for which we define the activeness */
  day_type_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMinOrderBy = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  day_of_week?: InputMaybe<OrderBy>;
  /** The DAY TYPE for which we define the activeness */
  day_type_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMutationResponse =
  {
    __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_mutation_response';
    /** number of rows affected by the mutation */
    affected_rows: Scalars['Int'];
    /** data from the rows affected by the mutation */
    returning: Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeek>;
  };

/** on_conflict condition type for table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekOnConflict = {
  constraint: TimetablesServiceCalendarDayTypeActiveOnDayOfWeekConstraint;
  update_columns?: Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekUpdateColumn>;
  where?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>;
};

/** Ordering options when selecting data from "service_calendar.day_type_active_on_day_of_week". */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekOrderBy = {
  day_of_week?: InputMaybe<OrderBy>;
  day_type?: InputMaybe<TimetablesServiceCalendarDayTypeOrderBy>;
  day_type_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: service_calendar.day_type_active_on_day_of_week */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekPkColumnsInput = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  day_of_week: Scalars['Int'];
  /** The DAY TYPE for which we define the activeness */
  day_type_id: Scalars['uuid'];
};

/** select columns of table "service_calendar.day_type_active_on_day_of_week" */
export enum TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSelectColumn {
  /** column name */
  DayOfWeek = 'day_of_week',
  /** column name */
  DayTypeId = 'day_type_id',
}

/** input type for updating data in table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSetInput = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  day_of_week?: InputMaybe<Scalars['Int']>;
  /** The DAY TYPE for which we define the activeness */
  day_type_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStddevFields = {
  __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_stddev_fields';
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  day_of_week?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStddevOrderBy = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  day_of_week?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStddevPopFields = {
  __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_stddev_pop_fields';
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  day_of_week?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStddevPopOrderBy =
  {
    /** ISO week day definition (1 = Monday, 7 = Sunday) */
    day_of_week?: InputMaybe<OrderBy>;
  };

/** aggregate stddev_samp on columns */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStddevSampFields =
  {
    __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_stddev_samp_fields';
    /** ISO week day definition (1 = Monday, 7 = Sunday) */
    day_of_week?: Maybe<Scalars['Float']>;
  };

/** order by stddev_samp() on columns of table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStddevSampOrderBy =
  {
    /** ISO week day definition (1 = Monday, 7 = Sunday) */
    day_of_week?: InputMaybe<OrderBy>;
  };

/** Streaming cursor of the table "service_calendar_day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStreamCursorInput =
  {
    /** Stream column input with initial value */
    initial_value: TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<TimetablesCursorOrdering>;
  };

/** Initial value of the column from where the streaming should start */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStreamCursorValueInput =
  {
    /** ISO week day definition (1 = Monday, 7 = Sunday) */
    day_of_week?: InputMaybe<Scalars['Int']>;
    /** The DAY TYPE for which we define the activeness */
    day_type_id?: InputMaybe<Scalars['uuid']>;
  };

/** aggregate sum on columns */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSumFields = {
  __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_sum_fields';
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  day_of_week?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSumOrderBy = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  day_of_week?: InputMaybe<OrderBy>;
};

/** update columns of table "service_calendar.day_type_active_on_day_of_week" */
export enum TimetablesServiceCalendarDayTypeActiveOnDayOfWeekUpdateColumn {
  /** column name */
  DayOfWeek = 'day_of_week',
  /** column name */
  DayTypeId = 'day_type_id',
}

export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSetInput>;
  /** filter the rows which have to be updated */
  where: TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp;
};

/** aggregate var_pop on columns */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekVarPopFields = {
  __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_var_pop_fields';
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  day_of_week?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekVarPopOrderBy = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  day_of_week?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekVarSampFields = {
  __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_var_samp_fields';
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  day_of_week?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekVarSampOrderBy = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  day_of_week?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekVarianceFields = {
  __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_variance_fields';
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  day_of_week?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekVarianceOrderBy = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  day_of_week?: InputMaybe<OrderBy>;
};

/** aggregated selection of "service_calendar.day_type" */
export type TimetablesServiceCalendarDayTypeAggregate = {
  __typename?: 'timetables_service_calendar_day_type_aggregate';
  aggregate?: Maybe<TimetablesServiceCalendarDayTypeAggregateFields>;
  nodes: Array<TimetablesServiceCalendarDayType>;
};

/** aggregate fields of "service_calendar.day_type" */
export type TimetablesServiceCalendarDayTypeAggregateFields = {
  __typename?: 'timetables_service_calendar_day_type_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<TimetablesServiceCalendarDayTypeMaxFields>;
  min?: Maybe<TimetablesServiceCalendarDayTypeMinFields>;
};

/** aggregate fields of "service_calendar.day_type" */
export type TimetablesServiceCalendarDayTypeAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TimetablesServiceCalendarDayTypeSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type TimetablesServiceCalendarDayTypeAppendInput = {
  /** Human-readable name for the DAY TYPE */
  name_i18n?: InputMaybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "service_calendar.day_type". All fields are combined with a logical 'AND'. */
export type TimetablesServiceCalendarDayTypeBoolExp = {
  _and?: InputMaybe<Array<TimetablesServiceCalendarDayTypeBoolExp>>;
  _not?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
  _or?: InputMaybe<Array<TimetablesServiceCalendarDayTypeBoolExp>>;
  active_on_days_of_week?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>;
  active_on_days_of_week_aggregate?: InputMaybe<ServiceCalendarDayTypeActiveOnDayOfWeekAggregateBoolExp>;
  day_type_id?: InputMaybe<UuidComparisonExp>;
  label?: InputMaybe<StringComparisonExp>;
  name_i18n?: InputMaybe<JsonbComparisonExp>;
  vehicle_services?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
  vehicle_services_aggregate?: InputMaybe<VehicleServiceVehicleServiceAggregateBoolExp>;
};

/** unique or primary key constraints on table "service_calendar.day_type" */
export enum TimetablesServiceCalendarDayTypeConstraint {
  /** unique or primary key constraint on columns "day_type_id" */
  DayTypePkey = 'day_type_pkey',
  /** unique or primary key constraint on columns "label" */
  ServiceCalendarDayTypeLabelIdx = 'service_calendar_day_type_label_idx',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type TimetablesServiceCalendarDayTypeDeleteAtPathInput = {
  /** Human-readable name for the DAY TYPE */
  name_i18n?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type TimetablesServiceCalendarDayTypeDeleteElemInput = {
  /** Human-readable name for the DAY TYPE */
  name_i18n?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type TimetablesServiceCalendarDayTypeDeleteKeyInput = {
  /** Human-readable name for the DAY TYPE */
  name_i18n?: InputMaybe<Scalars['String']>;
};

/** input type for inserting data into table "service_calendar.day_type" */
export type TimetablesServiceCalendarDayTypeInsertInput = {
  active_on_days_of_week?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekArrRelInsertInput>;
  day_type_id?: InputMaybe<Scalars['uuid']>;
  /** The label for the DAY TYPE. Used for identifying the DAY TYPE when importing data from Hastus. Includes both basic (e.g. "Monday-Thursday") and special ("Easter Sunday") day types */
  label?: InputMaybe<Scalars['String']>;
  /** Human-readable name for the DAY TYPE */
  name_i18n?: InputMaybe<Scalars['jsonb']>;
  vehicle_services?: InputMaybe<TimetablesVehicleServiceVehicleServiceArrRelInsertInput>;
};

/** aggregate max on columns */
export type TimetablesServiceCalendarDayTypeMaxFields = {
  __typename?: 'timetables_service_calendar_day_type_max_fields';
  day_type_id?: Maybe<Scalars['uuid']>;
  /** The label for the DAY TYPE. Used for identifying the DAY TYPE when importing data from Hastus. Includes both basic (e.g. "Monday-Thursday") and special ("Easter Sunday") day types */
  label?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type TimetablesServiceCalendarDayTypeMinFields = {
  __typename?: 'timetables_service_calendar_day_type_min_fields';
  day_type_id?: Maybe<Scalars['uuid']>;
  /** The label for the DAY TYPE. Used for identifying the DAY TYPE when importing data from Hastus. Includes both basic (e.g. "Monday-Thursday") and special ("Easter Sunday") day types */
  label?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "service_calendar.day_type" */
export type TimetablesServiceCalendarDayTypeMutationResponse = {
  __typename?: 'timetables_service_calendar_day_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<TimetablesServiceCalendarDayType>;
};

/** input type for inserting object relation for remote table "service_calendar.day_type" */
export type TimetablesServiceCalendarDayTypeObjRelInsertInput = {
  data: TimetablesServiceCalendarDayTypeInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<TimetablesServiceCalendarDayTypeOnConflict>;
};

/** on_conflict condition type for table "service_calendar.day_type" */
export type TimetablesServiceCalendarDayTypeOnConflict = {
  constraint: TimetablesServiceCalendarDayTypeConstraint;
  update_columns?: Array<TimetablesServiceCalendarDayTypeUpdateColumn>;
  where?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
};

/** Ordering options when selecting data from "service_calendar.day_type". */
export type TimetablesServiceCalendarDayTypeOrderBy = {
  active_on_days_of_week_aggregate?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAggregateOrderBy>;
  day_type_id?: InputMaybe<OrderBy>;
  label?: InputMaybe<OrderBy>;
  name_i18n?: InputMaybe<OrderBy>;
  vehicle_services_aggregate?: InputMaybe<TimetablesVehicleServiceVehicleServiceAggregateOrderBy>;
};

/** primary key columns input for table: service_calendar.day_type */
export type TimetablesServiceCalendarDayTypePkColumnsInput = {
  day_type_id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type TimetablesServiceCalendarDayTypePrependInput = {
  /** Human-readable name for the DAY TYPE */
  name_i18n?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "service_calendar.day_type" */
export enum TimetablesServiceCalendarDayTypeSelectColumn {
  /** column name */
  DayTypeId = 'day_type_id',
  /** column name */
  Label = 'label',
  /** column name */
  NameI18n = 'name_i18n',
}

/** input type for updating data in table "service_calendar.day_type" */
export type TimetablesServiceCalendarDayTypeSetInput = {
  day_type_id?: InputMaybe<Scalars['uuid']>;
  /** The label for the DAY TYPE. Used for identifying the DAY TYPE when importing data from Hastus. Includes both basic (e.g. "Monday-Thursday") and special ("Easter Sunday") day types */
  label?: InputMaybe<Scalars['String']>;
  /** Human-readable name for the DAY TYPE */
  name_i18n?: InputMaybe<Scalars['jsonb']>;
};

/** Streaming cursor of the table "service_calendar_day_type" */
export type TimetablesServiceCalendarDayTypeStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TimetablesServiceCalendarDayTypeStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesServiceCalendarDayTypeStreamCursorValueInput = {
  day_type_id?: InputMaybe<Scalars['uuid']>;
  /** The label for the DAY TYPE. Used for identifying the DAY TYPE when importing data from Hastus. Includes both basic (e.g. "Monday-Thursday") and special ("Easter Sunday") day types */
  label?: InputMaybe<Scalars['String']>;
  /** Human-readable name for the DAY TYPE */
  name_i18n?: InputMaybe<Scalars['jsonb']>;
};

/** update columns of table "service_calendar.day_type" */
export enum TimetablesServiceCalendarDayTypeUpdateColumn {
  /** column name */
  DayTypeId = 'day_type_id',
  /** column name */
  Label = 'label',
  /** column name */
  NameI18n = 'name_i18n',
}

export type TimetablesServiceCalendarDayTypeUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<TimetablesServiceCalendarDayTypeAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<TimetablesServiceCalendarDayTypeDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<TimetablesServiceCalendarDayTypeDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<TimetablesServiceCalendarDayTypeDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<TimetablesServiceCalendarDayTypePrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TimetablesServiceCalendarDayTypeSetInput>;
  /** filter the rows which have to be updated */
  where: TimetablesServiceCalendarDayTypeBoolExp;
};

export type TimetablesServiceCalendarGetActiveDayTypesForDateArgs = {
  observation_date?: InputMaybe<Scalars['date']>;
};

/** Models substitute public transit as (1) a reference day or (2) indicating that public transit does not occur on certain date. Substitute operating days are always bound to a type of line. */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineType = {
  __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type';
  /** Calculated timestamp for the instant from which the substituting public transit comes into effect. */
  begin_datetime: Scalars['timestamptz'];
  /** The time from which the substituting public transit comes into effect. If NULL, the substitution is in effect from the start of the operating day. When substitute_day_of_week is not NULL (reference day case), vehicle journeys prior to this time are not operated. When substitute_day_of_week is NULL (no traffic case), the vehicle journeys before this time are operated as usual. */
  begin_time?: Maybe<Scalars['interval']>;
  created_at: Scalars['timestamptz'];
  /** Calculated timestamp for the instant (exclusive) until which the substituting public transit is in effect. */
  end_datetime: Scalars['timestamptz'];
  /** The time (exclusive) until which the substituting public transit is valid. If NULL, the substitution is in effect until the end of the operating day. When substitute_day_of_week is not NULL (reference day case), vehicle journeys starting from this time are not operated. When substitute_day_of_week is NULL (no traffic case), the vehicle journeys starting from this time are operated as usual. */
  end_time?: Maybe<Scalars['interval']>;
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  substitute_day_of_week?: Maybe<Scalars['Int']>;
  substitute_operating_day_by_line_type_id: Scalars['uuid'];
  /** The id of the substitute operating period */
  substitute_operating_period_id: Scalars['uuid'];
  /** The date of operating day being superseded. */
  superseded_date: Scalars['date'];
  timezone: Scalars['String'];
  /** The type of line this substitute operating day is bound to. */
  type_of_line: Scalars['String'];
};

/** aggregated selection of "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAggregate =
  {
    __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_aggregate';
    aggregate?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAggregateFields>;
    nodes: Array<TimetablesServiceCalendarSubstituteOperatingDayByLineType>;
  };

/** aggregate fields of "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAggregateFields =
  {
    __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_aggregate_fields';
    avg?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAvgFields>;
    count: Scalars['Int'];
    max?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMaxFields>;
    min?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMinFields>;
    stddev?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStddevFields>;
    stddev_pop?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStddevPopFields>;
    stddev_samp?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStddevSampFields>;
    sum?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSumFields>;
    var_pop?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeVarPopFields>;
    var_samp?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeVarSampFields>;
    variance?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeVarianceFields>;
  };

/** aggregate fields of "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAggregateFieldsCountArgs =
  {
    columns?: InputMaybe<
      Array<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
  };

/** order by aggregate values of table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAggregateOrderBy =
  {
    avg?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAvgOrderBy>;
    count?: InputMaybe<OrderBy>;
    max?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMaxOrderBy>;
    min?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMinOrderBy>;
    stddev?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStddevOrderBy>;
    stddev_pop?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStddevPopOrderBy>;
    stddev_samp?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStddevSampOrderBy>;
    sum?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSumOrderBy>;
    var_pop?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeVarPopOrderBy>;
    var_samp?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeVarSampOrderBy>;
    variance?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeVarianceOrderBy>;
  };

/** input type for inserting array relation for remote table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeArrRelInsertInput =
  {
    data: Array<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeInsertInput>;
    /** upsert condition */
    on_conflict?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOnConflict>;
  };

/** aggregate avg on columns */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAvgFields =
  {
    __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_avg_fields';
    /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
    substitute_day_of_week?: Maybe<Scalars['Float']>;
  };

/** order by avg() on columns of table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAvgOrderBy =
  {
    /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
    substitute_day_of_week?: InputMaybe<OrderBy>;
  };

/** Boolean expression to filter rows from the table "service_calendar.substitute_operating_day_by_line_type". All fields are combined with a logical 'AND'. */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp = {
  _and?: InputMaybe<
    Array<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>
  >;
  _not?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>;
  _or?: InputMaybe<
    Array<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>
  >;
  begin_datetime?: InputMaybe<TimestamptzComparisonExp>;
  begin_time?: InputMaybe<IntervalComparisonExp>;
  created_at?: InputMaybe<TimestamptzComparisonExp>;
  end_datetime?: InputMaybe<TimestamptzComparisonExp>;
  end_time?: InputMaybe<IntervalComparisonExp>;
  substitute_day_of_week?: InputMaybe<IntComparisonExp>;
  substitute_operating_day_by_line_type_id?: InputMaybe<UuidComparisonExp>;
  substitute_operating_period_id?: InputMaybe<UuidComparisonExp>;
  superseded_date?: InputMaybe<DateComparisonExp>;
  timezone?: InputMaybe<StringComparisonExp>;
  type_of_line?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "service_calendar.substitute_operating_day_by_line_type" */
export enum TimetablesServiceCalendarSubstituteOperatingDayByLineTypeConstraint {
  /** unique or primary key constraint on columns "substitute_operating_day_by_line_type_id" */
  SubstituteOperatingDayByLineTypePkey = 'substitute_operating_day_by_line_type_pkey',
}

/** input type for incrementing numeric columns in table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeIncInput =
  {
    /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
    substitute_day_of_week?: InputMaybe<Scalars['Int']>;
  };

/** input type for inserting data into table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeInsertInput =
  {
    /** The time from which the substituting public transit comes into effect. If NULL, the substitution is in effect from the start of the operating day. When substitute_day_of_week is not NULL (reference day case), vehicle journeys prior to this time are not operated. When substitute_day_of_week is NULL (no traffic case), the vehicle journeys before this time are operated as usual. */
    begin_time?: InputMaybe<Scalars['interval']>;
    created_at?: InputMaybe<Scalars['timestamptz']>;
    /** The time (exclusive) until which the substituting public transit is valid. If NULL, the substitution is in effect until the end of the operating day. When substitute_day_of_week is not NULL (reference day case), vehicle journeys starting from this time are not operated. When substitute_day_of_week is NULL (no traffic case), the vehicle journeys starting from this time are operated as usual. */
    end_time?: InputMaybe<Scalars['interval']>;
    /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
    substitute_day_of_week?: InputMaybe<Scalars['Int']>;
    substitute_operating_day_by_line_type_id?: InputMaybe<Scalars['uuid']>;
    /** The id of the substitute operating period */
    substitute_operating_period_id?: InputMaybe<Scalars['uuid']>;
    /** The date of operating day being superseded. */
    superseded_date?: InputMaybe<Scalars['date']>;
    timezone?: InputMaybe<Scalars['String']>;
    /** The type of line this substitute operating day is bound to. */
    type_of_line?: InputMaybe<Scalars['String']>;
  };

/** aggregate max on columns */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMaxFields =
  {
    __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_max_fields';
    /** Calculated timestamp for the instant from which the substituting public transit comes into effect. */
    begin_datetime?: Maybe<Scalars['timestamptz']>;
    created_at?: Maybe<Scalars['timestamptz']>;
    /** Calculated timestamp for the instant (exclusive) until which the substituting public transit is in effect. */
    end_datetime?: Maybe<Scalars['timestamptz']>;
    /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
    substitute_day_of_week?: Maybe<Scalars['Int']>;
    substitute_operating_day_by_line_type_id?: Maybe<Scalars['uuid']>;
    /** The id of the substitute operating period */
    substitute_operating_period_id?: Maybe<Scalars['uuid']>;
    /** The date of operating day being superseded. */
    superseded_date?: Maybe<Scalars['date']>;
    timezone?: Maybe<Scalars['String']>;
    /** The type of line this substitute operating day is bound to. */
    type_of_line?: Maybe<Scalars['String']>;
  };

/** order by max() on columns of table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMaxOrderBy =
  {
    /** Calculated timestamp for the instant from which the substituting public transit comes into effect. */
    begin_datetime?: InputMaybe<OrderBy>;
    created_at?: InputMaybe<OrderBy>;
    /** Calculated timestamp for the instant (exclusive) until which the substituting public transit is in effect. */
    end_datetime?: InputMaybe<OrderBy>;
    /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
    substitute_day_of_week?: InputMaybe<OrderBy>;
    substitute_operating_day_by_line_type_id?: InputMaybe<OrderBy>;
    /** The id of the substitute operating period */
    substitute_operating_period_id?: InputMaybe<OrderBy>;
    /** The date of operating day being superseded. */
    superseded_date?: InputMaybe<OrderBy>;
    timezone?: InputMaybe<OrderBy>;
    /** The type of line this substitute operating day is bound to. */
    type_of_line?: InputMaybe<OrderBy>;
  };

/** aggregate min on columns */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMinFields =
  {
    __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_min_fields';
    /** Calculated timestamp for the instant from which the substituting public transit comes into effect. */
    begin_datetime?: Maybe<Scalars['timestamptz']>;
    created_at?: Maybe<Scalars['timestamptz']>;
    /** Calculated timestamp for the instant (exclusive) until which the substituting public transit is in effect. */
    end_datetime?: Maybe<Scalars['timestamptz']>;
    /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
    substitute_day_of_week?: Maybe<Scalars['Int']>;
    substitute_operating_day_by_line_type_id?: Maybe<Scalars['uuid']>;
    /** The id of the substitute operating period */
    substitute_operating_period_id?: Maybe<Scalars['uuid']>;
    /** The date of operating day being superseded. */
    superseded_date?: Maybe<Scalars['date']>;
    timezone?: Maybe<Scalars['String']>;
    /** The type of line this substitute operating day is bound to. */
    type_of_line?: Maybe<Scalars['String']>;
  };

/** order by min() on columns of table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMinOrderBy =
  {
    /** Calculated timestamp for the instant from which the substituting public transit comes into effect. */
    begin_datetime?: InputMaybe<OrderBy>;
    created_at?: InputMaybe<OrderBy>;
    /** Calculated timestamp for the instant (exclusive) until which the substituting public transit is in effect. */
    end_datetime?: InputMaybe<OrderBy>;
    /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
    substitute_day_of_week?: InputMaybe<OrderBy>;
    substitute_operating_day_by_line_type_id?: InputMaybe<OrderBy>;
    /** The id of the substitute operating period */
    substitute_operating_period_id?: InputMaybe<OrderBy>;
    /** The date of operating day being superseded. */
    superseded_date?: InputMaybe<OrderBy>;
    timezone?: InputMaybe<OrderBy>;
    /** The type of line this substitute operating day is bound to. */
    type_of_line?: InputMaybe<OrderBy>;
  };

/** response of any mutation on the table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMutationResponse =
  {
    __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_mutation_response';
    /** number of rows affected by the mutation */
    affected_rows: Scalars['Int'];
    /** data from the rows affected by the mutation */
    returning: Array<TimetablesServiceCalendarSubstituteOperatingDayByLineType>;
  };

/** input type for inserting object relation for remote table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeObjRelInsertInput =
  {
    data: TimetablesServiceCalendarSubstituteOperatingDayByLineTypeInsertInput;
    /** upsert condition */
    on_conflict?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOnConflict>;
  };

/** on_conflict condition type for table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOnConflict =
  {
    constraint: TimetablesServiceCalendarSubstituteOperatingDayByLineTypeConstraint;
    update_columns?: Array<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeUpdateColumn>;
    where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>;
  };

/** Ordering options when selecting data from "service_calendar.substitute_operating_day_by_line_type". */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOrderBy = {
  begin_datetime?: InputMaybe<OrderBy>;
  begin_time?: InputMaybe<OrderBy>;
  created_at?: InputMaybe<OrderBy>;
  end_datetime?: InputMaybe<OrderBy>;
  end_time?: InputMaybe<OrderBy>;
  substitute_day_of_week?: InputMaybe<OrderBy>;
  substitute_operating_day_by_line_type_id?: InputMaybe<OrderBy>;
  substitute_operating_period_id?: InputMaybe<OrderBy>;
  superseded_date?: InputMaybe<OrderBy>;
  timezone?: InputMaybe<OrderBy>;
  type_of_line?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: service_calendar.substitute_operating_day_by_line_type */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypePkColumnsInput =
  {
    substitute_operating_day_by_line_type_id: Scalars['uuid'];
  };

/** select columns of table "service_calendar.substitute_operating_day_by_line_type" */
export enum TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSelectColumn {
  /** column name */
  BeginDatetime = 'begin_datetime',
  /** column name */
  BeginTime = 'begin_time',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndDatetime = 'end_datetime',
  /** column name */
  EndTime = 'end_time',
  /** column name */
  SubstituteDayOfWeek = 'substitute_day_of_week',
  /** column name */
  SubstituteOperatingDayByLineTypeId = 'substitute_operating_day_by_line_type_id',
  /** column name */
  SubstituteOperatingPeriodId = 'substitute_operating_period_id',
  /** column name */
  SupersededDate = 'superseded_date',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  TypeOfLine = 'type_of_line',
}

/** input type for updating data in table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSetInput =
  {
    /** The time from which the substituting public transit comes into effect. If NULL, the substitution is in effect from the start of the operating day. When substitute_day_of_week is not NULL (reference day case), vehicle journeys prior to this time are not operated. When substitute_day_of_week is NULL (no traffic case), the vehicle journeys before this time are operated as usual. */
    begin_time?: InputMaybe<Scalars['interval']>;
    created_at?: InputMaybe<Scalars['timestamptz']>;
    /** The time (exclusive) until which the substituting public transit is valid. If NULL, the substitution is in effect until the end of the operating day. When substitute_day_of_week is not NULL (reference day case), vehicle journeys starting from this time are not operated. When substitute_day_of_week is NULL (no traffic case), the vehicle journeys starting from this time are operated as usual. */
    end_time?: InputMaybe<Scalars['interval']>;
    /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
    substitute_day_of_week?: InputMaybe<Scalars['Int']>;
    substitute_operating_day_by_line_type_id?: InputMaybe<Scalars['uuid']>;
    /** The id of the substitute operating period */
    substitute_operating_period_id?: InputMaybe<Scalars['uuid']>;
    /** The date of operating day being superseded. */
    superseded_date?: InputMaybe<Scalars['date']>;
    timezone?: InputMaybe<Scalars['String']>;
    /** The type of line this substitute operating day is bound to. */
    type_of_line?: InputMaybe<Scalars['String']>;
  };

/** aggregate stddev on columns */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStddevFields =
  {
    __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_stddev_fields';
    /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
    substitute_day_of_week?: Maybe<Scalars['Float']>;
  };

/** order by stddev() on columns of table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStddevOrderBy =
  {
    /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
    substitute_day_of_week?: InputMaybe<OrderBy>;
  };

/** aggregate stddev_pop on columns */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStddevPopFields =
  {
    __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_stddev_pop_fields';
    /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
    substitute_day_of_week?: Maybe<Scalars['Float']>;
  };

/** order by stddev_pop() on columns of table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStddevPopOrderBy =
  {
    /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
    substitute_day_of_week?: InputMaybe<OrderBy>;
  };

/** aggregate stddev_samp on columns */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStddevSampFields =
  {
    __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_stddev_samp_fields';
    /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
    substitute_day_of_week?: Maybe<Scalars['Float']>;
  };

/** order by stddev_samp() on columns of table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStddevSampOrderBy =
  {
    /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
    substitute_day_of_week?: InputMaybe<OrderBy>;
  };

/** Streaming cursor of the table "service_calendar_substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStreamCursorInput =
  {
    /** Stream column input with initial value */
    initial_value: TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<TimetablesCursorOrdering>;
  };

/** Initial value of the column from where the streaming should start */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStreamCursorValueInput =
  {
    /** Calculated timestamp for the instant from which the substituting public transit comes into effect. */
    begin_datetime?: InputMaybe<Scalars['timestamptz']>;
    /** The time from which the substituting public transit comes into effect. If NULL, the substitution is in effect from the start of the operating day. When substitute_day_of_week is not NULL (reference day case), vehicle journeys prior to this time are not operated. When substitute_day_of_week is NULL (no traffic case), the vehicle journeys before this time are operated as usual. */
    begin_time?: InputMaybe<Scalars['interval']>;
    created_at?: InputMaybe<Scalars['timestamptz']>;
    /** Calculated timestamp for the instant (exclusive) until which the substituting public transit is in effect. */
    end_datetime?: InputMaybe<Scalars['timestamptz']>;
    /** The time (exclusive) until which the substituting public transit is valid. If NULL, the substitution is in effect until the end of the operating day. When substitute_day_of_week is not NULL (reference day case), vehicle journeys starting from this time are not operated. When substitute_day_of_week is NULL (no traffic case), the vehicle journeys starting from this time are operated as usual. */
    end_time?: InputMaybe<Scalars['interval']>;
    /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
    substitute_day_of_week?: InputMaybe<Scalars['Int']>;
    substitute_operating_day_by_line_type_id?: InputMaybe<Scalars['uuid']>;
    /** The id of the substitute operating period */
    substitute_operating_period_id?: InputMaybe<Scalars['uuid']>;
    /** The date of operating day being superseded. */
    superseded_date?: InputMaybe<Scalars['date']>;
    timezone?: InputMaybe<Scalars['String']>;
    /** The type of line this substitute operating day is bound to. */
    type_of_line?: InputMaybe<Scalars['String']>;
  };

/** aggregate sum on columns */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSumFields =
  {
    __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_sum_fields';
    /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
    substitute_day_of_week?: Maybe<Scalars['Int']>;
  };

/** order by sum() on columns of table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSumOrderBy =
  {
    /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
    substitute_day_of_week?: InputMaybe<OrderBy>;
  };

/** update columns of table "service_calendar.substitute_operating_day_by_line_type" */
export enum TimetablesServiceCalendarSubstituteOperatingDayByLineTypeUpdateColumn {
  /** column name */
  BeginTime = 'begin_time',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndTime = 'end_time',
  /** column name */
  SubstituteDayOfWeek = 'substitute_day_of_week',
  /** column name */
  SubstituteOperatingDayByLineTypeId = 'substitute_operating_day_by_line_type_id',
  /** column name */
  SubstituteOperatingPeriodId = 'substitute_operating_period_id',
  /** column name */
  SupersededDate = 'superseded_date',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  TypeOfLine = 'type_of_line',
}

export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSetInput>;
  /** filter the rows which have to be updated */
  where: TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp;
};

/** aggregate var_pop on columns */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeVarPopFields =
  {
    __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_var_pop_fields';
    /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
    substitute_day_of_week?: Maybe<Scalars['Float']>;
  };

/** order by var_pop() on columns of table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeVarPopOrderBy =
  {
    /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
    substitute_day_of_week?: InputMaybe<OrderBy>;
  };

/** aggregate var_samp on columns */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeVarSampFields =
  {
    __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_var_samp_fields';
    /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
    substitute_day_of_week?: Maybe<Scalars['Float']>;
  };

/** order by var_samp() on columns of table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeVarSampOrderBy =
  {
    /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
    substitute_day_of_week?: InputMaybe<OrderBy>;
  };

/** aggregate variance on columns */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeVarianceFields =
  {
    __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_variance_fields';
    /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
    substitute_day_of_week?: Maybe<Scalars['Float']>;
  };

/** order by variance() on columns of table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeVarianceOrderBy =
  {
    /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
    substitute_day_of_week?: InputMaybe<OrderBy>;
  };

/** Models substitute operating period that consists of substitute operating days by line types. */
export type TimetablesServiceCalendarSubstituteOperatingPeriod = {
  __typename?: 'timetables_service_calendar_substitute_operating_period';
  /** Flag indicating whether operating period is preset or not. Preset operating periods have restrictions on the UI */
  is_preset: Scalars['Boolean'];
  /** Substitute operating period's name */
  period_name: Scalars['String'];
  /** An array relationship */
  substitute_operating_day_by_line_types: Array<TimetablesServiceCalendarSubstituteOperatingDayByLineType>;
  /** An aggregate relationship */
  substitute_operating_day_by_line_types_aggregate: TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAggregate;
  substitute_operating_period_id: Scalars['uuid'];
};

/** Models substitute operating period that consists of substitute operating days by line types. */
export type TimetablesServiceCalendarSubstituteOperatingPeriodSubstituteOperatingDayByLineTypesArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOrderBy>
    >;
    where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>;
  };

/** Models substitute operating period that consists of substitute operating days by line types. */
export type TimetablesServiceCalendarSubstituteOperatingPeriodSubstituteOperatingDayByLineTypesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOrderBy>
    >;
    where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>;
  };

/** aggregated selection of "service_calendar.substitute_operating_period" */
export type TimetablesServiceCalendarSubstituteOperatingPeriodAggregate = {
  __typename?: 'timetables_service_calendar_substitute_operating_period_aggregate';
  aggregate?: Maybe<TimetablesServiceCalendarSubstituteOperatingPeriodAggregateFields>;
  nodes: Array<TimetablesServiceCalendarSubstituteOperatingPeriod>;
};

/** aggregate fields of "service_calendar.substitute_operating_period" */
export type TimetablesServiceCalendarSubstituteOperatingPeriodAggregateFields =
  {
    __typename?: 'timetables_service_calendar_substitute_operating_period_aggregate_fields';
    count: Scalars['Int'];
    max?: Maybe<TimetablesServiceCalendarSubstituteOperatingPeriodMaxFields>;
    min?: Maybe<TimetablesServiceCalendarSubstituteOperatingPeriodMinFields>;
  };

/** aggregate fields of "service_calendar.substitute_operating_period" */
export type TimetablesServiceCalendarSubstituteOperatingPeriodAggregateFieldsCountArgs =
  {
    columns?: InputMaybe<
      Array<TimetablesServiceCalendarSubstituteOperatingPeriodSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
  };

/** Boolean expression to filter rows from the table "service_calendar.substitute_operating_period". All fields are combined with a logical 'AND'. */
export type TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp = {
  _and?: InputMaybe<
    Array<TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp>
  >;
  _not?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp>;
  _or?: InputMaybe<
    Array<TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp>
  >;
  is_preset?: InputMaybe<BooleanComparisonExp>;
  period_name?: InputMaybe<StringComparisonExp>;
  substitute_operating_day_by_line_types?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>;
  substitute_operating_day_by_line_types_aggregate?: InputMaybe<ServiceCalendarSubstituteOperatingDayByLineTypeAggregateBoolExp>;
  substitute_operating_period_id?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "service_calendar.substitute_operating_period" */
export enum TimetablesServiceCalendarSubstituteOperatingPeriodConstraint {
  /** unique or primary key constraint on columns "period_name" */
  SubstituteOperatingPeriodPeriodNameKey = 'substitute_operating_period_period_name_key',
  /** unique or primary key constraint on columns "substitute_operating_period_id" */
  SubstituteOperatingPeriodPkey = 'substitute_operating_period_pkey',
}

/** input type for inserting data into table "service_calendar.substitute_operating_period" */
export type TimetablesServiceCalendarSubstituteOperatingPeriodInsertInput = {
  /** Flag indicating whether operating period is preset or not. Preset operating periods have restrictions on the UI */
  is_preset?: InputMaybe<Scalars['Boolean']>;
  /** Substitute operating period's name */
  period_name?: InputMaybe<Scalars['String']>;
  substitute_operating_day_by_line_types?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeArrRelInsertInput>;
  substitute_operating_period_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type TimetablesServiceCalendarSubstituteOperatingPeriodMaxFields = {
  __typename?: 'timetables_service_calendar_substitute_operating_period_max_fields';
  /** Substitute operating period's name */
  period_name?: Maybe<Scalars['String']>;
  substitute_operating_period_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type TimetablesServiceCalendarSubstituteOperatingPeriodMinFields = {
  __typename?: 'timetables_service_calendar_substitute_operating_period_min_fields';
  /** Substitute operating period's name */
  period_name?: Maybe<Scalars['String']>;
  substitute_operating_period_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "service_calendar.substitute_operating_period" */
export type TimetablesServiceCalendarSubstituteOperatingPeriodMutationResponse =
  {
    __typename?: 'timetables_service_calendar_substitute_operating_period_mutation_response';
    /** number of rows affected by the mutation */
    affected_rows: Scalars['Int'];
    /** data from the rows affected by the mutation */
    returning: Array<TimetablesServiceCalendarSubstituteOperatingPeriod>;
  };

/** on_conflict condition type for table "service_calendar.substitute_operating_period" */
export type TimetablesServiceCalendarSubstituteOperatingPeriodOnConflict = {
  constraint: TimetablesServiceCalendarSubstituteOperatingPeriodConstraint;
  update_columns?: Array<TimetablesServiceCalendarSubstituteOperatingPeriodUpdateColumn>;
  where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp>;
};

/** Ordering options when selecting data from "service_calendar.substitute_operating_period". */
export type TimetablesServiceCalendarSubstituteOperatingPeriodOrderBy = {
  is_preset?: InputMaybe<OrderBy>;
  period_name?: InputMaybe<OrderBy>;
  substitute_operating_day_by_line_types_aggregate?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAggregateOrderBy>;
  substitute_operating_period_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: service_calendar.substitute_operating_period */
export type TimetablesServiceCalendarSubstituteOperatingPeriodPkColumnsInput = {
  substitute_operating_period_id: Scalars['uuid'];
};

/** select columns of table "service_calendar.substitute_operating_period" */
export enum TimetablesServiceCalendarSubstituteOperatingPeriodSelectColumn {
  /** column name */
  IsPreset = 'is_preset',
  /** column name */
  PeriodName = 'period_name',
  /** column name */
  SubstituteOperatingPeriodId = 'substitute_operating_period_id',
}

/** input type for updating data in table "service_calendar.substitute_operating_period" */
export type TimetablesServiceCalendarSubstituteOperatingPeriodSetInput = {
  /** Flag indicating whether operating period is preset or not. Preset operating periods have restrictions on the UI */
  is_preset?: InputMaybe<Scalars['Boolean']>;
  /** Substitute operating period's name */
  period_name?: InputMaybe<Scalars['String']>;
  substitute_operating_period_id?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "service_calendar_substitute_operating_period" */
export type TimetablesServiceCalendarSubstituteOperatingPeriodStreamCursorInput =
  {
    /** Stream column input with initial value */
    initial_value: TimetablesServiceCalendarSubstituteOperatingPeriodStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<TimetablesCursorOrdering>;
  };

/** Initial value of the column from where the streaming should start */
export type TimetablesServiceCalendarSubstituteOperatingPeriodStreamCursorValueInput =
  {
    /** Flag indicating whether operating period is preset or not. Preset operating periods have restrictions on the UI */
    is_preset?: InputMaybe<Scalars['Boolean']>;
    /** Substitute operating period's name */
    period_name?: InputMaybe<Scalars['String']>;
    substitute_operating_period_id?: InputMaybe<Scalars['uuid']>;
  };

/** update columns of table "service_calendar.substitute_operating_period" */
export enum TimetablesServiceCalendarSubstituteOperatingPeriodUpdateColumn {
  /** column name */
  IsPreset = 'is_preset',
  /** column name */
  PeriodName = 'period_name',
  /** column name */
  SubstituteOperatingPeriodId = 'substitute_operating_period_id',
}

export type TimetablesServiceCalendarSubstituteOperatingPeriodUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodSetInput>;
  /** filter the rows which have to be updated */
  where: TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp;
};

/** Reference the a SCHEDULED STOP POINT within a JOURNEY PATTERN. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:729  */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRef = {
  __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref';
  /** An object relationship */
  journey_pattern_ref: TimetablesJourneyPatternJourneyPatternRef;
  /** JOURNEY PATTERN to which the SCHEDULED STOP POINT belongs */
  journey_pattern_ref_id: Scalars['uuid'];
  scheduled_stop_point_in_journey_pattern_ref_id: Scalars['uuid'];
  scheduled_stop_point_instances: Array<ServicePatternScheduledStopPoint>;
  scheduled_stop_point_instances_aggregate: ServicePatternScheduledStopPointAggregate;
  /** The label of the SCHEDULED STOP POINT */
  scheduled_stop_point_label: Scalars['String'];
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  scheduled_stop_point_sequence: Scalars['Int'];
  /** An array relationship */
  timetabled_passing_times: Array<TimetablesPassingTimesTimetabledPassingTime>;
  /** An aggregate relationship */
  timetabled_passing_times_aggregate: TimetablesPassingTimesTimetabledPassingTimeAggregate;
  /** The label of the timing place associated with the referenced scheduled stop point in journey pattern */
  timing_place_label?: Maybe<Scalars['String']>;
};

/** Reference the a SCHEDULED STOP POINT within a JOURNEY PATTERN. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:729  */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefScheduledStopPointInstancesArgs =
  {
    distinct_on?: InputMaybe<
      Array<ServicePatternScheduledStopPointSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<ServicePatternScheduledStopPointOrderBy>>;
    where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
  };

/** Reference the a SCHEDULED STOP POINT within a JOURNEY PATTERN. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:729  */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefScheduledStopPointInstancesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<ServicePatternScheduledStopPointSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<ServicePatternScheduledStopPointOrderBy>>;
    where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
  };

/** Reference the a SCHEDULED STOP POINT within a JOURNEY PATTERN. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:729  */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefTimetabledPassingTimesArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesPassingTimesTimetabledPassingTimeSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesPassingTimesTimetabledPassingTimeOrderBy>
    >;
    where?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
  };

/** Reference the a SCHEDULED STOP POINT within a JOURNEY PATTERN. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:729  */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefTimetabledPassingTimesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesPassingTimesTimetabledPassingTimeSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesPassingTimesTimetabledPassingTimeOrderBy>
    >;
    where?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
  };

/** aggregated selection of "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefAggregate =
  {
    __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_aggregate';
    aggregate?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefAggregateFields>;
    nodes: Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRef>;
  };

/** aggregate fields of "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefAggregateFields =
  {
    __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_aggregate_fields';
    avg?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefAvgFields>;
    count: Scalars['Int'];
    max?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefMaxFields>;
    min?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefMinFields>;
    stddev?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefStddevFields>;
    stddev_pop?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefStddevPopFields>;
    stddev_samp?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefStddevSampFields>;
    sum?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSumFields>;
    var_pop?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefVarPopFields>;
    var_samp?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefVarSampFields>;
    variance?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefVarianceFields>;
  };

/** aggregate fields of "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefAggregateFieldsCountArgs =
  {
    columns?: InputMaybe<
      Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
  };

/** order by aggregate values of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefAggregateOrderBy =
  {
    avg?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefAvgOrderBy>;
    count?: InputMaybe<OrderBy>;
    max?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefMaxOrderBy>;
    min?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefMinOrderBy>;
    stddev?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefStddevOrderBy>;
    stddev_pop?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefStddevPopOrderBy>;
    stddev_samp?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefStddevSampOrderBy>;
    sum?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSumOrderBy>;
    var_pop?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefVarPopOrderBy>;
    var_samp?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefVarSampOrderBy>;
    variance?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefVarianceOrderBy>;
  };

/** input type for inserting array relation for remote table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefArrRelInsertInput =
  {
    data: Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRefInsertInput>;
    /** upsert condition */
    on_conflict?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefOnConflict>;
  };

/** aggregate avg on columns */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefAvgFields =
  {
    __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_avg_fields';
    /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
    scheduled_stop_point_sequence?: Maybe<Scalars['Float']>;
  };

/** order by avg() on columns of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefAvgOrderBy =
  {
    /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
    scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
  };

/** Boolean expression to filter rows from the table "service_pattern.scheduled_stop_point_in_journey_pattern_ref". All fields are combined with a logical 'AND'. */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp =
  {
    _and?: InputMaybe<
      Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>
    >;
    _not?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>;
    _or?: InputMaybe<
      Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>
    >;
    journey_pattern_ref?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefBoolExp>;
    journey_pattern_ref_id?: InputMaybe<UuidComparisonExp>;
    scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<UuidComparisonExp>;
    scheduled_stop_point_label?: InputMaybe<StringComparisonExp>;
    scheduled_stop_point_sequence?: InputMaybe<IntComparisonExp>;
    timetabled_passing_times?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
    timetabled_passing_times_aggregate?: InputMaybe<PassingTimesTimetabledPassingTimeAggregateBoolExp>;
    timing_place_label?: InputMaybe<StringComparisonExp>;
  };

/** unique or primary key constraints on table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export enum TimetablesServicePatternScheduledStopPointInJourneyPatternRefConstraint {
  /** unique or primary key constraint on columns "scheduled_stop_point_in_journey_pattern_ref_id" */
  ScheduledStopPointInJourneyPatternRefPkey = 'scheduled_stop_point_in_journey_pattern_ref_pkey',
  /** unique or primary key constraint on columns "scheduled_stop_point_sequence", "journey_pattern_ref_id" */
  ServicePatternScheduledStopPointInJourneyPatternRefIdx = 'service_pattern_scheduled_stop_point_in_journey_pattern_ref_idx',
}

/** input type for incrementing numeric columns in table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefIncInput =
  {
    /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
    scheduled_stop_point_sequence?: InputMaybe<Scalars['Int']>;
  };

/** input type for inserting data into table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefInsertInput =
  {
    journey_pattern_ref?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefObjRelInsertInput>;
    /** JOURNEY PATTERN to which the SCHEDULED STOP POINT belongs */
    journey_pattern_ref_id?: InputMaybe<Scalars['uuid']>;
    scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<
      Scalars['uuid']
    >;
    /** The label of the SCHEDULED STOP POINT */
    scheduled_stop_point_label?: InputMaybe<Scalars['String']>;
    /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
    scheduled_stop_point_sequence?: InputMaybe<Scalars['Int']>;
    timetabled_passing_times?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeArrRelInsertInput>;
    /** The label of the timing place associated with the referenced scheduled stop point in journey pattern */
    timing_place_label?: InputMaybe<Scalars['String']>;
  };

/** aggregate max on columns */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefMaxFields =
  {
    __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_max_fields';
    /** JOURNEY PATTERN to which the SCHEDULED STOP POINT belongs */
    journey_pattern_ref_id?: Maybe<Scalars['uuid']>;
    scheduled_stop_point_in_journey_pattern_ref_id?: Maybe<Scalars['uuid']>;
    /** The label of the SCHEDULED STOP POINT */
    scheduled_stop_point_label?: Maybe<Scalars['String']>;
    /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
    scheduled_stop_point_sequence?: Maybe<Scalars['Int']>;
    /** The label of the timing place associated with the referenced scheduled stop point in journey pattern */
    timing_place_label?: Maybe<Scalars['String']>;
  };

/** order by max() on columns of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefMaxOrderBy =
  {
    /** JOURNEY PATTERN to which the SCHEDULED STOP POINT belongs */
    journey_pattern_ref_id?: InputMaybe<OrderBy>;
    scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<OrderBy>;
    /** The label of the SCHEDULED STOP POINT */
    scheduled_stop_point_label?: InputMaybe<OrderBy>;
    /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
    scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
    /** The label of the timing place associated with the referenced scheduled stop point in journey pattern */
    timing_place_label?: InputMaybe<OrderBy>;
  };

/** aggregate min on columns */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefMinFields =
  {
    __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_min_fields';
    /** JOURNEY PATTERN to which the SCHEDULED STOP POINT belongs */
    journey_pattern_ref_id?: Maybe<Scalars['uuid']>;
    scheduled_stop_point_in_journey_pattern_ref_id?: Maybe<Scalars['uuid']>;
    /** The label of the SCHEDULED STOP POINT */
    scheduled_stop_point_label?: Maybe<Scalars['String']>;
    /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
    scheduled_stop_point_sequence?: Maybe<Scalars['Int']>;
    /** The label of the timing place associated with the referenced scheduled stop point in journey pattern */
    timing_place_label?: Maybe<Scalars['String']>;
  };

/** order by min() on columns of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefMinOrderBy =
  {
    /** JOURNEY PATTERN to which the SCHEDULED STOP POINT belongs */
    journey_pattern_ref_id?: InputMaybe<OrderBy>;
    scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<OrderBy>;
    /** The label of the SCHEDULED STOP POINT */
    scheduled_stop_point_label?: InputMaybe<OrderBy>;
    /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
    scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
    /** The label of the timing place associated with the referenced scheduled stop point in journey pattern */
    timing_place_label?: InputMaybe<OrderBy>;
  };

/** response of any mutation on the table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefMutationResponse =
  {
    __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_mutation_response';
    /** number of rows affected by the mutation */
    affected_rows: Scalars['Int'];
    /** data from the rows affected by the mutation */
    returning: Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRef>;
  };

/** input type for inserting object relation for remote table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefObjRelInsertInput =
  {
    data: TimetablesServicePatternScheduledStopPointInJourneyPatternRefInsertInput;
    /** upsert condition */
    on_conflict?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefOnConflict>;
  };

/** on_conflict condition type for table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefOnConflict =
  {
    constraint: TimetablesServicePatternScheduledStopPointInJourneyPatternRefConstraint;
    update_columns?: Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRefUpdateColumn>;
    where?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>;
  };

/** Ordering options when selecting data from "service_pattern.scheduled_stop_point_in_journey_pattern_ref". */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefOrderBy =
  {
    journey_pattern_ref?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefOrderBy>;
    journey_pattern_ref_id?: InputMaybe<OrderBy>;
    scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<OrderBy>;
    scheduled_stop_point_label?: InputMaybe<OrderBy>;
    scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
    timetabled_passing_times_aggregate?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeAggregateOrderBy>;
    timing_place_label?: InputMaybe<OrderBy>;
  };

/** primary key columns input for table: service_pattern.scheduled_stop_point_in_journey_pattern_ref */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefPkColumnsInput =
  {
    scheduled_stop_point_in_journey_pattern_ref_id: Scalars['uuid'];
  };

/** select columns of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export enum TimetablesServicePatternScheduledStopPointInJourneyPatternRefSelectColumn {
  /** column name */
  JourneyPatternRefId = 'journey_pattern_ref_id',
  /** column name */
  ScheduledStopPointInJourneyPatternRefId = 'scheduled_stop_point_in_journey_pattern_ref_id',
  /** column name */
  ScheduledStopPointLabel = 'scheduled_stop_point_label',
  /** column name */
  ScheduledStopPointSequence = 'scheduled_stop_point_sequence',
  /** column name */
  TimingPlaceLabel = 'timing_place_label',
}

/** input type for updating data in table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefSetInput =
  {
    /** JOURNEY PATTERN to which the SCHEDULED STOP POINT belongs */
    journey_pattern_ref_id?: InputMaybe<Scalars['uuid']>;
    scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<
      Scalars['uuid']
    >;
    /** The label of the SCHEDULED STOP POINT */
    scheduled_stop_point_label?: InputMaybe<Scalars['String']>;
    /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
    scheduled_stop_point_sequence?: InputMaybe<Scalars['Int']>;
    /** The label of the timing place associated with the referenced scheduled stop point in journey pattern */
    timing_place_label?: InputMaybe<Scalars['String']>;
  };

/** aggregate stddev on columns */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefStddevFields =
  {
    __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_stddev_fields';
    /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
    scheduled_stop_point_sequence?: Maybe<Scalars['Float']>;
  };

/** order by stddev() on columns of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefStddevOrderBy =
  {
    /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
    scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
  };

/** aggregate stddev_pop on columns */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefStddevPopFields =
  {
    __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_stddev_pop_fields';
    /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
    scheduled_stop_point_sequence?: Maybe<Scalars['Float']>;
  };

/** order by stddev_pop() on columns of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefStddevPopOrderBy =
  {
    /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
    scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
  };

/** aggregate stddev_samp on columns */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefStddevSampFields =
  {
    __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_stddev_samp_fields';
    /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
    scheduled_stop_point_sequence?: Maybe<Scalars['Float']>;
  };

/** order by stddev_samp() on columns of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefStddevSampOrderBy =
  {
    /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
    scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
  };

/** Streaming cursor of the table "service_pattern_scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefStreamCursorInput =
  {
    /** Stream column input with initial value */
    initial_value: TimetablesServicePatternScheduledStopPointInJourneyPatternRefStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<TimetablesCursorOrdering>;
  };

/** Initial value of the column from where the streaming should start */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefStreamCursorValueInput =
  {
    /** JOURNEY PATTERN to which the SCHEDULED STOP POINT belongs */
    journey_pattern_ref_id?: InputMaybe<Scalars['uuid']>;
    scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<
      Scalars['uuid']
    >;
    /** The label of the SCHEDULED STOP POINT */
    scheduled_stop_point_label?: InputMaybe<Scalars['String']>;
    /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
    scheduled_stop_point_sequence?: InputMaybe<Scalars['Int']>;
    /** The label of the timing place associated with the referenced scheduled stop point in journey pattern */
    timing_place_label?: InputMaybe<Scalars['String']>;
  };

/** aggregate sum on columns */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefSumFields =
  {
    __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_sum_fields';
    /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
    scheduled_stop_point_sequence?: Maybe<Scalars['Int']>;
  };

/** order by sum() on columns of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefSumOrderBy =
  {
    /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
    scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
  };

/** update columns of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export enum TimetablesServicePatternScheduledStopPointInJourneyPatternRefUpdateColumn {
  /** column name */
  JourneyPatternRefId = 'journey_pattern_ref_id',
  /** column name */
  ScheduledStopPointInJourneyPatternRefId = 'scheduled_stop_point_in_journey_pattern_ref_id',
  /** column name */
  ScheduledStopPointLabel = 'scheduled_stop_point_label',
  /** column name */
  ScheduledStopPointSequence = 'scheduled_stop_point_sequence',
  /** column name */
  TimingPlaceLabel = 'timing_place_label',
}

export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefUpdates =
  {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSetInput>;
    /** filter the rows which have to be updated */
    where: TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp;
  };

/** aggregate var_pop on columns */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefVarPopFields =
  {
    __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_var_pop_fields';
    /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
    scheduled_stop_point_sequence?: Maybe<Scalars['Float']>;
  };

/** order by var_pop() on columns of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefVarPopOrderBy =
  {
    /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
    scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
  };

/** aggregate var_samp on columns */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefVarSampFields =
  {
    __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_var_samp_fields';
    /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
    scheduled_stop_point_sequence?: Maybe<Scalars['Float']>;
  };

/** order by var_samp() on columns of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefVarSampOrderBy =
  {
    /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
    scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
  };

/** aggregate variance on columns */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefVarianceFields =
  {
    __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_variance_fields';
    /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
    scheduled_stop_point_sequence?: Maybe<Scalars['Float']>;
  };

/** order by variance() on columns of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefVarianceOrderBy =
  {
    /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
    scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
  };

export type TimetablesTimetablesMutationFrontend = {
  __typename?: 'timetables_timetables_mutation_frontend';
  /** delete data from the table: "journey_pattern.journey_pattern_ref" */
  timetables_delete_journey_pattern_journey_pattern_ref?: Maybe<TimetablesJourneyPatternJourneyPatternRefMutationResponse>;
  /** delete single row from the table: "journey_pattern.journey_pattern_ref" */
  timetables_delete_journey_pattern_journey_pattern_ref_by_pk?: Maybe<TimetablesJourneyPatternJourneyPatternRef>;
  /** delete data from the table: "passing_times.timetabled_passing_time" */
  timetables_delete_passing_times_timetabled_passing_time?: Maybe<TimetablesPassingTimesTimetabledPassingTimeMutationResponse>;
  /** delete single row from the table: "passing_times.timetabled_passing_time" */
  timetables_delete_passing_times_timetabled_passing_time_by_pk?: Maybe<TimetablesPassingTimesTimetabledPassingTime>;
  /** delete data from the table: "return_value.timetable_version" */
  timetables_delete_return_value_timetable_version?: Maybe<TimetablesReturnValueTimetableVersionMutationResponse>;
  /** delete data from the table: "return_value.vehicle_schedule" */
  timetables_delete_return_value_vehicle_schedule?: Maybe<TimetablesReturnValueVehicleScheduleMutationResponse>;
  /** delete data from the table: "route.direction" */
  timetables_delete_route_direction?: Maybe<TimetablesRouteDirectionMutationResponse>;
  /** delete single row from the table: "route.direction" */
  timetables_delete_route_direction_by_pk?: Maybe<TimetablesRouteDirection>;
  /** delete data from the table: "route.type_of_line" */
  timetables_delete_route_type_of_line?: Maybe<TimetablesRouteTypeOfLineMutationResponse>;
  /** delete single row from the table: "route.type_of_line" */
  timetables_delete_route_type_of_line_by_pk?: Maybe<TimetablesRouteTypeOfLine>;
  /** delete data from the table: "service_calendar.day_type" */
  timetables_delete_service_calendar_day_type?: Maybe<TimetablesServiceCalendarDayTypeMutationResponse>;
  /** delete data from the table: "service_calendar.day_type_active_on_day_of_week" */
  timetables_delete_service_calendar_day_type_active_on_day_of_week?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMutationResponse>;
  /** delete single row from the table: "service_calendar.day_type_active_on_day_of_week" */
  timetables_delete_service_calendar_day_type_active_on_day_of_week_by_pk?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeek>;
  /** delete single row from the table: "service_calendar.day_type" */
  timetables_delete_service_calendar_day_type_by_pk?: Maybe<TimetablesServiceCalendarDayType>;
  /** delete data from the table: "service_calendar.substitute_operating_day_by_line_type" */
  timetables_delete_service_calendar_substitute_operating_day_by_line_type?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMutationResponse>;
  /** delete single row from the table: "service_calendar.substitute_operating_day_by_line_type" */
  timetables_delete_service_calendar_substitute_operating_day_by_line_type_by_pk?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineType>;
  /** delete data from the table: "service_calendar.substitute_operating_period" */
  timetables_delete_service_calendar_substitute_operating_period?: Maybe<TimetablesServiceCalendarSubstituteOperatingPeriodMutationResponse>;
  /** delete single row from the table: "service_calendar.substitute_operating_period" */
  timetables_delete_service_calendar_substitute_operating_period_by_pk?: Maybe<TimetablesServiceCalendarSubstituteOperatingPeriod>;
  /** delete data from the table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
  timetables_delete_service_pattern_scheduled_stop_point_in_journey_pattern_ref?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefMutationResponse>;
  /** delete single row from the table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
  timetables_delete_service_pattern_scheduled_stop_point_in_journey_pattern_ref_by_pk?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRef>;
  /** delete data from the table: "vehicle_journey.vehicle_journey" */
  timetables_delete_vehicle_journey_vehicle_journey?: Maybe<TimetablesVehicleJourneyVehicleJourneyMutationResponse>;
  /** delete single row from the table: "vehicle_journey.vehicle_journey" */
  timetables_delete_vehicle_journey_vehicle_journey_by_pk?: Maybe<TimetablesVehicleJourneyVehicleJourney>;
  /** delete data from the table: "vehicle_schedule.vehicle_schedule_frame" */
  timetables_delete_vehicle_schedule_vehicle_schedule_frame?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameMutationResponse>;
  /** delete single row from the table: "vehicle_schedule.vehicle_schedule_frame" */
  timetables_delete_vehicle_schedule_vehicle_schedule_frame_by_pk?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrame>;
  /** delete data from the table: "vehicle_service.block" */
  timetables_delete_vehicle_service_block?: Maybe<TimetablesVehicleServiceBlockMutationResponse>;
  /** delete single row from the table: "vehicle_service.block" */
  timetables_delete_vehicle_service_block_by_pk?: Maybe<TimetablesVehicleServiceBlock>;
  /** delete data from the table: "vehicle_service.journey_patterns_in_vehicle_service" */
  timetables_delete_vehicle_service_journey_patterns_in_vehicle_service?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceMutationResponse>;
  /** delete single row from the table: "vehicle_service.journey_patterns_in_vehicle_service" */
  timetables_delete_vehicle_service_journey_patterns_in_vehicle_service_by_pk?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleService>;
  /** delete data from the table: "vehicle_service.vehicle_service" */
  timetables_delete_vehicle_service_vehicle_service?: Maybe<TimetablesVehicleServiceVehicleServiceMutationResponse>;
  /** delete single row from the table: "vehicle_service.vehicle_service" */
  timetables_delete_vehicle_service_vehicle_service_by_pk?: Maybe<TimetablesVehicleServiceVehicleService>;
  /** delete data from the table: "vehicle_type.vehicle_type" */
  timetables_delete_vehicle_type_vehicle_type?: Maybe<TimetablesVehicleTypeVehicleTypeMutationResponse>;
  /** delete single row from the table: "vehicle_type.vehicle_type" */
  timetables_delete_vehicle_type_vehicle_type_by_pk?: Maybe<TimetablesVehicleTypeVehicleType>;
  /** insert data into the table: "journey_pattern.journey_pattern_ref" */
  timetables_insert_journey_pattern_journey_pattern_ref?: Maybe<TimetablesJourneyPatternJourneyPatternRefMutationResponse>;
  /** insert a single row into the table: "journey_pattern.journey_pattern_ref" */
  timetables_insert_journey_pattern_journey_pattern_ref_one?: Maybe<TimetablesJourneyPatternJourneyPatternRef>;
  /** insert data into the table: "passing_times.timetabled_passing_time" */
  timetables_insert_passing_times_timetabled_passing_time?: Maybe<TimetablesPassingTimesTimetabledPassingTimeMutationResponse>;
  /** insert a single row into the table: "passing_times.timetabled_passing_time" */
  timetables_insert_passing_times_timetabled_passing_time_one?: Maybe<TimetablesPassingTimesTimetabledPassingTime>;
  /** insert data into the table: "return_value.timetable_version" */
  timetables_insert_return_value_timetable_version?: Maybe<TimetablesReturnValueTimetableVersionMutationResponse>;
  /** insert a single row into the table: "return_value.timetable_version" */
  timetables_insert_return_value_timetable_version_one?: Maybe<TimetablesReturnValueTimetableVersion>;
  /** insert data into the table: "return_value.vehicle_schedule" */
  timetables_insert_return_value_vehicle_schedule?: Maybe<TimetablesReturnValueVehicleScheduleMutationResponse>;
  /** insert a single row into the table: "return_value.vehicle_schedule" */
  timetables_insert_return_value_vehicle_schedule_one?: Maybe<TimetablesReturnValueVehicleSchedule>;
  /** insert data into the table: "route.direction" */
  timetables_insert_route_direction?: Maybe<TimetablesRouteDirectionMutationResponse>;
  /** insert a single row into the table: "route.direction" */
  timetables_insert_route_direction_one?: Maybe<TimetablesRouteDirection>;
  /** insert data into the table: "route.type_of_line" */
  timetables_insert_route_type_of_line?: Maybe<TimetablesRouteTypeOfLineMutationResponse>;
  /** insert a single row into the table: "route.type_of_line" */
  timetables_insert_route_type_of_line_one?: Maybe<TimetablesRouteTypeOfLine>;
  /** insert data into the table: "service_calendar.day_type" */
  timetables_insert_service_calendar_day_type?: Maybe<TimetablesServiceCalendarDayTypeMutationResponse>;
  /** insert data into the table: "service_calendar.day_type_active_on_day_of_week" */
  timetables_insert_service_calendar_day_type_active_on_day_of_week?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMutationResponse>;
  /** insert a single row into the table: "service_calendar.day_type_active_on_day_of_week" */
  timetables_insert_service_calendar_day_type_active_on_day_of_week_one?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeek>;
  /** insert a single row into the table: "service_calendar.day_type" */
  timetables_insert_service_calendar_day_type_one?: Maybe<TimetablesServiceCalendarDayType>;
  /** insert data into the table: "service_calendar.substitute_operating_day_by_line_type" */
  timetables_insert_service_calendar_substitute_operating_day_by_line_type?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMutationResponse>;
  /** insert a single row into the table: "service_calendar.substitute_operating_day_by_line_type" */
  timetables_insert_service_calendar_substitute_operating_day_by_line_type_one?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineType>;
  /** insert data into the table: "service_calendar.substitute_operating_period" */
  timetables_insert_service_calendar_substitute_operating_period?: Maybe<TimetablesServiceCalendarSubstituteOperatingPeriodMutationResponse>;
  /** insert a single row into the table: "service_calendar.substitute_operating_period" */
  timetables_insert_service_calendar_substitute_operating_period_one?: Maybe<TimetablesServiceCalendarSubstituteOperatingPeriod>;
  /** insert data into the table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
  timetables_insert_service_pattern_scheduled_stop_point_in_journey_pattern_ref?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefMutationResponse>;
  /** insert a single row into the table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
  timetables_insert_service_pattern_scheduled_stop_point_in_journey_pattern_ref_one?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRef>;
  /** insert data into the table: "vehicle_journey.vehicle_journey" */
  timetables_insert_vehicle_journey_vehicle_journey?: Maybe<TimetablesVehicleJourneyVehicleJourneyMutationResponse>;
  /** insert a single row into the table: "vehicle_journey.vehicle_journey" */
  timetables_insert_vehicle_journey_vehicle_journey_one?: Maybe<TimetablesVehicleJourneyVehicleJourney>;
  /** insert data into the table: "vehicle_schedule.vehicle_schedule_frame" */
  timetables_insert_vehicle_schedule_vehicle_schedule_frame?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameMutationResponse>;
  /** insert a single row into the table: "vehicle_schedule.vehicle_schedule_frame" */
  timetables_insert_vehicle_schedule_vehicle_schedule_frame_one?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrame>;
  /** insert data into the table: "vehicle_service.block" */
  timetables_insert_vehicle_service_block?: Maybe<TimetablesVehicleServiceBlockMutationResponse>;
  /** insert a single row into the table: "vehicle_service.block" */
  timetables_insert_vehicle_service_block_one?: Maybe<TimetablesVehicleServiceBlock>;
  /** insert data into the table: "vehicle_service.journey_patterns_in_vehicle_service" */
  timetables_insert_vehicle_service_journey_patterns_in_vehicle_service?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceMutationResponse>;
  /** insert a single row into the table: "vehicle_service.journey_patterns_in_vehicle_service" */
  timetables_insert_vehicle_service_journey_patterns_in_vehicle_service_one?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleService>;
  /** insert data into the table: "vehicle_service.vehicle_service" */
  timetables_insert_vehicle_service_vehicle_service?: Maybe<TimetablesVehicleServiceVehicleServiceMutationResponse>;
  /** insert a single row into the table: "vehicle_service.vehicle_service" */
  timetables_insert_vehicle_service_vehicle_service_one?: Maybe<TimetablesVehicleServiceVehicleService>;
  /** insert data into the table: "vehicle_type.vehicle_type" */
  timetables_insert_vehicle_type_vehicle_type?: Maybe<TimetablesVehicleTypeVehicleTypeMutationResponse>;
  /** insert a single row into the table: "vehicle_type.vehicle_type" */
  timetables_insert_vehicle_type_vehicle_type_one?: Maybe<TimetablesVehicleTypeVehicleType>;
  /** update data of the table: "journey_pattern.journey_pattern_ref" */
  timetables_update_journey_pattern_journey_pattern_ref?: Maybe<TimetablesJourneyPatternJourneyPatternRefMutationResponse>;
  /** update single row of the table: "journey_pattern.journey_pattern_ref" */
  timetables_update_journey_pattern_journey_pattern_ref_by_pk?: Maybe<TimetablesJourneyPatternJourneyPatternRef>;
  /** update multiples rows of table: "journey_pattern.journey_pattern_ref" */
  timetables_update_journey_pattern_journey_pattern_ref_many?: Maybe<
    Array<Maybe<TimetablesJourneyPatternJourneyPatternRefMutationResponse>>
  >;
  /** update data of the table: "passing_times.timetabled_passing_time" */
  timetables_update_passing_times_timetabled_passing_time?: Maybe<TimetablesPassingTimesTimetabledPassingTimeMutationResponse>;
  /** update single row of the table: "passing_times.timetabled_passing_time" */
  timetables_update_passing_times_timetabled_passing_time_by_pk?: Maybe<TimetablesPassingTimesTimetabledPassingTime>;
  /** update multiples rows of table: "passing_times.timetabled_passing_time" */
  timetables_update_passing_times_timetabled_passing_time_many?: Maybe<
    Array<Maybe<TimetablesPassingTimesTimetabledPassingTimeMutationResponse>>
  >;
  /** update data of the table: "return_value.timetable_version" */
  timetables_update_return_value_timetable_version?: Maybe<TimetablesReturnValueTimetableVersionMutationResponse>;
  /** update multiples rows of table: "return_value.timetable_version" */
  timetables_update_return_value_timetable_version_many?: Maybe<
    Array<Maybe<TimetablesReturnValueTimetableVersionMutationResponse>>
  >;
  /** update data of the table: "return_value.vehicle_schedule" */
  timetables_update_return_value_vehicle_schedule?: Maybe<TimetablesReturnValueVehicleScheduleMutationResponse>;
  /** update multiples rows of table: "return_value.vehicle_schedule" */
  timetables_update_return_value_vehicle_schedule_many?: Maybe<
    Array<Maybe<TimetablesReturnValueVehicleScheduleMutationResponse>>
  >;
  /** update data of the table: "route.direction" */
  timetables_update_route_direction?: Maybe<TimetablesRouteDirectionMutationResponse>;
  /** update single row of the table: "route.direction" */
  timetables_update_route_direction_by_pk?: Maybe<TimetablesRouteDirection>;
  /** update multiples rows of table: "route.direction" */
  timetables_update_route_direction_many?: Maybe<
    Array<Maybe<TimetablesRouteDirectionMutationResponse>>
  >;
  /** update data of the table: "route.type_of_line" */
  timetables_update_route_type_of_line?: Maybe<TimetablesRouteTypeOfLineMutationResponse>;
  /** update single row of the table: "route.type_of_line" */
  timetables_update_route_type_of_line_by_pk?: Maybe<TimetablesRouteTypeOfLine>;
  /** update multiples rows of table: "route.type_of_line" */
  timetables_update_route_type_of_line_many?: Maybe<
    Array<Maybe<TimetablesRouteTypeOfLineMutationResponse>>
  >;
  /** update data of the table: "service_calendar.day_type" */
  timetables_update_service_calendar_day_type?: Maybe<TimetablesServiceCalendarDayTypeMutationResponse>;
  /** update data of the table: "service_calendar.day_type_active_on_day_of_week" */
  timetables_update_service_calendar_day_type_active_on_day_of_week?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMutationResponse>;
  /** update single row of the table: "service_calendar.day_type_active_on_day_of_week" */
  timetables_update_service_calendar_day_type_active_on_day_of_week_by_pk?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeek>;
  /** update multiples rows of table: "service_calendar.day_type_active_on_day_of_week" */
  timetables_update_service_calendar_day_type_active_on_day_of_week_many?: Maybe<
    Array<
      Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMutationResponse>
    >
  >;
  /** update single row of the table: "service_calendar.day_type" */
  timetables_update_service_calendar_day_type_by_pk?: Maybe<TimetablesServiceCalendarDayType>;
  /** update multiples rows of table: "service_calendar.day_type" */
  timetables_update_service_calendar_day_type_many?: Maybe<
    Array<Maybe<TimetablesServiceCalendarDayTypeMutationResponse>>
  >;
  /** update data of the table: "service_calendar.substitute_operating_day_by_line_type" */
  timetables_update_service_calendar_substitute_operating_day_by_line_type?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMutationResponse>;
  /** update single row of the table: "service_calendar.substitute_operating_day_by_line_type" */
  timetables_update_service_calendar_substitute_operating_day_by_line_type_by_pk?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineType>;
  /** update multiples rows of table: "service_calendar.substitute_operating_day_by_line_type" */
  timetables_update_service_calendar_substitute_operating_day_by_line_type_many?: Maybe<
    Array<
      Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMutationResponse>
    >
  >;
  /** update data of the table: "service_calendar.substitute_operating_period" */
  timetables_update_service_calendar_substitute_operating_period?: Maybe<TimetablesServiceCalendarSubstituteOperatingPeriodMutationResponse>;
  /** update single row of the table: "service_calendar.substitute_operating_period" */
  timetables_update_service_calendar_substitute_operating_period_by_pk?: Maybe<TimetablesServiceCalendarSubstituteOperatingPeriod>;
  /** update multiples rows of table: "service_calendar.substitute_operating_period" */
  timetables_update_service_calendar_substitute_operating_period_many?: Maybe<
    Array<
      Maybe<TimetablesServiceCalendarSubstituteOperatingPeriodMutationResponse>
    >
  >;
  /** update data of the table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
  timetables_update_service_pattern_scheduled_stop_point_in_journey_pattern_ref?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefMutationResponse>;
  /** update single row of the table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
  timetables_update_service_pattern_scheduled_stop_point_in_journey_pattern_ref_by_pk?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRef>;
  /** update multiples rows of table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
  timetables_update_service_pattern_scheduled_stop_point_in_journey_pattern_ref_many?: Maybe<
    Array<
      Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefMutationResponse>
    >
  >;
  /** update data of the table: "vehicle_journey.vehicle_journey" */
  timetables_update_vehicle_journey_vehicle_journey?: Maybe<TimetablesVehicleJourneyVehicleJourneyMutationResponse>;
  /** update single row of the table: "vehicle_journey.vehicle_journey" */
  timetables_update_vehicle_journey_vehicle_journey_by_pk?: Maybe<TimetablesVehicleJourneyVehicleJourney>;
  /** update multiples rows of table: "vehicle_journey.vehicle_journey" */
  timetables_update_vehicle_journey_vehicle_journey_many?: Maybe<
    Array<Maybe<TimetablesVehicleJourneyVehicleJourneyMutationResponse>>
  >;
  /** update data of the table: "vehicle_schedule.vehicle_schedule_frame" */
  timetables_update_vehicle_schedule_vehicle_schedule_frame?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameMutationResponse>;
  /** update single row of the table: "vehicle_schedule.vehicle_schedule_frame" */
  timetables_update_vehicle_schedule_vehicle_schedule_frame_by_pk?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrame>;
  /** update multiples rows of table: "vehicle_schedule.vehicle_schedule_frame" */
  timetables_update_vehicle_schedule_vehicle_schedule_frame_many?: Maybe<
    Array<Maybe<TimetablesVehicleScheduleVehicleScheduleFrameMutationResponse>>
  >;
  /** update data of the table: "vehicle_service.block" */
  timetables_update_vehicle_service_block?: Maybe<TimetablesVehicleServiceBlockMutationResponse>;
  /** update single row of the table: "vehicle_service.block" */
  timetables_update_vehicle_service_block_by_pk?: Maybe<TimetablesVehicleServiceBlock>;
  /** update multiples rows of table: "vehicle_service.block" */
  timetables_update_vehicle_service_block_many?: Maybe<
    Array<Maybe<TimetablesVehicleServiceBlockMutationResponse>>
  >;
  /** update data of the table: "vehicle_service.journey_patterns_in_vehicle_service" */
  timetables_update_vehicle_service_journey_patterns_in_vehicle_service?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceMutationResponse>;
  /** update single row of the table: "vehicle_service.journey_patterns_in_vehicle_service" */
  timetables_update_vehicle_service_journey_patterns_in_vehicle_service_by_pk?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleService>;
  /** update multiples rows of table: "vehicle_service.journey_patterns_in_vehicle_service" */
  timetables_update_vehicle_service_journey_patterns_in_vehicle_service_many?: Maybe<
    Array<
      Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceMutationResponse>
    >
  >;
  /** update data of the table: "vehicle_service.vehicle_service" */
  timetables_update_vehicle_service_vehicle_service?: Maybe<TimetablesVehicleServiceVehicleServiceMutationResponse>;
  /** update single row of the table: "vehicle_service.vehicle_service" */
  timetables_update_vehicle_service_vehicle_service_by_pk?: Maybe<TimetablesVehicleServiceVehicleService>;
  /** update multiples rows of table: "vehicle_service.vehicle_service" */
  timetables_update_vehicle_service_vehicle_service_many?: Maybe<
    Array<Maybe<TimetablesVehicleServiceVehicleServiceMutationResponse>>
  >;
  /** update data of the table: "vehicle_type.vehicle_type" */
  timetables_update_vehicle_type_vehicle_type?: Maybe<TimetablesVehicleTypeVehicleTypeMutationResponse>;
  /** update single row of the table: "vehicle_type.vehicle_type" */
  timetables_update_vehicle_type_vehicle_type_by_pk?: Maybe<TimetablesVehicleTypeVehicleType>;
  /** update multiples rows of table: "vehicle_type.vehicle_type" */
  timetables_update_vehicle_type_vehicle_type_many?: Maybe<
    Array<Maybe<TimetablesVehicleTypeVehicleTypeMutationResponse>>
  >;
};

export type TimetablesTimetablesMutationFrontendTimetablesDeleteJourneyPatternJourneyPatternRefArgs =
  {
    where: TimetablesJourneyPatternJourneyPatternRefBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteJourneyPatternJourneyPatternRefByPkArgs =
  {
    journey_pattern_ref_id: Scalars['uuid'];
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeletePassingTimesTimetabledPassingTimeArgs =
  {
    where: TimetablesPassingTimesTimetabledPassingTimeBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeletePassingTimesTimetabledPassingTimeByPkArgs =
  {
    timetabled_passing_time_id: Scalars['uuid'];
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteReturnValueTimetableVersionArgs =
  {
    where: TimetablesReturnValueTimetableVersionBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteReturnValueVehicleScheduleArgs =
  {
    where: TimetablesReturnValueVehicleScheduleBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteRouteDirectionArgs =
  {
    where: TimetablesRouteDirectionBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteRouteDirectionByPkArgs =
  {
    direction: Scalars['String'];
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteRouteTypeOfLineArgs =
  {
    where: TimetablesRouteTypeOfLineBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteRouteTypeOfLineByPkArgs =
  {
    type_of_line: Scalars['String'];
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteServiceCalendarDayTypeArgs =
  {
    where: TimetablesServiceCalendarDayTypeBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteServiceCalendarDayTypeActiveOnDayOfWeekArgs =
  {
    where: TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteServiceCalendarDayTypeActiveOnDayOfWeekByPkArgs =
  {
    day_of_week: Scalars['Int'];
    day_type_id: Scalars['uuid'];
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteServiceCalendarDayTypeByPkArgs =
  {
    day_type_id: Scalars['uuid'];
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteServiceCalendarSubstituteOperatingDayByLineTypeArgs =
  {
    where: TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteServiceCalendarSubstituteOperatingDayByLineTypeByPkArgs =
  {
    substitute_operating_day_by_line_type_id: Scalars['uuid'];
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteServiceCalendarSubstituteOperatingPeriodArgs =
  {
    where: TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteServiceCalendarSubstituteOperatingPeriodByPkArgs =
  {
    substitute_operating_period_id: Scalars['uuid'];
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteServicePatternScheduledStopPointInJourneyPatternRefArgs =
  {
    where: TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteServicePatternScheduledStopPointInJourneyPatternRefByPkArgs =
  {
    scheduled_stop_point_in_journey_pattern_ref_id: Scalars['uuid'];
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteVehicleJourneyVehicleJourneyArgs =
  {
    where: TimetablesVehicleJourneyVehicleJourneyBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteVehicleJourneyVehicleJourneyByPkArgs =
  {
    vehicle_journey_id: Scalars['uuid'];
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteVehicleScheduleVehicleScheduleFrameArgs =
  {
    where: TimetablesVehicleScheduleVehicleScheduleFrameBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteVehicleScheduleVehicleScheduleFrameByPkArgs =
  {
    vehicle_schedule_frame_id: Scalars['uuid'];
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteVehicleServiceBlockArgs =
  {
    where: TimetablesVehicleServiceBlockBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteVehicleServiceBlockByPkArgs =
  {
    block_id: Scalars['uuid'];
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteVehicleServiceJourneyPatternsInVehicleServiceArgs =
  {
    where: TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteVehicleServiceJourneyPatternsInVehicleServiceByPkArgs =
  {
    journey_pattern_id: Scalars['uuid'];
    vehicle_service_id: Scalars['uuid'];
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteVehicleServiceVehicleServiceArgs =
  {
    where: TimetablesVehicleServiceVehicleServiceBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteVehicleServiceVehicleServiceByPkArgs =
  {
    vehicle_service_id: Scalars['uuid'];
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteVehicleTypeVehicleTypeArgs =
  {
    where: TimetablesVehicleTypeVehicleTypeBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesDeleteVehicleTypeVehicleTypeByPkArgs =
  {
    vehicle_type_id: Scalars['uuid'];
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertJourneyPatternJourneyPatternRefArgs =
  {
    objects: Array<TimetablesJourneyPatternJourneyPatternRefInsertInput>;
    on_conflict?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertJourneyPatternJourneyPatternRefOneArgs =
  {
    object: TimetablesJourneyPatternJourneyPatternRefInsertInput;
    on_conflict?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertPassingTimesTimetabledPassingTimeArgs =
  {
    objects: Array<TimetablesPassingTimesTimetabledPassingTimeInsertInput>;
    on_conflict?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertPassingTimesTimetabledPassingTimeOneArgs =
  {
    object: TimetablesPassingTimesTimetabledPassingTimeInsertInput;
    on_conflict?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertReturnValueTimetableVersionArgs =
  {
    objects: Array<TimetablesReturnValueTimetableVersionInsertInput>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertReturnValueTimetableVersionOneArgs =
  {
    object: TimetablesReturnValueTimetableVersionInsertInput;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertReturnValueVehicleScheduleArgs =
  {
    objects: Array<TimetablesReturnValueVehicleScheduleInsertInput>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertReturnValueVehicleScheduleOneArgs =
  {
    object: TimetablesReturnValueVehicleScheduleInsertInput;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertRouteDirectionArgs =
  {
    objects: Array<TimetablesRouteDirectionInsertInput>;
    on_conflict?: InputMaybe<TimetablesRouteDirectionOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertRouteDirectionOneArgs =
  {
    object: TimetablesRouteDirectionInsertInput;
    on_conflict?: InputMaybe<TimetablesRouteDirectionOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertRouteTypeOfLineArgs =
  {
    objects: Array<TimetablesRouteTypeOfLineInsertInput>;
    on_conflict?: InputMaybe<TimetablesRouteTypeOfLineOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertRouteTypeOfLineOneArgs =
  {
    object: TimetablesRouteTypeOfLineInsertInput;
    on_conflict?: InputMaybe<TimetablesRouteTypeOfLineOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertServiceCalendarDayTypeArgs =
  {
    objects: Array<TimetablesServiceCalendarDayTypeInsertInput>;
    on_conflict?: InputMaybe<TimetablesServiceCalendarDayTypeOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertServiceCalendarDayTypeActiveOnDayOfWeekArgs =
  {
    objects: Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekInsertInput>;
    on_conflict?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertServiceCalendarDayTypeActiveOnDayOfWeekOneArgs =
  {
    object: TimetablesServiceCalendarDayTypeActiveOnDayOfWeekInsertInput;
    on_conflict?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertServiceCalendarDayTypeOneArgs =
  {
    object: TimetablesServiceCalendarDayTypeInsertInput;
    on_conflict?: InputMaybe<TimetablesServiceCalendarDayTypeOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertServiceCalendarSubstituteOperatingDayByLineTypeArgs =
  {
    objects: Array<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeInsertInput>;
    on_conflict?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertServiceCalendarSubstituteOperatingDayByLineTypeOneArgs =
  {
    object: TimetablesServiceCalendarSubstituteOperatingDayByLineTypeInsertInput;
    on_conflict?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertServiceCalendarSubstituteOperatingPeriodArgs =
  {
    objects: Array<TimetablesServiceCalendarSubstituteOperatingPeriodInsertInput>;
    on_conflict?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertServiceCalendarSubstituteOperatingPeriodOneArgs =
  {
    object: TimetablesServiceCalendarSubstituteOperatingPeriodInsertInput;
    on_conflict?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertServicePatternScheduledStopPointInJourneyPatternRefArgs =
  {
    objects: Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRefInsertInput>;
    on_conflict?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertServicePatternScheduledStopPointInJourneyPatternRefOneArgs =
  {
    object: TimetablesServicePatternScheduledStopPointInJourneyPatternRefInsertInput;
    on_conflict?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertVehicleJourneyVehicleJourneyArgs =
  {
    objects: Array<TimetablesVehicleJourneyVehicleJourneyInsertInput>;
    on_conflict?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertVehicleJourneyVehicleJourneyOneArgs =
  {
    object: TimetablesVehicleJourneyVehicleJourneyInsertInput;
    on_conflict?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertVehicleScheduleVehicleScheduleFrameArgs =
  {
    objects: Array<TimetablesVehicleScheduleVehicleScheduleFrameInsertInput>;
    on_conflict?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertVehicleScheduleVehicleScheduleFrameOneArgs =
  {
    object: TimetablesVehicleScheduleVehicleScheduleFrameInsertInput;
    on_conflict?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertVehicleServiceBlockArgs =
  {
    objects: Array<TimetablesVehicleServiceBlockInsertInput>;
    on_conflict?: InputMaybe<TimetablesVehicleServiceBlockOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertVehicleServiceBlockOneArgs =
  {
    object: TimetablesVehicleServiceBlockInsertInput;
    on_conflict?: InputMaybe<TimetablesVehicleServiceBlockOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertVehicleServiceJourneyPatternsInVehicleServiceArgs =
  {
    objects: Array<TimetablesVehicleServiceJourneyPatternsInVehicleServiceInsertInput>;
    on_conflict?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertVehicleServiceJourneyPatternsInVehicleServiceOneArgs =
  {
    object: TimetablesVehicleServiceJourneyPatternsInVehicleServiceInsertInput;
    on_conflict?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertVehicleServiceVehicleServiceArgs =
  {
    objects: Array<TimetablesVehicleServiceVehicleServiceInsertInput>;
    on_conflict?: InputMaybe<TimetablesVehicleServiceVehicleServiceOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertVehicleServiceVehicleServiceOneArgs =
  {
    object: TimetablesVehicleServiceVehicleServiceInsertInput;
    on_conflict?: InputMaybe<TimetablesVehicleServiceVehicleServiceOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertVehicleTypeVehicleTypeArgs =
  {
    objects: Array<TimetablesVehicleTypeVehicleTypeInsertInput>;
    on_conflict?: InputMaybe<TimetablesVehicleTypeVehicleTypeOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesInsertVehicleTypeVehicleTypeOneArgs =
  {
    object: TimetablesVehicleTypeVehicleTypeInsertInput;
    on_conflict?: InputMaybe<TimetablesVehicleTypeVehicleTypeOnConflict>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateJourneyPatternJourneyPatternRefArgs =
  {
    _set?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefSetInput>;
    where: TimetablesJourneyPatternJourneyPatternRefBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateJourneyPatternJourneyPatternRefByPkArgs =
  {
    _set?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefSetInput>;
    pk_columns: TimetablesJourneyPatternJourneyPatternRefPkColumnsInput;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateJourneyPatternJourneyPatternRefManyArgs =
  {
    updates: Array<TimetablesJourneyPatternJourneyPatternRefUpdates>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdatePassingTimesTimetabledPassingTimeArgs =
  {
    _set?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeSetInput>;
    where: TimetablesPassingTimesTimetabledPassingTimeBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdatePassingTimesTimetabledPassingTimeByPkArgs =
  {
    _set?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeSetInput>;
    pk_columns: TimetablesPassingTimesTimetabledPassingTimePkColumnsInput;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdatePassingTimesTimetabledPassingTimeManyArgs =
  {
    updates: Array<TimetablesPassingTimesTimetabledPassingTimeUpdates>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateReturnValueTimetableVersionArgs =
  {
    _inc?: InputMaybe<TimetablesReturnValueTimetableVersionIncInput>;
    _set?: InputMaybe<TimetablesReturnValueTimetableVersionSetInput>;
    where: TimetablesReturnValueTimetableVersionBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateReturnValueTimetableVersionManyArgs =
  {
    updates: Array<TimetablesReturnValueTimetableVersionUpdates>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateReturnValueVehicleScheduleArgs =
  {
    _inc?: InputMaybe<TimetablesReturnValueVehicleScheduleIncInput>;
    _set?: InputMaybe<TimetablesReturnValueVehicleScheduleSetInput>;
    where: TimetablesReturnValueVehicleScheduleBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateReturnValueVehicleScheduleManyArgs =
  {
    updates: Array<TimetablesReturnValueVehicleScheduleUpdates>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateRouteDirectionArgs =
  {
    _set?: InputMaybe<TimetablesRouteDirectionSetInput>;
    where: TimetablesRouteDirectionBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateRouteDirectionByPkArgs =
  {
    _set?: InputMaybe<TimetablesRouteDirectionSetInput>;
    pk_columns: TimetablesRouteDirectionPkColumnsInput;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateRouteDirectionManyArgs =
  {
    updates: Array<TimetablesRouteDirectionUpdates>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateRouteTypeOfLineArgs =
  {
    _set?: InputMaybe<TimetablesRouteTypeOfLineSetInput>;
    where: TimetablesRouteTypeOfLineBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateRouteTypeOfLineByPkArgs =
  {
    _set?: InputMaybe<TimetablesRouteTypeOfLineSetInput>;
    pk_columns: TimetablesRouteTypeOfLinePkColumnsInput;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateRouteTypeOfLineManyArgs =
  {
    updates: Array<TimetablesRouteTypeOfLineUpdates>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateServiceCalendarDayTypeArgs =
  {
    _append?: InputMaybe<TimetablesServiceCalendarDayTypeAppendInput>;
    _delete_at_path?: InputMaybe<TimetablesServiceCalendarDayTypeDeleteAtPathInput>;
    _delete_elem?: InputMaybe<TimetablesServiceCalendarDayTypeDeleteElemInput>;
    _delete_key?: InputMaybe<TimetablesServiceCalendarDayTypeDeleteKeyInput>;
    _prepend?: InputMaybe<TimetablesServiceCalendarDayTypePrependInput>;
    _set?: InputMaybe<TimetablesServiceCalendarDayTypeSetInput>;
    where: TimetablesServiceCalendarDayTypeBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateServiceCalendarDayTypeActiveOnDayOfWeekArgs =
  {
    _inc?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekIncInput>;
    _set?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSetInput>;
    where: TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateServiceCalendarDayTypeActiveOnDayOfWeekByPkArgs =
  {
    _inc?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekIncInput>;
    _set?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSetInput>;
    pk_columns: TimetablesServiceCalendarDayTypeActiveOnDayOfWeekPkColumnsInput;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateServiceCalendarDayTypeActiveOnDayOfWeekManyArgs =
  {
    updates: Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekUpdates>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateServiceCalendarDayTypeByPkArgs =
  {
    _append?: InputMaybe<TimetablesServiceCalendarDayTypeAppendInput>;
    _delete_at_path?: InputMaybe<TimetablesServiceCalendarDayTypeDeleteAtPathInput>;
    _delete_elem?: InputMaybe<TimetablesServiceCalendarDayTypeDeleteElemInput>;
    _delete_key?: InputMaybe<TimetablesServiceCalendarDayTypeDeleteKeyInput>;
    _prepend?: InputMaybe<TimetablesServiceCalendarDayTypePrependInput>;
    _set?: InputMaybe<TimetablesServiceCalendarDayTypeSetInput>;
    pk_columns: TimetablesServiceCalendarDayTypePkColumnsInput;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateServiceCalendarDayTypeManyArgs =
  {
    updates: Array<TimetablesServiceCalendarDayTypeUpdates>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateServiceCalendarSubstituteOperatingDayByLineTypeArgs =
  {
    _inc?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeIncInput>;
    _set?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSetInput>;
    where: TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateServiceCalendarSubstituteOperatingDayByLineTypeByPkArgs =
  {
    _inc?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeIncInput>;
    _set?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSetInput>;
    pk_columns: TimetablesServiceCalendarSubstituteOperatingDayByLineTypePkColumnsInput;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateServiceCalendarSubstituteOperatingDayByLineTypeManyArgs =
  {
    updates: Array<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeUpdates>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateServiceCalendarSubstituteOperatingPeriodArgs =
  {
    _set?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodSetInput>;
    where: TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateServiceCalendarSubstituteOperatingPeriodByPkArgs =
  {
    _set?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodSetInput>;
    pk_columns: TimetablesServiceCalendarSubstituteOperatingPeriodPkColumnsInput;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateServiceCalendarSubstituteOperatingPeriodManyArgs =
  {
    updates: Array<TimetablesServiceCalendarSubstituteOperatingPeriodUpdates>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateServicePatternScheduledStopPointInJourneyPatternRefArgs =
  {
    _inc?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefIncInput>;
    _set?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSetInput>;
    where: TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateServicePatternScheduledStopPointInJourneyPatternRefByPkArgs =
  {
    _inc?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefIncInput>;
    _set?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSetInput>;
    pk_columns: TimetablesServicePatternScheduledStopPointInJourneyPatternRefPkColumnsInput;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateServicePatternScheduledStopPointInJourneyPatternRefManyArgs =
  {
    updates: Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRefUpdates>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleJourneyVehicleJourneyArgs =
  {
    _append?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyAppendInput>;
    _delete_at_path?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyDeleteAtPathInput>;
    _delete_elem?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyDeleteElemInput>;
    _delete_key?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyDeleteKeyInput>;
    _prepend?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyPrependInput>;
    _set?: InputMaybe<TimetablesVehicleJourneyVehicleJourneySetInput>;
    where: TimetablesVehicleJourneyVehicleJourneyBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleJourneyVehicleJourneyByPkArgs =
  {
    _append?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyAppendInput>;
    _delete_at_path?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyDeleteAtPathInput>;
    _delete_elem?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyDeleteElemInput>;
    _delete_key?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyDeleteKeyInput>;
    _prepend?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyPrependInput>;
    _set?: InputMaybe<TimetablesVehicleJourneyVehicleJourneySetInput>;
    pk_columns: TimetablesVehicleJourneyVehicleJourneyPkColumnsInput;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleJourneyVehicleJourneyManyArgs =
  {
    updates: Array<TimetablesVehicleJourneyVehicleJourneyUpdates>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleScheduleVehicleScheduleFrameArgs =
  {
    _append?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameAppendInput>;
    _delete_at_path?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameDeleteAtPathInput>;
    _delete_elem?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameDeleteElemInput>;
    _delete_key?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameDeleteKeyInput>;
    _inc?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameIncInput>;
    _prepend?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFramePrependInput>;
    _set?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameSetInput>;
    where: TimetablesVehicleScheduleVehicleScheduleFrameBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleScheduleVehicleScheduleFrameByPkArgs =
  {
    _append?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameAppendInput>;
    _delete_at_path?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameDeleteAtPathInput>;
    _delete_elem?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameDeleteElemInput>;
    _delete_key?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameDeleteKeyInput>;
    _inc?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameIncInput>;
    _prepend?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFramePrependInput>;
    _set?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameSetInput>;
    pk_columns: TimetablesVehicleScheduleVehicleScheduleFramePkColumnsInput;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleScheduleVehicleScheduleFrameManyArgs =
  {
    updates: Array<TimetablesVehicleScheduleVehicleScheduleFrameUpdates>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleServiceBlockArgs =
  {
    _set?: InputMaybe<TimetablesVehicleServiceBlockSetInput>;
    where: TimetablesVehicleServiceBlockBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleServiceBlockByPkArgs =
  {
    _set?: InputMaybe<TimetablesVehicleServiceBlockSetInput>;
    pk_columns: TimetablesVehicleServiceBlockPkColumnsInput;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleServiceBlockManyArgs =
  {
    updates: Array<TimetablesVehicleServiceBlockUpdates>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleServiceJourneyPatternsInVehicleServiceArgs =
  {
    _inc?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceIncInput>;
    _set?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSetInput>;
    where: TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleServiceJourneyPatternsInVehicleServiceByPkArgs =
  {
    _inc?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceIncInput>;
    _set?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSetInput>;
    pk_columns: TimetablesVehicleServiceJourneyPatternsInVehicleServicePkColumnsInput;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleServiceJourneyPatternsInVehicleServiceManyArgs =
  {
    updates: Array<TimetablesVehicleServiceJourneyPatternsInVehicleServiceUpdates>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleServiceVehicleServiceArgs =
  {
    _append?: InputMaybe<TimetablesVehicleServiceVehicleServiceAppendInput>;
    _delete_at_path?: InputMaybe<TimetablesVehicleServiceVehicleServiceDeleteAtPathInput>;
    _delete_elem?: InputMaybe<TimetablesVehicleServiceVehicleServiceDeleteElemInput>;
    _delete_key?: InputMaybe<TimetablesVehicleServiceVehicleServiceDeleteKeyInput>;
    _prepend?: InputMaybe<TimetablesVehicleServiceVehicleServicePrependInput>;
    _set?: InputMaybe<TimetablesVehicleServiceVehicleServiceSetInput>;
    where: TimetablesVehicleServiceVehicleServiceBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleServiceVehicleServiceByPkArgs =
  {
    _append?: InputMaybe<TimetablesVehicleServiceVehicleServiceAppendInput>;
    _delete_at_path?: InputMaybe<TimetablesVehicleServiceVehicleServiceDeleteAtPathInput>;
    _delete_elem?: InputMaybe<TimetablesVehicleServiceVehicleServiceDeleteElemInput>;
    _delete_key?: InputMaybe<TimetablesVehicleServiceVehicleServiceDeleteKeyInput>;
    _prepend?: InputMaybe<TimetablesVehicleServiceVehicleServicePrependInput>;
    _set?: InputMaybe<TimetablesVehicleServiceVehicleServiceSetInput>;
    pk_columns: TimetablesVehicleServiceVehicleServicePkColumnsInput;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleServiceVehicleServiceManyArgs =
  {
    updates: Array<TimetablesVehicleServiceVehicleServiceUpdates>;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleTypeVehicleTypeArgs =
  {
    _append?: InputMaybe<TimetablesVehicleTypeVehicleTypeAppendInput>;
    _delete_at_path?: InputMaybe<TimetablesVehicleTypeVehicleTypeDeleteAtPathInput>;
    _delete_elem?: InputMaybe<TimetablesVehicleTypeVehicleTypeDeleteElemInput>;
    _delete_key?: InputMaybe<TimetablesVehicleTypeVehicleTypeDeleteKeyInput>;
    _inc?: InputMaybe<TimetablesVehicleTypeVehicleTypeIncInput>;
    _prepend?: InputMaybe<TimetablesVehicleTypeVehicleTypePrependInput>;
    _set?: InputMaybe<TimetablesVehicleTypeVehicleTypeSetInput>;
    where: TimetablesVehicleTypeVehicleTypeBoolExp;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleTypeVehicleTypeByPkArgs =
  {
    _append?: InputMaybe<TimetablesVehicleTypeVehicleTypeAppendInput>;
    _delete_at_path?: InputMaybe<TimetablesVehicleTypeVehicleTypeDeleteAtPathInput>;
    _delete_elem?: InputMaybe<TimetablesVehicleTypeVehicleTypeDeleteElemInput>;
    _delete_key?: InputMaybe<TimetablesVehicleTypeVehicleTypeDeleteKeyInput>;
    _inc?: InputMaybe<TimetablesVehicleTypeVehicleTypeIncInput>;
    _prepend?: InputMaybe<TimetablesVehicleTypeVehicleTypePrependInput>;
    _set?: InputMaybe<TimetablesVehicleTypeVehicleTypeSetInput>;
    pk_columns: TimetablesVehicleTypeVehicleTypePkColumnsInput;
  };

export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleTypeVehicleTypeManyArgs =
  {
    updates: Array<TimetablesVehicleTypeVehicleTypeUpdates>;
  };

export type TimetablesTimetablesQuery = {
  __typename?: 'timetables_timetables_query';
  /** fetch data from the table: "journey_pattern.journey_pattern_ref" */
  timetables_journey_pattern_journey_pattern_ref: Array<TimetablesJourneyPatternJourneyPatternRef>;
  /** fetch aggregated fields from the table: "journey_pattern.journey_pattern_ref" */
  timetables_journey_pattern_journey_pattern_ref_aggregate: TimetablesJourneyPatternJourneyPatternRefAggregate;
  /** fetch data from the table: "journey_pattern.journey_pattern_ref" using primary key columns */
  timetables_journey_pattern_journey_pattern_ref_by_pk?: Maybe<TimetablesJourneyPatternJourneyPatternRef>;
  /** fetch data from the table: "passing_times.timetabled_passing_time" */
  timetables_passing_times_timetabled_passing_time: Array<TimetablesPassingTimesTimetabledPassingTime>;
  /** fetch aggregated fields from the table: "passing_times.timetabled_passing_time" */
  timetables_passing_times_timetabled_passing_time_aggregate: TimetablesPassingTimesTimetabledPassingTimeAggregate;
  /** fetch data from the table: "passing_times.timetabled_passing_time" using primary key columns */
  timetables_passing_times_timetabled_passing_time_by_pk?: Maybe<TimetablesPassingTimesTimetabledPassingTime>;
  /** fetch data from the table: "return_value.timetable_version" */
  timetables_return_value_timetable_version: Array<TimetablesReturnValueTimetableVersion>;
  /** fetch aggregated fields from the table: "return_value.timetable_version" */
  timetables_return_value_timetable_version_aggregate: TimetablesReturnValueTimetableVersionAggregate;
  /** fetch data from the table: "return_value.vehicle_schedule" */
  timetables_return_value_vehicle_schedule: Array<TimetablesReturnValueVehicleSchedule>;
  /** fetch aggregated fields from the table: "return_value.vehicle_schedule" */
  timetables_return_value_vehicle_schedule_aggregate: TimetablesReturnValueVehicleScheduleAggregate;
  /** fetch data from the table: "route.direction" */
  timetables_route_direction: Array<TimetablesRouteDirection>;
  /** fetch aggregated fields from the table: "route.direction" */
  timetables_route_direction_aggregate: TimetablesRouteDirectionAggregate;
  /** fetch data from the table: "route.direction" using primary key columns */
  timetables_route_direction_by_pk?: Maybe<TimetablesRouteDirection>;
  /** fetch data from the table: "route.type_of_line" */
  timetables_route_type_of_line: Array<TimetablesRouteTypeOfLine>;
  /** fetch aggregated fields from the table: "route.type_of_line" */
  timetables_route_type_of_line_aggregate: TimetablesRouteTypeOfLineAggregate;
  /** fetch data from the table: "route.type_of_line" using primary key columns */
  timetables_route_type_of_line_by_pk?: Maybe<TimetablesRouteTypeOfLine>;
  /** fetch data from the table: "service_calendar.day_type" */
  timetables_service_calendar_day_type: Array<TimetablesServiceCalendarDayType>;
  /** fetch data from the table: "service_calendar.day_type_active_on_day_of_week" */
  timetables_service_calendar_day_type_active_on_day_of_week: Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeek>;
  /** fetch aggregated fields from the table: "service_calendar.day_type_active_on_day_of_week" */
  timetables_service_calendar_day_type_active_on_day_of_week_aggregate: TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAggregate;
  /** fetch data from the table: "service_calendar.day_type_active_on_day_of_week" using primary key columns */
  timetables_service_calendar_day_type_active_on_day_of_week_by_pk?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeek>;
  /** fetch aggregated fields from the table: "service_calendar.day_type" */
  timetables_service_calendar_day_type_aggregate: TimetablesServiceCalendarDayTypeAggregate;
  /** fetch data from the table: "service_calendar.day_type" using primary key columns */
  timetables_service_calendar_day_type_by_pk?: Maybe<TimetablesServiceCalendarDayType>;
  /** execute function "service_calendar.get_active_day_types_for_date" which returns "service_calendar.day_type" */
  timetables_service_calendar_get_active_day_types_for_date: Array<TimetablesServiceCalendarDayType>;
  /** execute function "service_calendar.get_active_day_types_for_date" and query aggregates on result of table type "service_calendar.day_type" */
  timetables_service_calendar_get_active_day_types_for_date_aggregate: TimetablesServiceCalendarDayTypeAggregate;
  /** fetch data from the table: "service_calendar.substitute_operating_day_by_line_type" */
  timetables_service_calendar_substitute_operating_day_by_line_type: Array<TimetablesServiceCalendarSubstituteOperatingDayByLineType>;
  /** fetch aggregated fields from the table: "service_calendar.substitute_operating_day_by_line_type" */
  timetables_service_calendar_substitute_operating_day_by_line_type_aggregate: TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAggregate;
  /** fetch data from the table: "service_calendar.substitute_operating_day_by_line_type" using primary key columns */
  timetables_service_calendar_substitute_operating_day_by_line_type_by_pk?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineType>;
  /** fetch data from the table: "service_calendar.substitute_operating_period" */
  timetables_service_calendar_substitute_operating_period: Array<TimetablesServiceCalendarSubstituteOperatingPeriod>;
  /** fetch aggregated fields from the table: "service_calendar.substitute_operating_period" */
  timetables_service_calendar_substitute_operating_period_aggregate: TimetablesServiceCalendarSubstituteOperatingPeriodAggregate;
  /** fetch data from the table: "service_calendar.substitute_operating_period" using primary key columns */
  timetables_service_calendar_substitute_operating_period_by_pk?: Maybe<TimetablesServiceCalendarSubstituteOperatingPeriod>;
  /** fetch data from the table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
  timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref: Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRef>;
  /** fetch aggregated fields from the table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
  timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_aggregate: TimetablesServicePatternScheduledStopPointInJourneyPatternRefAggregate;
  /** fetch data from the table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" using primary key columns */
  timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_by_pk?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRef>;
  /** execute function "vehicle_journey.get_vehicle_schedules_on_date" which returns "return_value.vehicle_schedule" */
  timetables_vehicle_journey_get_vehicle_schedules_on_date: Array<TimetablesReturnValueVehicleSchedule>;
  /** execute function "vehicle_journey.get_vehicle_schedules_on_date" and query aggregates on result of table type "return_value.vehicle_schedule" */
  timetables_vehicle_journey_get_vehicle_schedules_on_date_aggregate: TimetablesReturnValueVehicleScheduleAggregate;
  /** fetch data from the table: "vehicle_journey.vehicle_journey" */
  timetables_vehicle_journey_vehicle_journey: Array<TimetablesVehicleJourneyVehicleJourney>;
  /** fetch aggregated fields from the table: "vehicle_journey.vehicle_journey" */
  timetables_vehicle_journey_vehicle_journey_aggregate: TimetablesVehicleJourneyVehicleJourneyAggregate;
  /** fetch data from the table: "vehicle_journey.vehicle_journey" using primary key columns */
  timetables_vehicle_journey_vehicle_journey_by_pk?: Maybe<TimetablesVehicleJourneyVehicleJourney>;
  /** fetch data from the table: "vehicle_schedule.vehicle_schedule_frame" */
  timetables_vehicle_schedule_vehicle_schedule_frame: Array<TimetablesVehicleScheduleVehicleScheduleFrame>;
  /** fetch aggregated fields from the table: "vehicle_schedule.vehicle_schedule_frame" */
  timetables_vehicle_schedule_vehicle_schedule_frame_aggregate: TimetablesVehicleScheduleVehicleScheduleFrameAggregate;
  /** fetch data from the table: "vehicle_schedule.vehicle_schedule_frame" using primary key columns */
  timetables_vehicle_schedule_vehicle_schedule_frame_by_pk?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrame>;
  /** fetch data from the table: "vehicle_service.block" */
  timetables_vehicle_service_block: Array<TimetablesVehicleServiceBlock>;
  /** fetch aggregated fields from the table: "vehicle_service.block" */
  timetables_vehicle_service_block_aggregate: TimetablesVehicleServiceBlockAggregate;
  /** fetch data from the table: "vehicle_service.block" using primary key columns */
  timetables_vehicle_service_block_by_pk?: Maybe<TimetablesVehicleServiceBlock>;
  /** execute function "vehicle_service.get_timetable_versions_by_journey_pattern_ids" which returns "return_value.timetable_version" */
  timetables_vehicle_service_get_timetable_versions_by_journey_pattern_ids: Array<TimetablesReturnValueTimetableVersion>;
  /** execute function "vehicle_service.get_timetable_versions_by_journey_pattern_ids" and query aggregates on result of table type "return_value.timetable_version" */
  timetables_vehicle_service_get_timetable_versions_by_journey_pattern_ids_aggregate: TimetablesReturnValueTimetableVersionAggregate;
  /** execute function "vehicle_service.get_timetables_and_substitute_operating_days" which returns "return_value.timetable_version" */
  timetables_vehicle_service_get_timetables_and_substitute_operating_days: Array<TimetablesReturnValueTimetableVersion>;
  /** execute function "vehicle_service.get_timetables_and_substitute_operating_days" and query aggregates on result of table type "return_value.timetable_version" */
  timetables_vehicle_service_get_timetables_and_substitute_operating_days_aggregate: TimetablesReturnValueTimetableVersionAggregate;
  /** fetch data from the table: "vehicle_service.journey_patterns_in_vehicle_service" */
  timetables_vehicle_service_journey_patterns_in_vehicle_service: Array<TimetablesVehicleServiceJourneyPatternsInVehicleService>;
  /** fetch aggregated fields from the table: "vehicle_service.journey_patterns_in_vehicle_service" */
  timetables_vehicle_service_journey_patterns_in_vehicle_service_aggregate: TimetablesVehicleServiceJourneyPatternsInVehicleServiceAggregate;
  /** fetch data from the table: "vehicle_service.journey_patterns_in_vehicle_service" using primary key columns */
  timetables_vehicle_service_journey_patterns_in_vehicle_service_by_pk?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleService>;
  /** fetch data from the table: "vehicle_service.vehicle_service" */
  timetables_vehicle_service_vehicle_service: Array<TimetablesVehicleServiceVehicleService>;
  /** fetch aggregated fields from the table: "vehicle_service.vehicle_service" */
  timetables_vehicle_service_vehicle_service_aggregate: TimetablesVehicleServiceVehicleServiceAggregate;
  /** fetch data from the table: "vehicle_service.vehicle_service" using primary key columns */
  timetables_vehicle_service_vehicle_service_by_pk?: Maybe<TimetablesVehicleServiceVehicleService>;
  /** fetch data from the table: "vehicle_type.vehicle_type" */
  timetables_vehicle_type_vehicle_type: Array<TimetablesVehicleTypeVehicleType>;
  /** fetch aggregated fields from the table: "vehicle_type.vehicle_type" */
  timetables_vehicle_type_vehicle_type_aggregate: TimetablesVehicleTypeVehicleTypeAggregate;
  /** fetch data from the table: "vehicle_type.vehicle_type" using primary key columns */
  timetables_vehicle_type_vehicle_type_by_pk?: Maybe<TimetablesVehicleTypeVehicleType>;
};

export type TimetablesTimetablesQueryTimetablesJourneyPatternJourneyPatternRefArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesJourneyPatternJourneyPatternRefSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesJourneyPatternJourneyPatternRefOrderBy>
    >;
    where?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesJourneyPatternJourneyPatternRefAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesJourneyPatternJourneyPatternRefSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesJourneyPatternJourneyPatternRefOrderBy>
    >;
    where?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesJourneyPatternJourneyPatternRefByPkArgs =
  {
    journey_pattern_ref_id: Scalars['uuid'];
  };

export type TimetablesTimetablesQueryTimetablesPassingTimesTimetabledPassingTimeArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesPassingTimesTimetabledPassingTimeSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesPassingTimesTimetabledPassingTimeOrderBy>
    >;
    where?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesPassingTimesTimetabledPassingTimeAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesPassingTimesTimetabledPassingTimeSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesPassingTimesTimetabledPassingTimeOrderBy>
    >;
    where?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesPassingTimesTimetabledPassingTimeByPkArgs =
  {
    timetabled_passing_time_id: Scalars['uuid'];
  };

export type TimetablesTimetablesQueryTimetablesReturnValueTimetableVersionArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesReturnValueTimetableVersionSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesReturnValueTimetableVersionOrderBy>>;
    where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesReturnValueTimetableVersionAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesReturnValueTimetableVersionSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesReturnValueTimetableVersionOrderBy>>;
    where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesReturnValueVehicleScheduleArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesReturnValueVehicleScheduleSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesReturnValueVehicleScheduleOrderBy>>;
    where?: InputMaybe<TimetablesReturnValueVehicleScheduleBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesReturnValueVehicleScheduleAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesReturnValueVehicleScheduleSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesReturnValueVehicleScheduleOrderBy>>;
    where?: InputMaybe<TimetablesReturnValueVehicleScheduleBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesRouteDirectionArgs = {
  distinct_on?: InputMaybe<Array<TimetablesRouteDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<TimetablesRouteDirectionOrderBy>>;
  where?: InputMaybe<TimetablesRouteDirectionBoolExp>;
};

export type TimetablesTimetablesQueryTimetablesRouteDirectionAggregateArgs = {
  distinct_on?: InputMaybe<Array<TimetablesRouteDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<TimetablesRouteDirectionOrderBy>>;
  where?: InputMaybe<TimetablesRouteDirectionBoolExp>;
};

export type TimetablesTimetablesQueryTimetablesRouteDirectionByPkArgs = {
  direction: Scalars['String'];
};

export type TimetablesTimetablesQueryTimetablesRouteTypeOfLineArgs = {
  distinct_on?: InputMaybe<Array<TimetablesRouteTypeOfLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<TimetablesRouteTypeOfLineOrderBy>>;
  where?: InputMaybe<TimetablesRouteTypeOfLineBoolExp>;
};

export type TimetablesTimetablesQueryTimetablesRouteTypeOfLineAggregateArgs = {
  distinct_on?: InputMaybe<Array<TimetablesRouteTypeOfLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<TimetablesRouteTypeOfLineOrderBy>>;
  where?: InputMaybe<TimetablesRouteTypeOfLineBoolExp>;
};

export type TimetablesTimetablesQueryTimetablesRouteTypeOfLineByPkArgs = {
  type_of_line: Scalars['String'];
};

export type TimetablesTimetablesQueryTimetablesServiceCalendarDayTypeArgs = {
  distinct_on?: InputMaybe<Array<TimetablesServiceCalendarDayTypeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<TimetablesServiceCalendarDayTypeOrderBy>>;
  where?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
};

export type TimetablesTimetablesQueryTimetablesServiceCalendarDayTypeActiveOnDayOfWeekArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekOrderBy>
    >;
    where?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesServiceCalendarDayTypeActiveOnDayOfWeekAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekOrderBy>
    >;
    where?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesServiceCalendarDayTypeActiveOnDayOfWeekByPkArgs =
  {
    day_of_week: Scalars['Int'];
    day_type_id: Scalars['uuid'];
  };

export type TimetablesTimetablesQueryTimetablesServiceCalendarDayTypeAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesServiceCalendarDayTypeSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesServiceCalendarDayTypeOrderBy>>;
    where?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesServiceCalendarDayTypeByPkArgs =
  {
    day_type_id: Scalars['uuid'];
  };

export type TimetablesTimetablesQueryTimetablesServiceCalendarGetActiveDayTypesForDateArgs =
  {
    args: TimetablesServiceCalendarGetActiveDayTypesForDateArgs;
    distinct_on?: InputMaybe<
      Array<TimetablesServiceCalendarDayTypeSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesServiceCalendarDayTypeOrderBy>>;
    where?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesServiceCalendarGetActiveDayTypesForDateAggregateArgs =
  {
    args: TimetablesServiceCalendarGetActiveDayTypesForDateArgs;
    distinct_on?: InputMaybe<
      Array<TimetablesServiceCalendarDayTypeSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesServiceCalendarDayTypeOrderBy>>;
    where?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesServiceCalendarSubstituteOperatingDayByLineTypeArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOrderBy>
    >;
    where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesServiceCalendarSubstituteOperatingDayByLineTypeAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOrderBy>
    >;
    where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesServiceCalendarSubstituteOperatingDayByLineTypeByPkArgs =
  {
    substitute_operating_day_by_line_type_id: Scalars['uuid'];
  };

export type TimetablesTimetablesQueryTimetablesServiceCalendarSubstituteOperatingPeriodArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesServiceCalendarSubstituteOperatingPeriodSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesServiceCalendarSubstituteOperatingPeriodOrderBy>
    >;
    where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesServiceCalendarSubstituteOperatingPeriodAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesServiceCalendarSubstituteOperatingPeriodSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesServiceCalendarSubstituteOperatingPeriodOrderBy>
    >;
    where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesServiceCalendarSubstituteOperatingPeriodByPkArgs =
  {
    substitute_operating_period_id: Scalars['uuid'];
  };

export type TimetablesTimetablesQueryTimetablesServicePatternScheduledStopPointInJourneyPatternRefArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRefOrderBy>
    >;
    where?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesServicePatternScheduledStopPointInJourneyPatternRefAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRefOrderBy>
    >;
    where?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesServicePatternScheduledStopPointInJourneyPatternRefByPkArgs =
  {
    scheduled_stop_point_in_journey_pattern_ref_id: Scalars['uuid'];
  };

export type TimetablesTimetablesQueryTimetablesVehicleJourneyGetVehicleSchedulesOnDateArgs =
  {
    args: TimetablesVehicleJourneyGetVehicleSchedulesOnDateArgs;
    distinct_on?: InputMaybe<
      Array<TimetablesReturnValueVehicleScheduleSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesReturnValueVehicleScheduleOrderBy>>;
    where?: InputMaybe<TimetablesReturnValueVehicleScheduleBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesVehicleJourneyGetVehicleSchedulesOnDateAggregateArgs =
  {
    args: TimetablesVehicleJourneyGetVehicleSchedulesOnDateArgs;
    distinct_on?: InputMaybe<
      Array<TimetablesReturnValueVehicleScheduleSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesReturnValueVehicleScheduleOrderBy>>;
    where?: InputMaybe<TimetablesReturnValueVehicleScheduleBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesVehicleJourneyVehicleJourneyArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesVehicleJourneyVehicleJourneySelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesVehicleJourneyVehicleJourneyOrderBy>>;
    where?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesVehicleJourneyVehicleJourneyAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesVehicleJourneyVehicleJourneySelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesVehicleJourneyVehicleJourneyOrderBy>>;
    where?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesVehicleJourneyVehicleJourneyByPkArgs =
  {
    vehicle_journey_id: Scalars['uuid'];
  };

export type TimetablesTimetablesQueryTimetablesVehicleScheduleVehicleScheduleFrameArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesVehicleScheduleVehicleScheduleFrameSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesVehicleScheduleVehicleScheduleFrameOrderBy>
    >;
    where?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesVehicleScheduleVehicleScheduleFrameAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesVehicleScheduleVehicleScheduleFrameSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesVehicleScheduleVehicleScheduleFrameOrderBy>
    >;
    where?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesVehicleScheduleVehicleScheduleFrameByPkArgs =
  {
    vehicle_schedule_frame_id: Scalars['uuid'];
  };

export type TimetablesTimetablesQueryTimetablesVehicleServiceBlockArgs = {
  distinct_on?: InputMaybe<Array<TimetablesVehicleServiceBlockSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<TimetablesVehicleServiceBlockOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceBlockBoolExp>;
};

export type TimetablesTimetablesQueryTimetablesVehicleServiceBlockAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<TimetablesVehicleServiceBlockSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesVehicleServiceBlockOrderBy>>;
    where?: InputMaybe<TimetablesVehicleServiceBlockBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesVehicleServiceBlockByPkArgs = {
  block_id: Scalars['uuid'];
};

export type TimetablesTimetablesQueryTimetablesVehicleServiceGetTimetableVersionsByJourneyPatternIdsArgs =
  {
    args: TimetablesVehicleServiceGetTimetableVersionsByJourneyPatternIdsArgs;
    distinct_on?: InputMaybe<
      Array<TimetablesReturnValueTimetableVersionSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesReturnValueTimetableVersionOrderBy>>;
    where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesVehicleServiceGetTimetableVersionsByJourneyPatternIdsAggregateArgs =
  {
    args: TimetablesVehicleServiceGetTimetableVersionsByJourneyPatternIdsArgs;
    distinct_on?: InputMaybe<
      Array<TimetablesReturnValueTimetableVersionSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesReturnValueTimetableVersionOrderBy>>;
    where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesVehicleServiceGetTimetablesAndSubstituteOperatingDaysArgs =
  {
    args: TimetablesVehicleServiceGetTimetablesAndSubstituteOperatingDaysArgs;
    distinct_on?: InputMaybe<
      Array<TimetablesReturnValueTimetableVersionSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesReturnValueTimetableVersionOrderBy>>;
    where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesVehicleServiceGetTimetablesAndSubstituteOperatingDaysAggregateArgs =
  {
    args: TimetablesVehicleServiceGetTimetablesAndSubstituteOperatingDaysArgs;
    distinct_on?: InputMaybe<
      Array<TimetablesReturnValueTimetableVersionSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesReturnValueTimetableVersionOrderBy>>;
    where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesVehicleServiceJourneyPatternsInVehicleServiceArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesVehicleServiceJourneyPatternsInVehicleServiceOrderBy>
    >;
    where?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesVehicleServiceJourneyPatternsInVehicleServiceAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesVehicleServiceJourneyPatternsInVehicleServiceOrderBy>
    >;
    where?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesVehicleServiceJourneyPatternsInVehicleServiceByPkArgs =
  {
    journey_pattern_id: Scalars['uuid'];
    vehicle_service_id: Scalars['uuid'];
  };

export type TimetablesTimetablesQueryTimetablesVehicleServiceVehicleServiceArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesVehicleServiceVehicleServiceSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesVehicleServiceVehicleServiceOrderBy>>;
    where?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesVehicleServiceVehicleServiceAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesVehicleServiceVehicleServiceSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesVehicleServiceVehicleServiceOrderBy>>;
    where?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesVehicleServiceVehicleServiceByPkArgs =
  {
    vehicle_service_id: Scalars['uuid'];
  };

export type TimetablesTimetablesQueryTimetablesVehicleTypeVehicleTypeArgs = {
  distinct_on?: InputMaybe<Array<TimetablesVehicleTypeVehicleTypeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<TimetablesVehicleTypeVehicleTypeOrderBy>>;
  where?: InputMaybe<TimetablesVehicleTypeVehicleTypeBoolExp>;
};

export type TimetablesTimetablesQueryTimetablesVehicleTypeVehicleTypeAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesVehicleTypeVehicleTypeSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesVehicleTypeVehicleTypeOrderBy>>;
    where?: InputMaybe<TimetablesVehicleTypeVehicleTypeBoolExp>;
  };

export type TimetablesTimetablesQueryTimetablesVehicleTypeVehicleTypeByPkArgs =
  {
    vehicle_type_id: Scalars['uuid'];
  };

export type TimetablesTimetablesSubscription = {
  __typename?: 'timetables_timetables_subscription';
  /** fetch data from the table: "journey_pattern.journey_pattern_ref" */
  timetables_journey_pattern_journey_pattern_ref: Array<TimetablesJourneyPatternJourneyPatternRef>;
  /** fetch aggregated fields from the table: "journey_pattern.journey_pattern_ref" */
  timetables_journey_pattern_journey_pattern_ref_aggregate: TimetablesJourneyPatternJourneyPatternRefAggregate;
  /** fetch data from the table: "journey_pattern.journey_pattern_ref" using primary key columns */
  timetables_journey_pattern_journey_pattern_ref_by_pk?: Maybe<TimetablesJourneyPatternJourneyPatternRef>;
  /** fetch data from the table in a streaming manner: "journey_pattern.journey_pattern_ref" */
  timetables_journey_pattern_journey_pattern_ref_stream: Array<TimetablesJourneyPatternJourneyPatternRef>;
  /** fetch data from the table: "passing_times.timetabled_passing_time" */
  timetables_passing_times_timetabled_passing_time: Array<TimetablesPassingTimesTimetabledPassingTime>;
  /** fetch aggregated fields from the table: "passing_times.timetabled_passing_time" */
  timetables_passing_times_timetabled_passing_time_aggregate: TimetablesPassingTimesTimetabledPassingTimeAggregate;
  /** fetch data from the table: "passing_times.timetabled_passing_time" using primary key columns */
  timetables_passing_times_timetabled_passing_time_by_pk?: Maybe<TimetablesPassingTimesTimetabledPassingTime>;
  /** fetch data from the table in a streaming manner: "passing_times.timetabled_passing_time" */
  timetables_passing_times_timetabled_passing_time_stream: Array<TimetablesPassingTimesTimetabledPassingTime>;
  /** fetch data from the table: "return_value.timetable_version" */
  timetables_return_value_timetable_version: Array<TimetablesReturnValueTimetableVersion>;
  /** fetch aggregated fields from the table: "return_value.timetable_version" */
  timetables_return_value_timetable_version_aggregate: TimetablesReturnValueTimetableVersionAggregate;
  /** fetch data from the table in a streaming manner: "return_value.timetable_version" */
  timetables_return_value_timetable_version_stream: Array<TimetablesReturnValueTimetableVersion>;
  /** fetch data from the table: "return_value.vehicle_schedule" */
  timetables_return_value_vehicle_schedule: Array<TimetablesReturnValueVehicleSchedule>;
  /** fetch aggregated fields from the table: "return_value.vehicle_schedule" */
  timetables_return_value_vehicle_schedule_aggregate: TimetablesReturnValueVehicleScheduleAggregate;
  /** fetch data from the table in a streaming manner: "return_value.vehicle_schedule" */
  timetables_return_value_vehicle_schedule_stream: Array<TimetablesReturnValueVehicleSchedule>;
  /** fetch data from the table: "route.direction" */
  timetables_route_direction: Array<TimetablesRouteDirection>;
  /** fetch aggregated fields from the table: "route.direction" */
  timetables_route_direction_aggregate: TimetablesRouteDirectionAggregate;
  /** fetch data from the table: "route.direction" using primary key columns */
  timetables_route_direction_by_pk?: Maybe<TimetablesRouteDirection>;
  /** fetch data from the table in a streaming manner: "route.direction" */
  timetables_route_direction_stream: Array<TimetablesRouteDirection>;
  /** fetch data from the table: "route.type_of_line" */
  timetables_route_type_of_line: Array<TimetablesRouteTypeOfLine>;
  /** fetch aggregated fields from the table: "route.type_of_line" */
  timetables_route_type_of_line_aggregate: TimetablesRouteTypeOfLineAggregate;
  /** fetch data from the table: "route.type_of_line" using primary key columns */
  timetables_route_type_of_line_by_pk?: Maybe<TimetablesRouteTypeOfLine>;
  /** fetch data from the table in a streaming manner: "route.type_of_line" */
  timetables_route_type_of_line_stream: Array<TimetablesRouteTypeOfLine>;
  /** fetch data from the table: "service_calendar.day_type" */
  timetables_service_calendar_day_type: Array<TimetablesServiceCalendarDayType>;
  /** fetch data from the table: "service_calendar.day_type_active_on_day_of_week" */
  timetables_service_calendar_day_type_active_on_day_of_week: Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeek>;
  /** fetch aggregated fields from the table: "service_calendar.day_type_active_on_day_of_week" */
  timetables_service_calendar_day_type_active_on_day_of_week_aggregate: TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAggregate;
  /** fetch data from the table: "service_calendar.day_type_active_on_day_of_week" using primary key columns */
  timetables_service_calendar_day_type_active_on_day_of_week_by_pk?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeek>;
  /** fetch data from the table in a streaming manner: "service_calendar.day_type_active_on_day_of_week" */
  timetables_service_calendar_day_type_active_on_day_of_week_stream: Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeek>;
  /** fetch aggregated fields from the table: "service_calendar.day_type" */
  timetables_service_calendar_day_type_aggregate: TimetablesServiceCalendarDayTypeAggregate;
  /** fetch data from the table: "service_calendar.day_type" using primary key columns */
  timetables_service_calendar_day_type_by_pk?: Maybe<TimetablesServiceCalendarDayType>;
  /** fetch data from the table in a streaming manner: "service_calendar.day_type" */
  timetables_service_calendar_day_type_stream: Array<TimetablesServiceCalendarDayType>;
  /** execute function "service_calendar.get_active_day_types_for_date" which returns "service_calendar.day_type" */
  timetables_service_calendar_get_active_day_types_for_date: Array<TimetablesServiceCalendarDayType>;
  /** execute function "service_calendar.get_active_day_types_for_date" and query aggregates on result of table type "service_calendar.day_type" */
  timetables_service_calendar_get_active_day_types_for_date_aggregate: TimetablesServiceCalendarDayTypeAggregate;
  /** fetch data from the table: "service_calendar.substitute_operating_day_by_line_type" */
  timetables_service_calendar_substitute_operating_day_by_line_type: Array<TimetablesServiceCalendarSubstituteOperatingDayByLineType>;
  /** fetch aggregated fields from the table: "service_calendar.substitute_operating_day_by_line_type" */
  timetables_service_calendar_substitute_operating_day_by_line_type_aggregate: TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAggregate;
  /** fetch data from the table: "service_calendar.substitute_operating_day_by_line_type" using primary key columns */
  timetables_service_calendar_substitute_operating_day_by_line_type_by_pk?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineType>;
  /** fetch data from the table in a streaming manner: "service_calendar.substitute_operating_day_by_line_type" */
  timetables_service_calendar_substitute_operating_day_by_line_type_stream: Array<TimetablesServiceCalendarSubstituteOperatingDayByLineType>;
  /** fetch data from the table: "service_calendar.substitute_operating_period" */
  timetables_service_calendar_substitute_operating_period: Array<TimetablesServiceCalendarSubstituteOperatingPeriod>;
  /** fetch aggregated fields from the table: "service_calendar.substitute_operating_period" */
  timetables_service_calendar_substitute_operating_period_aggregate: TimetablesServiceCalendarSubstituteOperatingPeriodAggregate;
  /** fetch data from the table: "service_calendar.substitute_operating_period" using primary key columns */
  timetables_service_calendar_substitute_operating_period_by_pk?: Maybe<TimetablesServiceCalendarSubstituteOperatingPeriod>;
  /** fetch data from the table in a streaming manner: "service_calendar.substitute_operating_period" */
  timetables_service_calendar_substitute_operating_period_stream: Array<TimetablesServiceCalendarSubstituteOperatingPeriod>;
  /** fetch data from the table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
  timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref: Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRef>;
  /** fetch aggregated fields from the table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
  timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_aggregate: TimetablesServicePatternScheduledStopPointInJourneyPatternRefAggregate;
  /** fetch data from the table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" using primary key columns */
  timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_by_pk?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRef>;
  /** fetch data from the table in a streaming manner: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
  timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_stream: Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRef>;
  /** execute function "vehicle_journey.get_vehicle_schedules_on_date" which returns "return_value.vehicle_schedule" */
  timetables_vehicle_journey_get_vehicle_schedules_on_date: Array<TimetablesReturnValueVehicleSchedule>;
  /** execute function "vehicle_journey.get_vehicle_schedules_on_date" and query aggregates on result of table type "return_value.vehicle_schedule" */
  timetables_vehicle_journey_get_vehicle_schedules_on_date_aggregate: TimetablesReturnValueVehicleScheduleAggregate;
  /** fetch data from the table: "vehicle_journey.vehicle_journey" */
  timetables_vehicle_journey_vehicle_journey: Array<TimetablesVehicleJourneyVehicleJourney>;
  /** fetch aggregated fields from the table: "vehicle_journey.vehicle_journey" */
  timetables_vehicle_journey_vehicle_journey_aggregate: TimetablesVehicleJourneyVehicleJourneyAggregate;
  /** fetch data from the table: "vehicle_journey.vehicle_journey" using primary key columns */
  timetables_vehicle_journey_vehicle_journey_by_pk?: Maybe<TimetablesVehicleJourneyVehicleJourney>;
  /** fetch data from the table in a streaming manner: "vehicle_journey.vehicle_journey" */
  timetables_vehicle_journey_vehicle_journey_stream: Array<TimetablesVehicleJourneyVehicleJourney>;
  /** fetch data from the table: "vehicle_schedule.vehicle_schedule_frame" */
  timetables_vehicle_schedule_vehicle_schedule_frame: Array<TimetablesVehicleScheduleVehicleScheduleFrame>;
  /** fetch aggregated fields from the table: "vehicle_schedule.vehicle_schedule_frame" */
  timetables_vehicle_schedule_vehicle_schedule_frame_aggregate: TimetablesVehicleScheduleVehicleScheduleFrameAggregate;
  /** fetch data from the table: "vehicle_schedule.vehicle_schedule_frame" using primary key columns */
  timetables_vehicle_schedule_vehicle_schedule_frame_by_pk?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrame>;
  /** fetch data from the table in a streaming manner: "vehicle_schedule.vehicle_schedule_frame" */
  timetables_vehicle_schedule_vehicle_schedule_frame_stream: Array<TimetablesVehicleScheduleVehicleScheduleFrame>;
  /** fetch data from the table: "vehicle_service.block" */
  timetables_vehicle_service_block: Array<TimetablesVehicleServiceBlock>;
  /** fetch aggregated fields from the table: "vehicle_service.block" */
  timetables_vehicle_service_block_aggregate: TimetablesVehicleServiceBlockAggregate;
  /** fetch data from the table: "vehicle_service.block" using primary key columns */
  timetables_vehicle_service_block_by_pk?: Maybe<TimetablesVehicleServiceBlock>;
  /** fetch data from the table in a streaming manner: "vehicle_service.block" */
  timetables_vehicle_service_block_stream: Array<TimetablesVehicleServiceBlock>;
  /** execute function "vehicle_service.get_timetable_versions_by_journey_pattern_ids" which returns "return_value.timetable_version" */
  timetables_vehicle_service_get_timetable_versions_by_journey_pattern_ids: Array<TimetablesReturnValueTimetableVersion>;
  /** execute function "vehicle_service.get_timetable_versions_by_journey_pattern_ids" and query aggregates on result of table type "return_value.timetable_version" */
  timetables_vehicle_service_get_timetable_versions_by_journey_pattern_ids_aggregate: TimetablesReturnValueTimetableVersionAggregate;
  /** execute function "vehicle_service.get_timetables_and_substitute_operating_days" which returns "return_value.timetable_version" */
  timetables_vehicle_service_get_timetables_and_substitute_operating_days: Array<TimetablesReturnValueTimetableVersion>;
  /** execute function "vehicle_service.get_timetables_and_substitute_operating_days" and query aggregates on result of table type "return_value.timetable_version" */
  timetables_vehicle_service_get_timetables_and_substitute_operating_days_aggregate: TimetablesReturnValueTimetableVersionAggregate;
  /** fetch data from the table: "vehicle_service.journey_patterns_in_vehicle_service" */
  timetables_vehicle_service_journey_patterns_in_vehicle_service: Array<TimetablesVehicleServiceJourneyPatternsInVehicleService>;
  /** fetch aggregated fields from the table: "vehicle_service.journey_patterns_in_vehicle_service" */
  timetables_vehicle_service_journey_patterns_in_vehicle_service_aggregate: TimetablesVehicleServiceJourneyPatternsInVehicleServiceAggregate;
  /** fetch data from the table: "vehicle_service.journey_patterns_in_vehicle_service" using primary key columns */
  timetables_vehicle_service_journey_patterns_in_vehicle_service_by_pk?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleService>;
  /** fetch data from the table in a streaming manner: "vehicle_service.journey_patterns_in_vehicle_service" */
  timetables_vehicle_service_journey_patterns_in_vehicle_service_stream: Array<TimetablesVehicleServiceJourneyPatternsInVehicleService>;
  /** fetch data from the table: "vehicle_service.vehicle_service" */
  timetables_vehicle_service_vehicle_service: Array<TimetablesVehicleServiceVehicleService>;
  /** fetch aggregated fields from the table: "vehicle_service.vehicle_service" */
  timetables_vehicle_service_vehicle_service_aggregate: TimetablesVehicleServiceVehicleServiceAggregate;
  /** fetch data from the table: "vehicle_service.vehicle_service" using primary key columns */
  timetables_vehicle_service_vehicle_service_by_pk?: Maybe<TimetablesVehicleServiceVehicleService>;
  /** fetch data from the table in a streaming manner: "vehicle_service.vehicle_service" */
  timetables_vehicle_service_vehicle_service_stream: Array<TimetablesVehicleServiceVehicleService>;
  /** fetch data from the table: "vehicle_type.vehicle_type" */
  timetables_vehicle_type_vehicle_type: Array<TimetablesVehicleTypeVehicleType>;
  /** fetch aggregated fields from the table: "vehicle_type.vehicle_type" */
  timetables_vehicle_type_vehicle_type_aggregate: TimetablesVehicleTypeVehicleTypeAggregate;
  /** fetch data from the table: "vehicle_type.vehicle_type" using primary key columns */
  timetables_vehicle_type_vehicle_type_by_pk?: Maybe<TimetablesVehicleTypeVehicleType>;
  /** fetch data from the table in a streaming manner: "vehicle_type.vehicle_type" */
  timetables_vehicle_type_vehicle_type_stream: Array<TimetablesVehicleTypeVehicleType>;
};

export type TimetablesTimetablesSubscriptionTimetablesJourneyPatternJourneyPatternRefArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesJourneyPatternJourneyPatternRefSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesJourneyPatternJourneyPatternRefOrderBy>
    >;
    where?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesJourneyPatternJourneyPatternRefAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesJourneyPatternJourneyPatternRefSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesJourneyPatternJourneyPatternRefOrderBy>
    >;
    where?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesJourneyPatternJourneyPatternRefByPkArgs =
  {
    journey_pattern_ref_id: Scalars['uuid'];
  };

export type TimetablesTimetablesSubscriptionTimetablesJourneyPatternJourneyPatternRefStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<TimetablesJourneyPatternJourneyPatternRefStreamCursorInput>
    >;
    where?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesPassingTimesTimetabledPassingTimeArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesPassingTimesTimetabledPassingTimeSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesPassingTimesTimetabledPassingTimeOrderBy>
    >;
    where?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesPassingTimesTimetabledPassingTimeAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesPassingTimesTimetabledPassingTimeSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesPassingTimesTimetabledPassingTimeOrderBy>
    >;
    where?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesPassingTimesTimetabledPassingTimeByPkArgs =
  {
    timetabled_passing_time_id: Scalars['uuid'];
  };

export type TimetablesTimetablesSubscriptionTimetablesPassingTimesTimetabledPassingTimeStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<TimetablesPassingTimesTimetabledPassingTimeStreamCursorInput>
    >;
    where?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesReturnValueTimetableVersionArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesReturnValueTimetableVersionSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesReturnValueTimetableVersionOrderBy>>;
    where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesReturnValueTimetableVersionAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesReturnValueTimetableVersionSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesReturnValueTimetableVersionOrderBy>>;
    where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesReturnValueTimetableVersionStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<TimetablesReturnValueTimetableVersionStreamCursorInput>
    >;
    where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesReturnValueVehicleScheduleArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesReturnValueVehicleScheduleSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesReturnValueVehicleScheduleOrderBy>>;
    where?: InputMaybe<TimetablesReturnValueVehicleScheduleBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesReturnValueVehicleScheduleAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesReturnValueVehicleScheduleSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesReturnValueVehicleScheduleOrderBy>>;
    where?: InputMaybe<TimetablesReturnValueVehicleScheduleBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesReturnValueVehicleScheduleStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<TimetablesReturnValueVehicleScheduleStreamCursorInput>
    >;
    where?: InputMaybe<TimetablesReturnValueVehicleScheduleBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesRouteDirectionArgs = {
  distinct_on?: InputMaybe<Array<TimetablesRouteDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<TimetablesRouteDirectionOrderBy>>;
  where?: InputMaybe<TimetablesRouteDirectionBoolExp>;
};

export type TimetablesTimetablesSubscriptionTimetablesRouteDirectionAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<TimetablesRouteDirectionSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesRouteDirectionOrderBy>>;
    where?: InputMaybe<TimetablesRouteDirectionBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesRouteDirectionByPkArgs = {
  direction: Scalars['String'];
};

export type TimetablesTimetablesSubscriptionTimetablesRouteDirectionStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<TimetablesRouteDirectionStreamCursorInput>>;
    where?: InputMaybe<TimetablesRouteDirectionBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesRouteTypeOfLineArgs = {
  distinct_on?: InputMaybe<Array<TimetablesRouteTypeOfLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<TimetablesRouteTypeOfLineOrderBy>>;
  where?: InputMaybe<TimetablesRouteTypeOfLineBoolExp>;
};

export type TimetablesTimetablesSubscriptionTimetablesRouteTypeOfLineAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<TimetablesRouteTypeOfLineSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesRouteTypeOfLineOrderBy>>;
    where?: InputMaybe<TimetablesRouteTypeOfLineBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesRouteTypeOfLineByPkArgs =
  {
    type_of_line: Scalars['String'];
  };

export type TimetablesTimetablesSubscriptionTimetablesRouteTypeOfLineStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<TimetablesRouteTypeOfLineStreamCursorInput>>;
    where?: InputMaybe<TimetablesRouteTypeOfLineBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarDayTypeArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesServiceCalendarDayTypeSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesServiceCalendarDayTypeOrderBy>>;
    where?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarDayTypeActiveOnDayOfWeekArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekOrderBy>
    >;
    where?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarDayTypeActiveOnDayOfWeekAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekOrderBy>
    >;
    where?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarDayTypeActiveOnDayOfWeekByPkArgs =
  {
    day_of_week: Scalars['Int'];
    day_type_id: Scalars['uuid'];
  };

export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarDayTypeActiveOnDayOfWeekStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStreamCursorInput>
    >;
    where?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarDayTypeAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesServiceCalendarDayTypeSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesServiceCalendarDayTypeOrderBy>>;
    where?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarDayTypeByPkArgs =
  {
    day_type_id: Scalars['uuid'];
  };

export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarDayTypeStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<TimetablesServiceCalendarDayTypeStreamCursorInput>
    >;
    where?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarGetActiveDayTypesForDateArgs =
  {
    args: TimetablesServiceCalendarGetActiveDayTypesForDateArgs;
    distinct_on?: InputMaybe<
      Array<TimetablesServiceCalendarDayTypeSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesServiceCalendarDayTypeOrderBy>>;
    where?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarGetActiveDayTypesForDateAggregateArgs =
  {
    args: TimetablesServiceCalendarGetActiveDayTypesForDateArgs;
    distinct_on?: InputMaybe<
      Array<TimetablesServiceCalendarDayTypeSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesServiceCalendarDayTypeOrderBy>>;
    where?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarSubstituteOperatingDayByLineTypeArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOrderBy>
    >;
    where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarSubstituteOperatingDayByLineTypeAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOrderBy>
    >;
    where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarSubstituteOperatingDayByLineTypeByPkArgs =
  {
    substitute_operating_day_by_line_type_id: Scalars['uuid'];
  };

export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarSubstituteOperatingDayByLineTypeStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStreamCursorInput>
    >;
    where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarSubstituteOperatingPeriodArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesServiceCalendarSubstituteOperatingPeriodSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesServiceCalendarSubstituteOperatingPeriodOrderBy>
    >;
    where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarSubstituteOperatingPeriodAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesServiceCalendarSubstituteOperatingPeriodSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesServiceCalendarSubstituteOperatingPeriodOrderBy>
    >;
    where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarSubstituteOperatingPeriodByPkArgs =
  {
    substitute_operating_period_id: Scalars['uuid'];
  };

export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarSubstituteOperatingPeriodStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodStreamCursorInput>
    >;
    where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesServicePatternScheduledStopPointInJourneyPatternRefArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRefOrderBy>
    >;
    where?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesServicePatternScheduledStopPointInJourneyPatternRefAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesServicePatternScheduledStopPointInJourneyPatternRefOrderBy>
    >;
    where?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesServicePatternScheduledStopPointInJourneyPatternRefByPkArgs =
  {
    scheduled_stop_point_in_journey_pattern_ref_id: Scalars['uuid'];
  };

export type TimetablesTimetablesSubscriptionTimetablesServicePatternScheduledStopPointInJourneyPatternRefStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefStreamCursorInput>
    >;
    where?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleJourneyGetVehicleSchedulesOnDateArgs =
  {
    args: TimetablesVehicleJourneyGetVehicleSchedulesOnDateArgs;
    distinct_on?: InputMaybe<
      Array<TimetablesReturnValueVehicleScheduleSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesReturnValueVehicleScheduleOrderBy>>;
    where?: InputMaybe<TimetablesReturnValueVehicleScheduleBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleJourneyGetVehicleSchedulesOnDateAggregateArgs =
  {
    args: TimetablesVehicleJourneyGetVehicleSchedulesOnDateArgs;
    distinct_on?: InputMaybe<
      Array<TimetablesReturnValueVehicleScheduleSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesReturnValueVehicleScheduleOrderBy>>;
    where?: InputMaybe<TimetablesReturnValueVehicleScheduleBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleJourneyVehicleJourneyArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesVehicleJourneyVehicleJourneySelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesVehicleJourneyVehicleJourneyOrderBy>>;
    where?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleJourneyVehicleJourneyAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesVehicleJourneyVehicleJourneySelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesVehicleJourneyVehicleJourneyOrderBy>>;
    where?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleJourneyVehicleJourneyByPkArgs =
  {
    vehicle_journey_id: Scalars['uuid'];
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleJourneyVehicleJourneyStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<TimetablesVehicleJourneyVehicleJourneyStreamCursorInput>
    >;
    where?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleScheduleVehicleScheduleFrameArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesVehicleScheduleVehicleScheduleFrameSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesVehicleScheduleVehicleScheduleFrameOrderBy>
    >;
    where?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleScheduleVehicleScheduleFrameAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesVehicleScheduleVehicleScheduleFrameSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesVehicleScheduleVehicleScheduleFrameOrderBy>
    >;
    where?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleScheduleVehicleScheduleFrameByPkArgs =
  {
    vehicle_schedule_frame_id: Scalars['uuid'];
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleScheduleVehicleScheduleFrameStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameStreamCursorInput>
    >;
    where?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceBlockArgs =
  {
    distinct_on?: InputMaybe<Array<TimetablesVehicleServiceBlockSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesVehicleServiceBlockOrderBy>>;
    where?: InputMaybe<TimetablesVehicleServiceBlockBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceBlockAggregateArgs =
  {
    distinct_on?: InputMaybe<Array<TimetablesVehicleServiceBlockSelectColumn>>;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesVehicleServiceBlockOrderBy>>;
    where?: InputMaybe<TimetablesVehicleServiceBlockBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceBlockByPkArgs =
  {
    block_id: Scalars['uuid'];
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceBlockStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<InputMaybe<TimetablesVehicleServiceBlockStreamCursorInput>>;
    where?: InputMaybe<TimetablesVehicleServiceBlockBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceGetTimetableVersionsByJourneyPatternIdsArgs =
  {
    args: TimetablesVehicleServiceGetTimetableVersionsByJourneyPatternIdsArgs;
    distinct_on?: InputMaybe<
      Array<TimetablesReturnValueTimetableVersionSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesReturnValueTimetableVersionOrderBy>>;
    where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceGetTimetableVersionsByJourneyPatternIdsAggregateArgs =
  {
    args: TimetablesVehicleServiceGetTimetableVersionsByJourneyPatternIdsArgs;
    distinct_on?: InputMaybe<
      Array<TimetablesReturnValueTimetableVersionSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesReturnValueTimetableVersionOrderBy>>;
    where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceGetTimetablesAndSubstituteOperatingDaysArgs =
  {
    args: TimetablesVehicleServiceGetTimetablesAndSubstituteOperatingDaysArgs;
    distinct_on?: InputMaybe<
      Array<TimetablesReturnValueTimetableVersionSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesReturnValueTimetableVersionOrderBy>>;
    where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceGetTimetablesAndSubstituteOperatingDaysAggregateArgs =
  {
    args: TimetablesVehicleServiceGetTimetablesAndSubstituteOperatingDaysArgs;
    distinct_on?: InputMaybe<
      Array<TimetablesReturnValueTimetableVersionSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesReturnValueTimetableVersionOrderBy>>;
    where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceJourneyPatternsInVehicleServiceArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesVehicleServiceJourneyPatternsInVehicleServiceOrderBy>
    >;
    where?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceJourneyPatternsInVehicleServiceAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesVehicleServiceJourneyPatternsInVehicleServiceOrderBy>
    >;
    where?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceJourneyPatternsInVehicleServiceByPkArgs =
  {
    journey_pattern_id: Scalars['uuid'];
    vehicle_service_id: Scalars['uuid'];
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceJourneyPatternsInVehicleServiceStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceStreamCursorInput>
    >;
    where?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceVehicleServiceArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesVehicleServiceVehicleServiceSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesVehicleServiceVehicleServiceOrderBy>>;
    where?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceVehicleServiceAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesVehicleServiceVehicleServiceSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesVehicleServiceVehicleServiceOrderBy>>;
    where?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceVehicleServiceByPkArgs =
  {
    vehicle_service_id: Scalars['uuid'];
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceVehicleServiceStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<TimetablesVehicleServiceVehicleServiceStreamCursorInput>
    >;
    where?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleTypeVehicleTypeArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesVehicleTypeVehicleTypeSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesVehicleTypeVehicleTypeOrderBy>>;
    where?: InputMaybe<TimetablesVehicleTypeVehicleTypeBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleTypeVehicleTypeAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesVehicleTypeVehicleTypeSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesVehicleTypeVehicleTypeOrderBy>>;
    where?: InputMaybe<TimetablesVehicleTypeVehicleTypeBoolExp>;
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleTypeVehicleTypeByPkArgs =
  {
    vehicle_type_id: Scalars['uuid'];
  };

export type TimetablesTimetablesSubscriptionTimetablesVehicleTypeVehicleTypeStreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      InputMaybe<TimetablesVehicleTypeVehicleTypeStreamCursorInput>
    >;
    where?: InputMaybe<TimetablesVehicleTypeVehicleTypeBoolExp>;
  };

export type TimetablesVehicleJourneyGetVehicleSchedulesOnDateArgs = {
  journey_pattern_uuid?: InputMaybe<Scalars['uuid']>;
  observation_date?: InputMaybe<Scalars['date']>;
};

/** The planned movement of a public transport vehicle on a DAY TYPE from the start point to the end point of a JOURNEY PATTERN on a specified ROUTE. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:1:1:831  */
export type TimetablesVehicleJourneyVehicleJourney = {
  __typename?: 'timetables_vehicle_journey_vehicle_journey';
  /** An object relationship */
  block: TimetablesVehicleServiceBlock;
  /** The BLOCK to which this VEHICLE JOURNEY belongs */
  block_id: Scalars['uuid'];
  /** The contract number for this vehicle journey. */
  contract_number: Scalars['String'];
  /** Displayed name of the journey. */
  displayed_name?: Maybe<Scalars['String']>;
  /** A computed field, executes function "vehicle_journey.vehicle_journey_end_time" */
  end_time: Scalars['interval'];
  /** Is the journey a backup journey. */
  is_backup_journey: Scalars['Boolean'];
  /** Is the journey an extra journey. */
  is_extra_journey: Scalars['Boolean'];
  /** It is required to use the same vehicle type as required in vehicle service. */
  is_vehicle_type_mandatory: Scalars['Boolean'];
  /** Name that user can give to the vehicle journey. */
  journey_name_i18n?: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  journey_pattern_ref: TimetablesJourneyPatternJourneyPatternRef;
  /** The JOURNEY PATTERN on which the VEHICLE JOURNEY travels */
  journey_pattern_ref_id: Scalars['uuid'];
  /** STANDARD | DRY_RUN | SERVICE_JOURNEY */
  journey_type: Scalars['String'];
  /** LAYOVER TIMEs describe a certain time allowance that may be given at the end of each VEHICLE JOURNEY, before starting the next one, to compensate delays or for other purposes (e.g. rest time for the driver). This “layover time” can be regarded as a buffer time, which may or may not be actually consumed in real time operation. */
  layover_time?: Maybe<Scalars['interval']>;
  /** A computed field, executes function "vehicle_journey.vehicle_journey_start_time" */
  start_time: Scalars['interval'];
  /** An array relationship */
  timetabled_passing_times: Array<TimetablesPassingTimesTimetabledPassingTime>;
  /** An aggregate relationship */
  timetabled_passing_times_aggregate: TimetablesPassingTimesTimetabledPassingTimeAggregate;
  /** Turnaround time is the time taken by a vehicle to proceed from the end of a ROUTE to the start of another. */
  turnaround_time?: Maybe<Scalars['interval']>;
  vehicle_journey_id: Scalars['uuid'];
};

/** The planned movement of a public transport vehicle on a DAY TYPE from the start point to the end point of a JOURNEY PATTERN on a specified ROUTE. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:1:1:831  */
export type TimetablesVehicleJourneyVehicleJourneyJourneyNameI18nArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** The planned movement of a public transport vehicle on a DAY TYPE from the start point to the end point of a JOURNEY PATTERN on a specified ROUTE. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:1:1:831  */
export type TimetablesVehicleJourneyVehicleJourneyTimetabledPassingTimesArgs = {
  distinct_on?: InputMaybe<
    Array<TimetablesPassingTimesTimetabledPassingTimeSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<
    Array<TimetablesPassingTimesTimetabledPassingTimeOrderBy>
  >;
  where?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
};

/** The planned movement of a public transport vehicle on a DAY TYPE from the start point to the end point of a JOURNEY PATTERN on a specified ROUTE. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:1:1:831  */
export type TimetablesVehicleJourneyVehicleJourneyTimetabledPassingTimesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesPassingTimesTimetabledPassingTimeSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesPassingTimesTimetabledPassingTimeOrderBy>
    >;
    where?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
  };

/** aggregated selection of "vehicle_journey.vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneyAggregate = {
  __typename?: 'timetables_vehicle_journey_vehicle_journey_aggregate';
  aggregate?: Maybe<TimetablesVehicleJourneyVehicleJourneyAggregateFields>;
  nodes: Array<TimetablesVehicleJourneyVehicleJourney>;
};

/** aggregate fields of "vehicle_journey.vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneyAggregateFields = {
  __typename?: 'timetables_vehicle_journey_vehicle_journey_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<TimetablesVehicleJourneyVehicleJourneyMaxFields>;
  min?: Maybe<TimetablesVehicleJourneyVehicleJourneyMinFields>;
};

/** aggregate fields of "vehicle_journey.vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneyAggregateFieldsCountArgs = {
  columns?: InputMaybe<
    Array<TimetablesVehicleJourneyVehicleJourneySelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "vehicle_journey.vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneyAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyMaxOrderBy>;
  min?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyMinOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type TimetablesVehicleJourneyVehicleJourneyAppendInput = {
  /** Name that user can give to the vehicle journey. */
  journey_name_i18n?: InputMaybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "vehicle_journey.vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneyArrRelInsertInput = {
  data: Array<TimetablesVehicleJourneyVehicleJourneyInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyOnConflict>;
};

/** Boolean expression to filter rows from the table "vehicle_journey.vehicle_journey". All fields are combined with a logical 'AND'. */
export type TimetablesVehicleJourneyVehicleJourneyBoolExp = {
  _and?: InputMaybe<Array<TimetablesVehicleJourneyVehicleJourneyBoolExp>>;
  _not?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
  _or?: InputMaybe<Array<TimetablesVehicleJourneyVehicleJourneyBoolExp>>;
  block?: InputMaybe<TimetablesVehicleServiceBlockBoolExp>;
  block_id?: InputMaybe<UuidComparisonExp>;
  contract_number?: InputMaybe<StringComparisonExp>;
  displayed_name?: InputMaybe<StringComparisonExp>;
  end_time?: InputMaybe<StringComparisonExp>;
  is_backup_journey?: InputMaybe<BooleanComparisonExp>;
  is_extra_journey?: InputMaybe<BooleanComparisonExp>;
  is_vehicle_type_mandatory?: InputMaybe<BooleanComparisonExp>;
  journey_name_i18n?: InputMaybe<JsonbComparisonExp>;
  journey_pattern_ref?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefBoolExp>;
  journey_pattern_ref_id?: InputMaybe<UuidComparisonExp>;
  journey_type?: InputMaybe<StringComparisonExp>;
  layover_time?: InputMaybe<IntervalComparisonExp>;
  start_time?: InputMaybe<StringComparisonExp>;
  timetabled_passing_times?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
  timetabled_passing_times_aggregate?: InputMaybe<PassingTimesTimetabledPassingTimeAggregateBoolExp>;
  turnaround_time?: InputMaybe<IntervalComparisonExp>;
  vehicle_journey_id?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "vehicle_journey.vehicle_journey" */
export enum TimetablesVehicleJourneyVehicleJourneyConstraint {
  /** unique or primary key constraint on columns "vehicle_journey_id" */
  VehicleJourneyPkey = 'vehicle_journey_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type TimetablesVehicleJourneyVehicleJourneyDeleteAtPathInput = {
  /** Name that user can give to the vehicle journey. */
  journey_name_i18n?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type TimetablesVehicleJourneyVehicleJourneyDeleteElemInput = {
  /** Name that user can give to the vehicle journey. */
  journey_name_i18n?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type TimetablesVehicleJourneyVehicleJourneyDeleteKeyInput = {
  /** Name that user can give to the vehicle journey. */
  journey_name_i18n?: InputMaybe<Scalars['String']>;
};

/** input type for inserting data into table "vehicle_journey.vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneyInsertInput = {
  block?: InputMaybe<TimetablesVehicleServiceBlockObjRelInsertInput>;
  /** The BLOCK to which this VEHICLE JOURNEY belongs */
  block_id?: InputMaybe<Scalars['uuid']>;
  /** The contract number for this vehicle journey. */
  contract_number?: InputMaybe<Scalars['String']>;
  /** Displayed name of the journey. */
  displayed_name?: InputMaybe<Scalars['String']>;
  /** Is the journey a backup journey. */
  is_backup_journey?: InputMaybe<Scalars['Boolean']>;
  /** Is the journey an extra journey. */
  is_extra_journey?: InputMaybe<Scalars['Boolean']>;
  /** It is required to use the same vehicle type as required in vehicle service. */
  is_vehicle_type_mandatory?: InputMaybe<Scalars['Boolean']>;
  /** Name that user can give to the vehicle journey. */
  journey_name_i18n?: InputMaybe<Scalars['jsonb']>;
  journey_pattern_ref?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefObjRelInsertInput>;
  /** The JOURNEY PATTERN on which the VEHICLE JOURNEY travels */
  journey_pattern_ref_id?: InputMaybe<Scalars['uuid']>;
  /** STANDARD | DRY_RUN | SERVICE_JOURNEY */
  journey_type?: InputMaybe<Scalars['String']>;
  /** LAYOVER TIMEs describe a certain time allowance that may be given at the end of each VEHICLE JOURNEY, before starting the next one, to compensate delays or for other purposes (e.g. rest time for the driver). This “layover time” can be regarded as a buffer time, which may or may not be actually consumed in real time operation. */
  layover_time?: InputMaybe<Scalars['interval']>;
  timetabled_passing_times?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeArrRelInsertInput>;
  /** Turnaround time is the time taken by a vehicle to proceed from the end of a ROUTE to the start of another. */
  turnaround_time?: InputMaybe<Scalars['interval']>;
  vehicle_journey_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type TimetablesVehicleJourneyVehicleJourneyMaxFields = {
  __typename?: 'timetables_vehicle_journey_vehicle_journey_max_fields';
  /** The BLOCK to which this VEHICLE JOURNEY belongs */
  block_id?: Maybe<Scalars['uuid']>;
  /** The contract number for this vehicle journey. */
  contract_number?: Maybe<Scalars['String']>;
  /** Displayed name of the journey. */
  displayed_name?: Maybe<Scalars['String']>;
  /** A computed field, executes function "vehicle_journey.vehicle_journey_end_time" */
  end_time?: Maybe<Scalars['String']>;
  /** The JOURNEY PATTERN on which the VEHICLE JOURNEY travels */
  journey_pattern_ref_id?: Maybe<Scalars['uuid']>;
  /** STANDARD | DRY_RUN | SERVICE_JOURNEY */
  journey_type?: Maybe<Scalars['String']>;
  /** A computed field, executes function "vehicle_journey.vehicle_journey_start_time" */
  start_time?: Maybe<Scalars['String']>;
  vehicle_journey_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "vehicle_journey.vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneyMaxOrderBy = {
  /** The BLOCK to which this VEHICLE JOURNEY belongs */
  block_id?: InputMaybe<OrderBy>;
  /** The contract number for this vehicle journey. */
  contract_number?: InputMaybe<OrderBy>;
  /** Displayed name of the journey. */
  displayed_name?: InputMaybe<OrderBy>;
  /** The JOURNEY PATTERN on which the VEHICLE JOURNEY travels */
  journey_pattern_ref_id?: InputMaybe<OrderBy>;
  /** STANDARD | DRY_RUN | SERVICE_JOURNEY */
  journey_type?: InputMaybe<OrderBy>;
  vehicle_journey_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type TimetablesVehicleJourneyVehicleJourneyMinFields = {
  __typename?: 'timetables_vehicle_journey_vehicle_journey_min_fields';
  /** The BLOCK to which this VEHICLE JOURNEY belongs */
  block_id?: Maybe<Scalars['uuid']>;
  /** The contract number for this vehicle journey. */
  contract_number?: Maybe<Scalars['String']>;
  /** Displayed name of the journey. */
  displayed_name?: Maybe<Scalars['String']>;
  /** A computed field, executes function "vehicle_journey.vehicle_journey_end_time" */
  end_time?: Maybe<Scalars['String']>;
  /** The JOURNEY PATTERN on which the VEHICLE JOURNEY travels */
  journey_pattern_ref_id?: Maybe<Scalars['uuid']>;
  /** STANDARD | DRY_RUN | SERVICE_JOURNEY */
  journey_type?: Maybe<Scalars['String']>;
  /** A computed field, executes function "vehicle_journey.vehicle_journey_start_time" */
  start_time?: Maybe<Scalars['String']>;
  vehicle_journey_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "vehicle_journey.vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneyMinOrderBy = {
  /** The BLOCK to which this VEHICLE JOURNEY belongs */
  block_id?: InputMaybe<OrderBy>;
  /** The contract number for this vehicle journey. */
  contract_number?: InputMaybe<OrderBy>;
  /** Displayed name of the journey. */
  displayed_name?: InputMaybe<OrderBy>;
  /** The JOURNEY PATTERN on which the VEHICLE JOURNEY travels */
  journey_pattern_ref_id?: InputMaybe<OrderBy>;
  /** STANDARD | DRY_RUN | SERVICE_JOURNEY */
  journey_type?: InputMaybe<OrderBy>;
  vehicle_journey_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "vehicle_journey.vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneyMutationResponse = {
  __typename?: 'timetables_vehicle_journey_vehicle_journey_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<TimetablesVehicleJourneyVehicleJourney>;
};

/** input type for inserting object relation for remote table "vehicle_journey.vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneyObjRelInsertInput = {
  data: TimetablesVehicleJourneyVehicleJourneyInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyOnConflict>;
};

/** on_conflict condition type for table "vehicle_journey.vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneyOnConflict = {
  constraint: TimetablesVehicleJourneyVehicleJourneyConstraint;
  update_columns?: Array<TimetablesVehicleJourneyVehicleJourneyUpdateColumn>;
  where?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
};

/** Ordering options when selecting data from "vehicle_journey.vehicle_journey". */
export type TimetablesVehicleJourneyVehicleJourneyOrderBy = {
  block?: InputMaybe<TimetablesVehicleServiceBlockOrderBy>;
  block_id?: InputMaybe<OrderBy>;
  contract_number?: InputMaybe<OrderBy>;
  displayed_name?: InputMaybe<OrderBy>;
  end_time?: InputMaybe<OrderBy>;
  is_backup_journey?: InputMaybe<OrderBy>;
  is_extra_journey?: InputMaybe<OrderBy>;
  is_vehicle_type_mandatory?: InputMaybe<OrderBy>;
  journey_name_i18n?: InputMaybe<OrderBy>;
  journey_pattern_ref?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefOrderBy>;
  journey_pattern_ref_id?: InputMaybe<OrderBy>;
  journey_type?: InputMaybe<OrderBy>;
  layover_time?: InputMaybe<OrderBy>;
  start_time?: InputMaybe<OrderBy>;
  timetabled_passing_times_aggregate?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeAggregateOrderBy>;
  turnaround_time?: InputMaybe<OrderBy>;
  vehicle_journey_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: vehicle_journey.vehicle_journey */
export type TimetablesVehicleJourneyVehicleJourneyPkColumnsInput = {
  vehicle_journey_id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type TimetablesVehicleJourneyVehicleJourneyPrependInput = {
  /** Name that user can give to the vehicle journey. */
  journey_name_i18n?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "vehicle_journey.vehicle_journey" */
export enum TimetablesVehicleJourneyVehicleJourneySelectColumn {
  /** column name */
  BlockId = 'block_id',
  /** column name */
  ContractNumber = 'contract_number',
  /** column name */
  DisplayedName = 'displayed_name',
  /** column name */
  IsBackupJourney = 'is_backup_journey',
  /** column name */
  IsExtraJourney = 'is_extra_journey',
  /** column name */
  IsVehicleTypeMandatory = 'is_vehicle_type_mandatory',
  /** column name */
  JourneyNameI18n = 'journey_name_i18n',
  /** column name */
  JourneyPatternRefId = 'journey_pattern_ref_id',
  /** column name */
  JourneyType = 'journey_type',
  /** column name */
  LayoverTime = 'layover_time',
  /** column name */
  TurnaroundTime = 'turnaround_time',
  /** column name */
  VehicleJourneyId = 'vehicle_journey_id',
}

/** select "vehicle_journey_vehicle_journey_aggregate_bool_exp_bool_and_arguments_columns" columns of table "vehicle_journey.vehicle_journey" */
export enum TimetablesVehicleJourneyVehicleJourneySelectColumnVehicleJourneyVehicleJourneyAggregateBoolExpBoolAndArgumentsColumns {
  /** column name */
  IsBackupJourney = 'is_backup_journey',
  /** column name */
  IsExtraJourney = 'is_extra_journey',
  /** column name */
  IsVehicleTypeMandatory = 'is_vehicle_type_mandatory',
}

/** select "vehicle_journey_vehicle_journey_aggregate_bool_exp_bool_or_arguments_columns" columns of table "vehicle_journey.vehicle_journey" */
export enum TimetablesVehicleJourneyVehicleJourneySelectColumnVehicleJourneyVehicleJourneyAggregateBoolExpBoolOrArgumentsColumns {
  /** column name */
  IsBackupJourney = 'is_backup_journey',
  /** column name */
  IsExtraJourney = 'is_extra_journey',
  /** column name */
  IsVehicleTypeMandatory = 'is_vehicle_type_mandatory',
}

/** input type for updating data in table "vehicle_journey.vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneySetInput = {
  /** The BLOCK to which this VEHICLE JOURNEY belongs */
  block_id?: InputMaybe<Scalars['uuid']>;
  /** The contract number for this vehicle journey. */
  contract_number?: InputMaybe<Scalars['String']>;
  /** Displayed name of the journey. */
  displayed_name?: InputMaybe<Scalars['String']>;
  /** Is the journey a backup journey. */
  is_backup_journey?: InputMaybe<Scalars['Boolean']>;
  /** Is the journey an extra journey. */
  is_extra_journey?: InputMaybe<Scalars['Boolean']>;
  /** It is required to use the same vehicle type as required in vehicle service. */
  is_vehicle_type_mandatory?: InputMaybe<Scalars['Boolean']>;
  /** Name that user can give to the vehicle journey. */
  journey_name_i18n?: InputMaybe<Scalars['jsonb']>;
  /** The JOURNEY PATTERN on which the VEHICLE JOURNEY travels */
  journey_pattern_ref_id?: InputMaybe<Scalars['uuid']>;
  /** STANDARD | DRY_RUN | SERVICE_JOURNEY */
  journey_type?: InputMaybe<Scalars['String']>;
  /** LAYOVER TIMEs describe a certain time allowance that may be given at the end of each VEHICLE JOURNEY, before starting the next one, to compensate delays or for other purposes (e.g. rest time for the driver). This “layover time” can be regarded as a buffer time, which may or may not be actually consumed in real time operation. */
  layover_time?: InputMaybe<Scalars['interval']>;
  /** Turnaround time is the time taken by a vehicle to proceed from the end of a ROUTE to the start of another. */
  turnaround_time?: InputMaybe<Scalars['interval']>;
  vehicle_journey_id?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "vehicle_journey_vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneyStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TimetablesVehicleJourneyVehicleJourneyStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesVehicleJourneyVehicleJourneyStreamCursorValueInput = {
  /** The BLOCK to which this VEHICLE JOURNEY belongs */
  block_id?: InputMaybe<Scalars['uuid']>;
  /** The contract number for this vehicle journey. */
  contract_number?: InputMaybe<Scalars['String']>;
  /** Displayed name of the journey. */
  displayed_name?: InputMaybe<Scalars['String']>;
  /** Is the journey a backup journey. */
  is_backup_journey?: InputMaybe<Scalars['Boolean']>;
  /** Is the journey an extra journey. */
  is_extra_journey?: InputMaybe<Scalars['Boolean']>;
  /** It is required to use the same vehicle type as required in vehicle service. */
  is_vehicle_type_mandatory?: InputMaybe<Scalars['Boolean']>;
  /** Name that user can give to the vehicle journey. */
  journey_name_i18n?: InputMaybe<Scalars['jsonb']>;
  /** The JOURNEY PATTERN on which the VEHICLE JOURNEY travels */
  journey_pattern_ref_id?: InputMaybe<Scalars['uuid']>;
  /** STANDARD | DRY_RUN | SERVICE_JOURNEY */
  journey_type?: InputMaybe<Scalars['String']>;
  /** LAYOVER TIMEs describe a certain time allowance that may be given at the end of each VEHICLE JOURNEY, before starting the next one, to compensate delays or for other purposes (e.g. rest time for the driver). This “layover time” can be regarded as a buffer time, which may or may not be actually consumed in real time operation. */
  layover_time?: InputMaybe<Scalars['interval']>;
  /** Turnaround time is the time taken by a vehicle to proceed from the end of a ROUTE to the start of another. */
  turnaround_time?: InputMaybe<Scalars['interval']>;
  vehicle_journey_id?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "vehicle_journey.vehicle_journey" */
export enum TimetablesVehicleJourneyVehicleJourneyUpdateColumn {
  /** column name */
  BlockId = 'block_id',
  /** column name */
  ContractNumber = 'contract_number',
  /** column name */
  DisplayedName = 'displayed_name',
  /** column name */
  IsBackupJourney = 'is_backup_journey',
  /** column name */
  IsExtraJourney = 'is_extra_journey',
  /** column name */
  IsVehicleTypeMandatory = 'is_vehicle_type_mandatory',
  /** column name */
  JourneyNameI18n = 'journey_name_i18n',
  /** column name */
  JourneyPatternRefId = 'journey_pattern_ref_id',
  /** column name */
  JourneyType = 'journey_type',
  /** column name */
  LayoverTime = 'layover_time',
  /** column name */
  TurnaroundTime = 'turnaround_time',
  /** column name */
  VehicleJourneyId = 'vehicle_journey_id',
}

export type TimetablesVehicleJourneyVehicleJourneyUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TimetablesVehicleJourneyVehicleJourneySetInput>;
  /** filter the rows which have to be updated */
  where: TimetablesVehicleJourneyVehicleJourneyBoolExp;
};

/** A coherent set of BLOCKS, COMPOUND BLOCKs, COURSEs of JOURNEY and VEHICLE SCHEDULEs to which the same set of VALIDITY CONDITIONs have been assigned. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:7:2:993  */
export type TimetablesVehicleScheduleVehicleScheduleFrame = {
  __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame';
  /** Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus. */
  booking_description_i18n?: Maybe<Scalars['jsonb']>;
  /** Booking label for the vehicle schedule frame. Comes from BookingRecord vsc_booking field from Hastus. */
  booking_label: Scalars['String'];
  created_at: Scalars['timestamptz'];
  /** Label for the vehicle schedule frame. Comes from BookingRecord vsc_name field from Hastus. */
  label: Scalars['String'];
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  name_i18n?: Maybe<Scalars['jsonb']>;
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  priority: Scalars['Int'];
  /** OPERATING DAY when the VEHICLE SCHEDULE FRAME validity ends (inclusive). Null if always will be valid. */
  validity_end: Scalars['date'];
  /**
   *
   * A denormalized column for actual daterange when vehicle schedule frame is valid,
   * that is, a closed date range [validity_start, validity_end].
   * Added to make working with PostgreSQL functions easier:
   * they typically expect ranges to be half closed.
   */
  validity_range: Scalars['daterange'];
  /** OPERATING DAY when the VEHICLE SCHEDULE FRAME validity starts (inclusive). Null if always has been valid. */
  validity_start: Scalars['date'];
  vehicle_schedule_frame_id: Scalars['uuid'];
  /** An array relationship */
  vehicle_services: Array<TimetablesVehicleServiceVehicleService>;
  /** An aggregate relationship */
  vehicle_services_aggregate: TimetablesVehicleServiceVehicleServiceAggregate;
};

/** A coherent set of BLOCKS, COMPOUND BLOCKs, COURSEs of JOURNEY and VEHICLE SCHEDULEs to which the same set of VALIDITY CONDITIONs have been assigned. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:7:2:993  */
export type TimetablesVehicleScheduleVehicleScheduleFrameBookingDescriptionI18nArgs =
  {
    path?: InputMaybe<Scalars['String']>;
  };

/** A coherent set of BLOCKS, COMPOUND BLOCKs, COURSEs of JOURNEY and VEHICLE SCHEDULEs to which the same set of VALIDITY CONDITIONs have been assigned. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:7:2:993  */
export type TimetablesVehicleScheduleVehicleScheduleFrameNameI18nArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** A coherent set of BLOCKS, COMPOUND BLOCKs, COURSEs of JOURNEY and VEHICLE SCHEDULEs to which the same set of VALIDITY CONDITIONs have been assigned. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:7:2:993  */
export type TimetablesVehicleScheduleVehicleScheduleFrameVehicleServicesArgs = {
  distinct_on?: InputMaybe<
    Array<TimetablesVehicleServiceVehicleServiceSelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<TimetablesVehicleServiceVehicleServiceOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
};

/** A coherent set of BLOCKS, COMPOUND BLOCKs, COURSEs of JOURNEY and VEHICLE SCHEDULEs to which the same set of VALIDITY CONDITIONs have been assigned. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:7:2:993  */
export type TimetablesVehicleScheduleVehicleScheduleFrameVehicleServicesAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesVehicleServiceVehicleServiceSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<Array<TimetablesVehicleServiceVehicleServiceOrderBy>>;
    where?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
  };

/** aggregated selection of "vehicle_schedule.vehicle_schedule_frame" */
export type TimetablesVehicleScheduleVehicleScheduleFrameAggregate = {
  __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_aggregate';
  aggregate?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameAggregateFields>;
  nodes: Array<TimetablesVehicleScheduleVehicleScheduleFrame>;
};

/** aggregate fields of "vehicle_schedule.vehicle_schedule_frame" */
export type TimetablesVehicleScheduleVehicleScheduleFrameAggregateFields = {
  __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_aggregate_fields';
  avg?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameMaxFields>;
  min?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameMinFields>;
  stddev?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameStddevFields>;
  stddev_pop?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameStddevPopFields>;
  stddev_samp?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameStddevSampFields>;
  sum?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameSumFields>;
  var_pop?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameVarPopFields>;
  var_samp?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameVarSampFields>;
  variance?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameVarianceFields>;
};

/** aggregate fields of "vehicle_schedule.vehicle_schedule_frame" */
export type TimetablesVehicleScheduleVehicleScheduleFrameAggregateFieldsCountArgs =
  {
    columns?: InputMaybe<
      Array<TimetablesVehicleScheduleVehicleScheduleFrameSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
  };

/** append existing jsonb value of filtered columns with new jsonb value */
export type TimetablesVehicleScheduleVehicleScheduleFrameAppendInput = {
  /** Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus. */
  booking_description_i18n?: InputMaybe<Scalars['jsonb']>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  name_i18n?: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type TimetablesVehicleScheduleVehicleScheduleFrameAvgFields = {
  __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_avg_fields';
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "vehicle_schedule.vehicle_schedule_frame". All fields are combined with a logical 'AND'. */
export type TimetablesVehicleScheduleVehicleScheduleFrameBoolExp = {
  _and?: InputMaybe<
    Array<TimetablesVehicleScheduleVehicleScheduleFrameBoolExp>
  >;
  _not?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameBoolExp>;
  _or?: InputMaybe<Array<TimetablesVehicleScheduleVehicleScheduleFrameBoolExp>>;
  booking_description_i18n?: InputMaybe<JsonbComparisonExp>;
  booking_label?: InputMaybe<StringComparisonExp>;
  created_at?: InputMaybe<TimestamptzComparisonExp>;
  label?: InputMaybe<StringComparisonExp>;
  name_i18n?: InputMaybe<JsonbComparisonExp>;
  priority?: InputMaybe<IntComparisonExp>;
  validity_end?: InputMaybe<DateComparisonExp>;
  validity_range?: InputMaybe<DaterangeComparisonExp>;
  validity_start?: InputMaybe<DateComparisonExp>;
  vehicle_schedule_frame_id?: InputMaybe<UuidComparisonExp>;
  vehicle_services?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
  vehicle_services_aggregate?: InputMaybe<VehicleServiceVehicleServiceAggregateBoolExp>;
};

/** unique or primary key constraints on table "vehicle_schedule.vehicle_schedule_frame" */
export enum TimetablesVehicleScheduleVehicleScheduleFrameConstraint {
  /** unique or primary key constraint on columns "vehicle_schedule_frame_id" */
  VehicleScheduleFramePkey = 'vehicle_schedule_frame_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type TimetablesVehicleScheduleVehicleScheduleFrameDeleteAtPathInput = {
  /** Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus. */
  booking_description_i18n?: InputMaybe<Array<Scalars['String']>>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  name_i18n?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type TimetablesVehicleScheduleVehicleScheduleFrameDeleteElemInput = {
  /** Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus. */
  booking_description_i18n?: InputMaybe<Scalars['Int']>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  name_i18n?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type TimetablesVehicleScheduleVehicleScheduleFrameDeleteKeyInput = {
  /** Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus. */
  booking_description_i18n?: InputMaybe<Scalars['String']>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  name_i18n?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "vehicle_schedule.vehicle_schedule_frame" */
export type TimetablesVehicleScheduleVehicleScheduleFrameIncInput = {
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "vehicle_schedule.vehicle_schedule_frame" */
export type TimetablesVehicleScheduleVehicleScheduleFrameInsertInput = {
  /** Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus. */
  booking_description_i18n?: InputMaybe<Scalars['jsonb']>;
  /** Booking label for the vehicle schedule frame. Comes from BookingRecord vsc_booking field from Hastus. */
  booking_label?: InputMaybe<Scalars['String']>;
  created_at?: InputMaybe<Scalars['timestamptz']>;
  /** Label for the vehicle schedule frame. Comes from BookingRecord vsc_name field from Hastus. */
  label?: InputMaybe<Scalars['String']>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  name_i18n?: InputMaybe<Scalars['jsonb']>;
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<Scalars['Int']>;
  /** OPERATING DAY when the VEHICLE SCHEDULE FRAME validity ends (inclusive). Null if always will be valid. */
  validity_end?: InputMaybe<Scalars['date']>;
  /** OPERATING DAY when the VEHICLE SCHEDULE FRAME validity starts (inclusive). Null if always has been valid. */
  validity_start?: InputMaybe<Scalars['date']>;
  vehicle_schedule_frame_id?: InputMaybe<Scalars['uuid']>;
  vehicle_services?: InputMaybe<TimetablesVehicleServiceVehicleServiceArrRelInsertInput>;
};

/** aggregate max on columns */
export type TimetablesVehicleScheduleVehicleScheduleFrameMaxFields = {
  __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_max_fields';
  /** Booking label for the vehicle schedule frame. Comes from BookingRecord vsc_booking field from Hastus. */
  booking_label?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  /** Label for the vehicle schedule frame. Comes from BookingRecord vsc_name field from Hastus. */
  label?: Maybe<Scalars['String']>;
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Int']>;
  /** OPERATING DAY when the VEHICLE SCHEDULE FRAME validity ends (inclusive). Null if always will be valid. */
  validity_end?: Maybe<Scalars['date']>;
  /** OPERATING DAY when the VEHICLE SCHEDULE FRAME validity starts (inclusive). Null if always has been valid. */
  validity_start?: Maybe<Scalars['date']>;
  vehicle_schedule_frame_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type TimetablesVehicleScheduleVehicleScheduleFrameMinFields = {
  __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_min_fields';
  /** Booking label for the vehicle schedule frame. Comes from BookingRecord vsc_booking field from Hastus. */
  booking_label?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  /** Label for the vehicle schedule frame. Comes from BookingRecord vsc_name field from Hastus. */
  label?: Maybe<Scalars['String']>;
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Int']>;
  /** OPERATING DAY when the VEHICLE SCHEDULE FRAME validity ends (inclusive). Null if always will be valid. */
  validity_end?: Maybe<Scalars['date']>;
  /** OPERATING DAY when the VEHICLE SCHEDULE FRAME validity starts (inclusive). Null if always has been valid. */
  validity_start?: Maybe<Scalars['date']>;
  vehicle_schedule_frame_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "vehicle_schedule.vehicle_schedule_frame" */
export type TimetablesVehicleScheduleVehicleScheduleFrameMutationResponse = {
  __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<TimetablesVehicleScheduleVehicleScheduleFrame>;
};

/** input type for inserting object relation for remote table "vehicle_schedule.vehicle_schedule_frame" */
export type TimetablesVehicleScheduleVehicleScheduleFrameObjRelInsertInput = {
  data: TimetablesVehicleScheduleVehicleScheduleFrameInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameOnConflict>;
};

/** on_conflict condition type for table "vehicle_schedule.vehicle_schedule_frame" */
export type TimetablesVehicleScheduleVehicleScheduleFrameOnConflict = {
  constraint: TimetablesVehicleScheduleVehicleScheduleFrameConstraint;
  update_columns?: Array<TimetablesVehicleScheduleVehicleScheduleFrameUpdateColumn>;
  where?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameBoolExp>;
};

/** Ordering options when selecting data from "vehicle_schedule.vehicle_schedule_frame". */
export type TimetablesVehicleScheduleVehicleScheduleFrameOrderBy = {
  booking_description_i18n?: InputMaybe<OrderBy>;
  booking_label?: InputMaybe<OrderBy>;
  created_at?: InputMaybe<OrderBy>;
  label?: InputMaybe<OrderBy>;
  name_i18n?: InputMaybe<OrderBy>;
  priority?: InputMaybe<OrderBy>;
  validity_end?: InputMaybe<OrderBy>;
  validity_range?: InputMaybe<OrderBy>;
  validity_start?: InputMaybe<OrderBy>;
  vehicle_schedule_frame_id?: InputMaybe<OrderBy>;
  vehicle_services_aggregate?: InputMaybe<TimetablesVehicleServiceVehicleServiceAggregateOrderBy>;
};

/** primary key columns input for table: vehicle_schedule.vehicle_schedule_frame */
export type TimetablesVehicleScheduleVehicleScheduleFramePkColumnsInput = {
  vehicle_schedule_frame_id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type TimetablesVehicleScheduleVehicleScheduleFramePrependInput = {
  /** Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus. */
  booking_description_i18n?: InputMaybe<Scalars['jsonb']>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  name_i18n?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "vehicle_schedule.vehicle_schedule_frame" */
export enum TimetablesVehicleScheduleVehicleScheduleFrameSelectColumn {
  /** column name */
  BookingDescriptionI18n = 'booking_description_i18n',
  /** column name */
  BookingLabel = 'booking_label',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Label = 'label',
  /** column name */
  NameI18n = 'name_i18n',
  /** column name */
  Priority = 'priority',
  /** column name */
  ValidityEnd = 'validity_end',
  /** column name */
  ValidityRange = 'validity_range',
  /** column name */
  ValidityStart = 'validity_start',
  /** column name */
  VehicleScheduleFrameId = 'vehicle_schedule_frame_id',
}

/** input type for updating data in table "vehicle_schedule.vehicle_schedule_frame" */
export type TimetablesVehicleScheduleVehicleScheduleFrameSetInput = {
  /** Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus. */
  booking_description_i18n?: InputMaybe<Scalars['jsonb']>;
  /** Booking label for the vehicle schedule frame. Comes from BookingRecord vsc_booking field from Hastus. */
  booking_label?: InputMaybe<Scalars['String']>;
  created_at?: InputMaybe<Scalars['timestamptz']>;
  /** Label for the vehicle schedule frame. Comes from BookingRecord vsc_name field from Hastus. */
  label?: InputMaybe<Scalars['String']>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  name_i18n?: InputMaybe<Scalars['jsonb']>;
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  priority?: InputMaybe<Scalars['Int']>;
  /** OPERATING DAY when the VEHICLE SCHEDULE FRAME validity ends (inclusive). Null if always will be valid. */
  validity_end?: InputMaybe<Scalars['date']>;
  /** OPERATING DAY when the VEHICLE SCHEDULE FRAME validity starts (inclusive). Null if always has been valid. */
  validity_start?: InputMaybe<Scalars['date']>;
  vehicle_schedule_frame_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type TimetablesVehicleScheduleVehicleScheduleFrameStddevFields = {
  __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_stddev_fields';
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type TimetablesVehicleScheduleVehicleScheduleFrameStddevPopFields = {
  __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_stddev_pop_fields';
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type TimetablesVehicleScheduleVehicleScheduleFrameStddevSampFields = {
  __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_stddev_samp_fields';
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "vehicle_schedule_vehicle_schedule_frame" */
export type TimetablesVehicleScheduleVehicleScheduleFrameStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TimetablesVehicleScheduleVehicleScheduleFrameStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesVehicleScheduleVehicleScheduleFrameStreamCursorValueInput =
  {
    /** Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus. */
    booking_description_i18n?: InputMaybe<Scalars['jsonb']>;
    /** Booking label for the vehicle schedule frame. Comes from BookingRecord vsc_booking field from Hastus. */
    booking_label?: InputMaybe<Scalars['String']>;
    created_at?: InputMaybe<Scalars['timestamptz']>;
    /** Label for the vehicle schedule frame. Comes from BookingRecord vsc_name field from Hastus. */
    label?: InputMaybe<Scalars['String']>;
    /** Human-readable name for the VEHICLE SCHEDULE FRAME */
    name_i18n?: InputMaybe<Scalars['jsonb']>;
    /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
    priority?: InputMaybe<Scalars['Int']>;
    /** OPERATING DAY when the VEHICLE SCHEDULE FRAME validity ends (inclusive). Null if always will be valid. */
    validity_end?: InputMaybe<Scalars['date']>;
    /**
     *
     * A denormalized column for actual daterange when vehicle schedule frame is valid,
     * that is, a closed date range [validity_start, validity_end].
     * Added to make working with PostgreSQL functions easier:
     * they typically expect ranges to be half closed.
     */
    validity_range?: InputMaybe<Scalars['daterange']>;
    /** OPERATING DAY when the VEHICLE SCHEDULE FRAME validity starts (inclusive). Null if always has been valid. */
    validity_start?: InputMaybe<Scalars['date']>;
    vehicle_schedule_frame_id?: InputMaybe<Scalars['uuid']>;
  };

/** aggregate sum on columns */
export type TimetablesVehicleScheduleVehicleScheduleFrameSumFields = {
  __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_sum_fields';
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Int']>;
};

/** update columns of table "vehicle_schedule.vehicle_schedule_frame" */
export enum TimetablesVehicleScheduleVehicleScheduleFrameUpdateColumn {
  /** column name */
  BookingDescriptionI18n = 'booking_description_i18n',
  /** column name */
  BookingLabel = 'booking_label',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Label = 'label',
  /** column name */
  NameI18n = 'name_i18n',
  /** column name */
  Priority = 'priority',
  /** column name */
  ValidityEnd = 'validity_end',
  /** column name */
  ValidityStart = 'validity_start',
  /** column name */
  VehicleScheduleFrameId = 'vehicle_schedule_frame_id',
}

export type TimetablesVehicleScheduleVehicleScheduleFrameUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFramePrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameSetInput>;
  /** filter the rows which have to be updated */
  where: TimetablesVehicleScheduleVehicleScheduleFrameBoolExp;
};

/** aggregate var_pop on columns */
export type TimetablesVehicleScheduleVehicleScheduleFrameVarPopFields = {
  __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_var_pop_fields';
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type TimetablesVehicleScheduleVehicleScheduleFrameVarSampFields = {
  __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_var_samp_fields';
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type TimetablesVehicleScheduleVehicleScheduleFrameVarianceFields = {
  __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_variance_fields';
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  priority?: Maybe<Scalars['Float']>;
};

/** The work of a vehicle from the time it leaves a PARKING POINT after parking until its next return to park at a PARKING POINT. Any subsequent departure from a PARKING POINT after parking marks the start of a new BLOCK. The period of a BLOCK has to be covered by DUTies. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:5:958  */
export type TimetablesVehicleServiceBlock = {
  __typename?: 'timetables_vehicle_service_block';
  block_id: Scalars['uuid'];
  /** Finishing time after end of vehicle service block. */
  finishing_time?: Maybe<Scalars['interval']>;
  /** Preparation time before start of vehicle service block. */
  preparing_time?: Maybe<Scalars['interval']>;
  /** An array relationship */
  vehicle_journeys: Array<TimetablesVehicleJourneyVehicleJourney>;
  /** An aggregate relationship */
  vehicle_journeys_aggregate: TimetablesVehicleJourneyVehicleJourneyAggregate;
  /** An object relationship */
  vehicle_service: TimetablesVehicleServiceVehicleService;
  /** The VEHICLE SERVICE to which this BLOCK belongs. */
  vehicle_service_id: Scalars['uuid'];
  /** An object relationship */
  vehicle_type?: Maybe<TimetablesVehicleTypeVehicleType>;
  /** Reference to vehicle_type.vehicle_type. */
  vehicle_type_id?: Maybe<Scalars['uuid']>;
};

/** The work of a vehicle from the time it leaves a PARKING POINT after parking until its next return to park at a PARKING POINT. Any subsequent departure from a PARKING POINT after parking marks the start of a new BLOCK. The period of a BLOCK has to be covered by DUTies. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:5:958  */
export type TimetablesVehicleServiceBlockVehicleJourneysArgs = {
  distinct_on?: InputMaybe<
    Array<TimetablesVehicleJourneyVehicleJourneySelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<TimetablesVehicleJourneyVehicleJourneyOrderBy>>;
  where?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
};

/** The work of a vehicle from the time it leaves a PARKING POINT after parking until its next return to park at a PARKING POINT. Any subsequent departure from a PARKING POINT after parking marks the start of a new BLOCK. The period of a BLOCK has to be covered by DUTies. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:5:958  */
export type TimetablesVehicleServiceBlockVehicleJourneysAggregateArgs = {
  distinct_on?: InputMaybe<
    Array<TimetablesVehicleJourneyVehicleJourneySelectColumn>
  >;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<TimetablesVehicleJourneyVehicleJourneyOrderBy>>;
  where?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
};

/** aggregated selection of "vehicle_service.block" */
export type TimetablesVehicleServiceBlockAggregate = {
  __typename?: 'timetables_vehicle_service_block_aggregate';
  aggregate?: Maybe<TimetablesVehicleServiceBlockAggregateFields>;
  nodes: Array<TimetablesVehicleServiceBlock>;
};

/** aggregate fields of "vehicle_service.block" */
export type TimetablesVehicleServiceBlockAggregateFields = {
  __typename?: 'timetables_vehicle_service_block_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<TimetablesVehicleServiceBlockMaxFields>;
  min?: Maybe<TimetablesVehicleServiceBlockMinFields>;
};

/** aggregate fields of "vehicle_service.block" */
export type TimetablesVehicleServiceBlockAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TimetablesVehicleServiceBlockSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "vehicle_service.block" */
export type TimetablesVehicleServiceBlockAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<TimetablesVehicleServiceBlockMaxOrderBy>;
  min?: InputMaybe<TimetablesVehicleServiceBlockMinOrderBy>;
};

/** input type for inserting array relation for remote table "vehicle_service.block" */
export type TimetablesVehicleServiceBlockArrRelInsertInput = {
  data: Array<TimetablesVehicleServiceBlockInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<TimetablesVehicleServiceBlockOnConflict>;
};

/** Boolean expression to filter rows from the table "vehicle_service.block". All fields are combined with a logical 'AND'. */
export type TimetablesVehicleServiceBlockBoolExp = {
  _and?: InputMaybe<Array<TimetablesVehicleServiceBlockBoolExp>>;
  _not?: InputMaybe<TimetablesVehicleServiceBlockBoolExp>;
  _or?: InputMaybe<Array<TimetablesVehicleServiceBlockBoolExp>>;
  block_id?: InputMaybe<UuidComparisonExp>;
  finishing_time?: InputMaybe<IntervalComparisonExp>;
  preparing_time?: InputMaybe<IntervalComparisonExp>;
  vehicle_journeys?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
  vehicle_journeys_aggregate?: InputMaybe<VehicleJourneyVehicleJourneyAggregateBoolExp>;
  vehicle_service?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
  vehicle_service_id?: InputMaybe<UuidComparisonExp>;
  vehicle_type?: InputMaybe<TimetablesVehicleTypeVehicleTypeBoolExp>;
  vehicle_type_id?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "vehicle_service.block" */
export enum TimetablesVehicleServiceBlockConstraint {
  /** unique or primary key constraint on columns "block_id" */
  BlockPkey = 'block_pkey',
}

/** input type for inserting data into table "vehicle_service.block" */
export type TimetablesVehicleServiceBlockInsertInput = {
  block_id?: InputMaybe<Scalars['uuid']>;
  /** Finishing time after end of vehicle service block. */
  finishing_time?: InputMaybe<Scalars['interval']>;
  /** Preparation time before start of vehicle service block. */
  preparing_time?: InputMaybe<Scalars['interval']>;
  vehicle_journeys?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyArrRelInsertInput>;
  vehicle_service?: InputMaybe<TimetablesVehicleServiceVehicleServiceObjRelInsertInput>;
  /** The VEHICLE SERVICE to which this BLOCK belongs. */
  vehicle_service_id?: InputMaybe<Scalars['uuid']>;
  vehicle_type?: InputMaybe<TimetablesVehicleTypeVehicleTypeObjRelInsertInput>;
  /** Reference to vehicle_type.vehicle_type. */
  vehicle_type_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type TimetablesVehicleServiceBlockMaxFields = {
  __typename?: 'timetables_vehicle_service_block_max_fields';
  block_id?: Maybe<Scalars['uuid']>;
  /** The VEHICLE SERVICE to which this BLOCK belongs. */
  vehicle_service_id?: Maybe<Scalars['uuid']>;
  /** Reference to vehicle_type.vehicle_type. */
  vehicle_type_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "vehicle_service.block" */
export type TimetablesVehicleServiceBlockMaxOrderBy = {
  block_id?: InputMaybe<OrderBy>;
  /** The VEHICLE SERVICE to which this BLOCK belongs. */
  vehicle_service_id?: InputMaybe<OrderBy>;
  /** Reference to vehicle_type.vehicle_type. */
  vehicle_type_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type TimetablesVehicleServiceBlockMinFields = {
  __typename?: 'timetables_vehicle_service_block_min_fields';
  block_id?: Maybe<Scalars['uuid']>;
  /** The VEHICLE SERVICE to which this BLOCK belongs. */
  vehicle_service_id?: Maybe<Scalars['uuid']>;
  /** Reference to vehicle_type.vehicle_type. */
  vehicle_type_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "vehicle_service.block" */
export type TimetablesVehicleServiceBlockMinOrderBy = {
  block_id?: InputMaybe<OrderBy>;
  /** The VEHICLE SERVICE to which this BLOCK belongs. */
  vehicle_service_id?: InputMaybe<OrderBy>;
  /** Reference to vehicle_type.vehicle_type. */
  vehicle_type_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "vehicle_service.block" */
export type TimetablesVehicleServiceBlockMutationResponse = {
  __typename?: 'timetables_vehicle_service_block_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<TimetablesVehicleServiceBlock>;
};

/** input type for inserting object relation for remote table "vehicle_service.block" */
export type TimetablesVehicleServiceBlockObjRelInsertInput = {
  data: TimetablesVehicleServiceBlockInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<TimetablesVehicleServiceBlockOnConflict>;
};

/** on_conflict condition type for table "vehicle_service.block" */
export type TimetablesVehicleServiceBlockOnConflict = {
  constraint: TimetablesVehicleServiceBlockConstraint;
  update_columns?: Array<TimetablesVehicleServiceBlockUpdateColumn>;
  where?: InputMaybe<TimetablesVehicleServiceBlockBoolExp>;
};

/** Ordering options when selecting data from "vehicle_service.block". */
export type TimetablesVehicleServiceBlockOrderBy = {
  block_id?: InputMaybe<OrderBy>;
  finishing_time?: InputMaybe<OrderBy>;
  preparing_time?: InputMaybe<OrderBy>;
  vehicle_journeys_aggregate?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyAggregateOrderBy>;
  vehicle_service?: InputMaybe<TimetablesVehicleServiceVehicleServiceOrderBy>;
  vehicle_service_id?: InputMaybe<OrderBy>;
  vehicle_type?: InputMaybe<TimetablesVehicleTypeVehicleTypeOrderBy>;
  vehicle_type_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: vehicle_service.block */
export type TimetablesVehicleServiceBlockPkColumnsInput = {
  block_id: Scalars['uuid'];
};

/** select columns of table "vehicle_service.block" */
export enum TimetablesVehicleServiceBlockSelectColumn {
  /** column name */
  BlockId = 'block_id',
  /** column name */
  FinishingTime = 'finishing_time',
  /** column name */
  PreparingTime = 'preparing_time',
  /** column name */
  VehicleServiceId = 'vehicle_service_id',
  /** column name */
  VehicleTypeId = 'vehicle_type_id',
}

/** input type for updating data in table "vehicle_service.block" */
export type TimetablesVehicleServiceBlockSetInput = {
  block_id?: InputMaybe<Scalars['uuid']>;
  /** Finishing time after end of vehicle service block. */
  finishing_time?: InputMaybe<Scalars['interval']>;
  /** Preparation time before start of vehicle service block. */
  preparing_time?: InputMaybe<Scalars['interval']>;
  /** The VEHICLE SERVICE to which this BLOCK belongs. */
  vehicle_service_id?: InputMaybe<Scalars['uuid']>;
  /** Reference to vehicle_type.vehicle_type. */
  vehicle_type_id?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "vehicle_service_block" */
export type TimetablesVehicleServiceBlockStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TimetablesVehicleServiceBlockStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesVehicleServiceBlockStreamCursorValueInput = {
  block_id?: InputMaybe<Scalars['uuid']>;
  /** Finishing time after end of vehicle service block. */
  finishing_time?: InputMaybe<Scalars['interval']>;
  /** Preparation time before start of vehicle service block. */
  preparing_time?: InputMaybe<Scalars['interval']>;
  /** The VEHICLE SERVICE to which this BLOCK belongs. */
  vehicle_service_id?: InputMaybe<Scalars['uuid']>;
  /** Reference to vehicle_type.vehicle_type. */
  vehicle_type_id?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "vehicle_service.block" */
export enum TimetablesVehicleServiceBlockUpdateColumn {
  /** column name */
  BlockId = 'block_id',
  /** column name */
  FinishingTime = 'finishing_time',
  /** column name */
  PreparingTime = 'preparing_time',
  /** column name */
  VehicleServiceId = 'vehicle_service_id',
  /** column name */
  VehicleTypeId = 'vehicle_type_id',
}

export type TimetablesVehicleServiceBlockUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TimetablesVehicleServiceBlockSetInput>;
  /** filter the rows which have to be updated */
  where: TimetablesVehicleServiceBlockBoolExp;
};

export type TimetablesVehicleServiceGetTimetableVersionsByJourneyPatternIdsArgs =
  {
    end_date?: InputMaybe<Scalars['date']>;
    journey_pattern_ids?: InputMaybe<Scalars['_uuid']>;
    observation_date?: InputMaybe<Scalars['date']>;
    start_date?: InputMaybe<Scalars['date']>;
  };

export type TimetablesVehicleServiceGetTimetablesAndSubstituteOperatingDaysArgs =
  {
    end_date?: InputMaybe<Scalars['date']>;
    journey_pattern_ids?: InputMaybe<Scalars['_uuid']>;
    start_date?: InputMaybe<Scalars['date']>;
  };

/**
 * A denormalized table containing relationships between vehicle_services and journey_patterns (via journey_pattern_ref.journey_pattern_id).
 *  Without this table this relationship could be found via vehicle_service -> block -> vehicle_journey -> journey_pattern_ref.
 *  Kept up to date with triggers, should not be updated manually.
 */
export type TimetablesVehicleServiceJourneyPatternsInVehicleService = {
  __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service';
  /**
   * The journey_pattern_id from journey_pattern.journey_pattern_ref.
   *  No foreign key reference is set because the target column is not unique.
   */
  journey_pattern_id: Scalars['uuid'];
  journey_pattern_instance?: Maybe<JourneyPatternJourneyPattern>;
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  reference_count: Scalars['Int'];
  /** An object relationship */
  vehicle_service: TimetablesVehicleServiceVehicleService;
  vehicle_service_id: Scalars['uuid'];
};

/** aggregated selection of "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceAggregate = {
  __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_aggregate';
  aggregate?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceAggregateFields>;
  nodes: Array<TimetablesVehicleServiceJourneyPatternsInVehicleService>;
};

/** aggregate fields of "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceAggregateFields =
  {
    __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_aggregate_fields';
    avg?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceAvgFields>;
    count: Scalars['Int'];
    max?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceMaxFields>;
    min?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceMinFields>;
    stddev?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceStddevFields>;
    stddev_pop?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceStddevPopFields>;
    stddev_samp?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceStddevSampFields>;
    sum?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSumFields>;
    var_pop?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceVarPopFields>;
    var_samp?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceVarSampFields>;
    variance?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceVarianceFields>;
  };

/** aggregate fields of "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceAggregateFieldsCountArgs =
  {
    columns?: InputMaybe<
      Array<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
  };

/** order by aggregate values of table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceAggregateOrderBy =
  {
    avg?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceAvgOrderBy>;
    count?: InputMaybe<OrderBy>;
    max?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceMaxOrderBy>;
    min?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceMinOrderBy>;
    stddev?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceStddevOrderBy>;
    stddev_pop?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceStddevPopOrderBy>;
    stddev_samp?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceStddevSampOrderBy>;
    sum?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSumOrderBy>;
    var_pop?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceVarPopOrderBy>;
    var_samp?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceVarSampOrderBy>;
    variance?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceVarianceOrderBy>;
  };

/** input type for inserting array relation for remote table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceArrRelInsertInput =
  {
    data: Array<TimetablesVehicleServiceJourneyPatternsInVehicleServiceInsertInput>;
    /** upsert condition */
    on_conflict?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceOnConflict>;
  };

/** aggregate avg on columns */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceAvgFields = {
  __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_avg_fields';
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  reference_count?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceAvgOrderBy =
  {
    /**
     * The amount of unique references between the journey_pattern and vehicle_service.
     *   When this reaches 0 the row will be deleted.
     */
    reference_count?: InputMaybe<OrderBy>;
  };

/** Boolean expression to filter rows from the table "vehicle_service.journey_patterns_in_vehicle_service". All fields are combined with a logical 'AND'. */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp = {
  _and?: InputMaybe<
    Array<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>
  >;
  _not?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
  _or?: InputMaybe<
    Array<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>
  >;
  journey_pattern_id?: InputMaybe<UuidComparisonExp>;
  reference_count?: InputMaybe<IntComparisonExp>;
  vehicle_service?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
  vehicle_service_id?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "vehicle_service.journey_patterns_in_vehicle_service" */
export enum TimetablesVehicleServiceJourneyPatternsInVehicleServiceConstraint {
  /** unique or primary key constraint on columns "journey_pattern_id", "vehicle_service_id" */
  JourneyPatternsInVehicleServicePkey = 'journey_patterns_in_vehicle_service_pkey',
}

/** input type for incrementing numeric columns in table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceIncInput = {
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  reference_count?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceInsertInput =
  {
    /**
     * The journey_pattern_id from journey_pattern.journey_pattern_ref.
     *  No foreign key reference is set because the target column is not unique.
     */
    journey_pattern_id?: InputMaybe<Scalars['uuid']>;
    /**
     * The amount of unique references between the journey_pattern and vehicle_service.
     *   When this reaches 0 the row will be deleted.
     */
    reference_count?: InputMaybe<Scalars['Int']>;
    vehicle_service?: InputMaybe<TimetablesVehicleServiceVehicleServiceObjRelInsertInput>;
    vehicle_service_id?: InputMaybe<Scalars['uuid']>;
  };

/** aggregate max on columns */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceMaxFields = {
  __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_max_fields';
  /**
   * The journey_pattern_id from journey_pattern.journey_pattern_ref.
   *  No foreign key reference is set because the target column is not unique.
   */
  journey_pattern_id?: Maybe<Scalars['uuid']>;
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  reference_count?: Maybe<Scalars['Int']>;
  vehicle_service_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceMaxOrderBy =
  {
    /**
     * The journey_pattern_id from journey_pattern.journey_pattern_ref.
     *  No foreign key reference is set because the target column is not unique.
     */
    journey_pattern_id?: InputMaybe<OrderBy>;
    /**
     * The amount of unique references between the journey_pattern and vehicle_service.
     *   When this reaches 0 the row will be deleted.
     */
    reference_count?: InputMaybe<OrderBy>;
    vehicle_service_id?: InputMaybe<OrderBy>;
  };

/** aggregate min on columns */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceMinFields = {
  __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_min_fields';
  /**
   * The journey_pattern_id from journey_pattern.journey_pattern_ref.
   *  No foreign key reference is set because the target column is not unique.
   */
  journey_pattern_id?: Maybe<Scalars['uuid']>;
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  reference_count?: Maybe<Scalars['Int']>;
  vehicle_service_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceMinOrderBy =
  {
    /**
     * The journey_pattern_id from journey_pattern.journey_pattern_ref.
     *  No foreign key reference is set because the target column is not unique.
     */
    journey_pattern_id?: InputMaybe<OrderBy>;
    /**
     * The amount of unique references between the journey_pattern and vehicle_service.
     *   When this reaches 0 the row will be deleted.
     */
    reference_count?: InputMaybe<OrderBy>;
    vehicle_service_id?: InputMaybe<OrderBy>;
  };

/** response of any mutation on the table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceMutationResponse =
  {
    __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_mutation_response';
    /** number of rows affected by the mutation */
    affected_rows: Scalars['Int'];
    /** data from the rows affected by the mutation */
    returning: Array<TimetablesVehicleServiceJourneyPatternsInVehicleService>;
  };

/** on_conflict condition type for table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceOnConflict =
  {
    constraint: TimetablesVehicleServiceJourneyPatternsInVehicleServiceConstraint;
    update_columns?: Array<TimetablesVehicleServiceJourneyPatternsInVehicleServiceUpdateColumn>;
    where?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
  };

/** Ordering options when selecting data from "vehicle_service.journey_patterns_in_vehicle_service". */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceOrderBy = {
  journey_pattern_id?: InputMaybe<OrderBy>;
  reference_count?: InputMaybe<OrderBy>;
  vehicle_service?: InputMaybe<TimetablesVehicleServiceVehicleServiceOrderBy>;
  vehicle_service_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: vehicle_service.journey_patterns_in_vehicle_service */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServicePkColumnsInput =
  {
    /**
     * The journey_pattern_id from journey_pattern.journey_pattern_ref.
     *  No foreign key reference is set because the target column is not unique.
     */
    journey_pattern_id: Scalars['uuid'];
    vehicle_service_id: Scalars['uuid'];
  };

/** select columns of table "vehicle_service.journey_patterns_in_vehicle_service" */
export enum TimetablesVehicleServiceJourneyPatternsInVehicleServiceSelectColumn {
  /** column name */
  JourneyPatternId = 'journey_pattern_id',
  /** column name */
  ReferenceCount = 'reference_count',
  /** column name */
  VehicleServiceId = 'vehicle_service_id',
}

/** input type for updating data in table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceSetInput = {
  /**
   * The journey_pattern_id from journey_pattern.journey_pattern_ref.
   *  No foreign key reference is set because the target column is not unique.
   */
  journey_pattern_id?: InputMaybe<Scalars['uuid']>;
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  reference_count?: InputMaybe<Scalars['Int']>;
  vehicle_service_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceStddevFields =
  {
    __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_stddev_fields';
    /**
     * The amount of unique references between the journey_pattern and vehicle_service.
     *   When this reaches 0 the row will be deleted.
     */
    reference_count?: Maybe<Scalars['Float']>;
  };

/** order by stddev() on columns of table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceStddevOrderBy =
  {
    /**
     * The amount of unique references between the journey_pattern and vehicle_service.
     *   When this reaches 0 the row will be deleted.
     */
    reference_count?: InputMaybe<OrderBy>;
  };

/** aggregate stddev_pop on columns */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceStddevPopFields =
  {
    __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_stddev_pop_fields';
    /**
     * The amount of unique references between the journey_pattern and vehicle_service.
     *   When this reaches 0 the row will be deleted.
     */
    reference_count?: Maybe<Scalars['Float']>;
  };

/** order by stddev_pop() on columns of table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceStddevPopOrderBy =
  {
    /**
     * The amount of unique references between the journey_pattern and vehicle_service.
     *   When this reaches 0 the row will be deleted.
     */
    reference_count?: InputMaybe<OrderBy>;
  };

/** aggregate stddev_samp on columns */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceStddevSampFields =
  {
    __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_stddev_samp_fields';
    /**
     * The amount of unique references between the journey_pattern and vehicle_service.
     *   When this reaches 0 the row will be deleted.
     */
    reference_count?: Maybe<Scalars['Float']>;
  };

/** order by stddev_samp() on columns of table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceStddevSampOrderBy =
  {
    /**
     * The amount of unique references between the journey_pattern and vehicle_service.
     *   When this reaches 0 the row will be deleted.
     */
    reference_count?: InputMaybe<OrderBy>;
  };

/** Streaming cursor of the table "vehicle_service_journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceStreamCursorInput =
  {
    /** Stream column input with initial value */
    initial_value: TimetablesVehicleServiceJourneyPatternsInVehicleServiceStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<TimetablesCursorOrdering>;
  };

/** Initial value of the column from where the streaming should start */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceStreamCursorValueInput =
  {
    /**
     * The journey_pattern_id from journey_pattern.journey_pattern_ref.
     *  No foreign key reference is set because the target column is not unique.
     */
    journey_pattern_id?: InputMaybe<Scalars['uuid']>;
    /**
     * The amount of unique references between the journey_pattern and vehicle_service.
     *   When this reaches 0 the row will be deleted.
     */
    reference_count?: InputMaybe<Scalars['Int']>;
    vehicle_service_id?: InputMaybe<Scalars['uuid']>;
  };

/** aggregate sum on columns */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceSumFields = {
  __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_sum_fields';
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  reference_count?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceSumOrderBy =
  {
    /**
     * The amount of unique references between the journey_pattern and vehicle_service.
     *   When this reaches 0 the row will be deleted.
     */
    reference_count?: InputMaybe<OrderBy>;
  };

/** update columns of table "vehicle_service.journey_patterns_in_vehicle_service" */
export enum TimetablesVehicleServiceJourneyPatternsInVehicleServiceUpdateColumn {
  /** column name */
  JourneyPatternId = 'journey_pattern_id',
  /** column name */
  ReferenceCount = 'reference_count',
  /** column name */
  VehicleServiceId = 'vehicle_service_id',
}

export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSetInput>;
  /** filter the rows which have to be updated */
  where: TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp;
};

/** aggregate var_pop on columns */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceVarPopFields =
  {
    __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_var_pop_fields';
    /**
     * The amount of unique references between the journey_pattern and vehicle_service.
     *   When this reaches 0 the row will be deleted.
     */
    reference_count?: Maybe<Scalars['Float']>;
  };

/** order by var_pop() on columns of table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceVarPopOrderBy =
  {
    /**
     * The amount of unique references between the journey_pattern and vehicle_service.
     *   When this reaches 0 the row will be deleted.
     */
    reference_count?: InputMaybe<OrderBy>;
  };

/** aggregate var_samp on columns */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceVarSampFields =
  {
    __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_var_samp_fields';
    /**
     * The amount of unique references between the journey_pattern and vehicle_service.
     *   When this reaches 0 the row will be deleted.
     */
    reference_count?: Maybe<Scalars['Float']>;
  };

/** order by var_samp() on columns of table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceVarSampOrderBy =
  {
    /**
     * The amount of unique references between the journey_pattern and vehicle_service.
     *   When this reaches 0 the row will be deleted.
     */
    reference_count?: InputMaybe<OrderBy>;
  };

/** aggregate variance on columns */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceVarianceFields =
  {
    __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_variance_fields';
    /**
     * The amount of unique references between the journey_pattern and vehicle_service.
     *   When this reaches 0 the row will be deleted.
     */
    reference_count?: Maybe<Scalars['Float']>;
  };

/** order by variance() on columns of table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceVarianceOrderBy =
  {
    /**
     * The amount of unique references between the journey_pattern and vehicle_service.
     *   When this reaches 0 the row will be deleted.
     */
    reference_count?: InputMaybe<OrderBy>;
  };

/** A work plan for a single vehicle for a whole day, planned for a specific DAY TYPE. A VEHICLE SERVICE includes one or several BLOCKs. If there is no service on a given day, it does not include any BLOCKs. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:5:965  */
export type TimetablesVehicleServiceVehicleService = {
  __typename?: 'timetables_vehicle_service_vehicle_service';
  /** An array relationship */
  blocks: Array<TimetablesVehicleServiceBlock>;
  /** An aggregate relationship */
  blocks_aggregate: TimetablesVehicleServiceBlockAggregate;
  /** An object relationship */
  day_type: TimetablesServiceCalendarDayType;
  /** The DAY TYPE for the VEHICLE SERVICE. */
  day_type_id: Scalars['uuid'];
  /** An array relationship */
  journey_patterns_in_vehicle_service: Array<TimetablesVehicleServiceJourneyPatternsInVehicleService>;
  /** An aggregate relationship */
  journey_patterns_in_vehicle_service_aggregate: TimetablesVehicleServiceJourneyPatternsInVehicleServiceAggregate;
  /** Name for vehicle service. */
  name_i18n?: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  vehicle_schedule_frame: TimetablesVehicleScheduleVehicleScheduleFrame;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  vehicle_schedule_frame_id: Scalars['uuid'];
  vehicle_service_id: Scalars['uuid'];
};

/** A work plan for a single vehicle for a whole day, planned for a specific DAY TYPE. A VEHICLE SERVICE includes one or several BLOCKs. If there is no service on a given day, it does not include any BLOCKs. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:5:965  */
export type TimetablesVehicleServiceVehicleServiceBlocksArgs = {
  distinct_on?: InputMaybe<Array<TimetablesVehicleServiceBlockSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<TimetablesVehicleServiceBlockOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceBlockBoolExp>;
};

/** A work plan for a single vehicle for a whole day, planned for a specific DAY TYPE. A VEHICLE SERVICE includes one or several BLOCKs. If there is no service on a given day, it does not include any BLOCKs. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:5:965  */
export type TimetablesVehicleServiceVehicleServiceBlocksAggregateArgs = {
  distinct_on?: InputMaybe<Array<TimetablesVehicleServiceBlockSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<TimetablesVehicleServiceBlockOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceBlockBoolExp>;
};

/** A work plan for a single vehicle for a whole day, planned for a specific DAY TYPE. A VEHICLE SERVICE includes one or several BLOCKs. If there is no service on a given day, it does not include any BLOCKs. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:5:965  */
export type TimetablesVehicleServiceVehicleServiceJourneyPatternsInVehicleServiceArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesVehicleServiceJourneyPatternsInVehicleServiceOrderBy>
    >;
    where?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
  };

/** A work plan for a single vehicle for a whole day, planned for a specific DAY TYPE. A VEHICLE SERVICE includes one or several BLOCKs. If there is no service on a given day, it does not include any BLOCKs. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:5:965  */
export type TimetablesVehicleServiceVehicleServiceJourneyPatternsInVehicleServiceAggregateArgs =
  {
    distinct_on?: InputMaybe<
      Array<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSelectColumn>
    >;
    limit?: InputMaybe<Scalars['Int']>;
    offset?: InputMaybe<Scalars['Int']>;
    order_by?: InputMaybe<
      Array<TimetablesVehicleServiceJourneyPatternsInVehicleServiceOrderBy>
    >;
    where?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
  };

/** A work plan for a single vehicle for a whole day, planned for a specific DAY TYPE. A VEHICLE SERVICE includes one or several BLOCKs. If there is no service on a given day, it does not include any BLOCKs. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:5:965  */
export type TimetablesVehicleServiceVehicleServiceNameI18nArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "vehicle_service.vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceAggregate = {
  __typename?: 'timetables_vehicle_service_vehicle_service_aggregate';
  aggregate?: Maybe<TimetablesVehicleServiceVehicleServiceAggregateFields>;
  nodes: Array<TimetablesVehicleServiceVehicleService>;
};

/** aggregate fields of "vehicle_service.vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceAggregateFields = {
  __typename?: 'timetables_vehicle_service_vehicle_service_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<TimetablesVehicleServiceVehicleServiceMaxFields>;
  min?: Maybe<TimetablesVehicleServiceVehicleServiceMinFields>;
};

/** aggregate fields of "vehicle_service.vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceAggregateFieldsCountArgs = {
  columns?: InputMaybe<
    Array<TimetablesVehicleServiceVehicleServiceSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "vehicle_service.vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<TimetablesVehicleServiceVehicleServiceMaxOrderBy>;
  min?: InputMaybe<TimetablesVehicleServiceVehicleServiceMinOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type TimetablesVehicleServiceVehicleServiceAppendInput = {
  /** Name for vehicle service. */
  name_i18n?: InputMaybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "vehicle_service.vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceArrRelInsertInput = {
  data: Array<TimetablesVehicleServiceVehicleServiceInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<TimetablesVehicleServiceVehicleServiceOnConflict>;
};

/** Boolean expression to filter rows from the table "vehicle_service.vehicle_service". All fields are combined with a logical 'AND'. */
export type TimetablesVehicleServiceVehicleServiceBoolExp = {
  _and?: InputMaybe<Array<TimetablesVehicleServiceVehicleServiceBoolExp>>;
  _not?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
  _or?: InputMaybe<Array<TimetablesVehicleServiceVehicleServiceBoolExp>>;
  blocks?: InputMaybe<TimetablesVehicleServiceBlockBoolExp>;
  blocks_aggregate?: InputMaybe<VehicleServiceBlockAggregateBoolExp>;
  day_type?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
  day_type_id?: InputMaybe<UuidComparisonExp>;
  journey_patterns_in_vehicle_service?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
  journey_patterns_in_vehicle_service_aggregate?: InputMaybe<VehicleServiceJourneyPatternsInVehicleServiceAggregateBoolExp>;
  name_i18n?: InputMaybe<JsonbComparisonExp>;
  vehicle_schedule_frame?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameBoolExp>;
  vehicle_schedule_frame_id?: InputMaybe<UuidComparisonExp>;
  vehicle_service_id?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "vehicle_service.vehicle_service" */
export enum TimetablesVehicleServiceVehicleServiceConstraint {
  /** unique or primary key constraint on columns "vehicle_service_id" */
  VehicleServicePkey = 'vehicle_service_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type TimetablesVehicleServiceVehicleServiceDeleteAtPathInput = {
  /** Name for vehicle service. */
  name_i18n?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type TimetablesVehicleServiceVehicleServiceDeleteElemInput = {
  /** Name for vehicle service. */
  name_i18n?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type TimetablesVehicleServiceVehicleServiceDeleteKeyInput = {
  /** Name for vehicle service. */
  name_i18n?: InputMaybe<Scalars['String']>;
};

/** input type for inserting data into table "vehicle_service.vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceInsertInput = {
  blocks?: InputMaybe<TimetablesVehicleServiceBlockArrRelInsertInput>;
  day_type?: InputMaybe<TimetablesServiceCalendarDayTypeObjRelInsertInput>;
  /** The DAY TYPE for the VEHICLE SERVICE. */
  day_type_id?: InputMaybe<Scalars['uuid']>;
  journey_patterns_in_vehicle_service?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceArrRelInsertInput>;
  /** Name for vehicle service. */
  name_i18n?: InputMaybe<Scalars['jsonb']>;
  vehicle_schedule_frame?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameObjRelInsertInput>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  vehicle_schedule_frame_id?: InputMaybe<Scalars['uuid']>;
  vehicle_service_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type TimetablesVehicleServiceVehicleServiceMaxFields = {
  __typename?: 'timetables_vehicle_service_vehicle_service_max_fields';
  /** The DAY TYPE for the VEHICLE SERVICE. */
  day_type_id?: Maybe<Scalars['uuid']>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  vehicle_schedule_frame_id?: Maybe<Scalars['uuid']>;
  vehicle_service_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "vehicle_service.vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceMaxOrderBy = {
  /** The DAY TYPE for the VEHICLE SERVICE. */
  day_type_id?: InputMaybe<OrderBy>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  vehicle_schedule_frame_id?: InputMaybe<OrderBy>;
  vehicle_service_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type TimetablesVehicleServiceVehicleServiceMinFields = {
  __typename?: 'timetables_vehicle_service_vehicle_service_min_fields';
  /** The DAY TYPE for the VEHICLE SERVICE. */
  day_type_id?: Maybe<Scalars['uuid']>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  vehicle_schedule_frame_id?: Maybe<Scalars['uuid']>;
  vehicle_service_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "vehicle_service.vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceMinOrderBy = {
  /** The DAY TYPE for the VEHICLE SERVICE. */
  day_type_id?: InputMaybe<OrderBy>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  vehicle_schedule_frame_id?: InputMaybe<OrderBy>;
  vehicle_service_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "vehicle_service.vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceMutationResponse = {
  __typename?: 'timetables_vehicle_service_vehicle_service_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<TimetablesVehicleServiceVehicleService>;
};

/** input type for inserting object relation for remote table "vehicle_service.vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceObjRelInsertInput = {
  data: TimetablesVehicleServiceVehicleServiceInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<TimetablesVehicleServiceVehicleServiceOnConflict>;
};

/** on_conflict condition type for table "vehicle_service.vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceOnConflict = {
  constraint: TimetablesVehicleServiceVehicleServiceConstraint;
  update_columns?: Array<TimetablesVehicleServiceVehicleServiceUpdateColumn>;
  where?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
};

/** Ordering options when selecting data from "vehicle_service.vehicle_service". */
export type TimetablesVehicleServiceVehicleServiceOrderBy = {
  blocks_aggregate?: InputMaybe<TimetablesVehicleServiceBlockAggregateOrderBy>;
  day_type?: InputMaybe<TimetablesServiceCalendarDayTypeOrderBy>;
  day_type_id?: InputMaybe<OrderBy>;
  journey_patterns_in_vehicle_service_aggregate?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceAggregateOrderBy>;
  name_i18n?: InputMaybe<OrderBy>;
  vehicle_schedule_frame?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameOrderBy>;
  vehicle_schedule_frame_id?: InputMaybe<OrderBy>;
  vehicle_service_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: vehicle_service.vehicle_service */
export type TimetablesVehicleServiceVehicleServicePkColumnsInput = {
  vehicle_service_id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type TimetablesVehicleServiceVehicleServicePrependInput = {
  /** Name for vehicle service. */
  name_i18n?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "vehicle_service.vehicle_service" */
export enum TimetablesVehicleServiceVehicleServiceSelectColumn {
  /** column name */
  DayTypeId = 'day_type_id',
  /** column name */
  NameI18n = 'name_i18n',
  /** column name */
  VehicleScheduleFrameId = 'vehicle_schedule_frame_id',
  /** column name */
  VehicleServiceId = 'vehicle_service_id',
}

/** input type for updating data in table "vehicle_service.vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceSetInput = {
  /** The DAY TYPE for the VEHICLE SERVICE. */
  day_type_id?: InputMaybe<Scalars['uuid']>;
  /** Name for vehicle service. */
  name_i18n?: InputMaybe<Scalars['jsonb']>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  vehicle_schedule_frame_id?: InputMaybe<Scalars['uuid']>;
  vehicle_service_id?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "vehicle_service_vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TimetablesVehicleServiceVehicleServiceStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesVehicleServiceVehicleServiceStreamCursorValueInput = {
  /** The DAY TYPE for the VEHICLE SERVICE. */
  day_type_id?: InputMaybe<Scalars['uuid']>;
  /** Name for vehicle service. */
  name_i18n?: InputMaybe<Scalars['jsonb']>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  vehicle_schedule_frame_id?: InputMaybe<Scalars['uuid']>;
  vehicle_service_id?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "vehicle_service.vehicle_service" */
export enum TimetablesVehicleServiceVehicleServiceUpdateColumn {
  /** column name */
  DayTypeId = 'day_type_id',
  /** column name */
  NameI18n = 'name_i18n',
  /** column name */
  VehicleScheduleFrameId = 'vehicle_schedule_frame_id',
  /** column name */
  VehicleServiceId = 'vehicle_service_id',
}

export type TimetablesVehicleServiceVehicleServiceUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<TimetablesVehicleServiceVehicleServiceAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<TimetablesVehicleServiceVehicleServiceDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<TimetablesVehicleServiceVehicleServiceDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<TimetablesVehicleServiceVehicleServiceDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<TimetablesVehicleServiceVehicleServicePrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TimetablesVehicleServiceVehicleServiceSetInput>;
  /** filter the rows which have to be updated */
  where: TimetablesVehicleServiceVehicleServiceBoolExp;
};

/** The VEHICLE entity is used to describe the physical public transport vehicles available for short-term planning of operations and daily assignment (in contrast to logical vehicles considered for resource planning of operations and daily assignment (in contrast to logical vehicles cplanning). Each VEHICLE shall be classified as of a particular VEHICLE TYPE. */
export type TimetablesVehicleTypeVehicleType = {
  __typename?: 'timetables_vehicle_type_vehicle_type';
  /** Description of the vehicle type. */
  description_i18n?: Maybe<Scalars['jsonb']>;
  /** ID used in Hastus to represent the vehicle type. */
  hsl_id: Scalars['smallint'];
  /** Label of the vehicle type. */
  label: Scalars['String'];
  vehicle_type_id: Scalars['uuid'];
};

/** The VEHICLE entity is used to describe the physical public transport vehicles available for short-term planning of operations and daily assignment (in contrast to logical vehicles considered for resource planning of operations and daily assignment (in contrast to logical vehicles cplanning). Each VEHICLE shall be classified as of a particular VEHICLE TYPE. */
export type TimetablesVehicleTypeVehicleTypeDescriptionI18nArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "vehicle_type.vehicle_type" */
export type TimetablesVehicleTypeVehicleTypeAggregate = {
  __typename?: 'timetables_vehicle_type_vehicle_type_aggregate';
  aggregate?: Maybe<TimetablesVehicleTypeVehicleTypeAggregateFields>;
  nodes: Array<TimetablesVehicleTypeVehicleType>;
};

/** aggregate fields of "vehicle_type.vehicle_type" */
export type TimetablesVehicleTypeVehicleTypeAggregateFields = {
  __typename?: 'timetables_vehicle_type_vehicle_type_aggregate_fields';
  avg?: Maybe<TimetablesVehicleTypeVehicleTypeAvgFields>;
  count: Scalars['Int'];
  max?: Maybe<TimetablesVehicleTypeVehicleTypeMaxFields>;
  min?: Maybe<TimetablesVehicleTypeVehicleTypeMinFields>;
  stddev?: Maybe<TimetablesVehicleTypeVehicleTypeStddevFields>;
  stddev_pop?: Maybe<TimetablesVehicleTypeVehicleTypeStddevPopFields>;
  stddev_samp?: Maybe<TimetablesVehicleTypeVehicleTypeStddevSampFields>;
  sum?: Maybe<TimetablesVehicleTypeVehicleTypeSumFields>;
  var_pop?: Maybe<TimetablesVehicleTypeVehicleTypeVarPopFields>;
  var_samp?: Maybe<TimetablesVehicleTypeVehicleTypeVarSampFields>;
  variance?: Maybe<TimetablesVehicleTypeVehicleTypeVarianceFields>;
};

/** aggregate fields of "vehicle_type.vehicle_type" */
export type TimetablesVehicleTypeVehicleTypeAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TimetablesVehicleTypeVehicleTypeSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type TimetablesVehicleTypeVehicleTypeAppendInput = {
  /** Description of the vehicle type. */
  description_i18n?: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type TimetablesVehicleTypeVehicleTypeAvgFields = {
  __typename?: 'timetables_vehicle_type_vehicle_type_avg_fields';
  /** ID used in Hastus to represent the vehicle type. */
  hsl_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "vehicle_type.vehicle_type". All fields are combined with a logical 'AND'. */
export type TimetablesVehicleTypeVehicleTypeBoolExp = {
  _and?: InputMaybe<Array<TimetablesVehicleTypeVehicleTypeBoolExp>>;
  _not?: InputMaybe<TimetablesVehicleTypeVehicleTypeBoolExp>;
  _or?: InputMaybe<Array<TimetablesVehicleTypeVehicleTypeBoolExp>>;
  description_i18n?: InputMaybe<JsonbComparisonExp>;
  hsl_id?: InputMaybe<SmallintComparisonExp>;
  label?: InputMaybe<StringComparisonExp>;
  vehicle_type_id?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "vehicle_type.vehicle_type" */
export enum TimetablesVehicleTypeVehicleTypeConstraint {
  /** unique or primary key constraint on columns "hsl_id" */
  VehicleTypeHslIdIdx = 'vehicle_type_hsl_id_idx',
  /** unique or primary key constraint on columns "label" */
  VehicleTypeLabelIdx = 'vehicle_type_label_idx',
  /** unique or primary key constraint on columns "vehicle_type_id" */
  VehicleTypePkey = 'vehicle_type_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type TimetablesVehicleTypeVehicleTypeDeleteAtPathInput = {
  /** Description of the vehicle type. */
  description_i18n?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type TimetablesVehicleTypeVehicleTypeDeleteElemInput = {
  /** Description of the vehicle type. */
  description_i18n?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type TimetablesVehicleTypeVehicleTypeDeleteKeyInput = {
  /** Description of the vehicle type. */
  description_i18n?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "vehicle_type.vehicle_type" */
export type TimetablesVehicleTypeVehicleTypeIncInput = {
  /** ID used in Hastus to represent the vehicle type. */
  hsl_id?: InputMaybe<Scalars['smallint']>;
};

/** input type for inserting data into table "vehicle_type.vehicle_type" */
export type TimetablesVehicleTypeVehicleTypeInsertInput = {
  /** Description of the vehicle type. */
  description_i18n?: InputMaybe<Scalars['jsonb']>;
  /** ID used in Hastus to represent the vehicle type. */
  hsl_id?: InputMaybe<Scalars['smallint']>;
  /** Label of the vehicle type. */
  label?: InputMaybe<Scalars['String']>;
  vehicle_type_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type TimetablesVehicleTypeVehicleTypeMaxFields = {
  __typename?: 'timetables_vehicle_type_vehicle_type_max_fields';
  /** ID used in Hastus to represent the vehicle type. */
  hsl_id?: Maybe<Scalars['smallint']>;
  /** Label of the vehicle type. */
  label?: Maybe<Scalars['String']>;
  vehicle_type_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type TimetablesVehicleTypeVehicleTypeMinFields = {
  __typename?: 'timetables_vehicle_type_vehicle_type_min_fields';
  /** ID used in Hastus to represent the vehicle type. */
  hsl_id?: Maybe<Scalars['smallint']>;
  /** Label of the vehicle type. */
  label?: Maybe<Scalars['String']>;
  vehicle_type_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "vehicle_type.vehicle_type" */
export type TimetablesVehicleTypeVehicleTypeMutationResponse = {
  __typename?: 'timetables_vehicle_type_vehicle_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<TimetablesVehicleTypeVehicleType>;
};

/** input type for inserting object relation for remote table "vehicle_type.vehicle_type" */
export type TimetablesVehicleTypeVehicleTypeObjRelInsertInput = {
  data: TimetablesVehicleTypeVehicleTypeInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<TimetablesVehicleTypeVehicleTypeOnConflict>;
};

/** on_conflict condition type for table "vehicle_type.vehicle_type" */
export type TimetablesVehicleTypeVehicleTypeOnConflict = {
  constraint: TimetablesVehicleTypeVehicleTypeConstraint;
  update_columns?: Array<TimetablesVehicleTypeVehicleTypeUpdateColumn>;
  where?: InputMaybe<TimetablesVehicleTypeVehicleTypeBoolExp>;
};

/** Ordering options when selecting data from "vehicle_type.vehicle_type". */
export type TimetablesVehicleTypeVehicleTypeOrderBy = {
  description_i18n?: InputMaybe<OrderBy>;
  hsl_id?: InputMaybe<OrderBy>;
  label?: InputMaybe<OrderBy>;
  vehicle_type_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: vehicle_type.vehicle_type */
export type TimetablesVehicleTypeVehicleTypePkColumnsInput = {
  vehicle_type_id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type TimetablesVehicleTypeVehicleTypePrependInput = {
  /** Description of the vehicle type. */
  description_i18n?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "vehicle_type.vehicle_type" */
export enum TimetablesVehicleTypeVehicleTypeSelectColumn {
  /** column name */
  DescriptionI18n = 'description_i18n',
  /** column name */
  HslId = 'hsl_id',
  /** column name */
  Label = 'label',
  /** column name */
  VehicleTypeId = 'vehicle_type_id',
}

/** input type for updating data in table "vehicle_type.vehicle_type" */
export type TimetablesVehicleTypeVehicleTypeSetInput = {
  /** Description of the vehicle type. */
  description_i18n?: InputMaybe<Scalars['jsonb']>;
  /** ID used in Hastus to represent the vehicle type. */
  hsl_id?: InputMaybe<Scalars['smallint']>;
  /** Label of the vehicle type. */
  label?: InputMaybe<Scalars['String']>;
  vehicle_type_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type TimetablesVehicleTypeVehicleTypeStddevFields = {
  __typename?: 'timetables_vehicle_type_vehicle_type_stddev_fields';
  /** ID used in Hastus to represent the vehicle type. */
  hsl_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type TimetablesVehicleTypeVehicleTypeStddevPopFields = {
  __typename?: 'timetables_vehicle_type_vehicle_type_stddev_pop_fields';
  /** ID used in Hastus to represent the vehicle type. */
  hsl_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type TimetablesVehicleTypeVehicleTypeStddevSampFields = {
  __typename?: 'timetables_vehicle_type_vehicle_type_stddev_samp_fields';
  /** ID used in Hastus to represent the vehicle type. */
  hsl_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "vehicle_type_vehicle_type" */
export type TimetablesVehicleTypeVehicleTypeStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TimetablesVehicleTypeVehicleTypeStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesVehicleTypeVehicleTypeStreamCursorValueInput = {
  /** Description of the vehicle type. */
  description_i18n?: InputMaybe<Scalars['jsonb']>;
  /** ID used in Hastus to represent the vehicle type. */
  hsl_id?: InputMaybe<Scalars['smallint']>;
  /** Label of the vehicle type. */
  label?: InputMaybe<Scalars['String']>;
  vehicle_type_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type TimetablesVehicleTypeVehicleTypeSumFields = {
  __typename?: 'timetables_vehicle_type_vehicle_type_sum_fields';
  /** ID used in Hastus to represent the vehicle type. */
  hsl_id?: Maybe<Scalars['smallint']>;
};

/** update columns of table "vehicle_type.vehicle_type" */
export enum TimetablesVehicleTypeVehicleTypeUpdateColumn {
  /** column name */
  DescriptionI18n = 'description_i18n',
  /** column name */
  HslId = 'hsl_id',
  /** column name */
  Label = 'label',
  /** column name */
  VehicleTypeId = 'vehicle_type_id',
}

export type TimetablesVehicleTypeVehicleTypeUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<TimetablesVehicleTypeVehicleTypeAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<TimetablesVehicleTypeVehicleTypeDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<TimetablesVehicleTypeVehicleTypeDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<TimetablesVehicleTypeVehicleTypeDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TimetablesVehicleTypeVehicleTypeIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<TimetablesVehicleTypeVehicleTypePrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TimetablesVehicleTypeVehicleTypeSetInput>;
  /** filter the rows which have to be updated */
  where: TimetablesVehicleTypeVehicleTypeBoolExp;
};

/** aggregate var_pop on columns */
export type TimetablesVehicleTypeVehicleTypeVarPopFields = {
  __typename?: 'timetables_vehicle_type_vehicle_type_var_pop_fields';
  /** ID used in Hastus to represent the vehicle type. */
  hsl_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type TimetablesVehicleTypeVehicleTypeVarSampFields = {
  __typename?: 'timetables_vehicle_type_vehicle_type_var_samp_fields';
  /** ID used in Hastus to represent the vehicle type. */
  hsl_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type TimetablesVehicleTypeVehicleTypeVarianceFields = {
  __typename?: 'timetables_vehicle_type_vehicle_type_variance_fields';
  /** ID used in Hastus to represent the vehicle type. */
  hsl_id?: Maybe<Scalars['Float']>;
};

/** A set of SCHEDULED STOP POINTs against which the timing information necessary to build schedules may be recorded. In HSL context this is "Hastus paikka". Based on Transmodel entity TIMING POINT: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:2:709  */
export type TimingPatternTimingPlace = {
  __typename?: 'timing_pattern_timing_place';
  description?: Maybe<Scalars['jsonb']>;
  label: Scalars['String'];
  /** An array relationship */
  scheduled_stop_points: Array<ServicePatternScheduledStopPoint>;
  /** An aggregate relationship */
  scheduled_stop_points_aggregate: ServicePatternScheduledStopPointAggregate;
  timing_place_id: Scalars['uuid'];
};

/** A set of SCHEDULED STOP POINTs against which the timing information necessary to build schedules may be recorded. In HSL context this is "Hastus paikka". Based on Transmodel entity TIMING POINT: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:2:709  */
export type TimingPatternTimingPlaceDescriptionArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** A set of SCHEDULED STOP POINTs against which the timing information necessary to build schedules may be recorded. In HSL context this is "Hastus paikka". Based on Transmodel entity TIMING POINT: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:2:709  */
export type TimingPatternTimingPlaceScheduledStopPointsArgs = {
  distinct_on?: InputMaybe<Array<ServicePatternScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<ServicePatternScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};

/** A set of SCHEDULED STOP POINTs against which the timing information necessary to build schedules may be recorded. In HSL context this is "Hastus paikka". Based on Transmodel entity TIMING POINT: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:2:709  */
export type TimingPatternTimingPlaceScheduledStopPointsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ServicePatternScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<ServicePatternScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};

/** aggregated selection of "timing_pattern.timing_place" */
export type TimingPatternTimingPlaceAggregate = {
  __typename?: 'timing_pattern_timing_place_aggregate';
  aggregate?: Maybe<TimingPatternTimingPlaceAggregateFields>;
  nodes: Array<TimingPatternTimingPlace>;
};

/** aggregate fields of "timing_pattern.timing_place" */
export type TimingPatternTimingPlaceAggregateFields = {
  __typename?: 'timing_pattern_timing_place_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<TimingPatternTimingPlaceMaxFields>;
  min?: Maybe<TimingPatternTimingPlaceMinFields>;
};

/** aggregate fields of "timing_pattern.timing_place" */
export type TimingPatternTimingPlaceAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TimingPatternTimingPlaceSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type TimingPatternTimingPlaceAppendInput = {
  description?: InputMaybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "timing_pattern.timing_place". All fields are combined with a logical 'AND'. */
export type TimingPatternTimingPlaceBoolExp = {
  _and?: InputMaybe<Array<TimingPatternTimingPlaceBoolExp>>;
  _not?: InputMaybe<TimingPatternTimingPlaceBoolExp>;
  _or?: InputMaybe<Array<TimingPatternTimingPlaceBoolExp>>;
  description?: InputMaybe<JsonbComparisonExp>;
  label?: InputMaybe<StringComparisonExp>;
  scheduled_stop_points?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
  scheduled_stop_points_aggregate?: InputMaybe<ServicePatternScheduledStopPointAggregateBoolExp>;
  timing_place_id?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "timing_pattern.timing_place" */
export enum TimingPatternTimingPlaceConstraint {
  /** unique or primary key constraint on columns "label" */
  TimingPlaceLabelIdx = 'timing_place_label_idx',
  /** unique or primary key constraint on columns "timing_place_id" */
  TimingPlacePkey = 'timing_place_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type TimingPatternTimingPlaceDeleteAtPathInput = {
  description?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type TimingPatternTimingPlaceDeleteElemInput = {
  description?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type TimingPatternTimingPlaceDeleteKeyInput = {
  description?: InputMaybe<Scalars['String']>;
};

/** input type for inserting data into table "timing_pattern.timing_place" */
export type TimingPatternTimingPlaceInsertInput = {
  description?: InputMaybe<Scalars['jsonb']>;
  label?: InputMaybe<Scalars['String']>;
  scheduled_stop_points?: InputMaybe<ServicePatternScheduledStopPointArrRelInsertInput>;
  timing_place_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type TimingPatternTimingPlaceMaxFields = {
  __typename?: 'timing_pattern_timing_place_max_fields';
  label?: Maybe<Scalars['String']>;
  timing_place_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type TimingPatternTimingPlaceMinFields = {
  __typename?: 'timing_pattern_timing_place_min_fields';
  label?: Maybe<Scalars['String']>;
  timing_place_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "timing_pattern.timing_place" */
export type TimingPatternTimingPlaceMutationResponse = {
  __typename?: 'timing_pattern_timing_place_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<TimingPatternTimingPlace>;
};

/** input type for inserting object relation for remote table "timing_pattern.timing_place" */
export type TimingPatternTimingPlaceObjRelInsertInput = {
  data: TimingPatternTimingPlaceInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<TimingPatternTimingPlaceOnConflict>;
};

/** on_conflict condition type for table "timing_pattern.timing_place" */
export type TimingPatternTimingPlaceOnConflict = {
  constraint: TimingPatternTimingPlaceConstraint;
  update_columns?: Array<TimingPatternTimingPlaceUpdateColumn>;
  where?: InputMaybe<TimingPatternTimingPlaceBoolExp>;
};

/** Ordering options when selecting data from "timing_pattern.timing_place". */
export type TimingPatternTimingPlaceOrderBy = {
  description?: InputMaybe<OrderBy>;
  label?: InputMaybe<OrderBy>;
  scheduled_stop_points_aggregate?: InputMaybe<ServicePatternScheduledStopPointAggregateOrderBy>;
  timing_place_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: timing_pattern.timing_place */
export type TimingPatternTimingPlacePkColumnsInput = {
  timing_place_id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type TimingPatternTimingPlacePrependInput = {
  description?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "timing_pattern.timing_place" */
export enum TimingPatternTimingPlaceSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Label = 'label',
  /** column name */
  TimingPlaceId = 'timing_place_id',
}

/** input type for updating data in table "timing_pattern.timing_place" */
export type TimingPatternTimingPlaceSetInput = {
  description?: InputMaybe<Scalars['jsonb']>;
  label?: InputMaybe<Scalars['String']>;
  timing_place_id?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "timing_pattern_timing_place" */
export type TimingPatternTimingPlaceStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TimingPatternTimingPlaceStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimingPatternTimingPlaceStreamCursorValueInput = {
  description?: InputMaybe<Scalars['jsonb']>;
  label?: InputMaybe<Scalars['String']>;
  timing_place_id?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "timing_pattern.timing_place" */
export enum TimingPatternTimingPlaceUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Label = 'label',
  /** column name */
  TimingPlaceId = 'timing_place_id',
}

export type TimingPatternTimingPlaceUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<TimingPatternTimingPlaceAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<TimingPatternTimingPlaceDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<TimingPatternTimingPlaceDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<TimingPatternTimingPlaceDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<TimingPatternTimingPlacePrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TimingPatternTimingPlaceSetInput>;
  /** filter the rows which have to be updated */
  where: TimingPatternTimingPlaceBoolExp;
};

export type TopographicPlaceKeyValuesAggregateBoolExp = {
  count?: InputMaybe<TopographicPlaceKeyValuesAggregateBoolExpCount>;
};

export type TopographicPlaceKeyValuesAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<StopsDatabaseTopographicPlaceKeyValuesSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesBoolExp>;
  predicate: IntComparisonExp;
};

/** Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'. */
export type UuidComparisonExp = {
  _eq?: InputMaybe<Scalars['uuid']>;
  _gt?: InputMaybe<Scalars['uuid']>;
  _gte?: InputMaybe<Scalars['uuid']>;
  _in?: InputMaybe<Array<Scalars['uuid']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['uuid']>;
  _lte?: InputMaybe<Scalars['uuid']>;
  _neq?: InputMaybe<Scalars['uuid']>;
  _nin?: InputMaybe<Array<Scalars['uuid']>>;
};

export type ValidityPeriod = {
  validity_end?: Maybe<Scalars['date']>;
  validity_start?: Maybe<Scalars['date']>;
};

export type ValueItemsAggregateBoolExp = {
  count?: InputMaybe<ValueItemsAggregateBoolExpCount>;
};

export type ValueItemsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<StopsDatabaseValueItemsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<StopsDatabaseValueItemsBoolExp>;
  predicate: IntComparisonExp;
};

export type VehicleJourneyVehicleJourneyAggregateBoolExp = {
  bool_and?: InputMaybe<VehicleJourneyVehicleJourneyAggregateBoolExpBoolAnd>;
  bool_or?: InputMaybe<VehicleJourneyVehicleJourneyAggregateBoolExpBoolOr>;
  count?: InputMaybe<VehicleJourneyVehicleJourneyAggregateBoolExpCount>;
};

export type VehicleJourneyVehicleJourneyAggregateBoolExpBoolAnd = {
  arguments: TimetablesVehicleJourneyVehicleJourneySelectColumnVehicleJourneyVehicleJourneyAggregateBoolExpBoolAndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
  predicate: BooleanComparisonExp;
};

export type VehicleJourneyVehicleJourneyAggregateBoolExpBoolOr = {
  arguments: TimetablesVehicleJourneyVehicleJourneySelectColumnVehicleJourneyVehicleJourneyAggregateBoolExpBoolOrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
  predicate: BooleanComparisonExp;
};

export type VehicleJourneyVehicleJourneyAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<TimetablesVehicleJourneyVehicleJourneySelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
  predicate: IntComparisonExp;
};

export type VehicleServiceBlockAggregateBoolExp = {
  count?: InputMaybe<VehicleServiceBlockAggregateBoolExpCount>;
};

export type VehicleServiceBlockAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<TimetablesVehicleServiceBlockSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<TimetablesVehicleServiceBlockBoolExp>;
  predicate: IntComparisonExp;
};

export type VehicleServiceJourneyPatternsInVehicleServiceAggregateBoolExp = {
  count?: InputMaybe<VehicleServiceJourneyPatternsInVehicleServiceAggregateBoolExpCount>;
};

export type VehicleServiceJourneyPatternsInVehicleServiceAggregateBoolExpCount =
  {
    arguments?: InputMaybe<
      Array<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSelectColumn>
    >;
    distinct?: InputMaybe<Scalars['Boolean']>;
    filter?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
    predicate: IntComparisonExp;
  };

export type VehicleServiceVehicleServiceAggregateBoolExp = {
  count?: InputMaybe<VehicleServiceVehicleServiceAggregateBoolExpCount>;
};

export type VehicleServiceVehicleServiceAggregateBoolExpCount = {
  arguments?: InputMaybe<
    Array<TimetablesVehicleServiceVehicleServiceSelectColumn>
  >;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
  predicate: IntComparisonExp;
};

export type LineTableRowFragment = {
  __typename?: 'route_line';
  name_i18n: LocalizedString;
  short_name_i18n: LocalizedString;
  validity_start?: luxon.DateTime | null;
  validity_end?: luxon.DateTime | null;
  priority: number;
  line_id: UUID;
  label: string;
  line_routes: Array<{
    __typename?: 'route_route';
    unique_label: string;
    direction: RouteDirectionEnum;
    route_id: UUID;
    route_shape?: GeoJSON.LineString | null;
    label: string;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    route_journey_patterns: Array<{
      __typename?: 'journey_pattern_journey_pattern';
      journey_pattern_id: UUID;
      journey_pattern_refs: Array<{
        __typename?: 'timetables_journey_pattern_journey_pattern_ref';
        journey_pattern_ref_id: UUID;
        vehicle_journeys: Array<{
          __typename?: 'timetables_vehicle_journey_vehicle_journey';
          vehicle_journey_id: UUID;
        }>;
      }>;
      scheduled_stop_point_in_journey_patterns: Array<{
        __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
        journey_pattern_id: UUID;
        scheduled_stop_point_sequence: number;
        is_used_as_timing_point: boolean;
      }>;
    }>;
  }>;
};

export type RouteTableRowFragment = {
  __typename?: 'route_route';
  name_i18n: LocalizedString;
  direction: RouteDirectionEnum;
  priority: number;
  on_line_id: UUID;
  variant?: number | null;
  unique_label: string;
  route_id: UUID;
  label: string;
  route_shape?: GeoJSON.LineString | null;
  validity_start?: luxon.DateTime | null;
  validity_end?: luxon.DateTime | null;
  route_journey_patterns: Array<{
    __typename?: 'journey_pattern_journey_pattern';
    journey_pattern_id: UUID;
    journey_pattern_refs: Array<{
      __typename?: 'timetables_journey_pattern_journey_pattern_ref';
      journey_pattern_ref_id: UUID;
      vehicle_journeys: Array<{
        __typename?: 'timetables_vehicle_journey_vehicle_journey';
        vehicle_journey_id: UUID;
      }>;
    }>;
    scheduled_stop_point_in_journey_patterns: Array<{
      __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
      journey_pattern_id: UUID;
      scheduled_stop_point_sequence: number;
      is_used_as_timing_point: boolean;
    }>;
  }>;
};

export type LineWithRoutesUniqueFieldsFragment = {
  __typename?: 'route_line';
  primary_vehicle_mode: ReusableComponentsVehicleModeEnum;
  type_of_line: RouteTypeOfLineEnum;
  transport_target: HslRouteTransportTargetEnum;
  line_id: UUID;
  label: string;
  name_i18n: LocalizedString;
  short_name_i18n: LocalizedString;
  validity_start?: luxon.DateTime | null;
  validity_end?: luxon.DateTime | null;
  priority: number;
  line_routes: Array<{
    __typename?: 'route_route';
    label: string;
    direction: RouteDirectionEnum;
    variant?: number | null;
    route_id: UUID;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    priority: number;
  }>;
};

export type ListChangingRoutesQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']>;
}>;

export type ListChangingRoutesQuery = {
  __typename?: 'query_root';
  route_route: Array<{
    __typename?: 'route_route';
    name_i18n: LocalizedString;
    direction: RouteDirectionEnum;
    priority: number;
    on_line_id: UUID;
    variant?: number | null;
    unique_label: string;
    route_id: UUID;
    label: string;
    route_shape?: GeoJSON.LineString | null;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    route_journey_patterns: Array<{
      __typename?: 'journey_pattern_journey_pattern';
      journey_pattern_id: UUID;
      journey_pattern_refs: Array<{
        __typename?: 'timetables_journey_pattern_journey_pattern_ref';
        journey_pattern_ref_id: UUID;
        vehicle_journeys: Array<{
          __typename?: 'timetables_vehicle_journey_vehicle_journey';
          vehicle_journey_id: UUID;
        }>;
      }>;
      scheduled_stop_point_in_journey_patterns: Array<{
        __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
        journey_pattern_id: UUID;
        scheduled_stop_point_sequence: number;
        is_used_as_timing_point: boolean;
      }>;
    }>;
  }>;
};

export type ListOwnLinesQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']>;
}>;

export type ListOwnLinesQuery = {
  __typename?: 'query_root';
  route_line: Array<{
    __typename?: 'route_line';
    name_i18n: LocalizedString;
    short_name_i18n: LocalizedString;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    priority: number;
    line_id: UUID;
    label: string;
    line_routes: Array<{
      __typename?: 'route_route';
      unique_label: string;
      direction: RouteDirectionEnum;
      route_id: UUID;
      route_shape?: GeoJSON.LineString | null;
      label: string;
      validity_start?: luxon.DateTime | null;
      validity_end?: luxon.DateTime | null;
      route_journey_patterns: Array<{
        __typename?: 'journey_pattern_journey_pattern';
        journey_pattern_id: UUID;
        journey_pattern_refs: Array<{
          __typename?: 'timetables_journey_pattern_journey_pattern_ref';
          journey_pattern_ref_id: UUID;
          vehicle_journeys: Array<{
            __typename?: 'timetables_vehicle_journey_vehicle_journey';
            vehicle_journey_id: UUID;
          }>;
        }>;
        scheduled_stop_point_in_journey_patterns: Array<{
          __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
          journey_pattern_id: UUID;
          scheduled_stop_point_sequence: number;
          is_used_as_timing_point: boolean;
        }>;
      }>;
    }>;
  }>;
};

export type ScheduledStopPointWithTimingSettingsFragment = {
  __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
  journey_pattern_id: UUID;
  scheduled_stop_point_label: string;
  scheduled_stop_point_sequence: number;
  is_used_as_timing_point: boolean;
  is_regulated_timing_point: boolean;
  is_loading_time_allowed: boolean;
  is_via_point: boolean;
  via_point_name_i18n?: LocalizedString | null;
  via_point_short_name_i18n?: LocalizedString | null;
  journey_pattern: {
    __typename?: 'journey_pattern_journey_pattern';
    journey_pattern_id: UUID;
    on_route_id: UUID;
    journey_pattern_route?: {
      __typename?: 'route_route';
      route_id: UUID;
      label: string;
    } | null;
  };
  scheduled_stop_points: Array<{
    __typename?: 'service_pattern_scheduled_stop_point';
    scheduled_stop_point_id: UUID;
    timing_place_id?: UUID | null;
  }>;
};

export type GetScheduledStopPointWithTimingSettingsQueryVariables = Exact<{
  journeyPatternId: Scalars['uuid'];
  stopLabel: Scalars['String'];
  sequence: Scalars['Int'];
}>;

export type GetScheduledStopPointWithTimingSettingsQuery = {
  __typename?: 'query_root';
  journey_pattern_scheduled_stop_point_in_journey_pattern: Array<{
    __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
    journey_pattern_id: UUID;
    scheduled_stop_point_label: string;
    scheduled_stop_point_sequence: number;
    is_used_as_timing_point: boolean;
    is_regulated_timing_point: boolean;
    is_loading_time_allowed: boolean;
    is_via_point: boolean;
    via_point_name_i18n?: LocalizedString | null;
    via_point_short_name_i18n?: LocalizedString | null;
    journey_pattern: {
      __typename?: 'journey_pattern_journey_pattern';
      journey_pattern_id: UUID;
      on_route_id: UUID;
      journey_pattern_route?: {
        __typename?: 'route_route';
        route_id: UUID;
        label: string;
      } | null;
    };
    scheduled_stop_points: Array<{
      __typename?: 'service_pattern_scheduled_stop_point';
      scheduled_stop_point_id: UUID;
      timing_place_id?: UUID | null;
    }>;
  }>;
};

export type VehicleJourneyByStopFragment = {
  __typename?: 'timetables_vehicle_journey_vehicle_journey';
  journey_pattern_ref_id: UUID;
  vehicle_journey_id: UUID;
  timetabled_passing_times: Array<{
    __typename?: 'timetables_passing_times_timetabled_passing_time';
    arrival_time?: luxon.Duration | null;
    departure_time?: luxon.Duration | null;
    passing_time: luxon.Duration;
    scheduled_stop_point_in_journey_pattern_ref_id: UUID;
    timetabled_passing_time_id: UUID;
    vehicle_journey_id: UUID;
    scheduled_stop_point_in_journey_pattern_ref: {
      __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref';
      scheduled_stop_point_in_journey_pattern_ref_id: UUID;
      scheduled_stop_point_label: string;
      journey_pattern_ref: {
        __typename?: 'timetables_journey_pattern_journey_pattern_ref';
        journey_pattern_ref_id: UUID;
        observation_timestamp: luxon.DateTime;
      };
      scheduled_stop_point_instances: Array<{
        __typename?: 'service_pattern_scheduled_stop_point';
        priority: number;
        direction: InfrastructureNetworkDirectionEnum;
        scheduled_stop_point_id: UUID;
        label: string;
        timing_place_id?: UUID | null;
        validity_start?: luxon.DateTime | null;
        validity_end?: luxon.DateTime | null;
        located_on_infrastructure_link_id: UUID;
        timing_place?: {
          __typename?: 'timing_pattern_timing_place';
          label: string;
          timing_place_id: UUID;
        } | null;
      }>;
    };
    vehicle_journey: {
      __typename?: 'timetables_vehicle_journey_vehicle_journey';
      vehicle_journey_id: UUID;
      block: {
        __typename?: 'timetables_vehicle_service_block';
        block_id: UUID;
        vehicle_type?: {
          __typename?: 'timetables_vehicle_type_vehicle_type';
          description_i18n?: any | null;
          vehicle_type_id: UUID;
        } | null;
      };
    };
  }>;
};

export type PassingTimeByStopFragment = {
  __typename?: 'timetables_passing_times_timetabled_passing_time';
  arrival_time?: luxon.Duration | null;
  departure_time?: luxon.Duration | null;
  passing_time: luxon.Duration;
  scheduled_stop_point_in_journey_pattern_ref_id: UUID;
  timetabled_passing_time_id: UUID;
  vehicle_journey_id: UUID;
  scheduled_stop_point_in_journey_pattern_ref: {
    __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref';
    scheduled_stop_point_in_journey_pattern_ref_id: UUID;
    scheduled_stop_point_label: string;
    journey_pattern_ref: {
      __typename?: 'timetables_journey_pattern_journey_pattern_ref';
      journey_pattern_ref_id: UUID;
      observation_timestamp: luxon.DateTime;
    };
    scheduled_stop_point_instances: Array<{
      __typename?: 'service_pattern_scheduled_stop_point';
      priority: number;
      direction: InfrastructureNetworkDirectionEnum;
      scheduled_stop_point_id: UUID;
      label: string;
      timing_place_id?: UUID | null;
      validity_start?: luxon.DateTime | null;
      validity_end?: luxon.DateTime | null;
      located_on_infrastructure_link_id: UUID;
      timing_place?: {
        __typename?: 'timing_pattern_timing_place';
        label: string;
        timing_place_id: UUID;
      } | null;
    }>;
  };
  vehicle_journey: {
    __typename?: 'timetables_vehicle_journey_vehicle_journey';
    vehicle_journey_id: UUID;
    block: {
      __typename?: 'timetables_vehicle_service_block';
      block_id: UUID;
      vehicle_type?: {
        __typename?: 'timetables_vehicle_type_vehicle_type';
        description_i18n?: any | null;
        vehicle_type_id: UUID;
      } | null;
    };
  };
};

export type GetRouteWithJourneyPatternQueryVariables = Exact<{
  routeId: Scalars['uuid'];
}>;

export type GetRouteWithJourneyPatternQuery = {
  __typename?: 'query_root';
  route_route_by_pk?: {
    __typename?: 'route_route';
    route_shape?: GeoJSON.LineString | null;
    name_i18n: LocalizedString;
    description_i18n?: LocalizedString | null;
    origin_name_i18n: LocalizedString;
    origin_short_name_i18n: LocalizedString;
    destination_name_i18n: LocalizedString;
    destination_short_name_i18n: LocalizedString;
    on_line_id: UUID;
    label: string;
    direction: RouteDirectionEnum;
    variant?: number | null;
    route_id: UUID;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    priority: number;
    route_journey_patterns: Array<{
      __typename?: 'journey_pattern_journey_pattern';
      journey_pattern_id: UUID;
      on_route_id: UUID;
      ordered_scheduled_stop_point_in_journey_patterns: Array<{
        __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
        journey_pattern_id: UUID;
        scheduled_stop_point_label: string;
        scheduled_stop_point_sequence: number;
        is_used_as_timing_point: boolean;
        is_regulated_timing_point: boolean;
        is_loading_time_allowed: boolean;
        is_via_point: boolean;
        via_point_name_i18n?: LocalizedString | null;
        via_point_short_name_i18n?: LocalizedString | null;
        scheduled_stop_points: Array<{
          __typename?: 'service_pattern_scheduled_stop_point';
          priority: number;
          direction: InfrastructureNetworkDirectionEnum;
          scheduled_stop_point_id: UUID;
          label: string;
          timing_place_id?: UUID | null;
          validity_start?: luxon.DateTime | null;
          validity_end?: luxon.DateTime | null;
          located_on_infrastructure_link_id: UUID;
          timing_place?: {
            __typename?: 'timing_pattern_timing_place';
            timing_place_id: UUID;
            label: string;
          } | null;
        }>;
        journey_pattern: {
          __typename?: 'journey_pattern_journey_pattern';
          journey_pattern_id: UUID;
          on_route_id: UUID;
        };
      }>;
    }>;
  } | null;
};

export type RouteInfraLinkFieldsFragment = {
  __typename?: 'infrastructure_network_infrastructure_link';
  external_link_source: InfrastructureNetworkExternalSourceEnum;
  external_link_id: string;
  infrastructure_link_id: UUID;
  shape: GeoJSON.LineString;
  direction: InfrastructureNetworkDirectionEnum;
  scheduled_stop_points_located_on_infrastructure_link: Array<{
    __typename?: 'service_pattern_scheduled_stop_point';
    measured_location: GeoJSON.Point;
    relative_distance_from_infrastructure_link_start: number;
    closest_point_on_infrastructure_link?: GeoJSON.Point | null;
    priority: number;
    direction: InfrastructureNetworkDirectionEnum;
    scheduled_stop_point_id: UUID;
    label: string;
    timing_place_id?: UUID | null;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    located_on_infrastructure_link_id: UUID;
    other_label_instances: Array<{
      __typename?: 'service_pattern_scheduled_stop_point';
      priority: number;
      direction: InfrastructureNetworkDirectionEnum;
      scheduled_stop_point_id: UUID;
      label: string;
      timing_place_id?: UUID | null;
      validity_start?: luxon.DateTime | null;
      validity_end?: luxon.DateTime | null;
      located_on_infrastructure_link_id: UUID;
      timing_place?: {
        __typename?: 'timing_pattern_timing_place';
        timing_place_id: UUID;
        label: string;
      } | null;
    }>;
    scheduled_stop_point_in_journey_patterns: Array<{
      __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
      journey_pattern_id: UUID;
      scheduled_stop_point_label: string;
      scheduled_stop_point_sequence: number;
      is_used_as_timing_point: boolean;
      is_regulated_timing_point: boolean;
      is_loading_time_allowed: boolean;
      is_via_point: boolean;
      via_point_name_i18n?: LocalizedString | null;
      via_point_short_name_i18n?: LocalizedString | null;
      journey_pattern: {
        __typename?: 'journey_pattern_journey_pattern';
        journey_pattern_id: UUID;
        on_route_id: UUID;
      };
    }>;
    vehicle_mode_on_scheduled_stop_point: Array<{
      __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point';
      vehicle_mode: ReusableComponentsVehicleModeEnum;
    }>;
    timing_place?: {
      __typename?: 'timing_pattern_timing_place';
      timing_place_id: UUID;
      label: string;
    } | null;
  }>;
};

export type InfraLinkAlongRouteDefaultFieldsFragment = {
  __typename?: 'route_infrastructure_link_along_route';
  infrastructure_link_id: UUID;
  is_traversal_forwards: boolean;
  infrastructure_link: {
    __typename?: 'infrastructure_network_infrastructure_link';
    infrastructure_link_id: UUID;
  };
};

export type InfrastructureLinkDefaultFieldsFragment = {
  __typename?: 'infrastructure_network_infrastructure_link';
  infrastructure_link_id: UUID;
};

export type InfrastructureLinkAllFieldsFragment = {
  __typename?: 'infrastructure_network_infrastructure_link';
  direction: InfrastructureNetworkDirectionEnum;
  shape: GeoJSON.LineString;
  estimated_length_in_metres?: number | null;
  external_link_id: string;
  external_link_source: InfrastructureNetworkExternalSourceEnum;
  infrastructure_link_id: UUID;
};

export type InfraLinkMatchingFieldsFragment = {
  __typename?: 'infrastructure_network_infrastructure_link';
  external_link_id: string;
  infrastructure_link_id: UUID;
  shape: GeoJSON.LineString;
  direction: InfrastructureNetworkDirectionEnum;
};

export type QueryClosestLinkQueryVariables = Exact<{
  point?: InputMaybe<Scalars['geography']>;
}>;

export type QueryClosestLinkQuery = {
  __typename?: 'query_root';
  infrastructure_network_resolve_point_to_closest_link: Array<{
    __typename?: 'infrastructure_network_infrastructure_link';
    direction: InfrastructureNetworkDirectionEnum;
    shape: GeoJSON.LineString;
    estimated_length_in_metres?: number | null;
    external_link_id: string;
    external_link_source: InfrastructureNetworkExternalSourceEnum;
    infrastructure_link_id: UUID;
  }>;
};

export type QueryPointDirectionOnLinkQueryVariables = Exact<{
  point_of_interest?: InputMaybe<Scalars['geography']>;
  infrastructure_link_uuid?: InputMaybe<Scalars['uuid']>;
  point_max_distance_in_meters?: InputMaybe<Scalars['float8']>;
}>;

export type QueryPointDirectionOnLinkQuery = {
  __typename?: 'query_root';
  infrastructure_network_find_point_direction_on_link: Array<{
    __typename?: 'infrastructure_network_direction';
    value: InfrastructureNetworkDirectionEnum;
  }>;
};

export type GetStopsAlongInfrastructureLinksQueryVariables = Exact<{
  infrastructure_link_ids?: InputMaybe<
    Array<Scalars['uuid']> | Scalars['uuid']
  >;
}>;

export type GetStopsAlongInfrastructureLinksQuery = {
  __typename?: 'query_root';
  service_pattern_scheduled_stop_point: Array<{
    __typename?: 'service_pattern_scheduled_stop_point';
    measured_location: GeoJSON.Point;
    relative_distance_from_infrastructure_link_start: number;
    closest_point_on_infrastructure_link?: GeoJSON.Point | null;
    priority: number;
    direction: InfrastructureNetworkDirectionEnum;
    scheduled_stop_point_id: UUID;
    label: string;
    timing_place_id?: UUID | null;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    located_on_infrastructure_link_id: UUID;
    vehicle_mode_on_scheduled_stop_point: Array<{
      __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point';
      vehicle_mode: ReusableComponentsVehicleModeEnum;
    }>;
    timing_place?: {
      __typename?: 'timing_pattern_timing_place';
      timing_place_id: UUID;
      label: string;
    } | null;
  }>;
};

export type ScheduledStopPointInJourneyPatternAllFieldsFragment = {
  __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
  journey_pattern_id: UUID;
  scheduled_stop_point_label: string;
  scheduled_stop_point_sequence: number;
  is_used_as_timing_point: boolean;
  is_regulated_timing_point: boolean;
  is_loading_time_allowed: boolean;
  is_via_point: boolean;
  via_point_name_i18n?: LocalizedString | null;
  via_point_short_name_i18n?: LocalizedString | null;
  journey_pattern: {
    __typename?: 'journey_pattern_journey_pattern';
    journey_pattern_id: UUID;
    on_route_id: UUID;
  };
};

export type JourneyPatternWithStopsFragment = {
  __typename?: 'journey_pattern_journey_pattern';
  journey_pattern_id: UUID;
  on_route_id: UUID;
  ordered_scheduled_stop_point_in_journey_patterns: Array<{
    __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
    journey_pattern_id: UUID;
    scheduled_stop_point_label: string;
    scheduled_stop_point_sequence: number;
    is_used_as_timing_point: boolean;
    is_regulated_timing_point: boolean;
    is_loading_time_allowed: boolean;
    is_via_point: boolean;
    via_point_name_i18n?: LocalizedString | null;
    via_point_short_name_i18n?: LocalizedString | null;
    scheduled_stop_points: Array<{
      __typename?: 'service_pattern_scheduled_stop_point';
      priority: number;
      direction: InfrastructureNetworkDirectionEnum;
      scheduled_stop_point_id: UUID;
      label: string;
      timing_place_id?: UUID | null;
      validity_start?: luxon.DateTime | null;
      validity_end?: luxon.DateTime | null;
      located_on_infrastructure_link_id: UUID;
      timing_place?: {
        __typename?: 'timing_pattern_timing_place';
        timing_place_id: UUID;
        label: string;
      } | null;
    }>;
    journey_pattern: {
      __typename?: 'journey_pattern_journey_pattern';
      journey_pattern_id: UUID;
      on_route_id: UUID;
    };
  }>;
};

export type PatchScheduledStopPointViaInfoMutationVariables = Exact<{
  stopLabel: Scalars['String'];
  journeyPatternId: Scalars['uuid'];
  patch: JourneyPatternScheduledStopPointInJourneyPatternSetInput;
}>;

export type PatchScheduledStopPointViaInfoMutation = {
  __typename?: 'mutation_root';
  update_journey_pattern_scheduled_stop_point_in_journey_pattern?: {
    __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_mutation_response';
    returning: Array<{
      __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
      journey_pattern_id: UUID;
      scheduled_stop_point_label: string;
      scheduled_stop_point_sequence: number;
      is_used_as_timing_point: boolean;
      is_regulated_timing_point: boolean;
      is_loading_time_allowed: boolean;
      is_via_point: boolean;
      via_point_name_i18n?: LocalizedString | null;
      via_point_short_name_i18n?: LocalizedString | null;
      journey_pattern: {
        __typename?: 'journey_pattern_journey_pattern';
        journey_pattern_id: UUID;
        on_route_id: UUID;
      };
    }>;
  } | null;
};

export type RemoveScheduledStopPointViaInfoMutationVariables = Exact<{
  stopLabel: Scalars['String'];
  journeyPatternId: Scalars['uuid'];
}>;

export type RemoveScheduledStopPointViaInfoMutation = {
  __typename?: 'mutation_root';
  update_journey_pattern_scheduled_stop_point_in_journey_pattern?: {
    __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_mutation_response';
    returning: Array<{
      __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
      journey_pattern_id: UUID;
      scheduled_stop_point_label: string;
      scheduled_stop_point_sequence: number;
      is_used_as_timing_point: boolean;
      is_regulated_timing_point: boolean;
      is_loading_time_allowed: boolean;
      is_via_point: boolean;
      via_point_name_i18n?: LocalizedString | null;
      via_point_short_name_i18n?: LocalizedString | null;
      journey_pattern: {
        __typename?: 'journey_pattern_journey_pattern';
        journey_pattern_id: UUID;
        on_route_id: UUID;
      };
    }>;
  } | null;
};

export type GetScheduledStopPointWithViaInfoQueryVariables = Exact<{
  journeyPatternId: Scalars['uuid'];
  stopLabel: Scalars['String'];
}>;

export type GetScheduledStopPointWithViaInfoQuery = {
  __typename?: 'query_root';
  journey_pattern_scheduled_stop_point_in_journey_pattern: Array<{
    __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
    journey_pattern_id: UUID;
    scheduled_stop_point_label: string;
    scheduled_stop_point_sequence: number;
    is_used_as_timing_point: boolean;
    is_regulated_timing_point: boolean;
    is_loading_time_allowed: boolean;
    is_via_point: boolean;
    via_point_name_i18n?: LocalizedString | null;
    via_point_short_name_i18n?: LocalizedString | null;
    journey_pattern: {
      __typename?: 'journey_pattern_journey_pattern';
      journey_pattern_id: UUID;
      on_route_id: UUID;
      journey_pattern_route?: {
        __typename?: 'route_route';
        route_id: UUID;
        label: string;
      } | null;
    };
  }>;
};

export type LineDefaultFieldsFragment = {
  __typename?: 'route_line';
  line_id: UUID;
  label: string;
  name_i18n: LocalizedString;
  short_name_i18n: LocalizedString;
  validity_start?: luxon.DateTime | null;
  validity_end?: luxon.DateTime | null;
  priority: number;
};

export type LineAllFieldsFragment = {
  __typename?: 'route_line';
  primary_vehicle_mode: ReusableComponentsVehicleModeEnum;
  type_of_line: RouteTypeOfLineEnum;
  transport_target: HslRouteTransportTargetEnum;
  line_id: UUID;
  label: string;
  name_i18n: LocalizedString;
  short_name_i18n: LocalizedString;
  validity_start?: luxon.DateTime | null;
  validity_end?: luxon.DateTime | null;
  priority: number;
};

export type RouteValidityFragment = {
  __typename?: 'route_route';
  validity_start?: luxon.DateTime | null;
  validity_end?: luxon.DateTime | null;
  priority: number;
};

export type RouteUniqueFieldsFragment = {
  __typename?: 'route_route';
  label: string;
  direction: RouteDirectionEnum;
  variant?: number | null;
  route_id: UUID;
  validity_start?: luxon.DateTime | null;
  validity_end?: luxon.DateTime | null;
  priority: number;
};

export type RouteAllFieldsFragment = {
  __typename?: 'route_route';
  route_shape?: GeoJSON.LineString | null;
  name_i18n: LocalizedString;
  description_i18n?: LocalizedString | null;
  origin_name_i18n: LocalizedString;
  origin_short_name_i18n: LocalizedString;
  destination_name_i18n: LocalizedString;
  destination_short_name_i18n: LocalizedString;
  on_line_id: UUID;
  label: string;
  direction: RouteDirectionEnum;
  variant?: number | null;
  route_id: UUID;
  validity_start?: luxon.DateTime | null;
  validity_end?: luxon.DateTime | null;
  priority: number;
};

export type RouteDefaultFieldsFragment = {
  __typename?: 'route_route';
  name_i18n: LocalizedString;
  description_i18n?: LocalizedString | null;
  origin_name_i18n: LocalizedString;
  origin_short_name_i18n: LocalizedString;
  destination_name_i18n: LocalizedString;
  destination_short_name_i18n: LocalizedString;
  on_line_id: UUID;
  label: string;
  direction: RouteDirectionEnum;
  variant?: number | null;
  route_id: UUID;
  validity_start?: luxon.DateTime | null;
  validity_end?: luxon.DateTime | null;
  priority: number;
};

export type RouteWithJourneyPatternStopsFragment = {
  __typename?: 'route_route';
  route_shape?: GeoJSON.LineString | null;
  name_i18n: LocalizedString;
  description_i18n?: LocalizedString | null;
  origin_name_i18n: LocalizedString;
  origin_short_name_i18n: LocalizedString;
  destination_name_i18n: LocalizedString;
  destination_short_name_i18n: LocalizedString;
  on_line_id: UUID;
  label: string;
  direction: RouteDirectionEnum;
  variant?: number | null;
  route_id: UUID;
  validity_start?: luxon.DateTime | null;
  validity_end?: luxon.DateTime | null;
  priority: number;
  route_journey_patterns: Array<{
    __typename?: 'journey_pattern_journey_pattern';
    journey_pattern_id: UUID;
    on_route_id: UUID;
    ordered_scheduled_stop_point_in_journey_patterns: Array<{
      __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
      journey_pattern_id: UUID;
      scheduled_stop_point_label: string;
      scheduled_stop_point_sequence: number;
      is_used_as_timing_point: boolean;
      is_regulated_timing_point: boolean;
      is_loading_time_allowed: boolean;
      is_via_point: boolean;
      via_point_name_i18n?: LocalizedString | null;
      via_point_short_name_i18n?: LocalizedString | null;
      scheduled_stop_points: Array<{
        __typename?: 'service_pattern_scheduled_stop_point';
        priority: number;
        direction: InfrastructureNetworkDirectionEnum;
        scheduled_stop_point_id: UUID;
        label: string;
        timing_place_id?: UUID | null;
        validity_start?: luxon.DateTime | null;
        validity_end?: luxon.DateTime | null;
        located_on_infrastructure_link_id: UUID;
        timing_place?: {
          __typename?: 'timing_pattern_timing_place';
          timing_place_id: UUID;
          label: string;
        } | null;
      }>;
      journey_pattern: {
        __typename?: 'journey_pattern_journey_pattern';
        journey_pattern_id: UUID;
        on_route_id: UUID;
      };
    }>;
  }>;
};

export type RouteWithInfrastructureLinksFragment = {
  __typename?: 'route_route';
  route_shape?: GeoJSON.LineString | null;
  name_i18n: LocalizedString;
  description_i18n?: LocalizedString | null;
  origin_name_i18n: LocalizedString;
  origin_short_name_i18n: LocalizedString;
  destination_name_i18n: LocalizedString;
  destination_short_name_i18n: LocalizedString;
  on_line_id: UUID;
  label: string;
  direction: RouteDirectionEnum;
  variant?: number | null;
  route_id: UUID;
  validity_start?: luxon.DateTime | null;
  validity_end?: luxon.DateTime | null;
  priority: number;
  route_line: {
    __typename?: 'route_line';
    primary_vehicle_mode: ReusableComponentsVehicleModeEnum;
    type_of_line: RouteTypeOfLineEnum;
    transport_target: HslRouteTransportTargetEnum;
    line_id: UUID;
    label: string;
    name_i18n: LocalizedString;
    short_name_i18n: LocalizedString;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    priority: number;
  };
  infrastructure_links_along_route: Array<{
    __typename?: 'route_infrastructure_link_along_route';
    route_id: UUID;
    infrastructure_link_sequence: number;
    infrastructure_link_id: UUID;
    is_traversal_forwards: boolean;
    infrastructure_link: {
      __typename?: 'infrastructure_network_infrastructure_link';
      infrastructure_link_id: UUID;
      shape: GeoJSON.LineString;
      direction: InfrastructureNetworkDirectionEnum;
      external_link_id: string;
      external_link_source: InfrastructureNetworkExternalSourceEnum;
    };
  }>;
};

export type GetLineDetailsByIdQueryVariables = Exact<{
  line_id: Scalars['uuid'];
}>;

export type GetLineDetailsByIdQuery = {
  __typename?: 'query_root';
  route_line_by_pk?: {
    __typename?: 'route_line';
    primary_vehicle_mode: ReusableComponentsVehicleModeEnum;
    type_of_line: RouteTypeOfLineEnum;
    transport_target: HslRouteTransportTargetEnum;
    line_id: UUID;
    label: string;
    name_i18n: LocalizedString;
    short_name_i18n: LocalizedString;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    priority: number;
  } | null;
};

export type GetLineValidityPeriodByIdQueryVariables = Exact<{
  line_id: Scalars['uuid'];
}>;

export type GetLineValidityPeriodByIdQuery = {
  __typename?: 'query_root';
  route_line_by_pk?: {
    __typename?: 'route_line';
    line_id: UUID;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
  } | null;
};

export type GetLinesByValidityQueryVariables = Exact<{
  filter?: InputMaybe<RouteLineBoolExp>;
}>;

export type GetLinesByValidityQuery = {
  __typename?: 'query_root';
  route_line: Array<{
    __typename?: 'route_line';
    primary_vehicle_mode: ReusableComponentsVehicleModeEnum;
    type_of_line: RouteTypeOfLineEnum;
    transport_target: HslRouteTransportTargetEnum;
    line_id: UUID;
    label: string;
    name_i18n: LocalizedString;
    short_name_i18n: LocalizedString;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    priority: number;
  }>;
};

export type GetLineDetailsWithRoutesByIdQueryVariables = Exact<{
  line_id: Scalars['uuid'];
}>;

export type GetLineDetailsWithRoutesByIdQuery = {
  __typename?: 'query_root';
  route_line_by_pk?: {
    __typename?: 'route_line';
    primary_vehicle_mode: ReusableComponentsVehicleModeEnum;
    type_of_line: RouteTypeOfLineEnum;
    transport_target: HslRouteTransportTargetEnum;
    line_id: UUID;
    label: string;
    name_i18n: LocalizedString;
    short_name_i18n: LocalizedString;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    priority: number;
    line_routes: Array<{
      __typename?: 'route_route';
      route_shape?: GeoJSON.LineString | null;
      name_i18n: LocalizedString;
      description_i18n?: LocalizedString | null;
      origin_name_i18n: LocalizedString;
      origin_short_name_i18n: LocalizedString;
      destination_name_i18n: LocalizedString;
      destination_short_name_i18n: LocalizedString;
      on_line_id: UUID;
      label: string;
      direction: RouteDirectionEnum;
      variant?: number | null;
      route_id: UUID;
      validity_start?: luxon.DateTime | null;
      validity_end?: luxon.DateTime | null;
      priority: number;
      infrastructure_links_along_route: Array<{
        __typename?: 'route_infrastructure_link_along_route';
        route_id: UUID;
        infrastructure_link_id: UUID;
        infrastructure_link_sequence: number;
        is_traversal_forwards: boolean;
        infrastructure_link: {
          __typename?: 'infrastructure_network_infrastructure_link';
          infrastructure_link_id: UUID;
          scheduled_stop_points_located_on_infrastructure_link: Array<{
            __typename?: 'service_pattern_scheduled_stop_point';
            measured_location: GeoJSON.Point;
            relative_distance_from_infrastructure_link_start: number;
            closest_point_on_infrastructure_link?: GeoJSON.Point | null;
            priority: number;
            direction: InfrastructureNetworkDirectionEnum;
            scheduled_stop_point_id: UUID;
            label: string;
            timing_place_id?: UUID | null;
            validity_start?: luxon.DateTime | null;
            validity_end?: luxon.DateTime | null;
            located_on_infrastructure_link_id: UUID;
            scheduled_stop_point_in_journey_patterns: Array<{
              __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
              journey_pattern_id: UUID;
              scheduled_stop_point_label: string;
              scheduled_stop_point_sequence: number;
              is_used_as_timing_point: boolean;
              is_regulated_timing_point: boolean;
              is_loading_time_allowed: boolean;
              is_via_point: boolean;
              via_point_name_i18n?: LocalizedString | null;
              via_point_short_name_i18n?: LocalizedString | null;
              journey_pattern: {
                __typename?: 'journey_pattern_journey_pattern';
                journey_pattern_id: UUID;
                on_route_id: UUID;
              };
            }>;
            other_label_instances: Array<{
              __typename?: 'service_pattern_scheduled_stop_point';
              priority: number;
              direction: InfrastructureNetworkDirectionEnum;
              scheduled_stop_point_id: UUID;
              label: string;
              timing_place_id?: UUID | null;
              validity_start?: luxon.DateTime | null;
              validity_end?: luxon.DateTime | null;
              located_on_infrastructure_link_id: UUID;
              timing_place?: {
                __typename?: 'timing_pattern_timing_place';
                timing_place_id: UUID;
                label: string;
              } | null;
            }>;
            vehicle_mode_on_scheduled_stop_point: Array<{
              __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point';
              vehicle_mode: ReusableComponentsVehicleModeEnum;
            }>;
            timing_place?: {
              __typename?: 'timing_pattern_timing_place';
              timing_place_id: UUID;
              label: string;
            } | null;
          }>;
        };
      }>;
    }>;
  } | null;
};

export type GetRoutesWithStopsQueryVariables = Exact<{
  routeFilters?: InputMaybe<RouteRouteBoolExp>;
}>;

export type GetRoutesWithStopsQuery = {
  __typename?: 'query_root';
  route_route: Array<{
    __typename?: 'route_route';
    route_shape?: GeoJSON.LineString | null;
    name_i18n: LocalizedString;
    description_i18n?: LocalizedString | null;
    origin_name_i18n: LocalizedString;
    origin_short_name_i18n: LocalizedString;
    destination_name_i18n: LocalizedString;
    destination_short_name_i18n: LocalizedString;
    on_line_id: UUID;
    label: string;
    direction: RouteDirectionEnum;
    variant?: number | null;
    route_id: UUID;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    priority: number;
    route_line: {
      __typename?: 'route_line';
      primary_vehicle_mode: ReusableComponentsVehicleModeEnum;
      type_of_line: RouteTypeOfLineEnum;
      transport_target: HslRouteTransportTargetEnum;
      line_id: UUID;
      label: string;
      name_i18n: LocalizedString;
      short_name_i18n: LocalizedString;
      validity_start?: luxon.DateTime | null;
      validity_end?: luxon.DateTime | null;
      priority: number;
    };
    infrastructure_links_along_route: Array<{
      __typename?: 'route_infrastructure_link_along_route';
      route_id: UUID;
      infrastructure_link_sequence: number;
      infrastructure_link_id: UUID;
      is_traversal_forwards: boolean;
      infrastructure_link: {
        __typename?: 'infrastructure_network_infrastructure_link';
        external_link_source: InfrastructureNetworkExternalSourceEnum;
        external_link_id: string;
        infrastructure_link_id: UUID;
        shape: GeoJSON.LineString;
        direction: InfrastructureNetworkDirectionEnum;
        scheduled_stop_points_located_on_infrastructure_link: Array<{
          __typename?: 'service_pattern_scheduled_stop_point';
          measured_location: GeoJSON.Point;
          relative_distance_from_infrastructure_link_start: number;
          closest_point_on_infrastructure_link?: GeoJSON.Point | null;
          priority: number;
          direction: InfrastructureNetworkDirectionEnum;
          scheduled_stop_point_id: UUID;
          label: string;
          timing_place_id?: UUID | null;
          validity_start?: luxon.DateTime | null;
          validity_end?: luxon.DateTime | null;
          located_on_infrastructure_link_id: UUID;
          other_label_instances: Array<{
            __typename?: 'service_pattern_scheduled_stop_point';
            priority: number;
            direction: InfrastructureNetworkDirectionEnum;
            scheduled_stop_point_id: UUID;
            label: string;
            timing_place_id?: UUID | null;
            validity_start?: luxon.DateTime | null;
            validity_end?: luxon.DateTime | null;
            located_on_infrastructure_link_id: UUID;
            timing_place?: {
              __typename?: 'timing_pattern_timing_place';
              timing_place_id: UUID;
              label: string;
            } | null;
          }>;
          scheduled_stop_point_in_journey_patterns: Array<{
            __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
            journey_pattern_id: UUID;
            scheduled_stop_point_label: string;
            scheduled_stop_point_sequence: number;
            is_used_as_timing_point: boolean;
            is_regulated_timing_point: boolean;
            is_loading_time_allowed: boolean;
            is_via_point: boolean;
            via_point_name_i18n?: LocalizedString | null;
            via_point_short_name_i18n?: LocalizedString | null;
            journey_pattern: {
              __typename?: 'journey_pattern_journey_pattern';
              journey_pattern_id: UUID;
              on_route_id: UUID;
            };
          }>;
          vehicle_mode_on_scheduled_stop_point: Array<{
            __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point';
            vehicle_mode: ReusableComponentsVehicleModeEnum;
          }>;
          timing_place?: {
            __typename?: 'timing_pattern_timing_place';
            timing_place_id: UUID;
            label: string;
          } | null;
        }>;
      };
    }>;
    route_journey_patterns: Array<{
      __typename?: 'journey_pattern_journey_pattern';
      journey_pattern_id: UUID;
      on_route_id: UUID;
      ordered_scheduled_stop_point_in_journey_patterns: Array<{
        __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
        journey_pattern_id: UUID;
        scheduled_stop_point_label: string;
        scheduled_stop_point_sequence: number;
        is_used_as_timing_point: boolean;
        is_regulated_timing_point: boolean;
        is_loading_time_allowed: boolean;
        is_via_point: boolean;
        via_point_name_i18n?: LocalizedString | null;
        via_point_short_name_i18n?: LocalizedString | null;
        scheduled_stop_points: Array<{
          __typename?: 'service_pattern_scheduled_stop_point';
          priority: number;
          direction: InfrastructureNetworkDirectionEnum;
          scheduled_stop_point_id: UUID;
          label: string;
          timing_place_id?: UUID | null;
          validity_start?: luxon.DateTime | null;
          validity_end?: luxon.DateTime | null;
          located_on_infrastructure_link_id: UUID;
          timing_place?: {
            __typename?: 'timing_pattern_timing_place';
            timing_place_id: UUID;
            label: string;
          } | null;
        }>;
        journey_pattern: {
          __typename?: 'journey_pattern_journey_pattern';
          journey_pattern_id: UUID;
          on_route_id: UUID;
        };
      }>;
    }>;
  }>;
};

export type GetRouteDetailsByIdQueryVariables = Exact<{
  routeId: Scalars['uuid'];
}>;

export type GetRouteDetailsByIdQuery = {
  __typename?: 'query_root';
  route_route_by_pk?: {
    __typename?: 'route_route';
    route_shape?: GeoJSON.LineString | null;
    name_i18n: LocalizedString;
    description_i18n?: LocalizedString | null;
    origin_name_i18n: LocalizedString;
    origin_short_name_i18n: LocalizedString;
    destination_name_i18n: LocalizedString;
    destination_short_name_i18n: LocalizedString;
    on_line_id: UUID;
    label: string;
    direction: RouteDirectionEnum;
    variant?: number | null;
    route_id: UUID;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    priority: number;
    route_line: {
      __typename?: 'route_line';
      primary_vehicle_mode: ReusableComponentsVehicleModeEnum;
      type_of_line: RouteTypeOfLineEnum;
      transport_target: HslRouteTransportTargetEnum;
      line_id: UUID;
      label: string;
      name_i18n: LocalizedString;
      short_name_i18n: LocalizedString;
      validity_start?: luxon.DateTime | null;
      validity_end?: luxon.DateTime | null;
      priority: number;
    };
    infrastructure_links_along_route: Array<{
      __typename?: 'route_infrastructure_link_along_route';
      route_id: UUID;
      infrastructure_link_sequence: number;
      infrastructure_link_id: UUID;
      is_traversal_forwards: boolean;
      infrastructure_link: {
        __typename?: 'infrastructure_network_infrastructure_link';
        external_link_source: InfrastructureNetworkExternalSourceEnum;
        external_link_id: string;
        infrastructure_link_id: UUID;
        shape: GeoJSON.LineString;
        direction: InfrastructureNetworkDirectionEnum;
        scheduled_stop_points_located_on_infrastructure_link: Array<{
          __typename?: 'service_pattern_scheduled_stop_point';
          measured_location: GeoJSON.Point;
          relative_distance_from_infrastructure_link_start: number;
          closest_point_on_infrastructure_link?: GeoJSON.Point | null;
          priority: number;
          direction: InfrastructureNetworkDirectionEnum;
          scheduled_stop_point_id: UUID;
          label: string;
          timing_place_id?: UUID | null;
          validity_start?: luxon.DateTime | null;
          validity_end?: luxon.DateTime | null;
          located_on_infrastructure_link_id: UUID;
          other_label_instances: Array<{
            __typename?: 'service_pattern_scheduled_stop_point';
            priority: number;
            direction: InfrastructureNetworkDirectionEnum;
            scheduled_stop_point_id: UUID;
            label: string;
            timing_place_id?: UUID | null;
            validity_start?: luxon.DateTime | null;
            validity_end?: luxon.DateTime | null;
            located_on_infrastructure_link_id: UUID;
            timing_place?: {
              __typename?: 'timing_pattern_timing_place';
              timing_place_id: UUID;
              label: string;
            } | null;
          }>;
          scheduled_stop_point_in_journey_patterns: Array<{
            __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
            journey_pattern_id: UUID;
            scheduled_stop_point_label: string;
            scheduled_stop_point_sequence: number;
            is_used_as_timing_point: boolean;
            is_regulated_timing_point: boolean;
            is_loading_time_allowed: boolean;
            is_via_point: boolean;
            via_point_name_i18n?: LocalizedString | null;
            via_point_short_name_i18n?: LocalizedString | null;
            journey_pattern: {
              __typename?: 'journey_pattern_journey_pattern';
              journey_pattern_id: UUID;
              on_route_id: UUID;
            };
          }>;
          vehicle_mode_on_scheduled_stop_point: Array<{
            __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point';
            vehicle_mode: ReusableComponentsVehicleModeEnum;
          }>;
          timing_place?: {
            __typename?: 'timing_pattern_timing_place';
            timing_place_id: UUID;
            label: string;
          } | null;
        }>;
      };
    }>;
    route_journey_patterns: Array<{
      __typename?: 'journey_pattern_journey_pattern';
      journey_pattern_id: UUID;
      on_route_id: UUID;
      ordered_scheduled_stop_point_in_journey_patterns: Array<{
        __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
        journey_pattern_id: UUID;
        scheduled_stop_point_label: string;
        scheduled_stop_point_sequence: number;
        is_used_as_timing_point: boolean;
        is_regulated_timing_point: boolean;
        is_loading_time_allowed: boolean;
        is_via_point: boolean;
        via_point_name_i18n?: LocalizedString | null;
        via_point_short_name_i18n?: LocalizedString | null;
        scheduled_stop_points: Array<{
          __typename?: 'service_pattern_scheduled_stop_point';
          priority: number;
          direction: InfrastructureNetworkDirectionEnum;
          scheduled_stop_point_id: UUID;
          label: string;
          timing_place_id?: UUID | null;
          validity_start?: luxon.DateTime | null;
          validity_end?: luxon.DateTime | null;
          located_on_infrastructure_link_id: UUID;
          timing_place?: {
            __typename?: 'timing_pattern_timing_place';
            timing_place_id: UUID;
            label: string;
          } | null;
        }>;
        journey_pattern: {
          __typename?: 'journey_pattern_journey_pattern';
          journey_pattern_id: UUID;
          on_route_id: UUID;
        };
      }>;
    }>;
  } | null;
};

export type GetRouteDetailsByIdsQueryVariables = Exact<{
  route_ids?: InputMaybe<Array<Scalars['uuid']> | Scalars['uuid']>;
}>;

export type GetRouteDetailsByIdsQuery = {
  __typename?: 'query_root';
  route_route: Array<{
    __typename?: 'route_route';
    route_shape?: GeoJSON.LineString | null;
    name_i18n: LocalizedString;
    description_i18n?: LocalizedString | null;
    origin_name_i18n: LocalizedString;
    origin_short_name_i18n: LocalizedString;
    destination_name_i18n: LocalizedString;
    destination_short_name_i18n: LocalizedString;
    on_line_id: UUID;
    label: string;
    direction: RouteDirectionEnum;
    variant?: number | null;
    route_id: UUID;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    priority: number;
    route_line: {
      __typename?: 'route_line';
      primary_vehicle_mode: ReusableComponentsVehicleModeEnum;
      type_of_line: RouteTypeOfLineEnum;
      transport_target: HslRouteTransportTargetEnum;
      line_id: UUID;
      label: string;
      name_i18n: LocalizedString;
      short_name_i18n: LocalizedString;
      validity_start?: luxon.DateTime | null;
      validity_end?: luxon.DateTime | null;
      priority: number;
    };
    infrastructure_links_along_route: Array<{
      __typename?: 'route_infrastructure_link_along_route';
      route_id: UUID;
      infrastructure_link_sequence: number;
      infrastructure_link_id: UUID;
      is_traversal_forwards: boolean;
      infrastructure_link: {
        __typename?: 'infrastructure_network_infrastructure_link';
        external_link_source: InfrastructureNetworkExternalSourceEnum;
        external_link_id: string;
        infrastructure_link_id: UUID;
        shape: GeoJSON.LineString;
        direction: InfrastructureNetworkDirectionEnum;
        scheduled_stop_points_located_on_infrastructure_link: Array<{
          __typename?: 'service_pattern_scheduled_stop_point';
          measured_location: GeoJSON.Point;
          relative_distance_from_infrastructure_link_start: number;
          closest_point_on_infrastructure_link?: GeoJSON.Point | null;
          priority: number;
          direction: InfrastructureNetworkDirectionEnum;
          scheduled_stop_point_id: UUID;
          label: string;
          timing_place_id?: UUID | null;
          validity_start?: luxon.DateTime | null;
          validity_end?: luxon.DateTime | null;
          located_on_infrastructure_link_id: UUID;
          other_label_instances: Array<{
            __typename?: 'service_pattern_scheduled_stop_point';
            priority: number;
            direction: InfrastructureNetworkDirectionEnum;
            scheduled_stop_point_id: UUID;
            label: string;
            timing_place_id?: UUID | null;
            validity_start?: luxon.DateTime | null;
            validity_end?: luxon.DateTime | null;
            located_on_infrastructure_link_id: UUID;
            timing_place?: {
              __typename?: 'timing_pattern_timing_place';
              timing_place_id: UUID;
              label: string;
            } | null;
          }>;
          scheduled_stop_point_in_journey_patterns: Array<{
            __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
            journey_pattern_id: UUID;
            scheduled_stop_point_label: string;
            scheduled_stop_point_sequence: number;
            is_used_as_timing_point: boolean;
            is_regulated_timing_point: boolean;
            is_loading_time_allowed: boolean;
            is_via_point: boolean;
            via_point_name_i18n?: LocalizedString | null;
            via_point_short_name_i18n?: LocalizedString | null;
            journey_pattern: {
              __typename?: 'journey_pattern_journey_pattern';
              journey_pattern_id: UUID;
              on_route_id: UUID;
            };
          }>;
          vehicle_mode_on_scheduled_stop_point: Array<{
            __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point';
            vehicle_mode: ReusableComponentsVehicleModeEnum;
          }>;
          timing_place?: {
            __typename?: 'timing_pattern_timing_place';
            timing_place_id: UUID;
            label: string;
          } | null;
        }>;
      };
    }>;
    route_journey_patterns: Array<{
      __typename?: 'journey_pattern_journey_pattern';
      journey_pattern_id: UUID;
      on_route_id: UUID;
      ordered_scheduled_stop_point_in_journey_patterns: Array<{
        __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
        journey_pattern_id: UUID;
        scheduled_stop_point_label: string;
        scheduled_stop_point_sequence: number;
        is_used_as_timing_point: boolean;
        is_regulated_timing_point: boolean;
        is_loading_time_allowed: boolean;
        is_via_point: boolean;
        via_point_name_i18n?: LocalizedString | null;
        via_point_short_name_i18n?: LocalizedString | null;
        scheduled_stop_points: Array<{
          __typename?: 'service_pattern_scheduled_stop_point';
          priority: number;
          direction: InfrastructureNetworkDirectionEnum;
          scheduled_stop_point_id: UUID;
          label: string;
          timing_place_id?: UUID | null;
          validity_start?: luxon.DateTime | null;
          validity_end?: luxon.DateTime | null;
          located_on_infrastructure_link_id: UUID;
          timing_place?: {
            __typename?: 'timing_pattern_timing_place';
            timing_place_id: UUID;
            label: string;
          } | null;
        }>;
        journey_pattern: {
          __typename?: 'journey_pattern_journey_pattern';
          journey_pattern_id: UUID;
          on_route_id: UUID;
        };
      }>;
    }>;
  }>;
};

export type GetRouteRenderInfoByIdQueryVariables = Exact<{
  routeId: Scalars['uuid'];
}>;

export type GetRouteRenderInfoByIdQuery = {
  __typename?: 'query_root';
  route_route_by_pk?: {
    __typename?: 'route_route';
    route_id: UUID;
    route_shape?: GeoJSON.LineString | null;
    route_line: {
      __typename?: 'route_line';
      line_id: UUID;
      primary_vehicle_mode: ReusableComponentsVehicleModeEnum;
    };
  } | null;
};

export type GetRouteDetailsByLabelsQueryVariables = Exact<{
  labels?: InputMaybe<Array<Scalars['String']> | Scalars['String']>;
  date?: InputMaybe<Scalars['date']>;
}>;

export type GetRouteDetailsByLabelsQuery = {
  __typename?: 'query_root';
  route_route: Array<{
    __typename?: 'route_route';
    route_shape?: GeoJSON.LineString | null;
    name_i18n: LocalizedString;
    description_i18n?: LocalizedString | null;
    origin_name_i18n: LocalizedString;
    origin_short_name_i18n: LocalizedString;
    destination_name_i18n: LocalizedString;
    destination_short_name_i18n: LocalizedString;
    on_line_id: UUID;
    label: string;
    direction: RouteDirectionEnum;
    variant?: number | null;
    route_id: UUID;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    priority: number;
    route_line: {
      __typename?: 'route_line';
      line_id: UUID;
      label: string;
      primary_vehicle_mode: ReusableComponentsVehicleModeEnum;
    };
    route_journey_patterns: Array<{
      __typename?: 'journey_pattern_journey_pattern';
      journey_pattern_id: UUID;
      on_route_id: UUID;
      ordered_scheduled_stop_point_in_journey_patterns: Array<{
        __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
        journey_pattern_id: UUID;
        scheduled_stop_point_label: string;
        scheduled_stop_point_sequence: number;
        is_used_as_timing_point: boolean;
        is_regulated_timing_point: boolean;
        is_loading_time_allowed: boolean;
        is_via_point: boolean;
        via_point_name_i18n?: LocalizedString | null;
        via_point_short_name_i18n?: LocalizedString | null;
        scheduled_stop_points: Array<{
          __typename?: 'service_pattern_scheduled_stop_point';
          priority: number;
          direction: InfrastructureNetworkDirectionEnum;
          scheduled_stop_point_id: UUID;
          label: string;
          timing_place_id?: UUID | null;
          validity_start?: luxon.DateTime | null;
          validity_end?: luxon.DateTime | null;
          located_on_infrastructure_link_id: UUID;
          timing_place?: {
            __typename?: 'timing_pattern_timing_place';
            timing_place_id: UUID;
            label: string;
          } | null;
        }>;
        journey_pattern: {
          __typename?: 'journey_pattern_journey_pattern';
          journey_pattern_id: UUID;
          on_route_id: UUID;
        };
      }>;
    }>;
  }>;
};

export type GetRoutesWithInfrastructureLinksQueryVariables = Exact<{
  route_ids?: InputMaybe<Array<Scalars['uuid']> | Scalars['uuid']>;
}>;

export type GetRoutesWithInfrastructureLinksQuery = {
  __typename?: 'query_root';
  route_route: Array<{
    __typename?: 'route_route';
    route_shape?: GeoJSON.LineString | null;
    name_i18n: LocalizedString;
    description_i18n?: LocalizedString | null;
    origin_name_i18n: LocalizedString;
    origin_short_name_i18n: LocalizedString;
    destination_name_i18n: LocalizedString;
    destination_short_name_i18n: LocalizedString;
    on_line_id: UUID;
    label: string;
    direction: RouteDirectionEnum;
    variant?: number | null;
    route_id: UUID;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    priority: number;
    route_line: {
      __typename?: 'route_line';
      primary_vehicle_mode: ReusableComponentsVehicleModeEnum;
      type_of_line: RouteTypeOfLineEnum;
      transport_target: HslRouteTransportTargetEnum;
      line_id: UUID;
      label: string;
      name_i18n: LocalizedString;
      short_name_i18n: LocalizedString;
      validity_start?: luxon.DateTime | null;
      validity_end?: luxon.DateTime | null;
      priority: number;
    };
    infrastructure_links_along_route: Array<{
      __typename?: 'route_infrastructure_link_along_route';
      route_id: UUID;
      infrastructure_link_sequence: number;
      infrastructure_link_id: UUID;
      is_traversal_forwards: boolean;
      infrastructure_link: {
        __typename?: 'infrastructure_network_infrastructure_link';
        infrastructure_link_id: UUID;
        shape: GeoJSON.LineString;
        direction: InfrastructureNetworkDirectionEnum;
        external_link_id: string;
        external_link_source: InfrastructureNetworkExternalSourceEnum;
      };
    }>;
  }>;
};

export type GetRoutesByValidityQueryVariables = Exact<{
  filter?: InputMaybe<RouteRouteBoolExp>;
}>;

export type GetRoutesByValidityQuery = {
  __typename?: 'query_root';
  route_route: Array<{
    __typename?: 'route_route';
    name_i18n: LocalizedString;
    description_i18n?: LocalizedString | null;
    origin_name_i18n: LocalizedString;
    origin_short_name_i18n: LocalizedString;
    destination_name_i18n: LocalizedString;
    destination_short_name_i18n: LocalizedString;
    on_line_id: UUID;
    label: string;
    direction: RouteDirectionEnum;
    variant?: number | null;
    route_id: UUID;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    priority: number;
  }>;
};

export type InsertLineOneMutationVariables = Exact<{
  object: RouteLineInsertInput;
}>;

export type InsertLineOneMutation = {
  __typename?: 'mutation_root';
  insert_route_line_one?: {
    __typename?: 'route_line';
    line_id: UUID;
    label: string;
    priority: number;
    primary_vehicle_mode: ReusableComponentsVehicleModeEnum;
    transport_target: HslRouteTransportTargetEnum;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
  } | null;
};

export type PatchLineMutationVariables = Exact<{
  line_id: Scalars['uuid'];
  object: RouteLineSetInput;
}>;

export type PatchLineMutation = {
  __typename?: 'mutation_root';
  update_route_line_by_pk?: {
    __typename?: 'route_line';
    primary_vehicle_mode: ReusableComponentsVehicleModeEnum;
    type_of_line: RouteTypeOfLineEnum;
    transport_target: HslRouteTransportTargetEnum;
    line_id: UUID;
    label: string;
    name_i18n: LocalizedString;
    short_name_i18n: LocalizedString;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    priority: number;
  } | null;
};

export type InsertRouteOneMutationVariables = Exact<{
  object: RouteRouteInsertInput;
}>;

export type InsertRouteOneMutation = {
  __typename?: 'mutation_root';
  insert_route_route_one?: {
    __typename?: 'route_route';
    route_shape?: GeoJSON.LineString | null;
    name_i18n: LocalizedString;
    description_i18n?: LocalizedString | null;
    origin_name_i18n: LocalizedString;
    origin_short_name_i18n: LocalizedString;
    destination_name_i18n: LocalizedString;
    destination_short_name_i18n: LocalizedString;
    on_line_id: UUID;
    label: string;
    direction: RouteDirectionEnum;
    variant?: number | null;
    route_id: UUID;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    priority: number;
  } | null;
};

export type PatchRouteMutationVariables = Exact<{
  route_id: Scalars['uuid'];
  object: RouteRouteSetInput;
}>;

export type PatchRouteMutation = {
  __typename?: 'mutation_root';
  update_route_route?: {
    __typename?: 'route_route_mutation_response';
    returning: Array<{
      __typename?: 'route_route';
      route_shape?: GeoJSON.LineString | null;
      name_i18n: LocalizedString;
      description_i18n?: LocalizedString | null;
      origin_name_i18n: LocalizedString;
      origin_short_name_i18n: LocalizedString;
      destination_name_i18n: LocalizedString;
      destination_short_name_i18n: LocalizedString;
      on_line_id: UUID;
      label: string;
      direction: RouteDirectionEnum;
      variant?: number | null;
      route_id: UUID;
      validity_start?: luxon.DateTime | null;
      validity_end?: luxon.DateTime | null;
      priority: number;
    }>;
  } | null;
};

export type DeleteRouteMutationVariables = Exact<{
  route_id: Scalars['uuid'];
}>;

export type DeleteRouteMutation = {
  __typename?: 'mutation_root';
  delete_route_route?: {
    __typename?: 'route_route_mutation_response';
    returning: Array<{ __typename?: 'route_route'; route_id: UUID }>;
  } | null;
};

export type GetScheduledStopsOnRouteQueryVariables = Exact<{
  routeId: Scalars['uuid'];
}>;

export type GetScheduledStopsOnRouteQuery = {
  __typename?: 'query_root';
  journey_pattern_journey_pattern: Array<{
    __typename?: 'journey_pattern_journey_pattern';
    journey_pattern_id: UUID;
    scheduled_stop_point_in_journey_patterns: Array<{
      __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
      journey_pattern_id: UUID;
      scheduled_stop_point_sequence: number;
      scheduled_stop_points: Array<{
        __typename?: 'service_pattern_scheduled_stop_point';
        priority: number;
        direction: InfrastructureNetworkDirectionEnum;
        scheduled_stop_point_id: UUID;
        label: string;
        timing_place_id?: UUID | null;
        validity_start?: luxon.DateTime | null;
        validity_end?: luxon.DateTime | null;
        located_on_infrastructure_link_id: UUID;
        timing_place?: {
          __typename?: 'timing_pattern_timing_place';
          timing_place_id: UUID;
          label: string;
        } | null;
      }>;
    }>;
  }>;
};

export type ScheduledStopPointDefaultFieldsFragment = {
  __typename?: 'service_pattern_scheduled_stop_point';
  priority: number;
  direction: InfrastructureNetworkDirectionEnum;
  scheduled_stop_point_id: UUID;
  label: string;
  timing_place_id?: UUID | null;
  validity_start?: luxon.DateTime | null;
  validity_end?: luxon.DateTime | null;
  located_on_infrastructure_link_id: UUID;
  timing_place?: {
    __typename?: 'timing_pattern_timing_place';
    timing_place_id: UUID;
    label: string;
  } | null;
};

export type ScheduledStopPointAllFieldsFragment = {
  __typename?: 'service_pattern_scheduled_stop_point';
  measured_location: GeoJSON.Point;
  relative_distance_from_infrastructure_link_start: number;
  closest_point_on_infrastructure_link?: GeoJSON.Point | null;
  priority: number;
  direction: InfrastructureNetworkDirectionEnum;
  scheduled_stop_point_id: UUID;
  label: string;
  timing_place_id?: UUID | null;
  validity_start?: luxon.DateTime | null;
  validity_end?: luxon.DateTime | null;
  located_on_infrastructure_link_id: UUID;
  vehicle_mode_on_scheduled_stop_point: Array<{
    __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point';
    vehicle_mode: ReusableComponentsVehicleModeEnum;
  }>;
  timing_place?: {
    __typename?: 'timing_pattern_timing_place';
    timing_place_id: UUID;
    label: string;
  } | null;
};

export type StopWithJourneyPatternFieldsFragment = {
  __typename?: 'service_pattern_scheduled_stop_point';
  measured_location: GeoJSON.Point;
  relative_distance_from_infrastructure_link_start: number;
  closest_point_on_infrastructure_link?: GeoJSON.Point | null;
  priority: number;
  direction: InfrastructureNetworkDirectionEnum;
  scheduled_stop_point_id: UUID;
  label: string;
  timing_place_id?: UUID | null;
  validity_start?: luxon.DateTime | null;
  validity_end?: luxon.DateTime | null;
  located_on_infrastructure_link_id: UUID;
  scheduled_stop_point_in_journey_patterns: Array<{
    __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
    journey_pattern_id: UUID;
    scheduled_stop_point_label: string;
    scheduled_stop_point_sequence: number;
    is_used_as_timing_point: boolean;
    is_regulated_timing_point: boolean;
    is_loading_time_allowed: boolean;
    is_via_point: boolean;
    via_point_name_i18n?: LocalizedString | null;
    via_point_short_name_i18n?: LocalizedString | null;
    journey_pattern: {
      __typename?: 'journey_pattern_journey_pattern';
      journey_pattern_id: UUID;
      on_route_id: UUID;
    };
  }>;
  vehicle_mode_on_scheduled_stop_point: Array<{
    __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point';
    vehicle_mode: ReusableComponentsVehicleModeEnum;
  }>;
  timing_place?: {
    __typename?: 'timing_pattern_timing_place';
    timing_place_id: UUID;
    label: string;
  } | null;
};

export type RouteStopFieldsFragment = {
  __typename?: 'service_pattern_scheduled_stop_point';
  measured_location: GeoJSON.Point;
  relative_distance_from_infrastructure_link_start: number;
  closest_point_on_infrastructure_link?: GeoJSON.Point | null;
  priority: number;
  direction: InfrastructureNetworkDirectionEnum;
  scheduled_stop_point_id: UUID;
  label: string;
  timing_place_id?: UUID | null;
  validity_start?: luxon.DateTime | null;
  validity_end?: luxon.DateTime | null;
  located_on_infrastructure_link_id: UUID;
  other_label_instances: Array<{
    __typename?: 'service_pattern_scheduled_stop_point';
    priority: number;
    direction: InfrastructureNetworkDirectionEnum;
    scheduled_stop_point_id: UUID;
    label: string;
    timing_place_id?: UUID | null;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    located_on_infrastructure_link_id: UUID;
    timing_place?: {
      __typename?: 'timing_pattern_timing_place';
      timing_place_id: UUID;
      label: string;
    } | null;
  }>;
  scheduled_stop_point_in_journey_patterns: Array<{
    __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
    journey_pattern_id: UUID;
    scheduled_stop_point_label: string;
    scheduled_stop_point_sequence: number;
    is_used_as_timing_point: boolean;
    is_regulated_timing_point: boolean;
    is_loading_time_allowed: boolean;
    is_via_point: boolean;
    via_point_name_i18n?: LocalizedString | null;
    via_point_short_name_i18n?: LocalizedString | null;
    journey_pattern: {
      __typename?: 'journey_pattern_journey_pattern';
      journey_pattern_id: UUID;
      on_route_id: UUID;
    };
  }>;
  vehicle_mode_on_scheduled_stop_point: Array<{
    __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point';
    vehicle_mode: ReusableComponentsVehicleModeEnum;
  }>;
  timing_place?: {
    __typename?: 'timing_pattern_timing_place';
    timing_place_id: UUID;
    label: string;
  } | null;
};

export type RemoveStopMutationVariables = Exact<{
  stop_id: Scalars['uuid'];
}>;

export type RemoveStopMutation = {
  __typename?: 'mutation_root';
  delete_service_pattern_scheduled_stop_point?: {
    __typename?: 'service_pattern_scheduled_stop_point_mutation_response';
    returning: Array<{
      __typename?: 'service_pattern_scheduled_stop_point';
      scheduled_stop_point_id: UUID;
    }>;
  } | null;
};

export type GetStopsByLocationQueryVariables = Exact<{
  measured_location_filter?: InputMaybe<GeographyComparisonExp>;
}>;

export type GetStopsByLocationQuery = {
  __typename?: 'query_root';
  service_pattern_scheduled_stop_point: Array<{
    __typename?: 'service_pattern_scheduled_stop_point';
    measured_location: GeoJSON.Point;
    relative_distance_from_infrastructure_link_start: number;
    closest_point_on_infrastructure_link?: GeoJSON.Point | null;
    priority: number;
    direction: InfrastructureNetworkDirectionEnum;
    scheduled_stop_point_id: UUID;
    label: string;
    timing_place_id?: UUID | null;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    located_on_infrastructure_link_id: UUID;
    vehicle_mode_on_scheduled_stop_point: Array<{
      __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point';
      vehicle_mode: ReusableComponentsVehicleModeEnum;
    }>;
    timing_place?: {
      __typename?: 'timing_pattern_timing_place';
      timing_place_id: UUID;
      label: string;
    } | null;
  }>;
};

export type GetStopsByValidityQueryVariables = Exact<{
  filter?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
}>;

export type GetStopsByValidityQuery = {
  __typename?: 'query_root';
  service_pattern_scheduled_stop_point: Array<{
    __typename?: 'service_pattern_scheduled_stop_point';
    measured_location: GeoJSON.Point;
    relative_distance_from_infrastructure_link_start: number;
    closest_point_on_infrastructure_link?: GeoJSON.Point | null;
    priority: number;
    direction: InfrastructureNetworkDirectionEnum;
    scheduled_stop_point_id: UUID;
    label: string;
    timing_place_id?: UUID | null;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    located_on_infrastructure_link_id: UUID;
    vehicle_mode_on_scheduled_stop_point: Array<{
      __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point';
      vehicle_mode: ReusableComponentsVehicleModeEnum;
    }>;
    timing_place?: {
      __typename?: 'timing_pattern_timing_place';
      timing_place_id: UUID;
      label: string;
    } | null;
  }>;
};

export type GetStopsByIdsQueryVariables = Exact<{
  stopIds?: InputMaybe<Array<Scalars['uuid']> | Scalars['uuid']>;
}>;

export type GetStopsByIdsQuery = {
  __typename?: 'query_root';
  service_pattern_scheduled_stop_point: Array<{
    __typename?: 'service_pattern_scheduled_stop_point';
    measured_location: GeoJSON.Point;
    relative_distance_from_infrastructure_link_start: number;
    closest_point_on_infrastructure_link?: GeoJSON.Point | null;
    priority: number;
    direction: InfrastructureNetworkDirectionEnum;
    scheduled_stop_point_id: UUID;
    label: string;
    timing_place_id?: UUID | null;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    located_on_infrastructure_link_id: UUID;
    vehicle_mode_on_scheduled_stop_point: Array<{
      __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point';
      vehicle_mode: ReusableComponentsVehicleModeEnum;
    }>;
    timing_place?: {
      __typename?: 'timing_pattern_timing_place';
      timing_place_id: UUID;
      label: string;
    } | null;
  }>;
};

export type GetStopsByLabelsQueryVariables = Exact<{
  stopLabels?: InputMaybe<Array<Scalars['String']> | Scalars['String']>;
}>;

export type GetStopsByLabelsQuery = {
  __typename?: 'query_root';
  service_pattern_scheduled_stop_point: Array<{
    __typename?: 'service_pattern_scheduled_stop_point';
    measured_location: GeoJSON.Point;
    relative_distance_from_infrastructure_link_start: number;
    closest_point_on_infrastructure_link?: GeoJSON.Point | null;
    priority: number;
    direction: InfrastructureNetworkDirectionEnum;
    scheduled_stop_point_id: UUID;
    label: string;
    timing_place_id?: UUID | null;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    located_on_infrastructure_link_id: UUID;
    vehicle_mode_on_scheduled_stop_point: Array<{
      __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point';
      vehicle_mode: ReusableComponentsVehicleModeEnum;
    }>;
    timing_place?: {
      __typename?: 'timing_pattern_timing_place';
      timing_place_id: UUID;
      label: string;
    } | null;
  }>;
};

export type InsertStopMutationVariables = Exact<{
  object: ServicePatternScheduledStopPointInsertInput;
}>;

export type InsertStopMutation = {
  __typename?: 'mutation_root';
  insert_service_pattern_scheduled_stop_point_one?: {
    __typename?: 'service_pattern_scheduled_stop_point';
    scheduled_stop_point_id: UUID;
    located_on_infrastructure_link_id: UUID;
    direction: InfrastructureNetworkDirectionEnum;
    priority: number;
    measured_location: GeoJSON.Point;
    label: string;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
  } | null;
};

export type EditStopMutationVariables = Exact<{
  stop_id: Scalars['uuid'];
  stop_label: Scalars['String'];
  stop_patch: ServicePatternScheduledStopPointSetInput;
  delete_from_journey_pattern_ids: Array<Scalars['uuid']> | Scalars['uuid'];
}>;

export type EditStopMutation = {
  __typename?: 'mutation_root';
  update_service_pattern_scheduled_stop_point?: {
    __typename?: 'service_pattern_scheduled_stop_point_mutation_response';
    returning: Array<{
      __typename?: 'service_pattern_scheduled_stop_point';
      measured_location: GeoJSON.Point;
      relative_distance_from_infrastructure_link_start: number;
      closest_point_on_infrastructure_link?: GeoJSON.Point | null;
      priority: number;
      direction: InfrastructureNetworkDirectionEnum;
      scheduled_stop_point_id: UUID;
      label: string;
      timing_place_id?: UUID | null;
      validity_start?: luxon.DateTime | null;
      validity_end?: luxon.DateTime | null;
      located_on_infrastructure_link_id: UUID;
      vehicle_mode_on_scheduled_stop_point: Array<{
        __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point';
        vehicle_mode: ReusableComponentsVehicleModeEnum;
      }>;
      timing_place?: {
        __typename?: 'timing_pattern_timing_place';
        timing_place_id: UUID;
        label: string;
      } | null;
    }>;
  } | null;
  delete_journey_pattern_scheduled_stop_point_in_journey_pattern?: {
    __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_mutation_response';
    returning: Array<{
      __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
      journey_pattern_id: UUID;
      scheduled_stop_point_label: string;
      scheduled_stop_point_sequence: number;
      is_used_as_timing_point: boolean;
      is_regulated_timing_point: boolean;
      is_loading_time_allowed: boolean;
      is_via_point: boolean;
      via_point_name_i18n?: LocalizedString | null;
      via_point_short_name_i18n?: LocalizedString | null;
      journey_pattern: {
        __typename?: 'journey_pattern_journey_pattern';
        journey_pattern_id: UUID;
        on_route_id: UUID;
      };
    }>;
  } | null;
};

export type GetStopWithRouteGraphDataByIdQueryVariables = Exact<{
  stopId: Scalars['uuid'];
}>;

export type GetStopWithRouteGraphDataByIdQuery = {
  __typename?: 'query_root';
  service_pattern_scheduled_stop_point: Array<{
    __typename?: 'service_pattern_scheduled_stop_point';
    measured_location: GeoJSON.Point;
    relative_distance_from_infrastructure_link_start: number;
    closest_point_on_infrastructure_link?: GeoJSON.Point | null;
    priority: number;
    direction: InfrastructureNetworkDirectionEnum;
    scheduled_stop_point_id: UUID;
    label: string;
    timing_place_id?: UUID | null;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    located_on_infrastructure_link_id: UUID;
    scheduled_stop_point_in_journey_patterns: Array<{
      __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
      journey_pattern_id: UUID;
      scheduled_stop_point_label: string;
      scheduled_stop_point_sequence: number;
      is_used_as_timing_point: boolean;
      is_regulated_timing_point: boolean;
      is_loading_time_allowed: boolean;
      is_via_point: boolean;
      via_point_name_i18n?: LocalizedString | null;
      via_point_short_name_i18n?: LocalizedString | null;
      journey_pattern: {
        __typename?: 'journey_pattern_journey_pattern';
        journey_pattern_id: UUID;
        on_route_id: UUID;
        journey_pattern_route?: {
          __typename?: 'route_route';
          name_i18n: LocalizedString;
          description_i18n?: LocalizedString | null;
          origin_name_i18n: LocalizedString;
          origin_short_name_i18n: LocalizedString;
          destination_name_i18n: LocalizedString;
          destination_short_name_i18n: LocalizedString;
          on_line_id: UUID;
          label: string;
          direction: RouteDirectionEnum;
          variant?: number | null;
          route_id: UUID;
          validity_start?: luxon.DateTime | null;
          validity_end?: luxon.DateTime | null;
          priority: number;
          infrastructure_links_along_route: Array<{
            __typename?: 'route_infrastructure_link_along_route';
            route_id: UUID;
            infrastructure_link_id: UUID;
            infrastructure_link_sequence: number;
          }>;
        } | null;
      };
    }>;
    vehicle_mode_on_scheduled_stop_point: Array<{
      __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point';
      vehicle_mode: ReusableComponentsVehicleModeEnum;
    }>;
    timing_place?: {
      __typename?: 'timing_pattern_timing_place';
      timing_place_id: UUID;
      label: string;
    } | null;
  }>;
};

export type GetRoutesBrokenByStopChangeQueryVariables = Exact<{
  new_located_on_infrastructure_link_id: Scalars['uuid'];
  new_direction: Scalars['String'];
  new_label: Scalars['String'];
  new_validity_start?: InputMaybe<Scalars['date']>;
  new_validity_end?: InputMaybe<Scalars['date']>;
  new_priority: Scalars['Int'];
  new_measured_location: Scalars['geography'];
  replace_scheduled_stop_point_id?: InputMaybe<Scalars['uuid']>;
}>;

export type GetRoutesBrokenByStopChangeQuery = {
  __typename?: 'query_root';
  journey_pattern_check_infra_link_stop_refs_with_new_scheduled_stop_point: Array<{
    __typename?: 'journey_pattern_journey_pattern';
    journey_pattern_id: UUID;
    journey_pattern_route?: {
      __typename?: 'route_route';
      route_shape?: GeoJSON.LineString | null;
      name_i18n: LocalizedString;
      description_i18n?: LocalizedString | null;
      origin_name_i18n: LocalizedString;
      origin_short_name_i18n: LocalizedString;
      destination_name_i18n: LocalizedString;
      destination_short_name_i18n: LocalizedString;
      on_line_id: UUID;
      label: string;
      direction: RouteDirectionEnum;
      variant?: number | null;
      route_id: UUID;
      validity_start?: luxon.DateTime | null;
      validity_end?: luxon.DateTime | null;
      priority: number;
    } | null;
  }>;
};

export type InfrastructureLinkWithStopsFragment = {
  __typename?: 'infrastructure_network_infrastructure_link';
  direction: InfrastructureNetworkDirectionEnum;
  shape: GeoJSON.LineString;
  estimated_length_in_metres?: number | null;
  external_link_id: string;
  external_link_source: InfrastructureNetworkExternalSourceEnum;
  infrastructure_link_id: UUID;
  scheduled_stop_points_located_on_infrastructure_link: Array<{
    __typename?: 'service_pattern_scheduled_stop_point';
    measured_location: GeoJSON.Point;
    relative_distance_from_infrastructure_link_start: number;
    closest_point_on_infrastructure_link?: GeoJSON.Point | null;
    priority: number;
    direction: InfrastructureNetworkDirectionEnum;
    scheduled_stop_point_id: UUID;
    label: string;
    timing_place_id?: UUID | null;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    located_on_infrastructure_link_id: UUID;
    other_label_instances: Array<{
      __typename?: 'service_pattern_scheduled_stop_point';
      priority: number;
      direction: InfrastructureNetworkDirectionEnum;
      scheduled_stop_point_id: UUID;
      label: string;
      timing_place_id?: UUID | null;
      validity_start?: luxon.DateTime | null;
      validity_end?: luxon.DateTime | null;
      located_on_infrastructure_link_id: UUID;
      timing_place?: {
        __typename?: 'timing_pattern_timing_place';
        timing_place_id: UUID;
        label: string;
      } | null;
    }>;
    scheduled_stop_point_in_journey_patterns: Array<{
      __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
      journey_pattern_id: UUID;
      scheduled_stop_point_label: string;
      scheduled_stop_point_sequence: number;
      is_used_as_timing_point: boolean;
      is_regulated_timing_point: boolean;
      is_loading_time_allowed: boolean;
      is_via_point: boolean;
      via_point_name_i18n?: LocalizedString | null;
      via_point_short_name_i18n?: LocalizedString | null;
      journey_pattern: {
        __typename?: 'journey_pattern_journey_pattern';
        journey_pattern_id: UUID;
        on_route_id: UUID;
      };
    }>;
    vehicle_mode_on_scheduled_stop_point: Array<{
      __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point';
      vehicle_mode: ReusableComponentsVehicleModeEnum;
    }>;
    timing_place?: {
      __typename?: 'timing_pattern_timing_place';
      timing_place_id: UUID;
      label: string;
    } | null;
  }>;
};

export type LineWithRoutesFragment = {
  __typename?: 'route_line';
  primary_vehicle_mode: ReusableComponentsVehicleModeEnum;
  type_of_line: RouteTypeOfLineEnum;
  transport_target: HslRouteTransportTargetEnum;
  line_id: UUID;
  label: string;
  name_i18n: LocalizedString;
  short_name_i18n: LocalizedString;
  validity_start?: luxon.DateTime | null;
  validity_end?: luxon.DateTime | null;
  priority: number;
  line_routes: Array<{
    __typename?: 'route_route';
    route_shape?: GeoJSON.LineString | null;
    name_i18n: LocalizedString;
    description_i18n?: LocalizedString | null;
    origin_name_i18n: LocalizedString;
    origin_short_name_i18n: LocalizedString;
    destination_name_i18n: LocalizedString;
    destination_short_name_i18n: LocalizedString;
    on_line_id: UUID;
    label: string;
    direction: RouteDirectionEnum;
    variant?: number | null;
    route_id: UUID;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    priority: number;
    route_line: {
      __typename?: 'route_line';
      primary_vehicle_mode: ReusableComponentsVehicleModeEnum;
      type_of_line: RouteTypeOfLineEnum;
      transport_target: HslRouteTransportTargetEnum;
      line_id: UUID;
      label: string;
      name_i18n: LocalizedString;
      short_name_i18n: LocalizedString;
      validity_start?: luxon.DateTime | null;
      validity_end?: luxon.DateTime | null;
      priority: number;
    };
    infrastructure_links_along_route: Array<{
      __typename?: 'route_infrastructure_link_along_route';
      route_id: UUID;
      infrastructure_link_sequence: number;
      infrastructure_link_id: UUID;
      is_traversal_forwards: boolean;
      infrastructure_link: {
        __typename?: 'infrastructure_network_infrastructure_link';
        external_link_source: InfrastructureNetworkExternalSourceEnum;
        external_link_id: string;
        infrastructure_link_id: UUID;
        shape: GeoJSON.LineString;
        direction: InfrastructureNetworkDirectionEnum;
        scheduled_stop_points_located_on_infrastructure_link: Array<{
          __typename?: 'service_pattern_scheduled_stop_point';
          measured_location: GeoJSON.Point;
          relative_distance_from_infrastructure_link_start: number;
          closest_point_on_infrastructure_link?: GeoJSON.Point | null;
          priority: number;
          direction: InfrastructureNetworkDirectionEnum;
          scheduled_stop_point_id: UUID;
          label: string;
          timing_place_id?: UUID | null;
          validity_start?: luxon.DateTime | null;
          validity_end?: luxon.DateTime | null;
          located_on_infrastructure_link_id: UUID;
          other_label_instances: Array<{
            __typename?: 'service_pattern_scheduled_stop_point';
            priority: number;
            direction: InfrastructureNetworkDirectionEnum;
            scheduled_stop_point_id: UUID;
            label: string;
            timing_place_id?: UUID | null;
            validity_start?: luxon.DateTime | null;
            validity_end?: luxon.DateTime | null;
            located_on_infrastructure_link_id: UUID;
            timing_place?: {
              __typename?: 'timing_pattern_timing_place';
              timing_place_id: UUID;
              label: string;
            } | null;
          }>;
          scheduled_stop_point_in_journey_patterns: Array<{
            __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
            journey_pattern_id: UUID;
            scheduled_stop_point_label: string;
            scheduled_stop_point_sequence: number;
            is_used_as_timing_point: boolean;
            is_regulated_timing_point: boolean;
            is_loading_time_allowed: boolean;
            is_via_point: boolean;
            via_point_name_i18n?: LocalizedString | null;
            via_point_short_name_i18n?: LocalizedString | null;
            journey_pattern: {
              __typename?: 'journey_pattern_journey_pattern';
              journey_pattern_id: UUID;
              on_route_id: UUID;
            };
          }>;
          vehicle_mode_on_scheduled_stop_point: Array<{
            __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point';
            vehicle_mode: ReusableComponentsVehicleModeEnum;
          }>;
          timing_place?: {
            __typename?: 'timing_pattern_timing_place';
            timing_place_id: UUID;
            label: string;
          } | null;
        }>;
      };
    }>;
    route_journey_patterns: Array<{
      __typename?: 'journey_pattern_journey_pattern';
      journey_pattern_id: UUID;
      on_route_id: UUID;
      ordered_scheduled_stop_point_in_journey_patterns: Array<{
        __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
        journey_pattern_id: UUID;
        scheduled_stop_point_label: string;
        scheduled_stop_point_sequence: number;
        is_used_as_timing_point: boolean;
        is_regulated_timing_point: boolean;
        is_loading_time_allowed: boolean;
        is_via_point: boolean;
        via_point_name_i18n?: LocalizedString | null;
        via_point_short_name_i18n?: LocalizedString | null;
        scheduled_stop_points: Array<{
          __typename?: 'service_pattern_scheduled_stop_point';
          priority: number;
          direction: InfrastructureNetworkDirectionEnum;
          scheduled_stop_point_id: UUID;
          label: string;
          timing_place_id?: UUID | null;
          validity_start?: luxon.DateTime | null;
          validity_end?: luxon.DateTime | null;
          located_on_infrastructure_link_id: UUID;
          timing_place?: {
            __typename?: 'timing_pattern_timing_place';
            timing_place_id: UUID;
            label: string;
          } | null;
        }>;
        journey_pattern: {
          __typename?: 'journey_pattern_journey_pattern';
          journey_pattern_id: UUID;
          on_route_id: UUID;
        };
      }>;
    }>;
  }>;
};

export type GetHighestPriorityLineDetailsWithRoutesQueryVariables = Exact<{
  lineFilters?: InputMaybe<RouteLineBoolExp>;
  lineRouteFilters?: InputMaybe<RouteRouteBoolExp>;
  routeStopFilters?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
}>;

export type GetHighestPriorityLineDetailsWithRoutesQuery = {
  __typename?: 'query_root';
  route_line: Array<{
    __typename?: 'route_line';
    primary_vehicle_mode: ReusableComponentsVehicleModeEnum;
    type_of_line: RouteTypeOfLineEnum;
    transport_target: HslRouteTransportTargetEnum;
    line_id: UUID;
    label: string;
    name_i18n: LocalizedString;
    short_name_i18n: LocalizedString;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    priority: number;
    line_routes: Array<{
      __typename?: 'route_route';
      label: string;
      direction: RouteDirectionEnum;
      variant?: number | null;
      route_id: UUID;
      validity_start?: luxon.DateTime | null;
      validity_end?: luxon.DateTime | null;
      priority: number;
    }>;
  }>;
};

export type UpdateRouteGeometryMutationVariables = Exact<{
  route_id: Scalars['uuid'];
  journey_pattern_id: Scalars['uuid'];
  new_infrastructure_links:
    | Array<RouteInfrastructureLinkAlongRouteInsertInput>
    | RouteInfrastructureLinkAlongRouteInsertInput;
  new_stops_in_journey_pattern:
    | Array<JourneyPatternScheduledStopPointInJourneyPatternInsertInput>
    | JourneyPatternScheduledStopPointInJourneyPatternInsertInput;
}>;

export type UpdateRouteGeometryMutation = {
  __typename?: 'mutation_root';
  delete_route_infrastructure_link_along_route?: {
    __typename?: 'route_infrastructure_link_along_route_mutation_response';
    returning: Array<{
      __typename?: 'route_infrastructure_link_along_route';
      infrastructure_link_id: UUID;
      infrastructure_link_sequence: number;
      route_id: UUID;
    }>;
  } | null;
  insert_route_infrastructure_link_along_route?: {
    __typename?: 'route_infrastructure_link_along_route_mutation_response';
    returning: Array<{
      __typename?: 'route_infrastructure_link_along_route';
      route_id: UUID;
      infrastructure_link_id: UUID;
      infrastructure_link_sequence: number;
      is_traversal_forwards: boolean;
      infrastructure_link: {
        __typename?: 'infrastructure_network_infrastructure_link';
        infrastructure_link_id: UUID;
        shape: GeoJSON.LineString;
      };
    }>;
  } | null;
  delete_journey_pattern_scheduled_stop_point_in_journey_pattern?: {
    __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_mutation_response';
    returning: Array<{
      __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
      scheduled_stop_point_label: string;
      scheduled_stop_point_sequence: number;
      journey_pattern_id: UUID;
    }>;
  } | null;
  insert_journey_pattern_scheduled_stop_point_in_journey_pattern?: {
    __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_mutation_response';
    returning: Array<{
      __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
      scheduled_stop_point_label: string;
      scheduled_stop_point_sequence: number;
      journey_pattern_id: UUID;
    }>;
  } | null;
};

export type UpdateRouteJourneyPatternMutationVariables = Exact<{
  journey_pattern_id: Scalars['uuid'];
  new_stops_in_journey_pattern:
    | Array<JourneyPatternScheduledStopPointInJourneyPatternInsertInput>
    | JourneyPatternScheduledStopPointInJourneyPatternInsertInput;
}>;

export type UpdateRouteJourneyPatternMutation = {
  __typename?: 'mutation_root';
  delete_journey_pattern_scheduled_stop_point_in_journey_pattern?: {
    __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_mutation_response';
    returning: Array<{
      __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
      scheduled_stop_point_label: string;
      scheduled_stop_point_sequence: number;
      journey_pattern_id: UUID;
    }>;
  } | null;
  insert_journey_pattern_scheduled_stop_point_in_journey_pattern?: {
    __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_mutation_response';
    returning: Array<{
      __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
      scheduled_stop_point_label: string;
      scheduled_stop_point_sequence: number;
      journey_pattern_id: UUID;
    }>;
  } | null;
};

export type GetLinksWithStopsByExternalLinkIdsQueryVariables = Exact<{
  externalLinkIds?: InputMaybe<Array<Scalars['String']> | Scalars['String']>;
}>;

export type GetLinksWithStopsByExternalLinkIdsQuery = {
  __typename?: 'query_root';
  infrastructure_network_infrastructure_link: Array<{
    __typename?: 'infrastructure_network_infrastructure_link';
    external_link_source: InfrastructureNetworkExternalSourceEnum;
    external_link_id: string;
    infrastructure_link_id: UUID;
    shape: GeoJSON.LineString;
    direction: InfrastructureNetworkDirectionEnum;
    scheduled_stop_points_located_on_infrastructure_link: Array<{
      __typename?: 'service_pattern_scheduled_stop_point';
      measured_location: GeoJSON.Point;
      relative_distance_from_infrastructure_link_start: number;
      closest_point_on_infrastructure_link?: GeoJSON.Point | null;
      priority: number;
      direction: InfrastructureNetworkDirectionEnum;
      scheduled_stop_point_id: UUID;
      label: string;
      timing_place_id?: UUID | null;
      validity_start?: luxon.DateTime | null;
      validity_end?: luxon.DateTime | null;
      located_on_infrastructure_link_id: UUID;
      other_label_instances: Array<{
        __typename?: 'service_pattern_scheduled_stop_point';
        priority: number;
        direction: InfrastructureNetworkDirectionEnum;
        scheduled_stop_point_id: UUID;
        label: string;
        timing_place_id?: UUID | null;
        validity_start?: luxon.DateTime | null;
        validity_end?: luxon.DateTime | null;
        located_on_infrastructure_link_id: UUID;
        timing_place?: {
          __typename?: 'timing_pattern_timing_place';
          timing_place_id: UUID;
          label: string;
        } | null;
      }>;
      scheduled_stop_point_in_journey_patterns: Array<{
        __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
        journey_pattern_id: UUID;
        scheduled_stop_point_label: string;
        scheduled_stop_point_sequence: number;
        is_used_as_timing_point: boolean;
        is_regulated_timing_point: boolean;
        is_loading_time_allowed: boolean;
        is_via_point: boolean;
        via_point_name_i18n?: LocalizedString | null;
        via_point_short_name_i18n?: LocalizedString | null;
        journey_pattern: {
          __typename?: 'journey_pattern_journey_pattern';
          journey_pattern_id: UUID;
          on_route_id: UUID;
        };
      }>;
      vehicle_mode_on_scheduled_stop_point: Array<{
        __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point';
        vehicle_mode: ReusableComponentsVehicleModeEnum;
      }>;
      timing_place?: {
        __typename?: 'timing_pattern_timing_place';
        timing_place_id: UUID;
        label: string;
      } | null;
    }>;
  }>;
};

export type GetLineRoutesByLabelQueryVariables = Exact<{
  lineFilters?: InputMaybe<RouteLineBoolExp>;
  lineRouteFilters?: InputMaybe<RouteRouteBoolExp>;
}>;

export type GetLineRoutesByLabelQuery = {
  __typename?: 'query_root';
  route_line: Array<{
    __typename?: 'route_line';
    line_id: UUID;
    line_routes: Array<{
      __typename?: 'route_route';
      route_id: UUID;
      label: string;
      variant?: number | null;
      validity_start?: luxon.DateTime | null;
      validity_end?: luxon.DateTime | null;
      priority: number;
      direction: RouteDirectionEnum;
      route_journey_patterns: Array<{
        __typename?: 'journey_pattern_journey_pattern';
        journey_pattern_id: UUID;
        scheduled_stop_point_in_journey_patterns: Array<{
          __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
          journey_pattern_id: UUID;
          scheduled_stop_point_label: string;
          scheduled_stop_point_sequence: number;
        }>;
      }>;
    }>;
  }>;
};

export type GetRouteByFiltersQueryVariables = Exact<{
  routeFilters?: InputMaybe<RouteRouteBoolExp>;
}>;

export type GetRouteByFiltersQuery = {
  __typename?: 'query_root';
  route_route: Array<{
    __typename?: 'route_route';
    route_id: UUID;
    label: string;
    variant?: number | null;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    priority: number;
    direction: RouteDirectionEnum;
    route_journey_patterns: Array<{
      __typename?: 'journey_pattern_journey_pattern';
      journey_pattern_id: UUID;
      scheduled_stop_point_in_journey_patterns: Array<{
        __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
        journey_pattern_id: UUID;
        scheduled_stop_point_label: string;
        scheduled_stop_point_sequence: number;
      }>;
    }>;
  }>;
};

export type DisplayedRouteFragment = {
  __typename?: 'route_route';
  route_id: UUID;
  label: string;
  variant?: number | null;
  validity_start?: luxon.DateTime | null;
  validity_end?: luxon.DateTime | null;
  priority: number;
  direction: RouteDirectionEnum;
  route_journey_patterns: Array<{
    __typename?: 'journey_pattern_journey_pattern';
    journey_pattern_id: UUID;
    scheduled_stop_point_in_journey_patterns: Array<{
      __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
      journey_pattern_id: UUID;
      scheduled_stop_point_label: string;
      scheduled_stop_point_sequence: number;
    }>;
  }>;
};

export type RouteMetadataFragment = {
  __typename?: 'route_route';
  name_i18n: LocalizedString;
  label: string;
  priority: number;
  validity_start?: luxon.DateTime | null;
  validity_end?: luxon.DateTime | null;
  direction: RouteDirectionEnum;
  variant?: number | null;
};

export type RouteWithInfrastructureLinksWithStopsFragment = {
  __typename?: 'route_route';
  route_shape?: GeoJSON.LineString | null;
  name_i18n: LocalizedString;
  description_i18n?: LocalizedString | null;
  origin_name_i18n: LocalizedString;
  origin_short_name_i18n: LocalizedString;
  destination_name_i18n: LocalizedString;
  destination_short_name_i18n: LocalizedString;
  on_line_id: UUID;
  label: string;
  direction: RouteDirectionEnum;
  variant?: number | null;
  route_id: UUID;
  validity_start?: luxon.DateTime | null;
  validity_end?: luxon.DateTime | null;
  priority: number;
  route_line: {
    __typename?: 'route_line';
    primary_vehicle_mode: ReusableComponentsVehicleModeEnum;
    type_of_line: RouteTypeOfLineEnum;
    transport_target: HslRouteTransportTargetEnum;
    line_id: UUID;
    label: string;
    name_i18n: LocalizedString;
    short_name_i18n: LocalizedString;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    priority: number;
  };
  infrastructure_links_along_route: Array<{
    __typename?: 'route_infrastructure_link_along_route';
    route_id: UUID;
    infrastructure_link_sequence: number;
    infrastructure_link_id: UUID;
    is_traversal_forwards: boolean;
    infrastructure_link: {
      __typename?: 'infrastructure_network_infrastructure_link';
      external_link_source: InfrastructureNetworkExternalSourceEnum;
      external_link_id: string;
      infrastructure_link_id: UUID;
      shape: GeoJSON.LineString;
      direction: InfrastructureNetworkDirectionEnum;
      scheduled_stop_points_located_on_infrastructure_link: Array<{
        __typename?: 'service_pattern_scheduled_stop_point';
        measured_location: GeoJSON.Point;
        relative_distance_from_infrastructure_link_start: number;
        closest_point_on_infrastructure_link?: GeoJSON.Point | null;
        priority: number;
        direction: InfrastructureNetworkDirectionEnum;
        scheduled_stop_point_id: UUID;
        label: string;
        timing_place_id?: UUID | null;
        validity_start?: luxon.DateTime | null;
        validity_end?: luxon.DateTime | null;
        located_on_infrastructure_link_id: UUID;
        other_label_instances: Array<{
          __typename?: 'service_pattern_scheduled_stop_point';
          priority: number;
          direction: InfrastructureNetworkDirectionEnum;
          scheduled_stop_point_id: UUID;
          label: string;
          timing_place_id?: UUID | null;
          validity_start?: luxon.DateTime | null;
          validity_end?: luxon.DateTime | null;
          located_on_infrastructure_link_id: UUID;
          timing_place?: {
            __typename?: 'timing_pattern_timing_place';
            timing_place_id: UUID;
            label: string;
          } | null;
        }>;
        scheduled_stop_point_in_journey_patterns: Array<{
          __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
          journey_pattern_id: UUID;
          scheduled_stop_point_label: string;
          scheduled_stop_point_sequence: number;
          is_used_as_timing_point: boolean;
          is_regulated_timing_point: boolean;
          is_loading_time_allowed: boolean;
          is_via_point: boolean;
          via_point_name_i18n?: LocalizedString | null;
          via_point_short_name_i18n?: LocalizedString | null;
          journey_pattern: {
            __typename?: 'journey_pattern_journey_pattern';
            journey_pattern_id: UUID;
            on_route_id: UUID;
          };
        }>;
        vehicle_mode_on_scheduled_stop_point: Array<{
          __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point';
          vehicle_mode: ReusableComponentsVehicleModeEnum;
        }>;
        timing_place?: {
          __typename?: 'timing_pattern_timing_place';
          timing_place_id: UUID;
          label: string;
        } | null;
      }>;
    };
  }>;
};

export type RouteWithInfrastructureLinksWithStopsAndJpsFragment = {
  __typename?: 'route_route';
  route_shape?: GeoJSON.LineString | null;
  name_i18n: LocalizedString;
  description_i18n?: LocalizedString | null;
  origin_name_i18n: LocalizedString;
  origin_short_name_i18n: LocalizedString;
  destination_name_i18n: LocalizedString;
  destination_short_name_i18n: LocalizedString;
  on_line_id: UUID;
  label: string;
  direction: RouteDirectionEnum;
  variant?: number | null;
  route_id: UUID;
  validity_start?: luxon.DateTime | null;
  validity_end?: luxon.DateTime | null;
  priority: number;
  route_line: {
    __typename?: 'route_line';
    primary_vehicle_mode: ReusableComponentsVehicleModeEnum;
    type_of_line: RouteTypeOfLineEnum;
    transport_target: HslRouteTransportTargetEnum;
    line_id: UUID;
    label: string;
    name_i18n: LocalizedString;
    short_name_i18n: LocalizedString;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    priority: number;
  };
  infrastructure_links_along_route: Array<{
    __typename?: 'route_infrastructure_link_along_route';
    route_id: UUID;
    infrastructure_link_sequence: number;
    infrastructure_link_id: UUID;
    is_traversal_forwards: boolean;
    infrastructure_link: {
      __typename?: 'infrastructure_network_infrastructure_link';
      external_link_source: InfrastructureNetworkExternalSourceEnum;
      external_link_id: string;
      infrastructure_link_id: UUID;
      shape: GeoJSON.LineString;
      direction: InfrastructureNetworkDirectionEnum;
      scheduled_stop_points_located_on_infrastructure_link: Array<{
        __typename?: 'service_pattern_scheduled_stop_point';
        measured_location: GeoJSON.Point;
        relative_distance_from_infrastructure_link_start: number;
        closest_point_on_infrastructure_link?: GeoJSON.Point | null;
        priority: number;
        direction: InfrastructureNetworkDirectionEnum;
        scheduled_stop_point_id: UUID;
        label: string;
        timing_place_id?: UUID | null;
        validity_start?: luxon.DateTime | null;
        validity_end?: luxon.DateTime | null;
        located_on_infrastructure_link_id: UUID;
        other_label_instances: Array<{
          __typename?: 'service_pattern_scheduled_stop_point';
          priority: number;
          direction: InfrastructureNetworkDirectionEnum;
          scheduled_stop_point_id: UUID;
          label: string;
          timing_place_id?: UUID | null;
          validity_start?: luxon.DateTime | null;
          validity_end?: luxon.DateTime | null;
          located_on_infrastructure_link_id: UUID;
          timing_place?: {
            __typename?: 'timing_pattern_timing_place';
            timing_place_id: UUID;
            label: string;
          } | null;
        }>;
        scheduled_stop_point_in_journey_patterns: Array<{
          __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
          journey_pattern_id: UUID;
          scheduled_stop_point_label: string;
          scheduled_stop_point_sequence: number;
          is_used_as_timing_point: boolean;
          is_regulated_timing_point: boolean;
          is_loading_time_allowed: boolean;
          is_via_point: boolean;
          via_point_name_i18n?: LocalizedString | null;
          via_point_short_name_i18n?: LocalizedString | null;
          journey_pattern: {
            __typename?: 'journey_pattern_journey_pattern';
            journey_pattern_id: UUID;
            on_route_id: UUID;
          };
        }>;
        vehicle_mode_on_scheduled_stop_point: Array<{
          __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point';
          vehicle_mode: ReusableComponentsVehicleModeEnum;
        }>;
        timing_place?: {
          __typename?: 'timing_pattern_timing_place';
          timing_place_id: UUID;
          label: string;
        } | null;
      }>;
    };
  }>;
  route_journey_patterns: Array<{
    __typename?: 'journey_pattern_journey_pattern';
    journey_pattern_id: UUID;
    on_route_id: UUID;
    ordered_scheduled_stop_point_in_journey_patterns: Array<{
      __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
      journey_pattern_id: UUID;
      scheduled_stop_point_label: string;
      scheduled_stop_point_sequence: number;
      is_used_as_timing_point: boolean;
      is_regulated_timing_point: boolean;
      is_loading_time_allowed: boolean;
      is_via_point: boolean;
      via_point_name_i18n?: LocalizedString | null;
      via_point_short_name_i18n?: LocalizedString | null;
      scheduled_stop_points: Array<{
        __typename?: 'service_pattern_scheduled_stop_point';
        priority: number;
        direction: InfrastructureNetworkDirectionEnum;
        scheduled_stop_point_id: UUID;
        label: string;
        timing_place_id?: UUID | null;
        validity_start?: luxon.DateTime | null;
        validity_end?: luxon.DateTime | null;
        located_on_infrastructure_link_id: UUID;
        timing_place?: {
          __typename?: 'timing_pattern_timing_place';
          timing_place_id: UUID;
          label: string;
        } | null;
      }>;
      journey_pattern: {
        __typename?: 'journey_pattern_journey_pattern';
        journey_pattern_id: UUID;
        on_route_id: UUID;
      };
    }>;
  }>;
};

export type InfraLinkAlongRouteWithStopsFragment = {
  __typename?: 'route_infrastructure_link_along_route';
  route_id: UUID;
  infrastructure_link_sequence: number;
  infrastructure_link_id: UUID;
  is_traversal_forwards: boolean;
  infrastructure_link: {
    __typename?: 'infrastructure_network_infrastructure_link';
    external_link_source: InfrastructureNetworkExternalSourceEnum;
    external_link_id: string;
    infrastructure_link_id: UUID;
    shape: GeoJSON.LineString;
    direction: InfrastructureNetworkDirectionEnum;
    scheduled_stop_points_located_on_infrastructure_link: Array<{
      __typename?: 'service_pattern_scheduled_stop_point';
      measured_location: GeoJSON.Point;
      relative_distance_from_infrastructure_link_start: number;
      closest_point_on_infrastructure_link?: GeoJSON.Point | null;
      priority: number;
      direction: InfrastructureNetworkDirectionEnum;
      scheduled_stop_point_id: UUID;
      label: string;
      timing_place_id?: UUID | null;
      validity_start?: luxon.DateTime | null;
      validity_end?: luxon.DateTime | null;
      located_on_infrastructure_link_id: UUID;
      other_label_instances: Array<{
        __typename?: 'service_pattern_scheduled_stop_point';
        priority: number;
        direction: InfrastructureNetworkDirectionEnum;
        scheduled_stop_point_id: UUID;
        label: string;
        timing_place_id?: UUID | null;
        validity_start?: luxon.DateTime | null;
        validity_end?: luxon.DateTime | null;
        located_on_infrastructure_link_id: UUID;
        timing_place?: {
          __typename?: 'timing_pattern_timing_place';
          timing_place_id: UUID;
          label: string;
        } | null;
      }>;
      scheduled_stop_point_in_journey_patterns: Array<{
        __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
        journey_pattern_id: UUID;
        scheduled_stop_point_label: string;
        scheduled_stop_point_sequence: number;
        is_used_as_timing_point: boolean;
        is_regulated_timing_point: boolean;
        is_loading_time_allowed: boolean;
        is_via_point: boolean;
        via_point_name_i18n?: LocalizedString | null;
        via_point_short_name_i18n?: LocalizedString | null;
        journey_pattern: {
          __typename?: 'journey_pattern_journey_pattern';
          journey_pattern_id: UUID;
          on_route_id: UUID;
        };
      }>;
      vehicle_mode_on_scheduled_stop_point: Array<{
        __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point';
        vehicle_mode: ReusableComponentsVehicleModeEnum;
      }>;
      timing_place?: {
        __typename?: 'timing_pattern_timing_place';
        timing_place_id: UUID;
        label: string;
      } | null;
    }>;
  };
};

export type GetRouteWithInfrastructureLinksWithStopsQueryVariables = Exact<{
  route_id: Scalars['uuid'];
}>;

export type GetRouteWithInfrastructureLinksWithStopsQuery = {
  __typename?: 'query_root';
  route_route_by_pk?: {
    __typename?: 'route_route';
    route_shape?: GeoJSON.LineString | null;
    name_i18n: LocalizedString;
    description_i18n?: LocalizedString | null;
    origin_name_i18n: LocalizedString;
    origin_short_name_i18n: LocalizedString;
    destination_name_i18n: LocalizedString;
    destination_short_name_i18n: LocalizedString;
    on_line_id: UUID;
    label: string;
    direction: RouteDirectionEnum;
    variant?: number | null;
    route_id: UUID;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    priority: number;
    route_line: {
      __typename?: 'route_line';
      primary_vehicle_mode: ReusableComponentsVehicleModeEnum;
      type_of_line: RouteTypeOfLineEnum;
      transport_target: HslRouteTransportTargetEnum;
      line_id: UUID;
      label: string;
      name_i18n: LocalizedString;
      short_name_i18n: LocalizedString;
      validity_start?: luxon.DateTime | null;
      validity_end?: luxon.DateTime | null;
      priority: number;
    };
    infrastructure_links_along_route: Array<{
      __typename?: 'route_infrastructure_link_along_route';
      route_id: UUID;
      infrastructure_link_sequence: number;
      infrastructure_link_id: UUID;
      is_traversal_forwards: boolean;
      infrastructure_link: {
        __typename?: 'infrastructure_network_infrastructure_link';
        external_link_source: InfrastructureNetworkExternalSourceEnum;
        external_link_id: string;
        infrastructure_link_id: UUID;
        shape: GeoJSON.LineString;
        direction: InfrastructureNetworkDirectionEnum;
        scheduled_stop_points_located_on_infrastructure_link: Array<{
          __typename?: 'service_pattern_scheduled_stop_point';
          measured_location: GeoJSON.Point;
          relative_distance_from_infrastructure_link_start: number;
          closest_point_on_infrastructure_link?: GeoJSON.Point | null;
          priority: number;
          direction: InfrastructureNetworkDirectionEnum;
          scheduled_stop_point_id: UUID;
          label: string;
          timing_place_id?: UUID | null;
          validity_start?: luxon.DateTime | null;
          validity_end?: luxon.DateTime | null;
          located_on_infrastructure_link_id: UUID;
          other_label_instances: Array<{
            __typename?: 'service_pattern_scheduled_stop_point';
            priority: number;
            direction: InfrastructureNetworkDirectionEnum;
            scheduled_stop_point_id: UUID;
            label: string;
            timing_place_id?: UUID | null;
            validity_start?: luxon.DateTime | null;
            validity_end?: luxon.DateTime | null;
            located_on_infrastructure_link_id: UUID;
            timing_place?: {
              __typename?: 'timing_pattern_timing_place';
              timing_place_id: UUID;
              label: string;
            } | null;
          }>;
          scheduled_stop_point_in_journey_patterns: Array<{
            __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
            journey_pattern_id: UUID;
            scheduled_stop_point_label: string;
            scheduled_stop_point_sequence: number;
            is_used_as_timing_point: boolean;
            is_regulated_timing_point: boolean;
            is_loading_time_allowed: boolean;
            is_via_point: boolean;
            via_point_name_i18n?: LocalizedString | null;
            via_point_short_name_i18n?: LocalizedString | null;
            journey_pattern: {
              __typename?: 'journey_pattern_journey_pattern';
              journey_pattern_id: UUID;
              on_route_id: UUID;
            };
          }>;
          vehicle_mode_on_scheduled_stop_point: Array<{
            __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point';
            vehicle_mode: ReusableComponentsVehicleModeEnum;
          }>;
          timing_place?: {
            __typename?: 'timing_pattern_timing_place';
            timing_place_id: UUID;
            label: string;
          } | null;
        }>;
      };
    }>;
    route_journey_patterns: Array<{
      __typename?: 'journey_pattern_journey_pattern';
      journey_pattern_id: UUID;
      on_route_id: UUID;
      ordered_scheduled_stop_point_in_journey_patterns: Array<{
        __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
        journey_pattern_id: UUID;
        scheduled_stop_point_label: string;
        scheduled_stop_point_sequence: number;
        is_used_as_timing_point: boolean;
        is_regulated_timing_point: boolean;
        is_loading_time_allowed: boolean;
        is_via_point: boolean;
        via_point_name_i18n?: LocalizedString | null;
        via_point_short_name_i18n?: LocalizedString | null;
        scheduled_stop_points: Array<{
          __typename?: 'service_pattern_scheduled_stop_point';
          priority: number;
          direction: InfrastructureNetworkDirectionEnum;
          scheduled_stop_point_id: UUID;
          label: string;
          timing_place_id?: UUID | null;
          validity_start?: luxon.DateTime | null;
          validity_end?: luxon.DateTime | null;
          located_on_infrastructure_link_id: UUID;
          timing_place?: {
            __typename?: 'timing_pattern_timing_place';
            timing_place_id: UUID;
            label: string;
          } | null;
        }>;
        journey_pattern: {
          __typename?: 'journey_pattern_journey_pattern';
          journey_pattern_id: UUID;
          on_route_id: UUID;
        };
      }>;
    }>;
  } | null;
};

export type SearchLinesAndRoutesQueryVariables = Exact<{
  lineFilter?: InputMaybe<RouteLineBoolExp>;
  routeFilter?: InputMaybe<RouteRouteBoolExp>;
  lineOrderBy?: InputMaybe<Array<RouteLineOrderBy> | RouteLineOrderBy>;
  routeOrderBy?: InputMaybe<Array<RouteRouteOrderBy> | RouteRouteOrderBy>;
}>;

export type SearchLinesAndRoutesQuery = {
  __typename?: 'query_root';
  route_line: Array<{
    __typename?: 'route_line';
    name_i18n: LocalizedString;
    short_name_i18n: LocalizedString;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    priority: number;
    line_id: UUID;
    label: string;
    line_routes: Array<{
      __typename?: 'route_route';
      unique_label: string;
      direction: RouteDirectionEnum;
      route_id: UUID;
      route_shape?: GeoJSON.LineString | null;
      label: string;
      validity_start?: luxon.DateTime | null;
      validity_end?: luxon.DateTime | null;
      route_journey_patterns: Array<{
        __typename?: 'journey_pattern_journey_pattern';
        journey_pattern_id: UUID;
        journey_pattern_refs: Array<{
          __typename?: 'timetables_journey_pattern_journey_pattern_ref';
          journey_pattern_ref_id: UUID;
          vehicle_journeys: Array<{
            __typename?: 'timetables_vehicle_journey_vehicle_journey';
            vehicle_journey_id: UUID;
          }>;
        }>;
        scheduled_stop_point_in_journey_patterns: Array<{
          __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
          journey_pattern_id: UUID;
          scheduled_stop_point_sequence: number;
          is_used_as_timing_point: boolean;
        }>;
      }>;
    }>;
  }>;
  route_route: Array<{
    __typename?: 'route_route';
    name_i18n: LocalizedString;
    direction: RouteDirectionEnum;
    priority: number;
    on_line_id: UUID;
    variant?: number | null;
    unique_label: string;
    route_id: UUID;
    label: string;
    route_shape?: GeoJSON.LineString | null;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    route_journey_patterns: Array<{
      __typename?: 'journey_pattern_journey_pattern';
      journey_pattern_id: UUID;
      journey_pattern_refs: Array<{
        __typename?: 'timetables_journey_pattern_journey_pattern_ref';
        journey_pattern_ref_id: UUID;
        vehicle_journeys: Array<{
          __typename?: 'timetables_vehicle_journey_vehicle_journey';
          vehicle_journey_id: UUID;
        }>;
      }>;
      scheduled_stop_point_in_journey_patterns: Array<{
        __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
        journey_pattern_id: UUID;
        scheduled_stop_point_sequence: number;
        is_used_as_timing_point: boolean;
      }>;
    }>;
  }>;
};

export type StopTableRowStopPlaceFragment = {
  __typename?: 'stop_registry_StopPlace';
  id?: string | null;
  name?: {
    __typename?: 'stop_registry_EmbeddableMultilingualString';
    lang?: string | null;
    value?: string | null;
  } | null;
  alternativeNames?: Array<{
    __typename?: 'stop_registry_AlternativeName';
    nameType: StopRegistryNameType;
    name: {
      __typename?: 'stop_registry_EmbeddableMultilingualString';
      lang?: string | null;
      value?: string | null;
    };
  } | null> | null;
};

export type StopTableRowFragment = {
  __typename?: 'service_pattern_scheduled_stop_point';
  scheduled_stop_point_id: UUID;
  label: string;
  validity_start?: luxon.DateTime | null;
  validity_end?: luxon.DateTime | null;
  timing_place_id?: UUID | null;
  stop_place_ref?: string | null;
  timing_place?: {
    __typename?: 'timing_pattern_timing_place';
    timing_place_id: UUID;
    label: string;
  } | null;
  stop_place?: Array<
    | { __typename?: 'stop_registry_ParentStopPlace' }
    | {
        __typename?: 'stop_registry_StopPlace';
        id?: string | null;
        name?: {
          __typename?: 'stop_registry_EmbeddableMultilingualString';
          lang?: string | null;
          value?: string | null;
        } | null;
        alternativeNames?: Array<{
          __typename?: 'stop_registry_AlternativeName';
          nameType: StopRegistryNameType;
          name: {
            __typename?: 'stop_registry_EmbeddableMultilingualString';
            lang?: string | null;
            value?: string | null;
          };
        } | null> | null;
      }
    | null
  > | null;
};

export type SearchStopsQueryVariables = Exact<{
  stopFilter?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
  stopOrderBy?: InputMaybe<
    | Array<ServicePatternScheduledStopPointOrderBy>
    | ServicePatternScheduledStopPointOrderBy
  >;
}>;

export type SearchStopsQuery = {
  __typename?: 'query_root';
  service_pattern_scheduled_stop_point: Array<{
    __typename?: 'service_pattern_scheduled_stop_point';
    scheduled_stop_point_id: UUID;
    label: string;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    timing_place_id?: UUID | null;
    stop_place_ref?: string | null;
    timing_place?: {
      __typename?: 'timing_pattern_timing_place';
      timing_place_id: UUID;
      label: string;
    } | null;
    stop_place?: Array<
      | { __typename?: 'stop_registry_ParentStopPlace' }
      | {
          __typename?: 'stop_registry_StopPlace';
          id?: string | null;
          name?: {
            __typename?: 'stop_registry_EmbeddableMultilingualString';
            lang?: string | null;
            value?: string | null;
          } | null;
          alternativeNames?: Array<{
            __typename?: 'stop_registry_AlternativeName';
            nameType: StopRegistryNameType;
            name: {
              __typename?: 'stop_registry_EmbeddableMultilingualString';
              lang?: string | null;
              value?: string | null;
            };
          } | null> | null;
        }
      | null
    > | null;
  }>;
};

export type UpdateStopPlaceMutationVariables = Exact<{
  input: StopRegistryStopPlaceInput;
}>;

export type UpdateStopPlaceMutation = {
  __typename?: 'mutation_root';
  stop_registry?: {
    __typename?: 'stop_registryStopPlaceMutation';
    mutateStopPlace?: Array<{
      __typename?: 'stop_registry_StopPlace';
      id?: string | null;
      transportMode?: StopRegistryTransportModeType | null;
      weighting?: StopRegistryInterchangeWeightingType | null;
      submode?: StopRegistrySubmodeType | null;
      publicCode?: string | null;
      name?: {
        __typename?: 'stop_registry_EmbeddableMultilingualString';
        lang?: string | null;
        value?: string | null;
      } | null;
      alternativeNames?: Array<{
        __typename?: 'stop_registry_AlternativeName';
        nameType: StopRegistryNameType;
        name: {
          __typename?: 'stop_registry_EmbeddableMultilingualString';
          lang?: string | null;
          value?: string | null;
        };
      } | null> | null;
      keyValues?: Array<{
        __typename?: 'stop_registry_KeyValues';
        key?: string | null;
        values?: Array<string | null> | null;
      } | null> | null;
      privateCode?: {
        __typename?: 'stop_registry_PrivateCode';
        value?: string | null;
        type?: string | null;
      } | null;
      description?: {
        __typename?: 'stop_registry_EmbeddableMultilingualString';
        lang?: string | null;
        value?: string | null;
      } | null;
      geometry?: {
        __typename?: 'stop_registry_GeoJSON';
        coordinates?: any | null;
        type?: StopRegistryGeoJsonType | null;
      } | null;
      placeEquipments?: {
        __typename?: 'stop_registry_PlaceEquipments';
        generalSign?: Array<{
          __typename?: 'stop_registry_GeneralSign';
          signContentType?: StopRegistrySignContentType | null;
          numberOfFrames?: number | null;
          lineSignage?: boolean | null;
          mainLineSign?: boolean | null;
          replacesRailSign?: boolean | null;
          privateCode?: {
            __typename?: 'stop_registry_PrivateCode';
            value?: string | null;
            type?: string | null;
          } | null;
          note?: {
            __typename?: 'stop_registry_EmbeddableMultilingualString';
            lang?: string | null;
            value?: string | null;
          } | null;
        } | null> | null;
      } | null;
      quays?: Array<{
        __typename?: 'stop_registry_Quay';
        id?: string | null;
        publicCode?: string | null;
        alternativeNames?: Array<{
          __typename?: 'stop_registry_AlternativeName';
          nameType: StopRegistryNameType;
          name: {
            __typename?: 'stop_registry_EmbeddableMultilingualString';
            lang?: string | null;
            value?: string | null;
          };
        } | null> | null;
        placeEquipments?: {
          __typename?: 'stop_registry_PlaceEquipments';
          shelterEquipment?: Array<{
            __typename?: 'stop_registry_ShelterEquipment';
            enclosed?: boolean | null;
            stepFree?: boolean | null;
          } | null> | null;
          cycleStorageEquipment?: Array<{
            __typename?: 'stop_registry_CycleStorageEquipment';
            cycleStorageType?: StopRegistryCycleStorageType | null;
          } | null> | null;
        } | null;
      } | null> | null;
    } | null> | null;
  } | null;
};

export type ScheduledStopPointDetailFieldsFragment = {
  __typename?: 'service_pattern_scheduled_stop_point';
  priority: number;
  direction: InfrastructureNetworkDirectionEnum;
  scheduled_stop_point_id: UUID;
  label: string;
  timing_place_id?: UUID | null;
  validity_start?: luxon.DateTime | null;
  validity_end?: luxon.DateTime | null;
  located_on_infrastructure_link_id: UUID;
  stop_place_ref?: string | null;
  measured_location: GeoJSON.Point;
  timing_place?: {
    __typename?: 'timing_pattern_timing_place';
    timing_place_id: UUID;
    label: string;
  } | null;
};

export type GetStopDetailsByIdQueryVariables = Exact<{
  scheduled_stop_point_id: Scalars['uuid'];
}>;

export type GetStopDetailsByIdQuery = {
  __typename?: 'query_root';
  service_pattern_scheduled_stop_point_by_pk?: {
    __typename?: 'service_pattern_scheduled_stop_point';
    priority: number;
    direction: InfrastructureNetworkDirectionEnum;
    scheduled_stop_point_id: UUID;
    label: string;
    timing_place_id?: UUID | null;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    located_on_infrastructure_link_id: UUID;
    stop_place_ref?: string | null;
    measured_location: GeoJSON.Point;
    stop_place?: Array<
      | { __typename?: 'stop_registry_ParentStopPlace' }
      | {
          __typename?: 'stop_registry_StopPlace';
          id?: string | null;
          transportMode?: StopRegistryTransportModeType | null;
          weighting?: StopRegistryInterchangeWeightingType | null;
          submode?: StopRegistrySubmodeType | null;
          publicCode?: string | null;
          name?: {
            __typename?: 'stop_registry_EmbeddableMultilingualString';
            lang?: string | null;
            value?: string | null;
          } | null;
          alternativeNames?: Array<{
            __typename?: 'stop_registry_AlternativeName';
            nameType: StopRegistryNameType;
            name: {
              __typename?: 'stop_registry_EmbeddableMultilingualString';
              lang?: string | null;
              value?: string | null;
            };
          } | null> | null;
          keyValues?: Array<{
            __typename?: 'stop_registry_KeyValues';
            key?: string | null;
            values?: Array<string | null> | null;
          } | null> | null;
          privateCode?: {
            __typename?: 'stop_registry_PrivateCode';
            value?: string | null;
            type?: string | null;
          } | null;
          description?: {
            __typename?: 'stop_registry_EmbeddableMultilingualString';
            lang?: string | null;
            value?: string | null;
          } | null;
          geometry?: {
            __typename?: 'stop_registry_GeoJSON';
            coordinates?: any | null;
            type?: StopRegistryGeoJsonType | null;
          } | null;
          placeEquipments?: {
            __typename?: 'stop_registry_PlaceEquipments';
            generalSign?: Array<{
              __typename?: 'stop_registry_GeneralSign';
              signContentType?: StopRegistrySignContentType | null;
              numberOfFrames?: number | null;
              lineSignage?: boolean | null;
              mainLineSign?: boolean | null;
              replacesRailSign?: boolean | null;
              privateCode?: {
                __typename?: 'stop_registry_PrivateCode';
                value?: string | null;
                type?: string | null;
              } | null;
              note?: {
                __typename?: 'stop_registry_EmbeddableMultilingualString';
                lang?: string | null;
                value?: string | null;
              } | null;
            } | null> | null;
          } | null;
          quays?: Array<{
            __typename?: 'stop_registry_Quay';
            id?: string | null;
            publicCode?: string | null;
            alternativeNames?: Array<{
              __typename?: 'stop_registry_AlternativeName';
              nameType: StopRegistryNameType;
              name: {
                __typename?: 'stop_registry_EmbeddableMultilingualString';
                lang?: string | null;
                value?: string | null;
              };
            } | null> | null;
            placeEquipments?: {
              __typename?: 'stop_registry_PlaceEquipments';
              shelterEquipment?: Array<{
                __typename?: 'stop_registry_ShelterEquipment';
                enclosed?: boolean | null;
                stepFree?: boolean | null;
              } | null> | null;
              cycleStorageEquipment?: Array<{
                __typename?: 'stop_registry_CycleStorageEquipment';
                cycleStorageType?: StopRegistryCycleStorageType | null;
              } | null> | null;
            } | null;
          } | null> | null;
        }
      | null
    > | null;
    timing_place?: {
      __typename?: 'timing_pattern_timing_place';
      timing_place_id: UUID;
      label: string;
    } | null;
  } | null;
};

export type QuayDetailsFragment = {
  __typename?: 'stop_registry_Quay';
  id?: string | null;
  publicCode?: string | null;
  alternativeNames?: Array<{
    __typename?: 'stop_registry_AlternativeName';
    nameType: StopRegistryNameType;
    name: {
      __typename?: 'stop_registry_EmbeddableMultilingualString';
      lang?: string | null;
      value?: string | null;
    };
  } | null> | null;
  placeEquipments?: {
    __typename?: 'stop_registry_PlaceEquipments';
    shelterEquipment?: Array<{
      __typename?: 'stop_registry_ShelterEquipment';
      enclosed?: boolean | null;
      stepFree?: boolean | null;
    } | null> | null;
    cycleStorageEquipment?: Array<{
      __typename?: 'stop_registry_CycleStorageEquipment';
      cycleStorageType?: StopRegistryCycleStorageType | null;
    } | null> | null;
  } | null;
};

export type StopPlaceDetailsFragment = {
  __typename?: 'stop_registry_StopPlace';
  id?: string | null;
  transportMode?: StopRegistryTransportModeType | null;
  weighting?: StopRegistryInterchangeWeightingType | null;
  submode?: StopRegistrySubmodeType | null;
  publicCode?: string | null;
  name?: {
    __typename?: 'stop_registry_EmbeddableMultilingualString';
    lang?: string | null;
    value?: string | null;
  } | null;
  alternativeNames?: Array<{
    __typename?: 'stop_registry_AlternativeName';
    nameType: StopRegistryNameType;
    name: {
      __typename?: 'stop_registry_EmbeddableMultilingualString';
      lang?: string | null;
      value?: string | null;
    };
  } | null> | null;
  keyValues?: Array<{
    __typename?: 'stop_registry_KeyValues';
    key?: string | null;
    values?: Array<string | null> | null;
  } | null> | null;
  privateCode?: {
    __typename?: 'stop_registry_PrivateCode';
    value?: string | null;
    type?: string | null;
  } | null;
  description?: {
    __typename?: 'stop_registry_EmbeddableMultilingualString';
    lang?: string | null;
    value?: string | null;
  } | null;
  geometry?: {
    __typename?: 'stop_registry_GeoJSON';
    coordinates?: any | null;
    type?: StopRegistryGeoJsonType | null;
  } | null;
  placeEquipments?: {
    __typename?: 'stop_registry_PlaceEquipments';
    generalSign?: Array<{
      __typename?: 'stop_registry_GeneralSign';
      signContentType?: StopRegistrySignContentType | null;
      numberOfFrames?: number | null;
      lineSignage?: boolean | null;
      mainLineSign?: boolean | null;
      replacesRailSign?: boolean | null;
      privateCode?: {
        __typename?: 'stop_registry_PrivateCode';
        value?: string | null;
        type?: string | null;
      } | null;
      note?: {
        __typename?: 'stop_registry_EmbeddableMultilingualString';
        lang?: string | null;
        value?: string | null;
      } | null;
    } | null> | null;
  } | null;
  quays?: Array<{
    __typename?: 'stop_registry_Quay';
    id?: string | null;
    publicCode?: string | null;
    alternativeNames?: Array<{
      __typename?: 'stop_registry_AlternativeName';
      nameType: StopRegistryNameType;
      name: {
        __typename?: 'stop_registry_EmbeddableMultilingualString';
        lang?: string | null;
        value?: string | null;
      };
    } | null> | null;
    placeEquipments?: {
      __typename?: 'stop_registry_PlaceEquipments';
      shelterEquipment?: Array<{
        __typename?: 'stop_registry_ShelterEquipment';
        enclosed?: boolean | null;
        stepFree?: boolean | null;
      } | null> | null;
      cycleStorageEquipment?: Array<{
        __typename?: 'stop_registry_CycleStorageEquipment';
        cycleStorageType?: StopRegistryCycleStorageType | null;
      } | null> | null;
    } | null;
  } | null> | null;
};

export type PatchScheduledStopPointTimingSettingsMutationVariables = Exact<{
  stopLabel: Scalars['String'];
  journeyPatternId: Scalars['uuid'];
  sequence: Scalars['Int'];
  patch: JourneyPatternScheduledStopPointInJourneyPatternSetInput;
  stopId: Scalars['uuid'];
  timingPlaceId?: InputMaybe<Scalars['uuid']>;
}>;

export type PatchScheduledStopPointTimingSettingsMutation = {
  __typename?: 'mutation_root';
  update_service_pattern_scheduled_stop_point?: {
    __typename?: 'service_pattern_scheduled_stop_point_mutation_response';
    returning: Array<{
      __typename?: 'service_pattern_scheduled_stop_point';
      scheduled_stop_point_id: UUID;
      timing_place?: {
        __typename?: 'timing_pattern_timing_place';
        timing_place_id: UUID;
      } | null;
    }>;
  } | null;
  update_journey_pattern_scheduled_stop_point_in_journey_pattern?: {
    __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_mutation_response';
    returning: Array<{
      __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
      journey_pattern_id: UUID;
      scheduled_stop_point_label: string;
      scheduled_stop_point_sequence: number;
      is_used_as_timing_point: boolean;
      is_regulated_timing_point: boolean;
      is_loading_time_allowed: boolean;
      is_via_point: boolean;
      via_point_name_i18n?: LocalizedString | null;
      via_point_short_name_i18n?: LocalizedString | null;
      journey_pattern: {
        __typename?: 'journey_pattern_journey_pattern';
        journey_pattern_id: UUID;
        on_route_id: UUID;
      };
    }>;
  } | null;
};

export type GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQueryVariables =
  Exact<{
    label: Scalars['String'];
  }>;

export type GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery = {
  __typename?: 'query_root';
  journey_pattern_scheduled_stop_point_in_journey_pattern: Array<{
    __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
    journey_pattern_id: UUID;
    scheduled_stop_point_label: string;
    scheduled_stop_point_sequence: number;
    journey_pattern: {
      __typename?: 'journey_pattern_journey_pattern';
      journey_pattern_id: UUID;
      on_route_id: UUID;
      journey_pattern_route?: {
        __typename?: 'route_route';
        route_id: UUID;
        label: string;
        variant?: number | null;
      } | null;
    };
  }>;
};

export type CreateSubstituteOperatingPeriodMutationVariables = Exact<{
  data:
    | Array<TimetablesServiceCalendarSubstituteOperatingPeriodInsertInput>
    | TimetablesServiceCalendarSubstituteOperatingPeriodInsertInput;
}>;

export type CreateSubstituteOperatingPeriodMutation = {
  __typename?: 'mutation_root';
  timetables?: {
    __typename?: 'timetables_timetables_mutation_frontend';
    timetables_insert_service_calendar_substitute_operating_period?: {
      __typename?: 'timetables_service_calendar_substitute_operating_period_mutation_response';
      returning: Array<{
        __typename?: 'timetables_service_calendar_substitute_operating_period';
        substitute_operating_period_id: UUID;
        period_name: string;
        is_preset: boolean;
        substitute_operating_day_by_line_types: Array<{
          __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type';
          begin_time?: luxon.Duration | null;
          end_time?: luxon.Duration | null;
          substitute_day_of_week?: number | null;
          substitute_operating_day_by_line_type_id: UUID;
          superseded_date: luxon.DateTime;
          type_of_line: string;
        }>;
      }>;
    } | null;
  } | null;
};

export type DeleteSubstituteOperatingPeriodMutationVariables = Exact<{
  ids: Array<Scalars['uuid']> | Scalars['uuid'];
}>;

export type DeleteSubstituteOperatingPeriodMutation = {
  __typename?: 'mutation_root';
  timetables?: {
    __typename?: 'timetables_timetables_mutation_frontend';
    timetables_delete_service_calendar_substitute_operating_period?: {
      __typename?: 'timetables_service_calendar_substitute_operating_period_mutation_response';
      affected_rows: number;
    } | null;
  } | null;
};

export type EditSubstituteOperatingPeriodsMutationVariables = Exact<{
  periodsToInsert:
    | Array<TimetablesServiceCalendarSubstituteOperatingPeriodInsertInput>
    | TimetablesServiceCalendarSubstituteOperatingPeriodInsertInput;
  periodsToDelete: Array<Scalars['uuid']> | Scalars['uuid'];
  daysToInsert:
    | Array<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeInsertInput>
    | TimetablesServiceCalendarSubstituteOperatingDayByLineTypeInsertInput;
}>;

export type EditSubstituteOperatingPeriodsMutation = {
  __typename?: 'mutation_root';
  timetables?: {
    __typename?: 'timetables_timetables_mutation_frontend';
    timetables_insert_service_calendar_substitute_operating_period?: {
      __typename?: 'timetables_service_calendar_substitute_operating_period_mutation_response';
      affected_rows: number;
    } | null;
    timetables_delete_service_calendar_substitute_operating_day_by_line_type?: {
      __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_mutation_response';
      affected_rows: number;
    } | null;
    timetables_insert_service_calendar_substitute_operating_day_by_line_type?: {
      __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_mutation_response';
      affected_rows: number;
    } | null;
  } | null;
};

export type GetSubstituteOperatingPeriodsQueryVariables = Exact<{
  periodFilters?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp>;
}>;

export type GetSubstituteOperatingPeriodsQuery = {
  __typename?: 'query_root';
  timetables?: {
    __typename?: 'timetables_timetables_query';
    timetables_service_calendar_substitute_operating_period: Array<{
      __typename?: 'timetables_service_calendar_substitute_operating_period';
      period_name: string;
      is_preset: boolean;
      substitute_operating_period_id: UUID;
      substitute_operating_day_by_line_types: Array<{
        __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type';
        begin_time?: luxon.Duration | null;
        end_time?: luxon.Duration | null;
        substitute_day_of_week?: number | null;
        substitute_operating_day_by_line_type_id: UUID;
        superseded_date: luxon.DateTime;
        type_of_line: string;
      }>;
    }>;
  } | null;
};

export type GetToCombineTargetVehicleScheduleFrameIdQueryVariables = Exact<{
  arg1: ToCombineTargetVehicleScheduleFrameIdInput;
}>;

export type GetToCombineTargetVehicleScheduleFrameIdQuery = {
  __typename?: 'query_root';
  toCombineTargetVehicleScheduleFrameId?: {
    __typename?: 'ToCombineTargetVehicleScheduleFrameIdOutput';
    toCombineTargetVehicleScheduleFrameId: UUID;
  } | null;
};

export type GetToReplaceVehicleScheduleFramesQueryVariables = Exact<{
  arg1: ToReplaceVehicleScheduleFrameIdsInput;
}>;

export type GetToReplaceVehicleScheduleFramesQuery = {
  __typename?: 'query_root';
  toReplaceVehicleScheduleFrameIds?: {
    __typename?: 'ToReplaceVehicleScheduleFrameIdsOutput';
    toReplaceVehicleScheduleFrameIds: Array<UUID | null>;
  } | null;
};

export type VehicleJourneyWithPatternAndRouteFragmentFragment = {
  __typename?: 'timetables_vehicle_journey_vehicle_journey';
  vehicle_journey_id: UUID;
  start_time: luxon.Duration;
  contract_number: string;
  journey_pattern_ref: {
    __typename?: 'timetables_journey_pattern_journey_pattern_ref';
    journey_pattern_ref_id: UUID;
    journey_pattern_instance?: {
      __typename?: 'journey_pattern_journey_pattern';
      journey_pattern_id: UUID;
      journey_pattern_route?: {
        __typename?: 'route_route';
        route_id: UUID;
        unique_label: string;
        direction: RouteDirectionEnum;
        variant?: number | null;
        name_i18n: LocalizedString;
        route_line: { __typename?: 'route_line'; line_id: UUID };
      } | null;
    } | null;
  };
};

export type GetVehicleScheduleFrameWithJourneyInfoQueryVariables = Exact<{
  vehicle_schedule_frame_ids: Array<Scalars['uuid']> | Scalars['uuid'];
}>;

export type GetVehicleScheduleFrameWithJourneyInfoQuery = {
  __typename?: 'query_root';
  timetables?: {
    __typename?: 'timetables_timetables_query';
    timetables_vehicle_schedule_vehicle_schedule_frame: Array<{
      __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame';
      vehicle_schedule_frame_id: UUID;
      validity_start: luxon.DateTime;
      validity_end: luxon.DateTime;
      vehicle_services: Array<{
        __typename?: 'timetables_vehicle_service_vehicle_service';
        vehicle_service_id: UUID;
        day_type: {
          __typename?: 'timetables_service_calendar_day_type';
          day_type_id: UUID;
          label: string;
          name_i18n: any;
        };
        blocks: Array<{
          __typename?: 'timetables_vehicle_service_block';
          block_id: UUID;
          vehicle_journeys: Array<{
            __typename?: 'timetables_vehicle_journey_vehicle_journey';
            vehicle_journey_id: UUID;
            start_time: luxon.Duration;
            contract_number: string;
            journey_pattern_ref: {
              __typename?: 'timetables_journey_pattern_journey_pattern_ref';
              journey_pattern_ref_id: UUID;
              journey_pattern_instance?: {
                __typename?: 'journey_pattern_journey_pattern';
                journey_pattern_id: UUID;
                journey_pattern_route?: {
                  __typename?: 'route_route';
                  route_id: UUID;
                  unique_label: string;
                  direction: RouteDirectionEnum;
                  variant?: number | null;
                  name_i18n: LocalizedString;
                  route_line: { __typename?: 'route_line'; line_id: UUID };
                } | null;
              } | null;
            };
          }>;
        }>;
      }>;
    }>;
  } | null;
};

export type GetVehicleScheduleFrameWithRouteAndLineInfoQueryVariables = Exact<{
  vehicle_schedule_frame_ids: Array<Scalars['uuid']> | Scalars['uuid'];
}>;

export type GetVehicleScheduleFrameWithRouteAndLineInfoQuery = {
  __typename?: 'query_root';
  timetables?: {
    __typename?: 'timetables_timetables_query';
    timetables_vehicle_schedule_vehicle_schedule_frame: Array<{
      __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame';
      vehicle_schedule_frame_id: UUID;
      vehicle_services: Array<{
        __typename?: 'timetables_vehicle_service_vehicle_service';
        vehicle_service_id: UUID;
        journey_patterns_in_vehicle_service: Array<{
          __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service';
          journey_pattern_id: UUID;
          journey_pattern_instance?: {
            __typename?: 'journey_pattern_journey_pattern';
            journey_pattern_id: UUID;
            journey_pattern_route?: {
              __typename?: 'route_route';
              route_id: UUID;
              unique_label: string;
              direction: RouteDirectionEnum;
              variant?: number | null;
              name_i18n: LocalizedString;
              route_line: { __typename?: 'route_line'; line_id: UUID };
            } | null;
          } | null;
        }>;
      }>;
    }>;
  } | null;
};

export type VehicleJourneyWithRouteInfoFragment = {
  __typename?: 'timetables_vehicle_journey_vehicle_journey';
  start_time: luxon.Duration;
  end_time: luxon.Duration;
  contract_number: string;
  vehicle_journey_id: UUID;
  journey_pattern_ref: {
    __typename?: 'timetables_journey_pattern_journey_pattern_ref';
    journey_pattern_ref_id: UUID;
    journey_pattern_instance?: {
      __typename?: 'journey_pattern_journey_pattern';
      journey_pattern_id: UUID;
      journey_pattern_route?: {
        __typename?: 'route_route';
        direction: RouteDirectionEnum;
        name_i18n: LocalizedString;
        description_i18n?: LocalizedString | null;
        origin_name_i18n: LocalizedString;
        origin_short_name_i18n: LocalizedString;
        destination_name_i18n: LocalizedString;
        destination_short_name_i18n: LocalizedString;
        on_line_id: UUID;
        label: string;
        variant?: number | null;
        route_id: UUID;
        validity_start?: luxon.DateTime | null;
        validity_end?: luxon.DateTime | null;
        priority: number;
      } | null;
    } | null;
  };
};

export type VehicleServiceWithJourneysFragment = {
  __typename?: 'timetables_vehicle_service_vehicle_service';
  vehicle_service_id: UUID;
  name_i18n?: any | null;
  day_type: {
    __typename?: 'timetables_service_calendar_day_type';
    day_type_id: UUID;
    label: string;
    name_i18n: any;
  };
  blocks: Array<{
    __typename?: 'timetables_vehicle_service_block';
    block_id: UUID;
    vehicle_journeys: Array<{
      __typename?: 'timetables_vehicle_journey_vehicle_journey';
      start_time: luxon.Duration;
      end_time: luxon.Duration;
      contract_number: string;
      vehicle_journey_id: UUID;
      journey_pattern_ref: {
        __typename?: 'timetables_journey_pattern_journey_pattern_ref';
        journey_pattern_ref_id: UUID;
        journey_pattern_instance?: {
          __typename?: 'journey_pattern_journey_pattern';
          journey_pattern_id: UUID;
          journey_pattern_route?: {
            __typename?: 'route_route';
            direction: RouteDirectionEnum;
            name_i18n: LocalizedString;
            description_i18n?: LocalizedString | null;
            origin_name_i18n: LocalizedString;
            origin_short_name_i18n: LocalizedString;
            destination_name_i18n: LocalizedString;
            destination_short_name_i18n: LocalizedString;
            on_line_id: UUID;
            label: string;
            variant?: number | null;
            route_id: UUID;
            validity_start?: luxon.DateTime | null;
            validity_end?: luxon.DateTime | null;
            priority: number;
          } | null;
        } | null;
      };
    }>;
    vehicle_type?: {
      __typename?: 'timetables_vehicle_type_vehicle_type';
      vehicle_type_id: UUID;
      description_i18n?: any | null;
    } | null;
  }>;
};

export type VehicleScheduleFrameWithRouteInfoFragment = {
  __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame';
  label: string;
  validity_end: luxon.DateTime;
  validity_start: luxon.DateTime;
  name_i18n?: any | null;
  vehicle_schedule_frame_id: UUID;
  priority: number;
  vehicle_services: Array<{
    __typename?: 'timetables_vehicle_service_vehicle_service';
    vehicle_service_id: UUID;
    name_i18n?: any | null;
    day_type: {
      __typename?: 'timetables_service_calendar_day_type';
      day_type_id: UUID;
      label: string;
      name_i18n: any;
    };
    blocks: Array<{
      __typename?: 'timetables_vehicle_service_block';
      block_id: UUID;
      vehicle_journeys: Array<{
        __typename?: 'timetables_vehicle_journey_vehicle_journey';
        start_time: luxon.Duration;
        end_time: luxon.Duration;
        contract_number: string;
        vehicle_journey_id: UUID;
        journey_pattern_ref: {
          __typename?: 'timetables_journey_pattern_journey_pattern_ref';
          journey_pattern_ref_id: UUID;
          journey_pattern_instance?: {
            __typename?: 'journey_pattern_journey_pattern';
            journey_pattern_id: UUID;
            journey_pattern_route?: {
              __typename?: 'route_route';
              direction: RouteDirectionEnum;
              name_i18n: LocalizedString;
              description_i18n?: LocalizedString | null;
              origin_name_i18n: LocalizedString;
              origin_short_name_i18n: LocalizedString;
              destination_name_i18n: LocalizedString;
              destination_short_name_i18n: LocalizedString;
              on_line_id: UUID;
              label: string;
              variant?: number | null;
              route_id: UUID;
              validity_start?: luxon.DateTime | null;
              validity_end?: luxon.DateTime | null;
              priority: number;
            } | null;
          } | null;
        };
      }>;
      vehicle_type?: {
        __typename?: 'timetables_vehicle_type_vehicle_type';
        vehicle_type_id: UUID;
        description_i18n?: any | null;
      } | null;
    }>;
  }>;
};

export type GetStagingVehicleScheduleFramesQueryVariables = Exact<{
  [key: string]: never;
}>;

export type GetStagingVehicleScheduleFramesQuery = {
  __typename?: 'query_root';
  timetables?: {
    __typename?: 'timetables_timetables_query';
    timetables_vehicle_schedule_vehicle_schedule_frame: Array<{
      __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame';
      label: string;
      validity_end: luxon.DateTime;
      validity_start: luxon.DateTime;
      name_i18n?: any | null;
      vehicle_schedule_frame_id: UUID;
      priority: number;
      vehicle_services: Array<{
        __typename?: 'timetables_vehicle_service_vehicle_service';
        vehicle_service_id: UUID;
        name_i18n?: any | null;
        day_type: {
          __typename?: 'timetables_service_calendar_day_type';
          day_type_id: UUID;
          label: string;
          name_i18n: any;
        };
        blocks: Array<{
          __typename?: 'timetables_vehicle_service_block';
          block_id: UUID;
          vehicle_journeys: Array<{
            __typename?: 'timetables_vehicle_journey_vehicle_journey';
            start_time: luxon.Duration;
            end_time: luxon.Duration;
            contract_number: string;
            vehicle_journey_id: UUID;
            journey_pattern_ref: {
              __typename?: 'timetables_journey_pattern_journey_pattern_ref';
              journey_pattern_ref_id: UUID;
              journey_pattern_instance?: {
                __typename?: 'journey_pattern_journey_pattern';
                journey_pattern_id: UUID;
                journey_pattern_route?: {
                  __typename?: 'route_route';
                  direction: RouteDirectionEnum;
                  name_i18n: LocalizedString;
                  description_i18n?: LocalizedString | null;
                  origin_name_i18n: LocalizedString;
                  origin_short_name_i18n: LocalizedString;
                  destination_name_i18n: LocalizedString;
                  destination_short_name_i18n: LocalizedString;
                  on_line_id: UUID;
                  label: string;
                  variant?: number | null;
                  route_id: UUID;
                  validity_start?: luxon.DateTime | null;
                  validity_end?: luxon.DateTime | null;
                  priority: number;
                } | null;
              } | null;
            };
          }>;
          vehicle_type?: {
            __typename?: 'timetables_vehicle_type_vehicle_type';
            vehicle_type_id: UUID;
            description_i18n?: any | null;
          } | null;
        }>;
      }>;
    }>;
  } | null;
};

export type ChangeStagingVehicleScheduleFramePriorityMutationVariables = Exact<{
  newPriority: Scalars['Int'];
}>;

export type ChangeStagingVehicleScheduleFramePriorityMutation = {
  __typename?: 'mutation_root';
  timetables?: {
    __typename?: 'timetables_timetables_mutation_frontend';
    timetables_update_vehicle_schedule_vehicle_schedule_frame?: {
      __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_mutation_response';
      returning: Array<{
        __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame';
        priority: number;
        validity_end: luxon.DateTime;
        validity_start: luxon.DateTime;
        name_i18n?: any | null;
        vehicle_schedule_frame_id: UUID;
      }>;
    } | null;
  } | null;
};

export type CombineTimetablesMutationVariables = Exact<{
  stagingVehicleScheduleFrameIds:
    | Array<InputMaybe<Scalars['uuid']>>
    | InputMaybe<Scalars['uuid']>;
  targetPriority: Scalars['Int'];
}>;

export type CombineTimetablesMutation = {
  __typename?: 'mutation_root';
  combineTimetables?: {
    __typename?: 'CombineTimetablesOutput';
    combinedIntoVehicleScheduleFrameIds: Array<UUID | null>;
  } | null;
};

export type ReplaceTimetablesMutationVariables = Exact<{
  stagingVehicleScheduleFrameIds:
    | Array<InputMaybe<Scalars['uuid']>>
    | InputMaybe<Scalars['uuid']>;
  targetPriority: Scalars['Int'];
}>;

export type ReplaceTimetablesMutation = {
  __typename?: 'mutation_root';
  replaceTimetables?: {
    __typename?: 'ReplaceTimetablesOutput';
    replacedVehicleScheduleFrameIds: Array<UUID | null>;
  } | null;
};

export type DeleteStagingTimetablesMutationVariables = Exact<{
  stagingVehicleScheduleFrameIds?: InputMaybe<
    Array<Scalars['uuid']> | Scalars['uuid']
  >;
}>;

export type DeleteStagingTimetablesMutation = {
  __typename?: 'mutation_root';
  timetables?: {
    __typename?: 'timetables_timetables_mutation_frontend';
    timetables_delete_vehicle_schedule_vehicle_schedule_frame?: {
      __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_mutation_response';
      returning: Array<{
        __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame';
        vehicle_schedule_frame_id: UUID;
      }>;
    } | null;
  } | null;
};

export type NewTimingPlaceFragment = {
  __typename?: 'timing_pattern_timing_place';
  label: string;
  description?: any | null;
};

export type CreatedTimingPlaceFragment = {
  __typename?: 'timing_pattern_timing_place';
  timing_place_id: UUID;
  label: string;
  description?: any | null;
};

export type InsertTimingPlaceMutationVariables = Exact<{
  object: TimingPatternTimingPlaceInsertInput;
}>;

export type InsertTimingPlaceMutation = {
  __typename?: 'mutation_root';
  insert_timing_pattern_timing_place_one?: {
    __typename?: 'timing_pattern_timing_place';
    timing_place_id: UUID;
    label: string;
    description?: any | null;
  } | null;
};

export type GetTimingPlacesByLabelQueryVariables = Exact<{
  label: Scalars['String'];
}>;

export type GetTimingPlacesByLabelQuery = {
  __typename?: 'query_root';
  timing_pattern_timing_place: Array<{
    __typename?: 'timing_pattern_timing_place';
    timing_place_id: UUID;
    label: string;
    description?: any | null;
  }>;
};

export type GetLinesForComboboxQueryVariables = Exact<{
  labelPattern: Scalars['String'];
  date: Scalars['date'];
}>;

export type GetLinesForComboboxQuery = {
  __typename?: 'query_root';
  route_line: Array<{
    __typename?: 'route_line';
    line_id: UUID;
    name_i18n: LocalizedString;
    label: string;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
  }>;
};

export type GetSelectedLineDetailsByIdQueryVariables = Exact<{
  line_id: Scalars['uuid'];
}>;

export type GetSelectedLineDetailsByIdQuery = {
  __typename?: 'query_root';
  route_line_by_pk?: {
    __typename?: 'route_line';
    line_id: UUID;
    name_i18n: LocalizedString;
    label: string;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
  } | null;
};

export type LineForComboboxFragment = {
  __typename?: 'route_line';
  line_id: UUID;
  name_i18n: LocalizedString;
  label: string;
  validity_start?: luxon.DateTime | null;
  validity_end?: luxon.DateTime | null;
};

export type GetRouteDetailsByLabelWildcardQueryVariables = Exact<{
  labelPattern: Scalars['String'];
  date?: InputMaybe<Scalars['date']>;
  priorities?: InputMaybe<Array<Scalars['Int']> | Scalars['Int']>;
}>;

export type GetRouteDetailsByLabelWildcardQuery = {
  __typename?: 'query_root';
  route_route: Array<{
    __typename?: 'route_route';
    route_shape?: GeoJSON.LineString | null;
    name_i18n: LocalizedString;
    description_i18n?: LocalizedString | null;
    origin_name_i18n: LocalizedString;
    origin_short_name_i18n: LocalizedString;
    destination_name_i18n: LocalizedString;
    destination_short_name_i18n: LocalizedString;
    on_line_id: UUID;
    label: string;
    direction: RouteDirectionEnum;
    variant?: number | null;
    route_id: UUID;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    priority: number;
  }>;
};

export type GetSelectedRouteDetailsByIdQueryVariables = Exact<{
  routeId: Scalars['uuid'];
}>;

export type GetSelectedRouteDetailsByIdQuery = {
  __typename?: 'query_root';
  route_route_by_pk?: {
    __typename?: 'route_route';
    route_shape?: GeoJSON.LineString | null;
    name_i18n: LocalizedString;
    description_i18n?: LocalizedString | null;
    origin_name_i18n: LocalizedString;
    origin_short_name_i18n: LocalizedString;
    destination_name_i18n: LocalizedString;
    destination_short_name_i18n: LocalizedString;
    on_line_id: UUID;
    label: string;
    direction: RouteDirectionEnum;
    variant?: number | null;
    route_id: UUID;
    validity_start?: luxon.DateTime | null;
    validity_end?: luxon.DateTime | null;
    priority: number;
  } | null;
};

export type GetTimingPlacesForComboboxQueryVariables = Exact<{
  labelPattern: Scalars['String'];
}>;

export type GetTimingPlacesForComboboxQuery = {
  __typename?: 'query_root';
  timing_pattern_timing_place: Array<{
    __typename?: 'timing_pattern_timing_place';
    timing_place_id: UUID;
    label: string;
    description?: any | null;
  }>;
};

export type GetSelectedTimingPlaceDetailsByIdQueryVariables = Exact<{
  timing_place_id: Scalars['uuid'];
}>;

export type GetSelectedTimingPlaceDetailsByIdQuery = {
  __typename?: 'query_root';
  timing_pattern_timing_place_by_pk?: {
    __typename?: 'timing_pattern_timing_place';
    timing_place_id: UUID;
    label: string;
    description?: any | null;
  } | null;
};

export type TimingPlaceForComboboxFragment = {
  __typename?: 'timing_pattern_timing_place';
  timing_place_id: UUID;
  label: string;
  description?: any | null;
};

export type RouteInfoForTimetableVersionFragment = {
  __typename?: 'route_route';
  route_id: UUID;
  label: string;
  variant?: number | null;
  validity_start?: luxon.DateTime | null;
  priority: number;
  validity_end?: luxon.DateTime | null;
  route_journey_patterns: Array<{
    __typename?: 'journey_pattern_journey_pattern';
    journey_pattern_id: UUID;
  }>;
};

export type GetRouteInfoForTimetableVersionsQueryVariables = Exact<{
  routeFilters?: InputMaybe<RouteRouteBoolExp>;
}>;

export type GetRouteInfoForTimetableVersionsQuery = {
  __typename?: 'query_root';
  route_route: Array<{
    __typename?: 'route_route';
    route_id: UUID;
    label: string;
    variant?: number | null;
    validity_start?: luxon.DateTime | null;
    priority: number;
    validity_end?: luxon.DateTime | null;
    route_journey_patterns: Array<{
      __typename?: 'journey_pattern_journey_pattern';
      journey_pattern_id: UUID;
    }>;
  }>;
};

export type TimetableVersionFragment = {
  __typename?: 'timetables_return_value_timetable_version';
  validity_start: luxon.DateTime;
  validity_end: luxon.DateTime;
  priority: number;
  in_effect: boolean;
  day_type?: {
    __typename?: 'timetables_service_calendar_day_type';
    day_type_id: UUID;
    name_i18n: any;
    label: string;
  } | null;
  substitute_operating_day_by_line_type?: {
    __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type';
    substitute_operating_day_by_line_type_id: UUID;
    superseded_date: luxon.DateTime;
    substitute_day_of_week?: number | null;
  } | null;
  vehicle_schedule_frame?: {
    __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame';
    vehicle_schedule_frame_id: UUID;
    name_i18n?: any | null;
  } | null;
};

export type GetTimetableVersionsByJourneyPatternIdsQueryVariables = Exact<{
  journey_pattern_ids?: InputMaybe<Scalars['_uuid']>;
  start_date?: InputMaybe<Scalars['date']>;
  end_date?: InputMaybe<Scalars['date']>;
  observation_date?: InputMaybe<Scalars['date']>;
}>;

export type GetTimetableVersionsByJourneyPatternIdsQuery = {
  __typename?: 'query_root';
  timetables?: {
    __typename?: 'timetables_timetables_query';
    timetables_vehicle_service_get_timetable_versions_by_journey_pattern_ids: Array<{
      __typename?: 'timetables_return_value_timetable_version';
      validity_start: luxon.DateTime;
      validity_end: luxon.DateTime;
      priority: number;
      in_effect: boolean;
      day_type?: {
        __typename?: 'timetables_service_calendar_day_type';
        day_type_id: UUID;
        name_i18n: any;
        label: string;
      } | null;
      substitute_operating_day_by_line_type?: {
        __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type';
        substitute_operating_day_by_line_type_id: UUID;
        superseded_date: luxon.DateTime;
        substitute_day_of_week?: number | null;
      } | null;
      vehicle_schedule_frame?: {
        __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame';
        vehicle_schedule_frame_id: UUID;
        name_i18n?: any | null;
      } | null;
    }>;
  } | null;
};

export type RouteMapParamsFragment = {
  __typename?: 'route_route';
  route_id: UUID;
  label: string;
  route_shape?: GeoJSON.LineString | null;
  validity_start?: luxon.DateTime | null;
  validity_end?: luxon.DateTime | null;
};

export type LineMapParamsFragment = {
  __typename?: 'route_line';
  line_id: UUID;
  label: string;
  validity_start?: luxon.DateTime | null;
  validity_end?: luxon.DateTime | null;
  line_routes: Array<{
    __typename?: 'route_route';
    route_id: UUID;
    route_shape?: GeoJSON.LineString | null;
  }>;
};

export type DeleteVehicleScheduleFrameMutationVariables = Exact<{
  vehicle_schedule_frame_id: Scalars['uuid'];
}>;

export type DeleteVehicleScheduleFrameMutation = {
  __typename?: 'mutation_root';
  timetables?: {
    __typename?: 'timetables_timetables_mutation_frontend';
    timetables_delete_vehicle_schedule_vehicle_schedule_frame_by_pk?: {
      __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame';
      vehicle_schedule_frame_id: UUID;
    } | null;
  } | null;
};

export type GetVehicleScheduleFrameSchedulesQueryVariables = Exact<{
  vehicle_schedule_frame_id: Scalars['uuid'];
}>;

export type GetVehicleScheduleFrameSchedulesQuery = {
  __typename?: 'query_root';
  timetables?: {
    __typename?: 'timetables_timetables_query';
    timetables_vehicle_schedule_vehicle_schedule_frame_by_pk?: {
      __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame';
      vehicle_schedule_frame_id: UUID;
      validity_start: luxon.DateTime;
      validity_end: luxon.DateTime;
      priority: number;
      created_at: luxon.DateTime;
      vehicle_services: Array<{
        __typename?: 'timetables_vehicle_service_vehicle_service';
        vehicle_service_id: UUID;
        day_type: {
          __typename?: 'timetables_service_calendar_day_type';
          day_type_id: UUID;
          label: string;
          name_i18n: any;
        };
        blocks: Array<{
          __typename?: 'timetables_vehicle_service_block';
          block_id: UUID;
          vehicle_journeys: Array<{
            __typename?: 'timetables_vehicle_journey_vehicle_journey';
            vehicle_journey_id: UUID;
            start_time: luxon.Duration;
            journey_pattern_ref: {
              __typename?: 'timetables_journey_pattern_journey_pattern_ref';
              journey_pattern_ref_id: UUID;
              journey_pattern_instance?: {
                __typename?: 'journey_pattern_journey_pattern';
                journey_pattern_id: UUID;
                journey_pattern_route?: {
                  __typename?: 'route_route';
                  route_id: UUID;
                  unique_label: string;
                  direction: RouteDirectionEnum;
                  name_i18n: LocalizedString;
                } | null;
              } | null;
            };
          }>;
        }>;
      }>;
    } | null;
  } | null;
};

export type VehicleJourneyWithStartTimeInfoFragment = {
  __typename?: 'timetables_vehicle_journey_vehicle_journey';
  vehicle_journey_id: UUID;
  start_time: luxon.Duration;
  journey_pattern_ref: {
    __typename?: 'timetables_journey_pattern_journey_pattern_ref';
    journey_pattern_ref_id: UUID;
    journey_pattern_instance?: {
      __typename?: 'journey_pattern_journey_pattern';
      journey_pattern_id: UUID;
      journey_pattern_route?: {
        __typename?: 'route_route';
        route_id: UUID;
        unique_label: string;
        direction: RouteDirectionEnum;
        name_i18n: LocalizedString;
      } | null;
    } | null;
  };
};

export type VehicleScheduleFrameWithRoutesFragment = {
  __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame';
  vehicle_schedule_frame_id: UUID;
  validity_start: luxon.DateTime;
  validity_end: luxon.DateTime;
  vehicle_services: Array<{
    __typename?: 'timetables_vehicle_service_vehicle_service';
    vehicle_service_id: UUID;
    journey_patterns_in_vehicle_service: Array<{
      __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service';
      journey_pattern_instance?: {
        __typename?: 'journey_pattern_journey_pattern';
        journey_pattern_id: UUID;
        journey_pattern_route?: {
          __typename?: 'route_route';
          route_id: UUID;
          label: string;
        } | null;
      } | null;
    }>;
  }>;
};

export type GetVehicleScheduleFrameWithRoutesQueryVariables = Exact<{
  vehicle_schedule_frame_id: Scalars['uuid'];
}>;

export type GetVehicleScheduleFrameWithRoutesQuery = {
  __typename?: 'query_root';
  timetables?: {
    __typename?: 'timetables_timetables_query';
    timetables_vehicle_schedule_vehicle_schedule_frame: Array<{
      __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame';
      vehicle_schedule_frame_id: UUID;
      validity_start: luxon.DateTime;
      validity_end: luxon.DateTime;
      vehicle_services: Array<{
        __typename?: 'timetables_vehicle_service_vehicle_service';
        vehicle_service_id: UUID;
        journey_patterns_in_vehicle_service: Array<{
          __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service';
          journey_pattern_instance?: {
            __typename?: 'journey_pattern_journey_pattern';
            journey_pattern_id: UUID;
            journey_pattern_route?: {
              __typename?: 'route_route';
              route_id: UUID;
              label: string;
            } | null;
          } | null;
        }>;
      }>;
    }>;
  } | null;
};

export type UpdateVehicleScheduleFrameValidityMutationVariables = Exact<{
  vehicle_schedule_frame_id: Scalars['uuid'];
  validity_start?: InputMaybe<Scalars['date']>;
  validity_end?: InputMaybe<Scalars['date']>;
}>;

export type UpdateVehicleScheduleFrameValidityMutation = {
  __typename?: 'mutation_root';
  timetables?: {
    __typename?: 'timetables_timetables_mutation_frontend';
    timetables_update_vehicle_schedule_vehicle_schedule_frame?: {
      __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_mutation_response';
      returning: Array<{
        __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame';
        vehicle_schedule_frame_id: UUID;
        validity_start: luxon.DateTime;
        validity_end: luxon.DateTime;
      }>;
    } | null;
  } | null;
};

export type DayTypeAllFieldsFragment = {
  __typename?: 'timetables_service_calendar_day_type';
  day_type_id: UUID;
  label: string;
  name_i18n: any;
};

export type VehicleJourneyWithServiceFragment = {
  __typename?: 'timetables_vehicle_journey_vehicle_journey';
  vehicle_journey_id: UUID;
  start_time: luxon.Duration;
  end_time: luxon.Duration;
  journey_pattern_ref_id: UUID;
  journey_pattern_ref: {
    __typename?: 'timetables_journey_pattern_journey_pattern_ref';
    journey_pattern_ref_id: UUID;
    journey_pattern_id: UUID;
  };
  block: {
    __typename?: 'timetables_vehicle_service_block';
    block_id: UUID;
    vehicle_service_id: UUID;
    vehicle_service: {
      __typename?: 'timetables_vehicle_service_vehicle_service';
      vehicle_service_id: UUID;
      day_type_id: UUID;
      vehicle_schedule_frame: {
        __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame';
        vehicle_schedule_frame_id: UUID;
        validity_end: luxon.DateTime;
        validity_start: luxon.DateTime;
        priority: number;
        name_i18n?: any | null;
        created_at: luxon.DateTime;
      };
      day_type: {
        __typename?: 'timetables_service_calendar_day_type';
        day_type_id: UUID;
        label: string;
        name_i18n: any;
      };
    };
  };
  timetabled_passing_times: Array<{
    __typename?: 'timetables_passing_times_timetabled_passing_time';
    arrival_time?: luxon.Duration | null;
    departure_time?: luxon.Duration | null;
    passing_time: luxon.Duration;
    scheduled_stop_point_in_journey_pattern_ref_id: UUID;
    timetabled_passing_time_id: UUID;
    vehicle_journey_id: UUID;
    scheduled_stop_point_in_journey_pattern_ref: {
      __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref';
      scheduled_stop_point_in_journey_pattern_ref_id: UUID;
      scheduled_stop_point_label: string;
      journey_pattern_ref: {
        __typename?: 'timetables_journey_pattern_journey_pattern_ref';
        journey_pattern_ref_id: UUID;
        observation_timestamp: luxon.DateTime;
      };
      scheduled_stop_point_instances: Array<{
        __typename?: 'service_pattern_scheduled_stop_point';
        priority: number;
        direction: InfrastructureNetworkDirectionEnum;
        scheduled_stop_point_id: UUID;
        label: string;
        timing_place_id?: UUID | null;
        validity_start?: luxon.DateTime | null;
        validity_end?: luxon.DateTime | null;
        located_on_infrastructure_link_id: UUID;
        timing_place?: {
          __typename?: 'timing_pattern_timing_place';
          label: string;
          timing_place_id: UUID;
        } | null;
      }>;
    };
    vehicle_journey: {
      __typename?: 'timetables_vehicle_journey_vehicle_journey';
      vehicle_journey_id: UUID;
      block: {
        __typename?: 'timetables_vehicle_service_block';
        block_id: UUID;
        vehicle_type?: {
          __typename?: 'timetables_vehicle_type_vehicle_type';
          description_i18n?: any | null;
          vehicle_type_id: UUID;
        } | null;
      };
    };
  }>;
};

export type VehicleScheduleFragment = {
  __typename?: 'timetables_return_value_vehicle_schedule';
  priority: number;
  validity_start: luxon.DateTime;
  validity_end: luxon.DateTime;
  created_at?: luxon.DateTime | null;
  vehicle_schedule_frame_id?: UUID | null;
  vehicle_journey?: {
    __typename?: 'timetables_vehicle_journey_vehicle_journey';
    vehicle_journey_id: UUID;
    start_time: luxon.Duration;
    end_time: luxon.Duration;
    journey_pattern_ref_id: UUID;
    journey_pattern_ref: {
      __typename?: 'timetables_journey_pattern_journey_pattern_ref';
      journey_pattern_ref_id: UUID;
      journey_pattern_id: UUID;
    };
    block: {
      __typename?: 'timetables_vehicle_service_block';
      block_id: UUID;
      vehicle_service_id: UUID;
      vehicle_service: {
        __typename?: 'timetables_vehicle_service_vehicle_service';
        vehicle_service_id: UUID;
        day_type_id: UUID;
        vehicle_schedule_frame: {
          __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame';
          vehicle_schedule_frame_id: UUID;
          validity_end: luxon.DateTime;
          validity_start: luxon.DateTime;
          priority: number;
          name_i18n?: any | null;
          created_at: luxon.DateTime;
        };
        day_type: {
          __typename?: 'timetables_service_calendar_day_type';
          day_type_id: UUID;
          label: string;
          name_i18n: any;
        };
      };
    };
    timetabled_passing_times: Array<{
      __typename?: 'timetables_passing_times_timetabled_passing_time';
      arrival_time?: luxon.Duration | null;
      departure_time?: luxon.Duration | null;
      passing_time: luxon.Duration;
      scheduled_stop_point_in_journey_pattern_ref_id: UUID;
      timetabled_passing_time_id: UUID;
      vehicle_journey_id: UUID;
      scheduled_stop_point_in_journey_pattern_ref: {
        __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref';
        scheduled_stop_point_in_journey_pattern_ref_id: UUID;
        scheduled_stop_point_label: string;
        journey_pattern_ref: {
          __typename?: 'timetables_journey_pattern_journey_pattern_ref';
          journey_pattern_ref_id: UUID;
          observation_timestamp: luxon.DateTime;
        };
        scheduled_stop_point_instances: Array<{
          __typename?: 'service_pattern_scheduled_stop_point';
          priority: number;
          direction: InfrastructureNetworkDirectionEnum;
          scheduled_stop_point_id: UUID;
          label: string;
          timing_place_id?: UUID | null;
          validity_start?: luxon.DateTime | null;
          validity_end?: luxon.DateTime | null;
          located_on_infrastructure_link_id: UUID;
          timing_place?: {
            __typename?: 'timing_pattern_timing_place';
            label: string;
            timing_place_id: UUID;
          } | null;
        }>;
      };
      vehicle_journey: {
        __typename?: 'timetables_vehicle_journey_vehicle_journey';
        vehicle_journey_id: UUID;
        block: {
          __typename?: 'timetables_vehicle_service_block';
          block_id: UUID;
          vehicle_type?: {
            __typename?: 'timetables_vehicle_type_vehicle_type';
            description_i18n?: any | null;
            vehicle_type_id: UUID;
          } | null;
        };
      };
    }>;
  } | null;
  day_type?: {
    __typename?: 'timetables_service_calendar_day_type';
    day_type_id: UUID;
    label: string;
    name_i18n: any;
  } | null;
};

export type GetVehicleSchedulesForDateQueryVariables = Exact<{
  journey_pattern_id: Scalars['uuid'];
  observation_date: Scalars['date'];
}>;

export type GetVehicleSchedulesForDateQuery = {
  __typename?: 'query_root';
  timetables?: {
    __typename?: 'timetables_timetables_query';
    timetables_vehicle_journey_get_vehicle_schedules_on_date: Array<{
      __typename?: 'timetables_return_value_vehicle_schedule';
      priority: number;
      validity_start: luxon.DateTime;
      validity_end: luxon.DateTime;
      created_at?: luxon.DateTime | null;
      vehicle_schedule_frame_id?: UUID | null;
      vehicle_journey?: {
        __typename?: 'timetables_vehicle_journey_vehicle_journey';
        vehicle_journey_id: UUID;
        start_time: luxon.Duration;
        end_time: luxon.Duration;
        journey_pattern_ref_id: UUID;
        journey_pattern_ref: {
          __typename?: 'timetables_journey_pattern_journey_pattern_ref';
          journey_pattern_ref_id: UUID;
          journey_pattern_id: UUID;
        };
        block: {
          __typename?: 'timetables_vehicle_service_block';
          block_id: UUID;
          vehicle_service_id: UUID;
          vehicle_service: {
            __typename?: 'timetables_vehicle_service_vehicle_service';
            vehicle_service_id: UUID;
            day_type_id: UUID;
            vehicle_schedule_frame: {
              __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame';
              vehicle_schedule_frame_id: UUID;
              validity_end: luxon.DateTime;
              validity_start: luxon.DateTime;
              priority: number;
              name_i18n?: any | null;
              created_at: luxon.DateTime;
            };
            day_type: {
              __typename?: 'timetables_service_calendar_day_type';
              day_type_id: UUID;
              label: string;
              name_i18n: any;
            };
          };
        };
        timetabled_passing_times: Array<{
          __typename?: 'timetables_passing_times_timetabled_passing_time';
          arrival_time?: luxon.Duration | null;
          departure_time?: luxon.Duration | null;
          passing_time: luxon.Duration;
          scheduled_stop_point_in_journey_pattern_ref_id: UUID;
          timetabled_passing_time_id: UUID;
          vehicle_journey_id: UUID;
          scheduled_stop_point_in_journey_pattern_ref: {
            __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref';
            scheduled_stop_point_in_journey_pattern_ref_id: UUID;
            scheduled_stop_point_label: string;
            journey_pattern_ref: {
              __typename?: 'timetables_journey_pattern_journey_pattern_ref';
              journey_pattern_ref_id: UUID;
              observation_timestamp: luxon.DateTime;
            };
            scheduled_stop_point_instances: Array<{
              __typename?: 'service_pattern_scheduled_stop_point';
              priority: number;
              direction: InfrastructureNetworkDirectionEnum;
              scheduled_stop_point_id: UUID;
              label: string;
              timing_place_id?: UUID | null;
              validity_start?: luxon.DateTime | null;
              validity_end?: luxon.DateTime | null;
              located_on_infrastructure_link_id: UUID;
              timing_place?: {
                __typename?: 'timing_pattern_timing_place';
                label: string;
                timing_place_id: UUID;
              } | null;
            }>;
          };
          vehicle_journey: {
            __typename?: 'timetables_vehicle_journey_vehicle_journey';
            vehicle_journey_id: UUID;
            block: {
              __typename?: 'timetables_vehicle_service_block';
              block_id: UUID;
              vehicle_type?: {
                __typename?: 'timetables_vehicle_type_vehicle_type';
                description_i18n?: any | null;
                vehicle_type_id: UUID;
              } | null;
            };
          };
        }>;
      } | null;
      day_type?: {
        __typename?: 'timetables_service_calendar_day_type';
        day_type_id: UUID;
        label: string;
        name_i18n: any;
      } | null;
    }>;
    timetables_service_calendar_get_active_day_types_for_date: Array<{
      __typename?: 'timetables_service_calendar_day_type';
      day_type_id: UUID;
    }>;
  } | null;
};

export type JourneyPatternStopFragment = {
  __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
  scheduled_stop_point_label: string;
  scheduled_stop_point_sequence: number;
  is_used_as_timing_point: boolean;
  is_via_point: boolean;
  via_point_name_i18n?: LocalizedString | null;
  via_point_short_name_i18n?: LocalizedString | null;
};

export const LineMapParamsFragmentDoc = gql`
  fragment line_map_params on route_line {
    line_id
    label
    validity_start
    validity_end
    line_routes {
      route_id
      route_shape
    }
  }
`;
export const RouteMapParamsFragmentDoc = gql`
  fragment route_map_params on route_route {
    route_id
    label
    route_shape
    validity_start
    validity_end
  }
`;
export const LineTableRowFragmentDoc = gql`
  fragment line_table_row on route_line {
    name_i18n
    short_name_i18n
    validity_start
    validity_end
    priority
    ...line_map_params
    line_routes {
      ...route_map_params
      unique_label
      direction
      route_journey_patterns {
        journey_pattern_id
        journey_pattern_refs {
          journey_pattern_ref_id
          vehicle_journeys {
            vehicle_journey_id
          }
        }
        scheduled_stop_point_in_journey_patterns {
          journey_pattern_id
          scheduled_stop_point_sequence
          is_used_as_timing_point
        }
      }
    }
  }
  ${LineMapParamsFragmentDoc}
  ${RouteMapParamsFragmentDoc}
`;
export const RouteTableRowFragmentDoc = gql`
  fragment route_table_row on route_route {
    ...route_map_params
    name_i18n
    direction
    priority
    on_line_id
    variant
    unique_label
    route_journey_patterns {
      journey_pattern_id
      journey_pattern_refs {
        journey_pattern_ref_id
        vehicle_journeys {
          vehicle_journey_id
        }
      }
      scheduled_stop_point_in_journey_patterns {
        journey_pattern_id
        scheduled_stop_point_sequence
        is_used_as_timing_point
      }
    }
  }
  ${RouteMapParamsFragmentDoc}
`;
export const LineDefaultFieldsFragmentDoc = gql`
  fragment line_default_fields on route_line {
    line_id
    label
    name_i18n
    short_name_i18n
    validity_start
    validity_end
    priority
  }
`;
export const LineAllFieldsFragmentDoc = gql`
  fragment line_all_fields on route_line {
    ...line_default_fields
    primary_vehicle_mode
    type_of_line
    transport_target
  }
  ${LineDefaultFieldsFragmentDoc}
`;
export const RouteValidityFragmentDoc = gql`
  fragment route_validity on route_route {
    validity_start
    validity_end
    priority
  }
`;
export const RouteUniqueFieldsFragmentDoc = gql`
  fragment route_unique_fields on route_route {
    ...route_validity
    label
    direction
    variant
    route_id
  }
  ${RouteValidityFragmentDoc}
`;
export const LineWithRoutesUniqueFieldsFragmentDoc = gql`
  fragment line_with_routes_unique_fields on route_line {
    ...line_all_fields
    line_routes(where: $lineRouteFilters) {
      ...route_unique_fields
    }
  }
  ${LineAllFieldsFragmentDoc}
  ${RouteUniqueFieldsFragmentDoc}
`;
export const ScheduledStopPointInJourneyPatternAllFieldsFragmentDoc = gql`
  fragment scheduled_stop_point_in_journey_pattern_all_fields on journey_pattern_scheduled_stop_point_in_journey_pattern {
    journey_pattern_id
    scheduled_stop_point_label
    scheduled_stop_point_sequence
    is_used_as_timing_point
    is_regulated_timing_point
    is_loading_time_allowed
    is_via_point
    via_point_name_i18n
    via_point_short_name_i18n
    journey_pattern {
      journey_pattern_id
      on_route_id
    }
  }
`;
export const ScheduledStopPointWithTimingSettingsFragmentDoc = gql`
  fragment scheduled_stop_point_with_timing_settings on journey_pattern_scheduled_stop_point_in_journey_pattern {
    ...scheduled_stop_point_in_journey_pattern_all_fields
    journey_pattern {
      journey_pattern_id
      journey_pattern_route {
        route_id
        label
      }
    }
    scheduled_stop_points {
      scheduled_stop_point_id
      timing_place_id
    }
  }
  ${ScheduledStopPointInJourneyPatternAllFieldsFragmentDoc}
`;
export const InfraLinkMatchingFieldsFragmentDoc = gql`
  fragment infra_link_matching_fields on infrastructure_network_infrastructure_link {
    external_link_id
    infrastructure_link_id
    shape
    direction
  }
`;
export const ScheduledStopPointDefaultFieldsFragmentDoc = gql`
  fragment scheduled_stop_point_default_fields on service_pattern_scheduled_stop_point {
    priority
    direction
    scheduled_stop_point_id
    label
    timing_place_id
    timing_place {
      timing_place_id
      label
    }
    validity_start
    validity_end
    located_on_infrastructure_link_id
  }
`;
export const ScheduledStopPointAllFieldsFragmentDoc = gql`
  fragment scheduled_stop_point_all_fields on service_pattern_scheduled_stop_point {
    ...scheduled_stop_point_default_fields
    measured_location
    relative_distance_from_infrastructure_link_start
    closest_point_on_infrastructure_link
    vehicle_mode_on_scheduled_stop_point {
      vehicle_mode
    }
  }
  ${ScheduledStopPointDefaultFieldsFragmentDoc}
`;
export const StopWithJourneyPatternFieldsFragmentDoc = gql`
  fragment stop_with_journey_pattern_fields on service_pattern_scheduled_stop_point {
    ...scheduled_stop_point_all_fields
    scheduled_stop_point_in_journey_patterns {
      ...scheduled_stop_point_in_journey_pattern_all_fields
    }
  }
  ${ScheduledStopPointAllFieldsFragmentDoc}
  ${ScheduledStopPointInJourneyPatternAllFieldsFragmentDoc}
`;
export const RouteStopFieldsFragmentDoc = gql`
  fragment route_stop_fields on service_pattern_scheduled_stop_point {
    ...stop_with_journey_pattern_fields
    other_label_instances {
      ...scheduled_stop_point_default_fields
    }
  }
  ${StopWithJourneyPatternFieldsFragmentDoc}
  ${ScheduledStopPointDefaultFieldsFragmentDoc}
`;
export const RouteInfraLinkFieldsFragmentDoc = gql`
  fragment route_infra_link_fields on infrastructure_network_infrastructure_link {
    ...infra_link_matching_fields
    external_link_source
    scheduled_stop_points_located_on_infrastructure_link {
      ...route_stop_fields
    }
  }
  ${InfraLinkMatchingFieldsFragmentDoc}
  ${RouteStopFieldsFragmentDoc}
`;
export const InfraLinkAlongRouteDefaultFieldsFragmentDoc = gql`
  fragment infra_link_along_route_default_fields on route_infrastructure_link_along_route {
    infrastructure_link_id
    infrastructure_link {
      infrastructure_link_id
    }
    is_traversal_forwards
  }
`;
export const RouteDefaultFieldsFragmentDoc = gql`
  fragment route_default_fields on route_route {
    ...route_unique_fields
    name_i18n
    description_i18n
    origin_name_i18n
    origin_short_name_i18n
    destination_name_i18n
    destination_short_name_i18n
    on_line_id
  }
  ${RouteUniqueFieldsFragmentDoc}
`;
export const RouteAllFieldsFragmentDoc = gql`
  fragment route_all_fields on route_route {
    ...route_default_fields
    route_shape
  }
  ${RouteDefaultFieldsFragmentDoc}
`;
export const RouteWithInfrastructureLinksFragmentDoc = gql`
  fragment route_with_infrastructure_links on route_route {
    ...route_all_fields
    route_line {
      ...line_all_fields
    }
    infrastructure_links_along_route {
      route_id
      infrastructure_link_sequence
      infrastructure_link_id
      infrastructure_link {
        infrastructure_link_id
        shape
        direction
        external_link_id
        external_link_source
      }
      is_traversal_forwards
    }
  }
  ${RouteAllFieldsFragmentDoc}
  ${LineAllFieldsFragmentDoc}
`;
export const InfrastructureLinkDefaultFieldsFragmentDoc = gql`
  fragment infrastructure_link_default_fields on infrastructure_network_infrastructure_link {
    infrastructure_link_id
  }
`;
export const InfrastructureLinkAllFieldsFragmentDoc = gql`
  fragment infrastructure_link_all_fields on infrastructure_network_infrastructure_link {
    ...infrastructure_link_default_fields
    direction
    shape
    estimated_length_in_metres
    external_link_id
    external_link_source
  }
  ${InfrastructureLinkDefaultFieldsFragmentDoc}
`;
export const InfrastructureLinkWithStopsFragmentDoc = gql`
  fragment infrastructure_link_with_stops on infrastructure_network_infrastructure_link {
    ...infrastructure_link_all_fields
    scheduled_stop_points_located_on_infrastructure_link(
      where: $routeStopFilters
    ) {
      ...scheduled_stop_point_all_fields
      other_label_instances {
        ...scheduled_stop_point_default_fields
      }
      scheduled_stop_point_in_journey_patterns {
        ...scheduled_stop_point_in_journey_pattern_all_fields
        journey_pattern {
          journey_pattern_id
          on_route_id
        }
      }
    }
  }
  ${InfrastructureLinkAllFieldsFragmentDoc}
  ${ScheduledStopPointAllFieldsFragmentDoc}
  ${ScheduledStopPointDefaultFieldsFragmentDoc}
  ${ScheduledStopPointInJourneyPatternAllFieldsFragmentDoc}
`;
export const InfraLinkAlongRouteWithStopsFragmentDoc = gql`
  fragment infra_link_along_route_with_stops on route_infrastructure_link_along_route {
    route_id
    infrastructure_link_sequence
    infrastructure_link_id
    infrastructure_link {
      ...infra_link_matching_fields
      external_link_source
      scheduled_stop_points_located_on_infrastructure_link {
        ...route_stop_fields
      }
    }
    is_traversal_forwards
  }
  ${InfraLinkMatchingFieldsFragmentDoc}
  ${RouteStopFieldsFragmentDoc}
`;
export const RouteWithInfrastructureLinksWithStopsFragmentDoc = gql`
  fragment route_with_infrastructure_links_with_stops on route_route {
    ...route_all_fields
    route_line {
      ...line_all_fields
    }
    infrastructure_links_along_route {
      ...infra_link_along_route_with_stops
    }
  }
  ${RouteAllFieldsFragmentDoc}
  ${LineAllFieldsFragmentDoc}
  ${InfraLinkAlongRouteWithStopsFragmentDoc}
`;
export const JourneyPatternWithStopsFragmentDoc = gql`
  fragment journey_pattern_with_stops on journey_pattern_journey_pattern {
    journey_pattern_id
    on_route_id
    ordered_scheduled_stop_point_in_journey_patterns: scheduled_stop_point_in_journey_patterns(
      order_by: { scheduled_stop_point_sequence: asc }
    ) {
      ...scheduled_stop_point_in_journey_pattern_all_fields
      scheduled_stop_points {
        ...scheduled_stop_point_default_fields
      }
    }
  }
  ${ScheduledStopPointInJourneyPatternAllFieldsFragmentDoc}
  ${ScheduledStopPointDefaultFieldsFragmentDoc}
`;
export const RouteWithJourneyPatternStopsFragmentDoc = gql`
  fragment route_with_journey_pattern_stops on route_route {
    ...route_all_fields
    route_journey_patterns {
      ...journey_pattern_with_stops
    }
  }
  ${RouteAllFieldsFragmentDoc}
  ${JourneyPatternWithStopsFragmentDoc}
`;
export const RouteWithInfrastructureLinksWithStopsAndJpsFragmentDoc = gql`
  fragment route_with_infrastructure_links_with_stops_and_jps on route_route {
    ...route_with_infrastructure_links_with_stops
    ...route_with_journey_pattern_stops
  }
  ${RouteWithInfrastructureLinksWithStopsFragmentDoc}
  ${RouteWithJourneyPatternStopsFragmentDoc}
`;
export const LineWithRoutesFragmentDoc = gql`
  fragment line_with_routes on route_line {
    ...line_all_fields
    line_routes(where: $lineRouteFilters) {
      ...route_with_infrastructure_links_with_stops_and_jps
    }
  }
  ${LineAllFieldsFragmentDoc}
  ${RouteWithInfrastructureLinksWithStopsAndJpsFragmentDoc}
`;
export const DisplayedRouteFragmentDoc = gql`
  fragment displayed_route on route_route {
    route_id
    label
    variant
    validity_start
    validity_end
    priority
    direction
    route_journey_patterns {
      journey_pattern_id
      scheduled_stop_point_in_journey_patterns {
        journey_pattern_id
        scheduled_stop_point_label
        scheduled_stop_point_sequence
      }
    }
  }
`;
export const RouteMetadataFragmentDoc = gql`
  fragment route_metadata on route_route {
    name_i18n
    label
    priority
    validity_start
    validity_end
    direction
    variant
  }
`;
export const StopTableRowStopPlaceFragmentDoc = gql`
  fragment stop_table_row_stop_place on stop_registry_StopPlace {
    id
    name {
      lang
      value
    }
    alternativeNames {
      nameType
      name {
        lang
        value
      }
    }
  }
`;
export const StopTableRowFragmentDoc = gql`
  fragment stop_table_row on service_pattern_scheduled_stop_point {
    scheduled_stop_point_id
    label
    validity_start
    validity_end
    timing_place_id
    timing_place {
      timing_place_id
      label
    }
    stop_place_ref
    stop_place {
      ...stop_table_row_stop_place
    }
  }
  ${StopTableRowStopPlaceFragmentDoc}
`;
export const ScheduledStopPointDetailFieldsFragmentDoc = gql`
  fragment scheduled_stop_point_detail_fields on service_pattern_scheduled_stop_point {
    priority
    direction
    scheduled_stop_point_id
    label
    timing_place_id
    timing_place {
      timing_place_id
      label
    }
    validity_start
    validity_end
    located_on_infrastructure_link_id
    stop_place_ref
    measured_location
  }
`;
export const QuayDetailsFragmentDoc = gql`
  fragment quay_details on stop_registry_Quay {
    id
    publicCode
    alternativeNames {
      name {
        lang
        value
      }
      nameType
    }
    placeEquipments {
      shelterEquipment {
        enclosed
        stepFree
      }
      cycleStorageEquipment {
        cycleStorageType
      }
    }
  }
`;
export const StopPlaceDetailsFragmentDoc = gql`
  fragment stop_place_details on stop_registry_StopPlace {
    id
    name {
      lang
      value
    }
    alternativeNames {
      name {
        lang
        value
      }
      nameType
    }
    keyValues {
      key
      values
    }
    transportMode
    weighting
    submode
    publicCode
    privateCode {
      value
      type
    }
    description {
      lang
      value
    }
    geometry {
      coordinates
      type
    }
    placeEquipments {
      generalSign {
        privateCode {
          value
          type
        }
        signContentType
        numberOfFrames
        lineSignage
        mainLineSign
        replacesRailSign
        note {
          lang
          value
        }
      }
    }
    quays {
      ...quay_details
    }
  }
  ${QuayDetailsFragmentDoc}
`;
export const VehicleJourneyWithPatternAndRouteFragmentFragmentDoc = gql`
  fragment vehicle_journey_with_pattern_and_route_fragment on timetables_vehicle_journey_vehicle_journey {
    vehicle_journey_id
    start_time
    contract_number
    journey_pattern_ref {
      journey_pattern_ref_id
      journey_pattern_instance {
        journey_pattern_id
        journey_pattern_route {
          route_id
          unique_label
          direction
          variant
          name_i18n
          route_line {
            line_id
          }
        }
      }
    }
  }
`;
export const DayTypeAllFieldsFragmentDoc = gql`
  fragment day_type_all_fields on timetables_service_calendar_day_type {
    day_type_id
    label
    name_i18n
  }
`;
export const VehicleJourneyWithRouteInfoFragmentDoc = gql`
  fragment vehicle_journey_with_route_info on timetables_vehicle_journey_vehicle_journey {
    start_time
    end_time
    contract_number
    vehicle_journey_id
    journey_pattern_ref {
      journey_pattern_ref_id
      journey_pattern_instance {
        journey_pattern_id
        journey_pattern_route {
          ...route_default_fields
          direction
        }
      }
    }
  }
  ${RouteDefaultFieldsFragmentDoc}
`;
export const VehicleServiceWithJourneysFragmentDoc = gql`
  fragment vehicle_service_with_journeys on timetables_vehicle_service_vehicle_service {
    vehicle_service_id
    name_i18n
    day_type {
      ...day_type_all_fields
    }
    blocks {
      block_id
      vehicle_journeys {
        ...vehicle_journey_with_route_info
      }
      vehicle_type {
        vehicle_type_id
        description_i18n
      }
    }
  }
  ${DayTypeAllFieldsFragmentDoc}
  ${VehicleJourneyWithRouteInfoFragmentDoc}
`;
export const VehicleScheduleFrameWithRouteInfoFragmentDoc = gql`
  fragment vehicle_schedule_frame_with_route_info on timetables_vehicle_schedule_vehicle_schedule_frame {
    label
    validity_end
    validity_start
    name_i18n
    vehicle_schedule_frame_id
    priority
    vehicle_services {
      ...vehicle_service_with_journeys
    }
  }
  ${VehicleServiceWithJourneysFragmentDoc}
`;
export const NewTimingPlaceFragmentDoc = gql`
  fragment new_timing_place on timing_pattern_timing_place {
    label
    description
  }
`;
export const CreatedTimingPlaceFragmentDoc = gql`
  fragment created_timing_place on timing_pattern_timing_place {
    timing_place_id
    label
    description
  }
`;
export const LineForComboboxFragmentDoc = gql`
  fragment line_for_combobox on route_line {
    line_id
    name_i18n
    label
    validity_start
    validity_end
  }
`;
export const TimingPlaceForComboboxFragmentDoc = gql`
  fragment timing_place_for_combobox on timing_pattern_timing_place {
    timing_place_id
    label
    description
  }
`;
export const RouteInfoForTimetableVersionFragmentDoc = gql`
  fragment route_info_for_timetable_version on route_route {
    route_id
    label
    variant
    validity_start
    priority
    validity_end
    route_journey_patterns {
      journey_pattern_id
    }
  }
`;
export const TimetableVersionFragmentDoc = gql`
  fragment timetable_version on timetables_return_value_timetable_version {
    day_type {
      day_type_id
      name_i18n
      label
    }
    substitute_operating_day_by_line_type {
      substitute_operating_day_by_line_type_id
      superseded_date
      substitute_day_of_week
    }
    vehicle_schedule_frame {
      vehicle_schedule_frame_id
      name_i18n
    }
    validity_start
    validity_end
    priority
    in_effect
  }
`;
export const VehicleJourneyWithStartTimeInfoFragmentDoc = gql`
  fragment vehicle_journey_with_start_time_info on timetables_vehicle_journey_vehicle_journey {
    vehicle_journey_id
    start_time
    journey_pattern_ref {
      journey_pattern_ref_id
      journey_pattern_instance {
        journey_pattern_id
        journey_pattern_route {
          route_id
          unique_label
          direction
          name_i18n
        }
      }
    }
  }
`;
export const VehicleScheduleFrameWithRoutesFragmentDoc = gql`
  fragment vehicle_schedule_frame_with_routes on timetables_vehicle_schedule_vehicle_schedule_frame {
    vehicle_schedule_frame_id
    validity_start
    validity_end
    vehicle_services {
      vehicle_service_id
      journey_patterns_in_vehicle_service {
        journey_pattern_instance {
          journey_pattern_id
          journey_pattern_route {
            route_id
            label
          }
        }
      }
    }
  }
`;
export const PassingTimeByStopFragmentDoc = gql`
  fragment passing_time_by_stop on timetables_passing_times_timetabled_passing_time {
    arrival_time
    departure_time
    passing_time
    scheduled_stop_point_in_journey_pattern_ref_id
    timetabled_passing_time_id
    vehicle_journey_id
    scheduled_stop_point_in_journey_pattern_ref {
      journey_pattern_ref {
        journey_pattern_ref_id
        observation_timestamp
      }
      scheduled_stop_point_in_journey_pattern_ref_id
      scheduled_stop_point_label
      scheduled_stop_point_instances {
        ...scheduled_stop_point_default_fields
        timing_place {
          label
          timing_place_id
        }
      }
    }
    vehicle_journey {
      vehicle_journey_id
      block {
        block_id
        vehicle_type {
          description_i18n
          vehicle_type_id
        }
      }
    }
  }
  ${ScheduledStopPointDefaultFieldsFragmentDoc}
`;
export const VehicleJourneyByStopFragmentDoc = gql`
  fragment vehicle_journey_by_stop on timetables_vehicle_journey_vehicle_journey {
    timetabled_passing_times {
      ...passing_time_by_stop
    }
    journey_pattern_ref_id
    vehicle_journey_id
  }
  ${PassingTimeByStopFragmentDoc}
`;
export const VehicleJourneyWithServiceFragmentDoc = gql`
  fragment vehicle_journey_with_service on timetables_vehicle_journey_vehicle_journey {
    vehicle_journey_id
    start_time
    end_time
    journey_pattern_ref {
      journey_pattern_ref_id
      journey_pattern_id
    }
    block {
      block_id
      vehicle_service_id
      vehicle_service {
        vehicle_schedule_frame {
          vehicle_schedule_frame_id
          validity_end
          validity_start
          priority
          name_i18n
          created_at
        }
        vehicle_service_id
        day_type_id
        day_type {
          ...day_type_all_fields
        }
      }
    }
    ...vehicle_journey_by_stop
  }
  ${DayTypeAllFieldsFragmentDoc}
  ${VehicleJourneyByStopFragmentDoc}
`;
export const VehicleScheduleFragmentDoc = gql`
  fragment vehicle_schedule on timetables_return_value_vehicle_schedule {
    vehicle_journey {
      ...vehicle_journey_with_service
    }
    day_type {
      ...day_type_all_fields
    }
    priority
    validity_start
    validity_end
    created_at
    vehicle_schedule_frame_id
  }
  ${VehicleJourneyWithServiceFragmentDoc}
  ${DayTypeAllFieldsFragmentDoc}
`;
export const JourneyPatternStopFragmentDoc = gql`
  fragment journey_pattern_stop on journey_pattern_scheduled_stop_point_in_journey_pattern {
    scheduled_stop_point_label
    scheduled_stop_point_sequence
    is_used_as_timing_point
    is_via_point
    via_point_name_i18n
    via_point_short_name_i18n
  }
`;
export const ListChangingRoutesDocument = gql`
  query ListChangingRoutes($limit: Int) {
    route_route(
      limit: $limit
      order_by: [{ label: asc }, { validity_start: asc }]
    ) {
      ...route_table_row
    }
  }
  ${RouteTableRowFragmentDoc}
`;

/**
 * __useListChangingRoutesQuery__
 *
 * To run a query within a React component, call `useListChangingRoutesQuery` and pass it any options that fit your needs.
 * When your component renders, `useListChangingRoutesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListChangingRoutesQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useListChangingRoutesQuery(
  baseOptions?: Apollo.QueryHookOptions<
    ListChangingRoutesQuery,
    ListChangingRoutesQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    ListChangingRoutesQuery,
    ListChangingRoutesQueryVariables
  >(ListChangingRoutesDocument, options);
}
export function useListChangingRoutesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    ListChangingRoutesQuery,
    ListChangingRoutesQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    ListChangingRoutesQuery,
    ListChangingRoutesQueryVariables
  >(ListChangingRoutesDocument, options);
}
export type ListChangingRoutesQueryHookResult = ReturnType<
  typeof useListChangingRoutesQuery
>;
export type ListChangingRoutesLazyQueryHookResult = ReturnType<
  typeof useListChangingRoutesLazyQuery
>;
export type ListChangingRoutesQueryResult = Apollo.QueryResult<
  ListChangingRoutesQuery,
  ListChangingRoutesQueryVariables
>;
export const ListOwnLinesDocument = gql`
  query ListOwnLines($limit: Int = 10) {
    route_line(
      limit: $limit
      order_by: [{ label: asc }, { validity_start: asc }]
    ) {
      ...line_table_row
    }
  }
  ${LineTableRowFragmentDoc}
`;

/**
 * __useListOwnLinesQuery__
 *
 * To run a query within a React component, call `useListOwnLinesQuery` and pass it any options that fit your needs.
 * When your component renders, `useListOwnLinesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListOwnLinesQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useListOwnLinesQuery(
  baseOptions?: Apollo.QueryHookOptions<
    ListOwnLinesQuery,
    ListOwnLinesQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<ListOwnLinesQuery, ListOwnLinesQueryVariables>(
    ListOwnLinesDocument,
    options,
  );
}
export function useListOwnLinesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    ListOwnLinesQuery,
    ListOwnLinesQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<ListOwnLinesQuery, ListOwnLinesQueryVariables>(
    ListOwnLinesDocument,
    options,
  );
}
export type ListOwnLinesQueryHookResult = ReturnType<
  typeof useListOwnLinesQuery
>;
export type ListOwnLinesLazyQueryHookResult = ReturnType<
  typeof useListOwnLinesLazyQuery
>;
export type ListOwnLinesQueryResult = Apollo.QueryResult<
  ListOwnLinesQuery,
  ListOwnLinesQueryVariables
>;
export const GetScheduledStopPointWithTimingSettingsDocument = gql`
  query GetScheduledStopPointWithTimingSettings(
    $journeyPatternId: uuid!
    $stopLabel: String!
    $sequence: Int!
  ) {
    journey_pattern_scheduled_stop_point_in_journey_pattern(
      where: {
        journey_pattern_id: { _eq: $journeyPatternId }
        scheduled_stop_point_label: { _eq: $stopLabel }
        scheduled_stop_point_sequence: { _eq: $sequence }
      }
    ) {
      ...scheduled_stop_point_with_timing_settings
    }
  }
  ${ScheduledStopPointWithTimingSettingsFragmentDoc}
`;

/**
 * __useGetScheduledStopPointWithTimingSettingsQuery__
 *
 * To run a query within a React component, call `useGetScheduledStopPointWithTimingSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetScheduledStopPointWithTimingSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetScheduledStopPointWithTimingSettingsQuery({
 *   variables: {
 *      journeyPatternId: // value for 'journeyPatternId'
 *      stopLabel: // value for 'stopLabel'
 *      sequence: // value for 'sequence'
 *   },
 * });
 */
export function useGetScheduledStopPointWithTimingSettingsQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetScheduledStopPointWithTimingSettingsQuery,
    GetScheduledStopPointWithTimingSettingsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetScheduledStopPointWithTimingSettingsQuery,
    GetScheduledStopPointWithTimingSettingsQueryVariables
  >(GetScheduledStopPointWithTimingSettingsDocument, options);
}
export function useGetScheduledStopPointWithTimingSettingsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetScheduledStopPointWithTimingSettingsQuery,
    GetScheduledStopPointWithTimingSettingsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetScheduledStopPointWithTimingSettingsQuery,
    GetScheduledStopPointWithTimingSettingsQueryVariables
  >(GetScheduledStopPointWithTimingSettingsDocument, options);
}
export type GetScheduledStopPointWithTimingSettingsQueryHookResult = ReturnType<
  typeof useGetScheduledStopPointWithTimingSettingsQuery
>;
export type GetScheduledStopPointWithTimingSettingsLazyQueryHookResult =
  ReturnType<typeof useGetScheduledStopPointWithTimingSettingsLazyQuery>;
export type GetScheduledStopPointWithTimingSettingsQueryResult =
  Apollo.QueryResult<
    GetScheduledStopPointWithTimingSettingsQuery,
    GetScheduledStopPointWithTimingSettingsQueryVariables
  >;
export const GetRouteWithJourneyPatternDocument = gql`
  query GetRouteWithJourneyPattern($routeId: uuid!) {
    route_route_by_pk(route_id: $routeId) {
      ...route_with_journey_pattern_stops
    }
  }
  ${RouteWithJourneyPatternStopsFragmentDoc}
`;

/**
 * __useGetRouteWithJourneyPatternQuery__
 *
 * To run a query within a React component, call `useGetRouteWithJourneyPatternQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRouteWithJourneyPatternQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRouteWithJourneyPatternQuery({
 *   variables: {
 *      routeId: // value for 'routeId'
 *   },
 * });
 */
export function useGetRouteWithJourneyPatternQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetRouteWithJourneyPatternQuery,
    GetRouteWithJourneyPatternQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetRouteWithJourneyPatternQuery,
    GetRouteWithJourneyPatternQueryVariables
  >(GetRouteWithJourneyPatternDocument, options);
}
export function useGetRouteWithJourneyPatternLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetRouteWithJourneyPatternQuery,
    GetRouteWithJourneyPatternQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetRouteWithJourneyPatternQuery,
    GetRouteWithJourneyPatternQueryVariables
  >(GetRouteWithJourneyPatternDocument, options);
}
export type GetRouteWithJourneyPatternQueryHookResult = ReturnType<
  typeof useGetRouteWithJourneyPatternQuery
>;
export type GetRouteWithJourneyPatternLazyQueryHookResult = ReturnType<
  typeof useGetRouteWithJourneyPatternLazyQuery
>;
export type GetRouteWithJourneyPatternQueryResult = Apollo.QueryResult<
  GetRouteWithJourneyPatternQuery,
  GetRouteWithJourneyPatternQueryVariables
>;
export const QueryClosestLinkDocument = gql`
  query QueryClosestLink($point: geography) {
    infrastructure_network_resolve_point_to_closest_link(
      args: { geog: $point }
    ) {
      ...infrastructure_link_all_fields
    }
  }
  ${InfrastructureLinkAllFieldsFragmentDoc}
`;

/**
 * __useQueryClosestLinkQuery__
 *
 * To run a query within a React component, call `useQueryClosestLinkQuery` and pass it any options that fit your needs.
 * When your component renders, `useQueryClosestLinkQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQueryClosestLinkQuery({
 *   variables: {
 *      point: // value for 'point'
 *   },
 * });
 */
export function useQueryClosestLinkQuery(
  baseOptions?: Apollo.QueryHookOptions<
    QueryClosestLinkQuery,
    QueryClosestLinkQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<QueryClosestLinkQuery, QueryClosestLinkQueryVariables>(
    QueryClosestLinkDocument,
    options,
  );
}
export function useQueryClosestLinkLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    QueryClosestLinkQuery,
    QueryClosestLinkQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    QueryClosestLinkQuery,
    QueryClosestLinkQueryVariables
  >(QueryClosestLinkDocument, options);
}
export type QueryClosestLinkQueryHookResult = ReturnType<
  typeof useQueryClosestLinkQuery
>;
export type QueryClosestLinkLazyQueryHookResult = ReturnType<
  typeof useQueryClosestLinkLazyQuery
>;
export type QueryClosestLinkQueryResult = Apollo.QueryResult<
  QueryClosestLinkQuery,
  QueryClosestLinkQueryVariables
>;
export const QueryPointDirectionOnLinkDocument = gql`
  query QueryPointDirectionOnLink(
    $point_of_interest: geography
    $infrastructure_link_uuid: uuid
    $point_max_distance_in_meters: float8
  ) {
    infrastructure_network_find_point_direction_on_link(
      args: {
        point_of_interest: $point_of_interest
        infrastructure_link_uuid: $infrastructure_link_uuid
        point_max_distance_in_meters: $point_max_distance_in_meters
      }
    ) {
      value
    }
  }
`;

/**
 * __useQueryPointDirectionOnLinkQuery__
 *
 * To run a query within a React component, call `useQueryPointDirectionOnLinkQuery` and pass it any options that fit your needs.
 * When your component renders, `useQueryPointDirectionOnLinkQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQueryPointDirectionOnLinkQuery({
 *   variables: {
 *      point_of_interest: // value for 'point_of_interest'
 *      infrastructure_link_uuid: // value for 'infrastructure_link_uuid'
 *      point_max_distance_in_meters: // value for 'point_max_distance_in_meters'
 *   },
 * });
 */
export function useQueryPointDirectionOnLinkQuery(
  baseOptions?: Apollo.QueryHookOptions<
    QueryPointDirectionOnLinkQuery,
    QueryPointDirectionOnLinkQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    QueryPointDirectionOnLinkQuery,
    QueryPointDirectionOnLinkQueryVariables
  >(QueryPointDirectionOnLinkDocument, options);
}
export function useQueryPointDirectionOnLinkLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    QueryPointDirectionOnLinkQuery,
    QueryPointDirectionOnLinkQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    QueryPointDirectionOnLinkQuery,
    QueryPointDirectionOnLinkQueryVariables
  >(QueryPointDirectionOnLinkDocument, options);
}
export type QueryPointDirectionOnLinkQueryHookResult = ReturnType<
  typeof useQueryPointDirectionOnLinkQuery
>;
export type QueryPointDirectionOnLinkLazyQueryHookResult = ReturnType<
  typeof useQueryPointDirectionOnLinkLazyQuery
>;
export type QueryPointDirectionOnLinkQueryResult = Apollo.QueryResult<
  QueryPointDirectionOnLinkQuery,
  QueryPointDirectionOnLinkQueryVariables
>;
export const GetStopsAlongInfrastructureLinksDocument = gql`
  query GetStopsAlongInfrastructureLinks($infrastructure_link_ids: [uuid!]) {
    service_pattern_scheduled_stop_point(
      where: {
        located_on_infrastructure_link_id: { _in: $infrastructure_link_ids }
      }
    ) {
      ...scheduled_stop_point_all_fields
    }
  }
  ${ScheduledStopPointAllFieldsFragmentDoc}
`;

/**
 * __useGetStopsAlongInfrastructureLinksQuery__
 *
 * To run a query within a React component, call `useGetStopsAlongInfrastructureLinksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStopsAlongInfrastructureLinksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStopsAlongInfrastructureLinksQuery({
 *   variables: {
 *      infrastructure_link_ids: // value for 'infrastructure_link_ids'
 *   },
 * });
 */
export function useGetStopsAlongInfrastructureLinksQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetStopsAlongInfrastructureLinksQuery,
    GetStopsAlongInfrastructureLinksQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetStopsAlongInfrastructureLinksQuery,
    GetStopsAlongInfrastructureLinksQueryVariables
  >(GetStopsAlongInfrastructureLinksDocument, options);
}
export function useGetStopsAlongInfrastructureLinksLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetStopsAlongInfrastructureLinksQuery,
    GetStopsAlongInfrastructureLinksQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetStopsAlongInfrastructureLinksQuery,
    GetStopsAlongInfrastructureLinksQueryVariables
  >(GetStopsAlongInfrastructureLinksDocument, options);
}
export type GetStopsAlongInfrastructureLinksQueryHookResult = ReturnType<
  typeof useGetStopsAlongInfrastructureLinksQuery
>;
export type GetStopsAlongInfrastructureLinksLazyQueryHookResult = ReturnType<
  typeof useGetStopsAlongInfrastructureLinksLazyQuery
>;
export type GetStopsAlongInfrastructureLinksQueryResult = Apollo.QueryResult<
  GetStopsAlongInfrastructureLinksQuery,
  GetStopsAlongInfrastructureLinksQueryVariables
>;
export const PatchScheduledStopPointViaInfoDocument = gql`
  mutation PatchScheduledStopPointViaInfo(
    $stopLabel: String!
    $journeyPatternId: uuid!
    $patch: journey_pattern_scheduled_stop_point_in_journey_pattern_set_input!
  ) {
    update_journey_pattern_scheduled_stop_point_in_journey_pattern(
      where: {
        scheduled_stop_point_label: { _eq: $stopLabel }
        journey_pattern_id: { _eq: $journeyPatternId }
      }
      _set: $patch
    ) {
      returning {
        ...scheduled_stop_point_in_journey_pattern_all_fields
      }
    }
  }
  ${ScheduledStopPointInJourneyPatternAllFieldsFragmentDoc}
`;
export type PatchScheduledStopPointViaInfoMutationFn = Apollo.MutationFunction<
  PatchScheduledStopPointViaInfoMutation,
  PatchScheduledStopPointViaInfoMutationVariables
>;

/**
 * __usePatchScheduledStopPointViaInfoMutation__
 *
 * To run a mutation, you first call `usePatchScheduledStopPointViaInfoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePatchScheduledStopPointViaInfoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [patchScheduledStopPointViaInfoMutation, { data, loading, error }] = usePatchScheduledStopPointViaInfoMutation({
 *   variables: {
 *      stopLabel: // value for 'stopLabel'
 *      journeyPatternId: // value for 'journeyPatternId'
 *      patch: // value for 'patch'
 *   },
 * });
 */
export function usePatchScheduledStopPointViaInfoMutation(
  baseOptions?: Apollo.MutationHookOptions<
    PatchScheduledStopPointViaInfoMutation,
    PatchScheduledStopPointViaInfoMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    PatchScheduledStopPointViaInfoMutation,
    PatchScheduledStopPointViaInfoMutationVariables
  >(PatchScheduledStopPointViaInfoDocument, options);
}
export type PatchScheduledStopPointViaInfoMutationHookResult = ReturnType<
  typeof usePatchScheduledStopPointViaInfoMutation
>;
export type PatchScheduledStopPointViaInfoMutationResult =
  Apollo.MutationResult<PatchScheduledStopPointViaInfoMutation>;
export type PatchScheduledStopPointViaInfoMutationOptions =
  Apollo.BaseMutationOptions<
    PatchScheduledStopPointViaInfoMutation,
    PatchScheduledStopPointViaInfoMutationVariables
  >;
export const RemoveScheduledStopPointViaInfoDocument = gql`
  mutation RemoveScheduledStopPointViaInfo(
    $stopLabel: String!
    $journeyPatternId: uuid!
  ) {
    update_journey_pattern_scheduled_stop_point_in_journey_pattern(
      where: {
        scheduled_stop_point_label: { _eq: $stopLabel }
        journey_pattern_id: { _eq: $journeyPatternId }
      }
      _set: {
        is_via_point: false
        via_point_name_i18n: null
        via_point_short_name_i18n: null
      }
    ) {
      returning {
        ...scheduled_stop_point_in_journey_pattern_all_fields
      }
    }
  }
  ${ScheduledStopPointInJourneyPatternAllFieldsFragmentDoc}
`;
export type RemoveScheduledStopPointViaInfoMutationFn = Apollo.MutationFunction<
  RemoveScheduledStopPointViaInfoMutation,
  RemoveScheduledStopPointViaInfoMutationVariables
>;

/**
 * __useRemoveScheduledStopPointViaInfoMutation__
 *
 * To run a mutation, you first call `useRemoveScheduledStopPointViaInfoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveScheduledStopPointViaInfoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeScheduledStopPointViaInfoMutation, { data, loading, error }] = useRemoveScheduledStopPointViaInfoMutation({
 *   variables: {
 *      stopLabel: // value for 'stopLabel'
 *      journeyPatternId: // value for 'journeyPatternId'
 *   },
 * });
 */
export function useRemoveScheduledStopPointViaInfoMutation(
  baseOptions?: Apollo.MutationHookOptions<
    RemoveScheduledStopPointViaInfoMutation,
    RemoveScheduledStopPointViaInfoMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    RemoveScheduledStopPointViaInfoMutation,
    RemoveScheduledStopPointViaInfoMutationVariables
  >(RemoveScheduledStopPointViaInfoDocument, options);
}
export type RemoveScheduledStopPointViaInfoMutationHookResult = ReturnType<
  typeof useRemoveScheduledStopPointViaInfoMutation
>;
export type RemoveScheduledStopPointViaInfoMutationResult =
  Apollo.MutationResult<RemoveScheduledStopPointViaInfoMutation>;
export type RemoveScheduledStopPointViaInfoMutationOptions =
  Apollo.BaseMutationOptions<
    RemoveScheduledStopPointViaInfoMutation,
    RemoveScheduledStopPointViaInfoMutationVariables
  >;
export const GetScheduledStopPointWithViaInfoDocument = gql`
  query GetScheduledStopPointWithViaInfo(
    $journeyPatternId: uuid!
    $stopLabel: String!
  ) {
    journey_pattern_scheduled_stop_point_in_journey_pattern(
      where: {
        journey_pattern_id: { _eq: $journeyPatternId }
        scheduled_stop_point_label: { _eq: $stopLabel }
      }
    ) {
      ...scheduled_stop_point_in_journey_pattern_all_fields
      journey_pattern {
        journey_pattern_id
        journey_pattern_route {
          route_id
          label
        }
      }
    }
  }
  ${ScheduledStopPointInJourneyPatternAllFieldsFragmentDoc}
`;

/**
 * __useGetScheduledStopPointWithViaInfoQuery__
 *
 * To run a query within a React component, call `useGetScheduledStopPointWithViaInfoQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetScheduledStopPointWithViaInfoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetScheduledStopPointWithViaInfoQuery({
 *   variables: {
 *      journeyPatternId: // value for 'journeyPatternId'
 *      stopLabel: // value for 'stopLabel'
 *   },
 * });
 */
export function useGetScheduledStopPointWithViaInfoQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetScheduledStopPointWithViaInfoQuery,
    GetScheduledStopPointWithViaInfoQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetScheduledStopPointWithViaInfoQuery,
    GetScheduledStopPointWithViaInfoQueryVariables
  >(GetScheduledStopPointWithViaInfoDocument, options);
}
export function useGetScheduledStopPointWithViaInfoLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetScheduledStopPointWithViaInfoQuery,
    GetScheduledStopPointWithViaInfoQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetScheduledStopPointWithViaInfoQuery,
    GetScheduledStopPointWithViaInfoQueryVariables
  >(GetScheduledStopPointWithViaInfoDocument, options);
}
export type GetScheduledStopPointWithViaInfoQueryHookResult = ReturnType<
  typeof useGetScheduledStopPointWithViaInfoQuery
>;
export type GetScheduledStopPointWithViaInfoLazyQueryHookResult = ReturnType<
  typeof useGetScheduledStopPointWithViaInfoLazyQuery
>;
export type GetScheduledStopPointWithViaInfoQueryResult = Apollo.QueryResult<
  GetScheduledStopPointWithViaInfoQuery,
  GetScheduledStopPointWithViaInfoQueryVariables
>;
export const GetLineDetailsByIdDocument = gql`
  query GetLineDetailsById($line_id: uuid!) {
    route_line_by_pk(line_id: $line_id) {
      ...line_all_fields
    }
  }
  ${LineAllFieldsFragmentDoc}
`;

/**
 * __useGetLineDetailsByIdQuery__
 *
 * To run a query within a React component, call `useGetLineDetailsByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLineDetailsByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLineDetailsByIdQuery({
 *   variables: {
 *      line_id: // value for 'line_id'
 *   },
 * });
 */
export function useGetLineDetailsByIdQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetLineDetailsByIdQuery,
    GetLineDetailsByIdQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetLineDetailsByIdQuery,
    GetLineDetailsByIdQueryVariables
  >(GetLineDetailsByIdDocument, options);
}
export function useGetLineDetailsByIdLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetLineDetailsByIdQuery,
    GetLineDetailsByIdQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetLineDetailsByIdQuery,
    GetLineDetailsByIdQueryVariables
  >(GetLineDetailsByIdDocument, options);
}
export type GetLineDetailsByIdQueryHookResult = ReturnType<
  typeof useGetLineDetailsByIdQuery
>;
export type GetLineDetailsByIdLazyQueryHookResult = ReturnType<
  typeof useGetLineDetailsByIdLazyQuery
>;
export type GetLineDetailsByIdQueryResult = Apollo.QueryResult<
  GetLineDetailsByIdQuery,
  GetLineDetailsByIdQueryVariables
>;
export const GetLineValidityPeriodByIdDocument = gql`
  query GetLineValidityPeriodById($line_id: uuid!) {
    route_line_by_pk(line_id: $line_id) {
      line_id
      validity_start
      validity_end
    }
  }
`;

/**
 * __useGetLineValidityPeriodByIdQuery__
 *
 * To run a query within a React component, call `useGetLineValidityPeriodByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLineValidityPeriodByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLineValidityPeriodByIdQuery({
 *   variables: {
 *      line_id: // value for 'line_id'
 *   },
 * });
 */
export function useGetLineValidityPeriodByIdQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetLineValidityPeriodByIdQuery,
    GetLineValidityPeriodByIdQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetLineValidityPeriodByIdQuery,
    GetLineValidityPeriodByIdQueryVariables
  >(GetLineValidityPeriodByIdDocument, options);
}
export function useGetLineValidityPeriodByIdLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetLineValidityPeriodByIdQuery,
    GetLineValidityPeriodByIdQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetLineValidityPeriodByIdQuery,
    GetLineValidityPeriodByIdQueryVariables
  >(GetLineValidityPeriodByIdDocument, options);
}
export type GetLineValidityPeriodByIdQueryHookResult = ReturnType<
  typeof useGetLineValidityPeriodByIdQuery
>;
export type GetLineValidityPeriodByIdLazyQueryHookResult = ReturnType<
  typeof useGetLineValidityPeriodByIdLazyQuery
>;
export type GetLineValidityPeriodByIdQueryResult = Apollo.QueryResult<
  GetLineValidityPeriodByIdQuery,
  GetLineValidityPeriodByIdQueryVariables
>;
export const GetLinesByValidityDocument = gql`
  query GetLinesByValidity($filter: route_line_bool_exp) {
    route_line(where: $filter) {
      ...line_all_fields
    }
  }
  ${LineAllFieldsFragmentDoc}
`;

/**
 * __useGetLinesByValidityQuery__
 *
 * To run a query within a React component, call `useGetLinesByValidityQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLinesByValidityQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLinesByValidityQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *   },
 * });
 */
export function useGetLinesByValidityQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetLinesByValidityQuery,
    GetLinesByValidityQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetLinesByValidityQuery,
    GetLinesByValidityQueryVariables
  >(GetLinesByValidityDocument, options);
}
export function useGetLinesByValidityLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetLinesByValidityQuery,
    GetLinesByValidityQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetLinesByValidityQuery,
    GetLinesByValidityQueryVariables
  >(GetLinesByValidityDocument, options);
}
export type GetLinesByValidityQueryHookResult = ReturnType<
  typeof useGetLinesByValidityQuery
>;
export type GetLinesByValidityLazyQueryHookResult = ReturnType<
  typeof useGetLinesByValidityLazyQuery
>;
export type GetLinesByValidityQueryResult = Apollo.QueryResult<
  GetLinesByValidityQuery,
  GetLinesByValidityQueryVariables
>;
export const GetLineDetailsWithRoutesByIdDocument = gql`
  query GetLineDetailsWithRoutesById($line_id: uuid!) {
    route_line_by_pk(line_id: $line_id) {
      ...line_all_fields
      line_routes {
        ...route_all_fields
        infrastructure_links_along_route {
          route_id
          infrastructure_link_id
          infrastructure_link_sequence
          is_traversal_forwards
          infrastructure_link {
            infrastructure_link_id
            scheduled_stop_points_located_on_infrastructure_link {
              ...scheduled_stop_point_all_fields
              scheduled_stop_point_in_journey_patterns {
                ...scheduled_stop_point_in_journey_pattern_all_fields
                journey_pattern {
                  journey_pattern_id
                  on_route_id
                }
              }
              other_label_instances {
                ...scheduled_stop_point_default_fields
              }
            }
          }
        }
      }
    }
  }
  ${LineAllFieldsFragmentDoc}
  ${RouteAllFieldsFragmentDoc}
  ${ScheduledStopPointAllFieldsFragmentDoc}
  ${ScheduledStopPointInJourneyPatternAllFieldsFragmentDoc}
  ${ScheduledStopPointDefaultFieldsFragmentDoc}
`;

/**
 * __useGetLineDetailsWithRoutesByIdQuery__
 *
 * To run a query within a React component, call `useGetLineDetailsWithRoutesByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLineDetailsWithRoutesByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLineDetailsWithRoutesByIdQuery({
 *   variables: {
 *      line_id: // value for 'line_id'
 *   },
 * });
 */
export function useGetLineDetailsWithRoutesByIdQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetLineDetailsWithRoutesByIdQuery,
    GetLineDetailsWithRoutesByIdQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetLineDetailsWithRoutesByIdQuery,
    GetLineDetailsWithRoutesByIdQueryVariables
  >(GetLineDetailsWithRoutesByIdDocument, options);
}
export function useGetLineDetailsWithRoutesByIdLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetLineDetailsWithRoutesByIdQuery,
    GetLineDetailsWithRoutesByIdQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetLineDetailsWithRoutesByIdQuery,
    GetLineDetailsWithRoutesByIdQueryVariables
  >(GetLineDetailsWithRoutesByIdDocument, options);
}
export type GetLineDetailsWithRoutesByIdQueryHookResult = ReturnType<
  typeof useGetLineDetailsWithRoutesByIdQuery
>;
export type GetLineDetailsWithRoutesByIdLazyQueryHookResult = ReturnType<
  typeof useGetLineDetailsWithRoutesByIdLazyQuery
>;
export type GetLineDetailsWithRoutesByIdQueryResult = Apollo.QueryResult<
  GetLineDetailsWithRoutesByIdQuery,
  GetLineDetailsWithRoutesByIdQueryVariables
>;
export const GetRoutesWithStopsDocument = gql`
  query GetRoutesWithStops($routeFilters: route_route_bool_exp) {
    route_route(where: $routeFilters) {
      ...route_with_infrastructure_links_with_stops_and_jps
    }
  }
  ${RouteWithInfrastructureLinksWithStopsAndJpsFragmentDoc}
`;

/**
 * __useGetRoutesWithStopsQuery__
 *
 * To run a query within a React component, call `useGetRoutesWithStopsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRoutesWithStopsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRoutesWithStopsQuery({
 *   variables: {
 *      routeFilters: // value for 'routeFilters'
 *   },
 * });
 */
export function useGetRoutesWithStopsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetRoutesWithStopsQuery,
    GetRoutesWithStopsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetRoutesWithStopsQuery,
    GetRoutesWithStopsQueryVariables
  >(GetRoutesWithStopsDocument, options);
}
export function useGetRoutesWithStopsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetRoutesWithStopsQuery,
    GetRoutesWithStopsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetRoutesWithStopsQuery,
    GetRoutesWithStopsQueryVariables
  >(GetRoutesWithStopsDocument, options);
}
export type GetRoutesWithStopsQueryHookResult = ReturnType<
  typeof useGetRoutesWithStopsQuery
>;
export type GetRoutesWithStopsLazyQueryHookResult = ReturnType<
  typeof useGetRoutesWithStopsLazyQuery
>;
export type GetRoutesWithStopsQueryResult = Apollo.QueryResult<
  GetRoutesWithStopsQuery,
  GetRoutesWithStopsQueryVariables
>;
export const GetRouteDetailsByIdDocument = gql`
  query GetRouteDetailsById($routeId: uuid!) {
    route_route_by_pk(route_id: $routeId) {
      ...route_with_infrastructure_links_with_stops_and_jps
    }
  }
  ${RouteWithInfrastructureLinksWithStopsAndJpsFragmentDoc}
`;

/**
 * __useGetRouteDetailsByIdQuery__
 *
 * To run a query within a React component, call `useGetRouteDetailsByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRouteDetailsByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRouteDetailsByIdQuery({
 *   variables: {
 *      routeId: // value for 'routeId'
 *   },
 * });
 */
export function useGetRouteDetailsByIdQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetRouteDetailsByIdQuery,
    GetRouteDetailsByIdQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetRouteDetailsByIdQuery,
    GetRouteDetailsByIdQueryVariables
  >(GetRouteDetailsByIdDocument, options);
}
export function useGetRouteDetailsByIdLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetRouteDetailsByIdQuery,
    GetRouteDetailsByIdQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetRouteDetailsByIdQuery,
    GetRouteDetailsByIdQueryVariables
  >(GetRouteDetailsByIdDocument, options);
}
export type GetRouteDetailsByIdQueryHookResult = ReturnType<
  typeof useGetRouteDetailsByIdQuery
>;
export type GetRouteDetailsByIdLazyQueryHookResult = ReturnType<
  typeof useGetRouteDetailsByIdLazyQuery
>;
export type GetRouteDetailsByIdQueryResult = Apollo.QueryResult<
  GetRouteDetailsByIdQuery,
  GetRouteDetailsByIdQueryVariables
>;
export const GetRouteDetailsByIdsDocument = gql`
  query GetRouteDetailsByIds($route_ids: [uuid!]) {
    route_route(where: { route_id: { _in: $route_ids } }) {
      ...route_with_infrastructure_links_with_stops_and_jps
    }
  }
  ${RouteWithInfrastructureLinksWithStopsAndJpsFragmentDoc}
`;

/**
 * __useGetRouteDetailsByIdsQuery__
 *
 * To run a query within a React component, call `useGetRouteDetailsByIdsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRouteDetailsByIdsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRouteDetailsByIdsQuery({
 *   variables: {
 *      route_ids: // value for 'route_ids'
 *   },
 * });
 */
export function useGetRouteDetailsByIdsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetRouteDetailsByIdsQuery,
    GetRouteDetailsByIdsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetRouteDetailsByIdsQuery,
    GetRouteDetailsByIdsQueryVariables
  >(GetRouteDetailsByIdsDocument, options);
}
export function useGetRouteDetailsByIdsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetRouteDetailsByIdsQuery,
    GetRouteDetailsByIdsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetRouteDetailsByIdsQuery,
    GetRouteDetailsByIdsQueryVariables
  >(GetRouteDetailsByIdsDocument, options);
}
export type GetRouteDetailsByIdsQueryHookResult = ReturnType<
  typeof useGetRouteDetailsByIdsQuery
>;
export type GetRouteDetailsByIdsLazyQueryHookResult = ReturnType<
  typeof useGetRouteDetailsByIdsLazyQuery
>;
export type GetRouteDetailsByIdsQueryResult = Apollo.QueryResult<
  GetRouteDetailsByIdsQuery,
  GetRouteDetailsByIdsQueryVariables
>;
export const GetRouteRenderInfoByIdDocument = gql`
  query GetRouteRenderInfoById($routeId: uuid!) {
    route_route_by_pk(route_id: $routeId) {
      route_id
      route_shape
      route_line {
        line_id
        primary_vehicle_mode
      }
    }
  }
`;

/**
 * __useGetRouteRenderInfoByIdQuery__
 *
 * To run a query within a React component, call `useGetRouteRenderInfoByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRouteRenderInfoByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRouteRenderInfoByIdQuery({
 *   variables: {
 *      routeId: // value for 'routeId'
 *   },
 * });
 */
export function useGetRouteRenderInfoByIdQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetRouteRenderInfoByIdQuery,
    GetRouteRenderInfoByIdQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetRouteRenderInfoByIdQuery,
    GetRouteRenderInfoByIdQueryVariables
  >(GetRouteRenderInfoByIdDocument, options);
}
export function useGetRouteRenderInfoByIdLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetRouteRenderInfoByIdQuery,
    GetRouteRenderInfoByIdQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetRouteRenderInfoByIdQuery,
    GetRouteRenderInfoByIdQueryVariables
  >(GetRouteRenderInfoByIdDocument, options);
}
export type GetRouteRenderInfoByIdQueryHookResult = ReturnType<
  typeof useGetRouteRenderInfoByIdQuery
>;
export type GetRouteRenderInfoByIdLazyQueryHookResult = ReturnType<
  typeof useGetRouteRenderInfoByIdLazyQuery
>;
export type GetRouteRenderInfoByIdQueryResult = Apollo.QueryResult<
  GetRouteRenderInfoByIdQuery,
  GetRouteRenderInfoByIdQueryVariables
>;
export const GetRouteDetailsByLabelsDocument = gql`
  query GetRouteDetailsByLabels($labels: [String!], $date: date) {
    route_route(
      where: {
        label: { _in: $labels }
        validity_start: { _lte: $date }
        _or: [
          { validity_end: { _gte: $date } }
          { validity_end: { _is_null: true } }
        ]
      }
    ) {
      ...route_with_journey_pattern_stops
      route_line {
        line_id
        label
        primary_vehicle_mode
      }
    }
  }
  ${RouteWithJourneyPatternStopsFragmentDoc}
`;

/**
 * __useGetRouteDetailsByLabelsQuery__
 *
 * To run a query within a React component, call `useGetRouteDetailsByLabelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRouteDetailsByLabelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRouteDetailsByLabelsQuery({
 *   variables: {
 *      labels: // value for 'labels'
 *      date: // value for 'date'
 *   },
 * });
 */
export function useGetRouteDetailsByLabelsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetRouteDetailsByLabelsQuery,
    GetRouteDetailsByLabelsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetRouteDetailsByLabelsQuery,
    GetRouteDetailsByLabelsQueryVariables
  >(GetRouteDetailsByLabelsDocument, options);
}
export function useGetRouteDetailsByLabelsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetRouteDetailsByLabelsQuery,
    GetRouteDetailsByLabelsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetRouteDetailsByLabelsQuery,
    GetRouteDetailsByLabelsQueryVariables
  >(GetRouteDetailsByLabelsDocument, options);
}
export type GetRouteDetailsByLabelsQueryHookResult = ReturnType<
  typeof useGetRouteDetailsByLabelsQuery
>;
export type GetRouteDetailsByLabelsLazyQueryHookResult = ReturnType<
  typeof useGetRouteDetailsByLabelsLazyQuery
>;
export type GetRouteDetailsByLabelsQueryResult = Apollo.QueryResult<
  GetRouteDetailsByLabelsQuery,
  GetRouteDetailsByLabelsQueryVariables
>;
export const GetRoutesWithInfrastructureLinksDocument = gql`
  query GetRoutesWithInfrastructureLinks($route_ids: [uuid!]) {
    route_route(where: { route_id: { _in: $route_ids } }) {
      ...route_with_infrastructure_links
    }
  }
  ${RouteWithInfrastructureLinksFragmentDoc}
`;

/**
 * __useGetRoutesWithInfrastructureLinksQuery__
 *
 * To run a query within a React component, call `useGetRoutesWithInfrastructureLinksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRoutesWithInfrastructureLinksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRoutesWithInfrastructureLinksQuery({
 *   variables: {
 *      route_ids: // value for 'route_ids'
 *   },
 * });
 */
export function useGetRoutesWithInfrastructureLinksQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetRoutesWithInfrastructureLinksQuery,
    GetRoutesWithInfrastructureLinksQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetRoutesWithInfrastructureLinksQuery,
    GetRoutesWithInfrastructureLinksQueryVariables
  >(GetRoutesWithInfrastructureLinksDocument, options);
}
export function useGetRoutesWithInfrastructureLinksLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetRoutesWithInfrastructureLinksQuery,
    GetRoutesWithInfrastructureLinksQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetRoutesWithInfrastructureLinksQuery,
    GetRoutesWithInfrastructureLinksQueryVariables
  >(GetRoutesWithInfrastructureLinksDocument, options);
}
export type GetRoutesWithInfrastructureLinksQueryHookResult = ReturnType<
  typeof useGetRoutesWithInfrastructureLinksQuery
>;
export type GetRoutesWithInfrastructureLinksLazyQueryHookResult = ReturnType<
  typeof useGetRoutesWithInfrastructureLinksLazyQuery
>;
export type GetRoutesWithInfrastructureLinksQueryResult = Apollo.QueryResult<
  GetRoutesWithInfrastructureLinksQuery,
  GetRoutesWithInfrastructureLinksQueryVariables
>;
export const GetRoutesByValidityDocument = gql`
  query GetRoutesByValidity($filter: route_route_bool_exp) {
    route_route(where: $filter) {
      ...route_default_fields
    }
  }
  ${RouteDefaultFieldsFragmentDoc}
`;

/**
 * __useGetRoutesByValidityQuery__
 *
 * To run a query within a React component, call `useGetRoutesByValidityQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRoutesByValidityQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRoutesByValidityQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *   },
 * });
 */
export function useGetRoutesByValidityQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetRoutesByValidityQuery,
    GetRoutesByValidityQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetRoutesByValidityQuery,
    GetRoutesByValidityQueryVariables
  >(GetRoutesByValidityDocument, options);
}
export function useGetRoutesByValidityLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetRoutesByValidityQuery,
    GetRoutesByValidityQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetRoutesByValidityQuery,
    GetRoutesByValidityQueryVariables
  >(GetRoutesByValidityDocument, options);
}
export type GetRoutesByValidityQueryHookResult = ReturnType<
  typeof useGetRoutesByValidityQuery
>;
export type GetRoutesByValidityLazyQueryHookResult = ReturnType<
  typeof useGetRoutesByValidityLazyQuery
>;
export type GetRoutesByValidityQueryResult = Apollo.QueryResult<
  GetRoutesByValidityQuery,
  GetRoutesByValidityQueryVariables
>;
export const InsertLineOneDocument = gql`
  mutation InsertLineOne($object: route_line_insert_input!) {
    insert_route_line_one(object: $object) {
      line_id
      label
      priority
      primary_vehicle_mode
      transport_target
      validity_start
      validity_end
    }
  }
`;
export type InsertLineOneMutationFn = Apollo.MutationFunction<
  InsertLineOneMutation,
  InsertLineOneMutationVariables
>;

/**
 * __useInsertLineOneMutation__
 *
 * To run a mutation, you first call `useInsertLineOneMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertLineOneMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertLineOneMutation, { data, loading, error }] = useInsertLineOneMutation({
 *   variables: {
 *      object: // value for 'object'
 *   },
 * });
 */
export function useInsertLineOneMutation(
  baseOptions?: Apollo.MutationHookOptions<
    InsertLineOneMutation,
    InsertLineOneMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    InsertLineOneMutation,
    InsertLineOneMutationVariables
  >(InsertLineOneDocument, options);
}
export type InsertLineOneMutationHookResult = ReturnType<
  typeof useInsertLineOneMutation
>;
export type InsertLineOneMutationResult =
  Apollo.MutationResult<InsertLineOneMutation>;
export type InsertLineOneMutationOptions = Apollo.BaseMutationOptions<
  InsertLineOneMutation,
  InsertLineOneMutationVariables
>;
export const PatchLineDocument = gql`
  mutation PatchLine($line_id: uuid!, $object: route_line_set_input!) {
    update_route_line_by_pk(pk_columns: { line_id: $line_id }, _set: $object) {
      ...line_all_fields
    }
  }
  ${LineAllFieldsFragmentDoc}
`;
export type PatchLineMutationFn = Apollo.MutationFunction<
  PatchLineMutation,
  PatchLineMutationVariables
>;

/**
 * __usePatchLineMutation__
 *
 * To run a mutation, you first call `usePatchLineMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePatchLineMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [patchLineMutation, { data, loading, error }] = usePatchLineMutation({
 *   variables: {
 *      line_id: // value for 'line_id'
 *      object: // value for 'object'
 *   },
 * });
 */
export function usePatchLineMutation(
  baseOptions?: Apollo.MutationHookOptions<
    PatchLineMutation,
    PatchLineMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<PatchLineMutation, PatchLineMutationVariables>(
    PatchLineDocument,
    options,
  );
}
export type PatchLineMutationHookResult = ReturnType<
  typeof usePatchLineMutation
>;
export type PatchLineMutationResult = Apollo.MutationResult<PatchLineMutation>;
export type PatchLineMutationOptions = Apollo.BaseMutationOptions<
  PatchLineMutation,
  PatchLineMutationVariables
>;
export const InsertRouteOneDocument = gql`
  mutation InsertRouteOne($object: route_route_insert_input!) {
    insert_route_route_one(object: $object) {
      ...route_all_fields
    }
  }
  ${RouteAllFieldsFragmentDoc}
`;
export type InsertRouteOneMutationFn = Apollo.MutationFunction<
  InsertRouteOneMutation,
  InsertRouteOneMutationVariables
>;

/**
 * __useInsertRouteOneMutation__
 *
 * To run a mutation, you first call `useInsertRouteOneMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertRouteOneMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertRouteOneMutation, { data, loading, error }] = useInsertRouteOneMutation({
 *   variables: {
 *      object: // value for 'object'
 *   },
 * });
 */
export function useInsertRouteOneMutation(
  baseOptions?: Apollo.MutationHookOptions<
    InsertRouteOneMutation,
    InsertRouteOneMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    InsertRouteOneMutation,
    InsertRouteOneMutationVariables
  >(InsertRouteOneDocument, options);
}
export type InsertRouteOneMutationHookResult = ReturnType<
  typeof useInsertRouteOneMutation
>;
export type InsertRouteOneMutationResult =
  Apollo.MutationResult<InsertRouteOneMutation>;
export type InsertRouteOneMutationOptions = Apollo.BaseMutationOptions<
  InsertRouteOneMutation,
  InsertRouteOneMutationVariables
>;
export const PatchRouteDocument = gql`
  mutation PatchRoute($route_id: uuid!, $object: route_route_set_input!) {
    update_route_route(where: { route_id: { _eq: $route_id } }, _set: $object) {
      returning {
        ...route_all_fields
      }
    }
  }
  ${RouteAllFieldsFragmentDoc}
`;
export type PatchRouteMutationFn = Apollo.MutationFunction<
  PatchRouteMutation,
  PatchRouteMutationVariables
>;

/**
 * __usePatchRouteMutation__
 *
 * To run a mutation, you first call `usePatchRouteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePatchRouteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [patchRouteMutation, { data, loading, error }] = usePatchRouteMutation({
 *   variables: {
 *      route_id: // value for 'route_id'
 *      object: // value for 'object'
 *   },
 * });
 */
export function usePatchRouteMutation(
  baseOptions?: Apollo.MutationHookOptions<
    PatchRouteMutation,
    PatchRouteMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<PatchRouteMutation, PatchRouteMutationVariables>(
    PatchRouteDocument,
    options,
  );
}
export type PatchRouteMutationHookResult = ReturnType<
  typeof usePatchRouteMutation
>;
export type PatchRouteMutationResult =
  Apollo.MutationResult<PatchRouteMutation>;
export type PatchRouteMutationOptions = Apollo.BaseMutationOptions<
  PatchRouteMutation,
  PatchRouteMutationVariables
>;
export const DeleteRouteDocument = gql`
  mutation DeleteRoute($route_id: uuid!) {
    delete_route_route(where: { route_id: { _eq: $route_id } }) {
      returning {
        route_id
      }
    }
  }
`;
export type DeleteRouteMutationFn = Apollo.MutationFunction<
  DeleteRouteMutation,
  DeleteRouteMutationVariables
>;

/**
 * __useDeleteRouteMutation__
 *
 * To run a mutation, you first call `useDeleteRouteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteRouteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteRouteMutation, { data, loading, error }] = useDeleteRouteMutation({
 *   variables: {
 *      route_id: // value for 'route_id'
 *   },
 * });
 */
export function useDeleteRouteMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteRouteMutation,
    DeleteRouteMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<DeleteRouteMutation, DeleteRouteMutationVariables>(
    DeleteRouteDocument,
    options,
  );
}
export type DeleteRouteMutationHookResult = ReturnType<
  typeof useDeleteRouteMutation
>;
export type DeleteRouteMutationResult =
  Apollo.MutationResult<DeleteRouteMutation>;
export type DeleteRouteMutationOptions = Apollo.BaseMutationOptions<
  DeleteRouteMutation,
  DeleteRouteMutationVariables
>;
export const GetScheduledStopsOnRouteDocument = gql`
  query GetScheduledStopsOnRoute($routeId: uuid!) {
    journey_pattern_journey_pattern(where: { on_route_id: { _eq: $routeId } }) {
      journey_pattern_id
      scheduled_stop_point_in_journey_patterns {
        journey_pattern_id
        scheduled_stop_point_sequence
        scheduled_stop_points {
          ...scheduled_stop_point_default_fields
        }
      }
    }
  }
  ${ScheduledStopPointDefaultFieldsFragmentDoc}
`;

/**
 * __useGetScheduledStopsOnRouteQuery__
 *
 * To run a query within a React component, call `useGetScheduledStopsOnRouteQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetScheduledStopsOnRouteQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetScheduledStopsOnRouteQuery({
 *   variables: {
 *      routeId: // value for 'routeId'
 *   },
 * });
 */
export function useGetScheduledStopsOnRouteQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetScheduledStopsOnRouteQuery,
    GetScheduledStopsOnRouteQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetScheduledStopsOnRouteQuery,
    GetScheduledStopsOnRouteQueryVariables
  >(GetScheduledStopsOnRouteDocument, options);
}
export function useGetScheduledStopsOnRouteLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetScheduledStopsOnRouteQuery,
    GetScheduledStopsOnRouteQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetScheduledStopsOnRouteQuery,
    GetScheduledStopsOnRouteQueryVariables
  >(GetScheduledStopsOnRouteDocument, options);
}
export type GetScheduledStopsOnRouteQueryHookResult = ReturnType<
  typeof useGetScheduledStopsOnRouteQuery
>;
export type GetScheduledStopsOnRouteLazyQueryHookResult = ReturnType<
  typeof useGetScheduledStopsOnRouteLazyQuery
>;
export type GetScheduledStopsOnRouteQueryResult = Apollo.QueryResult<
  GetScheduledStopsOnRouteQuery,
  GetScheduledStopsOnRouteQueryVariables
>;
export const RemoveStopDocument = gql`
  mutation RemoveStop($stop_id: uuid!) {
    delete_service_pattern_scheduled_stop_point(
      where: { scheduled_stop_point_id: { _eq: $stop_id } }
    ) {
      returning {
        scheduled_stop_point_id
      }
    }
  }
`;
export type RemoveStopMutationFn = Apollo.MutationFunction<
  RemoveStopMutation,
  RemoveStopMutationVariables
>;

/**
 * __useRemoveStopMutation__
 *
 * To run a mutation, you first call `useRemoveStopMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveStopMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeStopMutation, { data, loading, error }] = useRemoveStopMutation({
 *   variables: {
 *      stop_id: // value for 'stop_id'
 *   },
 * });
 */
export function useRemoveStopMutation(
  baseOptions?: Apollo.MutationHookOptions<
    RemoveStopMutation,
    RemoveStopMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<RemoveStopMutation, RemoveStopMutationVariables>(
    RemoveStopDocument,
    options,
  );
}
export type RemoveStopMutationHookResult = ReturnType<
  typeof useRemoveStopMutation
>;
export type RemoveStopMutationResult =
  Apollo.MutationResult<RemoveStopMutation>;
export type RemoveStopMutationOptions = Apollo.BaseMutationOptions<
  RemoveStopMutation,
  RemoveStopMutationVariables
>;
export const GetStopsByLocationDocument = gql`
  query GetStopsByLocation(
    $measured_location_filter: geography_comparison_exp
  ) {
    service_pattern_scheduled_stop_point(
      where: { measured_location: $measured_location_filter }
    ) {
      ...scheduled_stop_point_all_fields
    }
  }
  ${ScheduledStopPointAllFieldsFragmentDoc}
`;

/**
 * __useGetStopsByLocationQuery__
 *
 * To run a query within a React component, call `useGetStopsByLocationQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStopsByLocationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStopsByLocationQuery({
 *   variables: {
 *      measured_location_filter: // value for 'measured_location_filter'
 *   },
 * });
 */
export function useGetStopsByLocationQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetStopsByLocationQuery,
    GetStopsByLocationQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetStopsByLocationQuery,
    GetStopsByLocationQueryVariables
  >(GetStopsByLocationDocument, options);
}
export function useGetStopsByLocationLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetStopsByLocationQuery,
    GetStopsByLocationQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetStopsByLocationQuery,
    GetStopsByLocationQueryVariables
  >(GetStopsByLocationDocument, options);
}
export type GetStopsByLocationQueryHookResult = ReturnType<
  typeof useGetStopsByLocationQuery
>;
export type GetStopsByLocationLazyQueryHookResult = ReturnType<
  typeof useGetStopsByLocationLazyQuery
>;
export type GetStopsByLocationQueryResult = Apollo.QueryResult<
  GetStopsByLocationQuery,
  GetStopsByLocationQueryVariables
>;
export const GetStopsByValidityDocument = gql`
  query GetStopsByValidity(
    $filter: service_pattern_scheduled_stop_point_bool_exp
  ) {
    service_pattern_scheduled_stop_point(where: $filter) {
      ...scheduled_stop_point_all_fields
    }
  }
  ${ScheduledStopPointAllFieldsFragmentDoc}
`;

/**
 * __useGetStopsByValidityQuery__
 *
 * To run a query within a React component, call `useGetStopsByValidityQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStopsByValidityQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStopsByValidityQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *   },
 * });
 */
export function useGetStopsByValidityQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetStopsByValidityQuery,
    GetStopsByValidityQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetStopsByValidityQuery,
    GetStopsByValidityQueryVariables
  >(GetStopsByValidityDocument, options);
}
export function useGetStopsByValidityLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetStopsByValidityQuery,
    GetStopsByValidityQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetStopsByValidityQuery,
    GetStopsByValidityQueryVariables
  >(GetStopsByValidityDocument, options);
}
export type GetStopsByValidityQueryHookResult = ReturnType<
  typeof useGetStopsByValidityQuery
>;
export type GetStopsByValidityLazyQueryHookResult = ReturnType<
  typeof useGetStopsByValidityLazyQuery
>;
export type GetStopsByValidityQueryResult = Apollo.QueryResult<
  GetStopsByValidityQuery,
  GetStopsByValidityQueryVariables
>;
export const GetStopsByIdsDocument = gql`
  query GetStopsByIds($stopIds: [uuid!]) {
    service_pattern_scheduled_stop_point(
      where: { scheduled_stop_point_id: { _in: $stopIds } }
    ) {
      ...scheduled_stop_point_all_fields
    }
  }
  ${ScheduledStopPointAllFieldsFragmentDoc}
`;

/**
 * __useGetStopsByIdsQuery__
 *
 * To run a query within a React component, call `useGetStopsByIdsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStopsByIdsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStopsByIdsQuery({
 *   variables: {
 *      stopIds: // value for 'stopIds'
 *   },
 * });
 */
export function useGetStopsByIdsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetStopsByIdsQuery,
    GetStopsByIdsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<GetStopsByIdsQuery, GetStopsByIdsQueryVariables>(
    GetStopsByIdsDocument,
    options,
  );
}
export function useGetStopsByIdsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetStopsByIdsQuery,
    GetStopsByIdsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<GetStopsByIdsQuery, GetStopsByIdsQueryVariables>(
    GetStopsByIdsDocument,
    options,
  );
}
export type GetStopsByIdsQueryHookResult = ReturnType<
  typeof useGetStopsByIdsQuery
>;
export type GetStopsByIdsLazyQueryHookResult = ReturnType<
  typeof useGetStopsByIdsLazyQuery
>;
export type GetStopsByIdsQueryResult = Apollo.QueryResult<
  GetStopsByIdsQuery,
  GetStopsByIdsQueryVariables
>;
export const GetStopsByLabelsDocument = gql`
  query GetStopsByLabels($stopLabels: [String!]) {
    service_pattern_scheduled_stop_point(
      where: { label: { _in: $stopLabels } }
    ) {
      ...scheduled_stop_point_all_fields
    }
  }
  ${ScheduledStopPointAllFieldsFragmentDoc}
`;

/**
 * __useGetStopsByLabelsQuery__
 *
 * To run a query within a React component, call `useGetStopsByLabelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStopsByLabelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStopsByLabelsQuery({
 *   variables: {
 *      stopLabels: // value for 'stopLabels'
 *   },
 * });
 */
export function useGetStopsByLabelsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetStopsByLabelsQuery,
    GetStopsByLabelsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<GetStopsByLabelsQuery, GetStopsByLabelsQueryVariables>(
    GetStopsByLabelsDocument,
    options,
  );
}
export function useGetStopsByLabelsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetStopsByLabelsQuery,
    GetStopsByLabelsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetStopsByLabelsQuery,
    GetStopsByLabelsQueryVariables
  >(GetStopsByLabelsDocument, options);
}
export type GetStopsByLabelsQueryHookResult = ReturnType<
  typeof useGetStopsByLabelsQuery
>;
export type GetStopsByLabelsLazyQueryHookResult = ReturnType<
  typeof useGetStopsByLabelsLazyQuery
>;
export type GetStopsByLabelsQueryResult = Apollo.QueryResult<
  GetStopsByLabelsQuery,
  GetStopsByLabelsQueryVariables
>;
export const InsertStopDocument = gql`
  mutation InsertStop(
    $object: service_pattern_scheduled_stop_point_insert_input!
  ) {
    insert_service_pattern_scheduled_stop_point_one(object: $object) {
      scheduled_stop_point_id
      located_on_infrastructure_link_id
      direction
      priority
      measured_location
      label
      validity_start
      validity_end
    }
  }
`;
export type InsertStopMutationFn = Apollo.MutationFunction<
  InsertStopMutation,
  InsertStopMutationVariables
>;

/**
 * __useInsertStopMutation__
 *
 * To run a mutation, you first call `useInsertStopMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertStopMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertStopMutation, { data, loading, error }] = useInsertStopMutation({
 *   variables: {
 *      object: // value for 'object'
 *   },
 * });
 */
export function useInsertStopMutation(
  baseOptions?: Apollo.MutationHookOptions<
    InsertStopMutation,
    InsertStopMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<InsertStopMutation, InsertStopMutationVariables>(
    InsertStopDocument,
    options,
  );
}
export type InsertStopMutationHookResult = ReturnType<
  typeof useInsertStopMutation
>;
export type InsertStopMutationResult =
  Apollo.MutationResult<InsertStopMutation>;
export type InsertStopMutationOptions = Apollo.BaseMutationOptions<
  InsertStopMutation,
  InsertStopMutationVariables
>;
export const EditStopDocument = gql`
  mutation EditStop(
    $stop_id: uuid!
    $stop_label: String!
    $stop_patch: service_pattern_scheduled_stop_point_set_input!
    $delete_from_journey_pattern_ids: [uuid!]!
  ) {
    update_service_pattern_scheduled_stop_point(
      where: { scheduled_stop_point_id: { _eq: $stop_id } }
      _set: $stop_patch
    ) {
      returning {
        ...scheduled_stop_point_all_fields
      }
    }
    delete_journey_pattern_scheduled_stop_point_in_journey_pattern(
      where: {
        _and: {
          scheduled_stop_point_label: { _eq: $stop_label }
          journey_pattern_id: { _in: $delete_from_journey_pattern_ids }
        }
      }
    ) {
      returning {
        ...scheduled_stop_point_in_journey_pattern_all_fields
      }
    }
  }
  ${ScheduledStopPointAllFieldsFragmentDoc}
  ${ScheduledStopPointInJourneyPatternAllFieldsFragmentDoc}
`;
export type EditStopMutationFn = Apollo.MutationFunction<
  EditStopMutation,
  EditStopMutationVariables
>;

/**
 * __useEditStopMutation__
 *
 * To run a mutation, you first call `useEditStopMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditStopMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editStopMutation, { data, loading, error }] = useEditStopMutation({
 *   variables: {
 *      stop_id: // value for 'stop_id'
 *      stop_label: // value for 'stop_label'
 *      stop_patch: // value for 'stop_patch'
 *      delete_from_journey_pattern_ids: // value for 'delete_from_journey_pattern_ids'
 *   },
 * });
 */
export function useEditStopMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditStopMutation,
    EditStopMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<EditStopMutation, EditStopMutationVariables>(
    EditStopDocument,
    options,
  );
}
export type EditStopMutationHookResult = ReturnType<typeof useEditStopMutation>;
export type EditStopMutationResult = Apollo.MutationResult<EditStopMutation>;
export type EditStopMutationOptions = Apollo.BaseMutationOptions<
  EditStopMutation,
  EditStopMutationVariables
>;
export const GetStopWithRouteGraphDataByIdDocument = gql`
  query GetStopWithRouteGraphDataById($stopId: uuid!) {
    service_pattern_scheduled_stop_point(
      where: { scheduled_stop_point_id: { _eq: $stopId } }
    ) {
      ...scheduled_stop_point_all_fields
      scheduled_stop_point_in_journey_patterns {
        ...scheduled_stop_point_in_journey_pattern_all_fields
        journey_pattern {
          journey_pattern_id
          journey_pattern_route {
            ...route_default_fields
            infrastructure_links_along_route {
              route_id
              infrastructure_link_id
              infrastructure_link_sequence
            }
          }
        }
      }
    }
  }
  ${ScheduledStopPointAllFieldsFragmentDoc}
  ${ScheduledStopPointInJourneyPatternAllFieldsFragmentDoc}
  ${RouteDefaultFieldsFragmentDoc}
`;

/**
 * __useGetStopWithRouteGraphDataByIdQuery__
 *
 * To run a query within a React component, call `useGetStopWithRouteGraphDataByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStopWithRouteGraphDataByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStopWithRouteGraphDataByIdQuery({
 *   variables: {
 *      stopId: // value for 'stopId'
 *   },
 * });
 */
export function useGetStopWithRouteGraphDataByIdQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetStopWithRouteGraphDataByIdQuery,
    GetStopWithRouteGraphDataByIdQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetStopWithRouteGraphDataByIdQuery,
    GetStopWithRouteGraphDataByIdQueryVariables
  >(GetStopWithRouteGraphDataByIdDocument, options);
}
export function useGetStopWithRouteGraphDataByIdLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetStopWithRouteGraphDataByIdQuery,
    GetStopWithRouteGraphDataByIdQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetStopWithRouteGraphDataByIdQuery,
    GetStopWithRouteGraphDataByIdQueryVariables
  >(GetStopWithRouteGraphDataByIdDocument, options);
}
export type GetStopWithRouteGraphDataByIdQueryHookResult = ReturnType<
  typeof useGetStopWithRouteGraphDataByIdQuery
>;
export type GetStopWithRouteGraphDataByIdLazyQueryHookResult = ReturnType<
  typeof useGetStopWithRouteGraphDataByIdLazyQuery
>;
export type GetStopWithRouteGraphDataByIdQueryResult = Apollo.QueryResult<
  GetStopWithRouteGraphDataByIdQuery,
  GetStopWithRouteGraphDataByIdQueryVariables
>;
export const GetRoutesBrokenByStopChangeDocument = gql`
  query GetRoutesBrokenByStopChange(
    $new_located_on_infrastructure_link_id: uuid!
    $new_direction: String!
    $new_label: String!
    $new_validity_start: date
    $new_validity_end: date
    $new_priority: Int!
    $new_measured_location: geography!
    $replace_scheduled_stop_point_id: uuid
  ) {
    journey_pattern_check_infra_link_stop_refs_with_new_scheduled_stop_point(
      args: {
        replace_scheduled_stop_point_id: $replace_scheduled_stop_point_id
        new_located_on_infrastructure_link_id: $new_located_on_infrastructure_link_id
        new_direction: $new_direction
        new_label: $new_label
        new_validity_start: $new_validity_start
        new_validity_end: $new_validity_end
        new_priority: $new_priority
        new_measured_location: $new_measured_location
      }
    ) {
      journey_pattern_id
      journey_pattern_route {
        ...route_all_fields
      }
    }
  }
  ${RouteAllFieldsFragmentDoc}
`;

/**
 * __useGetRoutesBrokenByStopChangeQuery__
 *
 * To run a query within a React component, call `useGetRoutesBrokenByStopChangeQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRoutesBrokenByStopChangeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRoutesBrokenByStopChangeQuery({
 *   variables: {
 *      new_located_on_infrastructure_link_id: // value for 'new_located_on_infrastructure_link_id'
 *      new_direction: // value for 'new_direction'
 *      new_label: // value for 'new_label'
 *      new_validity_start: // value for 'new_validity_start'
 *      new_validity_end: // value for 'new_validity_end'
 *      new_priority: // value for 'new_priority'
 *      new_measured_location: // value for 'new_measured_location'
 *      replace_scheduled_stop_point_id: // value for 'replace_scheduled_stop_point_id'
 *   },
 * });
 */
export function useGetRoutesBrokenByStopChangeQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetRoutesBrokenByStopChangeQuery,
    GetRoutesBrokenByStopChangeQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetRoutesBrokenByStopChangeQuery,
    GetRoutesBrokenByStopChangeQueryVariables
  >(GetRoutesBrokenByStopChangeDocument, options);
}
export function useGetRoutesBrokenByStopChangeLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetRoutesBrokenByStopChangeQuery,
    GetRoutesBrokenByStopChangeQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetRoutesBrokenByStopChangeQuery,
    GetRoutesBrokenByStopChangeQueryVariables
  >(GetRoutesBrokenByStopChangeDocument, options);
}
export type GetRoutesBrokenByStopChangeQueryHookResult = ReturnType<
  typeof useGetRoutesBrokenByStopChangeQuery
>;
export type GetRoutesBrokenByStopChangeLazyQueryHookResult = ReturnType<
  typeof useGetRoutesBrokenByStopChangeLazyQuery
>;
export type GetRoutesBrokenByStopChangeQueryResult = Apollo.QueryResult<
  GetRoutesBrokenByStopChangeQuery,
  GetRoutesBrokenByStopChangeQueryVariables
>;
export const GetHighestPriorityLineDetailsWithRoutesDocument = gql`
  query GetHighestPriorityLineDetailsWithRoutes(
    $lineFilters: route_line_bool_exp
    $lineRouteFilters: route_route_bool_exp
    $routeStopFilters: service_pattern_scheduled_stop_point_bool_exp
  ) {
    route_line(where: $lineFilters, order_by: { priority: desc }, limit: 1) {
      ...line_with_routes_unique_fields
    }
  }
  ${LineWithRoutesUniqueFieldsFragmentDoc}
`;

/**
 * __useGetHighestPriorityLineDetailsWithRoutesQuery__
 *
 * To run a query within a React component, call `useGetHighestPriorityLineDetailsWithRoutesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetHighestPriorityLineDetailsWithRoutesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetHighestPriorityLineDetailsWithRoutesQuery({
 *   variables: {
 *      lineFilters: // value for 'lineFilters'
 *      lineRouteFilters: // value for 'lineRouteFilters'
 *      routeStopFilters: // value for 'routeStopFilters'
 *   },
 * });
 */
export function useGetHighestPriorityLineDetailsWithRoutesQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetHighestPriorityLineDetailsWithRoutesQuery,
    GetHighestPriorityLineDetailsWithRoutesQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetHighestPriorityLineDetailsWithRoutesQuery,
    GetHighestPriorityLineDetailsWithRoutesQueryVariables
  >(GetHighestPriorityLineDetailsWithRoutesDocument, options);
}
export function useGetHighestPriorityLineDetailsWithRoutesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetHighestPriorityLineDetailsWithRoutesQuery,
    GetHighestPriorityLineDetailsWithRoutesQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetHighestPriorityLineDetailsWithRoutesQuery,
    GetHighestPriorityLineDetailsWithRoutesQueryVariables
  >(GetHighestPriorityLineDetailsWithRoutesDocument, options);
}
export type GetHighestPriorityLineDetailsWithRoutesQueryHookResult = ReturnType<
  typeof useGetHighestPriorityLineDetailsWithRoutesQuery
>;
export type GetHighestPriorityLineDetailsWithRoutesLazyQueryHookResult =
  ReturnType<typeof useGetHighestPriorityLineDetailsWithRoutesLazyQuery>;
export type GetHighestPriorityLineDetailsWithRoutesQueryResult =
  Apollo.QueryResult<
    GetHighestPriorityLineDetailsWithRoutesQuery,
    GetHighestPriorityLineDetailsWithRoutesQueryVariables
  >;
export const UpdateRouteGeometryDocument = gql`
  mutation UpdateRouteGeometry(
    $route_id: uuid!
    $journey_pattern_id: uuid!
    $new_infrastructure_links: [route_infrastructure_link_along_route_insert_input!]!
    $new_stops_in_journey_pattern: [journey_pattern_scheduled_stop_point_in_journey_pattern_insert_input!]!
  ) {
    delete_route_infrastructure_link_along_route(
      where: { route_id: { _eq: $route_id } }
    ) {
      returning {
        infrastructure_link_id
        infrastructure_link_sequence
        route_id
      }
    }
    insert_route_infrastructure_link_along_route(
      objects: $new_infrastructure_links
    ) {
      returning {
        route_id
        infrastructure_link_id
        infrastructure_link_sequence
        infrastructure_link {
          infrastructure_link_id
          shape
        }
        is_traversal_forwards
      }
    }
    delete_journey_pattern_scheduled_stop_point_in_journey_pattern(
      where: { journey_pattern_id: { _eq: $journey_pattern_id } }
    ) {
      returning {
        scheduled_stop_point_label
        scheduled_stop_point_sequence
        journey_pattern_id
      }
    }
    insert_journey_pattern_scheduled_stop_point_in_journey_pattern(
      objects: $new_stops_in_journey_pattern
    ) {
      returning {
        scheduled_stop_point_label
        scheduled_stop_point_sequence
        journey_pattern_id
      }
    }
  }
`;
export type UpdateRouteGeometryMutationFn = Apollo.MutationFunction<
  UpdateRouteGeometryMutation,
  UpdateRouteGeometryMutationVariables
>;

/**
 * __useUpdateRouteGeometryMutation__
 *
 * To run a mutation, you first call `useUpdateRouteGeometryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRouteGeometryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRouteGeometryMutation, { data, loading, error }] = useUpdateRouteGeometryMutation({
 *   variables: {
 *      route_id: // value for 'route_id'
 *      journey_pattern_id: // value for 'journey_pattern_id'
 *      new_infrastructure_links: // value for 'new_infrastructure_links'
 *      new_stops_in_journey_pattern: // value for 'new_stops_in_journey_pattern'
 *   },
 * });
 */
export function useUpdateRouteGeometryMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpdateRouteGeometryMutation,
    UpdateRouteGeometryMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    UpdateRouteGeometryMutation,
    UpdateRouteGeometryMutationVariables
  >(UpdateRouteGeometryDocument, options);
}
export type UpdateRouteGeometryMutationHookResult = ReturnType<
  typeof useUpdateRouteGeometryMutation
>;
export type UpdateRouteGeometryMutationResult =
  Apollo.MutationResult<UpdateRouteGeometryMutation>;
export type UpdateRouteGeometryMutationOptions = Apollo.BaseMutationOptions<
  UpdateRouteGeometryMutation,
  UpdateRouteGeometryMutationVariables
>;
export const UpdateRouteJourneyPatternDocument = gql`
  mutation UpdateRouteJourneyPattern(
    $journey_pattern_id: uuid!
    $new_stops_in_journey_pattern: [journey_pattern_scheduled_stop_point_in_journey_pattern_insert_input!]!
  ) {
    delete_journey_pattern_scheduled_stop_point_in_journey_pattern(
      where: { journey_pattern_id: { _eq: $journey_pattern_id } }
    ) {
      returning {
        scheduled_stop_point_label
        scheduled_stop_point_sequence
        journey_pattern_id
      }
    }
    insert_journey_pattern_scheduled_stop_point_in_journey_pattern(
      objects: $new_stops_in_journey_pattern
    ) {
      returning {
        scheduled_stop_point_label
        scheduled_stop_point_sequence
        journey_pattern_id
      }
    }
  }
`;
export type UpdateRouteJourneyPatternMutationFn = Apollo.MutationFunction<
  UpdateRouteJourneyPatternMutation,
  UpdateRouteJourneyPatternMutationVariables
>;

/**
 * __useUpdateRouteJourneyPatternMutation__
 *
 * To run a mutation, you first call `useUpdateRouteJourneyPatternMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRouteJourneyPatternMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRouteJourneyPatternMutation, { data, loading, error }] = useUpdateRouteJourneyPatternMutation({
 *   variables: {
 *      journey_pattern_id: // value for 'journey_pattern_id'
 *      new_stops_in_journey_pattern: // value for 'new_stops_in_journey_pattern'
 *   },
 * });
 */
export function useUpdateRouteJourneyPatternMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpdateRouteJourneyPatternMutation,
    UpdateRouteJourneyPatternMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    UpdateRouteJourneyPatternMutation,
    UpdateRouteJourneyPatternMutationVariables
  >(UpdateRouteJourneyPatternDocument, options);
}
export type UpdateRouteJourneyPatternMutationHookResult = ReturnType<
  typeof useUpdateRouteJourneyPatternMutation
>;
export type UpdateRouteJourneyPatternMutationResult =
  Apollo.MutationResult<UpdateRouteJourneyPatternMutation>;
export type UpdateRouteJourneyPatternMutationOptions =
  Apollo.BaseMutationOptions<
    UpdateRouteJourneyPatternMutation,
    UpdateRouteJourneyPatternMutationVariables
  >;
export const GetLinksWithStopsByExternalLinkIdsDocument = gql`
  query GetLinksWithStopsByExternalLinkIds($externalLinkIds: [String!]) {
    infrastructure_network_infrastructure_link(
      where: { external_link_id: { _in: $externalLinkIds } }
    ) {
      ...route_infra_link_fields
    }
  }
  ${RouteInfraLinkFieldsFragmentDoc}
`;

/**
 * __useGetLinksWithStopsByExternalLinkIdsQuery__
 *
 * To run a query within a React component, call `useGetLinksWithStopsByExternalLinkIdsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLinksWithStopsByExternalLinkIdsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLinksWithStopsByExternalLinkIdsQuery({
 *   variables: {
 *      externalLinkIds: // value for 'externalLinkIds'
 *   },
 * });
 */
export function useGetLinksWithStopsByExternalLinkIdsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetLinksWithStopsByExternalLinkIdsQuery,
    GetLinksWithStopsByExternalLinkIdsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetLinksWithStopsByExternalLinkIdsQuery,
    GetLinksWithStopsByExternalLinkIdsQueryVariables
  >(GetLinksWithStopsByExternalLinkIdsDocument, options);
}
export function useGetLinksWithStopsByExternalLinkIdsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetLinksWithStopsByExternalLinkIdsQuery,
    GetLinksWithStopsByExternalLinkIdsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetLinksWithStopsByExternalLinkIdsQuery,
    GetLinksWithStopsByExternalLinkIdsQueryVariables
  >(GetLinksWithStopsByExternalLinkIdsDocument, options);
}
export type GetLinksWithStopsByExternalLinkIdsQueryHookResult = ReturnType<
  typeof useGetLinksWithStopsByExternalLinkIdsQuery
>;
export type GetLinksWithStopsByExternalLinkIdsLazyQueryHookResult = ReturnType<
  typeof useGetLinksWithStopsByExternalLinkIdsLazyQuery
>;
export type GetLinksWithStopsByExternalLinkIdsQueryResult = Apollo.QueryResult<
  GetLinksWithStopsByExternalLinkIdsQuery,
  GetLinksWithStopsByExternalLinkIdsQueryVariables
>;
export const GetLineRoutesByLabelDocument = gql`
  query GetLineRoutesByLabel(
    $lineFilters: route_line_bool_exp
    $lineRouteFilters: route_route_bool_exp
  ) {
    route_line(where: $lineFilters) {
      line_id
      line_routes(where: $lineRouteFilters) {
        ...displayed_route
      }
    }
  }
  ${DisplayedRouteFragmentDoc}
`;

/**
 * __useGetLineRoutesByLabelQuery__
 *
 * To run a query within a React component, call `useGetLineRoutesByLabelQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLineRoutesByLabelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLineRoutesByLabelQuery({
 *   variables: {
 *      lineFilters: // value for 'lineFilters'
 *      lineRouteFilters: // value for 'lineRouteFilters'
 *   },
 * });
 */
export function useGetLineRoutesByLabelQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetLineRoutesByLabelQuery,
    GetLineRoutesByLabelQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetLineRoutesByLabelQuery,
    GetLineRoutesByLabelQueryVariables
  >(GetLineRoutesByLabelDocument, options);
}
export function useGetLineRoutesByLabelLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetLineRoutesByLabelQuery,
    GetLineRoutesByLabelQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetLineRoutesByLabelQuery,
    GetLineRoutesByLabelQueryVariables
  >(GetLineRoutesByLabelDocument, options);
}
export type GetLineRoutesByLabelQueryHookResult = ReturnType<
  typeof useGetLineRoutesByLabelQuery
>;
export type GetLineRoutesByLabelLazyQueryHookResult = ReturnType<
  typeof useGetLineRoutesByLabelLazyQuery
>;
export type GetLineRoutesByLabelQueryResult = Apollo.QueryResult<
  GetLineRoutesByLabelQuery,
  GetLineRoutesByLabelQueryVariables
>;
export const GetRouteByFiltersDocument = gql`
  query GetRouteByFilters($routeFilters: route_route_bool_exp) {
    route_route(where: $routeFilters) {
      ...displayed_route
    }
  }
  ${DisplayedRouteFragmentDoc}
`;

/**
 * __useGetRouteByFiltersQuery__
 *
 * To run a query within a React component, call `useGetRouteByFiltersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRouteByFiltersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRouteByFiltersQuery({
 *   variables: {
 *      routeFilters: // value for 'routeFilters'
 *   },
 * });
 */
export function useGetRouteByFiltersQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetRouteByFiltersQuery,
    GetRouteByFiltersQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetRouteByFiltersQuery,
    GetRouteByFiltersQueryVariables
  >(GetRouteByFiltersDocument, options);
}
export function useGetRouteByFiltersLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetRouteByFiltersQuery,
    GetRouteByFiltersQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetRouteByFiltersQuery,
    GetRouteByFiltersQueryVariables
  >(GetRouteByFiltersDocument, options);
}
export type GetRouteByFiltersQueryHookResult = ReturnType<
  typeof useGetRouteByFiltersQuery
>;
export type GetRouteByFiltersLazyQueryHookResult = ReturnType<
  typeof useGetRouteByFiltersLazyQuery
>;
export type GetRouteByFiltersQueryResult = Apollo.QueryResult<
  GetRouteByFiltersQuery,
  GetRouteByFiltersQueryVariables
>;
export const GetRouteWithInfrastructureLinksWithStopsDocument = gql`
  query GetRouteWithInfrastructureLinksWithStops($route_id: uuid!) {
    route_route_by_pk(route_id: $route_id) {
      ...route_with_infrastructure_links_with_stops_and_jps
    }
  }
  ${RouteWithInfrastructureLinksWithStopsAndJpsFragmentDoc}
`;

/**
 * __useGetRouteWithInfrastructureLinksWithStopsQuery__
 *
 * To run a query within a React component, call `useGetRouteWithInfrastructureLinksWithStopsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRouteWithInfrastructureLinksWithStopsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRouteWithInfrastructureLinksWithStopsQuery({
 *   variables: {
 *      route_id: // value for 'route_id'
 *   },
 * });
 */
export function useGetRouteWithInfrastructureLinksWithStopsQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetRouteWithInfrastructureLinksWithStopsQuery,
    GetRouteWithInfrastructureLinksWithStopsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetRouteWithInfrastructureLinksWithStopsQuery,
    GetRouteWithInfrastructureLinksWithStopsQueryVariables
  >(GetRouteWithInfrastructureLinksWithStopsDocument, options);
}
export function useGetRouteWithInfrastructureLinksWithStopsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetRouteWithInfrastructureLinksWithStopsQuery,
    GetRouteWithInfrastructureLinksWithStopsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetRouteWithInfrastructureLinksWithStopsQuery,
    GetRouteWithInfrastructureLinksWithStopsQueryVariables
  >(GetRouteWithInfrastructureLinksWithStopsDocument, options);
}
export type GetRouteWithInfrastructureLinksWithStopsQueryHookResult =
  ReturnType<typeof useGetRouteWithInfrastructureLinksWithStopsQuery>;
export type GetRouteWithInfrastructureLinksWithStopsLazyQueryHookResult =
  ReturnType<typeof useGetRouteWithInfrastructureLinksWithStopsLazyQuery>;
export type GetRouteWithInfrastructureLinksWithStopsQueryResult =
  Apollo.QueryResult<
    GetRouteWithInfrastructureLinksWithStopsQuery,
    GetRouteWithInfrastructureLinksWithStopsQueryVariables
  >;
export const SearchLinesAndRoutesDocument = gql`
  query SearchLinesAndRoutes(
    $lineFilter: route_line_bool_exp
    $routeFilter: route_route_bool_exp
    $lineOrderBy: [route_line_order_by!]
    $routeOrderBy: [route_route_order_by!]
  ) {
    route_line(where: $lineFilter, order_by: $lineOrderBy) {
      ...line_table_row
    }
    route_route(where: $routeFilter, order_by: $routeOrderBy) {
      ...route_table_row
    }
  }
  ${LineTableRowFragmentDoc}
  ${RouteTableRowFragmentDoc}
`;

/**
 * __useSearchLinesAndRoutesQuery__
 *
 * To run a query within a React component, call `useSearchLinesAndRoutesQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchLinesAndRoutesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchLinesAndRoutesQuery({
 *   variables: {
 *      lineFilter: // value for 'lineFilter'
 *      routeFilter: // value for 'routeFilter'
 *      lineOrderBy: // value for 'lineOrderBy'
 *      routeOrderBy: // value for 'routeOrderBy'
 *   },
 * });
 */
export function useSearchLinesAndRoutesQuery(
  baseOptions?: Apollo.QueryHookOptions<
    SearchLinesAndRoutesQuery,
    SearchLinesAndRoutesQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    SearchLinesAndRoutesQuery,
    SearchLinesAndRoutesQueryVariables
  >(SearchLinesAndRoutesDocument, options);
}
export function useSearchLinesAndRoutesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    SearchLinesAndRoutesQuery,
    SearchLinesAndRoutesQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    SearchLinesAndRoutesQuery,
    SearchLinesAndRoutesQueryVariables
  >(SearchLinesAndRoutesDocument, options);
}
export type SearchLinesAndRoutesQueryHookResult = ReturnType<
  typeof useSearchLinesAndRoutesQuery
>;
export type SearchLinesAndRoutesLazyQueryHookResult = ReturnType<
  typeof useSearchLinesAndRoutesLazyQuery
>;
export type SearchLinesAndRoutesQueryResult = Apollo.QueryResult<
  SearchLinesAndRoutesQuery,
  SearchLinesAndRoutesQueryVariables
>;
export const SearchStopsDocument = gql`
  query SearchStops(
    $stopFilter: service_pattern_scheduled_stop_point_bool_exp
    $stopOrderBy: [service_pattern_scheduled_stop_point_order_by!]
  ) {
    service_pattern_scheduled_stop_point(
      where: $stopFilter
      order_by: $stopOrderBy
    ) {
      ...stop_table_row
    }
  }
  ${StopTableRowFragmentDoc}
`;

/**
 * __useSearchStopsQuery__
 *
 * To run a query within a React component, call `useSearchStopsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchStopsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchStopsQuery({
 *   variables: {
 *      stopFilter: // value for 'stopFilter'
 *      stopOrderBy: // value for 'stopOrderBy'
 *   },
 * });
 */
export function useSearchStopsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    SearchStopsQuery,
    SearchStopsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<SearchStopsQuery, SearchStopsQueryVariables>(
    SearchStopsDocument,
    options,
  );
}
export function useSearchStopsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    SearchStopsQuery,
    SearchStopsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<SearchStopsQuery, SearchStopsQueryVariables>(
    SearchStopsDocument,
    options,
  );
}
export type SearchStopsQueryHookResult = ReturnType<typeof useSearchStopsQuery>;
export type SearchStopsLazyQueryHookResult = ReturnType<
  typeof useSearchStopsLazyQuery
>;
export type SearchStopsQueryResult = Apollo.QueryResult<
  SearchStopsQuery,
  SearchStopsQueryVariables
>;
export const UpdateStopPlaceDocument = gql`
  mutation UpdateStopPlace($input: stop_registry_StopPlaceInput!) {
    stop_registry {
      mutateStopPlace(StopPlace: $input) {
        ...stop_place_details
      }
    }
  }
  ${StopPlaceDetailsFragmentDoc}
`;
export type UpdateStopPlaceMutationFn = Apollo.MutationFunction<
  UpdateStopPlaceMutation,
  UpdateStopPlaceMutationVariables
>;

/**
 * __useUpdateStopPlaceMutation__
 *
 * To run a mutation, you first call `useUpdateStopPlaceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateStopPlaceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateStopPlaceMutation, { data, loading, error }] = useUpdateStopPlaceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateStopPlaceMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpdateStopPlaceMutation,
    UpdateStopPlaceMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    UpdateStopPlaceMutation,
    UpdateStopPlaceMutationVariables
  >(UpdateStopPlaceDocument, options);
}
export type UpdateStopPlaceMutationHookResult = ReturnType<
  typeof useUpdateStopPlaceMutation
>;
export type UpdateStopPlaceMutationResult =
  Apollo.MutationResult<UpdateStopPlaceMutation>;
export type UpdateStopPlaceMutationOptions = Apollo.BaseMutationOptions<
  UpdateStopPlaceMutation,
  UpdateStopPlaceMutationVariables
>;
export const GetStopDetailsByIdDocument = gql`
  query GetStopDetailsById($scheduled_stop_point_id: uuid!) {
    service_pattern_scheduled_stop_point_by_pk(
      scheduled_stop_point_id: $scheduled_stop_point_id
    ) {
      ...scheduled_stop_point_detail_fields
      stop_place {
        ...stop_place_details
      }
    }
  }
  ${ScheduledStopPointDetailFieldsFragmentDoc}
  ${StopPlaceDetailsFragmentDoc}
`;

/**
 * __useGetStopDetailsByIdQuery__
 *
 * To run a query within a React component, call `useGetStopDetailsByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStopDetailsByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStopDetailsByIdQuery({
 *   variables: {
 *      scheduled_stop_point_id: // value for 'scheduled_stop_point_id'
 *   },
 * });
 */
export function useGetStopDetailsByIdQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetStopDetailsByIdQuery,
    GetStopDetailsByIdQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetStopDetailsByIdQuery,
    GetStopDetailsByIdQueryVariables
  >(GetStopDetailsByIdDocument, options);
}
export function useGetStopDetailsByIdLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetStopDetailsByIdQuery,
    GetStopDetailsByIdQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetStopDetailsByIdQuery,
    GetStopDetailsByIdQueryVariables
  >(GetStopDetailsByIdDocument, options);
}
export type GetStopDetailsByIdQueryHookResult = ReturnType<
  typeof useGetStopDetailsByIdQuery
>;
export type GetStopDetailsByIdLazyQueryHookResult = ReturnType<
  typeof useGetStopDetailsByIdLazyQuery
>;
export type GetStopDetailsByIdQueryResult = Apollo.QueryResult<
  GetStopDetailsByIdQuery,
  GetStopDetailsByIdQueryVariables
>;
export const PatchScheduledStopPointTimingSettingsDocument = gql`
  mutation PatchScheduledStopPointTimingSettings(
    $stopLabel: String!
    $journeyPatternId: uuid!
    $sequence: Int!
    $patch: journey_pattern_scheduled_stop_point_in_journey_pattern_set_input!
    $stopId: uuid!
    $timingPlaceId: uuid
  ) {
    update_service_pattern_scheduled_stop_point(
      where: { scheduled_stop_point_id: { _eq: $stopId } }
      _set: { timing_place_id: $timingPlaceId }
    ) {
      returning {
        scheduled_stop_point_id
        timing_place {
          timing_place_id
        }
      }
    }
    update_journey_pattern_scheduled_stop_point_in_journey_pattern(
      where: {
        scheduled_stop_point_label: { _eq: $stopLabel }
        scheduled_stop_point_sequence: { _eq: $sequence }
        journey_pattern_id: { _eq: $journeyPatternId }
      }
      _set: $patch
    ) {
      returning {
        ...scheduled_stop_point_in_journey_pattern_all_fields
      }
    }
  }
  ${ScheduledStopPointInJourneyPatternAllFieldsFragmentDoc}
`;
export type PatchScheduledStopPointTimingSettingsMutationFn =
  Apollo.MutationFunction<
    PatchScheduledStopPointTimingSettingsMutation,
    PatchScheduledStopPointTimingSettingsMutationVariables
  >;

/**
 * __usePatchScheduledStopPointTimingSettingsMutation__
 *
 * To run a mutation, you first call `usePatchScheduledStopPointTimingSettingsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePatchScheduledStopPointTimingSettingsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [patchScheduledStopPointTimingSettingsMutation, { data, loading, error }] = usePatchScheduledStopPointTimingSettingsMutation({
 *   variables: {
 *      stopLabel: // value for 'stopLabel'
 *      journeyPatternId: // value for 'journeyPatternId'
 *      sequence: // value for 'sequence'
 *      patch: // value for 'patch'
 *      stopId: // value for 'stopId'
 *      timingPlaceId: // value for 'timingPlaceId'
 *   },
 * });
 */
export function usePatchScheduledStopPointTimingSettingsMutation(
  baseOptions?: Apollo.MutationHookOptions<
    PatchScheduledStopPointTimingSettingsMutation,
    PatchScheduledStopPointTimingSettingsMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    PatchScheduledStopPointTimingSettingsMutation,
    PatchScheduledStopPointTimingSettingsMutationVariables
  >(PatchScheduledStopPointTimingSettingsDocument, options);
}
export type PatchScheduledStopPointTimingSettingsMutationHookResult =
  ReturnType<typeof usePatchScheduledStopPointTimingSettingsMutation>;
export type PatchScheduledStopPointTimingSettingsMutationResult =
  Apollo.MutationResult<PatchScheduledStopPointTimingSettingsMutation>;
export type PatchScheduledStopPointTimingSettingsMutationOptions =
  Apollo.BaseMutationOptions<
    PatchScheduledStopPointTimingSettingsMutation,
    PatchScheduledStopPointTimingSettingsMutationVariables
  >;
export const GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsDocument = gql`
  query GetScheduledStopPointsInJourneyPatternsUsedAsTimingPoints(
    $label: String!
  ) {
    journey_pattern_scheduled_stop_point_in_journey_pattern(
      where: {
        is_used_as_timing_point: { _eq: true }
        scheduled_stop_points: { label: { _eq: $label } }
      }
    ) {
      journey_pattern_id
      scheduled_stop_point_label
      scheduled_stop_point_sequence
      journey_pattern {
        journey_pattern_id
        on_route_id
        journey_pattern_route {
          route_id
          label
          variant
        }
      }
    }
  }
`;

/**
 * __useGetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery__
 *
 * To run a query within a React component, call `useGetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery({
 *   variables: {
 *      label: // value for 'label'
 *   },
 * });
 */
export function useGetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery,
    GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery,
    GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQueryVariables
  >(GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsDocument, options);
}
export function useGetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery,
    GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery,
    GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQueryVariables
  >(GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsDocument, options);
}
export type GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQueryHookResult =
  ReturnType<
    typeof useGetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery
  >;
export type GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsLazyQueryHookResult =
  ReturnType<
    typeof useGetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsLazyQuery
  >;
export type GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQueryResult =
  Apollo.QueryResult<
    GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery,
    GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQueryVariables
  >;
export const CreateSubstituteOperatingPeriodDocument = gql`
  mutation CreateSubstituteOperatingPeriod(
    $data: [timetables_service_calendar_substitute_operating_period_insert_input!]!
  ) {
    timetables {
      timetables_insert_service_calendar_substitute_operating_period(
        objects: $data
      ) {
        returning {
          substitute_operating_period_id
          period_name
          is_preset
          substitute_operating_day_by_line_types {
            begin_time
            end_time
            substitute_day_of_week
            substitute_operating_day_by_line_type_id
            superseded_date
            type_of_line
          }
        }
      }
    }
  }
`;
export type CreateSubstituteOperatingPeriodMutationFn = Apollo.MutationFunction<
  CreateSubstituteOperatingPeriodMutation,
  CreateSubstituteOperatingPeriodMutationVariables
>;

/**
 * __useCreateSubstituteOperatingPeriodMutation__
 *
 * To run a mutation, you first call `useCreateSubstituteOperatingPeriodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSubstituteOperatingPeriodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSubstituteOperatingPeriodMutation, { data, loading, error }] = useCreateSubstituteOperatingPeriodMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateSubstituteOperatingPeriodMutation(
  baseOptions?: Apollo.MutationHookOptions<
    CreateSubstituteOperatingPeriodMutation,
    CreateSubstituteOperatingPeriodMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    CreateSubstituteOperatingPeriodMutation,
    CreateSubstituteOperatingPeriodMutationVariables
  >(CreateSubstituteOperatingPeriodDocument, options);
}
export type CreateSubstituteOperatingPeriodMutationHookResult = ReturnType<
  typeof useCreateSubstituteOperatingPeriodMutation
>;
export type CreateSubstituteOperatingPeriodMutationResult =
  Apollo.MutationResult<CreateSubstituteOperatingPeriodMutation>;
export type CreateSubstituteOperatingPeriodMutationOptions =
  Apollo.BaseMutationOptions<
    CreateSubstituteOperatingPeriodMutation,
    CreateSubstituteOperatingPeriodMutationVariables
  >;
export const DeleteSubstituteOperatingPeriodDocument = gql`
  mutation DeleteSubstituteOperatingPeriod($ids: [uuid!]!) {
    timetables {
      timetables_delete_service_calendar_substitute_operating_period(
        where: { substitute_operating_period_id: { _in: $ids } }
      ) {
        affected_rows
      }
    }
  }
`;
export type DeleteSubstituteOperatingPeriodMutationFn = Apollo.MutationFunction<
  DeleteSubstituteOperatingPeriodMutation,
  DeleteSubstituteOperatingPeriodMutationVariables
>;

/**
 * __useDeleteSubstituteOperatingPeriodMutation__
 *
 * To run a mutation, you first call `useDeleteSubstituteOperatingPeriodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteSubstituteOperatingPeriodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteSubstituteOperatingPeriodMutation, { data, loading, error }] = useDeleteSubstituteOperatingPeriodMutation({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useDeleteSubstituteOperatingPeriodMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteSubstituteOperatingPeriodMutation,
    DeleteSubstituteOperatingPeriodMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    DeleteSubstituteOperatingPeriodMutation,
    DeleteSubstituteOperatingPeriodMutationVariables
  >(DeleteSubstituteOperatingPeriodDocument, options);
}
export type DeleteSubstituteOperatingPeriodMutationHookResult = ReturnType<
  typeof useDeleteSubstituteOperatingPeriodMutation
>;
export type DeleteSubstituteOperatingPeriodMutationResult =
  Apollo.MutationResult<DeleteSubstituteOperatingPeriodMutation>;
export type DeleteSubstituteOperatingPeriodMutationOptions =
  Apollo.BaseMutationOptions<
    DeleteSubstituteOperatingPeriodMutation,
    DeleteSubstituteOperatingPeriodMutationVariables
  >;
export const EditSubstituteOperatingPeriodsDocument = gql`
  mutation EditSubstituteOperatingPeriods(
    $periodsToInsert: [timetables_service_calendar_substitute_operating_period_insert_input!]!
    $periodsToDelete: [uuid!]!
    $daysToInsert: [timetables_service_calendar_substitute_operating_day_by_line_type_insert_input!]!
  ) {
    timetables {
      timetables_insert_service_calendar_substitute_operating_period(
        objects: $periodsToInsert
        on_conflict: {
          constraint: substitute_operating_period_pkey
          update_columns: [period_name]
        }
      ) {
        affected_rows
      }
      timetables_delete_service_calendar_substitute_operating_day_by_line_type(
        where: { substitute_operating_period_id: { _in: $periodsToDelete } }
      ) {
        affected_rows
      }
      timetables_insert_service_calendar_substitute_operating_day_by_line_type(
        objects: $daysToInsert
      ) {
        affected_rows
      }
    }
  }
`;
export type EditSubstituteOperatingPeriodsMutationFn = Apollo.MutationFunction<
  EditSubstituteOperatingPeriodsMutation,
  EditSubstituteOperatingPeriodsMutationVariables
>;

/**
 * __useEditSubstituteOperatingPeriodsMutation__
 *
 * To run a mutation, you first call `useEditSubstituteOperatingPeriodsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditSubstituteOperatingPeriodsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editSubstituteOperatingPeriodsMutation, { data, loading, error }] = useEditSubstituteOperatingPeriodsMutation({
 *   variables: {
 *      periodsToInsert: // value for 'periodsToInsert'
 *      periodsToDelete: // value for 'periodsToDelete'
 *      daysToInsert: // value for 'daysToInsert'
 *   },
 * });
 */
export function useEditSubstituteOperatingPeriodsMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditSubstituteOperatingPeriodsMutation,
    EditSubstituteOperatingPeriodsMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    EditSubstituteOperatingPeriodsMutation,
    EditSubstituteOperatingPeriodsMutationVariables
  >(EditSubstituteOperatingPeriodsDocument, options);
}
export type EditSubstituteOperatingPeriodsMutationHookResult = ReturnType<
  typeof useEditSubstituteOperatingPeriodsMutation
>;
export type EditSubstituteOperatingPeriodsMutationResult =
  Apollo.MutationResult<EditSubstituteOperatingPeriodsMutation>;
export type EditSubstituteOperatingPeriodsMutationOptions =
  Apollo.BaseMutationOptions<
    EditSubstituteOperatingPeriodsMutation,
    EditSubstituteOperatingPeriodsMutationVariables
  >;
export const GetSubstituteOperatingPeriodsDocument = gql`
  query GetSubstituteOperatingPeriods(
    $periodFilters: timetables_service_calendar_substitute_operating_period_bool_exp
  ) {
    timetables {
      timetables_service_calendar_substitute_operating_period(
        where: $periodFilters
      ) {
        period_name
        is_preset
        substitute_operating_period_id
        substitute_operating_day_by_line_types {
          begin_time
          end_time
          substitute_day_of_week
          substitute_operating_day_by_line_type_id
          superseded_date
          type_of_line
        }
      }
    }
  }
`;

/**
 * __useGetSubstituteOperatingPeriodsQuery__
 *
 * To run a query within a React component, call `useGetSubstituteOperatingPeriodsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSubstituteOperatingPeriodsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSubstituteOperatingPeriodsQuery({
 *   variables: {
 *      periodFilters: // value for 'periodFilters'
 *   },
 * });
 */
export function useGetSubstituteOperatingPeriodsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetSubstituteOperatingPeriodsQuery,
    GetSubstituteOperatingPeriodsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetSubstituteOperatingPeriodsQuery,
    GetSubstituteOperatingPeriodsQueryVariables
  >(GetSubstituteOperatingPeriodsDocument, options);
}
export function useGetSubstituteOperatingPeriodsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetSubstituteOperatingPeriodsQuery,
    GetSubstituteOperatingPeriodsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetSubstituteOperatingPeriodsQuery,
    GetSubstituteOperatingPeriodsQueryVariables
  >(GetSubstituteOperatingPeriodsDocument, options);
}
export type GetSubstituteOperatingPeriodsQueryHookResult = ReturnType<
  typeof useGetSubstituteOperatingPeriodsQuery
>;
export type GetSubstituteOperatingPeriodsLazyQueryHookResult = ReturnType<
  typeof useGetSubstituteOperatingPeriodsLazyQuery
>;
export type GetSubstituteOperatingPeriodsQueryResult = Apollo.QueryResult<
  GetSubstituteOperatingPeriodsQuery,
  GetSubstituteOperatingPeriodsQueryVariables
>;
export const GetToCombineTargetVehicleScheduleFrameIdDocument = gql`
  query GetToCombineTargetVehicleScheduleFrameId(
    $arg1: ToCombineTargetVehicleScheduleFrameIdInput!
  ) {
    toCombineTargetVehicleScheduleFrameId(arg1: $arg1) {
      toCombineTargetVehicleScheduleFrameId
    }
  }
`;

/**
 * __useGetToCombineTargetVehicleScheduleFrameIdQuery__
 *
 * To run a query within a React component, call `useGetToCombineTargetVehicleScheduleFrameIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetToCombineTargetVehicleScheduleFrameIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetToCombineTargetVehicleScheduleFrameIdQuery({
 *   variables: {
 *      arg1: // value for 'arg1'
 *   },
 * });
 */
export function useGetToCombineTargetVehicleScheduleFrameIdQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetToCombineTargetVehicleScheduleFrameIdQuery,
    GetToCombineTargetVehicleScheduleFrameIdQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetToCombineTargetVehicleScheduleFrameIdQuery,
    GetToCombineTargetVehicleScheduleFrameIdQueryVariables
  >(GetToCombineTargetVehicleScheduleFrameIdDocument, options);
}
export function useGetToCombineTargetVehicleScheduleFrameIdLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetToCombineTargetVehicleScheduleFrameIdQuery,
    GetToCombineTargetVehicleScheduleFrameIdQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetToCombineTargetVehicleScheduleFrameIdQuery,
    GetToCombineTargetVehicleScheduleFrameIdQueryVariables
  >(GetToCombineTargetVehicleScheduleFrameIdDocument, options);
}
export type GetToCombineTargetVehicleScheduleFrameIdQueryHookResult =
  ReturnType<typeof useGetToCombineTargetVehicleScheduleFrameIdQuery>;
export type GetToCombineTargetVehicleScheduleFrameIdLazyQueryHookResult =
  ReturnType<typeof useGetToCombineTargetVehicleScheduleFrameIdLazyQuery>;
export type GetToCombineTargetVehicleScheduleFrameIdQueryResult =
  Apollo.QueryResult<
    GetToCombineTargetVehicleScheduleFrameIdQuery,
    GetToCombineTargetVehicleScheduleFrameIdQueryVariables
  >;
export const GetToReplaceVehicleScheduleFramesDocument = gql`
  query GetToReplaceVehicleScheduleFrames(
    $arg1: ToReplaceVehicleScheduleFrameIdsInput!
  ) {
    toReplaceVehicleScheduleFrameIds(arg1: $arg1) {
      toReplaceVehicleScheduleFrameIds
    }
  }
`;

/**
 * __useGetToReplaceVehicleScheduleFramesQuery__
 *
 * To run a query within a React component, call `useGetToReplaceVehicleScheduleFramesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetToReplaceVehicleScheduleFramesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetToReplaceVehicleScheduleFramesQuery({
 *   variables: {
 *      arg1: // value for 'arg1'
 *   },
 * });
 */
export function useGetToReplaceVehicleScheduleFramesQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetToReplaceVehicleScheduleFramesQuery,
    GetToReplaceVehicleScheduleFramesQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetToReplaceVehicleScheduleFramesQuery,
    GetToReplaceVehicleScheduleFramesQueryVariables
  >(GetToReplaceVehicleScheduleFramesDocument, options);
}
export function useGetToReplaceVehicleScheduleFramesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetToReplaceVehicleScheduleFramesQuery,
    GetToReplaceVehicleScheduleFramesQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetToReplaceVehicleScheduleFramesQuery,
    GetToReplaceVehicleScheduleFramesQueryVariables
  >(GetToReplaceVehicleScheduleFramesDocument, options);
}
export type GetToReplaceVehicleScheduleFramesQueryHookResult = ReturnType<
  typeof useGetToReplaceVehicleScheduleFramesQuery
>;
export type GetToReplaceVehicleScheduleFramesLazyQueryHookResult = ReturnType<
  typeof useGetToReplaceVehicleScheduleFramesLazyQuery
>;
export type GetToReplaceVehicleScheduleFramesQueryResult = Apollo.QueryResult<
  GetToReplaceVehicleScheduleFramesQuery,
  GetToReplaceVehicleScheduleFramesQueryVariables
>;
export const GetVehicleScheduleFrameWithJourneyInfoDocument = gql`
  query GetVehicleScheduleFrameWithJourneyInfo(
    $vehicle_schedule_frame_ids: [uuid!]!
  ) {
    timetables {
      timetables_vehicle_schedule_vehicle_schedule_frame(
        where: {
          vehicle_schedule_frame_id: { _in: $vehicle_schedule_frame_ids }
        }
      ) {
        vehicle_schedule_frame_id
        validity_start
        validity_end
        vehicle_services {
          vehicle_service_id
          day_type {
            day_type_id
            label
            name_i18n
          }
          blocks {
            block_id
            vehicle_journeys {
              ...vehicle_journey_with_pattern_and_route_fragment
            }
          }
        }
      }
    }
  }
  ${VehicleJourneyWithPatternAndRouteFragmentFragmentDoc}
`;

/**
 * __useGetVehicleScheduleFrameWithJourneyInfoQuery__
 *
 * To run a query within a React component, call `useGetVehicleScheduleFrameWithJourneyInfoQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetVehicleScheduleFrameWithJourneyInfoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetVehicleScheduleFrameWithJourneyInfoQuery({
 *   variables: {
 *      vehicle_schedule_frame_ids: // value for 'vehicle_schedule_frame_ids'
 *   },
 * });
 */
export function useGetVehicleScheduleFrameWithJourneyInfoQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetVehicleScheduleFrameWithJourneyInfoQuery,
    GetVehicleScheduleFrameWithJourneyInfoQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetVehicleScheduleFrameWithJourneyInfoQuery,
    GetVehicleScheduleFrameWithJourneyInfoQueryVariables
  >(GetVehicleScheduleFrameWithJourneyInfoDocument, options);
}
export function useGetVehicleScheduleFrameWithJourneyInfoLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetVehicleScheduleFrameWithJourneyInfoQuery,
    GetVehicleScheduleFrameWithJourneyInfoQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetVehicleScheduleFrameWithJourneyInfoQuery,
    GetVehicleScheduleFrameWithJourneyInfoQueryVariables
  >(GetVehicleScheduleFrameWithJourneyInfoDocument, options);
}
export type GetVehicleScheduleFrameWithJourneyInfoQueryHookResult = ReturnType<
  typeof useGetVehicleScheduleFrameWithJourneyInfoQuery
>;
export type GetVehicleScheduleFrameWithJourneyInfoLazyQueryHookResult =
  ReturnType<typeof useGetVehicleScheduleFrameWithJourneyInfoLazyQuery>;
export type GetVehicleScheduleFrameWithJourneyInfoQueryResult =
  Apollo.QueryResult<
    GetVehicleScheduleFrameWithJourneyInfoQuery,
    GetVehicleScheduleFrameWithJourneyInfoQueryVariables
  >;
export const GetVehicleScheduleFrameWithRouteAndLineInfoDocument = gql`
  query GetVehicleScheduleFrameWithRouteAndLineInfo(
    $vehicle_schedule_frame_ids: [uuid!]!
  ) {
    timetables {
      timetables_vehicle_schedule_vehicle_schedule_frame(
        where: {
          vehicle_schedule_frame_id: { _in: $vehicle_schedule_frame_ids }
        }
      ) {
        vehicle_schedule_frame_id
        vehicle_services {
          vehicle_service_id
          journey_patterns_in_vehicle_service {
            journey_pattern_id
            journey_pattern_instance {
              journey_pattern_id
              journey_pattern_route {
                route_id
                unique_label
                direction
                variant
                name_i18n
                route_line {
                  line_id
                }
              }
            }
          }
        }
      }
    }
  }
`;

/**
 * __useGetVehicleScheduleFrameWithRouteAndLineInfoQuery__
 *
 * To run a query within a React component, call `useGetVehicleScheduleFrameWithRouteAndLineInfoQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetVehicleScheduleFrameWithRouteAndLineInfoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetVehicleScheduleFrameWithRouteAndLineInfoQuery({
 *   variables: {
 *      vehicle_schedule_frame_ids: // value for 'vehicle_schedule_frame_ids'
 *   },
 * });
 */
export function useGetVehicleScheduleFrameWithRouteAndLineInfoQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetVehicleScheduleFrameWithRouteAndLineInfoQuery,
    GetVehicleScheduleFrameWithRouteAndLineInfoQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetVehicleScheduleFrameWithRouteAndLineInfoQuery,
    GetVehicleScheduleFrameWithRouteAndLineInfoQueryVariables
  >(GetVehicleScheduleFrameWithRouteAndLineInfoDocument, options);
}
export function useGetVehicleScheduleFrameWithRouteAndLineInfoLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetVehicleScheduleFrameWithRouteAndLineInfoQuery,
    GetVehicleScheduleFrameWithRouteAndLineInfoQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetVehicleScheduleFrameWithRouteAndLineInfoQuery,
    GetVehicleScheduleFrameWithRouteAndLineInfoQueryVariables
  >(GetVehicleScheduleFrameWithRouteAndLineInfoDocument, options);
}
export type GetVehicleScheduleFrameWithRouteAndLineInfoQueryHookResult =
  ReturnType<typeof useGetVehicleScheduleFrameWithRouteAndLineInfoQuery>;
export type GetVehicleScheduleFrameWithRouteAndLineInfoLazyQueryHookResult =
  ReturnType<typeof useGetVehicleScheduleFrameWithRouteAndLineInfoLazyQuery>;
export type GetVehicleScheduleFrameWithRouteAndLineInfoQueryResult =
  Apollo.QueryResult<
    GetVehicleScheduleFrameWithRouteAndLineInfoQuery,
    GetVehicleScheduleFrameWithRouteAndLineInfoQueryVariables
  >;
export const GetStagingVehicleScheduleFramesDocument = gql`
  query GetStagingVehicleScheduleFrames {
    timetables {
      timetables_vehicle_schedule_vehicle_schedule_frame(
        where: { priority: { _eq: 40 } }
      ) {
        ...vehicle_schedule_frame_with_route_info
      }
    }
  }
  ${VehicleScheduleFrameWithRouteInfoFragmentDoc}
`;

/**
 * __useGetStagingVehicleScheduleFramesQuery__
 *
 * To run a query within a React component, call `useGetStagingVehicleScheduleFramesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStagingVehicleScheduleFramesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStagingVehicleScheduleFramesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetStagingVehicleScheduleFramesQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetStagingVehicleScheduleFramesQuery,
    GetStagingVehicleScheduleFramesQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetStagingVehicleScheduleFramesQuery,
    GetStagingVehicleScheduleFramesQueryVariables
  >(GetStagingVehicleScheduleFramesDocument, options);
}
export function useGetStagingVehicleScheduleFramesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetStagingVehicleScheduleFramesQuery,
    GetStagingVehicleScheduleFramesQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetStagingVehicleScheduleFramesQuery,
    GetStagingVehicleScheduleFramesQueryVariables
  >(GetStagingVehicleScheduleFramesDocument, options);
}
export type GetStagingVehicleScheduleFramesQueryHookResult = ReturnType<
  typeof useGetStagingVehicleScheduleFramesQuery
>;
export type GetStagingVehicleScheduleFramesLazyQueryHookResult = ReturnType<
  typeof useGetStagingVehicleScheduleFramesLazyQuery
>;
export type GetStagingVehicleScheduleFramesQueryResult = Apollo.QueryResult<
  GetStagingVehicleScheduleFramesQuery,
  GetStagingVehicleScheduleFramesQueryVariables
>;
export const ChangeStagingVehicleScheduleFramePriorityDocument = gql`
  mutation ChangeStagingVehicleScheduleFramePriority($newPriority: Int!) {
    timetables {
      timetables_update_vehicle_schedule_vehicle_schedule_frame(
        where: { priority: { _eq: 40 } }
        _set: { priority: $newPriority }
      ) {
        returning {
          priority
          validity_end
          validity_start
          name_i18n
          vehicle_schedule_frame_id
        }
      }
    }
  }
`;
export type ChangeStagingVehicleScheduleFramePriorityMutationFn =
  Apollo.MutationFunction<
    ChangeStagingVehicleScheduleFramePriorityMutation,
    ChangeStagingVehicleScheduleFramePriorityMutationVariables
  >;

/**
 * __useChangeStagingVehicleScheduleFramePriorityMutation__
 *
 * To run a mutation, you first call `useChangeStagingVehicleScheduleFramePriorityMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChangeStagingVehicleScheduleFramePriorityMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [changeStagingVehicleScheduleFramePriorityMutation, { data, loading, error }] = useChangeStagingVehicleScheduleFramePriorityMutation({
 *   variables: {
 *      newPriority: // value for 'newPriority'
 *   },
 * });
 */
export function useChangeStagingVehicleScheduleFramePriorityMutation(
  baseOptions?: Apollo.MutationHookOptions<
    ChangeStagingVehicleScheduleFramePriorityMutation,
    ChangeStagingVehicleScheduleFramePriorityMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    ChangeStagingVehicleScheduleFramePriorityMutation,
    ChangeStagingVehicleScheduleFramePriorityMutationVariables
  >(ChangeStagingVehicleScheduleFramePriorityDocument, options);
}
export type ChangeStagingVehicleScheduleFramePriorityMutationHookResult =
  ReturnType<typeof useChangeStagingVehicleScheduleFramePriorityMutation>;
export type ChangeStagingVehicleScheduleFramePriorityMutationResult =
  Apollo.MutationResult<ChangeStagingVehicleScheduleFramePriorityMutation>;
export type ChangeStagingVehicleScheduleFramePriorityMutationOptions =
  Apollo.BaseMutationOptions<
    ChangeStagingVehicleScheduleFramePriorityMutation,
    ChangeStagingVehicleScheduleFramePriorityMutationVariables
  >;
export const CombineTimetablesDocument = gql`
  mutation CombineTimetables(
    $stagingVehicleScheduleFrameIds: [uuid]!
    $targetPriority: Int!
  ) {
    combineTimetables(
      arg1: {
        stagingVehicleScheduleFrameIds: $stagingVehicleScheduleFrameIds
        targetPriority: $targetPriority
      }
    ) {
      combinedIntoVehicleScheduleFrameIds
    }
  }
`;
export type CombineTimetablesMutationFn = Apollo.MutationFunction<
  CombineTimetablesMutation,
  CombineTimetablesMutationVariables
>;

/**
 * __useCombineTimetablesMutation__
 *
 * To run a mutation, you first call `useCombineTimetablesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCombineTimetablesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [combineTimetablesMutation, { data, loading, error }] = useCombineTimetablesMutation({
 *   variables: {
 *      stagingVehicleScheduleFrameIds: // value for 'stagingVehicleScheduleFrameIds'
 *      targetPriority: // value for 'targetPriority'
 *   },
 * });
 */
export function useCombineTimetablesMutation(
  baseOptions?: Apollo.MutationHookOptions<
    CombineTimetablesMutation,
    CombineTimetablesMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    CombineTimetablesMutation,
    CombineTimetablesMutationVariables
  >(CombineTimetablesDocument, options);
}
export type CombineTimetablesMutationHookResult = ReturnType<
  typeof useCombineTimetablesMutation
>;
export type CombineTimetablesMutationResult =
  Apollo.MutationResult<CombineTimetablesMutation>;
export type CombineTimetablesMutationOptions = Apollo.BaseMutationOptions<
  CombineTimetablesMutation,
  CombineTimetablesMutationVariables
>;
export const ReplaceTimetablesDocument = gql`
  mutation ReplaceTimetables(
    $stagingVehicleScheduleFrameIds: [uuid]!
    $targetPriority: Int!
  ) {
    replaceTimetables(
      arg1: {
        stagingVehicleScheduleFrameIds: $stagingVehicleScheduleFrameIds
        targetPriority: $targetPriority
      }
    ) {
      replacedVehicleScheduleFrameIds
    }
  }
`;
export type ReplaceTimetablesMutationFn = Apollo.MutationFunction<
  ReplaceTimetablesMutation,
  ReplaceTimetablesMutationVariables
>;

/**
 * __useReplaceTimetablesMutation__
 *
 * To run a mutation, you first call `useReplaceTimetablesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useReplaceTimetablesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [replaceTimetablesMutation, { data, loading, error }] = useReplaceTimetablesMutation({
 *   variables: {
 *      stagingVehicleScheduleFrameIds: // value for 'stagingVehicleScheduleFrameIds'
 *      targetPriority: // value for 'targetPriority'
 *   },
 * });
 */
export function useReplaceTimetablesMutation(
  baseOptions?: Apollo.MutationHookOptions<
    ReplaceTimetablesMutation,
    ReplaceTimetablesMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    ReplaceTimetablesMutation,
    ReplaceTimetablesMutationVariables
  >(ReplaceTimetablesDocument, options);
}
export type ReplaceTimetablesMutationHookResult = ReturnType<
  typeof useReplaceTimetablesMutation
>;
export type ReplaceTimetablesMutationResult =
  Apollo.MutationResult<ReplaceTimetablesMutation>;
export type ReplaceTimetablesMutationOptions = Apollo.BaseMutationOptions<
  ReplaceTimetablesMutation,
  ReplaceTimetablesMutationVariables
>;
export const DeleteStagingTimetablesDocument = gql`
  mutation DeleteStagingTimetables($stagingVehicleScheduleFrameIds: [uuid!]) {
    timetables {
      timetables_delete_vehicle_schedule_vehicle_schedule_frame(
        where: {
          _and: {
            priority: { _eq: 40 }
            vehicle_schedule_frame_id: { _in: $stagingVehicleScheduleFrameIds }
          }
        }
      ) {
        returning {
          vehicle_schedule_frame_id
        }
      }
    }
  }
`;
export type DeleteStagingTimetablesMutationFn = Apollo.MutationFunction<
  DeleteStagingTimetablesMutation,
  DeleteStagingTimetablesMutationVariables
>;

/**
 * __useDeleteStagingTimetablesMutation__
 *
 * To run a mutation, you first call `useDeleteStagingTimetablesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteStagingTimetablesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteStagingTimetablesMutation, { data, loading, error }] = useDeleteStagingTimetablesMutation({
 *   variables: {
 *      stagingVehicleScheduleFrameIds: // value for 'stagingVehicleScheduleFrameIds'
 *   },
 * });
 */
export function useDeleteStagingTimetablesMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteStagingTimetablesMutation,
    DeleteStagingTimetablesMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    DeleteStagingTimetablesMutation,
    DeleteStagingTimetablesMutationVariables
  >(DeleteStagingTimetablesDocument, options);
}
export type DeleteStagingTimetablesMutationHookResult = ReturnType<
  typeof useDeleteStagingTimetablesMutation
>;
export type DeleteStagingTimetablesMutationResult =
  Apollo.MutationResult<DeleteStagingTimetablesMutation>;
export type DeleteStagingTimetablesMutationOptions = Apollo.BaseMutationOptions<
  DeleteStagingTimetablesMutation,
  DeleteStagingTimetablesMutationVariables
>;
export const InsertTimingPlaceDocument = gql`
  mutation InsertTimingPlace(
    $object: timing_pattern_timing_place_insert_input!
  ) {
    insert_timing_pattern_timing_place_one(object: $object) {
      ...created_timing_place
    }
  }
  ${CreatedTimingPlaceFragmentDoc}
`;
export type InsertTimingPlaceMutationFn = Apollo.MutationFunction<
  InsertTimingPlaceMutation,
  InsertTimingPlaceMutationVariables
>;

/**
 * __useInsertTimingPlaceMutation__
 *
 * To run a mutation, you first call `useInsertTimingPlaceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertTimingPlaceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertTimingPlaceMutation, { data, loading, error }] = useInsertTimingPlaceMutation({
 *   variables: {
 *      object: // value for 'object'
 *   },
 * });
 */
export function useInsertTimingPlaceMutation(
  baseOptions?: Apollo.MutationHookOptions<
    InsertTimingPlaceMutation,
    InsertTimingPlaceMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    InsertTimingPlaceMutation,
    InsertTimingPlaceMutationVariables
  >(InsertTimingPlaceDocument, options);
}
export type InsertTimingPlaceMutationHookResult = ReturnType<
  typeof useInsertTimingPlaceMutation
>;
export type InsertTimingPlaceMutationResult =
  Apollo.MutationResult<InsertTimingPlaceMutation>;
export type InsertTimingPlaceMutationOptions = Apollo.BaseMutationOptions<
  InsertTimingPlaceMutation,
  InsertTimingPlaceMutationVariables
>;
export const GetTimingPlacesByLabelDocument = gql`
  query GetTimingPlacesByLabel($label: String!) {
    timing_pattern_timing_place(where: { label: { _eq: $label } }) {
      ...created_timing_place
    }
  }
  ${CreatedTimingPlaceFragmentDoc}
`;

/**
 * __useGetTimingPlacesByLabelQuery__
 *
 * To run a query within a React component, call `useGetTimingPlacesByLabelQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTimingPlacesByLabelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTimingPlacesByLabelQuery({
 *   variables: {
 *      label: // value for 'label'
 *   },
 * });
 */
export function useGetTimingPlacesByLabelQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetTimingPlacesByLabelQuery,
    GetTimingPlacesByLabelQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetTimingPlacesByLabelQuery,
    GetTimingPlacesByLabelQueryVariables
  >(GetTimingPlacesByLabelDocument, options);
}
export function useGetTimingPlacesByLabelLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetTimingPlacesByLabelQuery,
    GetTimingPlacesByLabelQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetTimingPlacesByLabelQuery,
    GetTimingPlacesByLabelQueryVariables
  >(GetTimingPlacesByLabelDocument, options);
}
export type GetTimingPlacesByLabelQueryHookResult = ReturnType<
  typeof useGetTimingPlacesByLabelQuery
>;
export type GetTimingPlacesByLabelLazyQueryHookResult = ReturnType<
  typeof useGetTimingPlacesByLabelLazyQuery
>;
export type GetTimingPlacesByLabelQueryResult = Apollo.QueryResult<
  GetTimingPlacesByLabelQuery,
  GetTimingPlacesByLabelQueryVariables
>;
export const GetLinesForComboboxDocument = gql`
  query GetLinesForCombobox($labelPattern: String!, $date: date!) {
    route_line(
      limit: 10
      where: {
        label: { _ilike: $labelPattern }
        _or: [
          { validity_end: { _gte: $date } }
          { validity_end: { _is_null: true } }
        ]
      }
      order_by: [{ label: asc }, { validity_start: asc }]
    ) {
      ...line_for_combobox
    }
  }
  ${LineForComboboxFragmentDoc}
`;

/**
 * __useGetLinesForComboboxQuery__
 *
 * To run a query within a React component, call `useGetLinesForComboboxQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLinesForComboboxQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLinesForComboboxQuery({
 *   variables: {
 *      labelPattern: // value for 'labelPattern'
 *      date: // value for 'date'
 *   },
 * });
 */
export function useGetLinesForComboboxQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetLinesForComboboxQuery,
    GetLinesForComboboxQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetLinesForComboboxQuery,
    GetLinesForComboboxQueryVariables
  >(GetLinesForComboboxDocument, options);
}
export function useGetLinesForComboboxLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetLinesForComboboxQuery,
    GetLinesForComboboxQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetLinesForComboboxQuery,
    GetLinesForComboboxQueryVariables
  >(GetLinesForComboboxDocument, options);
}
export type GetLinesForComboboxQueryHookResult = ReturnType<
  typeof useGetLinesForComboboxQuery
>;
export type GetLinesForComboboxLazyQueryHookResult = ReturnType<
  typeof useGetLinesForComboboxLazyQuery
>;
export type GetLinesForComboboxQueryResult = Apollo.QueryResult<
  GetLinesForComboboxQuery,
  GetLinesForComboboxQueryVariables
>;
export const GetSelectedLineDetailsByIdDocument = gql`
  query GetSelectedLineDetailsById($line_id: uuid!) {
    route_line_by_pk(line_id: $line_id) {
      ...line_for_combobox
    }
  }
  ${LineForComboboxFragmentDoc}
`;

/**
 * __useGetSelectedLineDetailsByIdQuery__
 *
 * To run a query within a React component, call `useGetSelectedLineDetailsByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSelectedLineDetailsByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSelectedLineDetailsByIdQuery({
 *   variables: {
 *      line_id: // value for 'line_id'
 *   },
 * });
 */
export function useGetSelectedLineDetailsByIdQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetSelectedLineDetailsByIdQuery,
    GetSelectedLineDetailsByIdQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetSelectedLineDetailsByIdQuery,
    GetSelectedLineDetailsByIdQueryVariables
  >(GetSelectedLineDetailsByIdDocument, options);
}
export function useGetSelectedLineDetailsByIdLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetSelectedLineDetailsByIdQuery,
    GetSelectedLineDetailsByIdQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetSelectedLineDetailsByIdQuery,
    GetSelectedLineDetailsByIdQueryVariables
  >(GetSelectedLineDetailsByIdDocument, options);
}
export type GetSelectedLineDetailsByIdQueryHookResult = ReturnType<
  typeof useGetSelectedLineDetailsByIdQuery
>;
export type GetSelectedLineDetailsByIdLazyQueryHookResult = ReturnType<
  typeof useGetSelectedLineDetailsByIdLazyQuery
>;
export type GetSelectedLineDetailsByIdQueryResult = Apollo.QueryResult<
  GetSelectedLineDetailsByIdQuery,
  GetSelectedLineDetailsByIdQueryVariables
>;
export const GetRouteDetailsByLabelWildcardDocument = gql`
  query GetRouteDetailsByLabelWildcard(
    $labelPattern: String!
    $date: date
    $priorities: [Int!]
  ) {
    route_route(
      limit: 7
      where: {
        label: { _ilike: $labelPattern }
        validity_start: { _lte: $date }
        _or: [
          { validity_end: { _gte: $date } }
          { validity_end: { _is_null: true } }
        ]
        priority: { _in: $priorities }
      }
      order_by: { label: asc }
    ) {
      ...route_all_fields
    }
  }
  ${RouteAllFieldsFragmentDoc}
`;

/**
 * __useGetRouteDetailsByLabelWildcardQuery__
 *
 * To run a query within a React component, call `useGetRouteDetailsByLabelWildcardQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRouteDetailsByLabelWildcardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRouteDetailsByLabelWildcardQuery({
 *   variables: {
 *      labelPattern: // value for 'labelPattern'
 *      date: // value for 'date'
 *      priorities: // value for 'priorities'
 *   },
 * });
 */
export function useGetRouteDetailsByLabelWildcardQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetRouteDetailsByLabelWildcardQuery,
    GetRouteDetailsByLabelWildcardQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetRouteDetailsByLabelWildcardQuery,
    GetRouteDetailsByLabelWildcardQueryVariables
  >(GetRouteDetailsByLabelWildcardDocument, options);
}
export function useGetRouteDetailsByLabelWildcardLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetRouteDetailsByLabelWildcardQuery,
    GetRouteDetailsByLabelWildcardQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetRouteDetailsByLabelWildcardQuery,
    GetRouteDetailsByLabelWildcardQueryVariables
  >(GetRouteDetailsByLabelWildcardDocument, options);
}
export type GetRouteDetailsByLabelWildcardQueryHookResult = ReturnType<
  typeof useGetRouteDetailsByLabelWildcardQuery
>;
export type GetRouteDetailsByLabelWildcardLazyQueryHookResult = ReturnType<
  typeof useGetRouteDetailsByLabelWildcardLazyQuery
>;
export type GetRouteDetailsByLabelWildcardQueryResult = Apollo.QueryResult<
  GetRouteDetailsByLabelWildcardQuery,
  GetRouteDetailsByLabelWildcardQueryVariables
>;
export const GetSelectedRouteDetailsByIdDocument = gql`
  query GetSelectedRouteDetailsById($routeId: uuid!) {
    route_route_by_pk(route_id: $routeId) {
      ...route_all_fields
    }
  }
  ${RouteAllFieldsFragmentDoc}
`;

/**
 * __useGetSelectedRouteDetailsByIdQuery__
 *
 * To run a query within a React component, call `useGetSelectedRouteDetailsByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSelectedRouteDetailsByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSelectedRouteDetailsByIdQuery({
 *   variables: {
 *      routeId: // value for 'routeId'
 *   },
 * });
 */
export function useGetSelectedRouteDetailsByIdQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetSelectedRouteDetailsByIdQuery,
    GetSelectedRouteDetailsByIdQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetSelectedRouteDetailsByIdQuery,
    GetSelectedRouteDetailsByIdQueryVariables
  >(GetSelectedRouteDetailsByIdDocument, options);
}
export function useGetSelectedRouteDetailsByIdLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetSelectedRouteDetailsByIdQuery,
    GetSelectedRouteDetailsByIdQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetSelectedRouteDetailsByIdQuery,
    GetSelectedRouteDetailsByIdQueryVariables
  >(GetSelectedRouteDetailsByIdDocument, options);
}
export type GetSelectedRouteDetailsByIdQueryHookResult = ReturnType<
  typeof useGetSelectedRouteDetailsByIdQuery
>;
export type GetSelectedRouteDetailsByIdLazyQueryHookResult = ReturnType<
  typeof useGetSelectedRouteDetailsByIdLazyQuery
>;
export type GetSelectedRouteDetailsByIdQueryResult = Apollo.QueryResult<
  GetSelectedRouteDetailsByIdQuery,
  GetSelectedRouteDetailsByIdQueryVariables
>;
export const GetTimingPlacesForComboboxDocument = gql`
  query GetTimingPlacesForCombobox($labelPattern: String!) {
    timing_pattern_timing_place(
      limit: 10
      where: { label: { _ilike: $labelPattern } }
      order_by: [{ label: asc }]
    ) {
      ...timing_place_for_combobox
    }
  }
  ${TimingPlaceForComboboxFragmentDoc}
`;

/**
 * __useGetTimingPlacesForComboboxQuery__
 *
 * To run a query within a React component, call `useGetTimingPlacesForComboboxQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTimingPlacesForComboboxQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTimingPlacesForComboboxQuery({
 *   variables: {
 *      labelPattern: // value for 'labelPattern'
 *   },
 * });
 */
export function useGetTimingPlacesForComboboxQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetTimingPlacesForComboboxQuery,
    GetTimingPlacesForComboboxQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetTimingPlacesForComboboxQuery,
    GetTimingPlacesForComboboxQueryVariables
  >(GetTimingPlacesForComboboxDocument, options);
}
export function useGetTimingPlacesForComboboxLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetTimingPlacesForComboboxQuery,
    GetTimingPlacesForComboboxQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetTimingPlacesForComboboxQuery,
    GetTimingPlacesForComboboxQueryVariables
  >(GetTimingPlacesForComboboxDocument, options);
}
export type GetTimingPlacesForComboboxQueryHookResult = ReturnType<
  typeof useGetTimingPlacesForComboboxQuery
>;
export type GetTimingPlacesForComboboxLazyQueryHookResult = ReturnType<
  typeof useGetTimingPlacesForComboboxLazyQuery
>;
export type GetTimingPlacesForComboboxQueryResult = Apollo.QueryResult<
  GetTimingPlacesForComboboxQuery,
  GetTimingPlacesForComboboxQueryVariables
>;
export const GetSelectedTimingPlaceDetailsByIdDocument = gql`
  query GetSelectedTimingPlaceDetailsById($timing_place_id: uuid!) {
    timing_pattern_timing_place_by_pk(timing_place_id: $timing_place_id) {
      ...timing_place_for_combobox
    }
  }
  ${TimingPlaceForComboboxFragmentDoc}
`;

/**
 * __useGetSelectedTimingPlaceDetailsByIdQuery__
 *
 * To run a query within a React component, call `useGetSelectedTimingPlaceDetailsByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSelectedTimingPlaceDetailsByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSelectedTimingPlaceDetailsByIdQuery({
 *   variables: {
 *      timing_place_id: // value for 'timing_place_id'
 *   },
 * });
 */
export function useGetSelectedTimingPlaceDetailsByIdQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetSelectedTimingPlaceDetailsByIdQuery,
    GetSelectedTimingPlaceDetailsByIdQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetSelectedTimingPlaceDetailsByIdQuery,
    GetSelectedTimingPlaceDetailsByIdQueryVariables
  >(GetSelectedTimingPlaceDetailsByIdDocument, options);
}
export function useGetSelectedTimingPlaceDetailsByIdLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetSelectedTimingPlaceDetailsByIdQuery,
    GetSelectedTimingPlaceDetailsByIdQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetSelectedTimingPlaceDetailsByIdQuery,
    GetSelectedTimingPlaceDetailsByIdQueryVariables
  >(GetSelectedTimingPlaceDetailsByIdDocument, options);
}
export type GetSelectedTimingPlaceDetailsByIdQueryHookResult = ReturnType<
  typeof useGetSelectedTimingPlaceDetailsByIdQuery
>;
export type GetSelectedTimingPlaceDetailsByIdLazyQueryHookResult = ReturnType<
  typeof useGetSelectedTimingPlaceDetailsByIdLazyQuery
>;
export type GetSelectedTimingPlaceDetailsByIdQueryResult = Apollo.QueryResult<
  GetSelectedTimingPlaceDetailsByIdQuery,
  GetSelectedTimingPlaceDetailsByIdQueryVariables
>;
export const GetRouteInfoForTimetableVersionsDocument = gql`
  query GetRouteInfoForTimetableVersions($routeFilters: route_route_bool_exp) {
    route_route(where: $routeFilters) {
      ...route_info_for_timetable_version
    }
  }
  ${RouteInfoForTimetableVersionFragmentDoc}
`;

/**
 * __useGetRouteInfoForTimetableVersionsQuery__
 *
 * To run a query within a React component, call `useGetRouteInfoForTimetableVersionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRouteInfoForTimetableVersionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRouteInfoForTimetableVersionsQuery({
 *   variables: {
 *      routeFilters: // value for 'routeFilters'
 *   },
 * });
 */
export function useGetRouteInfoForTimetableVersionsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetRouteInfoForTimetableVersionsQuery,
    GetRouteInfoForTimetableVersionsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetRouteInfoForTimetableVersionsQuery,
    GetRouteInfoForTimetableVersionsQueryVariables
  >(GetRouteInfoForTimetableVersionsDocument, options);
}
export function useGetRouteInfoForTimetableVersionsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetRouteInfoForTimetableVersionsQuery,
    GetRouteInfoForTimetableVersionsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetRouteInfoForTimetableVersionsQuery,
    GetRouteInfoForTimetableVersionsQueryVariables
  >(GetRouteInfoForTimetableVersionsDocument, options);
}
export type GetRouteInfoForTimetableVersionsQueryHookResult = ReturnType<
  typeof useGetRouteInfoForTimetableVersionsQuery
>;
export type GetRouteInfoForTimetableVersionsLazyQueryHookResult = ReturnType<
  typeof useGetRouteInfoForTimetableVersionsLazyQuery
>;
export type GetRouteInfoForTimetableVersionsQueryResult = Apollo.QueryResult<
  GetRouteInfoForTimetableVersionsQuery,
  GetRouteInfoForTimetableVersionsQueryVariables
>;
export const GetTimetableVersionsByJourneyPatternIdsDocument = gql`
  query GetTimetableVersionsByJourneyPatternIds(
    $journey_pattern_ids: _uuid
    $start_date: date
    $end_date: date
    $observation_date: date
  ) {
    timetables {
      timetables_vehicle_service_get_timetable_versions_by_journey_pattern_ids(
        args: {
          journey_pattern_ids: $journey_pattern_ids
          start_date: $start_date
          end_date: $end_date
          observation_date: $observation_date
        }
      ) {
        ...timetable_version
      }
    }
  }
  ${TimetableVersionFragmentDoc}
`;

/**
 * __useGetTimetableVersionsByJourneyPatternIdsQuery__
 *
 * To run a query within a React component, call `useGetTimetableVersionsByJourneyPatternIdsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTimetableVersionsByJourneyPatternIdsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTimetableVersionsByJourneyPatternIdsQuery({
 *   variables: {
 *      journey_pattern_ids: // value for 'journey_pattern_ids'
 *      start_date: // value for 'start_date'
 *      end_date: // value for 'end_date'
 *      observation_date: // value for 'observation_date'
 *   },
 * });
 */
export function useGetTimetableVersionsByJourneyPatternIdsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetTimetableVersionsByJourneyPatternIdsQuery,
    GetTimetableVersionsByJourneyPatternIdsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetTimetableVersionsByJourneyPatternIdsQuery,
    GetTimetableVersionsByJourneyPatternIdsQueryVariables
  >(GetTimetableVersionsByJourneyPatternIdsDocument, options);
}
export function useGetTimetableVersionsByJourneyPatternIdsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetTimetableVersionsByJourneyPatternIdsQuery,
    GetTimetableVersionsByJourneyPatternIdsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetTimetableVersionsByJourneyPatternIdsQuery,
    GetTimetableVersionsByJourneyPatternIdsQueryVariables
  >(GetTimetableVersionsByJourneyPatternIdsDocument, options);
}
export type GetTimetableVersionsByJourneyPatternIdsQueryHookResult = ReturnType<
  typeof useGetTimetableVersionsByJourneyPatternIdsQuery
>;
export type GetTimetableVersionsByJourneyPatternIdsLazyQueryHookResult =
  ReturnType<typeof useGetTimetableVersionsByJourneyPatternIdsLazyQuery>;
export type GetTimetableVersionsByJourneyPatternIdsQueryResult =
  Apollo.QueryResult<
    GetTimetableVersionsByJourneyPatternIdsQuery,
    GetTimetableVersionsByJourneyPatternIdsQueryVariables
  >;
export const DeleteVehicleScheduleFrameDocument = gql`
  mutation DeleteVehicleScheduleFrame($vehicle_schedule_frame_id: uuid!) {
    timetables {
      timetables_delete_vehicle_schedule_vehicle_schedule_frame_by_pk(
        vehicle_schedule_frame_id: $vehicle_schedule_frame_id
      ) {
        vehicle_schedule_frame_id
      }
    }
  }
`;
export type DeleteVehicleScheduleFrameMutationFn = Apollo.MutationFunction<
  DeleteVehicleScheduleFrameMutation,
  DeleteVehicleScheduleFrameMutationVariables
>;

/**
 * __useDeleteVehicleScheduleFrameMutation__
 *
 * To run a mutation, you first call `useDeleteVehicleScheduleFrameMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteVehicleScheduleFrameMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteVehicleScheduleFrameMutation, { data, loading, error }] = useDeleteVehicleScheduleFrameMutation({
 *   variables: {
 *      vehicle_schedule_frame_id: // value for 'vehicle_schedule_frame_id'
 *   },
 * });
 */
export function useDeleteVehicleScheduleFrameMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteVehicleScheduleFrameMutation,
    DeleteVehicleScheduleFrameMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    DeleteVehicleScheduleFrameMutation,
    DeleteVehicleScheduleFrameMutationVariables
  >(DeleteVehicleScheduleFrameDocument, options);
}
export type DeleteVehicleScheduleFrameMutationHookResult = ReturnType<
  typeof useDeleteVehicleScheduleFrameMutation
>;
export type DeleteVehicleScheduleFrameMutationResult =
  Apollo.MutationResult<DeleteVehicleScheduleFrameMutation>;
export type DeleteVehicleScheduleFrameMutationOptions =
  Apollo.BaseMutationOptions<
    DeleteVehicleScheduleFrameMutation,
    DeleteVehicleScheduleFrameMutationVariables
  >;
export const GetVehicleScheduleFrameSchedulesDocument = gql`
  query GetVehicleScheduleFrameSchedules($vehicle_schedule_frame_id: uuid!) {
    timetables {
      timetables_vehicle_schedule_vehicle_schedule_frame_by_pk(
        vehicle_schedule_frame_id: $vehicle_schedule_frame_id
      ) {
        vehicle_schedule_frame_id
        validity_start
        validity_end
        priority
        created_at
        vehicle_services {
          vehicle_service_id
          day_type {
            day_type_id
            label
            name_i18n
          }
          blocks {
            block_id
            vehicle_journeys {
              ...vehicle_journey_with_start_time_info
            }
          }
        }
      }
    }
  }
  ${VehicleJourneyWithStartTimeInfoFragmentDoc}
`;

/**
 * __useGetVehicleScheduleFrameSchedulesQuery__
 *
 * To run a query within a React component, call `useGetVehicleScheduleFrameSchedulesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetVehicleScheduleFrameSchedulesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetVehicleScheduleFrameSchedulesQuery({
 *   variables: {
 *      vehicle_schedule_frame_id: // value for 'vehicle_schedule_frame_id'
 *   },
 * });
 */
export function useGetVehicleScheduleFrameSchedulesQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetVehicleScheduleFrameSchedulesQuery,
    GetVehicleScheduleFrameSchedulesQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetVehicleScheduleFrameSchedulesQuery,
    GetVehicleScheduleFrameSchedulesQueryVariables
  >(GetVehicleScheduleFrameSchedulesDocument, options);
}
export function useGetVehicleScheduleFrameSchedulesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetVehicleScheduleFrameSchedulesQuery,
    GetVehicleScheduleFrameSchedulesQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetVehicleScheduleFrameSchedulesQuery,
    GetVehicleScheduleFrameSchedulesQueryVariables
  >(GetVehicleScheduleFrameSchedulesDocument, options);
}
export type GetVehicleScheduleFrameSchedulesQueryHookResult = ReturnType<
  typeof useGetVehicleScheduleFrameSchedulesQuery
>;
export type GetVehicleScheduleFrameSchedulesLazyQueryHookResult = ReturnType<
  typeof useGetVehicleScheduleFrameSchedulesLazyQuery
>;
export type GetVehicleScheduleFrameSchedulesQueryResult = Apollo.QueryResult<
  GetVehicleScheduleFrameSchedulesQuery,
  GetVehicleScheduleFrameSchedulesQueryVariables
>;
export const GetVehicleScheduleFrameWithRoutesDocument = gql`
  query GetVehicleScheduleFrameWithRoutes($vehicle_schedule_frame_id: uuid!) {
    timetables {
      timetables_vehicle_schedule_vehicle_schedule_frame(
        where: {
          vehicle_schedule_frame_id: { _eq: $vehicle_schedule_frame_id }
        }
      ) {
        ...vehicle_schedule_frame_with_routes
      }
    }
  }
  ${VehicleScheduleFrameWithRoutesFragmentDoc}
`;

/**
 * __useGetVehicleScheduleFrameWithRoutesQuery__
 *
 * To run a query within a React component, call `useGetVehicleScheduleFrameWithRoutesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetVehicleScheduleFrameWithRoutesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetVehicleScheduleFrameWithRoutesQuery({
 *   variables: {
 *      vehicle_schedule_frame_id: // value for 'vehicle_schedule_frame_id'
 *   },
 * });
 */
export function useGetVehicleScheduleFrameWithRoutesQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetVehicleScheduleFrameWithRoutesQuery,
    GetVehicleScheduleFrameWithRoutesQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetVehicleScheduleFrameWithRoutesQuery,
    GetVehicleScheduleFrameWithRoutesQueryVariables
  >(GetVehicleScheduleFrameWithRoutesDocument, options);
}
export function useGetVehicleScheduleFrameWithRoutesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetVehicleScheduleFrameWithRoutesQuery,
    GetVehicleScheduleFrameWithRoutesQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetVehicleScheduleFrameWithRoutesQuery,
    GetVehicleScheduleFrameWithRoutesQueryVariables
  >(GetVehicleScheduleFrameWithRoutesDocument, options);
}
export type GetVehicleScheduleFrameWithRoutesQueryHookResult = ReturnType<
  typeof useGetVehicleScheduleFrameWithRoutesQuery
>;
export type GetVehicleScheduleFrameWithRoutesLazyQueryHookResult = ReturnType<
  typeof useGetVehicleScheduleFrameWithRoutesLazyQuery
>;
export type GetVehicleScheduleFrameWithRoutesQueryResult = Apollo.QueryResult<
  GetVehicleScheduleFrameWithRoutesQuery,
  GetVehicleScheduleFrameWithRoutesQueryVariables
>;
export const UpdateVehicleScheduleFrameValidityDocument = gql`
  mutation UpdateVehicleScheduleFrameValidity(
    $vehicle_schedule_frame_id: uuid!
    $validity_start: date
    $validity_end: date
  ) {
    timetables {
      timetables_update_vehicle_schedule_vehicle_schedule_frame(
        _set: { validity_start: $validity_start, validity_end: $validity_end }
        where: {
          vehicle_schedule_frame_id: { _eq: $vehicle_schedule_frame_id }
        }
      ) {
        returning {
          vehicle_schedule_frame_id
          validity_start
          validity_end
        }
      }
    }
  }
`;
export type UpdateVehicleScheduleFrameValidityMutationFn =
  Apollo.MutationFunction<
    UpdateVehicleScheduleFrameValidityMutation,
    UpdateVehicleScheduleFrameValidityMutationVariables
  >;

/**
 * __useUpdateVehicleScheduleFrameValidityMutation__
 *
 * To run a mutation, you first call `useUpdateVehicleScheduleFrameValidityMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateVehicleScheduleFrameValidityMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateVehicleScheduleFrameValidityMutation, { data, loading, error }] = useUpdateVehicleScheduleFrameValidityMutation({
 *   variables: {
 *      vehicle_schedule_frame_id: // value for 'vehicle_schedule_frame_id'
 *      validity_start: // value for 'validity_start'
 *      validity_end: // value for 'validity_end'
 *   },
 * });
 */
export function useUpdateVehicleScheduleFrameValidityMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UpdateVehicleScheduleFrameValidityMutation,
    UpdateVehicleScheduleFrameValidityMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    UpdateVehicleScheduleFrameValidityMutation,
    UpdateVehicleScheduleFrameValidityMutationVariables
  >(UpdateVehicleScheduleFrameValidityDocument, options);
}
export type UpdateVehicleScheduleFrameValidityMutationHookResult = ReturnType<
  typeof useUpdateVehicleScheduleFrameValidityMutation
>;
export type UpdateVehicleScheduleFrameValidityMutationResult =
  Apollo.MutationResult<UpdateVehicleScheduleFrameValidityMutation>;
export type UpdateVehicleScheduleFrameValidityMutationOptions =
  Apollo.BaseMutationOptions<
    UpdateVehicleScheduleFrameValidityMutation,
    UpdateVehicleScheduleFrameValidityMutationVariables
  >;
export const GetVehicleSchedulesForDateDocument = gql`
  query GetVehicleSchedulesForDate(
    $journey_pattern_id: uuid!
    $observation_date: date!
  ) {
    timetables {
      timetables_vehicle_journey_get_vehicle_schedules_on_date(
        args: {
          journey_pattern_uuid: $journey_pattern_id
          observation_date: $observation_date
        }
      ) {
        ...vehicle_schedule
      }
      timetables_service_calendar_get_active_day_types_for_date(
        args: { observation_date: $observation_date }
      ) {
        day_type_id
      }
    }
  }
  ${VehicleScheduleFragmentDoc}
`;

/**
 * __useGetVehicleSchedulesForDateQuery__
 *
 * To run a query within a React component, call `useGetVehicleSchedulesForDateQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetVehicleSchedulesForDateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetVehicleSchedulesForDateQuery({
 *   variables: {
 *      journey_pattern_id: // value for 'journey_pattern_id'
 *      observation_date: // value for 'observation_date'
 *   },
 * });
 */
export function useGetVehicleSchedulesForDateQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetVehicleSchedulesForDateQuery,
    GetVehicleSchedulesForDateQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<
    GetVehicleSchedulesForDateQuery,
    GetVehicleSchedulesForDateQueryVariables
  >(GetVehicleSchedulesForDateDocument, options);
}
export function useGetVehicleSchedulesForDateLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetVehicleSchedulesForDateQuery,
    GetVehicleSchedulesForDateQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<
    GetVehicleSchedulesForDateQuery,
    GetVehicleSchedulesForDateQueryVariables
  >(GetVehicleSchedulesForDateDocument, options);
}
export type GetVehicleSchedulesForDateQueryHookResult = ReturnType<
  typeof useGetVehicleSchedulesForDateQuery
>;
export type GetVehicleSchedulesForDateLazyQueryHookResult = ReturnType<
  typeof useGetVehicleSchedulesForDateLazyQuery
>;
export type GetVehicleSchedulesForDateQueryResult = Apollo.QueryResult<
  GetVehicleSchedulesForDateQuery,
  GetVehicleSchedulesForDateQueryVariables
>;

export function useListChangingRoutesAsyncQuery() {
  return useAsyncQuery<
    ListChangingRoutesQuery,
    ListChangingRoutesQueryVariables
  >(ListChangingRoutesDocument);
}
export type ListChangingRoutesAsyncQueryHookResult = ReturnType<
  typeof useListChangingRoutesAsyncQuery
>;
export function useListOwnLinesAsyncQuery() {
  return useAsyncQuery<ListOwnLinesQuery, ListOwnLinesQueryVariables>(
    ListOwnLinesDocument,
  );
}
export type ListOwnLinesAsyncQueryHookResult = ReturnType<
  typeof useListOwnLinesAsyncQuery
>;
export function useGetScheduledStopPointWithTimingSettingsAsyncQuery() {
  return useAsyncQuery<
    GetScheduledStopPointWithTimingSettingsQuery,
    GetScheduledStopPointWithTimingSettingsQueryVariables
  >(GetScheduledStopPointWithTimingSettingsDocument);
}
export type GetScheduledStopPointWithTimingSettingsAsyncQueryHookResult =
  ReturnType<typeof useGetScheduledStopPointWithTimingSettingsAsyncQuery>;
export function useGetRouteWithJourneyPatternAsyncQuery() {
  return useAsyncQuery<
    GetRouteWithJourneyPatternQuery,
    GetRouteWithJourneyPatternQueryVariables
  >(GetRouteWithJourneyPatternDocument);
}
export type GetRouteWithJourneyPatternAsyncQueryHookResult = ReturnType<
  typeof useGetRouteWithJourneyPatternAsyncQuery
>;
export function useQueryClosestLinkAsyncQuery() {
  return useAsyncQuery<QueryClosestLinkQuery, QueryClosestLinkQueryVariables>(
    QueryClosestLinkDocument,
  );
}
export type QueryClosestLinkAsyncQueryHookResult = ReturnType<
  typeof useQueryClosestLinkAsyncQuery
>;
export function useQueryPointDirectionOnLinkAsyncQuery() {
  return useAsyncQuery<
    QueryPointDirectionOnLinkQuery,
    QueryPointDirectionOnLinkQueryVariables
  >(QueryPointDirectionOnLinkDocument);
}
export type QueryPointDirectionOnLinkAsyncQueryHookResult = ReturnType<
  typeof useQueryPointDirectionOnLinkAsyncQuery
>;
export function useGetStopsAlongInfrastructureLinksAsyncQuery() {
  return useAsyncQuery<
    GetStopsAlongInfrastructureLinksQuery,
    GetStopsAlongInfrastructureLinksQueryVariables
  >(GetStopsAlongInfrastructureLinksDocument);
}
export type GetStopsAlongInfrastructureLinksAsyncQueryHookResult = ReturnType<
  typeof useGetStopsAlongInfrastructureLinksAsyncQuery
>;

export function useGetScheduledStopPointWithViaInfoAsyncQuery() {
  return useAsyncQuery<
    GetScheduledStopPointWithViaInfoQuery,
    GetScheduledStopPointWithViaInfoQueryVariables
  >(GetScheduledStopPointWithViaInfoDocument);
}
export type GetScheduledStopPointWithViaInfoAsyncQueryHookResult = ReturnType<
  typeof useGetScheduledStopPointWithViaInfoAsyncQuery
>;
export function useGetLineDetailsByIdAsyncQuery() {
  return useAsyncQuery<
    GetLineDetailsByIdQuery,
    GetLineDetailsByIdQueryVariables
  >(GetLineDetailsByIdDocument);
}
export type GetLineDetailsByIdAsyncQueryHookResult = ReturnType<
  typeof useGetLineDetailsByIdAsyncQuery
>;
export function useGetLineValidityPeriodByIdAsyncQuery() {
  return useAsyncQuery<
    GetLineValidityPeriodByIdQuery,
    GetLineValidityPeriodByIdQueryVariables
  >(GetLineValidityPeriodByIdDocument);
}
export type GetLineValidityPeriodByIdAsyncQueryHookResult = ReturnType<
  typeof useGetLineValidityPeriodByIdAsyncQuery
>;
export function useGetLinesByValidityAsyncQuery() {
  return useAsyncQuery<
    GetLinesByValidityQuery,
    GetLinesByValidityQueryVariables
  >(GetLinesByValidityDocument);
}
export type GetLinesByValidityAsyncQueryHookResult = ReturnType<
  typeof useGetLinesByValidityAsyncQuery
>;
export function useGetLineDetailsWithRoutesByIdAsyncQuery() {
  return useAsyncQuery<
    GetLineDetailsWithRoutesByIdQuery,
    GetLineDetailsWithRoutesByIdQueryVariables
  >(GetLineDetailsWithRoutesByIdDocument);
}
export type GetLineDetailsWithRoutesByIdAsyncQueryHookResult = ReturnType<
  typeof useGetLineDetailsWithRoutesByIdAsyncQuery
>;
export function useGetRoutesWithStopsAsyncQuery() {
  return useAsyncQuery<
    GetRoutesWithStopsQuery,
    GetRoutesWithStopsQueryVariables
  >(GetRoutesWithStopsDocument);
}
export type GetRoutesWithStopsAsyncQueryHookResult = ReturnType<
  typeof useGetRoutesWithStopsAsyncQuery
>;
export function useGetRouteDetailsByIdAsyncQuery() {
  return useAsyncQuery<
    GetRouteDetailsByIdQuery,
    GetRouteDetailsByIdQueryVariables
  >(GetRouteDetailsByIdDocument);
}
export type GetRouteDetailsByIdAsyncQueryHookResult = ReturnType<
  typeof useGetRouteDetailsByIdAsyncQuery
>;
export function useGetRouteDetailsByIdsAsyncQuery() {
  return useAsyncQuery<
    GetRouteDetailsByIdsQuery,
    GetRouteDetailsByIdsQueryVariables
  >(GetRouteDetailsByIdsDocument);
}
export type GetRouteDetailsByIdsAsyncQueryHookResult = ReturnType<
  typeof useGetRouteDetailsByIdsAsyncQuery
>;
export function useGetRouteRenderInfoByIdAsyncQuery() {
  return useAsyncQuery<
    GetRouteRenderInfoByIdQuery,
    GetRouteRenderInfoByIdQueryVariables
  >(GetRouteRenderInfoByIdDocument);
}
export type GetRouteRenderInfoByIdAsyncQueryHookResult = ReturnType<
  typeof useGetRouteRenderInfoByIdAsyncQuery
>;
export function useGetRouteDetailsByLabelsAsyncQuery() {
  return useAsyncQuery<
    GetRouteDetailsByLabelsQuery,
    GetRouteDetailsByLabelsQueryVariables
  >(GetRouteDetailsByLabelsDocument);
}
export type GetRouteDetailsByLabelsAsyncQueryHookResult = ReturnType<
  typeof useGetRouteDetailsByLabelsAsyncQuery
>;
export function useGetRoutesWithInfrastructureLinksAsyncQuery() {
  return useAsyncQuery<
    GetRoutesWithInfrastructureLinksQuery,
    GetRoutesWithInfrastructureLinksQueryVariables
  >(GetRoutesWithInfrastructureLinksDocument);
}
export type GetRoutesWithInfrastructureLinksAsyncQueryHookResult = ReturnType<
  typeof useGetRoutesWithInfrastructureLinksAsyncQuery
>;
export function useGetRoutesByValidityAsyncQuery() {
  return useAsyncQuery<
    GetRoutesByValidityQuery,
    GetRoutesByValidityQueryVariables
  >(GetRoutesByValidityDocument);
}
export type GetRoutesByValidityAsyncQueryHookResult = ReturnType<
  typeof useGetRoutesByValidityAsyncQuery
>;

export function useGetScheduledStopsOnRouteAsyncQuery() {
  return useAsyncQuery<
    GetScheduledStopsOnRouteQuery,
    GetScheduledStopsOnRouteQueryVariables
  >(GetScheduledStopsOnRouteDocument);
}
export type GetScheduledStopsOnRouteAsyncQueryHookResult = ReturnType<
  typeof useGetScheduledStopsOnRouteAsyncQuery
>;

export function useGetStopsByLocationAsyncQuery() {
  return useAsyncQuery<
    GetStopsByLocationQuery,
    GetStopsByLocationQueryVariables
  >(GetStopsByLocationDocument);
}
export type GetStopsByLocationAsyncQueryHookResult = ReturnType<
  typeof useGetStopsByLocationAsyncQuery
>;
export function useGetStopsByValidityAsyncQuery() {
  return useAsyncQuery<
    GetStopsByValidityQuery,
    GetStopsByValidityQueryVariables
  >(GetStopsByValidityDocument);
}
export type GetStopsByValidityAsyncQueryHookResult = ReturnType<
  typeof useGetStopsByValidityAsyncQuery
>;
export function useGetStopsByIdsAsyncQuery() {
  return useAsyncQuery<GetStopsByIdsQuery, GetStopsByIdsQueryVariables>(
    GetStopsByIdsDocument,
  );
}
export type GetStopsByIdsAsyncQueryHookResult = ReturnType<
  typeof useGetStopsByIdsAsyncQuery
>;
export function useGetStopsByLabelsAsyncQuery() {
  return useAsyncQuery<GetStopsByLabelsQuery, GetStopsByLabelsQueryVariables>(
    GetStopsByLabelsDocument,
  );
}
export type GetStopsByLabelsAsyncQueryHookResult = ReturnType<
  typeof useGetStopsByLabelsAsyncQuery
>;

export function useGetStopWithRouteGraphDataByIdAsyncQuery() {
  return useAsyncQuery<
    GetStopWithRouteGraphDataByIdQuery,
    GetStopWithRouteGraphDataByIdQueryVariables
  >(GetStopWithRouteGraphDataByIdDocument);
}
export type GetStopWithRouteGraphDataByIdAsyncQueryHookResult = ReturnType<
  typeof useGetStopWithRouteGraphDataByIdAsyncQuery
>;
export function useGetRoutesBrokenByStopChangeAsyncQuery() {
  return useAsyncQuery<
    GetRoutesBrokenByStopChangeQuery,
    GetRoutesBrokenByStopChangeQueryVariables
  >(GetRoutesBrokenByStopChangeDocument);
}
export type GetRoutesBrokenByStopChangeAsyncQueryHookResult = ReturnType<
  typeof useGetRoutesBrokenByStopChangeAsyncQuery
>;
export function useGetHighestPriorityLineDetailsWithRoutesAsyncQuery() {
  return useAsyncQuery<
    GetHighestPriorityLineDetailsWithRoutesQuery,
    GetHighestPriorityLineDetailsWithRoutesQueryVariables
  >(GetHighestPriorityLineDetailsWithRoutesDocument);
}
export type GetHighestPriorityLineDetailsWithRoutesAsyncQueryHookResult =
  ReturnType<typeof useGetHighestPriorityLineDetailsWithRoutesAsyncQuery>;

export function useGetLinksWithStopsByExternalLinkIdsAsyncQuery() {
  return useAsyncQuery<
    GetLinksWithStopsByExternalLinkIdsQuery,
    GetLinksWithStopsByExternalLinkIdsQueryVariables
  >(GetLinksWithStopsByExternalLinkIdsDocument);
}
export type GetLinksWithStopsByExternalLinkIdsAsyncQueryHookResult = ReturnType<
  typeof useGetLinksWithStopsByExternalLinkIdsAsyncQuery
>;
export function useGetLineRoutesByLabelAsyncQuery() {
  return useAsyncQuery<
    GetLineRoutesByLabelQuery,
    GetLineRoutesByLabelQueryVariables
  >(GetLineRoutesByLabelDocument);
}
export type GetLineRoutesByLabelAsyncQueryHookResult = ReturnType<
  typeof useGetLineRoutesByLabelAsyncQuery
>;
export function useGetRouteByFiltersAsyncQuery() {
  return useAsyncQuery<GetRouteByFiltersQuery, GetRouteByFiltersQueryVariables>(
    GetRouteByFiltersDocument,
  );
}
export type GetRouteByFiltersAsyncQueryHookResult = ReturnType<
  typeof useGetRouteByFiltersAsyncQuery
>;
export function useGetRouteWithInfrastructureLinksWithStopsAsyncQuery() {
  return useAsyncQuery<
    GetRouteWithInfrastructureLinksWithStopsQuery,
    GetRouteWithInfrastructureLinksWithStopsQueryVariables
  >(GetRouteWithInfrastructureLinksWithStopsDocument);
}
export type GetRouteWithInfrastructureLinksWithStopsAsyncQueryHookResult =
  ReturnType<typeof useGetRouteWithInfrastructureLinksWithStopsAsyncQuery>;
export function useSearchLinesAndRoutesAsyncQuery() {
  return useAsyncQuery<
    SearchLinesAndRoutesQuery,
    SearchLinesAndRoutesQueryVariables
  >(SearchLinesAndRoutesDocument);
}
export type SearchLinesAndRoutesAsyncQueryHookResult = ReturnType<
  typeof useSearchLinesAndRoutesAsyncQuery
>;
export function useSearchStopsAsyncQuery() {
  return useAsyncQuery<SearchStopsQuery, SearchStopsQueryVariables>(
    SearchStopsDocument,
  );
}
export type SearchStopsAsyncQueryHookResult = ReturnType<
  typeof useSearchStopsAsyncQuery
>;

export function useGetStopDetailsByIdAsyncQuery() {
  return useAsyncQuery<
    GetStopDetailsByIdQuery,
    GetStopDetailsByIdQueryVariables
  >(GetStopDetailsByIdDocument);
}
export type GetStopDetailsByIdAsyncQueryHookResult = ReturnType<
  typeof useGetStopDetailsByIdAsyncQuery
>;

export function useGetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsAsyncQuery() {
  return useAsyncQuery<
    GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery,
    GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQueryVariables
  >(GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsDocument);
}
export type GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsAsyncQueryHookResult =
  ReturnType<
    typeof useGetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsAsyncQuery
  >;

export function useGetSubstituteOperatingPeriodsAsyncQuery() {
  return useAsyncQuery<
    GetSubstituteOperatingPeriodsQuery,
    GetSubstituteOperatingPeriodsQueryVariables
  >(GetSubstituteOperatingPeriodsDocument);
}
export type GetSubstituteOperatingPeriodsAsyncQueryHookResult = ReturnType<
  typeof useGetSubstituteOperatingPeriodsAsyncQuery
>;
export function useGetToCombineTargetVehicleScheduleFrameIdAsyncQuery() {
  return useAsyncQuery<
    GetToCombineTargetVehicleScheduleFrameIdQuery,
    GetToCombineTargetVehicleScheduleFrameIdQueryVariables
  >(GetToCombineTargetVehicleScheduleFrameIdDocument);
}
export type GetToCombineTargetVehicleScheduleFrameIdAsyncQueryHookResult =
  ReturnType<typeof useGetToCombineTargetVehicleScheduleFrameIdAsyncQuery>;
export function useGetToReplaceVehicleScheduleFramesAsyncQuery() {
  return useAsyncQuery<
    GetToReplaceVehicleScheduleFramesQuery,
    GetToReplaceVehicleScheduleFramesQueryVariables
  >(GetToReplaceVehicleScheduleFramesDocument);
}
export type GetToReplaceVehicleScheduleFramesAsyncQueryHookResult = ReturnType<
  typeof useGetToReplaceVehicleScheduleFramesAsyncQuery
>;
export function useGetVehicleScheduleFrameWithJourneyInfoAsyncQuery() {
  return useAsyncQuery<
    GetVehicleScheduleFrameWithJourneyInfoQuery,
    GetVehicleScheduleFrameWithJourneyInfoQueryVariables
  >(GetVehicleScheduleFrameWithJourneyInfoDocument);
}
export type GetVehicleScheduleFrameWithJourneyInfoAsyncQueryHookResult =
  ReturnType<typeof useGetVehicleScheduleFrameWithJourneyInfoAsyncQuery>;
export function useGetVehicleScheduleFrameWithRouteAndLineInfoAsyncQuery() {
  return useAsyncQuery<
    GetVehicleScheduleFrameWithRouteAndLineInfoQuery,
    GetVehicleScheduleFrameWithRouteAndLineInfoQueryVariables
  >(GetVehicleScheduleFrameWithRouteAndLineInfoDocument);
}
export type GetVehicleScheduleFrameWithRouteAndLineInfoAsyncQueryHookResult =
  ReturnType<typeof useGetVehicleScheduleFrameWithRouteAndLineInfoAsyncQuery>;
export function useGetStagingVehicleScheduleFramesAsyncQuery() {
  return useAsyncQuery<
    GetStagingVehicleScheduleFramesQuery,
    GetStagingVehicleScheduleFramesQueryVariables
  >(GetStagingVehicleScheduleFramesDocument);
}
export type GetStagingVehicleScheduleFramesAsyncQueryHookResult = ReturnType<
  typeof useGetStagingVehicleScheduleFramesAsyncQuery
>;

export function useGetTimingPlacesByLabelAsyncQuery() {
  return useAsyncQuery<
    GetTimingPlacesByLabelQuery,
    GetTimingPlacesByLabelQueryVariables
  >(GetTimingPlacesByLabelDocument);
}
export type GetTimingPlacesByLabelAsyncQueryHookResult = ReturnType<
  typeof useGetTimingPlacesByLabelAsyncQuery
>;
export function useGetLinesForComboboxAsyncQuery() {
  return useAsyncQuery<
    GetLinesForComboboxQuery,
    GetLinesForComboboxQueryVariables
  >(GetLinesForComboboxDocument);
}
export type GetLinesForComboboxAsyncQueryHookResult = ReturnType<
  typeof useGetLinesForComboboxAsyncQuery
>;
export function useGetSelectedLineDetailsByIdAsyncQuery() {
  return useAsyncQuery<
    GetSelectedLineDetailsByIdQuery,
    GetSelectedLineDetailsByIdQueryVariables
  >(GetSelectedLineDetailsByIdDocument);
}
export type GetSelectedLineDetailsByIdAsyncQueryHookResult = ReturnType<
  typeof useGetSelectedLineDetailsByIdAsyncQuery
>;
export function useGetRouteDetailsByLabelWildcardAsyncQuery() {
  return useAsyncQuery<
    GetRouteDetailsByLabelWildcardQuery,
    GetRouteDetailsByLabelWildcardQueryVariables
  >(GetRouteDetailsByLabelWildcardDocument);
}
export type GetRouteDetailsByLabelWildcardAsyncQueryHookResult = ReturnType<
  typeof useGetRouteDetailsByLabelWildcardAsyncQuery
>;
export function useGetSelectedRouteDetailsByIdAsyncQuery() {
  return useAsyncQuery<
    GetSelectedRouteDetailsByIdQuery,
    GetSelectedRouteDetailsByIdQueryVariables
  >(GetSelectedRouteDetailsByIdDocument);
}
export type GetSelectedRouteDetailsByIdAsyncQueryHookResult = ReturnType<
  typeof useGetSelectedRouteDetailsByIdAsyncQuery
>;
export function useGetTimingPlacesForComboboxAsyncQuery() {
  return useAsyncQuery<
    GetTimingPlacesForComboboxQuery,
    GetTimingPlacesForComboboxQueryVariables
  >(GetTimingPlacesForComboboxDocument);
}
export type GetTimingPlacesForComboboxAsyncQueryHookResult = ReturnType<
  typeof useGetTimingPlacesForComboboxAsyncQuery
>;
export function useGetSelectedTimingPlaceDetailsByIdAsyncQuery() {
  return useAsyncQuery<
    GetSelectedTimingPlaceDetailsByIdQuery,
    GetSelectedTimingPlaceDetailsByIdQueryVariables
  >(GetSelectedTimingPlaceDetailsByIdDocument);
}
export type GetSelectedTimingPlaceDetailsByIdAsyncQueryHookResult = ReturnType<
  typeof useGetSelectedTimingPlaceDetailsByIdAsyncQuery
>;
export function useGetRouteInfoForTimetableVersionsAsyncQuery() {
  return useAsyncQuery<
    GetRouteInfoForTimetableVersionsQuery,
    GetRouteInfoForTimetableVersionsQueryVariables
  >(GetRouteInfoForTimetableVersionsDocument);
}
export type GetRouteInfoForTimetableVersionsAsyncQueryHookResult = ReturnType<
  typeof useGetRouteInfoForTimetableVersionsAsyncQuery
>;
export function useGetTimetableVersionsByJourneyPatternIdsAsyncQuery() {
  return useAsyncQuery<
    GetTimetableVersionsByJourneyPatternIdsQuery,
    GetTimetableVersionsByJourneyPatternIdsQueryVariables
  >(GetTimetableVersionsByJourneyPatternIdsDocument);
}
export type GetTimetableVersionsByJourneyPatternIdsAsyncQueryHookResult =
  ReturnType<typeof useGetTimetableVersionsByJourneyPatternIdsAsyncQuery>;

export function useGetVehicleScheduleFrameSchedulesAsyncQuery() {
  return useAsyncQuery<
    GetVehicleScheduleFrameSchedulesQuery,
    GetVehicleScheduleFrameSchedulesQueryVariables
  >(GetVehicleScheduleFrameSchedulesDocument);
}
export type GetVehicleScheduleFrameSchedulesAsyncQueryHookResult = ReturnType<
  typeof useGetVehicleScheduleFrameSchedulesAsyncQuery
>;
export function useGetVehicleScheduleFrameWithRoutesAsyncQuery() {
  return useAsyncQuery<
    GetVehicleScheduleFrameWithRoutesQuery,
    GetVehicleScheduleFrameWithRoutesQueryVariables
  >(GetVehicleScheduleFrameWithRoutesDocument);
}
export type GetVehicleScheduleFrameWithRoutesAsyncQueryHookResult = ReturnType<
  typeof useGetVehicleScheduleFrameWithRoutesAsyncQuery
>;

export function useGetVehicleSchedulesForDateAsyncQuery() {
  return useAsyncQuery<
    GetVehicleSchedulesForDateQuery,
    GetVehicleSchedulesForDateQueryVariables
  >(GetVehicleSchedulesForDateDocument);
}
export type GetVehicleSchedulesForDateAsyncQueryHookResult = ReturnType<
  typeof useGetVehicleSchedulesForDateAsyncQuery
>;

import * as luxon from 'luxon';
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  _uuid: { input: any; output: any; }
  bigint: { input: any; output: any; }
  bytea: { input: any; output: any; }
  date: { input: luxon.DateTime; output: luxon.DateTime; }
  daterange: { input: any; output: any; }
  float8: { input: number; output: number; }
  geography: { input: GeoJSON.Geometry; output: GeoJSON.Geometry; }
  geography_linestring: { input: GeoJSON.LineString; output: GeoJSON.LineString; }
  geography_point: { input: GeoJSON.Point; output: GeoJSON.Point; }
  geometry: { input: GeoJSON.Geometry; output: GeoJSON.Geometry; }
  interval: { input: luxon.Duration; output: luxon.Duration; }
  jsonb: { input: any; output: any; }
  localized_string: { input: LocalizedString; output: LocalizedString; }
  name: { input: any; output: any; }
  numeric: { input: any; output: any; }
  smallint: { input: number; output: number; }
  /** An arbitrary precision signed decimal */
  stop_registry_BigDecimal: { input: any; output: any; }
  /** An arbitrary precision signed integer */
  stop_registry_BigInteger: { input: any; output: any; }
  /** GeoJSON Coordinates */
  stop_registry_Coordinates: { input: GeoJSON.Position; output: GeoJSON.Position; }
  /** Date time using the format: yyyy-MM-dd'T'HH:mm:ss.SSSXXXX. Example: 2017-04-23T18:25:43.511+0100 */
  stop_registry_DateTime: { input: luxon.DateTime; output: luxon.DateTime; }
  /** Date using the format: yyyy-MM-dd. Example: 2025-04-23 */
  stop_registry_LocalDate: { input: any; output: any; }
  /** Legacy GeoJSON Coordinates */
  stop_registry_legacyCoordinates: { input: any; output: any; }
  timestamp: { input: any; output: any; }
  timestamptz: { input: luxon.DateTime; output: luxon.DateTime; }
  uuid: { input: UUID; output: UUID; }
};

/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
export type BooleanComparisonExp = {
  readonly _eq?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _gt?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _gte?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _in?: InputMaybe<ReadonlyArray<Scalars['Boolean']['input']>>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _lt?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _lte?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _neq?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _nin?: InputMaybe<ReadonlyArray<Scalars['Boolean']['input']>>;
};

export type CombineTimetablesInput = {
  readonly stagingVehicleScheduleFrameIds: ReadonlyArray<InputMaybe<Scalars['uuid']['input']>>;
  readonly targetPriority: Scalars['Int']['input'];
};

export type CombineTimetablesOutput = {
  readonly __typename?: 'CombineTimetablesOutput';
  readonly combinedIntoVehicleScheduleFrameIds: ReadonlyArray<Maybe<Scalars['uuid']['output']>>;
};

/** Boolean expression to compare columns of type "Float". All fields are combined with logical 'AND'. */
export type FloatComparisonExp = {
  readonly _eq?: InputMaybe<Scalars['Float']['input']>;
  readonly _gt?: InputMaybe<Scalars['Float']['input']>;
  readonly _gte?: InputMaybe<Scalars['Float']['input']>;
  readonly _in?: InputMaybe<ReadonlyArray<Scalars['Float']['input']>>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _lt?: InputMaybe<Scalars['Float']['input']>;
  readonly _lte?: InputMaybe<Scalars['Float']['input']>;
  readonly _neq?: InputMaybe<Scalars['Float']['input']>;
  readonly _nin?: InputMaybe<ReadonlyArray<Scalars['Float']['input']>>;
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type IntComparisonExp = {
  readonly _eq?: InputMaybe<Scalars['Int']['input']>;
  readonly _gt?: InputMaybe<Scalars['Int']['input']>;
  readonly _gte?: InputMaybe<Scalars['Int']['input']>;
  readonly _in?: InputMaybe<ReadonlyArray<Scalars['Int']['input']>>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _lt?: InputMaybe<Scalars['Int']['input']>;
  readonly _lte?: InputMaybe<Scalars['Int']['input']>;
  readonly _neq?: InputMaybe<Scalars['Int']['input']>;
  readonly _nin?: InputMaybe<ReadonlyArray<Scalars['Int']['input']>>;
};

export type ReplaceTimetablesInput = {
  readonly stagingVehicleScheduleFrameIds: ReadonlyArray<InputMaybe<Scalars['uuid']['input']>>;
  readonly targetPriority: Scalars['Int']['input'];
};

export type ReplaceTimetablesOutput = {
  readonly __typename?: 'ReplaceTimetablesOutput';
  readonly replacedVehicleScheduleFrameIds: ReadonlyArray<Maybe<Scalars['uuid']['output']>>;
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type StringComparisonExp = {
  readonly _eq?: InputMaybe<Scalars['String']['input']>;
  readonly _gt?: InputMaybe<Scalars['String']['input']>;
  readonly _gte?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given case-insensitive pattern */
  readonly _ilike?: InputMaybe<Scalars['String']['input']>;
  readonly _in?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  readonly _iregex?: InputMaybe<Scalars['String']['input']>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  /** does the column match the given pattern */
  readonly _like?: InputMaybe<Scalars['String']['input']>;
  readonly _lt?: InputMaybe<Scalars['String']['input']>;
  readonly _lte?: InputMaybe<Scalars['String']['input']>;
  readonly _neq?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given case-insensitive pattern */
  readonly _nilike?: InputMaybe<Scalars['String']['input']>;
  readonly _nin?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  readonly _niregex?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given pattern */
  readonly _nlike?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  readonly _nregex?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given SQL regular expression */
  readonly _nsimilar?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  readonly _regex?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given SQL regular expression */
  readonly _similar?: InputMaybe<Scalars['String']['input']>;
};

export type TerminalStopSearchResult = {
  readonly __typename?: 'TerminalStopSearchResult';
  readonly cursor: Scalars['bigint']['output'];
  readonly stops: Scalars['jsonb']['output'];
};


export type TerminalStopSearchResultStopsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

export enum TerminalStopSearchResultEnumName {
  /** column name */
  Cursor = 'cursor',
  /** column name */
  Stops = 'stops'
}

export type ToCombineTargetVehicleScheduleFrameIdInput = {
  readonly stagingVehicleScheduleFrameId: Scalars['uuid']['input'];
  readonly targetPriority: Scalars['Int']['input'];
};

export type ToCombineTargetVehicleScheduleFrameIdOutput = {
  readonly __typename?: 'ToCombineTargetVehicleScheduleFrameIdOutput';
  readonly toCombineTargetVehicleScheduleFrameId: Scalars['uuid']['output'];
};

export type ToReplaceVehicleScheduleFrameIdsInput = {
  readonly stagingVehicleScheduleFrameId: Scalars['uuid']['input'];
  readonly targetPriority: Scalars['Int']['input'];
};

export type ToReplaceVehicleScheduleFrameIdsOutput = {
  readonly __typename?: 'ToReplaceVehicleScheduleFrameIdsOutput';
  readonly toReplaceVehicleScheduleFrameIds: ReadonlyArray<Maybe<Scalars['uuid']['output']>>;
};

export type AccessSpaceAlternativeNamesAggregateBoolExp = {
  readonly count?: InputMaybe<AccessSpaceAlternativeNamesAggregateBoolExpCount>;
};

export type AccessSpaceAlternativeNamesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNamesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type AccessSpaceEquipmentPlacesAggregateBoolExp = {
  readonly count?: InputMaybe<AccessSpaceEquipmentPlacesAggregateBoolExpCount>;
};

export type AccessSpaceEquipmentPlacesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlacesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type AccessSpaceKeyValuesAggregateBoolExp = {
  readonly count?: InputMaybe<AccessSpaceKeyValuesAggregateBoolExpCount>;
};

export type AccessSpaceKeyValuesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceKeyValuesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type AccessibilityAssessmentLimitationsAggregateBoolExp = {
  readonly count?: InputMaybe<AccessibilityAssessmentLimitationsAggregateBoolExpCount>;
};

export type AccessibilityAssessmentLimitationsAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitationsSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>;
  readonly predicate: IntComparisonExp;
};

/** Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'. */
export type BigintComparisonExp = {
  readonly _eq?: InputMaybe<Scalars['bigint']['input']>;
  readonly _gt?: InputMaybe<Scalars['bigint']['input']>;
  readonly _gte?: InputMaybe<Scalars['bigint']['input']>;
  readonly _in?: InputMaybe<ReadonlyArray<Scalars['bigint']['input']>>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _lt?: InputMaybe<Scalars['bigint']['input']>;
  readonly _lte?: InputMaybe<Scalars['bigint']['input']>;
  readonly _neq?: InputMaybe<Scalars['bigint']['input']>;
  readonly _nin?: InputMaybe<ReadonlyArray<Scalars['bigint']['input']>>;
};

export type BoardingPositionAlternativeNamesAggregateBoolExp = {
  readonly count?: InputMaybe<BoardingPositionAlternativeNamesAggregateBoolExpCount>;
};

export type BoardingPositionAlternativeNamesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNamesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type BoardingPositionEquipmentPlacesAggregateBoolExp = {
  readonly count?: InputMaybe<BoardingPositionEquipmentPlacesAggregateBoolExpCount>;
};

export type BoardingPositionEquipmentPlacesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlacesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type BoardingPositionKeyValuesAggregateBoolExp = {
  readonly count?: InputMaybe<BoardingPositionKeyValuesAggregateBoolExpCount>;
};

export type BoardingPositionKeyValuesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionKeyValuesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesBoolExp>;
  readonly predicate: IntComparisonExp;
};

/** Boolean expression to compare columns of type "bytea". All fields are combined with logical 'AND'. */
export type ByteaComparisonExp = {
  readonly _eq?: InputMaybe<Scalars['bytea']['input']>;
  readonly _gt?: InputMaybe<Scalars['bytea']['input']>;
  readonly _gte?: InputMaybe<Scalars['bytea']['input']>;
  readonly _in?: InputMaybe<ReadonlyArray<Scalars['bytea']['input']>>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _lt?: InputMaybe<Scalars['bytea']['input']>;
  readonly _lte?: InputMaybe<Scalars['bytea']['input']>;
  readonly _neq?: InputMaybe<Scalars['bytea']['input']>;
  readonly _nin?: InputMaybe<ReadonlyArray<Scalars['bytea']['input']>>;
};

/** ordering argument of a cursor */
export enum CursorOrdering {
  /** ascending ordering of the cursor */
  Asc = 'ASC',
  /** descending ordering of the cursor */
  Desc = 'DESC'
}

/** Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'. */
export type DateComparisonExp = {
  readonly _eq?: InputMaybe<Scalars['date']['input']>;
  readonly _gt?: InputMaybe<Scalars['date']['input']>;
  readonly _gte?: InputMaybe<Scalars['date']['input']>;
  readonly _in?: InputMaybe<ReadonlyArray<Scalars['date']['input']>>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _lt?: InputMaybe<Scalars['date']['input']>;
  readonly _lte?: InputMaybe<Scalars['date']['input']>;
  readonly _neq?: InputMaybe<Scalars['date']['input']>;
  readonly _nin?: InputMaybe<ReadonlyArray<Scalars['date']['input']>>;
};

/** Boolean expression to compare columns of type "daterange". All fields are combined with logical 'AND'. */
export type DaterangeComparisonExp = {
  readonly _eq?: InputMaybe<Scalars['daterange']['input']>;
  readonly _gt?: InputMaybe<Scalars['daterange']['input']>;
  readonly _gte?: InputMaybe<Scalars['daterange']['input']>;
  readonly _in?: InputMaybe<ReadonlyArray<Scalars['daterange']['input']>>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _lt?: InputMaybe<Scalars['daterange']['input']>;
  readonly _lte?: InputMaybe<Scalars['daterange']['input']>;
  readonly _neq?: InputMaybe<Scalars['daterange']['input']>;
  readonly _nin?: InputMaybe<ReadonlyArray<Scalars['daterange']['input']>>;
};

export type EquipmentPlaceEquipmentPositionsAggregateBoolExp = {
  readonly count?: InputMaybe<EquipmentPlaceEquipmentPositionsAggregateBoolExpCount>;
};

export type EquipmentPlaceEquipmentPositionsAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositionsSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type EquipmentPlaceKeyValuesAggregateBoolExp = {
  readonly count?: InputMaybe<EquipmentPlaceKeyValuesAggregateBoolExpCount>;
};

export type EquipmentPlaceKeyValuesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValuesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type EquipmentPositionKeyValuesAggregateBoolExp = {
  readonly count?: InputMaybe<EquipmentPositionKeyValuesAggregateBoolExpCount>;
};

export type EquipmentPositionKeyValuesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionKeyValuesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type FareZoneKeyValuesAggregateBoolExp = {
  readonly count?: InputMaybe<FareZoneKeyValuesAggregateBoolExpCount>;
};

export type FareZoneKeyValuesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneKeyValuesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseFareZoneKeyValuesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type FareZoneMembersAggregateBoolExp = {
  readonly count?: InputMaybe<FareZoneMembersAggregateBoolExpCount>;
};

export type FareZoneMembersAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneMembersSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseFareZoneMembersBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type FareZoneNeighboursAggregateBoolExp = {
  readonly count?: InputMaybe<FareZoneNeighboursAggregateBoolExpCount>;
};

export type FareZoneNeighboursAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneNeighboursSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseFareZoneNeighboursBoolExp>;
  readonly predicate: IntComparisonExp;
};

/** findStopsForTerminalNative Query Arguments */
export type FindStopsForTerminalArguments = {
  readonly query: Scalars['String']['input'];
};

/** Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'. */
export type Float8ComparisonExp = {
  readonly _eq?: InputMaybe<Scalars['float8']['input']>;
  readonly _gt?: InputMaybe<Scalars['float8']['input']>;
  readonly _gte?: InputMaybe<Scalars['float8']['input']>;
  readonly _in?: InputMaybe<ReadonlyArray<Scalars['float8']['input']>>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _lt?: InputMaybe<Scalars['float8']['input']>;
  readonly _lte?: InputMaybe<Scalars['float8']['input']>;
  readonly _neq?: InputMaybe<Scalars['float8']['input']>;
  readonly _nin?: InputMaybe<ReadonlyArray<Scalars['float8']['input']>>;
};

export type GeographyCastExp = {
  readonly geometry?: InputMaybe<GeometryComparisonExp>;
};

/** Boolean expression to compare columns of type "geography". All fields are combined with logical 'AND'. */
export type GeographyComparisonExp = {
  readonly _cast?: InputMaybe<GeographyCastExp>;
  readonly _eq?: InputMaybe<Scalars['geography']['input']>;
  readonly _gt?: InputMaybe<Scalars['geography']['input']>;
  readonly _gte?: InputMaybe<Scalars['geography']['input']>;
  readonly _in?: InputMaybe<ReadonlyArray<Scalars['geography']['input']>>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _lt?: InputMaybe<Scalars['geography']['input']>;
  readonly _lte?: InputMaybe<Scalars['geography']['input']>;
  readonly _neq?: InputMaybe<Scalars['geography']['input']>;
  readonly _nin?: InputMaybe<ReadonlyArray<Scalars['geography']['input']>>;
  /** is the column within a given distance from the given geography value */
  readonly _st_d_within?: InputMaybe<StDWithinGeographyInput>;
  /** does the column spatially intersect the given geography value */
  readonly _st_intersects?: InputMaybe<Scalars['geography']['input']>;
};

export type GeometryCastExp = {
  readonly geography?: InputMaybe<GeographyComparisonExp>;
};

/** Boolean expression to compare columns of type "geometry". All fields are combined with logical 'AND'. */
export type GeometryComparisonExp = {
  readonly _cast?: InputMaybe<GeometryCastExp>;
  readonly _eq?: InputMaybe<Scalars['geometry']['input']>;
  readonly _gt?: InputMaybe<Scalars['geometry']['input']>;
  readonly _gte?: InputMaybe<Scalars['geometry']['input']>;
  readonly _in?: InputMaybe<ReadonlyArray<Scalars['geometry']['input']>>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _lt?: InputMaybe<Scalars['geometry']['input']>;
  readonly _lte?: InputMaybe<Scalars['geometry']['input']>;
  readonly _neq?: InputMaybe<Scalars['geometry']['input']>;
  readonly _nin?: InputMaybe<ReadonlyArray<Scalars['geometry']['input']>>;
  /** is the column within a given 3D distance from the given geometry value */
  readonly _st_3d_d_within?: InputMaybe<StDWithinInput>;
  /** does the column spatially intersect the given geometry value in 3D */
  readonly _st_3d_intersects?: InputMaybe<Scalars['geometry']['input']>;
  /** does the column contain the given geometry value */
  readonly _st_contains?: InputMaybe<Scalars['geometry']['input']>;
  /** does the column cross the given geometry value */
  readonly _st_crosses?: InputMaybe<Scalars['geometry']['input']>;
  /** is the column within a given distance from the given geometry value */
  readonly _st_d_within?: InputMaybe<StDWithinInput>;
  /** is the column equal to given geometry value (directionality is ignored) */
  readonly _st_equals?: InputMaybe<Scalars['geometry']['input']>;
  /** does the column spatially intersect the given geometry value */
  readonly _st_intersects?: InputMaybe<Scalars['geometry']['input']>;
  /** does the column 'spatially overlap' (intersect but not completely contain) the given geometry value */
  readonly _st_overlaps?: InputMaybe<Scalars['geometry']['input']>;
  /** does the column have atleast one point in common with the given geometry value */
  readonly _st_touches?: InputMaybe<Scalars['geometry']['input']>;
  /** is the column contained in the given geometry value */
  readonly _st_within?: InputMaybe<Scalars['geometry']['input']>;
};

export type GroupOfStopPlacesAlternativeNamesAggregateBoolExp = {
  readonly count?: InputMaybe<GroupOfStopPlacesAlternativeNamesAggregateBoolExpCount>;
};

export type GroupOfStopPlacesAlternativeNamesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNamesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type GroupOfStopPlacesKeyValuesAggregateBoolExp = {
  readonly count?: InputMaybe<GroupOfStopPlacesKeyValuesAggregateBoolExpCount>;
};

export type GroupOfStopPlacesKeyValuesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValuesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type GroupOfStopPlacesMembersAggregateBoolExp = {
  readonly count?: InputMaybe<GroupOfStopPlacesMembersAggregateBoolExpCount>;
};

export type GroupOfStopPlacesMembersAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembersSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type GroupOfTariffZonesKeyValuesAggregateBoolExp = {
  readonly count?: InputMaybe<GroupOfTariffZonesKeyValuesAggregateBoolExpCount>;
};

export type GroupOfTariffZonesKeyValuesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValuesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type GroupOfTariffZonesMembersAggregateBoolExp = {
  readonly count?: InputMaybe<GroupOfTariffZonesMembersAggregateBoolExpCount>;
};

export type GroupOfTariffZonesMembersAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembersSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersBoolExp>;
  readonly predicate: IntComparisonExp;
};

/** Legacy, avoid using. Main use nowadays is to enable support for eg. data exports that still need this. Originally this was used to represent the primary region for routes/lines. */
export type HslRouteLegacyHslMunicipalityCode = {
  readonly __typename?: 'hsl_route_legacy_hsl_municipality_code';
  readonly hsl_municipality: Scalars['String']['output'];
  readonly jore3_code: Scalars['smallint']['output'];
  /** An array relationship */
  readonly lines: ReadonlyArray<RouteLine>;
  /** An aggregate relationship */
  readonly lines_aggregate: RouteLineAggregate;
  /** An array relationship */
  readonly routes: ReadonlyArray<RouteRoute>;
  /** An aggregate relationship */
  readonly routes_aggregate: RouteRouteAggregate;
};


/** Legacy, avoid using. Main use nowadays is to enable support for eg. data exports that still need this. Originally this was used to represent the primary region for routes/lines. */
export type HslRouteLegacyHslMunicipalityCodeLinesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteLineOrderBy>>;
  where?: InputMaybe<RouteLineBoolExp>;
};


/** Legacy, avoid using. Main use nowadays is to enable support for eg. data exports that still need this. Originally this was used to represent the primary region for routes/lines. */
export type HslRouteLegacyHslMunicipalityCodeLinesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteLineOrderBy>>;
  where?: InputMaybe<RouteLineBoolExp>;
};


/** Legacy, avoid using. Main use nowadays is to enable support for eg. data exports that still need this. Originally this was used to represent the primary region for routes/lines. */
export type HslRouteLegacyHslMunicipalityCodeRoutesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteRouteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteRouteOrderBy>>;
  where?: InputMaybe<RouteRouteBoolExp>;
};


/** Legacy, avoid using. Main use nowadays is to enable support for eg. data exports that still need this. Originally this was used to represent the primary region for routes/lines. */
export type HslRouteLegacyHslMunicipalityCodeRoutesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteRouteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteRouteOrderBy>>;
  where?: InputMaybe<RouteRouteBoolExp>;
};

/** aggregated selection of "hsl_route.legacy_hsl_municipality_code" */
export type HslRouteLegacyHslMunicipalityCodeAggregate = {
  readonly __typename?: 'hsl_route_legacy_hsl_municipality_code_aggregate';
  readonly aggregate?: Maybe<HslRouteLegacyHslMunicipalityCodeAggregateFields>;
  readonly nodes: ReadonlyArray<HslRouteLegacyHslMunicipalityCode>;
};

/** aggregate fields of "hsl_route.legacy_hsl_municipality_code" */
export type HslRouteLegacyHslMunicipalityCodeAggregateFields = {
  readonly __typename?: 'hsl_route_legacy_hsl_municipality_code_aggregate_fields';
  readonly avg?: Maybe<HslRouteLegacyHslMunicipalityCodeAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<HslRouteLegacyHslMunicipalityCodeMaxFields>;
  readonly min?: Maybe<HslRouteLegacyHslMunicipalityCodeMinFields>;
  readonly stddev?: Maybe<HslRouteLegacyHslMunicipalityCodeStddevFields>;
  readonly stddev_pop?: Maybe<HslRouteLegacyHslMunicipalityCodeStddevPopFields>;
  readonly stddev_samp?: Maybe<HslRouteLegacyHslMunicipalityCodeStddevSampFields>;
  readonly sum?: Maybe<HslRouteLegacyHslMunicipalityCodeSumFields>;
  readonly var_pop?: Maybe<HslRouteLegacyHslMunicipalityCodeVarPopFields>;
  readonly var_samp?: Maybe<HslRouteLegacyHslMunicipalityCodeVarSampFields>;
  readonly variance?: Maybe<HslRouteLegacyHslMunicipalityCodeVarianceFields>;
};


/** aggregate fields of "hsl_route.legacy_hsl_municipality_code" */
export type HslRouteLegacyHslMunicipalityCodeAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<HslRouteLegacyHslMunicipalityCodeSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type HslRouteLegacyHslMunicipalityCodeAvgFields = {
  readonly __typename?: 'hsl_route_legacy_hsl_municipality_code_avg_fields';
  readonly jore3_code?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "hsl_route.legacy_hsl_municipality_code". All fields are combined with a logical 'AND'. */
export type HslRouteLegacyHslMunicipalityCodeBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<HslRouteLegacyHslMunicipalityCodeBoolExp>>;
  readonly _not?: InputMaybe<HslRouteLegacyHslMunicipalityCodeBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<HslRouteLegacyHslMunicipalityCodeBoolExp>>;
  readonly hsl_municipality?: InputMaybe<StringComparisonExp>;
  readonly jore3_code?: InputMaybe<SmallintComparisonExp>;
  readonly lines?: InputMaybe<RouteLineBoolExp>;
  readonly lines_aggregate?: InputMaybe<RouteLineAggregateBoolExp>;
  readonly routes?: InputMaybe<RouteRouteBoolExp>;
  readonly routes_aggregate?: InputMaybe<RouteRouteAggregateBoolExp>;
};

/** unique or primary key constraints on table "hsl_route.legacy_hsl_municipality_code" */
export enum HslRouteLegacyHslMunicipalityCodeConstraint {
  /** unique or primary key constraint on columns "hsl_municipality" */
  LegacyHslMunicipalityCodePkey = 'legacy_hsl_municipality_code_pkey'
}

/** input type for incrementing numeric columns in table "hsl_route.legacy_hsl_municipality_code" */
export type HslRouteLegacyHslMunicipalityCodeIncInput = {
  readonly jore3_code?: InputMaybe<Scalars['smallint']['input']>;
};

/** input type for inserting data into table "hsl_route.legacy_hsl_municipality_code" */
export type HslRouteLegacyHslMunicipalityCodeInsertInput = {
  readonly hsl_municipality?: InputMaybe<Scalars['String']['input']>;
  readonly jore3_code?: InputMaybe<Scalars['smallint']['input']>;
  readonly lines?: InputMaybe<RouteLineArrRelInsertInput>;
  readonly routes?: InputMaybe<RouteRouteArrRelInsertInput>;
};

/** aggregate max on columns */
export type HslRouteLegacyHslMunicipalityCodeMaxFields = {
  readonly __typename?: 'hsl_route_legacy_hsl_municipality_code_max_fields';
  readonly hsl_municipality?: Maybe<Scalars['String']['output']>;
  readonly jore3_code?: Maybe<Scalars['smallint']['output']>;
};

/** aggregate min on columns */
export type HslRouteLegacyHslMunicipalityCodeMinFields = {
  readonly __typename?: 'hsl_route_legacy_hsl_municipality_code_min_fields';
  readonly hsl_municipality?: Maybe<Scalars['String']['output']>;
  readonly jore3_code?: Maybe<Scalars['smallint']['output']>;
};

/** response of any mutation on the table "hsl_route.legacy_hsl_municipality_code" */
export type HslRouteLegacyHslMunicipalityCodeMutationResponse = {
  readonly __typename?: 'hsl_route_legacy_hsl_municipality_code_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<HslRouteLegacyHslMunicipalityCode>;
};

/** input type for inserting object relation for remote table "hsl_route.legacy_hsl_municipality_code" */
export type HslRouteLegacyHslMunicipalityCodeObjRelInsertInput = {
  readonly data: HslRouteLegacyHslMunicipalityCodeInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<HslRouteLegacyHslMunicipalityCodeOnConflict>;
};

/** on_conflict condition type for table "hsl_route.legacy_hsl_municipality_code" */
export type HslRouteLegacyHslMunicipalityCodeOnConflict = {
  readonly constraint: HslRouteLegacyHslMunicipalityCodeConstraint;
  readonly update_columns?: ReadonlyArray<HslRouteLegacyHslMunicipalityCodeUpdateColumn>;
  readonly where?: InputMaybe<HslRouteLegacyHslMunicipalityCodeBoolExp>;
};

/** Ordering options when selecting data from "hsl_route.legacy_hsl_municipality_code". */
export type HslRouteLegacyHslMunicipalityCodeOrderBy = {
  readonly hsl_municipality?: InputMaybe<OrderBy>;
  readonly jore3_code?: InputMaybe<OrderBy>;
  readonly lines_aggregate?: InputMaybe<RouteLineAggregateOrderBy>;
  readonly routes_aggregate?: InputMaybe<RouteRouteAggregateOrderBy>;
};

/** primary key columns input for table: hsl_route.legacy_hsl_municipality_code */
export type HslRouteLegacyHslMunicipalityCodePkColumnsInput = {
  readonly hsl_municipality: Scalars['String']['input'];
};

/** select columns of table "hsl_route.legacy_hsl_municipality_code" */
export enum HslRouteLegacyHslMunicipalityCodeSelectColumn {
  /** column name */
  HslMunicipality = 'hsl_municipality',
  /** column name */
  Jore3Code = 'jore3_code'
}

/** input type for updating data in table "hsl_route.legacy_hsl_municipality_code" */
export type HslRouteLegacyHslMunicipalityCodeSetInput = {
  readonly hsl_municipality?: InputMaybe<Scalars['String']['input']>;
  readonly jore3_code?: InputMaybe<Scalars['smallint']['input']>;
};

/** aggregate stddev on columns */
export type HslRouteLegacyHslMunicipalityCodeStddevFields = {
  readonly __typename?: 'hsl_route_legacy_hsl_municipality_code_stddev_fields';
  readonly jore3_code?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type HslRouteLegacyHslMunicipalityCodeStddevPopFields = {
  readonly __typename?: 'hsl_route_legacy_hsl_municipality_code_stddev_pop_fields';
  readonly jore3_code?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type HslRouteLegacyHslMunicipalityCodeStddevSampFields = {
  readonly __typename?: 'hsl_route_legacy_hsl_municipality_code_stddev_samp_fields';
  readonly jore3_code?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "hsl_route_legacy_hsl_municipality_code" */
export type HslRouteLegacyHslMunicipalityCodeStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: HslRouteLegacyHslMunicipalityCodeStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type HslRouteLegacyHslMunicipalityCodeStreamCursorValueInput = {
  readonly hsl_municipality?: InputMaybe<Scalars['String']['input']>;
  readonly jore3_code?: InputMaybe<Scalars['smallint']['input']>;
};

/** aggregate sum on columns */
export type HslRouteLegacyHslMunicipalityCodeSumFields = {
  readonly __typename?: 'hsl_route_legacy_hsl_municipality_code_sum_fields';
  readonly jore3_code?: Maybe<Scalars['smallint']['output']>;
};

/** update columns of table "hsl_route.legacy_hsl_municipality_code" */
export enum HslRouteLegacyHslMunicipalityCodeUpdateColumn {
  /** column name */
  HslMunicipality = 'hsl_municipality',
  /** column name */
  Jore3Code = 'jore3_code'
}

export type HslRouteLegacyHslMunicipalityCodeUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<HslRouteLegacyHslMunicipalityCodeIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<HslRouteLegacyHslMunicipalityCodeSetInput>;
  /** filter the rows which have to be updated */
  readonly where: HslRouteLegacyHslMunicipalityCodeBoolExp;
};

/** aggregate var_pop on columns */
export type HslRouteLegacyHslMunicipalityCodeVarPopFields = {
  readonly __typename?: 'hsl_route_legacy_hsl_municipality_code_var_pop_fields';
  readonly jore3_code?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type HslRouteLegacyHslMunicipalityCodeVarSampFields = {
  readonly __typename?: 'hsl_route_legacy_hsl_municipality_code_var_samp_fields';
  readonly jore3_code?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type HslRouteLegacyHslMunicipalityCodeVarianceFields = {
  readonly __typename?: 'hsl_route_legacy_hsl_municipality_code_variance_fields';
  readonly jore3_code?: Maybe<Scalars['Float']['output']>;
};

/** Transport target, can be used e.g. for cost sharing. */
export type HslRouteTransportTarget = {
  readonly __typename?: 'hsl_route_transport_target';
  /** An array relationship */
  readonly lines: ReadonlyArray<RouteLine>;
  /** An aggregate relationship */
  readonly lines_aggregate: RouteLineAggregate;
  readonly transport_target: Scalars['String']['output'];
};


/** Transport target, can be used e.g. for cost sharing. */
export type HslRouteTransportTargetLinesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteLineOrderBy>>;
  where?: InputMaybe<RouteLineBoolExp>;
};


/** Transport target, can be used e.g. for cost sharing. */
export type HslRouteTransportTargetLinesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteLineOrderBy>>;
  where?: InputMaybe<RouteLineBoolExp>;
};

/** aggregated selection of "hsl_route.transport_target" */
export type HslRouteTransportTargetAggregate = {
  readonly __typename?: 'hsl_route_transport_target_aggregate';
  readonly aggregate?: Maybe<HslRouteTransportTargetAggregateFields>;
  readonly nodes: ReadonlyArray<HslRouteTransportTarget>;
};

/** aggregate fields of "hsl_route.transport_target" */
export type HslRouteTransportTargetAggregateFields = {
  readonly __typename?: 'hsl_route_transport_target_aggregate_fields';
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<HslRouteTransportTargetMaxFields>;
  readonly min?: Maybe<HslRouteTransportTargetMinFields>;
};


/** aggregate fields of "hsl_route.transport_target" */
export type HslRouteTransportTargetAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<HslRouteTransportTargetSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "hsl_route.transport_target". All fields are combined with a logical 'AND'. */
export type HslRouteTransportTargetBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<HslRouteTransportTargetBoolExp>>;
  readonly _not?: InputMaybe<HslRouteTransportTargetBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<HslRouteTransportTargetBoolExp>>;
  readonly lines?: InputMaybe<RouteLineBoolExp>;
  readonly lines_aggregate?: InputMaybe<RouteLineAggregateBoolExp>;
  readonly transport_target?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "hsl_route.transport_target" */
export enum HslRouteTransportTargetConstraint {
  /** unique or primary key constraint on columns "transport_target" */
  TransportTargetPkey = 'transport_target_pkey'
}

export enum HslRouteTransportTargetEnum {
  EspooAndKauniainenInternalTraffic = 'espoo_and_kauniainen_internal_traffic',
  EspooRegionalTraffic = 'espoo_regional_traffic',
  HelsinkiInternalTraffic = 'helsinki_internal_traffic',
  KeravaInternalTraffic = 'kerava_internal_traffic',
  KeravaRegionalTraffic = 'kerava_regional_traffic',
  KirkkonummiInternalTraffic = 'kirkkonummi_internal_traffic',
  KirkkonummiRegionalTraffic = 'kirkkonummi_regional_traffic',
  SipooInternalTraffic = 'sipoo_internal_traffic',
  SiuntioInternalTraffic = 'siuntio_internal_traffic',
  SiuntioRegionalTraffic = 'siuntio_regional_traffic',
  TransverseRegional = 'transverse_regional',
  TuusulaInternalTraffic = 'tuusula_internal_traffic',
  TuusulaRegionalTraffic = 'tuusula_regional_traffic',
  VantaaInternalTraffic = 'vantaa_internal_traffic',
  VantaaRegionalTraffic = 'vantaa_regional_traffic'
}

/** Boolean expression to compare columns of type "hsl_route_transport_target_enum". All fields are combined with logical 'AND'. */
export type HslRouteTransportTargetEnumComparisonExp = {
  readonly _eq?: InputMaybe<HslRouteTransportTargetEnum>;
  readonly _in?: InputMaybe<ReadonlyArray<HslRouteTransportTargetEnum>>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _neq?: InputMaybe<HslRouteTransportTargetEnum>;
  readonly _nin?: InputMaybe<ReadonlyArray<HslRouteTransportTargetEnum>>;
};

/** input type for inserting data into table "hsl_route.transport_target" */
export type HslRouteTransportTargetInsertInput = {
  readonly lines?: InputMaybe<RouteLineArrRelInsertInput>;
  readonly transport_target?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type HslRouteTransportTargetMaxFields = {
  readonly __typename?: 'hsl_route_transport_target_max_fields';
  readonly transport_target?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type HslRouteTransportTargetMinFields = {
  readonly __typename?: 'hsl_route_transport_target_min_fields';
  readonly transport_target?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "hsl_route.transport_target" */
export type HslRouteTransportTargetMutationResponse = {
  readonly __typename?: 'hsl_route_transport_target_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<HslRouteTransportTarget>;
};

/** input type for inserting object relation for remote table "hsl_route.transport_target" */
export type HslRouteTransportTargetObjRelInsertInput = {
  readonly data: HslRouteTransportTargetInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<HslRouteTransportTargetOnConflict>;
};

/** on_conflict condition type for table "hsl_route.transport_target" */
export type HslRouteTransportTargetOnConflict = {
  readonly constraint: HslRouteTransportTargetConstraint;
  readonly update_columns?: ReadonlyArray<HslRouteTransportTargetUpdateColumn>;
  readonly where?: InputMaybe<HslRouteTransportTargetBoolExp>;
};

/** Ordering options when selecting data from "hsl_route.transport_target". */
export type HslRouteTransportTargetOrderBy = {
  readonly lines_aggregate?: InputMaybe<RouteLineAggregateOrderBy>;
  readonly transport_target?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: hsl_route.transport_target */
export type HslRouteTransportTargetPkColumnsInput = {
  readonly transport_target: Scalars['String']['input'];
};

/** select columns of table "hsl_route.transport_target" */
export enum HslRouteTransportTargetSelectColumn {
  /** column name */
  TransportTarget = 'transport_target'
}

/** input type for updating data in table "hsl_route.transport_target" */
export type HslRouteTransportTargetSetInput = {
  readonly transport_target?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "hsl_route_transport_target" */
export type HslRouteTransportTargetStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: HslRouteTransportTargetStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type HslRouteTransportTargetStreamCursorValueInput = {
  readonly transport_target?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "hsl_route.transport_target" */
export enum HslRouteTransportTargetUpdateColumn {
  /** column name */
  TransportTarget = 'transport_target'
}

export type HslRouteTransportTargetUpdates = {
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<HslRouteTransportTargetSetInput>;
  /** filter the rows which have to be updated */
  readonly where: HslRouteTransportTargetBoolExp;
};

/** The direction in which an e.g. infrastructure link can be traversed */
export type InfrastructureNetworkDirection = {
  readonly __typename?: 'infrastructure_network_direction';
  /** An array relationship */
  readonly infrastructure_links: ReadonlyArray<InfrastructureNetworkInfrastructureLink>;
  /** An aggregate relationship */
  readonly infrastructure_links_aggregate: InfrastructureNetworkInfrastructureLinkAggregate;
  readonly value: InfrastructureNetworkDirectionEnum;
};


/** The direction in which an e.g. infrastructure link can be traversed */
export type InfrastructureNetworkDirectionInfrastructureLinksArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
};


/** The direction in which an e.g. infrastructure link can be traversed */
export type InfrastructureNetworkDirectionInfrastructureLinksAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
};

/** aggregated selection of "infrastructure_network.direction" */
export type InfrastructureNetworkDirectionAggregate = {
  readonly __typename?: 'infrastructure_network_direction_aggregate';
  readonly aggregate?: Maybe<InfrastructureNetworkDirectionAggregateFields>;
  readonly nodes: ReadonlyArray<InfrastructureNetworkDirection>;
};

/** aggregate fields of "infrastructure_network.direction" */
export type InfrastructureNetworkDirectionAggregateFields = {
  readonly __typename?: 'infrastructure_network_direction_aggregate_fields';
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<InfrastructureNetworkDirectionMaxFields>;
  readonly min?: Maybe<InfrastructureNetworkDirectionMinFields>;
};


/** aggregate fields of "infrastructure_network.direction" */
export type InfrastructureNetworkDirectionAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<InfrastructureNetworkDirectionSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "infrastructure_network.direction". All fields are combined with a logical 'AND'. */
export type InfrastructureNetworkDirectionBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<InfrastructureNetworkDirectionBoolExp>>;
  readonly _not?: InputMaybe<InfrastructureNetworkDirectionBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<InfrastructureNetworkDirectionBoolExp>>;
  readonly infrastructure_links?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  readonly infrastructure_links_aggregate?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateBoolExp>;
  readonly value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "infrastructure_network.direction" */
export enum InfrastructureNetworkDirectionConstraint {
  /** unique or primary key constraint on columns "value" */
  DirectionPkey = 'direction_pkey'
}

export enum InfrastructureNetworkDirectionEnum {
  Backward = 'backward',
  Bidirectional = 'bidirectional',
  Forward = 'forward'
}

/** Boolean expression to compare columns of type "infrastructure_network_direction_enum". All fields are combined with logical 'AND'. */
export type InfrastructureNetworkDirectionEnumComparisonExp = {
  readonly _eq?: InputMaybe<InfrastructureNetworkDirectionEnum>;
  readonly _in?: InputMaybe<ReadonlyArray<InfrastructureNetworkDirectionEnum>>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _neq?: InputMaybe<InfrastructureNetworkDirectionEnum>;
  readonly _nin?: InputMaybe<ReadonlyArray<InfrastructureNetworkDirectionEnum>>;
};

/** input type for inserting data into table "infrastructure_network.direction" */
export type InfrastructureNetworkDirectionInsertInput = {
  readonly infrastructure_links?: InputMaybe<InfrastructureNetworkInfrastructureLinkArrRelInsertInput>;
  readonly value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type InfrastructureNetworkDirectionMaxFields = {
  readonly __typename?: 'infrastructure_network_direction_max_fields';
  readonly value?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type InfrastructureNetworkDirectionMinFields = {
  readonly __typename?: 'infrastructure_network_direction_min_fields';
  readonly value?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "infrastructure_network.direction" */
export type InfrastructureNetworkDirectionMutationResponse = {
  readonly __typename?: 'infrastructure_network_direction_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<InfrastructureNetworkDirection>;
};

/** input type for inserting object relation for remote table "infrastructure_network.direction" */
export type InfrastructureNetworkDirectionObjRelInsertInput = {
  readonly data: InfrastructureNetworkDirectionInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<InfrastructureNetworkDirectionOnConflict>;
};

/** on_conflict condition type for table "infrastructure_network.direction" */
export type InfrastructureNetworkDirectionOnConflict = {
  readonly constraint: InfrastructureNetworkDirectionConstraint;
  readonly update_columns?: ReadonlyArray<InfrastructureNetworkDirectionUpdateColumn>;
  readonly where?: InputMaybe<InfrastructureNetworkDirectionBoolExp>;
};

/** Ordering options when selecting data from "infrastructure_network.direction". */
export type InfrastructureNetworkDirectionOrderBy = {
  readonly infrastructure_links_aggregate?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateOrderBy>;
  readonly value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: infrastructure_network.direction */
export type InfrastructureNetworkDirectionPkColumnsInput = {
  readonly value: Scalars['String']['input'];
};

/** select columns of table "infrastructure_network.direction" */
export enum InfrastructureNetworkDirectionSelectColumn {
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "infrastructure_network.direction" */
export type InfrastructureNetworkDirectionSetInput = {
  readonly value?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "infrastructure_network_direction" */
export type InfrastructureNetworkDirectionStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: InfrastructureNetworkDirectionStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type InfrastructureNetworkDirectionStreamCursorValueInput = {
  readonly value?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "infrastructure_network.direction" */
export enum InfrastructureNetworkDirectionUpdateColumn {
  /** column name */
  Value = 'value'
}

export type InfrastructureNetworkDirectionUpdates = {
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<InfrastructureNetworkDirectionSetInput>;
  /** filter the rows which have to be updated */
  readonly where: InfrastructureNetworkDirectionBoolExp;
};

/** An external source from which infrastructure network parts are imported */
export type InfrastructureNetworkExternalSource = {
  readonly __typename?: 'infrastructure_network_external_source';
  /** An array relationship */
  readonly infrastructure_links: ReadonlyArray<InfrastructureNetworkInfrastructureLink>;
  /** An aggregate relationship */
  readonly infrastructure_links_aggregate: InfrastructureNetworkInfrastructureLinkAggregate;
  readonly value: Scalars['String']['output'];
};


/** An external source from which infrastructure network parts are imported */
export type InfrastructureNetworkExternalSourceInfrastructureLinksArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
};


/** An external source from which infrastructure network parts are imported */
export type InfrastructureNetworkExternalSourceInfrastructureLinksAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
};

/** aggregated selection of "infrastructure_network.external_source" */
export type InfrastructureNetworkExternalSourceAggregate = {
  readonly __typename?: 'infrastructure_network_external_source_aggregate';
  readonly aggregate?: Maybe<InfrastructureNetworkExternalSourceAggregateFields>;
  readonly nodes: ReadonlyArray<InfrastructureNetworkExternalSource>;
};

/** aggregate fields of "infrastructure_network.external_source" */
export type InfrastructureNetworkExternalSourceAggregateFields = {
  readonly __typename?: 'infrastructure_network_external_source_aggregate_fields';
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<InfrastructureNetworkExternalSourceMaxFields>;
  readonly min?: Maybe<InfrastructureNetworkExternalSourceMinFields>;
};


/** aggregate fields of "infrastructure_network.external_source" */
export type InfrastructureNetworkExternalSourceAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<InfrastructureNetworkExternalSourceSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "infrastructure_network.external_source". All fields are combined with a logical 'AND'. */
export type InfrastructureNetworkExternalSourceBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<InfrastructureNetworkExternalSourceBoolExp>>;
  readonly _not?: InputMaybe<InfrastructureNetworkExternalSourceBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<InfrastructureNetworkExternalSourceBoolExp>>;
  readonly infrastructure_links?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  readonly infrastructure_links_aggregate?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateBoolExp>;
  readonly value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "infrastructure_network.external_source" */
export enum InfrastructureNetworkExternalSourceConstraint {
  /** unique or primary key constraint on columns "value" */
  ExternalSourcePkey = 'external_source_pkey'
}

export enum InfrastructureNetworkExternalSourceEnum {
  DigiroadR = 'digiroad_r',
  HslFixup = 'hsl_fixup'
}

/** Boolean expression to compare columns of type "infrastructure_network_external_source_enum". All fields are combined with logical 'AND'. */
export type InfrastructureNetworkExternalSourceEnumComparisonExp = {
  readonly _eq?: InputMaybe<InfrastructureNetworkExternalSourceEnum>;
  readonly _in?: InputMaybe<ReadonlyArray<InfrastructureNetworkExternalSourceEnum>>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _neq?: InputMaybe<InfrastructureNetworkExternalSourceEnum>;
  readonly _nin?: InputMaybe<ReadonlyArray<InfrastructureNetworkExternalSourceEnum>>;
};

/** input type for inserting data into table "infrastructure_network.external_source" */
export type InfrastructureNetworkExternalSourceInsertInput = {
  readonly infrastructure_links?: InputMaybe<InfrastructureNetworkInfrastructureLinkArrRelInsertInput>;
  readonly value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type InfrastructureNetworkExternalSourceMaxFields = {
  readonly __typename?: 'infrastructure_network_external_source_max_fields';
  readonly value?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type InfrastructureNetworkExternalSourceMinFields = {
  readonly __typename?: 'infrastructure_network_external_source_min_fields';
  readonly value?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "infrastructure_network.external_source" */
export type InfrastructureNetworkExternalSourceMutationResponse = {
  readonly __typename?: 'infrastructure_network_external_source_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<InfrastructureNetworkExternalSource>;
};

/** input type for inserting object relation for remote table "infrastructure_network.external_source" */
export type InfrastructureNetworkExternalSourceObjRelInsertInput = {
  readonly data: InfrastructureNetworkExternalSourceInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<InfrastructureNetworkExternalSourceOnConflict>;
};

/** on_conflict condition type for table "infrastructure_network.external_source" */
export type InfrastructureNetworkExternalSourceOnConflict = {
  readonly constraint: InfrastructureNetworkExternalSourceConstraint;
  readonly update_columns?: ReadonlyArray<InfrastructureNetworkExternalSourceUpdateColumn>;
  readonly where?: InputMaybe<InfrastructureNetworkExternalSourceBoolExp>;
};

/** Ordering options when selecting data from "infrastructure_network.external_source". */
export type InfrastructureNetworkExternalSourceOrderBy = {
  readonly infrastructure_links_aggregate?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateOrderBy>;
  readonly value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: infrastructure_network.external_source */
export type InfrastructureNetworkExternalSourcePkColumnsInput = {
  readonly value: Scalars['String']['input'];
};

/** select columns of table "infrastructure_network.external_source" */
export enum InfrastructureNetworkExternalSourceSelectColumn {
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "infrastructure_network.external_source" */
export type InfrastructureNetworkExternalSourceSetInput = {
  readonly value?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "infrastructure_network_external_source" */
export type InfrastructureNetworkExternalSourceStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: InfrastructureNetworkExternalSourceStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type InfrastructureNetworkExternalSourceStreamCursorValueInput = {
  readonly value?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "infrastructure_network.external_source" */
export enum InfrastructureNetworkExternalSourceUpdateColumn {
  /** column name */
  Value = 'value'
}

export type InfrastructureNetworkExternalSourceUpdates = {
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<InfrastructureNetworkExternalSourceSetInput>;
  /** filter the rows which have to be updated */
  readonly where: InfrastructureNetworkExternalSourceBoolExp;
};

export type InfrastructureNetworkFindPointDirectionOnLinkArgs = {
  readonly infrastructure_link_uuid?: InputMaybe<Scalars['uuid']['input']>;
  readonly point_max_distance_in_meters?: InputMaybe<Scalars['float8']['input']>;
  readonly point_of_interest?: InputMaybe<Scalars['geography']['input']>;
};

/** The infrastructure links, e.g. road or rail elements: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:1:1:453 */
export type InfrastructureNetworkInfrastructureLink = {
  readonly __typename?: 'infrastructure_network_infrastructure_link';
  /** The direction(s) of traffic with respect to the digitization, i.e. the direction of the specified line string. */
  readonly direction: InfrastructureNetworkDirectionEnum;
  /** An object relationship */
  readonly directionByDirection: InfrastructureNetworkDirection;
  /** The estimated length of the infrastructure link in metres. */
  readonly estimated_length_in_metres?: Maybe<Scalars['float8']['output']>;
  readonly external_link_id: Scalars['String']['output'];
  readonly external_link_source: InfrastructureNetworkExternalSourceEnum;
  /** An object relationship */
  readonly external_source: InfrastructureNetworkExternalSource;
  /** An array relationship */
  readonly infrastructure_link_along_routes: ReadonlyArray<RouteInfrastructureLinkAlongRoute>;
  /** An aggregate relationship */
  readonly infrastructure_link_along_routes_aggregate: RouteInfrastructureLinkAlongRouteAggregate;
  /** The ID of the infrastructure link. */
  readonly infrastructure_link_id: Scalars['uuid']['output'];
  /** An array relationship */
  readonly scheduled_stop_points_located_on_infrastructure_link: ReadonlyArray<ServicePatternScheduledStopPoint>;
  /** An aggregate relationship */
  readonly scheduled_stop_points_located_on_infrastructure_link_aggregate: ServicePatternScheduledStopPointAggregate;
  /** A PostGIS LinestringZ geography in EPSG:4326 describing the infrastructure link. */
  readonly shape: Scalars['geography_linestring']['output'];
  /** An array relationship */
  readonly vehicle_submode_on_infrastructure_link: ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
  /** An aggregate relationship */
  readonly vehicle_submode_on_infrastructure_link_aggregate: InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregate;
  /** An array relationship */
  readonly vehicle_submode_on_infrastructure_links: ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
  /** An aggregate relationship */
  readonly vehicle_submode_on_infrastructure_links_aggregate: InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregate;
};


/** The infrastructure links, e.g. road or rail elements: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:1:1:453 */
export type InfrastructureNetworkInfrastructureLinkInfrastructureLinkAlongRoutesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteInfrastructureLinkAlongRouteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteInfrastructureLinkAlongRouteOrderBy>>;
  where?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
};


/** The infrastructure links, e.g. road or rail elements: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:1:1:453 */
export type InfrastructureNetworkInfrastructureLinkInfrastructureLinkAlongRoutesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteInfrastructureLinkAlongRouteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteInfrastructureLinkAlongRouteOrderBy>>;
  where?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
};


/** The infrastructure links, e.g. road or rail elements: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:1:1:453 */
export type InfrastructureNetworkInfrastructureLinkScheduledStopPointsLocatedOnInfrastructureLinkArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};


/** The infrastructure links, e.g. road or rail elements: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:1:1:453 */
export type InfrastructureNetworkInfrastructureLinkScheduledStopPointsLocatedOnInfrastructureLinkAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};


/** The infrastructure links, e.g. road or rail elements: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:1:1:453 */
export type InfrastructureNetworkInfrastructureLinkVehicleSubmodeOnInfrastructureLinkArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
};


/** The infrastructure links, e.g. road or rail elements: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:1:1:453 */
export type InfrastructureNetworkInfrastructureLinkVehicleSubmodeOnInfrastructureLinkAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
};


/** The infrastructure links, e.g. road or rail elements: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:1:1:453 */
export type InfrastructureNetworkInfrastructureLinkVehicleSubmodeOnInfrastructureLinksArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
};


/** The infrastructure links, e.g. road or rail elements: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:1:1:453 */
export type InfrastructureNetworkInfrastructureLinkVehicleSubmodeOnInfrastructureLinksAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
};

/** aggregated selection of "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkAggregate = {
  readonly __typename?: 'infrastructure_network_infrastructure_link_aggregate';
  readonly aggregate?: Maybe<InfrastructureNetworkInfrastructureLinkAggregateFields>;
  readonly nodes: ReadonlyArray<InfrastructureNetworkInfrastructureLink>;
};

export type InfrastructureNetworkInfrastructureLinkAggregateBoolExp = {
  readonly avg?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateBoolExpAvg>;
  readonly corr?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateBoolExpCorr>;
  readonly count?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateBoolExpCount>;
  readonly covar_samp?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateBoolExpCovarSamp>;
  readonly max?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateBoolExpMax>;
  readonly min?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateBoolExpMin>;
  readonly stddev_samp?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateBoolExpStddevSamp>;
  readonly sum?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateBoolExpSum>;
  readonly var_samp?: InputMaybe<InfrastructureNetworkInfrastructureLinkAggregateBoolExpVarSamp>;
};

export type InfrastructureNetworkInfrastructureLinkAggregateBoolExpAvg = {
  readonly arguments: InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpAvgArgumentsColumns;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  readonly predicate: Float8ComparisonExp;
};

export type InfrastructureNetworkInfrastructureLinkAggregateBoolExpCorr = {
  readonly arguments: InfrastructureNetworkInfrastructureLinkAggregateBoolExpCorrArguments;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  readonly predicate: Float8ComparisonExp;
};

export type InfrastructureNetworkInfrastructureLinkAggregateBoolExpCorrArguments = {
  readonly X: InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpCorrArgumentsColumns;
  readonly Y: InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpCorrArgumentsColumns;
};

export type InfrastructureNetworkInfrastructureLinkAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type InfrastructureNetworkInfrastructureLinkAggregateBoolExpCovarSamp = {
  readonly arguments: InfrastructureNetworkInfrastructureLinkAggregateBoolExpCovarSampArguments;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  readonly predicate: Float8ComparisonExp;
};

export type InfrastructureNetworkInfrastructureLinkAggregateBoolExpCovarSampArguments = {
  readonly X: InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpCovarSampArgumentsColumns;
  readonly Y: InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpCovarSampArgumentsColumns;
};

export type InfrastructureNetworkInfrastructureLinkAggregateBoolExpMax = {
  readonly arguments: InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpMaxArgumentsColumns;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  readonly predicate: Float8ComparisonExp;
};

export type InfrastructureNetworkInfrastructureLinkAggregateBoolExpMin = {
  readonly arguments: InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpMinArgumentsColumns;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  readonly predicate: Float8ComparisonExp;
};

export type InfrastructureNetworkInfrastructureLinkAggregateBoolExpStddevSamp = {
  readonly arguments: InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpStddevSampArgumentsColumns;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  readonly predicate: Float8ComparisonExp;
};

export type InfrastructureNetworkInfrastructureLinkAggregateBoolExpSum = {
  readonly arguments: InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpSumArgumentsColumns;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  readonly predicate: Float8ComparisonExp;
};

export type InfrastructureNetworkInfrastructureLinkAggregateBoolExpVarSamp = {
  readonly arguments: InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpVarSampArgumentsColumns;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  readonly predicate: Float8ComparisonExp;
};

/** aggregate fields of "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkAggregateFields = {
  readonly __typename?: 'infrastructure_network_infrastructure_link_aggregate_fields';
  readonly avg?: Maybe<InfrastructureNetworkInfrastructureLinkAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<InfrastructureNetworkInfrastructureLinkMaxFields>;
  readonly min?: Maybe<InfrastructureNetworkInfrastructureLinkMinFields>;
  readonly stddev?: Maybe<InfrastructureNetworkInfrastructureLinkStddevFields>;
  readonly stddev_pop?: Maybe<InfrastructureNetworkInfrastructureLinkStddevPopFields>;
  readonly stddev_samp?: Maybe<InfrastructureNetworkInfrastructureLinkStddevSampFields>;
  readonly sum?: Maybe<InfrastructureNetworkInfrastructureLinkSumFields>;
  readonly var_pop?: Maybe<InfrastructureNetworkInfrastructureLinkVarPopFields>;
  readonly var_samp?: Maybe<InfrastructureNetworkInfrastructureLinkVarSampFields>;
  readonly variance?: Maybe<InfrastructureNetworkInfrastructureLinkVarianceFields>;
};


/** aggregate fields of "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkAggregateOrderBy = {
  readonly avg?: InputMaybe<InfrastructureNetworkInfrastructureLinkAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<InfrastructureNetworkInfrastructureLinkMaxOrderBy>;
  readonly min?: InputMaybe<InfrastructureNetworkInfrastructureLinkMinOrderBy>;
  readonly stddev?: InputMaybe<InfrastructureNetworkInfrastructureLinkStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<InfrastructureNetworkInfrastructureLinkStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<InfrastructureNetworkInfrastructureLinkStddevSampOrderBy>;
  readonly sum?: InputMaybe<InfrastructureNetworkInfrastructureLinkSumOrderBy>;
  readonly var_pop?: InputMaybe<InfrastructureNetworkInfrastructureLinkVarPopOrderBy>;
  readonly var_samp?: InputMaybe<InfrastructureNetworkInfrastructureLinkVarSampOrderBy>;
  readonly variance?: InputMaybe<InfrastructureNetworkInfrastructureLinkVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkArrRelInsertInput = {
  readonly data: ReadonlyArray<InfrastructureNetworkInfrastructureLinkInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<InfrastructureNetworkInfrastructureLinkOnConflict>;
};

/** aggregate avg on columns */
export type InfrastructureNetworkInfrastructureLinkAvgFields = {
  readonly __typename?: 'infrastructure_network_infrastructure_link_avg_fields';
  /** The estimated length of the infrastructure link in metres. */
  readonly estimated_length_in_metres?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkAvgOrderBy = {
  /** The estimated length of the infrastructure link in metres. */
  readonly estimated_length_in_metres?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "infrastructure_network.infrastructure_link". All fields are combined with a logical 'AND'. */
export type InfrastructureNetworkInfrastructureLinkBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkBoolExp>>;
  readonly _not?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkBoolExp>>;
  readonly direction?: InputMaybe<InfrastructureNetworkDirectionEnumComparisonExp>;
  readonly directionByDirection?: InputMaybe<InfrastructureNetworkDirectionBoolExp>;
  readonly estimated_length_in_metres?: InputMaybe<Float8ComparisonExp>;
  readonly external_link_id?: InputMaybe<StringComparisonExp>;
  readonly external_link_source?: InputMaybe<InfrastructureNetworkExternalSourceEnumComparisonExp>;
  readonly external_source?: InputMaybe<InfrastructureNetworkExternalSourceBoolExp>;
  readonly infrastructure_link_along_routes?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
  readonly infrastructure_link_along_routes_aggregate?: InputMaybe<RouteInfrastructureLinkAlongRouteAggregateBoolExp>;
  readonly infrastructure_link_id?: InputMaybe<UuidComparisonExp>;
  readonly scheduled_stop_points_located_on_infrastructure_link?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
  readonly scheduled_stop_points_located_on_infrastructure_link_aggregate?: InputMaybe<ServicePatternScheduledStopPointAggregateBoolExp>;
  readonly shape?: InputMaybe<GeographyComparisonExp>;
  readonly vehicle_submode_on_infrastructure_link?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
  readonly vehicle_submode_on_infrastructure_link_aggregate?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateBoolExp>;
  readonly vehicle_submode_on_infrastructure_links?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
  readonly vehicle_submode_on_infrastructure_links_aggregate?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateBoolExp>;
};

/** unique or primary key constraints on table "infrastructure_network.infrastructure_link" */
export enum InfrastructureNetworkInfrastructureLinkConstraint {
  /** unique or primary key constraint on columns "external_link_id", "external_link_source" */
  InfrastructureLinkExternalLinkIdExternalLinkSourceIdx = 'infrastructure_link_external_link_id_external_link_source_idx',
  /** unique or primary key constraint on columns "infrastructure_link_id" */
  InfrastructureLinkPkey = 'infrastructure_link_pkey'
}

/** input type for incrementing numeric columns in table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkIncInput = {
  /** The estimated length of the infrastructure link in metres. */
  readonly estimated_length_in_metres?: InputMaybe<Scalars['float8']['input']>;
};

/** input type for inserting data into table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkInsertInput = {
  /** The direction(s) of traffic with respect to the digitization, i.e. the direction of the specified line string. */
  readonly direction?: InputMaybe<InfrastructureNetworkDirectionEnum>;
  readonly directionByDirection?: InputMaybe<InfrastructureNetworkDirectionObjRelInsertInput>;
  /** The estimated length of the infrastructure link in metres. */
  readonly estimated_length_in_metres?: InputMaybe<Scalars['float8']['input']>;
  readonly external_link_id?: InputMaybe<Scalars['String']['input']>;
  readonly external_link_source?: InputMaybe<InfrastructureNetworkExternalSourceEnum>;
  readonly external_source?: InputMaybe<InfrastructureNetworkExternalSourceObjRelInsertInput>;
  readonly infrastructure_link_along_routes?: InputMaybe<RouteInfrastructureLinkAlongRouteArrRelInsertInput>;
  /** The ID of the infrastructure link. */
  readonly infrastructure_link_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly scheduled_stop_points_located_on_infrastructure_link?: InputMaybe<ServicePatternScheduledStopPointArrRelInsertInput>;
  /** A PostGIS LinestringZ geography in EPSG:4326 describing the infrastructure link. */
  readonly shape?: InputMaybe<Scalars['geography']['input']>;
  readonly vehicle_submode_on_infrastructure_link?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkArrRelInsertInput>;
  readonly vehicle_submode_on_infrastructure_links?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkArrRelInsertInput>;
};

/** aggregate max on columns */
export type InfrastructureNetworkInfrastructureLinkMaxFields = {
  readonly __typename?: 'infrastructure_network_infrastructure_link_max_fields';
  /** The estimated length of the infrastructure link in metres. */
  readonly estimated_length_in_metres?: Maybe<Scalars['float8']['output']>;
  readonly external_link_id?: Maybe<Scalars['String']['output']>;
  /** The ID of the infrastructure link. */
  readonly infrastructure_link_id?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkMaxOrderBy = {
  /** The estimated length of the infrastructure link in metres. */
  readonly estimated_length_in_metres?: InputMaybe<OrderBy>;
  readonly external_link_id?: InputMaybe<OrderBy>;
  /** The ID of the infrastructure link. */
  readonly infrastructure_link_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type InfrastructureNetworkInfrastructureLinkMinFields = {
  readonly __typename?: 'infrastructure_network_infrastructure_link_min_fields';
  /** The estimated length of the infrastructure link in metres. */
  readonly estimated_length_in_metres?: Maybe<Scalars['float8']['output']>;
  readonly external_link_id?: Maybe<Scalars['String']['output']>;
  /** The ID of the infrastructure link. */
  readonly infrastructure_link_id?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkMinOrderBy = {
  /** The estimated length of the infrastructure link in metres. */
  readonly estimated_length_in_metres?: InputMaybe<OrderBy>;
  readonly external_link_id?: InputMaybe<OrderBy>;
  /** The ID of the infrastructure link. */
  readonly infrastructure_link_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkMutationResponse = {
  readonly __typename?: 'infrastructure_network_infrastructure_link_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<InfrastructureNetworkInfrastructureLink>;
};

/** input type for inserting object relation for remote table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkObjRelInsertInput = {
  readonly data: InfrastructureNetworkInfrastructureLinkInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<InfrastructureNetworkInfrastructureLinkOnConflict>;
};

/** on_conflict condition type for table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkOnConflict = {
  readonly constraint: InfrastructureNetworkInfrastructureLinkConstraint;
  readonly update_columns?: ReadonlyArray<InfrastructureNetworkInfrastructureLinkUpdateColumn>;
  readonly where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
};

/** Ordering options when selecting data from "infrastructure_network.infrastructure_link". */
export type InfrastructureNetworkInfrastructureLinkOrderBy = {
  readonly direction?: InputMaybe<OrderBy>;
  readonly directionByDirection?: InputMaybe<InfrastructureNetworkDirectionOrderBy>;
  readonly estimated_length_in_metres?: InputMaybe<OrderBy>;
  readonly external_link_id?: InputMaybe<OrderBy>;
  readonly external_link_source?: InputMaybe<OrderBy>;
  readonly external_source?: InputMaybe<InfrastructureNetworkExternalSourceOrderBy>;
  readonly infrastructure_link_along_routes_aggregate?: InputMaybe<RouteInfrastructureLinkAlongRouteAggregateOrderBy>;
  readonly infrastructure_link_id?: InputMaybe<OrderBy>;
  readonly scheduled_stop_points_located_on_infrastructure_link_aggregate?: InputMaybe<ServicePatternScheduledStopPointAggregateOrderBy>;
  readonly shape?: InputMaybe<OrderBy>;
  readonly vehicle_submode_on_infrastructure_link_aggregate?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateOrderBy>;
  readonly vehicle_submode_on_infrastructure_links_aggregate?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateOrderBy>;
};

/** primary key columns input for table: infrastructure_network.infrastructure_link */
export type InfrastructureNetworkInfrastructureLinkPkColumnsInput = {
  /** The ID of the infrastructure link. */
  readonly infrastructure_link_id: Scalars['uuid']['input'];
};

/** select columns of table "infrastructure_network.infrastructure_link" */
export enum InfrastructureNetworkInfrastructureLinkSelectColumn {
  /** column name */
  Direction = 'direction',
  /** column name */
  EstimatedLengthInMetres = 'estimated_length_in_metres',
  /** column name */
  ExternalLinkId = 'external_link_id',
  /** column name */
  ExternalLinkSource = 'external_link_source',
  /** column name */
  InfrastructureLinkId = 'infrastructure_link_id',
  /** column name */
  Shape = 'shape'
}

/** select "infrastructure_network_infrastructure_link_aggregate_bool_exp_avg_arguments_columns" columns of table "infrastructure_network.infrastructure_link" */
export enum InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpAvgArgumentsColumns {
  /** column name */
  EstimatedLengthInMetres = 'estimated_length_in_metres'
}

/** select "infrastructure_network_infrastructure_link_aggregate_bool_exp_corr_arguments_columns" columns of table "infrastructure_network.infrastructure_link" */
export enum InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpCorrArgumentsColumns {
  /** column name */
  EstimatedLengthInMetres = 'estimated_length_in_metres'
}

/** select "infrastructure_network_infrastructure_link_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "infrastructure_network.infrastructure_link" */
export enum InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpCovarSampArgumentsColumns {
  /** column name */
  EstimatedLengthInMetres = 'estimated_length_in_metres'
}

/** select "infrastructure_network_infrastructure_link_aggregate_bool_exp_max_arguments_columns" columns of table "infrastructure_network.infrastructure_link" */
export enum InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpMaxArgumentsColumns {
  /** column name */
  EstimatedLengthInMetres = 'estimated_length_in_metres'
}

/** select "infrastructure_network_infrastructure_link_aggregate_bool_exp_min_arguments_columns" columns of table "infrastructure_network.infrastructure_link" */
export enum InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpMinArgumentsColumns {
  /** column name */
  EstimatedLengthInMetres = 'estimated_length_in_metres'
}

/** select "infrastructure_network_infrastructure_link_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "infrastructure_network.infrastructure_link" */
export enum InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpStddevSampArgumentsColumns {
  /** column name */
  EstimatedLengthInMetres = 'estimated_length_in_metres'
}

/** select "infrastructure_network_infrastructure_link_aggregate_bool_exp_sum_arguments_columns" columns of table "infrastructure_network.infrastructure_link" */
export enum InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpSumArgumentsColumns {
  /** column name */
  EstimatedLengthInMetres = 'estimated_length_in_metres'
}

/** select "infrastructure_network_infrastructure_link_aggregate_bool_exp_var_samp_arguments_columns" columns of table "infrastructure_network.infrastructure_link" */
export enum InfrastructureNetworkInfrastructureLinkSelectColumnInfrastructureNetworkInfrastructureLinkAggregateBoolExpVarSampArgumentsColumns {
  /** column name */
  EstimatedLengthInMetres = 'estimated_length_in_metres'
}

/** input type for updating data in table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkSetInput = {
  /** The direction(s) of traffic with respect to the digitization, i.e. the direction of the specified line string. */
  readonly direction?: InputMaybe<InfrastructureNetworkDirectionEnum>;
  /** The estimated length of the infrastructure link in metres. */
  readonly estimated_length_in_metres?: InputMaybe<Scalars['float8']['input']>;
  readonly external_link_id?: InputMaybe<Scalars['String']['input']>;
  readonly external_link_source?: InputMaybe<InfrastructureNetworkExternalSourceEnum>;
  /** The ID of the infrastructure link. */
  readonly infrastructure_link_id?: InputMaybe<Scalars['uuid']['input']>;
  /** A PostGIS LinestringZ geography in EPSG:4326 describing the infrastructure link. */
  readonly shape?: InputMaybe<Scalars['geography']['input']>;
};

/** aggregate stddev on columns */
export type InfrastructureNetworkInfrastructureLinkStddevFields = {
  readonly __typename?: 'infrastructure_network_infrastructure_link_stddev_fields';
  /** The estimated length of the infrastructure link in metres. */
  readonly estimated_length_in_metres?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkStddevOrderBy = {
  /** The estimated length of the infrastructure link in metres. */
  readonly estimated_length_in_metres?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type InfrastructureNetworkInfrastructureLinkStddevPopFields = {
  readonly __typename?: 'infrastructure_network_infrastructure_link_stddev_pop_fields';
  /** The estimated length of the infrastructure link in metres. */
  readonly estimated_length_in_metres?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkStddevPopOrderBy = {
  /** The estimated length of the infrastructure link in metres. */
  readonly estimated_length_in_metres?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type InfrastructureNetworkInfrastructureLinkStddevSampFields = {
  readonly __typename?: 'infrastructure_network_infrastructure_link_stddev_samp_fields';
  /** The estimated length of the infrastructure link in metres. */
  readonly estimated_length_in_metres?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkStddevSampOrderBy = {
  /** The estimated length of the infrastructure link in metres. */
  readonly estimated_length_in_metres?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "infrastructure_network_infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: InfrastructureNetworkInfrastructureLinkStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type InfrastructureNetworkInfrastructureLinkStreamCursorValueInput = {
  /** The direction(s) of traffic with respect to the digitization, i.e. the direction of the specified line string. */
  readonly direction?: InputMaybe<InfrastructureNetworkDirectionEnum>;
  /** The estimated length of the infrastructure link in metres. */
  readonly estimated_length_in_metres?: InputMaybe<Scalars['float8']['input']>;
  readonly external_link_id?: InputMaybe<Scalars['String']['input']>;
  readonly external_link_source?: InputMaybe<InfrastructureNetworkExternalSourceEnum>;
  /** The ID of the infrastructure link. */
  readonly infrastructure_link_id?: InputMaybe<Scalars['uuid']['input']>;
  /** A PostGIS LinestringZ geography in EPSG:4326 describing the infrastructure link. */
  readonly shape?: InputMaybe<Scalars['geography']['input']>;
};

/** aggregate sum on columns */
export type InfrastructureNetworkInfrastructureLinkSumFields = {
  readonly __typename?: 'infrastructure_network_infrastructure_link_sum_fields';
  /** The estimated length of the infrastructure link in metres. */
  readonly estimated_length_in_metres?: Maybe<Scalars['float8']['output']>;
};

/** order by sum() on columns of table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkSumOrderBy = {
  /** The estimated length of the infrastructure link in metres. */
  readonly estimated_length_in_metres?: InputMaybe<OrderBy>;
};

/** update columns of table "infrastructure_network.infrastructure_link" */
export enum InfrastructureNetworkInfrastructureLinkUpdateColumn {
  /** column name */
  Direction = 'direction',
  /** column name */
  EstimatedLengthInMetres = 'estimated_length_in_metres',
  /** column name */
  ExternalLinkId = 'external_link_id',
  /** column name */
  ExternalLinkSource = 'external_link_source',
  /** column name */
  InfrastructureLinkId = 'infrastructure_link_id',
  /** column name */
  Shape = 'shape'
}

export type InfrastructureNetworkInfrastructureLinkUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<InfrastructureNetworkInfrastructureLinkIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<InfrastructureNetworkInfrastructureLinkSetInput>;
  /** filter the rows which have to be updated */
  readonly where: InfrastructureNetworkInfrastructureLinkBoolExp;
};

/** aggregate var_pop on columns */
export type InfrastructureNetworkInfrastructureLinkVarPopFields = {
  readonly __typename?: 'infrastructure_network_infrastructure_link_var_pop_fields';
  /** The estimated length of the infrastructure link in metres. */
  readonly estimated_length_in_metres?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkVarPopOrderBy = {
  /** The estimated length of the infrastructure link in metres. */
  readonly estimated_length_in_metres?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type InfrastructureNetworkInfrastructureLinkVarSampFields = {
  readonly __typename?: 'infrastructure_network_infrastructure_link_var_samp_fields';
  /** The estimated length of the infrastructure link in metres. */
  readonly estimated_length_in_metres?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkVarSampOrderBy = {
  /** The estimated length of the infrastructure link in metres. */
  readonly estimated_length_in_metres?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type InfrastructureNetworkInfrastructureLinkVarianceFields = {
  readonly __typename?: 'infrastructure_network_infrastructure_link_variance_fields';
  /** The estimated length of the infrastructure link in metres. */
  readonly estimated_length_in_metres?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "infrastructure_network.infrastructure_link" */
export type InfrastructureNetworkInfrastructureLinkVarianceOrderBy = {
  /** The estimated length of the infrastructure link in metres. */
  readonly estimated_length_in_metres?: InputMaybe<OrderBy>;
};

export type InfrastructureNetworkResolvePointToClosestLinkArgs = {
  readonly geog?: InputMaybe<Scalars['geography']['input']>;
};

/** Which infrastructure links are safely traversed by which vehicle submodes? */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLink = {
  readonly __typename?: 'infrastructure_network_vehicle_submode_on_infrastructure_link';
  /** An object relationship */
  readonly infrastructure_link: InfrastructureNetworkInfrastructureLink;
  /** The infrastructure link that can be safely traversed by the vehicle submode. */
  readonly infrastructure_link_id: Scalars['uuid']['output'];
  /** An object relationship */
  readonly vehicleSubmodeByVehicleSubmode: ReusableComponentsVehicleSubmode;
  /** The vehicle submode that can safely traverse the infrastructure link. */
  readonly vehicle_submode: ReusableComponentsVehicleSubmodeEnum;
};

/** aggregated selection of "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregate = {
  readonly __typename?: 'infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate';
  readonly aggregate?: Maybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateFields>;
  readonly nodes: ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
};

export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateBoolExp = {
  readonly count?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateBoolExpCount>;
};

export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
  readonly predicate: IntComparisonExp;
};

/** aggregate fields of "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateFields = {
  readonly __typename?: 'infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate_fields';
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMaxFields>;
  readonly min?: Maybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMinFields>;
};


/** aggregate fields of "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateOrderBy = {
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMaxOrderBy>;
  readonly min?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMinOrderBy>;
};

/** input type for inserting array relation for remote table "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkArrRelInsertInput = {
  readonly data: ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOnConflict>;
};

/** Boolean expression to filter rows from the table "infrastructure_network.vehicle_submode_on_infrastructure_link". All fields are combined with a logical 'AND'. */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>>;
  readonly _not?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>>;
  readonly infrastructure_link?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  readonly infrastructure_link_id?: InputMaybe<UuidComparisonExp>;
  readonly vehicleSubmodeByVehicleSubmode?: InputMaybe<ReusableComponentsVehicleSubmodeBoolExp>;
  readonly vehicle_submode?: InputMaybe<ReusableComponentsVehicleSubmodeEnumComparisonExp>;
};

/** unique or primary key constraints on table "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export enum InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkConstraint {
  /** unique or primary key constraint on columns "infrastructure_link_id", "vehicle_submode" */
  VehicleSubmodeOnInfrastructureLinkPkey = 'vehicle_submode_on_infrastructure_link_pkey'
}

/** input type for inserting data into table "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkInsertInput = {
  readonly infrastructure_link?: InputMaybe<InfrastructureNetworkInfrastructureLinkObjRelInsertInput>;
  /** The infrastructure link that can be safely traversed by the vehicle submode. */
  readonly infrastructure_link_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly vehicleSubmodeByVehicleSubmode?: InputMaybe<ReusableComponentsVehicleSubmodeObjRelInsertInput>;
  /** The vehicle submode that can safely traverse the infrastructure link. */
  readonly vehicle_submode?: InputMaybe<ReusableComponentsVehicleSubmodeEnum>;
};

/** aggregate max on columns */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMaxFields = {
  readonly __typename?: 'infrastructure_network_vehicle_submode_on_infrastructure_link_max_fields';
  /** The infrastructure link that can be safely traversed by the vehicle submode. */
  readonly infrastructure_link_id?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMaxOrderBy = {
  /** The infrastructure link that can be safely traversed by the vehicle submode. */
  readonly infrastructure_link_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMinFields = {
  readonly __typename?: 'infrastructure_network_vehicle_submode_on_infrastructure_link_min_fields';
  /** The infrastructure link that can be safely traversed by the vehicle submode. */
  readonly infrastructure_link_id?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMinOrderBy = {
  /** The infrastructure link that can be safely traversed by the vehicle submode. */
  readonly infrastructure_link_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMutationResponse = {
  readonly __typename?: 'infrastructure_network_vehicle_submode_on_infrastructure_link_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
};

/** on_conflict condition type for table "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOnConflict = {
  readonly constraint: InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkConstraint;
  readonly update_columns?: ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkUpdateColumn>;
  readonly where?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
};

/** Ordering options when selecting data from "infrastructure_network.vehicle_submode_on_infrastructure_link". */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOrderBy = {
  readonly infrastructure_link?: InputMaybe<InfrastructureNetworkInfrastructureLinkOrderBy>;
  readonly infrastructure_link_id?: InputMaybe<OrderBy>;
  readonly vehicleSubmodeByVehicleSubmode?: InputMaybe<ReusableComponentsVehicleSubmodeOrderBy>;
  readonly vehicle_submode?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: infrastructure_network.vehicle_submode_on_infrastructure_link */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkPkColumnsInput = {
  /** The infrastructure link that can be safely traversed by the vehicle submode. */
  readonly infrastructure_link_id: Scalars['uuid']['input'];
  /** The vehicle submode that can safely traverse the infrastructure link. */
  readonly vehicle_submode: ReusableComponentsVehicleSubmodeEnum;
};

/** select columns of table "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export enum InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn {
  /** column name */
  InfrastructureLinkId = 'infrastructure_link_id',
  /** column name */
  VehicleSubmode = 'vehicle_submode'
}

/** input type for updating data in table "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSetInput = {
  /** The infrastructure link that can be safely traversed by the vehicle submode. */
  readonly infrastructure_link_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The vehicle submode that can safely traverse the infrastructure link. */
  readonly vehicle_submode?: InputMaybe<ReusableComponentsVehicleSubmodeEnum>;
};

/** Streaming cursor of the table "infrastructure_network_vehicle_submode_on_infrastructure_link" */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkStreamCursorValueInput = {
  /** The infrastructure link that can be safely traversed by the vehicle submode. */
  readonly infrastructure_link_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The vehicle submode that can safely traverse the infrastructure link. */
  readonly vehicle_submode?: InputMaybe<ReusableComponentsVehicleSubmodeEnum>;
};

/** update columns of table "infrastructure_network.vehicle_submode_on_infrastructure_link" */
export enum InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkUpdateColumn {
  /** column name */
  InfrastructureLinkId = 'infrastructure_link_id',
  /** column name */
  VehicleSubmode = 'vehicle_submode'
}

export type InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkUpdates = {
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSetInput>;
  /** filter the rows which have to be updated */
  readonly where: InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp;
};

export type InstalledEquipmentVersionStructureInstalledEquipmentAggregateBoolExp = {
  readonly count?: InputMaybe<InstalledEquipmentVersionStructureInstalledEquipmentAggregateBoolExpCount>;
};

export type InstalledEquipmentVersionStructureInstalledEquipmentAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>;
  readonly predicate: IntComparisonExp;
};

/** Boolean expression to compare columns of type "interval". All fields are combined with logical 'AND'. */
export type IntervalComparisonExp = {
  readonly _eq?: InputMaybe<Scalars['interval']['input']>;
  readonly _gt?: InputMaybe<Scalars['interval']['input']>;
  readonly _gte?: InputMaybe<Scalars['interval']['input']>;
  readonly _in?: InputMaybe<ReadonlyArray<Scalars['interval']['input']>>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _lt?: InputMaybe<Scalars['interval']['input']>;
  readonly _lte?: InputMaybe<Scalars['interval']['input']>;
  readonly _neq?: InputMaybe<Scalars['interval']['input']>;
  readonly _nin?: InputMaybe<ReadonlyArray<Scalars['interval']['input']>>;
};

export type JourneyPatternCheckInfraLinkStopRefsWithNewScheduledStopPointArgs = {
  readonly new_direction?: InputMaybe<Scalars['String']['input']>;
  readonly new_label?: InputMaybe<Scalars['String']['input']>;
  readonly new_located_on_infrastructure_link_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly new_measured_location?: InputMaybe<Scalars['geography']['input']>;
  readonly new_priority?: InputMaybe<Scalars['Int']['input']>;
  readonly new_validity_end?: InputMaybe<Scalars['date']['input']>;
  readonly new_validity_start?: InputMaybe<Scalars['date']['input']>;
  readonly replace_scheduled_stop_point_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** The journey patterns, i.e. the ordered lists of stops and timing points along routes: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813 */
export type JourneyPatternJourneyPattern = {
  readonly __typename?: 'journey_pattern_journey_pattern';
  /** The ID of the journey pattern. */
  readonly journey_pattern_id: Scalars['uuid']['output'];
  readonly journey_pattern_refs: ReadonlyArray<TimetablesJourneyPatternJourneyPatternRef>;
  readonly journey_pattern_refs_aggregate: TimetablesJourneyPatternJourneyPatternRefAggregate;
  /** An object relationship */
  readonly journey_pattern_route?: Maybe<RouteRoute>;
  readonly journey_pattern_vehicle_services: ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleService>;
  readonly journey_pattern_vehicle_services_aggregate: TimetablesVehicleServiceJourneyPatternsInVehicleServiceAggregate;
  /** The ID of the route the journey pattern is on. */
  readonly on_route_id: Scalars['uuid']['output'];
  /** An array relationship */
  readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPattern>;
  /** An aggregate relationship */
  readonly scheduled_stop_point_in_journey_patterns_aggregate: JourneyPatternScheduledStopPointInJourneyPatternAggregate;
};


/** The journey patterns, i.e. the ordered lists of stops and timing points along routes: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813 */
export type JourneyPatternJourneyPatternJourneyPatternRefsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesJourneyPatternJourneyPatternRefSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesJourneyPatternJourneyPatternRefOrderBy>>;
  where?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefBoolExp>;
};


/** The journey patterns, i.e. the ordered lists of stops and timing points along routes: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813 */
export type JourneyPatternJourneyPatternJourneyPatternRefsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesJourneyPatternJourneyPatternRefSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesJourneyPatternJourneyPatternRefOrderBy>>;
  where?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefBoolExp>;
};


/** The journey patterns, i.e. the ordered lists of stops and timing points along routes: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813 */
export type JourneyPatternJourneyPatternJourneyPatternVehicleServicesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleServiceOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
};


/** The journey patterns, i.e. the ordered lists of stops and timing points along routes: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813 */
export type JourneyPatternJourneyPatternJourneyPatternVehicleServicesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleServiceOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
};


/** The journey patterns, i.e. the ordered lists of stops and timing points along routes: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813 */
export type JourneyPatternJourneyPatternScheduledStopPointInJourneyPatternsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternOrderBy>>;
  where?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
};


/** The journey patterns, i.e. the ordered lists of stops and timing points along routes: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813 */
export type JourneyPatternJourneyPatternScheduledStopPointInJourneyPatternsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternOrderBy>>;
  where?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
};

/** aggregated selection of "journey_pattern.journey_pattern" */
export type JourneyPatternJourneyPatternAggregate = {
  readonly __typename?: 'journey_pattern_journey_pattern_aggregate';
  readonly aggregate?: Maybe<JourneyPatternJourneyPatternAggregateFields>;
  readonly nodes: ReadonlyArray<JourneyPatternJourneyPattern>;
};

export type JourneyPatternJourneyPatternAggregateBoolExp = {
  readonly count?: InputMaybe<JourneyPatternJourneyPatternAggregateBoolExpCount>;
};

export type JourneyPatternJourneyPatternAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<JourneyPatternJourneyPatternSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
  readonly predicate: IntComparisonExp;
};

/** aggregate fields of "journey_pattern.journey_pattern" */
export type JourneyPatternJourneyPatternAggregateFields = {
  readonly __typename?: 'journey_pattern_journey_pattern_aggregate_fields';
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<JourneyPatternJourneyPatternMaxFields>;
  readonly min?: Maybe<JourneyPatternJourneyPatternMinFields>;
};


/** aggregate fields of "journey_pattern.journey_pattern" */
export type JourneyPatternJourneyPatternAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<JourneyPatternJourneyPatternSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "journey_pattern.journey_pattern" */
export type JourneyPatternJourneyPatternAggregateOrderBy = {
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<JourneyPatternJourneyPatternMaxOrderBy>;
  readonly min?: InputMaybe<JourneyPatternJourneyPatternMinOrderBy>;
};

/** input type for inserting array relation for remote table "journey_pattern.journey_pattern" */
export type JourneyPatternJourneyPatternArrRelInsertInput = {
  readonly data: ReadonlyArray<JourneyPatternJourneyPatternInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<JourneyPatternJourneyPatternOnConflict>;
};

/** Boolean expression to filter rows from the table "journey_pattern.journey_pattern". All fields are combined with a logical 'AND'. */
export type JourneyPatternJourneyPatternBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<JourneyPatternJourneyPatternBoolExp>>;
  readonly _not?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<JourneyPatternJourneyPatternBoolExp>>;
  readonly journey_pattern_id?: InputMaybe<UuidComparisonExp>;
  readonly journey_pattern_route?: InputMaybe<RouteRouteBoolExp>;
  readonly on_route_id?: InputMaybe<UuidComparisonExp>;
  readonly scheduled_stop_point_in_journey_patterns?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
  readonly scheduled_stop_point_in_journey_patterns_aggregate?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExp>;
};

/** unique or primary key constraints on table "journey_pattern.journey_pattern" */
export enum JourneyPatternJourneyPatternConstraint {
  /** unique or primary key constraint on columns "on_route_id" */
  JourneyPatternOnRouteIdIdx = 'journey_pattern_on_route_id_idx',
  /** unique or primary key constraint on columns "journey_pattern_id" */
  JourneyPatternPkey = 'journey_pattern_pkey'
}

/** input type for inserting data into table "journey_pattern.journey_pattern" */
export type JourneyPatternJourneyPatternInsertInput = {
  /** The ID of the journey pattern. */
  readonly journey_pattern_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly journey_pattern_route?: InputMaybe<RouteRouteObjRelInsertInput>;
  /** The ID of the route the journey pattern is on. */
  readonly on_route_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly scheduled_stop_point_in_journey_patterns?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternArrRelInsertInput>;
};

/** aggregate max on columns */
export type JourneyPatternJourneyPatternMaxFields = {
  readonly __typename?: 'journey_pattern_journey_pattern_max_fields';
  /** The ID of the journey pattern. */
  readonly journey_pattern_id?: Maybe<Scalars['uuid']['output']>;
  /** The ID of the route the journey pattern is on. */
  readonly on_route_id?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "journey_pattern.journey_pattern" */
export type JourneyPatternJourneyPatternMaxOrderBy = {
  /** The ID of the journey pattern. */
  readonly journey_pattern_id?: InputMaybe<OrderBy>;
  /** The ID of the route the journey pattern is on. */
  readonly on_route_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type JourneyPatternJourneyPatternMinFields = {
  readonly __typename?: 'journey_pattern_journey_pattern_min_fields';
  /** The ID of the journey pattern. */
  readonly journey_pattern_id?: Maybe<Scalars['uuid']['output']>;
  /** The ID of the route the journey pattern is on. */
  readonly on_route_id?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "journey_pattern.journey_pattern" */
export type JourneyPatternJourneyPatternMinOrderBy = {
  /** The ID of the journey pattern. */
  readonly journey_pattern_id?: InputMaybe<OrderBy>;
  /** The ID of the route the journey pattern is on. */
  readonly on_route_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "journey_pattern.journey_pattern" */
export type JourneyPatternJourneyPatternMutationResponse = {
  readonly __typename?: 'journey_pattern_journey_pattern_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<JourneyPatternJourneyPattern>;
};

/** input type for inserting object relation for remote table "journey_pattern.journey_pattern" */
export type JourneyPatternJourneyPatternObjRelInsertInput = {
  readonly data: JourneyPatternJourneyPatternInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<JourneyPatternJourneyPatternOnConflict>;
};

/** on_conflict condition type for table "journey_pattern.journey_pattern" */
export type JourneyPatternJourneyPatternOnConflict = {
  readonly constraint: JourneyPatternJourneyPatternConstraint;
  readonly update_columns?: ReadonlyArray<JourneyPatternJourneyPatternUpdateColumn>;
  readonly where?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
};

/** Ordering options when selecting data from "journey_pattern.journey_pattern". */
export type JourneyPatternJourneyPatternOrderBy = {
  readonly journey_pattern_id?: InputMaybe<OrderBy>;
  readonly journey_pattern_route?: InputMaybe<RouteRouteOrderBy>;
  readonly on_route_id?: InputMaybe<OrderBy>;
  readonly scheduled_stop_point_in_journey_patterns_aggregate?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternAggregateOrderBy>;
};

/** primary key columns input for table: journey_pattern.journey_pattern */
export type JourneyPatternJourneyPatternPkColumnsInput = {
  /** The ID of the journey pattern. */
  readonly journey_pattern_id: Scalars['uuid']['input'];
};

/** select columns of table "journey_pattern.journey_pattern" */
export enum JourneyPatternJourneyPatternSelectColumn {
  /** column name */
  JourneyPatternId = 'journey_pattern_id',
  /** column name */
  OnRouteId = 'on_route_id'
}

/** input type for updating data in table "journey_pattern.journey_pattern" */
export type JourneyPatternJourneyPatternSetInput = {
  /** The ID of the journey pattern. */
  readonly journey_pattern_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The ID of the route the journey pattern is on. */
  readonly on_route_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "journey_pattern_journey_pattern" */
export type JourneyPatternJourneyPatternStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: JourneyPatternJourneyPatternStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type JourneyPatternJourneyPatternStreamCursorValueInput = {
  /** The ID of the journey pattern. */
  readonly journey_pattern_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The ID of the route the journey pattern is on. */
  readonly on_route_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "journey_pattern.journey_pattern" */
export enum JourneyPatternJourneyPatternUpdateColumn {
  /** column name */
  JourneyPatternId = 'journey_pattern_id',
  /** column name */
  OnRouteId = 'on_route_id'
}

export type JourneyPatternJourneyPatternUpdates = {
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<JourneyPatternJourneyPatternSetInput>;
  /** filter the rows which have to be updated */
  readonly where: JourneyPatternJourneyPatternBoolExp;
};

/** The scheduled stop points that form the journey pattern, in order: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813 . For HSL, all timing points are stops, hence journey pattern instead of service pattern. */
export type JourneyPatternScheduledStopPointInJourneyPattern = {
  readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern';
  /** Is adding loading time to this scheduled stop point in the journey pattern allowed? */
  readonly is_loading_time_allowed: Scalars['Boolean']['output'];
  /** Is this stop point passing time regulated so that it cannot be passed before scheduled time? */
  readonly is_regulated_timing_point: Scalars['Boolean']['output'];
  /** Is this scheduled stop point used as a timing point in the journey pattern? */
  readonly is_used_as_timing_point: Scalars['Boolean']['output'];
  /** Is this scheduled stop point a via point? */
  readonly is_via_point: Scalars['Boolean']['output'];
  /** An object relationship */
  readonly journey_pattern: JourneyPatternJourneyPattern;
  /** The ID of the journey pattern. */
  readonly journey_pattern_id: Scalars['uuid']['output'];
  readonly scheduled_stop_point_label: Scalars['String']['output'];
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence: Scalars['Int']['output'];
  /** An array relationship */
  readonly scheduled_stop_points: ReadonlyArray<ServicePatternScheduledStopPoint>;
  /** An aggregate relationship */
  readonly scheduled_stop_points_aggregate: ServicePatternScheduledStopPointAggregate;
  readonly via_point_name_i18n?: Maybe<Scalars['localized_string']['output']>;
  readonly via_point_short_name_i18n?: Maybe<Scalars['localized_string']['output']>;
};


/** The scheduled stop points that form the journey pattern, in order: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813 . For HSL, all timing points are stops, hence journey pattern instead of service pattern. */
export type JourneyPatternScheduledStopPointInJourneyPatternScheduledStopPointsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};


/** The scheduled stop points that form the journey pattern, in order: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813 . For HSL, all timing points are stops, hence journey pattern instead of service pattern. */
export type JourneyPatternScheduledStopPointInJourneyPatternScheduledStopPointsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};


/** The scheduled stop points that form the journey pattern, in order: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813 . For HSL, all timing points are stops, hence journey pattern instead of service pattern. */
export type JourneyPatternScheduledStopPointInJourneyPatternViaPointNameI18nArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** The scheduled stop points that form the journey pattern, in order: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:1:813 . For HSL, all timing points are stops, hence journey pattern instead of service pattern. */
export type JourneyPatternScheduledStopPointInJourneyPatternViaPointShortNameI18nArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternAggregate = {
  readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate';
  readonly aggregate?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternAggregateFields>;
  readonly nodes: ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPattern>;
};

export type JourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExp = {
  readonly bool_and?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExpBoolAnd>;
  readonly bool_or?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExpBoolOr>;
  readonly count?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExpCount>;
};

export type JourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExpBoolAnd = {
  readonly arguments: JourneyPatternScheduledStopPointInJourneyPatternSelectColumnJourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExpBoolAndArgumentsColumns;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
  readonly predicate: BooleanComparisonExp;
};

export type JourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExpBoolOr = {
  readonly arguments: JourneyPatternScheduledStopPointInJourneyPatternSelectColumnJourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExpBoolOrArgumentsColumns;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
  readonly predicate: BooleanComparisonExp;
};

export type JourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
  readonly predicate: IntComparisonExp;
};

/** aggregate fields of "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternAggregateFields = {
  readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_fields';
  readonly avg?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternMaxFields>;
  readonly min?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternMinFields>;
  readonly stddev?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternStddevFields>;
  readonly stddev_pop?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternStddevPopFields>;
  readonly stddev_samp?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternStddevSampFields>;
  readonly sum?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternSumFields>;
  readonly var_pop?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternVarPopFields>;
  readonly var_samp?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternVarSampFields>;
  readonly variance?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternVarianceFields>;
};


/** aggregate fields of "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternAggregateOrderBy = {
  readonly avg?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternMaxOrderBy>;
  readonly min?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternMinOrderBy>;
  readonly stddev?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternStddevSampOrderBy>;
  readonly sum?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternSumOrderBy>;
  readonly var_pop?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternVarPopOrderBy>;
  readonly var_samp?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternVarSampOrderBy>;
  readonly variance?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type JourneyPatternScheduledStopPointInJourneyPatternAppendInput = {
  readonly via_point_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  readonly via_point_short_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternArrRelInsertInput = {
  readonly data: ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternOnConflict>;
};

/** aggregate avg on columns */
export type JourneyPatternScheduledStopPointInJourneyPatternAvgFields = {
  readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_avg_fields';
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternAvgOrderBy = {
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "journey_pattern.scheduled_stop_point_in_journey_pattern". All fields are combined with a logical 'AND'. */
export type JourneyPatternScheduledStopPointInJourneyPatternBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>>;
  readonly _not?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>>;
  readonly is_loading_time_allowed?: InputMaybe<BooleanComparisonExp>;
  readonly is_regulated_timing_point?: InputMaybe<BooleanComparisonExp>;
  readonly is_used_as_timing_point?: InputMaybe<BooleanComparisonExp>;
  readonly is_via_point?: InputMaybe<BooleanComparisonExp>;
  readonly journey_pattern?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
  readonly journey_pattern_id?: InputMaybe<UuidComparisonExp>;
  readonly scheduled_stop_point_label?: InputMaybe<StringComparisonExp>;
  readonly scheduled_stop_point_sequence?: InputMaybe<IntComparisonExp>;
  readonly scheduled_stop_points?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
  readonly scheduled_stop_points_aggregate?: InputMaybe<ServicePatternScheduledStopPointAggregateBoolExp>;
  readonly via_point_name_i18n?: InputMaybe<JsonbComparisonExp>;
  readonly via_point_short_name_i18n?: InputMaybe<JsonbComparisonExp>;
};

/** unique or primary key constraints on table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export enum JourneyPatternScheduledStopPointInJourneyPatternConstraint {
  /** unique or primary key constraint on columns "journey_pattern_id", "scheduled_stop_point_sequence" */
  ScheduledStopPointInJourneyPatternPkey = 'scheduled_stop_point_in_journey_pattern_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type JourneyPatternScheduledStopPointInJourneyPatternDeleteAtPathInput = {
  readonly via_point_name_i18n?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  readonly via_point_short_name_i18n?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type JourneyPatternScheduledStopPointInJourneyPatternDeleteElemInput = {
  readonly via_point_name_i18n?: InputMaybe<Scalars['Int']['input']>;
  readonly via_point_short_name_i18n?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type JourneyPatternScheduledStopPointInJourneyPatternDeleteKeyInput = {
  readonly via_point_name_i18n?: InputMaybe<Scalars['String']['input']>;
  readonly via_point_short_name_i18n?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternIncInput = {
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternInsertInput = {
  /** Is adding loading time to this scheduled stop point in the journey pattern allowed? */
  readonly is_loading_time_allowed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is this stop point passing time regulated so that it cannot be passed before scheduled time? */
  readonly is_regulated_timing_point?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is this scheduled stop point used as a timing point in the journey pattern? */
  readonly is_used_as_timing_point?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is this scheduled stop point a via point? */
  readonly is_via_point?: InputMaybe<Scalars['Boolean']['input']>;
  readonly journey_pattern?: InputMaybe<JourneyPatternJourneyPatternObjRelInsertInput>;
  /** The ID of the journey pattern. */
  readonly journey_pattern_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly scheduled_stop_point_label?: InputMaybe<Scalars['String']['input']>;
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence?: InputMaybe<Scalars['Int']['input']>;
  readonly scheduled_stop_points?: InputMaybe<ServicePatternScheduledStopPointArrRelInsertInput>;
  readonly via_point_name_i18n?: InputMaybe<Scalars['localized_string']['input']>;
  readonly via_point_short_name_i18n?: InputMaybe<Scalars['localized_string']['input']>;
};

/** aggregate max on columns */
export type JourneyPatternScheduledStopPointInJourneyPatternMaxFields = {
  readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_max_fields';
  /** The ID of the journey pattern. */
  readonly journey_pattern_id?: Maybe<Scalars['uuid']['output']>;
  readonly scheduled_stop_point_label?: Maybe<Scalars['String']['output']>;
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternMaxOrderBy = {
  /** The ID of the journey pattern. */
  readonly journey_pattern_id?: InputMaybe<OrderBy>;
  readonly scheduled_stop_point_label?: InputMaybe<OrderBy>;
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type JourneyPatternScheduledStopPointInJourneyPatternMinFields = {
  readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_min_fields';
  /** The ID of the journey pattern. */
  readonly journey_pattern_id?: Maybe<Scalars['uuid']['output']>;
  readonly scheduled_stop_point_label?: Maybe<Scalars['String']['output']>;
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternMinOrderBy = {
  /** The ID of the journey pattern. */
  readonly journey_pattern_id?: InputMaybe<OrderBy>;
  readonly scheduled_stop_point_label?: InputMaybe<OrderBy>;
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternMutationResponse = {
  readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPattern>;
};

/** on_conflict condition type for table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternOnConflict = {
  readonly constraint: JourneyPatternScheduledStopPointInJourneyPatternConstraint;
  readonly update_columns?: ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternUpdateColumn>;
  readonly where?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
};

/** Ordering options when selecting data from "journey_pattern.scheduled_stop_point_in_journey_pattern". */
export type JourneyPatternScheduledStopPointInJourneyPatternOrderBy = {
  readonly is_loading_time_allowed?: InputMaybe<OrderBy>;
  readonly is_regulated_timing_point?: InputMaybe<OrderBy>;
  readonly is_used_as_timing_point?: InputMaybe<OrderBy>;
  readonly is_via_point?: InputMaybe<OrderBy>;
  readonly journey_pattern?: InputMaybe<JourneyPatternJourneyPatternOrderBy>;
  readonly journey_pattern_id?: InputMaybe<OrderBy>;
  readonly scheduled_stop_point_label?: InputMaybe<OrderBy>;
  readonly scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
  readonly scheduled_stop_points_aggregate?: InputMaybe<ServicePatternScheduledStopPointAggregateOrderBy>;
  readonly via_point_name_i18n?: InputMaybe<OrderBy>;
  readonly via_point_short_name_i18n?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: journey_pattern.scheduled_stop_point_in_journey_pattern */
export type JourneyPatternScheduledStopPointInJourneyPatternPkColumnsInput = {
  /** The ID of the journey pattern. */
  readonly journey_pattern_id: Scalars['uuid']['input'];
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type JourneyPatternScheduledStopPointInJourneyPatternPrependInput = {
  readonly via_point_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  readonly via_point_short_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export enum JourneyPatternScheduledStopPointInJourneyPatternSelectColumn {
  /** column name */
  IsLoadingTimeAllowed = 'is_loading_time_allowed',
  /** column name */
  IsRegulatedTimingPoint = 'is_regulated_timing_point',
  /** column name */
  IsUsedAsTimingPoint = 'is_used_as_timing_point',
  /** column name */
  IsViaPoint = 'is_via_point',
  /** column name */
  JourneyPatternId = 'journey_pattern_id',
  /** column name */
  ScheduledStopPointLabel = 'scheduled_stop_point_label',
  /** column name */
  ScheduledStopPointSequence = 'scheduled_stop_point_sequence',
  /** column name */
  ViaPointNameI18n = 'via_point_name_i18n',
  /** column name */
  ViaPointShortNameI18n = 'via_point_short_name_i18n'
}

/** select "journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_bool_exp_bool_and_arguments_columns" columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export enum JourneyPatternScheduledStopPointInJourneyPatternSelectColumnJourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExpBoolAndArgumentsColumns {
  /** column name */
  IsLoadingTimeAllowed = 'is_loading_time_allowed',
  /** column name */
  IsRegulatedTimingPoint = 'is_regulated_timing_point',
  /** column name */
  IsUsedAsTimingPoint = 'is_used_as_timing_point',
  /** column name */
  IsViaPoint = 'is_via_point'
}

/** select "journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate_bool_exp_bool_or_arguments_columns" columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export enum JourneyPatternScheduledStopPointInJourneyPatternSelectColumnJourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExpBoolOrArgumentsColumns {
  /** column name */
  IsLoadingTimeAllowed = 'is_loading_time_allowed',
  /** column name */
  IsRegulatedTimingPoint = 'is_regulated_timing_point',
  /** column name */
  IsUsedAsTimingPoint = 'is_used_as_timing_point',
  /** column name */
  IsViaPoint = 'is_via_point'
}

/** input type for updating data in table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternSetInput = {
  /** Is adding loading time to this scheduled stop point in the journey pattern allowed? */
  readonly is_loading_time_allowed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is this stop point passing time regulated so that it cannot be passed before scheduled time? */
  readonly is_regulated_timing_point?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is this scheduled stop point used as a timing point in the journey pattern? */
  readonly is_used_as_timing_point?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is this scheduled stop point a via point? */
  readonly is_via_point?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the journey pattern. */
  readonly journey_pattern_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly scheduled_stop_point_label?: InputMaybe<Scalars['String']['input']>;
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence?: InputMaybe<Scalars['Int']['input']>;
  readonly via_point_name_i18n?: InputMaybe<Scalars['localized_string']['input']>;
  readonly via_point_short_name_i18n?: InputMaybe<Scalars['localized_string']['input']>;
};

/** aggregate stddev on columns */
export type JourneyPatternScheduledStopPointInJourneyPatternStddevFields = {
  readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_stddev_fields';
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternStddevOrderBy = {
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type JourneyPatternScheduledStopPointInJourneyPatternStddevPopFields = {
  readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_stddev_pop_fields';
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternStddevPopOrderBy = {
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type JourneyPatternScheduledStopPointInJourneyPatternStddevSampFields = {
  readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_stddev_samp_fields';
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternStddevSampOrderBy = {
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "journey_pattern_scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: JourneyPatternScheduledStopPointInJourneyPatternStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type JourneyPatternScheduledStopPointInJourneyPatternStreamCursorValueInput = {
  /** Is adding loading time to this scheduled stop point in the journey pattern allowed? */
  readonly is_loading_time_allowed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is this stop point passing time regulated so that it cannot be passed before scheduled time? */
  readonly is_regulated_timing_point?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is this scheduled stop point used as a timing point in the journey pattern? */
  readonly is_used_as_timing_point?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is this scheduled stop point a via point? */
  readonly is_via_point?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the journey pattern. */
  readonly journey_pattern_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly scheduled_stop_point_label?: InputMaybe<Scalars['String']['input']>;
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence?: InputMaybe<Scalars['Int']['input']>;
  readonly via_point_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  readonly via_point_short_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate sum on columns */
export type JourneyPatternScheduledStopPointInJourneyPatternSumFields = {
  readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_sum_fields';
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternSumOrderBy = {
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

/** update columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export enum JourneyPatternScheduledStopPointInJourneyPatternUpdateColumn {
  /** column name */
  IsLoadingTimeAllowed = 'is_loading_time_allowed',
  /** column name */
  IsRegulatedTimingPoint = 'is_regulated_timing_point',
  /** column name */
  IsUsedAsTimingPoint = 'is_used_as_timing_point',
  /** column name */
  IsViaPoint = 'is_via_point',
  /** column name */
  JourneyPatternId = 'journey_pattern_id',
  /** column name */
  ScheduledStopPointLabel = 'scheduled_stop_point_label',
  /** column name */
  ScheduledStopPointSequence = 'scheduled_stop_point_sequence',
  /** column name */
  ViaPointNameI18n = 'via_point_name_i18n',
  /** column name */
  ViaPointShortNameI18n = 'via_point_short_name_i18n'
}

export type JourneyPatternScheduledStopPointInJourneyPatternUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  readonly _append?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  readonly _delete_at_path?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  readonly _delete_elem?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  readonly _delete_key?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  readonly _prepend?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternSetInput>;
  /** filter the rows which have to be updated */
  readonly where: JourneyPatternScheduledStopPointInJourneyPatternBoolExp;
};

/** aggregate var_pop on columns */
export type JourneyPatternScheduledStopPointInJourneyPatternVarPopFields = {
  readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_var_pop_fields';
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternVarPopOrderBy = {
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type JourneyPatternScheduledStopPointInJourneyPatternVarSampFields = {
  readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_var_samp_fields';
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternVarSampOrderBy = {
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type JourneyPatternScheduledStopPointInJourneyPatternVarianceFields = {
  readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_variance_fields';
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "journey_pattern.scheduled_stop_point_in_journey_pattern" */
export type JourneyPatternScheduledStopPointInJourneyPatternVarianceOrderBy = {
  /** The order of the scheduled stop point within the journey pattern. */
  readonly scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

export type JsonbCastExp = {
  readonly String?: InputMaybe<StringComparisonExp>;
};

/** Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'. */
export type JsonbComparisonExp = {
  readonly _cast?: InputMaybe<JsonbCastExp>;
  /** is the column contained in the given json value */
  readonly _contained_in?: InputMaybe<Scalars['jsonb']['input']>;
  /** does the column contain the given json value at the top level */
  readonly _contains?: InputMaybe<Scalars['jsonb']['input']>;
  readonly _eq?: InputMaybe<Scalars['jsonb']['input']>;
  readonly _gt?: InputMaybe<Scalars['jsonb']['input']>;
  readonly _gte?: InputMaybe<Scalars['jsonb']['input']>;
  /** does the string exist as a top-level key in the column */
  readonly _has_key?: InputMaybe<Scalars['String']['input']>;
  /** do all of these strings exist as top-level keys in the column */
  readonly _has_keys_all?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  /** do any of these strings exist as top-level keys in the column */
  readonly _has_keys_any?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  readonly _in?: InputMaybe<ReadonlyArray<Scalars['jsonb']['input']>>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _lt?: InputMaybe<Scalars['jsonb']['input']>;
  readonly _lte?: InputMaybe<Scalars['jsonb']['input']>;
  readonly _neq?: InputMaybe<Scalars['jsonb']['input']>;
  readonly _nin?: InputMaybe<ReadonlyArray<Scalars['jsonb']['input']>>;
};

export type LevelKeyValuesAggregateBoolExp = {
  readonly count?: InputMaybe<LevelKeyValuesAggregateBoolExpCount>;
};

export type LevelKeyValuesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseLevelKeyValuesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseLevelKeyValuesBoolExp>;
  readonly predicate: IntComparisonExp;
};

/** mutation root */
export type MutationRoot = {
  readonly __typename?: 'mutation_root';
  readonly combineTimetables?: Maybe<CombineTimetablesOutput>;
  /** delete data from the table: "hsl_route.legacy_hsl_municipality_code" */
  readonly delete_hsl_route_legacy_hsl_municipality_code?: Maybe<HslRouteLegacyHslMunicipalityCodeMutationResponse>;
  /** delete single row from the table: "hsl_route.legacy_hsl_municipality_code" */
  readonly delete_hsl_route_legacy_hsl_municipality_code_by_pk?: Maybe<HslRouteLegacyHslMunicipalityCode>;
  /** delete data from the table: "hsl_route.transport_target" */
  readonly delete_hsl_route_transport_target?: Maybe<HslRouteTransportTargetMutationResponse>;
  /** delete single row from the table: "hsl_route.transport_target" */
  readonly delete_hsl_route_transport_target_by_pk?: Maybe<HslRouteTransportTarget>;
  /** delete data from the table: "infrastructure_network.direction" */
  readonly delete_infrastructure_network_direction?: Maybe<InfrastructureNetworkDirectionMutationResponse>;
  /** delete single row from the table: "infrastructure_network.direction" */
  readonly delete_infrastructure_network_direction_by_pk?: Maybe<InfrastructureNetworkDirection>;
  /** delete data from the table: "infrastructure_network.external_source" */
  readonly delete_infrastructure_network_external_source?: Maybe<InfrastructureNetworkExternalSourceMutationResponse>;
  /** delete single row from the table: "infrastructure_network.external_source" */
  readonly delete_infrastructure_network_external_source_by_pk?: Maybe<InfrastructureNetworkExternalSource>;
  /** delete data from the table: "infrastructure_network.infrastructure_link" */
  readonly delete_infrastructure_network_infrastructure_link?: Maybe<InfrastructureNetworkInfrastructureLinkMutationResponse>;
  /** delete single row from the table: "infrastructure_network.infrastructure_link" */
  readonly delete_infrastructure_network_infrastructure_link_by_pk?: Maybe<InfrastructureNetworkInfrastructureLink>;
  /** delete data from the table: "infrastructure_network.vehicle_submode_on_infrastructure_link" */
  readonly delete_infrastructure_network_vehicle_submode_on_infrastructure_link?: Maybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMutationResponse>;
  /** delete single row from the table: "infrastructure_network.vehicle_submode_on_infrastructure_link" */
  readonly delete_infrastructure_network_vehicle_submode_on_infrastructure_link_by_pk?: Maybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
  /** delete data from the table: "journey_pattern.journey_pattern" */
  readonly delete_journey_pattern_journey_pattern?: Maybe<JourneyPatternJourneyPatternMutationResponse>;
  /** delete single row from the table: "journey_pattern.journey_pattern" */
  readonly delete_journey_pattern_journey_pattern_by_pk?: Maybe<JourneyPatternJourneyPattern>;
  /** delete data from the table: "journey_pattern.scheduled_stop_point_in_journey_pattern" */
  readonly delete_journey_pattern_scheduled_stop_point_in_journey_pattern?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternMutationResponse>;
  /** delete single row from the table: "journey_pattern.scheduled_stop_point_in_journey_pattern" */
  readonly delete_journey_pattern_scheduled_stop_point_in_journey_pattern_by_pk?: Maybe<JourneyPatternScheduledStopPointInJourneyPattern>;
  /** delete data from the table: "reusable_components.vehicle_mode" */
  readonly delete_reusable_components_vehicle_mode?: Maybe<ReusableComponentsVehicleModeMutationResponse>;
  /** delete single row from the table: "reusable_components.vehicle_mode" */
  readonly delete_reusable_components_vehicle_mode_by_pk?: Maybe<ReusableComponentsVehicleMode>;
  /** delete data from the table: "reusable_components.vehicle_submode" */
  readonly delete_reusable_components_vehicle_submode?: Maybe<ReusableComponentsVehicleSubmodeMutationResponse>;
  /** delete single row from the table: "reusable_components.vehicle_submode" */
  readonly delete_reusable_components_vehicle_submode_by_pk?: Maybe<ReusableComponentsVehicleSubmode>;
  /** delete data from the table: "route.direction" */
  readonly delete_route_direction?: Maybe<RouteDirectionMutationResponse>;
  /** delete single row from the table: "route.direction" */
  readonly delete_route_direction_by_pk?: Maybe<RouteDirection>;
  /** delete data from the table: "route.infrastructure_link_along_route" */
  readonly delete_route_infrastructure_link_along_route?: Maybe<RouteInfrastructureLinkAlongRouteMutationResponse>;
  /** delete single row from the table: "route.infrastructure_link_along_route" */
  readonly delete_route_infrastructure_link_along_route_by_pk?: Maybe<RouteInfrastructureLinkAlongRoute>;
  /** delete data from the table: "route.line" */
  readonly delete_route_line?: Maybe<RouteLineMutationResponse>;
  /** delete single row from the table: "route.line" */
  readonly delete_route_line_by_pk?: Maybe<RouteLine>;
  /** delete data from the table: "route.route" */
  readonly delete_route_route?: Maybe<RouteRouteMutationResponse>;
  /** delete single row from the table: "route.route" */
  readonly delete_route_route_by_pk?: Maybe<RouteRoute>;
  /** delete data from the table: "route.type_of_line" */
  readonly delete_route_type_of_line?: Maybe<RouteTypeOfLineMutationResponse>;
  /** delete single row from the table: "route.type_of_line" */
  readonly delete_route_type_of_line_by_pk?: Maybe<RouteTypeOfLine>;
  /** delete data from the table: "service_pattern.distance_between_stops_calculation" */
  readonly delete_service_pattern_distance_between_stops_calculation?: Maybe<ServicePatternDistanceBetweenStopsCalculationMutationResponse>;
  /** delete single row from the table: "service_pattern.distance_between_stops_calculation" */
  readonly delete_service_pattern_distance_between_stops_calculation_by_pk?: Maybe<ServicePatternDistanceBetweenStopsCalculation>;
  /** delete data from the table: "service_pattern.scheduled_stop_point" */
  readonly delete_service_pattern_scheduled_stop_point?: Maybe<ServicePatternScheduledStopPointMutationResponse>;
  /** delete single row from the table: "service_pattern.scheduled_stop_point" */
  readonly delete_service_pattern_scheduled_stop_point_by_pk?: Maybe<ServicePatternScheduledStopPoint>;
  /** delete data from the table: "service_pattern.vehicle_mode_on_scheduled_stop_point" */
  readonly delete_service_pattern_vehicle_mode_on_scheduled_stop_point?: Maybe<ServicePatternVehicleModeOnScheduledStopPointMutationResponse>;
  /** delete single row from the table: "service_pattern.vehicle_mode_on_scheduled_stop_point" */
  readonly delete_service_pattern_vehicle_mode_on_scheduled_stop_point_by_pk?: Maybe<ServicePatternVehicleModeOnScheduledStopPoint>;
  /** delete data from the table: "timing_pattern.timing_place" */
  readonly delete_timing_pattern_timing_place?: Maybe<TimingPatternTimingPlaceMutationResponse>;
  /** delete single row from the table: "timing_pattern.timing_place" */
  readonly delete_timing_pattern_timing_place_by_pk?: Maybe<TimingPatternTimingPlace>;
  /** insert data into the table: "hsl_route.legacy_hsl_municipality_code" */
  readonly insert_hsl_route_legacy_hsl_municipality_code?: Maybe<HslRouteLegacyHslMunicipalityCodeMutationResponse>;
  /** insert a single row into the table: "hsl_route.legacy_hsl_municipality_code" */
  readonly insert_hsl_route_legacy_hsl_municipality_code_one?: Maybe<HslRouteLegacyHslMunicipalityCode>;
  /** insert data into the table: "hsl_route.transport_target" */
  readonly insert_hsl_route_transport_target?: Maybe<HslRouteTransportTargetMutationResponse>;
  /** insert a single row into the table: "hsl_route.transport_target" */
  readonly insert_hsl_route_transport_target_one?: Maybe<HslRouteTransportTarget>;
  /** insert data into the table: "infrastructure_network.direction" */
  readonly insert_infrastructure_network_direction?: Maybe<InfrastructureNetworkDirectionMutationResponse>;
  /** insert a single row into the table: "infrastructure_network.direction" */
  readonly insert_infrastructure_network_direction_one?: Maybe<InfrastructureNetworkDirection>;
  /** insert data into the table: "infrastructure_network.external_source" */
  readonly insert_infrastructure_network_external_source?: Maybe<InfrastructureNetworkExternalSourceMutationResponse>;
  /** insert a single row into the table: "infrastructure_network.external_source" */
  readonly insert_infrastructure_network_external_source_one?: Maybe<InfrastructureNetworkExternalSource>;
  /** insert data into the table: "infrastructure_network.infrastructure_link" */
  readonly insert_infrastructure_network_infrastructure_link?: Maybe<InfrastructureNetworkInfrastructureLinkMutationResponse>;
  /** insert a single row into the table: "infrastructure_network.infrastructure_link" */
  readonly insert_infrastructure_network_infrastructure_link_one?: Maybe<InfrastructureNetworkInfrastructureLink>;
  /** insert data into the table: "infrastructure_network.vehicle_submode_on_infrastructure_link" */
  readonly insert_infrastructure_network_vehicle_submode_on_infrastructure_link?: Maybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMutationResponse>;
  /** insert a single row into the table: "infrastructure_network.vehicle_submode_on_infrastructure_link" */
  readonly insert_infrastructure_network_vehicle_submode_on_infrastructure_link_one?: Maybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
  /** insert data into the table: "journey_pattern.journey_pattern" */
  readonly insert_journey_pattern_journey_pattern?: Maybe<JourneyPatternJourneyPatternMutationResponse>;
  /** insert a single row into the table: "journey_pattern.journey_pattern" */
  readonly insert_journey_pattern_journey_pattern_one?: Maybe<JourneyPatternJourneyPattern>;
  /** insert data into the table: "journey_pattern.scheduled_stop_point_in_journey_pattern" */
  readonly insert_journey_pattern_scheduled_stop_point_in_journey_pattern?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternMutationResponse>;
  /** insert a single row into the table: "journey_pattern.scheduled_stop_point_in_journey_pattern" */
  readonly insert_journey_pattern_scheduled_stop_point_in_journey_pattern_one?: Maybe<JourneyPatternScheduledStopPointInJourneyPattern>;
  /** insert data into the table: "reusable_components.vehicle_mode" */
  readonly insert_reusable_components_vehicle_mode?: Maybe<ReusableComponentsVehicleModeMutationResponse>;
  /** insert a single row into the table: "reusable_components.vehicle_mode" */
  readonly insert_reusable_components_vehicle_mode_one?: Maybe<ReusableComponentsVehicleMode>;
  /** insert data into the table: "reusable_components.vehicle_submode" */
  readonly insert_reusable_components_vehicle_submode?: Maybe<ReusableComponentsVehicleSubmodeMutationResponse>;
  /** insert a single row into the table: "reusable_components.vehicle_submode" */
  readonly insert_reusable_components_vehicle_submode_one?: Maybe<ReusableComponentsVehicleSubmode>;
  /** insert data into the table: "route.direction" */
  readonly insert_route_direction?: Maybe<RouteDirectionMutationResponse>;
  /** insert a single row into the table: "route.direction" */
  readonly insert_route_direction_one?: Maybe<RouteDirection>;
  /** insert data into the table: "route.infrastructure_link_along_route" */
  readonly insert_route_infrastructure_link_along_route?: Maybe<RouteInfrastructureLinkAlongRouteMutationResponse>;
  /** insert a single row into the table: "route.infrastructure_link_along_route" */
  readonly insert_route_infrastructure_link_along_route_one?: Maybe<RouteInfrastructureLinkAlongRoute>;
  /** insert data into the table: "route.line" */
  readonly insert_route_line?: Maybe<RouteLineMutationResponse>;
  /** insert a single row into the table: "route.line" */
  readonly insert_route_line_one?: Maybe<RouteLine>;
  /** insert data into the table: "route.route" */
  readonly insert_route_route?: Maybe<RouteRouteMutationResponse>;
  /** insert a single row into the table: "route.route" */
  readonly insert_route_route_one?: Maybe<RouteRoute>;
  /** insert data into the table: "route.type_of_line" */
  readonly insert_route_type_of_line?: Maybe<RouteTypeOfLineMutationResponse>;
  /** insert a single row into the table: "route.type_of_line" */
  readonly insert_route_type_of_line_one?: Maybe<RouteTypeOfLine>;
  /** insert data into the table: "service_pattern.distance_between_stops_calculation" */
  readonly insert_service_pattern_distance_between_stops_calculation?: Maybe<ServicePatternDistanceBetweenStopsCalculationMutationResponse>;
  /** insert a single row into the table: "service_pattern.distance_between_stops_calculation" */
  readonly insert_service_pattern_distance_between_stops_calculation_one?: Maybe<ServicePatternDistanceBetweenStopsCalculation>;
  /** insert data into the table: "service_pattern.scheduled_stop_point" */
  readonly insert_service_pattern_scheduled_stop_point?: Maybe<ServicePatternScheduledStopPointMutationResponse>;
  /** insert a single row into the table: "service_pattern.scheduled_stop_point" */
  readonly insert_service_pattern_scheduled_stop_point_one?: Maybe<ServicePatternScheduledStopPoint>;
  /** insert data into the table: "service_pattern.vehicle_mode_on_scheduled_stop_point" */
  readonly insert_service_pattern_vehicle_mode_on_scheduled_stop_point?: Maybe<ServicePatternVehicleModeOnScheduledStopPointMutationResponse>;
  /** insert a single row into the table: "service_pattern.vehicle_mode_on_scheduled_stop_point" */
  readonly insert_service_pattern_vehicle_mode_on_scheduled_stop_point_one?: Maybe<ServicePatternVehicleModeOnScheduledStopPoint>;
  /** insert data into the table: "timing_pattern.timing_place" */
  readonly insert_timing_pattern_timing_place?: Maybe<TimingPatternTimingPlaceMutationResponse>;
  /** insert a single row into the table: "timing_pattern.timing_place" */
  readonly insert_timing_pattern_timing_place_one?: Maybe<TimingPatternTimingPlace>;
  readonly replaceTimetables?: Maybe<ReplaceTimetablesOutput>;
  readonly stop_registry?: Maybe<StopRegistryStopPlaceMutation>;
  readonly stops_database?: Maybe<StopsDatabaseStopsDatabaseMutationFrontend>;
  readonly timetables?: Maybe<TimetablesTimetablesMutationFrontend>;
  /** update data of the table: "hsl_route.legacy_hsl_municipality_code" */
  readonly update_hsl_route_legacy_hsl_municipality_code?: Maybe<HslRouteLegacyHslMunicipalityCodeMutationResponse>;
  /** update single row of the table: "hsl_route.legacy_hsl_municipality_code" */
  readonly update_hsl_route_legacy_hsl_municipality_code_by_pk?: Maybe<HslRouteLegacyHslMunicipalityCode>;
  /** update multiples rows of table: "hsl_route.legacy_hsl_municipality_code" */
  readonly update_hsl_route_legacy_hsl_municipality_code_many?: Maybe<ReadonlyArray<Maybe<HslRouteLegacyHslMunicipalityCodeMutationResponse>>>;
  /** update data of the table: "hsl_route.transport_target" */
  readonly update_hsl_route_transport_target?: Maybe<HslRouteTransportTargetMutationResponse>;
  /** update single row of the table: "hsl_route.transport_target" */
  readonly update_hsl_route_transport_target_by_pk?: Maybe<HslRouteTransportTarget>;
  /** update multiples rows of table: "hsl_route.transport_target" */
  readonly update_hsl_route_transport_target_many?: Maybe<ReadonlyArray<Maybe<HslRouteTransportTargetMutationResponse>>>;
  /** update data of the table: "infrastructure_network.direction" */
  readonly update_infrastructure_network_direction?: Maybe<InfrastructureNetworkDirectionMutationResponse>;
  /** update single row of the table: "infrastructure_network.direction" */
  readonly update_infrastructure_network_direction_by_pk?: Maybe<InfrastructureNetworkDirection>;
  /** update multiples rows of table: "infrastructure_network.direction" */
  readonly update_infrastructure_network_direction_many?: Maybe<ReadonlyArray<Maybe<InfrastructureNetworkDirectionMutationResponse>>>;
  /** update data of the table: "infrastructure_network.external_source" */
  readonly update_infrastructure_network_external_source?: Maybe<InfrastructureNetworkExternalSourceMutationResponse>;
  /** update single row of the table: "infrastructure_network.external_source" */
  readonly update_infrastructure_network_external_source_by_pk?: Maybe<InfrastructureNetworkExternalSource>;
  /** update multiples rows of table: "infrastructure_network.external_source" */
  readonly update_infrastructure_network_external_source_many?: Maybe<ReadonlyArray<Maybe<InfrastructureNetworkExternalSourceMutationResponse>>>;
  /** update data of the table: "infrastructure_network.infrastructure_link" */
  readonly update_infrastructure_network_infrastructure_link?: Maybe<InfrastructureNetworkInfrastructureLinkMutationResponse>;
  /** update single row of the table: "infrastructure_network.infrastructure_link" */
  readonly update_infrastructure_network_infrastructure_link_by_pk?: Maybe<InfrastructureNetworkInfrastructureLink>;
  /** update multiples rows of table: "infrastructure_network.infrastructure_link" */
  readonly update_infrastructure_network_infrastructure_link_many?: Maybe<ReadonlyArray<Maybe<InfrastructureNetworkInfrastructureLinkMutationResponse>>>;
  /** update data of the table: "infrastructure_network.vehicle_submode_on_infrastructure_link" */
  readonly update_infrastructure_network_vehicle_submode_on_infrastructure_link?: Maybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMutationResponse>;
  /** update single row of the table: "infrastructure_network.vehicle_submode_on_infrastructure_link" */
  readonly update_infrastructure_network_vehicle_submode_on_infrastructure_link_by_pk?: Maybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
  /** update multiples rows of table: "infrastructure_network.vehicle_submode_on_infrastructure_link" */
  readonly update_infrastructure_network_vehicle_submode_on_infrastructure_link_many?: Maybe<ReadonlyArray<Maybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkMutationResponse>>>;
  /** update data of the table: "journey_pattern.journey_pattern" */
  readonly update_journey_pattern_journey_pattern?: Maybe<JourneyPatternJourneyPatternMutationResponse>;
  /** update single row of the table: "journey_pattern.journey_pattern" */
  readonly update_journey_pattern_journey_pattern_by_pk?: Maybe<JourneyPatternJourneyPattern>;
  /** update multiples rows of table: "journey_pattern.journey_pattern" */
  readonly update_journey_pattern_journey_pattern_many?: Maybe<ReadonlyArray<Maybe<JourneyPatternJourneyPatternMutationResponse>>>;
  /** update data of the table: "journey_pattern.scheduled_stop_point_in_journey_pattern" */
  readonly update_journey_pattern_scheduled_stop_point_in_journey_pattern?: Maybe<JourneyPatternScheduledStopPointInJourneyPatternMutationResponse>;
  /** update single row of the table: "journey_pattern.scheduled_stop_point_in_journey_pattern" */
  readonly update_journey_pattern_scheduled_stop_point_in_journey_pattern_by_pk?: Maybe<JourneyPatternScheduledStopPointInJourneyPattern>;
  /** update multiples rows of table: "journey_pattern.scheduled_stop_point_in_journey_pattern" */
  readonly update_journey_pattern_scheduled_stop_point_in_journey_pattern_many?: Maybe<ReadonlyArray<Maybe<JourneyPatternScheduledStopPointInJourneyPatternMutationResponse>>>;
  /** update data of the table: "reusable_components.vehicle_mode" */
  readonly update_reusable_components_vehicle_mode?: Maybe<ReusableComponentsVehicleModeMutationResponse>;
  /** update single row of the table: "reusable_components.vehicle_mode" */
  readonly update_reusable_components_vehicle_mode_by_pk?: Maybe<ReusableComponentsVehicleMode>;
  /** update multiples rows of table: "reusable_components.vehicle_mode" */
  readonly update_reusable_components_vehicle_mode_many?: Maybe<ReadonlyArray<Maybe<ReusableComponentsVehicleModeMutationResponse>>>;
  /** update data of the table: "reusable_components.vehicle_submode" */
  readonly update_reusable_components_vehicle_submode?: Maybe<ReusableComponentsVehicleSubmodeMutationResponse>;
  /** update single row of the table: "reusable_components.vehicle_submode" */
  readonly update_reusable_components_vehicle_submode_by_pk?: Maybe<ReusableComponentsVehicleSubmode>;
  /** update multiples rows of table: "reusable_components.vehicle_submode" */
  readonly update_reusable_components_vehicle_submode_many?: Maybe<ReadonlyArray<Maybe<ReusableComponentsVehicleSubmodeMutationResponse>>>;
  /** update data of the table: "route.direction" */
  readonly update_route_direction?: Maybe<RouteDirectionMutationResponse>;
  /** update single row of the table: "route.direction" */
  readonly update_route_direction_by_pk?: Maybe<RouteDirection>;
  /** update multiples rows of table: "route.direction" */
  readonly update_route_direction_many?: Maybe<ReadonlyArray<Maybe<RouteDirectionMutationResponse>>>;
  /** update data of the table: "route.infrastructure_link_along_route" */
  readonly update_route_infrastructure_link_along_route?: Maybe<RouteInfrastructureLinkAlongRouteMutationResponse>;
  /** update single row of the table: "route.infrastructure_link_along_route" */
  readonly update_route_infrastructure_link_along_route_by_pk?: Maybe<RouteInfrastructureLinkAlongRoute>;
  /** update multiples rows of table: "route.infrastructure_link_along_route" */
  readonly update_route_infrastructure_link_along_route_many?: Maybe<ReadonlyArray<Maybe<RouteInfrastructureLinkAlongRouteMutationResponse>>>;
  /** update data of the table: "route.line" */
  readonly update_route_line?: Maybe<RouteLineMutationResponse>;
  /** update single row of the table: "route.line" */
  readonly update_route_line_by_pk?: Maybe<RouteLine>;
  /** update multiples rows of table: "route.line" */
  readonly update_route_line_many?: Maybe<ReadonlyArray<Maybe<RouteLineMutationResponse>>>;
  /** update data of the table: "route.route" */
  readonly update_route_route?: Maybe<RouteRouteMutationResponse>;
  /** update single row of the table: "route.route" */
  readonly update_route_route_by_pk?: Maybe<RouteRoute>;
  /** update multiples rows of table: "route.route" */
  readonly update_route_route_many?: Maybe<ReadonlyArray<Maybe<RouteRouteMutationResponse>>>;
  /** update data of the table: "route.type_of_line" */
  readonly update_route_type_of_line?: Maybe<RouteTypeOfLineMutationResponse>;
  /** update single row of the table: "route.type_of_line" */
  readonly update_route_type_of_line_by_pk?: Maybe<RouteTypeOfLine>;
  /** update multiples rows of table: "route.type_of_line" */
  readonly update_route_type_of_line_many?: Maybe<ReadonlyArray<Maybe<RouteTypeOfLineMutationResponse>>>;
  /** update data of the table: "service_pattern.distance_between_stops_calculation" */
  readonly update_service_pattern_distance_between_stops_calculation?: Maybe<ServicePatternDistanceBetweenStopsCalculationMutationResponse>;
  /** update single row of the table: "service_pattern.distance_between_stops_calculation" */
  readonly update_service_pattern_distance_between_stops_calculation_by_pk?: Maybe<ServicePatternDistanceBetweenStopsCalculation>;
  /** update multiples rows of table: "service_pattern.distance_between_stops_calculation" */
  readonly update_service_pattern_distance_between_stops_calculation_many?: Maybe<ReadonlyArray<Maybe<ServicePatternDistanceBetweenStopsCalculationMutationResponse>>>;
  /** update data of the table: "service_pattern.scheduled_stop_point" */
  readonly update_service_pattern_scheduled_stop_point?: Maybe<ServicePatternScheduledStopPointMutationResponse>;
  /** update single row of the table: "service_pattern.scheduled_stop_point" */
  readonly update_service_pattern_scheduled_stop_point_by_pk?: Maybe<ServicePatternScheduledStopPoint>;
  /** update multiples rows of table: "service_pattern.scheduled_stop_point" */
  readonly update_service_pattern_scheduled_stop_point_many?: Maybe<ReadonlyArray<Maybe<ServicePatternScheduledStopPointMutationResponse>>>;
  /** update data of the table: "service_pattern.vehicle_mode_on_scheduled_stop_point" */
  readonly update_service_pattern_vehicle_mode_on_scheduled_stop_point?: Maybe<ServicePatternVehicleModeOnScheduledStopPointMutationResponse>;
  /** update single row of the table: "service_pattern.vehicle_mode_on_scheduled_stop_point" */
  readonly update_service_pattern_vehicle_mode_on_scheduled_stop_point_by_pk?: Maybe<ServicePatternVehicleModeOnScheduledStopPoint>;
  /** update multiples rows of table: "service_pattern.vehicle_mode_on_scheduled_stop_point" */
  readonly update_service_pattern_vehicle_mode_on_scheduled_stop_point_many?: Maybe<ReadonlyArray<Maybe<ServicePatternVehicleModeOnScheduledStopPointMutationResponse>>>;
  /** update data of the table: "timing_pattern.timing_place" */
  readonly update_timing_pattern_timing_place?: Maybe<TimingPatternTimingPlaceMutationResponse>;
  /** update single row of the table: "timing_pattern.timing_place" */
  readonly update_timing_pattern_timing_place_by_pk?: Maybe<TimingPatternTimingPlace>;
  /** update multiples rows of table: "timing_pattern.timing_place" */
  readonly update_timing_pattern_timing_place_many?: Maybe<ReadonlyArray<Maybe<TimingPatternTimingPlaceMutationResponse>>>;
};


/** mutation root */
export type MutationRootCombineTimetablesArgs = {
  arg1: CombineTimetablesInput;
};


/** mutation root */
export type MutationRootDeleteHslRouteLegacyHslMunicipalityCodeArgs = {
  where: HslRouteLegacyHslMunicipalityCodeBoolExp;
};


/** mutation root */
export type MutationRootDeleteHslRouteLegacyHslMunicipalityCodeByPkArgs = {
  hsl_municipality: Scalars['String']['input'];
};


/** mutation root */
export type MutationRootDeleteHslRouteTransportTargetArgs = {
  where: HslRouteTransportTargetBoolExp;
};


/** mutation root */
export type MutationRootDeleteHslRouteTransportTargetByPkArgs = {
  transport_target: Scalars['String']['input'];
};


/** mutation root */
export type MutationRootDeleteInfrastructureNetworkDirectionArgs = {
  where: InfrastructureNetworkDirectionBoolExp;
};


/** mutation root */
export type MutationRootDeleteInfrastructureNetworkDirectionByPkArgs = {
  value: Scalars['String']['input'];
};


/** mutation root */
export type MutationRootDeleteInfrastructureNetworkExternalSourceArgs = {
  where: InfrastructureNetworkExternalSourceBoolExp;
};


/** mutation root */
export type MutationRootDeleteInfrastructureNetworkExternalSourceByPkArgs = {
  value: Scalars['String']['input'];
};


/** mutation root */
export type MutationRootDeleteInfrastructureNetworkInfrastructureLinkArgs = {
  where: InfrastructureNetworkInfrastructureLinkBoolExp;
};


/** mutation root */
export type MutationRootDeleteInfrastructureNetworkInfrastructureLinkByPkArgs = {
  infrastructure_link_id: Scalars['uuid']['input'];
};


/** mutation root */
export type MutationRootDeleteInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkArgs = {
  where: InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp;
};


/** mutation root */
export type MutationRootDeleteInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkByPkArgs = {
  infrastructure_link_id: Scalars['uuid']['input'];
  vehicle_submode: ReusableComponentsVehicleSubmodeEnum;
};


/** mutation root */
export type MutationRootDeleteJourneyPatternJourneyPatternArgs = {
  where: JourneyPatternJourneyPatternBoolExp;
};


/** mutation root */
export type MutationRootDeleteJourneyPatternJourneyPatternByPkArgs = {
  journey_pattern_id: Scalars['uuid']['input'];
};


/** mutation root */
export type MutationRootDeleteJourneyPatternScheduledStopPointInJourneyPatternArgs = {
  where: JourneyPatternScheduledStopPointInJourneyPatternBoolExp;
};


/** mutation root */
export type MutationRootDeleteJourneyPatternScheduledStopPointInJourneyPatternByPkArgs = {
  journey_pattern_id: Scalars['uuid']['input'];
  scheduled_stop_point_sequence: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteReusableComponentsVehicleModeArgs = {
  where: ReusableComponentsVehicleModeBoolExp;
};


/** mutation root */
export type MutationRootDeleteReusableComponentsVehicleModeByPkArgs = {
  vehicle_mode: Scalars['String']['input'];
};


/** mutation root */
export type MutationRootDeleteReusableComponentsVehicleSubmodeArgs = {
  where: ReusableComponentsVehicleSubmodeBoolExp;
};


/** mutation root */
export type MutationRootDeleteReusableComponentsVehicleSubmodeByPkArgs = {
  vehicle_submode: Scalars['String']['input'];
};


/** mutation root */
export type MutationRootDeleteRouteDirectionArgs = {
  where: RouteDirectionBoolExp;
};


/** mutation root */
export type MutationRootDeleteRouteDirectionByPkArgs = {
  direction: Scalars['String']['input'];
};


/** mutation root */
export type MutationRootDeleteRouteInfrastructureLinkAlongRouteArgs = {
  where: RouteInfrastructureLinkAlongRouteBoolExp;
};


/** mutation root */
export type MutationRootDeleteRouteInfrastructureLinkAlongRouteByPkArgs = {
  infrastructure_link_sequence: Scalars['Int']['input'];
  route_id: Scalars['uuid']['input'];
};


/** mutation root */
export type MutationRootDeleteRouteLineArgs = {
  where: RouteLineBoolExp;
};


/** mutation root */
export type MutationRootDeleteRouteLineByPkArgs = {
  line_id: Scalars['uuid']['input'];
};


/** mutation root */
export type MutationRootDeleteRouteRouteArgs = {
  where: RouteRouteBoolExp;
};


/** mutation root */
export type MutationRootDeleteRouteRouteByPkArgs = {
  route_id: Scalars['uuid']['input'];
};


/** mutation root */
export type MutationRootDeleteRouteTypeOfLineArgs = {
  where: RouteTypeOfLineBoolExp;
};


/** mutation root */
export type MutationRootDeleteRouteTypeOfLineByPkArgs = {
  type_of_line: Scalars['String']['input'];
};


/** mutation root */
export type MutationRootDeleteServicePatternDistanceBetweenStopsCalculationArgs = {
  where: ServicePatternDistanceBetweenStopsCalculationBoolExp;
};


/** mutation root */
export type MutationRootDeleteServicePatternDistanceBetweenStopsCalculationByPkArgs = {
  journey_pattern_id: Scalars['uuid']['input'];
  observation_date: Scalars['date']['input'];
  route_priority: Scalars['Int']['input'];
  stop_interval_sequence: Scalars['Int']['input'];
};


/** mutation root */
export type MutationRootDeleteServicePatternScheduledStopPointArgs = {
  where: ServicePatternScheduledStopPointBoolExp;
};


/** mutation root */
export type MutationRootDeleteServicePatternScheduledStopPointByPkArgs = {
  scheduled_stop_point_id: Scalars['uuid']['input'];
};


/** mutation root */
export type MutationRootDeleteServicePatternVehicleModeOnScheduledStopPointArgs = {
  where: ServicePatternVehicleModeOnScheduledStopPointBoolExp;
};


/** mutation root */
export type MutationRootDeleteServicePatternVehicleModeOnScheduledStopPointByPkArgs = {
  scheduled_stop_point_id: Scalars['uuid']['input'];
  vehicle_mode: ReusableComponentsVehicleModeEnum;
};


/** mutation root */
export type MutationRootDeleteTimingPatternTimingPlaceArgs = {
  where: TimingPatternTimingPlaceBoolExp;
};


/** mutation root */
export type MutationRootDeleteTimingPatternTimingPlaceByPkArgs = {
  timing_place_id: Scalars['uuid']['input'];
};


/** mutation root */
export type MutationRootInsertHslRouteLegacyHslMunicipalityCodeArgs = {
  objects: ReadonlyArray<HslRouteLegacyHslMunicipalityCodeInsertInput>;
  on_conflict?: InputMaybe<HslRouteLegacyHslMunicipalityCodeOnConflict>;
};


/** mutation root */
export type MutationRootInsertHslRouteLegacyHslMunicipalityCodeOneArgs = {
  object: HslRouteLegacyHslMunicipalityCodeInsertInput;
  on_conflict?: InputMaybe<HslRouteLegacyHslMunicipalityCodeOnConflict>;
};


/** mutation root */
export type MutationRootInsertHslRouteTransportTargetArgs = {
  objects: ReadonlyArray<HslRouteTransportTargetInsertInput>;
  on_conflict?: InputMaybe<HslRouteTransportTargetOnConflict>;
};


/** mutation root */
export type MutationRootInsertHslRouteTransportTargetOneArgs = {
  object: HslRouteTransportTargetInsertInput;
  on_conflict?: InputMaybe<HslRouteTransportTargetOnConflict>;
};


/** mutation root */
export type MutationRootInsertInfrastructureNetworkDirectionArgs = {
  objects: ReadonlyArray<InfrastructureNetworkDirectionInsertInput>;
  on_conflict?: InputMaybe<InfrastructureNetworkDirectionOnConflict>;
};


/** mutation root */
export type MutationRootInsertInfrastructureNetworkDirectionOneArgs = {
  object: InfrastructureNetworkDirectionInsertInput;
  on_conflict?: InputMaybe<InfrastructureNetworkDirectionOnConflict>;
};


/** mutation root */
export type MutationRootInsertInfrastructureNetworkExternalSourceArgs = {
  objects: ReadonlyArray<InfrastructureNetworkExternalSourceInsertInput>;
  on_conflict?: InputMaybe<InfrastructureNetworkExternalSourceOnConflict>;
};


/** mutation root */
export type MutationRootInsertInfrastructureNetworkExternalSourceOneArgs = {
  object: InfrastructureNetworkExternalSourceInsertInput;
  on_conflict?: InputMaybe<InfrastructureNetworkExternalSourceOnConflict>;
};


/** mutation root */
export type MutationRootInsertInfrastructureNetworkInfrastructureLinkArgs = {
  objects: ReadonlyArray<InfrastructureNetworkInfrastructureLinkInsertInput>;
  on_conflict?: InputMaybe<InfrastructureNetworkInfrastructureLinkOnConflict>;
};


/** mutation root */
export type MutationRootInsertInfrastructureNetworkInfrastructureLinkOneArgs = {
  object: InfrastructureNetworkInfrastructureLinkInsertInput;
  on_conflict?: InputMaybe<InfrastructureNetworkInfrastructureLinkOnConflict>;
};


/** mutation root */
export type MutationRootInsertInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkArgs = {
  objects: ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkInsertInput>;
  on_conflict?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOnConflict>;
};


/** mutation root */
export type MutationRootInsertInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOneArgs = {
  object: InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkInsertInput;
  on_conflict?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOnConflict>;
};


/** mutation root */
export type MutationRootInsertJourneyPatternJourneyPatternArgs = {
  objects: ReadonlyArray<JourneyPatternJourneyPatternInsertInput>;
  on_conflict?: InputMaybe<JourneyPatternJourneyPatternOnConflict>;
};


/** mutation root */
export type MutationRootInsertJourneyPatternJourneyPatternOneArgs = {
  object: JourneyPatternJourneyPatternInsertInput;
  on_conflict?: InputMaybe<JourneyPatternJourneyPatternOnConflict>;
};


/** mutation root */
export type MutationRootInsertJourneyPatternScheduledStopPointInJourneyPatternArgs = {
  objects: ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternInsertInput>;
  on_conflict?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternOnConflict>;
};


/** mutation root */
export type MutationRootInsertJourneyPatternScheduledStopPointInJourneyPatternOneArgs = {
  object: JourneyPatternScheduledStopPointInJourneyPatternInsertInput;
  on_conflict?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternOnConflict>;
};


/** mutation root */
export type MutationRootInsertReusableComponentsVehicleModeArgs = {
  objects: ReadonlyArray<ReusableComponentsVehicleModeInsertInput>;
  on_conflict?: InputMaybe<ReusableComponentsVehicleModeOnConflict>;
};


/** mutation root */
export type MutationRootInsertReusableComponentsVehicleModeOneArgs = {
  object: ReusableComponentsVehicleModeInsertInput;
  on_conflict?: InputMaybe<ReusableComponentsVehicleModeOnConflict>;
};


/** mutation root */
export type MutationRootInsertReusableComponentsVehicleSubmodeArgs = {
  objects: ReadonlyArray<ReusableComponentsVehicleSubmodeInsertInput>;
  on_conflict?: InputMaybe<ReusableComponentsVehicleSubmodeOnConflict>;
};


/** mutation root */
export type MutationRootInsertReusableComponentsVehicleSubmodeOneArgs = {
  object: ReusableComponentsVehicleSubmodeInsertInput;
  on_conflict?: InputMaybe<ReusableComponentsVehicleSubmodeOnConflict>;
};


/** mutation root */
export type MutationRootInsertRouteDirectionArgs = {
  objects: ReadonlyArray<RouteDirectionInsertInput>;
  on_conflict?: InputMaybe<RouteDirectionOnConflict>;
};


/** mutation root */
export type MutationRootInsertRouteDirectionOneArgs = {
  object: RouteDirectionInsertInput;
  on_conflict?: InputMaybe<RouteDirectionOnConflict>;
};


/** mutation root */
export type MutationRootInsertRouteInfrastructureLinkAlongRouteArgs = {
  objects: ReadonlyArray<RouteInfrastructureLinkAlongRouteInsertInput>;
  on_conflict?: InputMaybe<RouteInfrastructureLinkAlongRouteOnConflict>;
};


/** mutation root */
export type MutationRootInsertRouteInfrastructureLinkAlongRouteOneArgs = {
  object: RouteInfrastructureLinkAlongRouteInsertInput;
  on_conflict?: InputMaybe<RouteInfrastructureLinkAlongRouteOnConflict>;
};


/** mutation root */
export type MutationRootInsertRouteLineArgs = {
  objects: ReadonlyArray<RouteLineInsertInput>;
  on_conflict?: InputMaybe<RouteLineOnConflict>;
};


/** mutation root */
export type MutationRootInsertRouteLineOneArgs = {
  object: RouteLineInsertInput;
  on_conflict?: InputMaybe<RouteLineOnConflict>;
};


/** mutation root */
export type MutationRootInsertRouteRouteArgs = {
  objects: ReadonlyArray<RouteRouteInsertInput>;
  on_conflict?: InputMaybe<RouteRouteOnConflict>;
};


/** mutation root */
export type MutationRootInsertRouteRouteOneArgs = {
  object: RouteRouteInsertInput;
  on_conflict?: InputMaybe<RouteRouteOnConflict>;
};


/** mutation root */
export type MutationRootInsertRouteTypeOfLineArgs = {
  objects: ReadonlyArray<RouteTypeOfLineInsertInput>;
  on_conflict?: InputMaybe<RouteTypeOfLineOnConflict>;
};


/** mutation root */
export type MutationRootInsertRouteTypeOfLineOneArgs = {
  object: RouteTypeOfLineInsertInput;
  on_conflict?: InputMaybe<RouteTypeOfLineOnConflict>;
};


/** mutation root */
export type MutationRootInsertServicePatternDistanceBetweenStopsCalculationArgs = {
  objects: ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationInsertInput>;
  on_conflict?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationOnConflict>;
};


/** mutation root */
export type MutationRootInsertServicePatternDistanceBetweenStopsCalculationOneArgs = {
  object: ServicePatternDistanceBetweenStopsCalculationInsertInput;
  on_conflict?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationOnConflict>;
};


/** mutation root */
export type MutationRootInsertServicePatternScheduledStopPointArgs = {
  objects: ReadonlyArray<ServicePatternScheduledStopPointInsertInput>;
  on_conflict?: InputMaybe<ServicePatternScheduledStopPointOnConflict>;
};


/** mutation root */
export type MutationRootInsertServicePatternScheduledStopPointOneArgs = {
  object: ServicePatternScheduledStopPointInsertInput;
  on_conflict?: InputMaybe<ServicePatternScheduledStopPointOnConflict>;
};


/** mutation root */
export type MutationRootInsertServicePatternVehicleModeOnScheduledStopPointArgs = {
  objects: ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPointInsertInput>;
  on_conflict?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointOnConflict>;
};


/** mutation root */
export type MutationRootInsertServicePatternVehicleModeOnScheduledStopPointOneArgs = {
  object: ServicePatternVehicleModeOnScheduledStopPointInsertInput;
  on_conflict?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointOnConflict>;
};


/** mutation root */
export type MutationRootInsertTimingPatternTimingPlaceArgs = {
  objects: ReadonlyArray<TimingPatternTimingPlaceInsertInput>;
  on_conflict?: InputMaybe<TimingPatternTimingPlaceOnConflict>;
};


/** mutation root */
export type MutationRootInsertTimingPatternTimingPlaceOneArgs = {
  object: TimingPatternTimingPlaceInsertInput;
  on_conflict?: InputMaybe<TimingPatternTimingPlaceOnConflict>;
};


/** mutation root */
export type MutationRootReplaceTimetablesArgs = {
  arg1: ReplaceTimetablesInput;
};


/** mutation root */
export type MutationRootUpdateHslRouteLegacyHslMunicipalityCodeArgs = {
  _inc?: InputMaybe<HslRouteLegacyHslMunicipalityCodeIncInput>;
  _set?: InputMaybe<HslRouteLegacyHslMunicipalityCodeSetInput>;
  where: HslRouteLegacyHslMunicipalityCodeBoolExp;
};


/** mutation root */
export type MutationRootUpdateHslRouteLegacyHslMunicipalityCodeByPkArgs = {
  _inc?: InputMaybe<HslRouteLegacyHslMunicipalityCodeIncInput>;
  _set?: InputMaybe<HslRouteLegacyHslMunicipalityCodeSetInput>;
  pk_columns: HslRouteLegacyHslMunicipalityCodePkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateHslRouteLegacyHslMunicipalityCodeManyArgs = {
  updates: ReadonlyArray<HslRouteLegacyHslMunicipalityCodeUpdates>;
};


/** mutation root */
export type MutationRootUpdateHslRouteTransportTargetArgs = {
  _set?: InputMaybe<HslRouteTransportTargetSetInput>;
  where: HslRouteTransportTargetBoolExp;
};


/** mutation root */
export type MutationRootUpdateHslRouteTransportTargetByPkArgs = {
  _set?: InputMaybe<HslRouteTransportTargetSetInput>;
  pk_columns: HslRouteTransportTargetPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateHslRouteTransportTargetManyArgs = {
  updates: ReadonlyArray<HslRouteTransportTargetUpdates>;
};


/** mutation root */
export type MutationRootUpdateInfrastructureNetworkDirectionArgs = {
  _set?: InputMaybe<InfrastructureNetworkDirectionSetInput>;
  where: InfrastructureNetworkDirectionBoolExp;
};


/** mutation root */
export type MutationRootUpdateInfrastructureNetworkDirectionByPkArgs = {
  _set?: InputMaybe<InfrastructureNetworkDirectionSetInput>;
  pk_columns: InfrastructureNetworkDirectionPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateInfrastructureNetworkDirectionManyArgs = {
  updates: ReadonlyArray<InfrastructureNetworkDirectionUpdates>;
};


/** mutation root */
export type MutationRootUpdateInfrastructureNetworkExternalSourceArgs = {
  _set?: InputMaybe<InfrastructureNetworkExternalSourceSetInput>;
  where: InfrastructureNetworkExternalSourceBoolExp;
};


/** mutation root */
export type MutationRootUpdateInfrastructureNetworkExternalSourceByPkArgs = {
  _set?: InputMaybe<InfrastructureNetworkExternalSourceSetInput>;
  pk_columns: InfrastructureNetworkExternalSourcePkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateInfrastructureNetworkExternalSourceManyArgs = {
  updates: ReadonlyArray<InfrastructureNetworkExternalSourceUpdates>;
};


/** mutation root */
export type MutationRootUpdateInfrastructureNetworkInfrastructureLinkArgs = {
  _inc?: InputMaybe<InfrastructureNetworkInfrastructureLinkIncInput>;
  _set?: InputMaybe<InfrastructureNetworkInfrastructureLinkSetInput>;
  where: InfrastructureNetworkInfrastructureLinkBoolExp;
};


/** mutation root */
export type MutationRootUpdateInfrastructureNetworkInfrastructureLinkByPkArgs = {
  _inc?: InputMaybe<InfrastructureNetworkInfrastructureLinkIncInput>;
  _set?: InputMaybe<InfrastructureNetworkInfrastructureLinkSetInput>;
  pk_columns: InfrastructureNetworkInfrastructureLinkPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateInfrastructureNetworkInfrastructureLinkManyArgs = {
  updates: ReadonlyArray<InfrastructureNetworkInfrastructureLinkUpdates>;
};


/** mutation root */
export type MutationRootUpdateInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkArgs = {
  _set?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSetInput>;
  where: InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp;
};


/** mutation root */
export type MutationRootUpdateInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkByPkArgs = {
  _set?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSetInput>;
  pk_columns: InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkManyArgs = {
  updates: ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkUpdates>;
};


/** mutation root */
export type MutationRootUpdateJourneyPatternJourneyPatternArgs = {
  _set?: InputMaybe<JourneyPatternJourneyPatternSetInput>;
  where: JourneyPatternJourneyPatternBoolExp;
};


/** mutation root */
export type MutationRootUpdateJourneyPatternJourneyPatternByPkArgs = {
  _set?: InputMaybe<JourneyPatternJourneyPatternSetInput>;
  pk_columns: JourneyPatternJourneyPatternPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateJourneyPatternJourneyPatternManyArgs = {
  updates: ReadonlyArray<JourneyPatternJourneyPatternUpdates>;
};


/** mutation root */
export type MutationRootUpdateJourneyPatternScheduledStopPointInJourneyPatternArgs = {
  _append?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternAppendInput>;
  _delete_at_path?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternDeleteAtPathInput>;
  _delete_elem?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternDeleteElemInput>;
  _delete_key?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternDeleteKeyInput>;
  _inc?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternIncInput>;
  _prepend?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternPrependInput>;
  _set?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternSetInput>;
  where: JourneyPatternScheduledStopPointInJourneyPatternBoolExp;
};


/** mutation root */
export type MutationRootUpdateJourneyPatternScheduledStopPointInJourneyPatternByPkArgs = {
  _append?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternAppendInput>;
  _delete_at_path?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternDeleteAtPathInput>;
  _delete_elem?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternDeleteElemInput>;
  _delete_key?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternDeleteKeyInput>;
  _inc?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternIncInput>;
  _prepend?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternPrependInput>;
  _set?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternSetInput>;
  pk_columns: JourneyPatternScheduledStopPointInJourneyPatternPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateJourneyPatternScheduledStopPointInJourneyPatternManyArgs = {
  updates: ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternUpdates>;
};


/** mutation root */
export type MutationRootUpdateReusableComponentsVehicleModeArgs = {
  _set?: InputMaybe<ReusableComponentsVehicleModeSetInput>;
  where: ReusableComponentsVehicleModeBoolExp;
};


/** mutation root */
export type MutationRootUpdateReusableComponentsVehicleModeByPkArgs = {
  _set?: InputMaybe<ReusableComponentsVehicleModeSetInput>;
  pk_columns: ReusableComponentsVehicleModePkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateReusableComponentsVehicleModeManyArgs = {
  updates: ReadonlyArray<ReusableComponentsVehicleModeUpdates>;
};


/** mutation root */
export type MutationRootUpdateReusableComponentsVehicleSubmodeArgs = {
  _set?: InputMaybe<ReusableComponentsVehicleSubmodeSetInput>;
  where: ReusableComponentsVehicleSubmodeBoolExp;
};


/** mutation root */
export type MutationRootUpdateReusableComponentsVehicleSubmodeByPkArgs = {
  _set?: InputMaybe<ReusableComponentsVehicleSubmodeSetInput>;
  pk_columns: ReusableComponentsVehicleSubmodePkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateReusableComponentsVehicleSubmodeManyArgs = {
  updates: ReadonlyArray<ReusableComponentsVehicleSubmodeUpdates>;
};


/** mutation root */
export type MutationRootUpdateRouteDirectionArgs = {
  _set?: InputMaybe<RouteDirectionSetInput>;
  where: RouteDirectionBoolExp;
};


/** mutation root */
export type MutationRootUpdateRouteDirectionByPkArgs = {
  _set?: InputMaybe<RouteDirectionSetInput>;
  pk_columns: RouteDirectionPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateRouteDirectionManyArgs = {
  updates: ReadonlyArray<RouteDirectionUpdates>;
};


/** mutation root */
export type MutationRootUpdateRouteInfrastructureLinkAlongRouteArgs = {
  _inc?: InputMaybe<RouteInfrastructureLinkAlongRouteIncInput>;
  _set?: InputMaybe<RouteInfrastructureLinkAlongRouteSetInput>;
  where: RouteInfrastructureLinkAlongRouteBoolExp;
};


/** mutation root */
export type MutationRootUpdateRouteInfrastructureLinkAlongRouteByPkArgs = {
  _inc?: InputMaybe<RouteInfrastructureLinkAlongRouteIncInput>;
  _set?: InputMaybe<RouteInfrastructureLinkAlongRouteSetInput>;
  pk_columns: RouteInfrastructureLinkAlongRoutePkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateRouteInfrastructureLinkAlongRouteManyArgs = {
  updates: ReadonlyArray<RouteInfrastructureLinkAlongRouteUpdates>;
};


/** mutation root */
export type MutationRootUpdateRouteLineArgs = {
  _append?: InputMaybe<RouteLineAppendInput>;
  _delete_at_path?: InputMaybe<RouteLineDeleteAtPathInput>;
  _delete_elem?: InputMaybe<RouteLineDeleteElemInput>;
  _delete_key?: InputMaybe<RouteLineDeleteKeyInput>;
  _inc?: InputMaybe<RouteLineIncInput>;
  _prepend?: InputMaybe<RouteLinePrependInput>;
  _set?: InputMaybe<RouteLineSetInput>;
  where: RouteLineBoolExp;
};


/** mutation root */
export type MutationRootUpdateRouteLineByPkArgs = {
  _append?: InputMaybe<RouteLineAppendInput>;
  _delete_at_path?: InputMaybe<RouteLineDeleteAtPathInput>;
  _delete_elem?: InputMaybe<RouteLineDeleteElemInput>;
  _delete_key?: InputMaybe<RouteLineDeleteKeyInput>;
  _inc?: InputMaybe<RouteLineIncInput>;
  _prepend?: InputMaybe<RouteLinePrependInput>;
  _set?: InputMaybe<RouteLineSetInput>;
  pk_columns: RouteLinePkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateRouteLineManyArgs = {
  updates: ReadonlyArray<RouteLineUpdates>;
};


/** mutation root */
export type MutationRootUpdateRouteRouteArgs = {
  _append?: InputMaybe<RouteRouteAppendInput>;
  _delete_at_path?: InputMaybe<RouteRouteDeleteAtPathInput>;
  _delete_elem?: InputMaybe<RouteRouteDeleteElemInput>;
  _delete_key?: InputMaybe<RouteRouteDeleteKeyInput>;
  _inc?: InputMaybe<RouteRouteIncInput>;
  _prepend?: InputMaybe<RouteRoutePrependInput>;
  _set?: InputMaybe<RouteRouteSetInput>;
  where: RouteRouteBoolExp;
};


/** mutation root */
export type MutationRootUpdateRouteRouteByPkArgs = {
  _append?: InputMaybe<RouteRouteAppendInput>;
  _delete_at_path?: InputMaybe<RouteRouteDeleteAtPathInput>;
  _delete_elem?: InputMaybe<RouteRouteDeleteElemInput>;
  _delete_key?: InputMaybe<RouteRouteDeleteKeyInput>;
  _inc?: InputMaybe<RouteRouteIncInput>;
  _prepend?: InputMaybe<RouteRoutePrependInput>;
  _set?: InputMaybe<RouteRouteSetInput>;
  pk_columns: RouteRoutePkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateRouteRouteManyArgs = {
  updates: ReadonlyArray<RouteRouteUpdates>;
};


/** mutation root */
export type MutationRootUpdateRouteTypeOfLineArgs = {
  _set?: InputMaybe<RouteTypeOfLineSetInput>;
  where: RouteTypeOfLineBoolExp;
};


/** mutation root */
export type MutationRootUpdateRouteTypeOfLineByPkArgs = {
  _set?: InputMaybe<RouteTypeOfLineSetInput>;
  pk_columns: RouteTypeOfLinePkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateRouteTypeOfLineManyArgs = {
  updates: ReadonlyArray<RouteTypeOfLineUpdates>;
};


/** mutation root */
export type MutationRootUpdateServicePatternDistanceBetweenStopsCalculationArgs = {
  _inc?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationIncInput>;
  _set?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationSetInput>;
  where: ServicePatternDistanceBetweenStopsCalculationBoolExp;
};


/** mutation root */
export type MutationRootUpdateServicePatternDistanceBetweenStopsCalculationByPkArgs = {
  _inc?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationIncInput>;
  _set?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationSetInput>;
  pk_columns: ServicePatternDistanceBetweenStopsCalculationPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateServicePatternDistanceBetweenStopsCalculationManyArgs = {
  updates: ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationUpdates>;
};


/** mutation root */
export type MutationRootUpdateServicePatternScheduledStopPointArgs = {
  _inc?: InputMaybe<ServicePatternScheduledStopPointIncInput>;
  _set?: InputMaybe<ServicePatternScheduledStopPointSetInput>;
  where: ServicePatternScheduledStopPointBoolExp;
};


/** mutation root */
export type MutationRootUpdateServicePatternScheduledStopPointByPkArgs = {
  _inc?: InputMaybe<ServicePatternScheduledStopPointIncInput>;
  _set?: InputMaybe<ServicePatternScheduledStopPointSetInput>;
  pk_columns: ServicePatternScheduledStopPointPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateServicePatternScheduledStopPointManyArgs = {
  updates: ReadonlyArray<ServicePatternScheduledStopPointUpdates>;
};


/** mutation root */
export type MutationRootUpdateServicePatternVehicleModeOnScheduledStopPointArgs = {
  _set?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointSetInput>;
  where: ServicePatternVehicleModeOnScheduledStopPointBoolExp;
};


/** mutation root */
export type MutationRootUpdateServicePatternVehicleModeOnScheduledStopPointByPkArgs = {
  _set?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointSetInput>;
  pk_columns: ServicePatternVehicleModeOnScheduledStopPointPkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateServicePatternVehicleModeOnScheduledStopPointManyArgs = {
  updates: ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPointUpdates>;
};


/** mutation root */
export type MutationRootUpdateTimingPatternTimingPlaceArgs = {
  _append?: InputMaybe<TimingPatternTimingPlaceAppendInput>;
  _delete_at_path?: InputMaybe<TimingPatternTimingPlaceDeleteAtPathInput>;
  _delete_elem?: InputMaybe<TimingPatternTimingPlaceDeleteElemInput>;
  _delete_key?: InputMaybe<TimingPatternTimingPlaceDeleteKeyInput>;
  _prepend?: InputMaybe<TimingPatternTimingPlacePrependInput>;
  _set?: InputMaybe<TimingPatternTimingPlaceSetInput>;
  where: TimingPatternTimingPlaceBoolExp;
};


/** mutation root */
export type MutationRootUpdateTimingPatternTimingPlaceByPkArgs = {
  _append?: InputMaybe<TimingPatternTimingPlaceAppendInput>;
  _delete_at_path?: InputMaybe<TimingPatternTimingPlaceDeleteAtPathInput>;
  _delete_elem?: InputMaybe<TimingPatternTimingPlaceDeleteElemInput>;
  _delete_key?: InputMaybe<TimingPatternTimingPlaceDeleteKeyInput>;
  _prepend?: InputMaybe<TimingPatternTimingPlacePrependInput>;
  _set?: InputMaybe<TimingPatternTimingPlaceSetInput>;
  pk_columns: TimingPatternTimingPlacePkColumnsInput;
};


/** mutation root */
export type MutationRootUpdateTimingPatternTimingPlaceManyArgs = {
  updates: ReadonlyArray<TimingPatternTimingPlaceUpdates>;
};

/** Boolean expression to compare columns of type "name". All fields are combined with logical 'AND'. */
export type NameComparisonExp = {
  readonly _eq?: InputMaybe<Scalars['name']['input']>;
  readonly _gt?: InputMaybe<Scalars['name']['input']>;
  readonly _gte?: InputMaybe<Scalars['name']['input']>;
  readonly _in?: InputMaybe<ReadonlyArray<Scalars['name']['input']>>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _lt?: InputMaybe<Scalars['name']['input']>;
  readonly _lte?: InputMaybe<Scalars['name']['input']>;
  readonly _neq?: InputMaybe<Scalars['name']['input']>;
  readonly _nin?: InputMaybe<ReadonlyArray<Scalars['name']['input']>>;
};

/** Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'. */
export type NumericComparisonExp = {
  readonly _eq?: InputMaybe<Scalars['numeric']['input']>;
  readonly _gt?: InputMaybe<Scalars['numeric']['input']>;
  readonly _gte?: InputMaybe<Scalars['numeric']['input']>;
  readonly _in?: InputMaybe<ReadonlyArray<Scalars['numeric']['input']>>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _lt?: InputMaybe<Scalars['numeric']['input']>;
  readonly _lte?: InputMaybe<Scalars['numeric']['input']>;
  readonly _neq?: InputMaybe<Scalars['numeric']['input']>;
  readonly _nin?: InputMaybe<ReadonlyArray<Scalars['numeric']['input']>>;
};

/** column ordering options */
export enum OrderBy {
  /** in ascending order, nulls last */
  Asc = 'asc',
  /** in ascending order, nulls first */
  AscNullsFirst = 'asc_nulls_first',
  /** in ascending order, nulls last */
  AscNullsLast = 'asc_nulls_last',
  /** in descending order, nulls first */
  Desc = 'desc',
  /** in descending order, nulls first */
  DescNullsFirst = 'desc_nulls_first',
  /** in descending order, nulls last */
  DescNullsLast = 'desc_nulls_last'
}

export type ParkingAlternativeNamesAggregateBoolExp = {
  readonly count?: InputMaybe<ParkingAlternativeNamesAggregateBoolExpCount>;
};

export type ParkingAlternativeNamesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAlternativeNamesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseParkingAlternativeNamesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type ParkingAreaAlternativeNamesAggregateBoolExp = {
  readonly count?: InputMaybe<ParkingAreaAlternativeNamesAggregateBoolExpCount>;
};

export type ParkingAreaAlternativeNamesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaAlternativeNamesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type ParkingAreaEquipmentPlacesAggregateBoolExp = {
  readonly count?: InputMaybe<ParkingAreaEquipmentPlacesAggregateBoolExpCount>;
};

export type ParkingAreaEquipmentPlacesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlacesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type ParkingAreaKeyValuesAggregateBoolExp = {
  readonly count?: InputMaybe<ParkingAreaKeyValuesAggregateBoolExpCount>;
};

export type ParkingAreaKeyValuesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaKeyValuesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseParkingAreaKeyValuesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type ParkingEquipmentPlacesAggregateBoolExp = {
  readonly count?: InputMaybe<ParkingEquipmentPlacesAggregateBoolExpCount>;
};

export type ParkingEquipmentPlacesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseParkingEquipmentPlacesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseParkingEquipmentPlacesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type ParkingKeyValuesAggregateBoolExp = {
  readonly count?: InputMaybe<ParkingKeyValuesAggregateBoolExpCount>;
};

export type ParkingKeyValuesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseParkingKeyValuesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseParkingKeyValuesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type ParkingParkingAreasAggregateBoolExp = {
  readonly count?: InputMaybe<ParkingParkingAreasAggregateBoolExpCount>;
};

export type ParkingParkingAreasAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingAreasSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseParkingParkingAreasBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type ParkingParkingPaymentProcessAggregateBoolExp = {
  readonly count?: InputMaybe<ParkingParkingPaymentProcessAggregateBoolExpCount>;
};

export type ParkingParkingPaymentProcessAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPaymentProcessSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type ParkingParkingPropertiesAggregateBoolExp = {
  readonly count?: InputMaybe<ParkingParkingPropertiesAggregateBoolExpCount>;
};

export type ParkingParkingPropertiesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPropertiesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseParkingParkingPropertiesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type ParkingParkingVehicleTypesAggregateBoolExp = {
  readonly count?: InputMaybe<ParkingParkingVehicleTypesAggregateBoolExpCount>;
};

export type ParkingParkingVehicleTypesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingVehicleTypesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type PassingTimesTimetabledPassingTimeAggregateBoolExp = {
  readonly count?: InputMaybe<PassingTimesTimetabledPassingTimeAggregateBoolExpCount>;
};

export type PassingTimesTimetabledPassingTimeAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<TimetablesPassingTimesTimetabledPassingTimeSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type QuayAlternativeNamesAggregateBoolExp = {
  readonly count?: InputMaybe<QuayAlternativeNamesAggregateBoolExpCount>;
};

export type QuayAlternativeNamesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseQuayAlternativeNamesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseQuayAlternativeNamesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type QuayBoardingPositionsAggregateBoolExp = {
  readonly count?: InputMaybe<QuayBoardingPositionsAggregateBoolExpCount>;
};

export type QuayBoardingPositionsAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseQuayBoardingPositionsSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseQuayBoardingPositionsBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type QuayEquipmentPlacesAggregateBoolExp = {
  readonly count?: InputMaybe<QuayEquipmentPlacesAggregateBoolExpCount>;
};

export type QuayEquipmentPlacesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseQuayEquipmentPlacesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseQuayEquipmentPlacesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type QuayKeyValuesAggregateBoolExp = {
  readonly count?: InputMaybe<QuayKeyValuesAggregateBoolExpCount>;
};

export type QuayKeyValuesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseQuayKeyValuesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseQuayKeyValuesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type QueryRoot = {
  readonly __typename?: 'query_root';
  /** fetch data from the table: "hsl_route.legacy_hsl_municipality_code" */
  readonly hsl_route_legacy_hsl_municipality_code: ReadonlyArray<HslRouteLegacyHslMunicipalityCode>;
  /** fetch aggregated fields from the table: "hsl_route.legacy_hsl_municipality_code" */
  readonly hsl_route_legacy_hsl_municipality_code_aggregate: HslRouteLegacyHslMunicipalityCodeAggregate;
  /** fetch data from the table: "hsl_route.legacy_hsl_municipality_code" using primary key columns */
  readonly hsl_route_legacy_hsl_municipality_code_by_pk?: Maybe<HslRouteLegacyHslMunicipalityCode>;
  /** fetch data from the table: "hsl_route.transport_target" */
  readonly hsl_route_transport_target: ReadonlyArray<HslRouteTransportTarget>;
  /** fetch aggregated fields from the table: "hsl_route.transport_target" */
  readonly hsl_route_transport_target_aggregate: HslRouteTransportTargetAggregate;
  /** fetch data from the table: "hsl_route.transport_target" using primary key columns */
  readonly hsl_route_transport_target_by_pk?: Maybe<HslRouteTransportTarget>;
  /** fetch data from the table: "infrastructure_network.direction" */
  readonly infrastructure_network_direction: ReadonlyArray<InfrastructureNetworkDirection>;
  /** fetch aggregated fields from the table: "infrastructure_network.direction" */
  readonly infrastructure_network_direction_aggregate: InfrastructureNetworkDirectionAggregate;
  /** fetch data from the table: "infrastructure_network.direction" using primary key columns */
  readonly infrastructure_network_direction_by_pk?: Maybe<InfrastructureNetworkDirection>;
  /** fetch data from the table: "infrastructure_network.external_source" */
  readonly infrastructure_network_external_source: ReadonlyArray<InfrastructureNetworkExternalSource>;
  /** fetch aggregated fields from the table: "infrastructure_network.external_source" */
  readonly infrastructure_network_external_source_aggregate: InfrastructureNetworkExternalSourceAggregate;
  /** fetch data from the table: "infrastructure_network.external_source" using primary key columns */
  readonly infrastructure_network_external_source_by_pk?: Maybe<InfrastructureNetworkExternalSource>;
  /** execute function "infrastructure_network.find_point_direction_on_link" which returns "infrastructure_network.direction" */
  readonly infrastructure_network_find_point_direction_on_link: ReadonlyArray<InfrastructureNetworkDirection>;
  /** execute function "infrastructure_network.find_point_direction_on_link" and query aggregates on result of table type "infrastructure_network.direction" */
  readonly infrastructure_network_find_point_direction_on_link_aggregate: InfrastructureNetworkDirectionAggregate;
  /** fetch data from the table: "infrastructure_network.infrastructure_link" */
  readonly infrastructure_network_infrastructure_link: ReadonlyArray<InfrastructureNetworkInfrastructureLink>;
  /** fetch aggregated fields from the table: "infrastructure_network.infrastructure_link" */
  readonly infrastructure_network_infrastructure_link_aggregate: InfrastructureNetworkInfrastructureLinkAggregate;
  /** fetch data from the table: "infrastructure_network.infrastructure_link" using primary key columns */
  readonly infrastructure_network_infrastructure_link_by_pk?: Maybe<InfrastructureNetworkInfrastructureLink>;
  /** execute function "infrastructure_network.resolve_point_to_closest_link" which returns "infrastructure_network.infrastructure_link" */
  readonly infrastructure_network_resolve_point_to_closest_link: ReadonlyArray<InfrastructureNetworkInfrastructureLink>;
  /** execute function "infrastructure_network.resolve_point_to_closest_link" and query aggregates on result of table type "infrastructure_network.infrastructure_link" */
  readonly infrastructure_network_resolve_point_to_closest_link_aggregate: InfrastructureNetworkInfrastructureLinkAggregate;
  /** fetch data from the table: "infrastructure_network.vehicle_submode_on_infrastructure_link" */
  readonly infrastructure_network_vehicle_submode_on_infrastructure_link: ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
  /** fetch aggregated fields from the table: "infrastructure_network.vehicle_submode_on_infrastructure_link" */
  readonly infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate: InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregate;
  /** fetch data from the table: "infrastructure_network.vehicle_submode_on_infrastructure_link" using primary key columns */
  readonly infrastructure_network_vehicle_submode_on_infrastructure_link_by_pk?: Maybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
  /** execute function "journey_pattern.check_infra_link_stop_refs_with_new_scheduled_stop_point" which returns "journey_pattern.journey_pattern" */
  readonly journey_pattern_check_infra_link_stop_refs_with_new_scheduled_stop_point: ReadonlyArray<JourneyPatternJourneyPattern>;
  /** execute function "journey_pattern.check_infra_link_stop_refs_with_new_scheduled_stop_point" and query aggregates on result of table type "journey_pattern.journey_pattern" */
  readonly journey_pattern_check_infra_link_stop_refs_with_new_scheduled_stop_point_aggregate: JourneyPatternJourneyPatternAggregate;
  /** fetch data from the table: "journey_pattern.journey_pattern" */
  readonly journey_pattern_journey_pattern: ReadonlyArray<JourneyPatternJourneyPattern>;
  /** fetch aggregated fields from the table: "journey_pattern.journey_pattern" */
  readonly journey_pattern_journey_pattern_aggregate: JourneyPatternJourneyPatternAggregate;
  /** fetch data from the table: "journey_pattern.journey_pattern" using primary key columns */
  readonly journey_pattern_journey_pattern_by_pk?: Maybe<JourneyPatternJourneyPattern>;
  /** fetch data from the table: "journey_pattern.scheduled_stop_point_in_journey_pattern" */
  readonly journey_pattern_scheduled_stop_point_in_journey_pattern: ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPattern>;
  /** fetch aggregated fields from the table: "journey_pattern.scheduled_stop_point_in_journey_pattern" */
  readonly journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate: JourneyPatternScheduledStopPointInJourneyPatternAggregate;
  /** fetch data from the table: "journey_pattern.scheduled_stop_point_in_journey_pattern" using primary key columns */
  readonly journey_pattern_scheduled_stop_point_in_journey_pattern_by_pk?: Maybe<JourneyPatternScheduledStopPointInJourneyPattern>;
  /** fetch data from the table: "reusable_components.vehicle_mode" */
  readonly reusable_components_vehicle_mode: ReadonlyArray<ReusableComponentsVehicleMode>;
  /** fetch aggregated fields from the table: "reusable_components.vehicle_mode" */
  readonly reusable_components_vehicle_mode_aggregate: ReusableComponentsVehicleModeAggregate;
  /** fetch data from the table: "reusable_components.vehicle_mode" using primary key columns */
  readonly reusable_components_vehicle_mode_by_pk?: Maybe<ReusableComponentsVehicleMode>;
  /** fetch data from the table: "reusable_components.vehicle_submode" */
  readonly reusable_components_vehicle_submode: ReadonlyArray<ReusableComponentsVehicleSubmode>;
  /** fetch aggregated fields from the table: "reusable_components.vehicle_submode" */
  readonly reusable_components_vehicle_submode_aggregate: ReusableComponentsVehicleSubmodeAggregate;
  /** fetch data from the table: "reusable_components.vehicle_submode" using primary key columns */
  readonly reusable_components_vehicle_submode_by_pk?: Maybe<ReusableComponentsVehicleSubmode>;
  /** fetch data from the table: "route.direction" */
  readonly route_direction: ReadonlyArray<RouteDirection>;
  /** fetch aggregated fields from the table: "route.direction" */
  readonly route_direction_aggregate: RouteDirectionAggregate;
  /** fetch data from the table: "route.direction" using primary key columns */
  readonly route_direction_by_pk?: Maybe<RouteDirection>;
  /** fetch data from the table: "route.infrastructure_link_along_route" */
  readonly route_infrastructure_link_along_route: ReadonlyArray<RouteInfrastructureLinkAlongRoute>;
  /** fetch aggregated fields from the table: "route.infrastructure_link_along_route" */
  readonly route_infrastructure_link_along_route_aggregate: RouteInfrastructureLinkAlongRouteAggregate;
  /** fetch data from the table: "route.infrastructure_link_along_route" using primary key columns */
  readonly route_infrastructure_link_along_route_by_pk?: Maybe<RouteInfrastructureLinkAlongRoute>;
  /** fetch data from the table: "route.line" */
  readonly route_line: ReadonlyArray<RouteLine>;
  /** fetch aggregated fields from the table: "route.line" */
  readonly route_line_aggregate: RouteLineAggregate;
  /** fetch data from the table: "route.line" using primary key columns */
  readonly route_line_by_pk?: Maybe<RouteLine>;
  /** fetch data from the table: "route.route" */
  readonly route_route: ReadonlyArray<RouteRoute>;
  /** fetch aggregated fields from the table: "route.route" */
  readonly route_route_aggregate: RouteRouteAggregate;
  /** fetch data from the table: "route.route" using primary key columns */
  readonly route_route_by_pk?: Maybe<RouteRoute>;
  /** fetch data from the table: "route.type_of_line" */
  readonly route_type_of_line: ReadonlyArray<RouteTypeOfLine>;
  /** fetch aggregated fields from the table: "route.type_of_line" */
  readonly route_type_of_line_aggregate: RouteTypeOfLineAggregate;
  /** fetch data from the table: "route.type_of_line" using primary key columns */
  readonly route_type_of_line_by_pk?: Maybe<RouteTypeOfLine>;
  /** fetch data from the table: "service_pattern.distance_between_stops_calculation" */
  readonly service_pattern_distance_between_stops_calculation: ReadonlyArray<ServicePatternDistanceBetweenStopsCalculation>;
  /** fetch aggregated fields from the table: "service_pattern.distance_between_stops_calculation" */
  readonly service_pattern_distance_between_stops_calculation_aggregate: ServicePatternDistanceBetweenStopsCalculationAggregate;
  /** fetch data from the table: "service_pattern.distance_between_stops_calculation" using primary key columns */
  readonly service_pattern_distance_between_stops_calculation_by_pk?: Maybe<ServicePatternDistanceBetweenStopsCalculation>;
  /** execute function "service_pattern.get_distances_between_stop_points_by_routes" which returns "service_pattern.distance_between_stops_calculation" */
  readonly service_pattern_get_distances_between_stop_points_by_routes: ReadonlyArray<ServicePatternDistanceBetweenStopsCalculation>;
  /** execute function "service_pattern.get_distances_between_stop_points_by_routes" and query aggregates on result of table type "service_pattern.distance_between_stops_calculation" */
  readonly service_pattern_get_distances_between_stop_points_by_routes_aggregate: ServicePatternDistanceBetweenStopsCalculationAggregate;
  /** execute function "service_pattern.get_distances_between_stop_points_in_journey_patterns" which returns "service_pattern.distance_between_stops_calculation" */
  readonly service_pattern_get_distances_between_stop_points_in_journey_patterns: ReadonlyArray<ServicePatternDistanceBetweenStopsCalculation>;
  /** execute function "service_pattern.get_distances_between_stop_points_in_journey_patterns" and query aggregates on result of table type "service_pattern.distance_between_stops_calculation" */
  readonly service_pattern_get_distances_between_stop_points_in_journey_patterns_aggregate: ServicePatternDistanceBetweenStopsCalculationAggregate;
  /** fetch data from the table: "service_pattern.scheduled_stop_point" */
  readonly service_pattern_scheduled_stop_point: ReadonlyArray<ServicePatternScheduledStopPoint>;
  /** fetch aggregated fields from the table: "service_pattern.scheduled_stop_point" */
  readonly service_pattern_scheduled_stop_point_aggregate: ServicePatternScheduledStopPointAggregate;
  /** fetch data from the table: "service_pattern.scheduled_stop_point" using primary key columns */
  readonly service_pattern_scheduled_stop_point_by_pk?: Maybe<ServicePatternScheduledStopPoint>;
  /** fetch data from the table: "service_pattern.vehicle_mode_on_scheduled_stop_point" */
  readonly service_pattern_vehicle_mode_on_scheduled_stop_point: ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPoint>;
  /** fetch aggregated fields from the table: "service_pattern.vehicle_mode_on_scheduled_stop_point" */
  readonly service_pattern_vehicle_mode_on_scheduled_stop_point_aggregate: ServicePatternVehicleModeOnScheduledStopPointAggregate;
  /** fetch data from the table: "service_pattern.vehicle_mode_on_scheduled_stop_point" using primary key columns */
  readonly service_pattern_vehicle_mode_on_scheduled_stop_point_by_pk?: Maybe<ServicePatternVehicleModeOnScheduledStopPoint>;
  readonly stop_registry?: Maybe<StopRegistryStopPlaceRegister>;
  readonly stops_database?: Maybe<StopsDatabaseStopsDatabaseQuery>;
  readonly timetables?: Maybe<TimetablesTimetablesQuery>;
  /** fetch data from the table: "timing_pattern.timing_place" */
  readonly timing_pattern_timing_place: ReadonlyArray<TimingPatternTimingPlace>;
  /** fetch aggregated fields from the table: "timing_pattern.timing_place" */
  readonly timing_pattern_timing_place_aggregate: TimingPatternTimingPlaceAggregate;
  /** fetch data from the table: "timing_pattern.timing_place" using primary key columns */
  readonly timing_pattern_timing_place_by_pk?: Maybe<TimingPatternTimingPlace>;
  readonly toCombineTargetVehicleScheduleFrameId?: Maybe<ToCombineTargetVehicleScheduleFrameIdOutput>;
  readonly toReplaceVehicleScheduleFrameIds?: Maybe<ToReplaceVehicleScheduleFrameIdsOutput>;
};


export type QueryRootHslRouteLegacyHslMunicipalityCodeArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<HslRouteLegacyHslMunicipalityCodeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<HslRouteLegacyHslMunicipalityCodeOrderBy>>;
  where?: InputMaybe<HslRouteLegacyHslMunicipalityCodeBoolExp>;
};


export type QueryRootHslRouteLegacyHslMunicipalityCodeAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<HslRouteLegacyHslMunicipalityCodeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<HslRouteLegacyHslMunicipalityCodeOrderBy>>;
  where?: InputMaybe<HslRouteLegacyHslMunicipalityCodeBoolExp>;
};


export type QueryRootHslRouteLegacyHslMunicipalityCodeByPkArgs = {
  hsl_municipality: Scalars['String']['input'];
};


export type QueryRootHslRouteTransportTargetArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<HslRouteTransportTargetSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<HslRouteTransportTargetOrderBy>>;
  where?: InputMaybe<HslRouteTransportTargetBoolExp>;
};


export type QueryRootHslRouteTransportTargetAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<HslRouteTransportTargetSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<HslRouteTransportTargetOrderBy>>;
  where?: InputMaybe<HslRouteTransportTargetBoolExp>;
};


export type QueryRootHslRouteTransportTargetByPkArgs = {
  transport_target: Scalars['String']['input'];
};


export type QueryRootInfrastructureNetworkDirectionArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkDirectionOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkDirectionBoolExp>;
};


export type QueryRootInfrastructureNetworkDirectionAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkDirectionOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkDirectionBoolExp>;
};


export type QueryRootInfrastructureNetworkDirectionByPkArgs = {
  value: Scalars['String']['input'];
};


export type QueryRootInfrastructureNetworkExternalSourceArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkExternalSourceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkExternalSourceOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkExternalSourceBoolExp>;
};


export type QueryRootInfrastructureNetworkExternalSourceAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkExternalSourceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkExternalSourceOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkExternalSourceBoolExp>;
};


export type QueryRootInfrastructureNetworkExternalSourceByPkArgs = {
  value: Scalars['String']['input'];
};


export type QueryRootInfrastructureNetworkFindPointDirectionOnLinkArgs = {
  args: InfrastructureNetworkFindPointDirectionOnLinkArgs;
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkDirectionOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkDirectionBoolExp>;
};


export type QueryRootInfrastructureNetworkFindPointDirectionOnLinkAggregateArgs = {
  args: InfrastructureNetworkFindPointDirectionOnLinkArgs;
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkDirectionOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkDirectionBoolExp>;
};


export type QueryRootInfrastructureNetworkInfrastructureLinkArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
};


export type QueryRootInfrastructureNetworkInfrastructureLinkAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
};


export type QueryRootInfrastructureNetworkInfrastructureLinkByPkArgs = {
  infrastructure_link_id: Scalars['uuid']['input'];
};


export type QueryRootInfrastructureNetworkResolvePointToClosestLinkArgs = {
  args: InfrastructureNetworkResolvePointToClosestLinkArgs;
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
};


export type QueryRootInfrastructureNetworkResolvePointToClosestLinkAggregateArgs = {
  args: InfrastructureNetworkResolvePointToClosestLinkArgs;
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
};


export type QueryRootInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
};


export type QueryRootInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
};


export type QueryRootInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkByPkArgs = {
  infrastructure_link_id: Scalars['uuid']['input'];
  vehicle_submode: ReusableComponentsVehicleSubmodeEnum;
};


export type QueryRootJourneyPatternCheckInfraLinkStopRefsWithNewScheduledStopPointArgs = {
  args: JourneyPatternCheckInfraLinkStopRefsWithNewScheduledStopPointArgs;
  distinct_on?: InputMaybe<ReadonlyArray<JourneyPatternJourneyPatternSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<JourneyPatternJourneyPatternOrderBy>>;
  where?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
};


export type QueryRootJourneyPatternCheckInfraLinkStopRefsWithNewScheduledStopPointAggregateArgs = {
  args: JourneyPatternCheckInfraLinkStopRefsWithNewScheduledStopPointArgs;
  distinct_on?: InputMaybe<ReadonlyArray<JourneyPatternJourneyPatternSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<JourneyPatternJourneyPatternOrderBy>>;
  where?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
};


export type QueryRootJourneyPatternJourneyPatternArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<JourneyPatternJourneyPatternSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<JourneyPatternJourneyPatternOrderBy>>;
  where?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
};


export type QueryRootJourneyPatternJourneyPatternAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<JourneyPatternJourneyPatternSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<JourneyPatternJourneyPatternOrderBy>>;
  where?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
};


export type QueryRootJourneyPatternJourneyPatternByPkArgs = {
  journey_pattern_id: Scalars['uuid']['input'];
};


export type QueryRootJourneyPatternScheduledStopPointInJourneyPatternArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternOrderBy>>;
  where?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
};


export type QueryRootJourneyPatternScheduledStopPointInJourneyPatternAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternOrderBy>>;
  where?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
};


export type QueryRootJourneyPatternScheduledStopPointInJourneyPatternByPkArgs = {
  journey_pattern_id: Scalars['uuid']['input'];
  scheduled_stop_point_sequence: Scalars['Int']['input'];
};


export type QueryRootReusableComponentsVehicleModeArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleModeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleModeOrderBy>>;
  where?: InputMaybe<ReusableComponentsVehicleModeBoolExp>;
};


export type QueryRootReusableComponentsVehicleModeAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleModeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleModeOrderBy>>;
  where?: InputMaybe<ReusableComponentsVehicleModeBoolExp>;
};


export type QueryRootReusableComponentsVehicleModeByPkArgs = {
  vehicle_mode: Scalars['String']['input'];
};


export type QueryRootReusableComponentsVehicleSubmodeArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleSubmodeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleSubmodeOrderBy>>;
  where?: InputMaybe<ReusableComponentsVehicleSubmodeBoolExp>;
};


export type QueryRootReusableComponentsVehicleSubmodeAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleSubmodeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleSubmodeOrderBy>>;
  where?: InputMaybe<ReusableComponentsVehicleSubmodeBoolExp>;
};


export type QueryRootReusableComponentsVehicleSubmodeByPkArgs = {
  vehicle_submode: Scalars['String']['input'];
};


export type QueryRootRouteDirectionArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteDirectionOrderBy>>;
  where?: InputMaybe<RouteDirectionBoolExp>;
};


export type QueryRootRouteDirectionAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteDirectionOrderBy>>;
  where?: InputMaybe<RouteDirectionBoolExp>;
};


export type QueryRootRouteDirectionByPkArgs = {
  direction: Scalars['String']['input'];
};


export type QueryRootRouteInfrastructureLinkAlongRouteArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteInfrastructureLinkAlongRouteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteInfrastructureLinkAlongRouteOrderBy>>;
  where?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
};


export type QueryRootRouteInfrastructureLinkAlongRouteAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteInfrastructureLinkAlongRouteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteInfrastructureLinkAlongRouteOrderBy>>;
  where?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
};


export type QueryRootRouteInfrastructureLinkAlongRouteByPkArgs = {
  infrastructure_link_sequence: Scalars['Int']['input'];
  route_id: Scalars['uuid']['input'];
};


export type QueryRootRouteLineArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteLineOrderBy>>;
  where?: InputMaybe<RouteLineBoolExp>;
};


export type QueryRootRouteLineAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteLineOrderBy>>;
  where?: InputMaybe<RouteLineBoolExp>;
};


export type QueryRootRouteLineByPkArgs = {
  line_id: Scalars['uuid']['input'];
};


export type QueryRootRouteRouteArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteRouteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteRouteOrderBy>>;
  where?: InputMaybe<RouteRouteBoolExp>;
};


export type QueryRootRouteRouteAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteRouteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteRouteOrderBy>>;
  where?: InputMaybe<RouteRouteBoolExp>;
};


export type QueryRootRouteRouteByPkArgs = {
  route_id: Scalars['uuid']['input'];
};


export type QueryRootRouteTypeOfLineArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteTypeOfLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteTypeOfLineOrderBy>>;
  where?: InputMaybe<RouteTypeOfLineBoolExp>;
};


export type QueryRootRouteTypeOfLineAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteTypeOfLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteTypeOfLineOrderBy>>;
  where?: InputMaybe<RouteTypeOfLineBoolExp>;
};


export type QueryRootRouteTypeOfLineByPkArgs = {
  type_of_line: Scalars['String']['input'];
};


export type QueryRootServicePatternDistanceBetweenStopsCalculationArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationOrderBy>>;
  where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
};


export type QueryRootServicePatternDistanceBetweenStopsCalculationAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationOrderBy>>;
  where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
};


export type QueryRootServicePatternDistanceBetweenStopsCalculationByPkArgs = {
  journey_pattern_id: Scalars['uuid']['input'];
  observation_date: Scalars['date']['input'];
  route_priority: Scalars['Int']['input'];
  stop_interval_sequence: Scalars['Int']['input'];
};


export type QueryRootServicePatternGetDistancesBetweenStopPointsByRoutesArgs = {
  args: ServicePatternGetDistancesBetweenStopPointsByRoutesArgs;
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationOrderBy>>;
  where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
};


export type QueryRootServicePatternGetDistancesBetweenStopPointsByRoutesAggregateArgs = {
  args: ServicePatternGetDistancesBetweenStopPointsByRoutesArgs;
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationOrderBy>>;
  where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
};


export type QueryRootServicePatternGetDistancesBetweenStopPointsInJourneyPatternsArgs = {
  args: ServicePatternGetDistancesBetweenStopPointsInJourneyPatternsArgs;
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationOrderBy>>;
  where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
};


export type QueryRootServicePatternGetDistancesBetweenStopPointsInJourneyPatternsAggregateArgs = {
  args: ServicePatternGetDistancesBetweenStopPointsInJourneyPatternsArgs;
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationOrderBy>>;
  where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
};


export type QueryRootServicePatternScheduledStopPointArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};


export type QueryRootServicePatternScheduledStopPointAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};


export type QueryRootServicePatternScheduledStopPointByPkArgs = {
  scheduled_stop_point_id: Scalars['uuid']['input'];
};


export type QueryRootServicePatternVehicleModeOnScheduledStopPointArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointBoolExp>;
};


export type QueryRootServicePatternVehicleModeOnScheduledStopPointAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointBoolExp>;
};


export type QueryRootServicePatternVehicleModeOnScheduledStopPointByPkArgs = {
  scheduled_stop_point_id: Scalars['uuid']['input'];
  vehicle_mode: ReusableComponentsVehicleModeEnum;
};


export type QueryRootTimingPatternTimingPlaceArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimingPatternTimingPlaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimingPatternTimingPlaceOrderBy>>;
  where?: InputMaybe<TimingPatternTimingPlaceBoolExp>;
};


export type QueryRootTimingPatternTimingPlaceAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimingPatternTimingPlaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimingPatternTimingPlaceOrderBy>>;
  where?: InputMaybe<TimingPatternTimingPlaceBoolExp>;
};


export type QueryRootTimingPatternTimingPlaceByPkArgs = {
  timing_place_id: Scalars['uuid']['input'];
};


export type QueryRootToCombineTargetVehicleScheduleFrameIdArgs = {
  arg1: ToCombineTargetVehicleScheduleFrameIdInput;
};


export type QueryRootToReplaceVehicleScheduleFrameIdsArgs = {
  arg1: ToReplaceVehicleScheduleFrameIdsInput;
};

/** The vehicle modes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
export type ReusableComponentsVehicleMode = {
  readonly __typename?: 'reusable_components_vehicle_mode';
  /** The vehicle mode from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
  readonly vehicle_mode: Scalars['String']['output'];
  /** An array relationship */
  readonly vehicle_submodes: ReadonlyArray<ReusableComponentsVehicleSubmode>;
  /** An aggregate relationship */
  readonly vehicle_submodes_aggregate: ReusableComponentsVehicleSubmodeAggregate;
};


/** The vehicle modes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
export type ReusableComponentsVehicleModeVehicleSubmodesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleSubmodeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleSubmodeOrderBy>>;
  where?: InputMaybe<ReusableComponentsVehicleSubmodeBoolExp>;
};


/** The vehicle modes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
export type ReusableComponentsVehicleModeVehicleSubmodesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleSubmodeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleSubmodeOrderBy>>;
  where?: InputMaybe<ReusableComponentsVehicleSubmodeBoolExp>;
};

/** aggregated selection of "reusable_components.vehicle_mode" */
export type ReusableComponentsVehicleModeAggregate = {
  readonly __typename?: 'reusable_components_vehicle_mode_aggregate';
  readonly aggregate?: Maybe<ReusableComponentsVehicleModeAggregateFields>;
  readonly nodes: ReadonlyArray<ReusableComponentsVehicleMode>;
};

/** aggregate fields of "reusable_components.vehicle_mode" */
export type ReusableComponentsVehicleModeAggregateFields = {
  readonly __typename?: 'reusable_components_vehicle_mode_aggregate_fields';
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<ReusableComponentsVehicleModeMaxFields>;
  readonly min?: Maybe<ReusableComponentsVehicleModeMinFields>;
};


/** aggregate fields of "reusable_components.vehicle_mode" */
export type ReusableComponentsVehicleModeAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleModeSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "reusable_components.vehicle_mode". All fields are combined with a logical 'AND'. */
export type ReusableComponentsVehicleModeBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleModeBoolExp>>;
  readonly _not?: InputMaybe<ReusableComponentsVehicleModeBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleModeBoolExp>>;
  readonly vehicle_mode?: InputMaybe<StringComparisonExp>;
  readonly vehicle_submodes?: InputMaybe<ReusableComponentsVehicleSubmodeBoolExp>;
  readonly vehicle_submodes_aggregate?: InputMaybe<ReusableComponentsVehicleSubmodeAggregateBoolExp>;
};

/** unique or primary key constraints on table "reusable_components.vehicle_mode" */
export enum ReusableComponentsVehicleModeConstraint {
  /** unique or primary key constraint on columns "vehicle_mode" */
  VehicleModePkey = 'vehicle_mode_pkey'
}

export enum ReusableComponentsVehicleModeEnum {
  Bus = 'bus',
  Ferry = 'ferry',
  Metro = 'metro',
  Train = 'train',
  Tram = 'tram'
}

/** Boolean expression to compare columns of type "reusable_components_vehicle_mode_enum". All fields are combined with logical 'AND'. */
export type ReusableComponentsVehicleModeEnumComparisonExp = {
  readonly _eq?: InputMaybe<ReusableComponentsVehicleModeEnum>;
  readonly _in?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleModeEnum>>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _neq?: InputMaybe<ReusableComponentsVehicleModeEnum>;
  readonly _nin?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleModeEnum>>;
};

/** input type for inserting data into table "reusable_components.vehicle_mode" */
export type ReusableComponentsVehicleModeInsertInput = {
  /** The vehicle mode from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
  readonly vehicle_mode?: InputMaybe<Scalars['String']['input']>;
  readonly vehicle_submodes?: InputMaybe<ReusableComponentsVehicleSubmodeArrRelInsertInput>;
};

/** aggregate max on columns */
export type ReusableComponentsVehicleModeMaxFields = {
  readonly __typename?: 'reusable_components_vehicle_mode_max_fields';
  /** The vehicle mode from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
  readonly vehicle_mode?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type ReusableComponentsVehicleModeMinFields = {
  readonly __typename?: 'reusable_components_vehicle_mode_min_fields';
  /** The vehicle mode from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
  readonly vehicle_mode?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "reusable_components.vehicle_mode" */
export type ReusableComponentsVehicleModeMutationResponse = {
  readonly __typename?: 'reusable_components_vehicle_mode_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<ReusableComponentsVehicleMode>;
};

/** input type for inserting object relation for remote table "reusable_components.vehicle_mode" */
export type ReusableComponentsVehicleModeObjRelInsertInput = {
  readonly data: ReusableComponentsVehicleModeInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<ReusableComponentsVehicleModeOnConflict>;
};

/** on_conflict condition type for table "reusable_components.vehicle_mode" */
export type ReusableComponentsVehicleModeOnConflict = {
  readonly constraint: ReusableComponentsVehicleModeConstraint;
  readonly update_columns?: ReadonlyArray<ReusableComponentsVehicleModeUpdateColumn>;
  readonly where?: InputMaybe<ReusableComponentsVehicleModeBoolExp>;
};

/** Ordering options when selecting data from "reusable_components.vehicle_mode". */
export type ReusableComponentsVehicleModeOrderBy = {
  readonly vehicle_mode?: InputMaybe<OrderBy>;
  readonly vehicle_submodes_aggregate?: InputMaybe<ReusableComponentsVehicleSubmodeAggregateOrderBy>;
};

/** primary key columns input for table: reusable_components.vehicle_mode */
export type ReusableComponentsVehicleModePkColumnsInput = {
  /** The vehicle mode from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
  readonly vehicle_mode: Scalars['String']['input'];
};

/** select columns of table "reusable_components.vehicle_mode" */
export enum ReusableComponentsVehicleModeSelectColumn {
  /** column name */
  VehicleMode = 'vehicle_mode'
}

/** input type for updating data in table "reusable_components.vehicle_mode" */
export type ReusableComponentsVehicleModeSetInput = {
  /** The vehicle mode from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
  readonly vehicle_mode?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "reusable_components_vehicle_mode" */
export type ReusableComponentsVehicleModeStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: ReusableComponentsVehicleModeStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ReusableComponentsVehicleModeStreamCursorValueInput = {
  /** The vehicle mode from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
  readonly vehicle_mode?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "reusable_components.vehicle_mode" */
export enum ReusableComponentsVehicleModeUpdateColumn {
  /** column name */
  VehicleMode = 'vehicle_mode'
}

export type ReusableComponentsVehicleModeUpdates = {
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<ReusableComponentsVehicleModeSetInput>;
  /** filter the rows which have to be updated */
  readonly where: ReusableComponentsVehicleModeBoolExp;
};

/** The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse */
export type ReusableComponentsVehicleSubmode = {
  readonly __typename?: 'reusable_components_vehicle_submode';
  /** The vehicle mode the vehicle submode belongs to: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
  readonly belonging_to_vehicle_mode: ReusableComponentsVehicleModeEnum;
  /** An object relationship */
  readonly vehicle_mode: ReusableComponentsVehicleMode;
  /** The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse */
  readonly vehicle_submode: Scalars['String']['output'];
  /** An array relationship */
  readonly vehicle_submode_on_infrastructure_links: ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
  /** An aggregate relationship */
  readonly vehicle_submode_on_infrastructure_links_aggregate: InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregate;
};


/** The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse */
export type ReusableComponentsVehicleSubmodeVehicleSubmodeOnInfrastructureLinksArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
};


/** The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse */
export type ReusableComponentsVehicleSubmodeVehicleSubmodeOnInfrastructureLinksAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
};

/** aggregated selection of "reusable_components.vehicle_submode" */
export type ReusableComponentsVehicleSubmodeAggregate = {
  readonly __typename?: 'reusable_components_vehicle_submode_aggregate';
  readonly aggregate?: Maybe<ReusableComponentsVehicleSubmodeAggregateFields>;
  readonly nodes: ReadonlyArray<ReusableComponentsVehicleSubmode>;
};

export type ReusableComponentsVehicleSubmodeAggregateBoolExp = {
  readonly count?: InputMaybe<ReusableComponentsVehicleSubmodeAggregateBoolExpCount>;
};

export type ReusableComponentsVehicleSubmodeAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleSubmodeSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<ReusableComponentsVehicleSubmodeBoolExp>;
  readonly predicate: IntComparisonExp;
};

/** aggregate fields of "reusable_components.vehicle_submode" */
export type ReusableComponentsVehicleSubmodeAggregateFields = {
  readonly __typename?: 'reusable_components_vehicle_submode_aggregate_fields';
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<ReusableComponentsVehicleSubmodeMaxFields>;
  readonly min?: Maybe<ReusableComponentsVehicleSubmodeMinFields>;
};


/** aggregate fields of "reusable_components.vehicle_submode" */
export type ReusableComponentsVehicleSubmodeAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleSubmodeSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "reusable_components.vehicle_submode" */
export type ReusableComponentsVehicleSubmodeAggregateOrderBy = {
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<ReusableComponentsVehicleSubmodeMaxOrderBy>;
  readonly min?: InputMaybe<ReusableComponentsVehicleSubmodeMinOrderBy>;
};

/** input type for inserting array relation for remote table "reusable_components.vehicle_submode" */
export type ReusableComponentsVehicleSubmodeArrRelInsertInput = {
  readonly data: ReadonlyArray<ReusableComponentsVehicleSubmodeInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<ReusableComponentsVehicleSubmodeOnConflict>;
};

/** Boolean expression to filter rows from the table "reusable_components.vehicle_submode". All fields are combined with a logical 'AND'. */
export type ReusableComponentsVehicleSubmodeBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleSubmodeBoolExp>>;
  readonly _not?: InputMaybe<ReusableComponentsVehicleSubmodeBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleSubmodeBoolExp>>;
  readonly belonging_to_vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnumComparisonExp>;
  readonly vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeBoolExp>;
  readonly vehicle_submode?: InputMaybe<StringComparisonExp>;
  readonly vehicle_submode_on_infrastructure_links?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
  readonly vehicle_submode_on_infrastructure_links_aggregate?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateBoolExp>;
};

/** unique or primary key constraints on table "reusable_components.vehicle_submode" */
export enum ReusableComponentsVehicleSubmodeConstraint {
  /** unique or primary key constraint on columns "vehicle_submode" */
  VehicleSubmodePkey = 'vehicle_submode_pkey'
}

export enum ReusableComponentsVehicleSubmodeEnum {
  /** bus */
  GenericBus = 'generic_bus',
  /** ferry */
  GenericFerry = 'generic_ferry',
  /** metro */
  GenericMetro = 'generic_metro',
  /** train */
  GenericTrain = 'generic_train',
  /** tram */
  GenericTram = 'generic_tram',
  /** bus */
  TallElectricBus = 'tall_electric_bus'
}

/** Boolean expression to compare columns of type "reusable_components_vehicle_submode_enum". All fields are combined with logical 'AND'. */
export type ReusableComponentsVehicleSubmodeEnumComparisonExp = {
  readonly _eq?: InputMaybe<ReusableComponentsVehicleSubmodeEnum>;
  readonly _in?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleSubmodeEnum>>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _neq?: InputMaybe<ReusableComponentsVehicleSubmodeEnum>;
  readonly _nin?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleSubmodeEnum>>;
};

/** input type for inserting data into table "reusable_components.vehicle_submode" */
export type ReusableComponentsVehicleSubmodeInsertInput = {
  /** The vehicle mode the vehicle submode belongs to: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
  readonly belonging_to_vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnum>;
  readonly vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeObjRelInsertInput>;
  /** The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse */
  readonly vehicle_submode?: InputMaybe<Scalars['String']['input']>;
  readonly vehicle_submode_on_infrastructure_links?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkArrRelInsertInput>;
};

/** aggregate max on columns */
export type ReusableComponentsVehicleSubmodeMaxFields = {
  readonly __typename?: 'reusable_components_vehicle_submode_max_fields';
  /** The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse */
  readonly vehicle_submode?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "reusable_components.vehicle_submode" */
export type ReusableComponentsVehicleSubmodeMaxOrderBy = {
  /** The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse */
  readonly vehicle_submode?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type ReusableComponentsVehicleSubmodeMinFields = {
  readonly __typename?: 'reusable_components_vehicle_submode_min_fields';
  /** The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse */
  readonly vehicle_submode?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "reusable_components.vehicle_submode" */
export type ReusableComponentsVehicleSubmodeMinOrderBy = {
  /** The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse */
  readonly vehicle_submode?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "reusable_components.vehicle_submode" */
export type ReusableComponentsVehicleSubmodeMutationResponse = {
  readonly __typename?: 'reusable_components_vehicle_submode_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<ReusableComponentsVehicleSubmode>;
};

/** input type for inserting object relation for remote table "reusable_components.vehicle_submode" */
export type ReusableComponentsVehicleSubmodeObjRelInsertInput = {
  readonly data: ReusableComponentsVehicleSubmodeInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<ReusableComponentsVehicleSubmodeOnConflict>;
};

/** on_conflict condition type for table "reusable_components.vehicle_submode" */
export type ReusableComponentsVehicleSubmodeOnConflict = {
  readonly constraint: ReusableComponentsVehicleSubmodeConstraint;
  readonly update_columns?: ReadonlyArray<ReusableComponentsVehicleSubmodeUpdateColumn>;
  readonly where?: InputMaybe<ReusableComponentsVehicleSubmodeBoolExp>;
};

/** Ordering options when selecting data from "reusable_components.vehicle_submode". */
export type ReusableComponentsVehicleSubmodeOrderBy = {
  readonly belonging_to_vehicle_mode?: InputMaybe<OrderBy>;
  readonly vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeOrderBy>;
  readonly vehicle_submode?: InputMaybe<OrderBy>;
  readonly vehicle_submode_on_infrastructure_links_aggregate?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateOrderBy>;
};

/** primary key columns input for table: reusable_components.vehicle_submode */
export type ReusableComponentsVehicleSubmodePkColumnsInput = {
  /** The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse */
  readonly vehicle_submode: Scalars['String']['input'];
};

/** select columns of table "reusable_components.vehicle_submode" */
export enum ReusableComponentsVehicleSubmodeSelectColumn {
  /** column name */
  BelongingToVehicleMode = 'belonging_to_vehicle_mode',
  /** column name */
  VehicleSubmode = 'vehicle_submode'
}

/** input type for updating data in table "reusable_components.vehicle_submode" */
export type ReusableComponentsVehicleSubmodeSetInput = {
  /** The vehicle mode the vehicle submode belongs to: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
  readonly belonging_to_vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnum>;
  /** The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse */
  readonly vehicle_submode?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "reusable_components_vehicle_submode" */
export type ReusableComponentsVehicleSubmodeStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: ReusableComponentsVehicleSubmodeStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ReusableComponentsVehicleSubmodeStreamCursorValueInput = {
  /** The vehicle mode the vehicle submode belongs to: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:1:283 */
  readonly belonging_to_vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnum>;
  /** The vehicle submode, which may have implications on which infrastructure links the vehicle can traverse */
  readonly vehicle_submode?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "reusable_components.vehicle_submode" */
export enum ReusableComponentsVehicleSubmodeUpdateColumn {
  /** column name */
  BelongingToVehicleMode = 'belonging_to_vehicle_mode',
  /** column name */
  VehicleSubmode = 'vehicle_submode'
}

export type ReusableComponentsVehicleSubmodeUpdates = {
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<ReusableComponentsVehicleSubmodeSetInput>;
  /** filter the rows which have to be updated */
  readonly where: ReusableComponentsVehicleSubmodeBoolExp;
};

/** The route directions from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:480 */
export type RouteDirection = {
  readonly __typename?: 'route_direction';
  /** The name of the route direction. */
  readonly direction: Scalars['String']['output'];
  /** An object relationship */
  readonly directionByTheOppositeOfDirection?: Maybe<RouteDirection>;
  /** An array relationship */
  readonly directions: ReadonlyArray<RouteDirection>;
  /** An aggregate relationship */
  readonly directions_aggregate: RouteDirectionAggregate;
  /** The opposite direction. */
  readonly the_opposite_of_direction?: Maybe<RouteDirectionEnum>;
};


/** The route directions from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:480 */
export type RouteDirectionDirectionsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteDirectionOrderBy>>;
  where?: InputMaybe<RouteDirectionBoolExp>;
};


/** The route directions from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:480 */
export type RouteDirectionDirectionsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteDirectionOrderBy>>;
  where?: InputMaybe<RouteDirectionBoolExp>;
};

/** aggregated selection of "route.direction" */
export type RouteDirectionAggregate = {
  readonly __typename?: 'route_direction_aggregate';
  readonly aggregate?: Maybe<RouteDirectionAggregateFields>;
  readonly nodes: ReadonlyArray<RouteDirection>;
};

export type RouteDirectionAggregateBoolExp = {
  readonly count?: InputMaybe<RouteDirectionAggregateBoolExpCount>;
};

export type RouteDirectionAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<RouteDirectionSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<RouteDirectionBoolExp>;
  readonly predicate: IntComparisonExp;
};

/** aggregate fields of "route.direction" */
export type RouteDirectionAggregateFields = {
  readonly __typename?: 'route_direction_aggregate_fields';
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<RouteDirectionMaxFields>;
  readonly min?: Maybe<RouteDirectionMinFields>;
};


/** aggregate fields of "route.direction" */
export type RouteDirectionAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<RouteDirectionSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "route.direction" */
export type RouteDirectionAggregateOrderBy = {
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<RouteDirectionMaxOrderBy>;
  readonly min?: InputMaybe<RouteDirectionMinOrderBy>;
};

/** input type for inserting array relation for remote table "route.direction" */
export type RouteDirectionArrRelInsertInput = {
  readonly data: ReadonlyArray<RouteDirectionInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<RouteDirectionOnConflict>;
};

/** Boolean expression to filter rows from the table "route.direction". All fields are combined with a logical 'AND'. */
export type RouteDirectionBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<RouteDirectionBoolExp>>;
  readonly _not?: InputMaybe<RouteDirectionBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<RouteDirectionBoolExp>>;
  readonly direction?: InputMaybe<StringComparisonExp>;
  readonly directionByTheOppositeOfDirection?: InputMaybe<RouteDirectionBoolExp>;
  readonly directions?: InputMaybe<RouteDirectionBoolExp>;
  readonly directions_aggregate?: InputMaybe<RouteDirectionAggregateBoolExp>;
  readonly the_opposite_of_direction?: InputMaybe<TimetablesRouteDirectionEnumComparisonExp>;
};

/** unique or primary key constraints on table "route.direction" */
export enum RouteDirectionConstraint {
  /** unique or primary key constraint on columns "direction" */
  DirectionPkey = 'direction_pkey'
}

export enum RouteDirectionEnum {
  /** clockwise */
  Anticlockwise = 'anticlockwise',
  /** anticlockwise */
  Clockwise = 'clockwise',
  /** westbound */
  Eastbound = 'eastbound',
  /** outbound */
  Inbound = 'inbound',
  /** southbound */
  Northbound = 'northbound',
  /** inbound */
  Outbound = 'outbound',
  /** northbound */
  Southbound = 'southbound',
  /** eastbound */
  Westbound = 'westbound'
}

/** input type for inserting data into table "route.direction" */
export type RouteDirectionInsertInput = {
  /** The name of the route direction. */
  readonly direction?: InputMaybe<Scalars['String']['input']>;
  readonly directionByTheOppositeOfDirection?: InputMaybe<RouteDirectionObjRelInsertInput>;
  readonly directions?: InputMaybe<RouteDirectionArrRelInsertInput>;
  /** The opposite direction. */
  readonly the_opposite_of_direction?: InputMaybe<RouteDirectionEnum>;
};

/** aggregate max on columns */
export type RouteDirectionMaxFields = {
  readonly __typename?: 'route_direction_max_fields';
  /** The name of the route direction. */
  readonly direction?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "route.direction" */
export type RouteDirectionMaxOrderBy = {
  /** The name of the route direction. */
  readonly direction?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type RouteDirectionMinFields = {
  readonly __typename?: 'route_direction_min_fields';
  /** The name of the route direction. */
  readonly direction?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "route.direction" */
export type RouteDirectionMinOrderBy = {
  /** The name of the route direction. */
  readonly direction?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "route.direction" */
export type RouteDirectionMutationResponse = {
  readonly __typename?: 'route_direction_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<RouteDirection>;
};

/** input type for inserting object relation for remote table "route.direction" */
export type RouteDirectionObjRelInsertInput = {
  readonly data: RouteDirectionInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<RouteDirectionOnConflict>;
};

/** on_conflict condition type for table "route.direction" */
export type RouteDirectionOnConflict = {
  readonly constraint: RouteDirectionConstraint;
  readonly update_columns?: ReadonlyArray<RouteDirectionUpdateColumn>;
  readonly where?: InputMaybe<RouteDirectionBoolExp>;
};

/** Ordering options when selecting data from "route.direction". */
export type RouteDirectionOrderBy = {
  readonly direction?: InputMaybe<OrderBy>;
  readonly directionByTheOppositeOfDirection?: InputMaybe<RouteDirectionOrderBy>;
  readonly directions_aggregate?: InputMaybe<RouteDirectionAggregateOrderBy>;
  readonly the_opposite_of_direction?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: route.direction */
export type RouteDirectionPkColumnsInput = {
  /** The name of the route direction. */
  readonly direction: Scalars['String']['input'];
};

/** select columns of table "route.direction" */
export enum RouteDirectionSelectColumn {
  /** column name */
  Direction = 'direction',
  /** column name */
  TheOppositeOfDirection = 'the_opposite_of_direction'
}

/** input type for updating data in table "route.direction" */
export type RouteDirectionSetInput = {
  /** The name of the route direction. */
  readonly direction?: InputMaybe<Scalars['String']['input']>;
  /** The opposite direction. */
  readonly the_opposite_of_direction?: InputMaybe<RouteDirectionEnum>;
};

/** Streaming cursor of the table "route_direction" */
export type RouteDirectionStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: RouteDirectionStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type RouteDirectionStreamCursorValueInput = {
  /** The name of the route direction. */
  readonly direction?: InputMaybe<Scalars['String']['input']>;
  /** The opposite direction. */
  readonly the_opposite_of_direction?: InputMaybe<RouteDirectionEnum>;
};

/** update columns of table "route.direction" */
export enum RouteDirectionUpdateColumn {
  /** column name */
  Direction = 'direction',
  /** column name */
  TheOppositeOfDirection = 'the_opposite_of_direction'
}

export type RouteDirectionUpdates = {
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<RouteDirectionSetInput>;
  /** filter the rows which have to be updated */
  readonly where: RouteDirectionBoolExp;
};

/** The infrastructure links along which the routes are defined. */
export type RouteInfrastructureLinkAlongRoute = {
  readonly __typename?: 'route_infrastructure_link_along_route';
  /** An object relationship */
  readonly infrastructure_link: InfrastructureNetworkInfrastructureLink;
  /** The ID of the infrastructure link. */
  readonly infrastructure_link_id: Scalars['uuid']['output'];
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence: Scalars['Int']['output'];
  /** Is the infrastructure link traversed in the direction of its linestring? */
  readonly is_traversal_forwards: Scalars['Boolean']['output'];
  /** The ID of the route. */
  readonly route_id: Scalars['uuid']['output'];
};

/** aggregated selection of "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteAggregate = {
  readonly __typename?: 'route_infrastructure_link_along_route_aggregate';
  readonly aggregate?: Maybe<RouteInfrastructureLinkAlongRouteAggregateFields>;
  readonly nodes: ReadonlyArray<RouteInfrastructureLinkAlongRoute>;
};

export type RouteInfrastructureLinkAlongRouteAggregateBoolExp = {
  readonly bool_and?: InputMaybe<RouteInfrastructureLinkAlongRouteAggregateBoolExpBoolAnd>;
  readonly bool_or?: InputMaybe<RouteInfrastructureLinkAlongRouteAggregateBoolExpBoolOr>;
  readonly count?: InputMaybe<RouteInfrastructureLinkAlongRouteAggregateBoolExpCount>;
};

export type RouteInfrastructureLinkAlongRouteAggregateBoolExpBoolAnd = {
  readonly arguments: RouteInfrastructureLinkAlongRouteSelectColumnRouteInfrastructureLinkAlongRouteAggregateBoolExpBoolAndArgumentsColumns;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
  readonly predicate: BooleanComparisonExp;
};

export type RouteInfrastructureLinkAlongRouteAggregateBoolExpBoolOr = {
  readonly arguments: RouteInfrastructureLinkAlongRouteSelectColumnRouteInfrastructureLinkAlongRouteAggregateBoolExpBoolOrArgumentsColumns;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
  readonly predicate: BooleanComparisonExp;
};

export type RouteInfrastructureLinkAlongRouteAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<RouteInfrastructureLinkAlongRouteSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
  readonly predicate: IntComparisonExp;
};

/** aggregate fields of "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteAggregateFields = {
  readonly __typename?: 'route_infrastructure_link_along_route_aggregate_fields';
  readonly avg?: Maybe<RouteInfrastructureLinkAlongRouteAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<RouteInfrastructureLinkAlongRouteMaxFields>;
  readonly min?: Maybe<RouteInfrastructureLinkAlongRouteMinFields>;
  readonly stddev?: Maybe<RouteInfrastructureLinkAlongRouteStddevFields>;
  readonly stddev_pop?: Maybe<RouteInfrastructureLinkAlongRouteStddevPopFields>;
  readonly stddev_samp?: Maybe<RouteInfrastructureLinkAlongRouteStddevSampFields>;
  readonly sum?: Maybe<RouteInfrastructureLinkAlongRouteSumFields>;
  readonly var_pop?: Maybe<RouteInfrastructureLinkAlongRouteVarPopFields>;
  readonly var_samp?: Maybe<RouteInfrastructureLinkAlongRouteVarSampFields>;
  readonly variance?: Maybe<RouteInfrastructureLinkAlongRouteVarianceFields>;
};


/** aggregate fields of "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<RouteInfrastructureLinkAlongRouteSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteAggregateOrderBy = {
  readonly avg?: InputMaybe<RouteInfrastructureLinkAlongRouteAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<RouteInfrastructureLinkAlongRouteMaxOrderBy>;
  readonly min?: InputMaybe<RouteInfrastructureLinkAlongRouteMinOrderBy>;
  readonly stddev?: InputMaybe<RouteInfrastructureLinkAlongRouteStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<RouteInfrastructureLinkAlongRouteStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<RouteInfrastructureLinkAlongRouteStddevSampOrderBy>;
  readonly sum?: InputMaybe<RouteInfrastructureLinkAlongRouteSumOrderBy>;
  readonly var_pop?: InputMaybe<RouteInfrastructureLinkAlongRouteVarPopOrderBy>;
  readonly var_samp?: InputMaybe<RouteInfrastructureLinkAlongRouteVarSampOrderBy>;
  readonly variance?: InputMaybe<RouteInfrastructureLinkAlongRouteVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteArrRelInsertInput = {
  readonly data: ReadonlyArray<RouteInfrastructureLinkAlongRouteInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<RouteInfrastructureLinkAlongRouteOnConflict>;
};

/** aggregate avg on columns */
export type RouteInfrastructureLinkAlongRouteAvgFields = {
  readonly __typename?: 'route_infrastructure_link_along_route_avg_fields';
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteAvgOrderBy = {
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "route.infrastructure_link_along_route". All fields are combined with a logical 'AND'. */
export type RouteInfrastructureLinkAlongRouteBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<RouteInfrastructureLinkAlongRouteBoolExp>>;
  readonly _not?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<RouteInfrastructureLinkAlongRouteBoolExp>>;
  readonly infrastructure_link?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  readonly infrastructure_link_id?: InputMaybe<UuidComparisonExp>;
  readonly infrastructure_link_sequence?: InputMaybe<IntComparisonExp>;
  readonly is_traversal_forwards?: InputMaybe<BooleanComparisonExp>;
  readonly route_id?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "route.infrastructure_link_along_route" */
export enum RouteInfrastructureLinkAlongRouteConstraint {
  /** unique or primary key constraint on columns "route_id", "infrastructure_link_sequence" */
  InfrastructureLinkAlongRoutePkey = 'infrastructure_link_along_route_pkey'
}

/** input type for incrementing numeric columns in table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteIncInput = {
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteInsertInput = {
  readonly infrastructure_link?: InputMaybe<InfrastructureNetworkInfrastructureLinkObjRelInsertInput>;
  /** The ID of the infrastructure link. */
  readonly infrastructure_link_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence?: InputMaybe<Scalars['Int']['input']>;
  /** Is the infrastructure link traversed in the direction of its linestring? */
  readonly is_traversal_forwards?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the route. */
  readonly route_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type RouteInfrastructureLinkAlongRouteMaxFields = {
  readonly __typename?: 'route_infrastructure_link_along_route_max_fields';
  /** The ID of the infrastructure link. */
  readonly infrastructure_link_id?: Maybe<Scalars['uuid']['output']>;
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence?: Maybe<Scalars['Int']['output']>;
  /** The ID of the route. */
  readonly route_id?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteMaxOrderBy = {
  /** The ID of the infrastructure link. */
  readonly infrastructure_link_id?: InputMaybe<OrderBy>;
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence?: InputMaybe<OrderBy>;
  /** The ID of the route. */
  readonly route_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type RouteInfrastructureLinkAlongRouteMinFields = {
  readonly __typename?: 'route_infrastructure_link_along_route_min_fields';
  /** The ID of the infrastructure link. */
  readonly infrastructure_link_id?: Maybe<Scalars['uuid']['output']>;
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence?: Maybe<Scalars['Int']['output']>;
  /** The ID of the route. */
  readonly route_id?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteMinOrderBy = {
  /** The ID of the infrastructure link. */
  readonly infrastructure_link_id?: InputMaybe<OrderBy>;
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence?: InputMaybe<OrderBy>;
  /** The ID of the route. */
  readonly route_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteMutationResponse = {
  readonly __typename?: 'route_infrastructure_link_along_route_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<RouteInfrastructureLinkAlongRoute>;
};

/** on_conflict condition type for table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteOnConflict = {
  readonly constraint: RouteInfrastructureLinkAlongRouteConstraint;
  readonly update_columns?: ReadonlyArray<RouteInfrastructureLinkAlongRouteUpdateColumn>;
  readonly where?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
};

/** Ordering options when selecting data from "route.infrastructure_link_along_route". */
export type RouteInfrastructureLinkAlongRouteOrderBy = {
  readonly infrastructure_link?: InputMaybe<InfrastructureNetworkInfrastructureLinkOrderBy>;
  readonly infrastructure_link_id?: InputMaybe<OrderBy>;
  readonly infrastructure_link_sequence?: InputMaybe<OrderBy>;
  readonly is_traversal_forwards?: InputMaybe<OrderBy>;
  readonly route_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: route.infrastructure_link_along_route */
export type RouteInfrastructureLinkAlongRoutePkColumnsInput = {
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence: Scalars['Int']['input'];
  /** The ID of the route. */
  readonly route_id: Scalars['uuid']['input'];
};

/** select columns of table "route.infrastructure_link_along_route" */
export enum RouteInfrastructureLinkAlongRouteSelectColumn {
  /** column name */
  InfrastructureLinkId = 'infrastructure_link_id',
  /** column name */
  InfrastructureLinkSequence = 'infrastructure_link_sequence',
  /** column name */
  IsTraversalForwards = 'is_traversal_forwards',
  /** column name */
  RouteId = 'route_id'
}

/** select "route_infrastructure_link_along_route_aggregate_bool_exp_bool_and_arguments_columns" columns of table "route.infrastructure_link_along_route" */
export enum RouteInfrastructureLinkAlongRouteSelectColumnRouteInfrastructureLinkAlongRouteAggregateBoolExpBoolAndArgumentsColumns {
  /** column name */
  IsTraversalForwards = 'is_traversal_forwards'
}

/** select "route_infrastructure_link_along_route_aggregate_bool_exp_bool_or_arguments_columns" columns of table "route.infrastructure_link_along_route" */
export enum RouteInfrastructureLinkAlongRouteSelectColumnRouteInfrastructureLinkAlongRouteAggregateBoolExpBoolOrArgumentsColumns {
  /** column name */
  IsTraversalForwards = 'is_traversal_forwards'
}

/** input type for updating data in table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteSetInput = {
  /** The ID of the infrastructure link. */
  readonly infrastructure_link_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence?: InputMaybe<Scalars['Int']['input']>;
  /** Is the infrastructure link traversed in the direction of its linestring? */
  readonly is_traversal_forwards?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the route. */
  readonly route_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type RouteInfrastructureLinkAlongRouteStddevFields = {
  readonly __typename?: 'route_infrastructure_link_along_route_stddev_fields';
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteStddevOrderBy = {
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type RouteInfrastructureLinkAlongRouteStddevPopFields = {
  readonly __typename?: 'route_infrastructure_link_along_route_stddev_pop_fields';
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteStddevPopOrderBy = {
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type RouteInfrastructureLinkAlongRouteStddevSampFields = {
  readonly __typename?: 'route_infrastructure_link_along_route_stddev_samp_fields';
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteStddevSampOrderBy = {
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "route_infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: RouteInfrastructureLinkAlongRouteStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type RouteInfrastructureLinkAlongRouteStreamCursorValueInput = {
  /** The ID of the infrastructure link. */
  readonly infrastructure_link_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence?: InputMaybe<Scalars['Int']['input']>;
  /** Is the infrastructure link traversed in the direction of its linestring? */
  readonly is_traversal_forwards?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the route. */
  readonly route_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type RouteInfrastructureLinkAlongRouteSumFields = {
  readonly __typename?: 'route_infrastructure_link_along_route_sum_fields';
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteSumOrderBy = {
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence?: InputMaybe<OrderBy>;
};

/** update columns of table "route.infrastructure_link_along_route" */
export enum RouteInfrastructureLinkAlongRouteUpdateColumn {
  /** column name */
  InfrastructureLinkId = 'infrastructure_link_id',
  /** column name */
  InfrastructureLinkSequence = 'infrastructure_link_sequence',
  /** column name */
  IsTraversalForwards = 'is_traversal_forwards',
  /** column name */
  RouteId = 'route_id'
}

export type RouteInfrastructureLinkAlongRouteUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<RouteInfrastructureLinkAlongRouteIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<RouteInfrastructureLinkAlongRouteSetInput>;
  /** filter the rows which have to be updated */
  readonly where: RouteInfrastructureLinkAlongRouteBoolExp;
};

/** aggregate var_pop on columns */
export type RouteInfrastructureLinkAlongRouteVarPopFields = {
  readonly __typename?: 'route_infrastructure_link_along_route_var_pop_fields';
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteVarPopOrderBy = {
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type RouteInfrastructureLinkAlongRouteVarSampFields = {
  readonly __typename?: 'route_infrastructure_link_along_route_var_samp_fields';
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteVarSampOrderBy = {
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type RouteInfrastructureLinkAlongRouteVarianceFields = {
  readonly __typename?: 'route_infrastructure_link_along_route_variance_fields';
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "route.infrastructure_link_along_route" */
export type RouteInfrastructureLinkAlongRouteVarianceOrderBy = {
  /** The order of the infrastructure link within the journey pattern. */
  readonly infrastructure_link_sequence?: InputMaybe<OrderBy>;
};

/** The line from Transmodel: http://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:487 */
export type RouteLine = {
  readonly __typename?: 'route_line';
  /** The label of the line definition. The label is unique for a certain priority and validity period. */
  readonly label: Scalars['String']['output'];
  /** An object relationship */
  readonly legacyHslMunicipalityCodeByLegacyHslMunicipalityCode?: Maybe<HslRouteLegacyHslMunicipalityCode>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  readonly legacy_hsl_municipality_code?: Maybe<Scalars['String']['output']>;
  /** The ID of the line. */
  readonly line_id: Scalars['uuid']['output'];
  /** An array relationship */
  readonly line_routes: ReadonlyArray<RouteRoute>;
  /** An aggregate relationship */
  readonly line_routes_aggregate: RouteRouteAggregate;
  /** The name of the line. Placeholder for multilingual strings. */
  readonly name_i18n: Scalars['localized_string']['output'];
  /** The mode of the vehicles used as primary on the line. */
  readonly primary_vehicle_mode: ReusableComponentsVehicleModeEnum;
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  readonly priority: Scalars['Int']['output'];
  /** The shorted name of the line. Placeholder for multilingual strings. */
  readonly short_name_i18n: Scalars['localized_string']['output'];
  /** An object relationship */
  readonly transportTargetByTransportTarget: HslRouteTransportTarget;
  readonly transport_target: HslRouteTransportTargetEnum;
  /** An object relationship */
  readonly typeOfLineByTypeOfLine: RouteTypeOfLine;
  /** The type of the line. */
  readonly type_of_line: RouteTypeOfLineEnum;
  /** The point in time from which onwards the line is no longer valid (inclusive). If NULL, the line will be always valid. */
  readonly validity_end?: Maybe<Scalars['date']['output']>;
  /** The point in time when the line becomes valid (inclusive). If NULL, the line has been always valid. */
  readonly validity_start?: Maybe<Scalars['date']['output']>;
  /** An object relationship */
  readonly vehicle_mode: ReusableComponentsVehicleMode;
};


/** The line from Transmodel: http://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:487 */
export type RouteLineLineRoutesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteRouteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteRouteOrderBy>>;
  where?: InputMaybe<RouteRouteBoolExp>;
};


/** The line from Transmodel: http://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:487 */
export type RouteLineLineRoutesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteRouteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteRouteOrderBy>>;
  where?: InputMaybe<RouteRouteBoolExp>;
};


/** The line from Transmodel: http://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:487 */
export type RouteLineNameI18nArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** The line from Transmodel: http://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:487 */
export type RouteLineShortNameI18nArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "route.line" */
export type RouteLineAggregate = {
  readonly __typename?: 'route_line_aggregate';
  readonly aggregate?: Maybe<RouteLineAggregateFields>;
  readonly nodes: ReadonlyArray<RouteLine>;
};

export type RouteLineAggregateBoolExp = {
  readonly count?: InputMaybe<RouteLineAggregateBoolExpCount>;
};

export type RouteLineAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<RouteLineSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<RouteLineBoolExp>;
  readonly predicate: IntComparisonExp;
};

/** aggregate fields of "route.line" */
export type RouteLineAggregateFields = {
  readonly __typename?: 'route_line_aggregate_fields';
  readonly avg?: Maybe<RouteLineAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<RouteLineMaxFields>;
  readonly min?: Maybe<RouteLineMinFields>;
  readonly stddev?: Maybe<RouteLineStddevFields>;
  readonly stddev_pop?: Maybe<RouteLineStddevPopFields>;
  readonly stddev_samp?: Maybe<RouteLineStddevSampFields>;
  readonly sum?: Maybe<RouteLineSumFields>;
  readonly var_pop?: Maybe<RouteLineVarPopFields>;
  readonly var_samp?: Maybe<RouteLineVarSampFields>;
  readonly variance?: Maybe<RouteLineVarianceFields>;
};


/** aggregate fields of "route.line" */
export type RouteLineAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<RouteLineSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "route.line" */
export type RouteLineAggregateOrderBy = {
  readonly avg?: InputMaybe<RouteLineAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<RouteLineMaxOrderBy>;
  readonly min?: InputMaybe<RouteLineMinOrderBy>;
  readonly stddev?: InputMaybe<RouteLineStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<RouteLineStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<RouteLineStddevSampOrderBy>;
  readonly sum?: InputMaybe<RouteLineSumOrderBy>;
  readonly var_pop?: InputMaybe<RouteLineVarPopOrderBy>;
  readonly var_samp?: InputMaybe<RouteLineVarSampOrderBy>;
  readonly variance?: InputMaybe<RouteLineVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type RouteLineAppendInput = {
  /** The name of the line. Placeholder for multilingual strings. */
  readonly name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  /** The shorted name of the line. Placeholder for multilingual strings. */
  readonly short_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "route.line" */
export type RouteLineArrRelInsertInput = {
  readonly data: ReadonlyArray<RouteLineInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<RouteLineOnConflict>;
};

/** aggregate avg on columns */
export type RouteLineAvgFields = {
  readonly __typename?: 'route_line_avg_fields';
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "route.line" */
export type RouteLineAvgOrderBy = {
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "route.line". All fields are combined with a logical 'AND'. */
export type RouteLineBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<RouteLineBoolExp>>;
  readonly _not?: InputMaybe<RouteLineBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<RouteLineBoolExp>>;
  readonly label?: InputMaybe<StringComparisonExp>;
  readonly legacyHslMunicipalityCodeByLegacyHslMunicipalityCode?: InputMaybe<HslRouteLegacyHslMunicipalityCodeBoolExp>;
  readonly legacy_hsl_municipality_code?: InputMaybe<StringComparisonExp>;
  readonly line_id?: InputMaybe<UuidComparisonExp>;
  readonly line_routes?: InputMaybe<RouteRouteBoolExp>;
  readonly line_routes_aggregate?: InputMaybe<RouteRouteAggregateBoolExp>;
  readonly name_i18n?: InputMaybe<JsonbComparisonExp>;
  readonly primary_vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnumComparisonExp>;
  readonly priority?: InputMaybe<IntComparisonExp>;
  readonly short_name_i18n?: InputMaybe<JsonbComparisonExp>;
  readonly transportTargetByTransportTarget?: InputMaybe<HslRouteTransportTargetBoolExp>;
  readonly transport_target?: InputMaybe<HslRouteTransportTargetEnumComparisonExp>;
  readonly typeOfLineByTypeOfLine?: InputMaybe<RouteTypeOfLineBoolExp>;
  readonly type_of_line?: InputMaybe<RouteTypeOfLineEnumComparisonExp>;
  readonly validity_end?: InputMaybe<DateComparisonExp>;
  readonly validity_start?: InputMaybe<DateComparisonExp>;
  readonly vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeBoolExp>;
};

/** unique or primary key constraints on table "route.line" */
export enum RouteLineConstraint {
  /** unique or primary key constraint on columns "line_id" */
  LinePkey = 'line_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type RouteLineDeleteAtPathInput = {
  /** The name of the line. Placeholder for multilingual strings. */
  readonly name_i18n?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  /** The shorted name of the line. Placeholder for multilingual strings. */
  readonly short_name_i18n?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type RouteLineDeleteElemInput = {
  /** The name of the line. Placeholder for multilingual strings. */
  readonly name_i18n?: InputMaybe<Scalars['Int']['input']>;
  /** The shorted name of the line. Placeholder for multilingual strings. */
  readonly short_name_i18n?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type RouteLineDeleteKeyInput = {
  /** The name of the line. Placeholder for multilingual strings. */
  readonly name_i18n?: InputMaybe<Scalars['String']['input']>;
  /** The shorted name of the line. Placeholder for multilingual strings. */
  readonly short_name_i18n?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "route.line" */
export type RouteLineIncInput = {
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "route.line" */
export type RouteLineInsertInput = {
  /** The label of the line definition. The label is unique for a certain priority and validity period. */
  readonly label?: InputMaybe<Scalars['String']['input']>;
  readonly legacyHslMunicipalityCodeByLegacyHslMunicipalityCode?: InputMaybe<HslRouteLegacyHslMunicipalityCodeObjRelInsertInput>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  readonly legacy_hsl_municipality_code?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the line. */
  readonly line_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly line_routes?: InputMaybe<RouteRouteArrRelInsertInput>;
  /** The name of the line. Placeholder for multilingual strings. */
  readonly name_i18n: Scalars['localized_string']['input'];
  /** The mode of the vehicles used as primary on the line. */
  readonly primary_vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnum>;
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<Scalars['Int']['input']>;
  /** The shorted name of the line. Placeholder for multilingual strings. */
  readonly short_name_i18n: Scalars['localized_string']['input'];
  readonly transportTargetByTransportTarget?: InputMaybe<HslRouteTransportTargetObjRelInsertInput>;
  readonly transport_target?: InputMaybe<HslRouteTransportTargetEnum>;
  readonly typeOfLineByTypeOfLine?: InputMaybe<RouteTypeOfLineObjRelInsertInput>;
  /** The type of the line. */
  readonly type_of_line?: InputMaybe<RouteTypeOfLineEnum>;
  /** The point in time from which onwards the line is no longer valid (inclusive). If NULL, the line will be always valid. */
  readonly validity_end?: InputMaybe<Scalars['date']['input']>;
  /** The point in time when the line becomes valid (inclusive). If NULL, the line has been always valid. */
  readonly validity_start?: InputMaybe<Scalars['date']['input']>;
  readonly vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeObjRelInsertInput>;
};

/** aggregate max on columns */
export type RouteLineMaxFields = {
  readonly __typename?: 'route_line_max_fields';
  /** The label of the line definition. The label is unique for a certain priority and validity period. */
  readonly label?: Maybe<Scalars['String']['output']>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  readonly legacy_hsl_municipality_code?: Maybe<Scalars['String']['output']>;
  /** The ID of the line. */
  readonly line_id?: Maybe<Scalars['uuid']['output']>;
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Int']['output']>;
  /** The point in time from which onwards the line is no longer valid (inclusive). If NULL, the line will be always valid. */
  readonly validity_end?: Maybe<Scalars['date']['output']>;
  /** The point in time when the line becomes valid (inclusive). If NULL, the line has been always valid. */
  readonly validity_start?: Maybe<Scalars['date']['output']>;
};

/** order by max() on columns of table "route.line" */
export type RouteLineMaxOrderBy = {
  /** The label of the line definition. The label is unique for a certain priority and validity period. */
  readonly label?: InputMaybe<OrderBy>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  readonly legacy_hsl_municipality_code?: InputMaybe<OrderBy>;
  /** The ID of the line. */
  readonly line_id?: InputMaybe<OrderBy>;
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<OrderBy>;
  /** The point in time from which onwards the line is no longer valid (inclusive). If NULL, the line will be always valid. */
  readonly validity_end?: InputMaybe<OrderBy>;
  /** The point in time when the line becomes valid (inclusive). If NULL, the line has been always valid. */
  readonly validity_start?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type RouteLineMinFields = {
  readonly __typename?: 'route_line_min_fields';
  /** The label of the line definition. The label is unique for a certain priority and validity period. */
  readonly label?: Maybe<Scalars['String']['output']>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  readonly legacy_hsl_municipality_code?: Maybe<Scalars['String']['output']>;
  /** The ID of the line. */
  readonly line_id?: Maybe<Scalars['uuid']['output']>;
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Int']['output']>;
  /** The point in time from which onwards the line is no longer valid (inclusive). If NULL, the line will be always valid. */
  readonly validity_end?: Maybe<Scalars['date']['output']>;
  /** The point in time when the line becomes valid (inclusive). If NULL, the line has been always valid. */
  readonly validity_start?: Maybe<Scalars['date']['output']>;
};

/** order by min() on columns of table "route.line" */
export type RouteLineMinOrderBy = {
  /** The label of the line definition. The label is unique for a certain priority and validity period. */
  readonly label?: InputMaybe<OrderBy>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  readonly legacy_hsl_municipality_code?: InputMaybe<OrderBy>;
  /** The ID of the line. */
  readonly line_id?: InputMaybe<OrderBy>;
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<OrderBy>;
  /** The point in time from which onwards the line is no longer valid (inclusive). If NULL, the line will be always valid. */
  readonly validity_end?: InputMaybe<OrderBy>;
  /** The point in time when the line becomes valid (inclusive). If NULL, the line has been always valid. */
  readonly validity_start?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "route.line" */
export type RouteLineMutationResponse = {
  readonly __typename?: 'route_line_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<RouteLine>;
};

/** input type for inserting object relation for remote table "route.line" */
export type RouteLineObjRelInsertInput = {
  readonly data: RouteLineInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<RouteLineOnConflict>;
};

/** on_conflict condition type for table "route.line" */
export type RouteLineOnConflict = {
  readonly constraint: RouteLineConstraint;
  readonly update_columns?: ReadonlyArray<RouteLineUpdateColumn>;
  readonly where?: InputMaybe<RouteLineBoolExp>;
};

/** Ordering options when selecting data from "route.line". */
export type RouteLineOrderBy = {
  readonly label?: InputMaybe<OrderBy>;
  readonly legacyHslMunicipalityCodeByLegacyHslMunicipalityCode?: InputMaybe<HslRouteLegacyHslMunicipalityCodeOrderBy>;
  readonly legacy_hsl_municipality_code?: InputMaybe<OrderBy>;
  readonly line_id?: InputMaybe<OrderBy>;
  readonly line_routes_aggregate?: InputMaybe<RouteRouteAggregateOrderBy>;
  readonly name_i18n?: InputMaybe<OrderBy>;
  readonly primary_vehicle_mode?: InputMaybe<OrderBy>;
  readonly priority?: InputMaybe<OrderBy>;
  readonly short_name_i18n?: InputMaybe<OrderBy>;
  readonly transportTargetByTransportTarget?: InputMaybe<HslRouteTransportTargetOrderBy>;
  readonly transport_target?: InputMaybe<OrderBy>;
  readonly typeOfLineByTypeOfLine?: InputMaybe<RouteTypeOfLineOrderBy>;
  readonly type_of_line?: InputMaybe<OrderBy>;
  readonly validity_end?: InputMaybe<OrderBy>;
  readonly validity_start?: InputMaybe<OrderBy>;
  readonly vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeOrderBy>;
};

/** primary key columns input for table: route.line */
export type RouteLinePkColumnsInput = {
  /** The ID of the line. */
  readonly line_id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type RouteLinePrependInput = {
  /** The name of the line. Placeholder for multilingual strings. */
  readonly name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  /** The shorted name of the line. Placeholder for multilingual strings. */
  readonly short_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "route.line" */
export enum RouteLineSelectColumn {
  /** column name */
  Label = 'label',
  /** column name */
  LegacyHslMunicipalityCode = 'legacy_hsl_municipality_code',
  /** column name */
  LineId = 'line_id',
  /** column name */
  NameI18n = 'name_i18n',
  /** column name */
  PrimaryVehicleMode = 'primary_vehicle_mode',
  /** column name */
  Priority = 'priority',
  /** column name */
  ShortNameI18n = 'short_name_i18n',
  /** column name */
  TransportTarget = 'transport_target',
  /** column name */
  TypeOfLine = 'type_of_line',
  /** column name */
  ValidityEnd = 'validity_end',
  /** column name */
  ValidityStart = 'validity_start'
}

/** input type for updating data in table "route.line" */
export type RouteLineSetInput = {
  /** The label of the line definition. The label is unique for a certain priority and validity period. */
  readonly label?: InputMaybe<Scalars['String']['input']>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  readonly legacy_hsl_municipality_code?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the line. */
  readonly line_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The name of the line. Placeholder for multilingual strings. */
  readonly name_i18n?: InputMaybe<Scalars['localized_string']['input']>;
  /** The mode of the vehicles used as primary on the line. */
  readonly primary_vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnum>;
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<Scalars['Int']['input']>;
  /** The shorted name of the line. Placeholder for multilingual strings. */
  readonly short_name_i18n?: InputMaybe<Scalars['localized_string']['input']>;
  readonly transport_target?: InputMaybe<HslRouteTransportTargetEnum>;
  /** The type of the line. */
  readonly type_of_line?: InputMaybe<RouteTypeOfLineEnum>;
  /** The point in time from which onwards the line is no longer valid (inclusive). If NULL, the line will be always valid. */
  readonly validity_end?: InputMaybe<Scalars['date']['input']>;
  /** The point in time when the line becomes valid (inclusive). If NULL, the line has been always valid. */
  readonly validity_start?: InputMaybe<Scalars['date']['input']>;
};

/** aggregate stddev on columns */
export type RouteLineStddevFields = {
  readonly __typename?: 'route_line_stddev_fields';
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "route.line" */
export type RouteLineStddevOrderBy = {
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type RouteLineStddevPopFields = {
  readonly __typename?: 'route_line_stddev_pop_fields';
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "route.line" */
export type RouteLineStddevPopOrderBy = {
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type RouteLineStddevSampFields = {
  readonly __typename?: 'route_line_stddev_samp_fields';
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "route.line" */
export type RouteLineStddevSampOrderBy = {
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "route_line" */
export type RouteLineStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: RouteLineStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type RouteLineStreamCursorValueInput = {
  /** The label of the line definition. The label is unique for a certain priority and validity period. */
  readonly label?: InputMaybe<Scalars['String']['input']>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  readonly legacy_hsl_municipality_code?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the line. */
  readonly line_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The name of the line. Placeholder for multilingual strings. */
  readonly name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  /** The mode of the vehicles used as primary on the line. */
  readonly primary_vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnum>;
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<Scalars['Int']['input']>;
  /** The shorted name of the line. Placeholder for multilingual strings. */
  readonly short_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  readonly transport_target?: InputMaybe<HslRouteTransportTargetEnum>;
  /** The type of the line. */
  readonly type_of_line?: InputMaybe<RouteTypeOfLineEnum>;
  /** The point in time from which onwards the line is no longer valid (inclusive). If NULL, the line will be always valid. */
  readonly validity_end?: InputMaybe<Scalars['date']['input']>;
  /** The point in time when the line becomes valid (inclusive). If NULL, the line has been always valid. */
  readonly validity_start?: InputMaybe<Scalars['date']['input']>;
};

/** aggregate sum on columns */
export type RouteLineSumFields = {
  readonly __typename?: 'route_line_sum_fields';
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "route.line" */
export type RouteLineSumOrderBy = {
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<OrderBy>;
};

/** update columns of table "route.line" */
export enum RouteLineUpdateColumn {
  /** column name */
  Label = 'label',
  /** column name */
  LegacyHslMunicipalityCode = 'legacy_hsl_municipality_code',
  /** column name */
  LineId = 'line_id',
  /** column name */
  NameI18n = 'name_i18n',
  /** column name */
  PrimaryVehicleMode = 'primary_vehicle_mode',
  /** column name */
  Priority = 'priority',
  /** column name */
  ShortNameI18n = 'short_name_i18n',
  /** column name */
  TransportTarget = 'transport_target',
  /** column name */
  TypeOfLine = 'type_of_line',
  /** column name */
  ValidityEnd = 'validity_end',
  /** column name */
  ValidityStart = 'validity_start'
}

export type RouteLineUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  readonly _append?: InputMaybe<RouteLineAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  readonly _delete_at_path?: InputMaybe<RouteLineDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  readonly _delete_elem?: InputMaybe<RouteLineDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  readonly _delete_key?: InputMaybe<RouteLineDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<RouteLineIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  readonly _prepend?: InputMaybe<RouteLinePrependInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<RouteLineSetInput>;
  /** filter the rows which have to be updated */
  readonly where: RouteLineBoolExp;
};

/** aggregate var_pop on columns */
export type RouteLineVarPopFields = {
  readonly __typename?: 'route_line_var_pop_fields';
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "route.line" */
export type RouteLineVarPopOrderBy = {
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type RouteLineVarSampFields = {
  readonly __typename?: 'route_line_var_samp_fields';
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "route.line" */
export type RouteLineVarSampOrderBy = {
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type RouteLineVarianceFields = {
  readonly __typename?: 'route_line_variance_fields';
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "route.line" */
export type RouteLineVarianceOrderBy = {
  /** The priority of the line definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<OrderBy>;
};

/** The routes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:483 */
export type RouteRoute = {
  readonly __typename?: 'route_route';
  /** The description of the route in the form of starting location - destination. Placeholder for multilingual strings. */
  readonly description_i18n?: Maybe<Scalars['localized_string']['output']>;
  readonly destination_name_i18n: Scalars['localized_string']['output'];
  readonly destination_short_name_i18n: Scalars['localized_string']['output'];
  /** The direction of the route definition. */
  readonly direction: RouteDirectionEnum;
  /** An array relationship */
  readonly infrastructure_links_along_route: ReadonlyArray<RouteInfrastructureLinkAlongRoute>;
  /** An aggregate relationship */
  readonly infrastructure_links_along_route_aggregate: RouteInfrastructureLinkAlongRouteAggregate;
  /** The label of the route definition. */
  readonly label: Scalars['String']['output'];
  /** An object relationship */
  readonly legacyHslMunicipalityCodeByLegacyHslMunicipalityCode?: Maybe<HslRouteLegacyHslMunicipalityCode>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  readonly legacy_hsl_municipality_code?: Maybe<Scalars['String']['output']>;
  readonly name_i18n: Scalars['localized_string']['output'];
  /** The line to which this route belongs. */
  readonly on_line_id: Scalars['uuid']['output'];
  readonly origin_name_i18n: Scalars['localized_string']['output'];
  readonly origin_short_name_i18n: Scalars['localized_string']['output'];
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  readonly priority: Scalars['Int']['output'];
  /** The ID of the route. */
  readonly route_id: Scalars['uuid']['output'];
  /** An array relationship */
  readonly route_journey_patterns: ReadonlyArray<JourneyPatternJourneyPattern>;
  /** An aggregate relationship */
  readonly route_journey_patterns_aggregate: JourneyPatternJourneyPatternAggregate;
  /** An object relationship */
  readonly route_line: RouteLine;
  /** A computed field, executes function "route.route_shape" */
  readonly route_shape?: Maybe<Scalars['geography_linestring']['output']>;
  /** Derived from label and variant. Routes are unique for each unique label for a certain direction, priority and validity period */
  readonly unique_label: Scalars['String']['output'];
  /** The point in time (inclusive) from which onwards the route is no longer valid. If NULL, the route is valid indefinitely after the start time of the validity period. */
  readonly validity_end?: Maybe<Scalars['date']['output']>;
  /** The point in time (inclusive) when the route becomes valid. If NULL, the route has been always valid before end time of validity period. */
  readonly validity_start?: Maybe<Scalars['date']['output']>;
  /** The variant for route definition. */
  readonly variant?: Maybe<Scalars['smallint']['output']>;
};


/** The routes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:483 */
export type RouteRouteDescriptionI18nArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** The routes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:483 */
export type RouteRouteDestinationNameI18nArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** The routes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:483 */
export type RouteRouteDestinationShortNameI18nArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** The routes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:483 */
export type RouteRouteInfrastructureLinksAlongRouteArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteInfrastructureLinkAlongRouteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteInfrastructureLinkAlongRouteOrderBy>>;
  where?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
};


/** The routes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:483 */
export type RouteRouteInfrastructureLinksAlongRouteAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteInfrastructureLinkAlongRouteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteInfrastructureLinkAlongRouteOrderBy>>;
  where?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
};


/** The routes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:483 */
export type RouteRouteNameI18nArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** The routes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:483 */
export type RouteRouteOriginNameI18nArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** The routes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:483 */
export type RouteRouteOriginShortNameI18nArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** The routes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:483 */
export type RouteRouteRouteJourneyPatternsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<JourneyPatternJourneyPatternSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<JourneyPatternJourneyPatternOrderBy>>;
  where?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
};


/** The routes from Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:483 */
export type RouteRouteRouteJourneyPatternsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<JourneyPatternJourneyPatternSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<JourneyPatternJourneyPatternOrderBy>>;
  where?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
};

/** aggregated selection of "route.route" */
export type RouteRouteAggregate = {
  readonly __typename?: 'route_route_aggregate';
  readonly aggregate?: Maybe<RouteRouteAggregateFields>;
  readonly nodes: ReadonlyArray<RouteRoute>;
};

export type RouteRouteAggregateBoolExp = {
  readonly count?: InputMaybe<RouteRouteAggregateBoolExpCount>;
};

export type RouteRouteAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<RouteRouteSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<RouteRouteBoolExp>;
  readonly predicate: IntComparisonExp;
};

/** aggregate fields of "route.route" */
export type RouteRouteAggregateFields = {
  readonly __typename?: 'route_route_aggregate_fields';
  readonly avg?: Maybe<RouteRouteAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<RouteRouteMaxFields>;
  readonly min?: Maybe<RouteRouteMinFields>;
  readonly stddev?: Maybe<RouteRouteStddevFields>;
  readonly stddev_pop?: Maybe<RouteRouteStddevPopFields>;
  readonly stddev_samp?: Maybe<RouteRouteStddevSampFields>;
  readonly sum?: Maybe<RouteRouteSumFields>;
  readonly var_pop?: Maybe<RouteRouteVarPopFields>;
  readonly var_samp?: Maybe<RouteRouteVarSampFields>;
  readonly variance?: Maybe<RouteRouteVarianceFields>;
};


/** aggregate fields of "route.route" */
export type RouteRouteAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<RouteRouteSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "route.route" */
export type RouteRouteAggregateOrderBy = {
  readonly avg?: InputMaybe<RouteRouteAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<RouteRouteMaxOrderBy>;
  readonly min?: InputMaybe<RouteRouteMinOrderBy>;
  readonly stddev?: InputMaybe<RouteRouteStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<RouteRouteStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<RouteRouteStddevSampOrderBy>;
  readonly sum?: InputMaybe<RouteRouteSumOrderBy>;
  readonly var_pop?: InputMaybe<RouteRouteVarPopOrderBy>;
  readonly var_samp?: InputMaybe<RouteRouteVarSampOrderBy>;
  readonly variance?: InputMaybe<RouteRouteVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type RouteRouteAppendInput = {
  /** The description of the route in the form of starting location - destination. Placeholder for multilingual strings. */
  readonly description_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  readonly destination_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  readonly destination_short_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  readonly name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  readonly origin_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  readonly origin_short_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "route.route" */
export type RouteRouteArrRelInsertInput = {
  readonly data: ReadonlyArray<RouteRouteInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<RouteRouteOnConflict>;
};

/** aggregate avg on columns */
export type RouteRouteAvgFields = {
  readonly __typename?: 'route_route_avg_fields';
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Float']['output']>;
  /** The variant for route definition. */
  readonly variant?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "route.route" */
export type RouteRouteAvgOrderBy = {
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<OrderBy>;
  /** The variant for route definition. */
  readonly variant?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "route.route". All fields are combined with a logical 'AND'. */
export type RouteRouteBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<RouteRouteBoolExp>>;
  readonly _not?: InputMaybe<RouteRouteBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<RouteRouteBoolExp>>;
  readonly description_i18n?: InputMaybe<JsonbComparisonExp>;
  readonly destination_name_i18n?: InputMaybe<JsonbComparisonExp>;
  readonly destination_short_name_i18n?: InputMaybe<JsonbComparisonExp>;
  readonly direction?: InputMaybe<TimetablesRouteDirectionEnumComparisonExp>;
  readonly infrastructure_links_along_route?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
  readonly infrastructure_links_along_route_aggregate?: InputMaybe<RouteInfrastructureLinkAlongRouteAggregateBoolExp>;
  readonly label?: InputMaybe<StringComparisonExp>;
  readonly legacyHslMunicipalityCodeByLegacyHslMunicipalityCode?: InputMaybe<HslRouteLegacyHslMunicipalityCodeBoolExp>;
  readonly legacy_hsl_municipality_code?: InputMaybe<StringComparisonExp>;
  readonly name_i18n?: InputMaybe<JsonbComparisonExp>;
  readonly on_line_id?: InputMaybe<UuidComparisonExp>;
  readonly origin_name_i18n?: InputMaybe<JsonbComparisonExp>;
  readonly origin_short_name_i18n?: InputMaybe<JsonbComparisonExp>;
  readonly priority?: InputMaybe<IntComparisonExp>;
  readonly route_id?: InputMaybe<UuidComparisonExp>;
  readonly route_journey_patterns?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
  readonly route_journey_patterns_aggregate?: InputMaybe<JourneyPatternJourneyPatternAggregateBoolExp>;
  readonly route_line?: InputMaybe<RouteLineBoolExp>;
  readonly route_shape?: InputMaybe<GeographyComparisonExp>;
  readonly unique_label?: InputMaybe<StringComparisonExp>;
  readonly validity_end?: InputMaybe<DateComparisonExp>;
  readonly validity_start?: InputMaybe<DateComparisonExp>;
  readonly variant?: InputMaybe<SmallintComparisonExp>;
};

/** unique or primary key constraints on table "route.route" */
export enum RouteRouteConstraint {
  /** unique or primary key constraint on columns "route_id" */
  RoutePkey = 'route_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type RouteRouteDeleteAtPathInput = {
  /** The description of the route in the form of starting location - destination. Placeholder for multilingual strings. */
  readonly description_i18n?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  readonly destination_name_i18n?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  readonly destination_short_name_i18n?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  readonly name_i18n?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  readonly origin_name_i18n?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  readonly origin_short_name_i18n?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type RouteRouteDeleteElemInput = {
  /** The description of the route in the form of starting location - destination. Placeholder for multilingual strings. */
  readonly description_i18n?: InputMaybe<Scalars['Int']['input']>;
  readonly destination_name_i18n?: InputMaybe<Scalars['Int']['input']>;
  readonly destination_short_name_i18n?: InputMaybe<Scalars['Int']['input']>;
  readonly name_i18n?: InputMaybe<Scalars['Int']['input']>;
  readonly origin_name_i18n?: InputMaybe<Scalars['Int']['input']>;
  readonly origin_short_name_i18n?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type RouteRouteDeleteKeyInput = {
  /** The description of the route in the form of starting location - destination. Placeholder for multilingual strings. */
  readonly description_i18n?: InputMaybe<Scalars['String']['input']>;
  readonly destination_name_i18n?: InputMaybe<Scalars['String']['input']>;
  readonly destination_short_name_i18n?: InputMaybe<Scalars['String']['input']>;
  readonly name_i18n?: InputMaybe<Scalars['String']['input']>;
  readonly origin_name_i18n?: InputMaybe<Scalars['String']['input']>;
  readonly origin_short_name_i18n?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "route.route" */
export type RouteRouteIncInput = {
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<Scalars['Int']['input']>;
  /** The variant for route definition. */
  readonly variant?: InputMaybe<Scalars['smallint']['input']>;
};

/** input type for inserting data into table "route.route" */
export type RouteRouteInsertInput = {
  /** The description of the route in the form of starting location - destination. Placeholder for multilingual strings. */
  readonly description_i18n?: InputMaybe<Scalars['localized_string']['input']>;
  readonly destination_name_i18n: Scalars['localized_string']['input'];
  readonly destination_short_name_i18n: Scalars['localized_string']['input'];
  /** The direction of the route definition. */
  readonly direction?: InputMaybe<RouteDirectionEnum>;
  readonly infrastructure_links_along_route?: InputMaybe<RouteInfrastructureLinkAlongRouteArrRelInsertInput>;
  /** The label of the route definition. */
  readonly label: Scalars['String']['input'];
  readonly legacyHslMunicipalityCodeByLegacyHslMunicipalityCode?: InputMaybe<HslRouteLegacyHslMunicipalityCodeObjRelInsertInput>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  readonly legacy_hsl_municipality_code?: InputMaybe<Scalars['String']['input']>;
  readonly name_i18n: Scalars['localized_string']['input'];
  /** The line to which this route belongs. */
  readonly on_line_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly origin_name_i18n: Scalars['localized_string']['input'];
  readonly origin_short_name_i18n: Scalars['localized_string']['input'];
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<Scalars['Int']['input']>;
  /** The ID of the route. */
  readonly route_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly route_journey_patterns?: InputMaybe<JourneyPatternJourneyPatternArrRelInsertInput>;
  readonly route_line?: InputMaybe<RouteLineObjRelInsertInput>;
  /** The point in time (inclusive) from which onwards the route is no longer valid. If NULL, the route is valid indefinitely after the start time of the validity period. */
  readonly validity_end?: InputMaybe<Scalars['date']['input']>;
  /** The point in time (inclusive) when the route becomes valid. If NULL, the route has been always valid before end time of validity period. */
  readonly validity_start?: InputMaybe<Scalars['date']['input']>;
  /** The variant for route definition. */
  readonly variant?: InputMaybe<Scalars['smallint']['input']>;
};

/** aggregate max on columns */
export type RouteRouteMaxFields = {
  readonly __typename?: 'route_route_max_fields';
  /** The label of the route definition. */
  readonly label?: Maybe<Scalars['String']['output']>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  readonly legacy_hsl_municipality_code?: Maybe<Scalars['String']['output']>;
  /** The line to which this route belongs. */
  readonly on_line_id?: Maybe<Scalars['uuid']['output']>;
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Int']['output']>;
  /** The ID of the route. */
  readonly route_id?: Maybe<Scalars['uuid']['output']>;
  /** Derived from label and variant. Routes are unique for each unique label for a certain direction, priority and validity period */
  readonly unique_label?: Maybe<Scalars['String']['output']>;
  /** The point in time (inclusive) from which onwards the route is no longer valid. If NULL, the route is valid indefinitely after the start time of the validity period. */
  readonly validity_end?: Maybe<Scalars['date']['output']>;
  /** The point in time (inclusive) when the route becomes valid. If NULL, the route has been always valid before end time of validity period. */
  readonly validity_start?: Maybe<Scalars['date']['output']>;
  /** The variant for route definition. */
  readonly variant?: Maybe<Scalars['smallint']['output']>;
};

/** order by max() on columns of table "route.route" */
export type RouteRouteMaxOrderBy = {
  /** The label of the route definition. */
  readonly label?: InputMaybe<OrderBy>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  readonly legacy_hsl_municipality_code?: InputMaybe<OrderBy>;
  /** The line to which this route belongs. */
  readonly on_line_id?: InputMaybe<OrderBy>;
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<OrderBy>;
  /** The ID of the route. */
  readonly route_id?: InputMaybe<OrderBy>;
  /** Derived from label and variant. Routes are unique for each unique label for a certain direction, priority and validity period */
  readonly unique_label?: InputMaybe<OrderBy>;
  /** The point in time (inclusive) from which onwards the route is no longer valid. If NULL, the route is valid indefinitely after the start time of the validity period. */
  readonly validity_end?: InputMaybe<OrderBy>;
  /** The point in time (inclusive) when the route becomes valid. If NULL, the route has been always valid before end time of validity period. */
  readonly validity_start?: InputMaybe<OrderBy>;
  /** The variant for route definition. */
  readonly variant?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type RouteRouteMinFields = {
  readonly __typename?: 'route_route_min_fields';
  /** The label of the route definition. */
  readonly label?: Maybe<Scalars['String']['output']>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  readonly legacy_hsl_municipality_code?: Maybe<Scalars['String']['output']>;
  /** The line to which this route belongs. */
  readonly on_line_id?: Maybe<Scalars['uuid']['output']>;
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Int']['output']>;
  /** The ID of the route. */
  readonly route_id?: Maybe<Scalars['uuid']['output']>;
  /** Derived from label and variant. Routes are unique for each unique label for a certain direction, priority and validity period */
  readonly unique_label?: Maybe<Scalars['String']['output']>;
  /** The point in time (inclusive) from which onwards the route is no longer valid. If NULL, the route is valid indefinitely after the start time of the validity period. */
  readonly validity_end?: Maybe<Scalars['date']['output']>;
  /** The point in time (inclusive) when the route becomes valid. If NULL, the route has been always valid before end time of validity period. */
  readonly validity_start?: Maybe<Scalars['date']['output']>;
  /** The variant for route definition. */
  readonly variant?: Maybe<Scalars['smallint']['output']>;
};

/** order by min() on columns of table "route.route" */
export type RouteRouteMinOrderBy = {
  /** The label of the route definition. */
  readonly label?: InputMaybe<OrderBy>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  readonly legacy_hsl_municipality_code?: InputMaybe<OrderBy>;
  /** The line to which this route belongs. */
  readonly on_line_id?: InputMaybe<OrderBy>;
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<OrderBy>;
  /** The ID of the route. */
  readonly route_id?: InputMaybe<OrderBy>;
  /** Derived from label and variant. Routes are unique for each unique label for a certain direction, priority and validity period */
  readonly unique_label?: InputMaybe<OrderBy>;
  /** The point in time (inclusive) from which onwards the route is no longer valid. If NULL, the route is valid indefinitely after the start time of the validity period. */
  readonly validity_end?: InputMaybe<OrderBy>;
  /** The point in time (inclusive) when the route becomes valid. If NULL, the route has been always valid before end time of validity period. */
  readonly validity_start?: InputMaybe<OrderBy>;
  /** The variant for route definition. */
  readonly variant?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "route.route" */
export type RouteRouteMutationResponse = {
  readonly __typename?: 'route_route_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<RouteRoute>;
};

/** input type for inserting object relation for remote table "route.route" */
export type RouteRouteObjRelInsertInput = {
  readonly data: RouteRouteInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<RouteRouteOnConflict>;
};

/** on_conflict condition type for table "route.route" */
export type RouteRouteOnConflict = {
  readonly constraint: RouteRouteConstraint;
  readonly update_columns?: ReadonlyArray<RouteRouteUpdateColumn>;
  readonly where?: InputMaybe<RouteRouteBoolExp>;
};

/** Ordering options when selecting data from "route.route". */
export type RouteRouteOrderBy = {
  readonly description_i18n?: InputMaybe<OrderBy>;
  readonly destination_name_i18n?: InputMaybe<OrderBy>;
  readonly destination_short_name_i18n?: InputMaybe<OrderBy>;
  readonly direction?: InputMaybe<OrderBy>;
  readonly infrastructure_links_along_route_aggregate?: InputMaybe<RouteInfrastructureLinkAlongRouteAggregateOrderBy>;
  readonly label?: InputMaybe<OrderBy>;
  readonly legacyHslMunicipalityCodeByLegacyHslMunicipalityCode?: InputMaybe<HslRouteLegacyHslMunicipalityCodeOrderBy>;
  readonly legacy_hsl_municipality_code?: InputMaybe<OrderBy>;
  readonly name_i18n?: InputMaybe<OrderBy>;
  readonly on_line_id?: InputMaybe<OrderBy>;
  readonly origin_name_i18n?: InputMaybe<OrderBy>;
  readonly origin_short_name_i18n?: InputMaybe<OrderBy>;
  readonly priority?: InputMaybe<OrderBy>;
  readonly route_id?: InputMaybe<OrderBy>;
  readonly route_journey_patterns_aggregate?: InputMaybe<JourneyPatternJourneyPatternAggregateOrderBy>;
  readonly route_line?: InputMaybe<RouteLineOrderBy>;
  readonly route_shape?: InputMaybe<OrderBy>;
  readonly unique_label?: InputMaybe<OrderBy>;
  readonly validity_end?: InputMaybe<OrderBy>;
  readonly validity_start?: InputMaybe<OrderBy>;
  readonly variant?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: route.route */
export type RouteRoutePkColumnsInput = {
  /** The ID of the route. */
  readonly route_id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type RouteRoutePrependInput = {
  /** The description of the route in the form of starting location - destination. Placeholder for multilingual strings. */
  readonly description_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  readonly destination_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  readonly destination_short_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  readonly name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  readonly origin_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  readonly origin_short_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "route.route" */
export enum RouteRouteSelectColumn {
  /** column name */
  DescriptionI18n = 'description_i18n',
  /** column name */
  DestinationNameI18n = 'destination_name_i18n',
  /** column name */
  DestinationShortNameI18n = 'destination_short_name_i18n',
  /** column name */
  Direction = 'direction',
  /** column name */
  Label = 'label',
  /** column name */
  LegacyHslMunicipalityCode = 'legacy_hsl_municipality_code',
  /** column name */
  NameI18n = 'name_i18n',
  /** column name */
  OnLineId = 'on_line_id',
  /** column name */
  OriginNameI18n = 'origin_name_i18n',
  /** column name */
  OriginShortNameI18n = 'origin_short_name_i18n',
  /** column name */
  Priority = 'priority',
  /** column name */
  RouteId = 'route_id',
  /** column name */
  UniqueLabel = 'unique_label',
  /** column name */
  ValidityEnd = 'validity_end',
  /** column name */
  ValidityStart = 'validity_start',
  /** column name */
  Variant = 'variant'
}

/** input type for updating data in table "route.route" */
export type RouteRouteSetInput = {
  /** The description of the route in the form of starting location - destination. Placeholder for multilingual strings. */
  readonly description_i18n?: InputMaybe<Scalars['localized_string']['input']>;
  readonly destination_name_i18n?: InputMaybe<Scalars['localized_string']['input']>;
  readonly destination_short_name_i18n?: InputMaybe<Scalars['localized_string']['input']>;
  /** The direction of the route definition. */
  readonly direction?: InputMaybe<RouteDirectionEnum>;
  /** The label of the route definition. */
  readonly label?: InputMaybe<Scalars['String']['input']>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  readonly legacy_hsl_municipality_code?: InputMaybe<Scalars['String']['input']>;
  readonly name_i18n?: InputMaybe<Scalars['localized_string']['input']>;
  /** The line to which this route belongs. */
  readonly on_line_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly origin_name_i18n?: InputMaybe<Scalars['localized_string']['input']>;
  readonly origin_short_name_i18n?: InputMaybe<Scalars['localized_string']['input']>;
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<Scalars['Int']['input']>;
  /** The ID of the route. */
  readonly route_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The point in time (inclusive) from which onwards the route is no longer valid. If NULL, the route is valid indefinitely after the start time of the validity period. */
  readonly validity_end?: InputMaybe<Scalars['date']['input']>;
  /** The point in time (inclusive) when the route becomes valid. If NULL, the route has been always valid before end time of validity period. */
  readonly validity_start?: InputMaybe<Scalars['date']['input']>;
  /** The variant for route definition. */
  readonly variant?: InputMaybe<Scalars['smallint']['input']>;
};

/** aggregate stddev on columns */
export type RouteRouteStddevFields = {
  readonly __typename?: 'route_route_stddev_fields';
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Float']['output']>;
  /** The variant for route definition. */
  readonly variant?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "route.route" */
export type RouteRouteStddevOrderBy = {
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<OrderBy>;
  /** The variant for route definition. */
  readonly variant?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type RouteRouteStddevPopFields = {
  readonly __typename?: 'route_route_stddev_pop_fields';
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Float']['output']>;
  /** The variant for route definition. */
  readonly variant?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "route.route" */
export type RouteRouteStddevPopOrderBy = {
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<OrderBy>;
  /** The variant for route definition. */
  readonly variant?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type RouteRouteStddevSampFields = {
  readonly __typename?: 'route_route_stddev_samp_fields';
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Float']['output']>;
  /** The variant for route definition. */
  readonly variant?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "route.route" */
export type RouteRouteStddevSampOrderBy = {
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<OrderBy>;
  /** The variant for route definition. */
  readonly variant?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "route_route" */
export type RouteRouteStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: RouteRouteStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type RouteRouteStreamCursorValueInput = {
  /** The description of the route in the form of starting location - destination. Placeholder for multilingual strings. */
  readonly description_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  readonly destination_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  readonly destination_short_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  /** The direction of the route definition. */
  readonly direction?: InputMaybe<RouteDirectionEnum>;
  /** The label of the route definition. */
  readonly label?: InputMaybe<Scalars['String']['input']>;
  /** Defines the legacy municipality that is mainly used for data exports. */
  readonly legacy_hsl_municipality_code?: InputMaybe<Scalars['String']['input']>;
  readonly name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  /** The line to which this route belongs. */
  readonly on_line_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly origin_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  readonly origin_short_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<Scalars['Int']['input']>;
  /** The ID of the route. */
  readonly route_id?: InputMaybe<Scalars['uuid']['input']>;
  /** Derived from label and variant. Routes are unique for each unique label for a certain direction, priority and validity period */
  readonly unique_label?: InputMaybe<Scalars['String']['input']>;
  /** The point in time (inclusive) from which onwards the route is no longer valid. If NULL, the route is valid indefinitely after the start time of the validity period. */
  readonly validity_end?: InputMaybe<Scalars['date']['input']>;
  /** The point in time (inclusive) when the route becomes valid. If NULL, the route has been always valid before end time of validity period. */
  readonly validity_start?: InputMaybe<Scalars['date']['input']>;
  /** The variant for route definition. */
  readonly variant?: InputMaybe<Scalars['smallint']['input']>;
};

/** aggregate sum on columns */
export type RouteRouteSumFields = {
  readonly __typename?: 'route_route_sum_fields';
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Int']['output']>;
  /** The variant for route definition. */
  readonly variant?: Maybe<Scalars['smallint']['output']>;
};

/** order by sum() on columns of table "route.route" */
export type RouteRouteSumOrderBy = {
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<OrderBy>;
  /** The variant for route definition. */
  readonly variant?: InputMaybe<OrderBy>;
};

/** update columns of table "route.route" */
export enum RouteRouteUpdateColumn {
  /** column name */
  DescriptionI18n = 'description_i18n',
  /** column name */
  DestinationNameI18n = 'destination_name_i18n',
  /** column name */
  DestinationShortNameI18n = 'destination_short_name_i18n',
  /** column name */
  Direction = 'direction',
  /** column name */
  Label = 'label',
  /** column name */
  LegacyHslMunicipalityCode = 'legacy_hsl_municipality_code',
  /** column name */
  NameI18n = 'name_i18n',
  /** column name */
  OnLineId = 'on_line_id',
  /** column name */
  OriginNameI18n = 'origin_name_i18n',
  /** column name */
  OriginShortNameI18n = 'origin_short_name_i18n',
  /** column name */
  Priority = 'priority',
  /** column name */
  RouteId = 'route_id',
  /** column name */
  ValidityEnd = 'validity_end',
  /** column name */
  ValidityStart = 'validity_start',
  /** column name */
  Variant = 'variant'
}

export type RouteRouteUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  readonly _append?: InputMaybe<RouteRouteAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  readonly _delete_at_path?: InputMaybe<RouteRouteDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  readonly _delete_elem?: InputMaybe<RouteRouteDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  readonly _delete_key?: InputMaybe<RouteRouteDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<RouteRouteIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  readonly _prepend?: InputMaybe<RouteRoutePrependInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<RouteRouteSetInput>;
  /** filter the rows which have to be updated */
  readonly where: RouteRouteBoolExp;
};

/** aggregate var_pop on columns */
export type RouteRouteVarPopFields = {
  readonly __typename?: 'route_route_var_pop_fields';
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Float']['output']>;
  /** The variant for route definition. */
  readonly variant?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "route.route" */
export type RouteRouteVarPopOrderBy = {
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<OrderBy>;
  /** The variant for route definition. */
  readonly variant?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type RouteRouteVarSampFields = {
  readonly __typename?: 'route_route_var_samp_fields';
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Float']['output']>;
  /** The variant for route definition. */
  readonly variant?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "route.route" */
export type RouteRouteVarSampOrderBy = {
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<OrderBy>;
  /** The variant for route definition. */
  readonly variant?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type RouteRouteVarianceFields = {
  readonly __typename?: 'route_route_variance_fields';
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Float']['output']>;
  /** The variant for route definition. */
  readonly variant?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "route.route" */
export type RouteRouteVarianceOrderBy = {
  /** The priority of the route definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<OrderBy>;
  /** The variant for route definition. */
  readonly variant?: InputMaybe<OrderBy>;
};

/** Type of line. https://www.transmodel-cen.eu/model/EARoot/EA2/EA1/EA3/EA491.htm */
export type RouteTypeOfLine = {
  readonly __typename?: 'route_type_of_line';
  readonly belonging_to_vehicle_mode: ReusableComponentsVehicleModeEnum;
  /** An array relationship */
  readonly lines: ReadonlyArray<RouteLine>;
  /** An aggregate relationship */
  readonly lines_aggregate: RouteLineAggregate;
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  readonly type_of_line: Scalars['String']['output'];
  /** An object relationship */
  readonly vehicle_mode: ReusableComponentsVehicleMode;
};


/** Type of line. https://www.transmodel-cen.eu/model/EARoot/EA2/EA1/EA3/EA491.htm */
export type RouteTypeOfLineLinesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteLineOrderBy>>;
  where?: InputMaybe<RouteLineBoolExp>;
};


/** Type of line. https://www.transmodel-cen.eu/model/EARoot/EA2/EA1/EA3/EA491.htm */
export type RouteTypeOfLineLinesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteLineOrderBy>>;
  where?: InputMaybe<RouteLineBoolExp>;
};

/** aggregated selection of "route.type_of_line" */
export type RouteTypeOfLineAggregate = {
  readonly __typename?: 'route_type_of_line_aggregate';
  readonly aggregate?: Maybe<RouteTypeOfLineAggregateFields>;
  readonly nodes: ReadonlyArray<RouteTypeOfLine>;
};

/** aggregate fields of "route.type_of_line" */
export type RouteTypeOfLineAggregateFields = {
  readonly __typename?: 'route_type_of_line_aggregate_fields';
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<RouteTypeOfLineMaxFields>;
  readonly min?: Maybe<RouteTypeOfLineMinFields>;
};


/** aggregate fields of "route.type_of_line" */
export type RouteTypeOfLineAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<RouteTypeOfLineSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "route.type_of_line". All fields are combined with a logical 'AND'. */
export type RouteTypeOfLineBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<RouteTypeOfLineBoolExp>>;
  readonly _not?: InputMaybe<RouteTypeOfLineBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<RouteTypeOfLineBoolExp>>;
  readonly belonging_to_vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnumComparisonExp>;
  readonly lines?: InputMaybe<RouteLineBoolExp>;
  readonly lines_aggregate?: InputMaybe<RouteLineAggregateBoolExp>;
  readonly type_of_line?: InputMaybe<StringComparisonExp>;
  readonly vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeBoolExp>;
};

/** unique or primary key constraints on table "route.type_of_line" */
export enum RouteTypeOfLineConstraint {
  /** unique or primary key constraint on columns "type_of_line" */
  TypeOfLinePkey = 'type_of_line_pkey'
}

export enum RouteTypeOfLineEnum {
  /** tram */
  CityTramService = 'city_tram_service',
  /** bus */
  DemandAndResponseBusService = 'demand_and_response_bus_service',
  /** bus */
  ExpressBusService = 'express_bus_service',
  /** ferry */
  FerryService = 'ferry_service',
  /** metro */
  MetroService = 'metro_service',
  /** bus */
  RegionalBusService = 'regional_bus_service',
  /** train */
  RegionalRailService = 'regional_rail_service',
  /** tram */
  RegionalTramService = 'regional_tram_service',
  /** bus */
  SpecialNeedsBus = 'special_needs_bus',
  /** bus */
  StoppingBusService = 'stopping_bus_service',
  /** train */
  SuburbanRailway = 'suburban_railway'
}

/** Boolean expression to compare columns of type "route_type_of_line_enum". All fields are combined with logical 'AND'. */
export type RouteTypeOfLineEnumComparisonExp = {
  readonly _eq?: InputMaybe<RouteTypeOfLineEnum>;
  readonly _in?: InputMaybe<ReadonlyArray<RouteTypeOfLineEnum>>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _neq?: InputMaybe<RouteTypeOfLineEnum>;
  readonly _nin?: InputMaybe<ReadonlyArray<RouteTypeOfLineEnum>>;
};

/** input type for inserting data into table "route.type_of_line" */
export type RouteTypeOfLineInsertInput = {
  readonly belonging_to_vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnum>;
  readonly lines?: InputMaybe<RouteLineArrRelInsertInput>;
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  readonly type_of_line?: InputMaybe<Scalars['String']['input']>;
  readonly vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeObjRelInsertInput>;
};

/** aggregate max on columns */
export type RouteTypeOfLineMaxFields = {
  readonly __typename?: 'route_type_of_line_max_fields';
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  readonly type_of_line?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type RouteTypeOfLineMinFields = {
  readonly __typename?: 'route_type_of_line_min_fields';
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  readonly type_of_line?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "route.type_of_line" */
export type RouteTypeOfLineMutationResponse = {
  readonly __typename?: 'route_type_of_line_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<RouteTypeOfLine>;
};

/** input type for inserting object relation for remote table "route.type_of_line" */
export type RouteTypeOfLineObjRelInsertInput = {
  readonly data: RouteTypeOfLineInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<RouteTypeOfLineOnConflict>;
};

/** on_conflict condition type for table "route.type_of_line" */
export type RouteTypeOfLineOnConflict = {
  readonly constraint: RouteTypeOfLineConstraint;
  readonly update_columns?: ReadonlyArray<RouteTypeOfLineUpdateColumn>;
  readonly where?: InputMaybe<RouteTypeOfLineBoolExp>;
};

/** Ordering options when selecting data from "route.type_of_line". */
export type RouteTypeOfLineOrderBy = {
  readonly belonging_to_vehicle_mode?: InputMaybe<OrderBy>;
  readonly lines_aggregate?: InputMaybe<RouteLineAggregateOrderBy>;
  readonly type_of_line?: InputMaybe<OrderBy>;
  readonly vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeOrderBy>;
};

/** primary key columns input for table: route.type_of_line */
export type RouteTypeOfLinePkColumnsInput = {
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  readonly type_of_line: Scalars['String']['input'];
};

/** select columns of table "route.type_of_line" */
export enum RouteTypeOfLineSelectColumn {
  /** column name */
  BelongingToVehicleMode = 'belonging_to_vehicle_mode',
  /** column name */
  TypeOfLine = 'type_of_line'
}

/** input type for updating data in table "route.type_of_line" */
export type RouteTypeOfLineSetInput = {
  readonly belonging_to_vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnum>;
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  readonly type_of_line?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "route_type_of_line" */
export type RouteTypeOfLineStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: RouteTypeOfLineStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type RouteTypeOfLineStreamCursorValueInput = {
  readonly belonging_to_vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnum>;
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  readonly type_of_line?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "route.type_of_line" */
export enum RouteTypeOfLineUpdateColumn {
  /** column name */
  BelongingToVehicleMode = 'belonging_to_vehicle_mode',
  /** column name */
  TypeOfLine = 'type_of_line'
}

export type RouteTypeOfLineUpdates = {
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<RouteTypeOfLineSetInput>;
  /** filter the rows which have to be updated */
  readonly where: RouteTypeOfLineBoolExp;
};

export type ServiceCalendarDayTypeActiveOnDayOfWeekAggregateBoolExp = {
  readonly count?: InputMaybe<ServiceCalendarDayTypeActiveOnDayOfWeekAggregateBoolExpCount>;
};

export type ServiceCalendarDayTypeActiveOnDayOfWeekAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type ServiceCalendarSubstituteOperatingDayByLineTypeAggregateBoolExp = {
  readonly count?: InputMaybe<ServiceCalendarSubstituteOperatingDayByLineTypeAggregateBoolExpCount>;
};

export type ServiceCalendarSubstituteOperatingDayByLineTypeAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>;
  readonly predicate: IntComparisonExp;
};

/** A dummy table that models the results of calculating the lengths of stop intervals from the given journey patterns. The table exists due to the limitations of Hasura and there is no intention to insert anything to it. */
export type ServicePatternDistanceBetweenStopsCalculation = {
  readonly __typename?: 'service_pattern_distance_between_stops_calculation';
  /** The length of the stop interval in metres. */
  readonly distance_in_metres: Scalars['float8']['output'];
  /** The label of the end stop of the stop interval. */
  readonly end_stop_label: Scalars['String']['output'];
  /** The ID of the journey pattern. */
  readonly journey_pattern_id: Scalars['uuid']['output'];
  /** The observation date for the state of the route related to the journey pattern. */
  readonly observation_date: Scalars['date']['output'];
  /** The ID of the route related to the journey pattern. */
  readonly route_id: Scalars['uuid']['output'];
  /** The priority of the route related to the journey pattern. */
  readonly route_priority: Scalars['Int']['output'];
  /** The label of the start stop of the stop interval. */
  readonly start_stop_label: Scalars['String']['output'];
  /** The sequence number of the stop interval within the journey pattern. */
  readonly stop_interval_sequence: Scalars['Int']['output'];
};

/** aggregated selection of "service_pattern.distance_between_stops_calculation" */
export type ServicePatternDistanceBetweenStopsCalculationAggregate = {
  readonly __typename?: 'service_pattern_distance_between_stops_calculation_aggregate';
  readonly aggregate?: Maybe<ServicePatternDistanceBetweenStopsCalculationAggregateFields>;
  readonly nodes: ReadonlyArray<ServicePatternDistanceBetweenStopsCalculation>;
};

/** aggregate fields of "service_pattern.distance_between_stops_calculation" */
export type ServicePatternDistanceBetweenStopsCalculationAggregateFields = {
  readonly __typename?: 'service_pattern_distance_between_stops_calculation_aggregate_fields';
  readonly avg?: Maybe<ServicePatternDistanceBetweenStopsCalculationAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<ServicePatternDistanceBetweenStopsCalculationMaxFields>;
  readonly min?: Maybe<ServicePatternDistanceBetweenStopsCalculationMinFields>;
  readonly stddev?: Maybe<ServicePatternDistanceBetweenStopsCalculationStddevFields>;
  readonly stddev_pop?: Maybe<ServicePatternDistanceBetweenStopsCalculationStddevPopFields>;
  readonly stddev_samp?: Maybe<ServicePatternDistanceBetweenStopsCalculationStddevSampFields>;
  readonly sum?: Maybe<ServicePatternDistanceBetweenStopsCalculationSumFields>;
  readonly var_pop?: Maybe<ServicePatternDistanceBetweenStopsCalculationVarPopFields>;
  readonly var_samp?: Maybe<ServicePatternDistanceBetweenStopsCalculationVarSampFields>;
  readonly variance?: Maybe<ServicePatternDistanceBetweenStopsCalculationVarianceFields>;
};


/** aggregate fields of "service_pattern.distance_between_stops_calculation" */
export type ServicePatternDistanceBetweenStopsCalculationAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type ServicePatternDistanceBetweenStopsCalculationAvgFields = {
  readonly __typename?: 'service_pattern_distance_between_stops_calculation_avg_fields';
  /** The length of the stop interval in metres. */
  readonly distance_in_metres?: Maybe<Scalars['Float']['output']>;
  /** The priority of the route related to the journey pattern. */
  readonly route_priority?: Maybe<Scalars['Float']['output']>;
  /** The sequence number of the stop interval within the journey pattern. */
  readonly stop_interval_sequence?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "service_pattern.distance_between_stops_calculation". All fields are combined with a logical 'AND'. */
export type ServicePatternDistanceBetweenStopsCalculationBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationBoolExp>>;
  readonly _not?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationBoolExp>>;
  readonly distance_in_metres?: InputMaybe<Float8ComparisonExp>;
  readonly end_stop_label?: InputMaybe<StringComparisonExp>;
  readonly journey_pattern_id?: InputMaybe<UuidComparisonExp>;
  readonly observation_date?: InputMaybe<DateComparisonExp>;
  readonly route_id?: InputMaybe<UuidComparisonExp>;
  readonly route_priority?: InputMaybe<IntComparisonExp>;
  readonly start_stop_label?: InputMaybe<StringComparisonExp>;
  readonly stop_interval_sequence?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "service_pattern.distance_between_stops_calculation" */
export enum ServicePatternDistanceBetweenStopsCalculationConstraint {
  /** unique or primary key constraint on columns "observation_date", "stop_interval_sequence", "route_priority", "journey_pattern_id" */
  DistanceBetweenStopsCalculationPkey = 'distance_between_stops_calculation_pkey'
}

/** input type for incrementing numeric columns in table "service_pattern.distance_between_stops_calculation" */
export type ServicePatternDistanceBetweenStopsCalculationIncInput = {
  /** The length of the stop interval in metres. */
  readonly distance_in_metres?: InputMaybe<Scalars['float8']['input']>;
  /** The priority of the route related to the journey pattern. */
  readonly route_priority?: InputMaybe<Scalars['Int']['input']>;
  /** The sequence number of the stop interval within the journey pattern. */
  readonly stop_interval_sequence?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "service_pattern.distance_between_stops_calculation" */
export type ServicePatternDistanceBetweenStopsCalculationInsertInput = {
  /** The length of the stop interval in metres. */
  readonly distance_in_metres?: InputMaybe<Scalars['float8']['input']>;
  /** The label of the end stop of the stop interval. */
  readonly end_stop_label?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the journey pattern. */
  readonly journey_pattern_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The observation date for the state of the route related to the journey pattern. */
  readonly observation_date?: InputMaybe<Scalars['date']['input']>;
  /** The ID of the route related to the journey pattern. */
  readonly route_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The priority of the route related to the journey pattern. */
  readonly route_priority?: InputMaybe<Scalars['Int']['input']>;
  /** The label of the start stop of the stop interval. */
  readonly start_stop_label?: InputMaybe<Scalars['String']['input']>;
  /** The sequence number of the stop interval within the journey pattern. */
  readonly stop_interval_sequence?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type ServicePatternDistanceBetweenStopsCalculationMaxFields = {
  readonly __typename?: 'service_pattern_distance_between_stops_calculation_max_fields';
  /** The length of the stop interval in metres. */
  readonly distance_in_metres?: Maybe<Scalars['float8']['output']>;
  /** The label of the end stop of the stop interval. */
  readonly end_stop_label?: Maybe<Scalars['String']['output']>;
  /** The ID of the journey pattern. */
  readonly journey_pattern_id?: Maybe<Scalars['uuid']['output']>;
  /** The observation date for the state of the route related to the journey pattern. */
  readonly observation_date?: Maybe<Scalars['date']['output']>;
  /** The ID of the route related to the journey pattern. */
  readonly route_id?: Maybe<Scalars['uuid']['output']>;
  /** The priority of the route related to the journey pattern. */
  readonly route_priority?: Maybe<Scalars['Int']['output']>;
  /** The label of the start stop of the stop interval. */
  readonly start_stop_label?: Maybe<Scalars['String']['output']>;
  /** The sequence number of the stop interval within the journey pattern. */
  readonly stop_interval_sequence?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type ServicePatternDistanceBetweenStopsCalculationMinFields = {
  readonly __typename?: 'service_pattern_distance_between_stops_calculation_min_fields';
  /** The length of the stop interval in metres. */
  readonly distance_in_metres?: Maybe<Scalars['float8']['output']>;
  /** The label of the end stop of the stop interval. */
  readonly end_stop_label?: Maybe<Scalars['String']['output']>;
  /** The ID of the journey pattern. */
  readonly journey_pattern_id?: Maybe<Scalars['uuid']['output']>;
  /** The observation date for the state of the route related to the journey pattern. */
  readonly observation_date?: Maybe<Scalars['date']['output']>;
  /** The ID of the route related to the journey pattern. */
  readonly route_id?: Maybe<Scalars['uuid']['output']>;
  /** The priority of the route related to the journey pattern. */
  readonly route_priority?: Maybe<Scalars['Int']['output']>;
  /** The label of the start stop of the stop interval. */
  readonly start_stop_label?: Maybe<Scalars['String']['output']>;
  /** The sequence number of the stop interval within the journey pattern. */
  readonly stop_interval_sequence?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "service_pattern.distance_between_stops_calculation" */
export type ServicePatternDistanceBetweenStopsCalculationMutationResponse = {
  readonly __typename?: 'service_pattern_distance_between_stops_calculation_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<ServicePatternDistanceBetweenStopsCalculation>;
};

/** on_conflict condition type for table "service_pattern.distance_between_stops_calculation" */
export type ServicePatternDistanceBetweenStopsCalculationOnConflict = {
  readonly constraint: ServicePatternDistanceBetweenStopsCalculationConstraint;
  readonly update_columns?: ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationUpdateColumn>;
  readonly where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
};

/** Ordering options when selecting data from "service_pattern.distance_between_stops_calculation". */
export type ServicePatternDistanceBetweenStopsCalculationOrderBy = {
  readonly distance_in_metres?: InputMaybe<OrderBy>;
  readonly end_stop_label?: InputMaybe<OrderBy>;
  readonly journey_pattern_id?: InputMaybe<OrderBy>;
  readonly observation_date?: InputMaybe<OrderBy>;
  readonly route_id?: InputMaybe<OrderBy>;
  readonly route_priority?: InputMaybe<OrderBy>;
  readonly start_stop_label?: InputMaybe<OrderBy>;
  readonly stop_interval_sequence?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: service_pattern.distance_between_stops_calculation */
export type ServicePatternDistanceBetweenStopsCalculationPkColumnsInput = {
  /** The ID of the journey pattern. */
  readonly journey_pattern_id: Scalars['uuid']['input'];
  /** The observation date for the state of the route related to the journey pattern. */
  readonly observation_date: Scalars['date']['input'];
  /** The priority of the route related to the journey pattern. */
  readonly route_priority: Scalars['Int']['input'];
  /** The sequence number of the stop interval within the journey pattern. */
  readonly stop_interval_sequence: Scalars['Int']['input'];
};

/** select columns of table "service_pattern.distance_between_stops_calculation" */
export enum ServicePatternDistanceBetweenStopsCalculationSelectColumn {
  /** column name */
  DistanceInMetres = 'distance_in_metres',
  /** column name */
  EndStopLabel = 'end_stop_label',
  /** column name */
  JourneyPatternId = 'journey_pattern_id',
  /** column name */
  ObservationDate = 'observation_date',
  /** column name */
  RouteId = 'route_id',
  /** column name */
  RoutePriority = 'route_priority',
  /** column name */
  StartStopLabel = 'start_stop_label',
  /** column name */
  StopIntervalSequence = 'stop_interval_sequence'
}

/** input type for updating data in table "service_pattern.distance_between_stops_calculation" */
export type ServicePatternDistanceBetweenStopsCalculationSetInput = {
  /** The length of the stop interval in metres. */
  readonly distance_in_metres?: InputMaybe<Scalars['float8']['input']>;
  /** The label of the end stop of the stop interval. */
  readonly end_stop_label?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the journey pattern. */
  readonly journey_pattern_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The observation date for the state of the route related to the journey pattern. */
  readonly observation_date?: InputMaybe<Scalars['date']['input']>;
  /** The ID of the route related to the journey pattern. */
  readonly route_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The priority of the route related to the journey pattern. */
  readonly route_priority?: InputMaybe<Scalars['Int']['input']>;
  /** The label of the start stop of the stop interval. */
  readonly start_stop_label?: InputMaybe<Scalars['String']['input']>;
  /** The sequence number of the stop interval within the journey pattern. */
  readonly stop_interval_sequence?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type ServicePatternDistanceBetweenStopsCalculationStddevFields = {
  readonly __typename?: 'service_pattern_distance_between_stops_calculation_stddev_fields';
  /** The length of the stop interval in metres. */
  readonly distance_in_metres?: Maybe<Scalars['Float']['output']>;
  /** The priority of the route related to the journey pattern. */
  readonly route_priority?: Maybe<Scalars['Float']['output']>;
  /** The sequence number of the stop interval within the journey pattern. */
  readonly stop_interval_sequence?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type ServicePatternDistanceBetweenStopsCalculationStddevPopFields = {
  readonly __typename?: 'service_pattern_distance_between_stops_calculation_stddev_pop_fields';
  /** The length of the stop interval in metres. */
  readonly distance_in_metres?: Maybe<Scalars['Float']['output']>;
  /** The priority of the route related to the journey pattern. */
  readonly route_priority?: Maybe<Scalars['Float']['output']>;
  /** The sequence number of the stop interval within the journey pattern. */
  readonly stop_interval_sequence?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type ServicePatternDistanceBetweenStopsCalculationStddevSampFields = {
  readonly __typename?: 'service_pattern_distance_between_stops_calculation_stddev_samp_fields';
  /** The length of the stop interval in metres. */
  readonly distance_in_metres?: Maybe<Scalars['Float']['output']>;
  /** The priority of the route related to the journey pattern. */
  readonly route_priority?: Maybe<Scalars['Float']['output']>;
  /** The sequence number of the stop interval within the journey pattern. */
  readonly stop_interval_sequence?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "service_pattern_distance_between_stops_calculation" */
export type ServicePatternDistanceBetweenStopsCalculationStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: ServicePatternDistanceBetweenStopsCalculationStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ServicePatternDistanceBetweenStopsCalculationStreamCursorValueInput = {
  /** The length of the stop interval in metres. */
  readonly distance_in_metres?: InputMaybe<Scalars['float8']['input']>;
  /** The label of the end stop of the stop interval. */
  readonly end_stop_label?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the journey pattern. */
  readonly journey_pattern_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The observation date for the state of the route related to the journey pattern. */
  readonly observation_date?: InputMaybe<Scalars['date']['input']>;
  /** The ID of the route related to the journey pattern. */
  readonly route_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The priority of the route related to the journey pattern. */
  readonly route_priority?: InputMaybe<Scalars['Int']['input']>;
  /** The label of the start stop of the stop interval. */
  readonly start_stop_label?: InputMaybe<Scalars['String']['input']>;
  /** The sequence number of the stop interval within the journey pattern. */
  readonly stop_interval_sequence?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type ServicePatternDistanceBetweenStopsCalculationSumFields = {
  readonly __typename?: 'service_pattern_distance_between_stops_calculation_sum_fields';
  /** The length of the stop interval in metres. */
  readonly distance_in_metres?: Maybe<Scalars['float8']['output']>;
  /** The priority of the route related to the journey pattern. */
  readonly route_priority?: Maybe<Scalars['Int']['output']>;
  /** The sequence number of the stop interval within the journey pattern. */
  readonly stop_interval_sequence?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "service_pattern.distance_between_stops_calculation" */
export enum ServicePatternDistanceBetweenStopsCalculationUpdateColumn {
  /** column name */
  DistanceInMetres = 'distance_in_metres',
  /** column name */
  EndStopLabel = 'end_stop_label',
  /** column name */
  JourneyPatternId = 'journey_pattern_id',
  /** column name */
  ObservationDate = 'observation_date',
  /** column name */
  RouteId = 'route_id',
  /** column name */
  RoutePriority = 'route_priority',
  /** column name */
  StartStopLabel = 'start_stop_label',
  /** column name */
  StopIntervalSequence = 'stop_interval_sequence'
}

export type ServicePatternDistanceBetweenStopsCalculationUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationSetInput>;
  /** filter the rows which have to be updated */
  readonly where: ServicePatternDistanceBetweenStopsCalculationBoolExp;
};

/** aggregate var_pop on columns */
export type ServicePatternDistanceBetweenStopsCalculationVarPopFields = {
  readonly __typename?: 'service_pattern_distance_between_stops_calculation_var_pop_fields';
  /** The length of the stop interval in metres. */
  readonly distance_in_metres?: Maybe<Scalars['Float']['output']>;
  /** The priority of the route related to the journey pattern. */
  readonly route_priority?: Maybe<Scalars['Float']['output']>;
  /** The sequence number of the stop interval within the journey pattern. */
  readonly stop_interval_sequence?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type ServicePatternDistanceBetweenStopsCalculationVarSampFields = {
  readonly __typename?: 'service_pattern_distance_between_stops_calculation_var_samp_fields';
  /** The length of the stop interval in metres. */
  readonly distance_in_metres?: Maybe<Scalars['Float']['output']>;
  /** The priority of the route related to the journey pattern. */
  readonly route_priority?: Maybe<Scalars['Float']['output']>;
  /** The sequence number of the stop interval within the journey pattern. */
  readonly stop_interval_sequence?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type ServicePatternDistanceBetweenStopsCalculationVarianceFields = {
  readonly __typename?: 'service_pattern_distance_between_stops_calculation_variance_fields';
  /** The length of the stop interval in metres. */
  readonly distance_in_metres?: Maybe<Scalars['Float']['output']>;
  /** The priority of the route related to the journey pattern. */
  readonly route_priority?: Maybe<Scalars['Float']['output']>;
  /** The sequence number of the stop interval within the journey pattern. */
  readonly stop_interval_sequence?: Maybe<Scalars['Float']['output']>;
};

export type ServicePatternGetDistancesBetweenStopPointsByRoutesArgs = {
  readonly observation_date?: InputMaybe<Scalars['date']['input']>;
  readonly route_ids?: InputMaybe<Scalars['_uuid']['input']>;
};

export type ServicePatternGetDistancesBetweenStopPointsInJourneyPatternsArgs = {
  readonly include_draft_stops?: InputMaybe<Scalars['Boolean']['input']>;
  readonly journey_pattern_ids?: InputMaybe<Scalars['_uuid']['input']>;
  readonly observation_date?: InputMaybe<Scalars['date']['input']>;
};

/** The scheduled stop points: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:845 . Colloquially known as stops from the perspective of timetable planning. */
export type ServicePatternScheduledStopPoint = {
  readonly __typename?: 'service_pattern_scheduled_stop_point';
  /** The point on the infrastructure link closest to measured_location. A PostGIS PointZ geography in EPSG:4326. */
  readonly closest_point_on_infrastructure_link?: Maybe<Scalars['geography_point']['output']>;
  /** The direction(s) of traffic with respect to the digitization, i.e. the direction of the specified line string. */
  readonly direction: InfrastructureNetworkDirectionEnum;
  /** The label is the short code that identifies the stop to the passengers. There can be at most one stop with the same label at a time. The label matches the GTFS stop_code. */
  readonly label: Scalars['String']['output'];
  /** An object relationship */
  readonly located_on_infrastructure_link: InfrastructureNetworkInfrastructureLink;
  /** The infrastructure link on which the stop is located. */
  readonly located_on_infrastructure_link_id: Scalars['uuid']['output'];
  /** The measured location describes the physical location of the stop. For some stops this describes the location of the pole-mounted flag. A PostGIS PointZ geography in EPSG:4326. */
  readonly measured_location: Scalars['geography_point']['output'];
  readonly newest_quay?: Maybe<StopsDatabaseQuayNewestVersion>;
  readonly newest_stop_place?: Maybe<StopsDatabaseQuayNewestVersion>;
  /** An array relationship */
  readonly other_label_instances: ReadonlyArray<ServicePatternScheduledStopPoint>;
  /** An aggregate relationship */
  readonly other_label_instances_aggregate: ServicePatternScheduledStopPointAggregate;
  readonly priority: Scalars['Int']['output'];
  /** The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]. */
  readonly relative_distance_from_infrastructure_link_start: Scalars['Float']['output'];
  /** The ID of the scheduled stop point. */
  readonly scheduled_stop_point_id: Scalars['uuid']['output'];
  /** An array relationship */
  readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPattern>;
  /** An aggregate relationship */
  readonly scheduled_stop_point_in_journey_patterns_aggregate: JourneyPatternScheduledStopPointInJourneyPatternAggregate;
  readonly stop_place?: Maybe<ReadonlyArray<Maybe<StopRegistryStopPlaceInterface>>>;
  /** The id of the related stop place in stop registry database. */
  readonly stop_place_ref?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  readonly timing_place?: Maybe<TimingPatternTimingPlace>;
  /** Optional reference to a TIMING PLACE. If NULL, the SCHEDULED STOP POINT is not used for timing. */
  readonly timing_place_id?: Maybe<Scalars['uuid']['output']>;
  /** end of the operating date span in the scheduled stop point's local time (inclusive). */
  readonly validity_end?: Maybe<Scalars['date']['output']>;
  /** start of the operating date span in the scheduled stop point's local time (inclusive). */
  readonly validity_start?: Maybe<Scalars['date']['output']>;
  /** An array relationship */
  readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPoint>;
  /** An aggregate relationship */
  readonly vehicle_mode_on_scheduled_stop_point_aggregate: ServicePatternVehicleModeOnScheduledStopPointAggregate;
};


/** The scheduled stop points: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:845 . Colloquially known as stops from the perspective of timetable planning. */
export type ServicePatternScheduledStopPointOtherLabelInstancesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};


/** The scheduled stop points: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:845 . Colloquially known as stops from the perspective of timetable planning. */
export type ServicePatternScheduledStopPointOtherLabelInstancesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};


/** The scheduled stop points: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:845 . Colloquially known as stops from the perspective of timetable planning. */
export type ServicePatternScheduledStopPointScheduledStopPointInJourneyPatternsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternOrderBy>>;
  where?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
};


/** The scheduled stop points: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:845 . Colloquially known as stops from the perspective of timetable planning. */
export type ServicePatternScheduledStopPointScheduledStopPointInJourneyPatternsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternOrderBy>>;
  where?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
};


/** The scheduled stop points: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:845 . Colloquially known as stops from the perspective of timetable planning. */
export type ServicePatternScheduledStopPointStopPlaceArgs = {
  allVersions?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  countryReference?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  countyReference?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  hasParking?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  importedId?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  municipalityReference?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  onlyMonomodalStopPlaces?: InputMaybe<Scalars['Boolean']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  pointInTime?: InputMaybe<Scalars['stop_registry_DateTime']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  stopPlaceType?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryStopPlaceType>>>;
  tags?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  values?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  version?: InputMaybe<Scalars['Int']['input']>;
  versionValidity?: InputMaybe<StopRegistryVersionValidity>;
  withDuplicatedQuayImportedIds?: InputMaybe<Scalars['Boolean']['input']>;
  withNearbySimilarDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
  withTags?: InputMaybe<Scalars['Boolean']['input']>;
  withoutLocationOnly?: InputMaybe<Scalars['Boolean']['input']>;
  withoutQuaysOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** The scheduled stop points: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:845 . Colloquially known as stops from the perspective of timetable planning. */
export type ServicePatternScheduledStopPointVehicleModeOnScheduledStopPointArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointBoolExp>;
};


/** The scheduled stop points: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:845 . Colloquially known as stops from the perspective of timetable planning. */
export type ServicePatternScheduledStopPointVehicleModeOnScheduledStopPointAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointBoolExp>;
};

/** aggregated selection of "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointAggregate = {
  readonly __typename?: 'service_pattern_scheduled_stop_point_aggregate';
  readonly aggregate?: Maybe<ServicePatternScheduledStopPointAggregateFields>;
  readonly nodes: ReadonlyArray<ServicePatternScheduledStopPoint>;
};

export type ServicePatternScheduledStopPointAggregateBoolExp = {
  readonly count?: InputMaybe<ServicePatternScheduledStopPointAggregateBoolExpCount>;
};

export type ServicePatternScheduledStopPointAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
  readonly predicate: IntComparisonExp;
};

/** aggregate fields of "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointAggregateFields = {
  readonly __typename?: 'service_pattern_scheduled_stop_point_aggregate_fields';
  readonly avg?: Maybe<ServicePatternScheduledStopPointAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<ServicePatternScheduledStopPointMaxFields>;
  readonly min?: Maybe<ServicePatternScheduledStopPointMinFields>;
  readonly stddev?: Maybe<ServicePatternScheduledStopPointStddevFields>;
  readonly stddev_pop?: Maybe<ServicePatternScheduledStopPointStddevPopFields>;
  readonly stddev_samp?: Maybe<ServicePatternScheduledStopPointStddevSampFields>;
  readonly sum?: Maybe<ServicePatternScheduledStopPointSumFields>;
  readonly var_pop?: Maybe<ServicePatternScheduledStopPointVarPopFields>;
  readonly var_samp?: Maybe<ServicePatternScheduledStopPointVarSampFields>;
  readonly variance?: Maybe<ServicePatternScheduledStopPointVarianceFields>;
};


/** aggregate fields of "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointAggregateOrderBy = {
  readonly avg?: InputMaybe<ServicePatternScheduledStopPointAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<ServicePatternScheduledStopPointMaxOrderBy>;
  readonly min?: InputMaybe<ServicePatternScheduledStopPointMinOrderBy>;
  readonly stddev?: InputMaybe<ServicePatternScheduledStopPointStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<ServicePatternScheduledStopPointStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<ServicePatternScheduledStopPointStddevSampOrderBy>;
  readonly sum?: InputMaybe<ServicePatternScheduledStopPointSumOrderBy>;
  readonly var_pop?: InputMaybe<ServicePatternScheduledStopPointVarPopOrderBy>;
  readonly var_samp?: InputMaybe<ServicePatternScheduledStopPointVarSampOrderBy>;
  readonly variance?: InputMaybe<ServicePatternScheduledStopPointVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointArrRelInsertInput = {
  readonly data: ReadonlyArray<ServicePatternScheduledStopPointInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<ServicePatternScheduledStopPointOnConflict>;
};

/** aggregate avg on columns */
export type ServicePatternScheduledStopPointAvgFields = {
  readonly __typename?: 'service_pattern_scheduled_stop_point_avg_fields';
  readonly priority?: Maybe<Scalars['Float']['output']>;
  /** The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]. */
  readonly relative_distance_from_infrastructure_link_start?: Maybe<Scalars['float8']['output']>;
};

/** order by avg() on columns of table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointAvgOrderBy = {
  readonly priority?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "service_pattern.scheduled_stop_point". All fields are combined with a logical 'AND'. */
export type ServicePatternScheduledStopPointBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointBoolExp>>;
  readonly _not?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointBoolExp>>;
  readonly closest_point_on_infrastructure_link?: InputMaybe<GeographyComparisonExp>;
  readonly direction?: InputMaybe<InfrastructureNetworkDirectionEnumComparisonExp>;
  readonly label?: InputMaybe<StringComparisonExp>;
  readonly located_on_infrastructure_link?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
  readonly located_on_infrastructure_link_id?: InputMaybe<UuidComparisonExp>;
  readonly measured_location?: InputMaybe<GeographyComparisonExp>;
  readonly other_label_instances?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
  readonly other_label_instances_aggregate?: InputMaybe<ServicePatternScheduledStopPointAggregateBoolExp>;
  readonly priority?: InputMaybe<IntComparisonExp>;
  readonly relative_distance_from_infrastructure_link_start?: InputMaybe<Float8ComparisonExp>;
  readonly scheduled_stop_point_id?: InputMaybe<UuidComparisonExp>;
  readonly scheduled_stop_point_in_journey_patterns?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
  readonly scheduled_stop_point_in_journey_patterns_aggregate?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternAggregateBoolExp>;
  readonly stop_place_ref?: InputMaybe<StringComparisonExp>;
  readonly timing_place?: InputMaybe<TimingPatternTimingPlaceBoolExp>;
  readonly timing_place_id?: InputMaybe<UuidComparisonExp>;
  readonly validity_end?: InputMaybe<DateComparisonExp>;
  readonly validity_start?: InputMaybe<DateComparisonExp>;
  readonly vehicle_mode_on_scheduled_stop_point?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointBoolExp>;
  readonly vehicle_mode_on_scheduled_stop_point_aggregate?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointAggregateBoolExp>;
};

/** unique or primary key constraints on table "service_pattern.scheduled_stop_point" */
export enum ServicePatternScheduledStopPointConstraint {
  /** unique or primary key constraint on columns "scheduled_stop_point_id" */
  ScheduledStopPointPkey = 'scheduled_stop_point_pkey',
  /** unique or primary key constraint on columns "stop_place_ref" */
  ScheduledStopPointStopPlaceRefIdx = 'scheduled_stop_point_stop_place_ref_idx'
}

export type ServicePatternScheduledStopPointInJourneyPatternRefAggregateBoolExp = {
  readonly count?: InputMaybe<ServicePatternScheduledStopPointInJourneyPatternRefAggregateBoolExpCount>;
};

export type ServicePatternScheduledStopPointInJourneyPatternRefAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>;
  readonly predicate: IntComparisonExp;
};

/** input type for incrementing numeric columns in table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointIncInput = {
  readonly priority?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointInsertInput = {
  /** The direction(s) of traffic with respect to the digitization, i.e. the direction of the specified line string. */
  readonly direction: InfrastructureNetworkDirectionEnum;
  /** The label is the short code that identifies the stop to the passengers. There can be at most one stop with the same label at a time. The label matches the GTFS stop_code. */
  readonly label: Scalars['String']['input'];
  readonly located_on_infrastructure_link?: InputMaybe<InfrastructureNetworkInfrastructureLinkObjRelInsertInput>;
  /** The infrastructure link on which the stop is located. */
  readonly located_on_infrastructure_link_id: Scalars['uuid']['input'];
  /** The measured location describes the physical location of the stop. For some stops this describes the location of the pole-mounted flag. A PostGIS PointZ geography in EPSG:4326. */
  readonly measured_location: Scalars['geography_point']['input'];
  readonly other_label_instances?: InputMaybe<ServicePatternScheduledStopPointArrRelInsertInput>;
  readonly priority: Scalars['Int']['input'];
  /** The ID of the scheduled stop point. */
  readonly scheduled_stop_point_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly scheduled_stop_point_in_journey_patterns?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternArrRelInsertInput>;
  /** The id of the related stop place in stop registry database. */
  readonly stop_place_ref?: InputMaybe<Scalars['String']['input']>;
  readonly timing_place?: InputMaybe<TimingPatternTimingPlaceObjRelInsertInput>;
  /** Optional reference to a TIMING PLACE. If NULL, the SCHEDULED STOP POINT is not used for timing. */
  readonly timing_place_id?: InputMaybe<Scalars['uuid']['input']>;
  /** end of the operating date span in the scheduled stop point's local time (inclusive). */
  readonly validity_end?: InputMaybe<Scalars['date']['input']>;
  /** start of the operating date span in the scheduled stop point's local time (inclusive). */
  readonly validity_start?: InputMaybe<Scalars['date']['input']>;
  readonly vehicle_mode_on_scheduled_stop_point?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointArrRelInsertInput>;
};

/** aggregate max on columns */
export type ServicePatternScheduledStopPointMaxFields = {
  readonly __typename?: 'service_pattern_scheduled_stop_point_max_fields';
  /** The label is the short code that identifies the stop to the passengers. There can be at most one stop with the same label at a time. The label matches the GTFS stop_code. */
  readonly label?: Maybe<Scalars['String']['output']>;
  /** The infrastructure link on which the stop is located. */
  readonly located_on_infrastructure_link_id?: Maybe<Scalars['uuid']['output']>;
  readonly priority?: Maybe<Scalars['Int']['output']>;
  /** The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]. */
  readonly relative_distance_from_infrastructure_link_start?: Maybe<Scalars['float8']['output']>;
  /** The ID of the scheduled stop point. */
  readonly scheduled_stop_point_id?: Maybe<Scalars['uuid']['output']>;
  /** The id of the related stop place in stop registry database. */
  readonly stop_place_ref?: Maybe<Scalars['String']['output']>;
  /** Optional reference to a TIMING PLACE. If NULL, the SCHEDULED STOP POINT is not used for timing. */
  readonly timing_place_id?: Maybe<Scalars['uuid']['output']>;
  /** end of the operating date span in the scheduled stop point's local time (inclusive). */
  readonly validity_end?: Maybe<Scalars['date']['output']>;
  /** start of the operating date span in the scheduled stop point's local time (inclusive). */
  readonly validity_start?: Maybe<Scalars['date']['output']>;
};

/** order by max() on columns of table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointMaxOrderBy = {
  /** The label is the short code that identifies the stop to the passengers. There can be at most one stop with the same label at a time. The label matches the GTFS stop_code. */
  readonly label?: InputMaybe<OrderBy>;
  /** The infrastructure link on which the stop is located. */
  readonly located_on_infrastructure_link_id?: InputMaybe<OrderBy>;
  readonly priority?: InputMaybe<OrderBy>;
  /** The ID of the scheduled stop point. */
  readonly scheduled_stop_point_id?: InputMaybe<OrderBy>;
  /** The id of the related stop place in stop registry database. */
  readonly stop_place_ref?: InputMaybe<OrderBy>;
  /** Optional reference to a TIMING PLACE. If NULL, the SCHEDULED STOP POINT is not used for timing. */
  readonly timing_place_id?: InputMaybe<OrderBy>;
  /** end of the operating date span in the scheduled stop point's local time (inclusive). */
  readonly validity_end?: InputMaybe<OrderBy>;
  /** start of the operating date span in the scheduled stop point's local time (inclusive). */
  readonly validity_start?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type ServicePatternScheduledStopPointMinFields = {
  readonly __typename?: 'service_pattern_scheduled_stop_point_min_fields';
  /** The label is the short code that identifies the stop to the passengers. There can be at most one stop with the same label at a time. The label matches the GTFS stop_code. */
  readonly label?: Maybe<Scalars['String']['output']>;
  /** The infrastructure link on which the stop is located. */
  readonly located_on_infrastructure_link_id?: Maybe<Scalars['uuid']['output']>;
  readonly priority?: Maybe<Scalars['Int']['output']>;
  /** The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]. */
  readonly relative_distance_from_infrastructure_link_start?: Maybe<Scalars['float8']['output']>;
  /** The ID of the scheduled stop point. */
  readonly scheduled_stop_point_id?: Maybe<Scalars['uuid']['output']>;
  /** The id of the related stop place in stop registry database. */
  readonly stop_place_ref?: Maybe<Scalars['String']['output']>;
  /** Optional reference to a TIMING PLACE. If NULL, the SCHEDULED STOP POINT is not used for timing. */
  readonly timing_place_id?: Maybe<Scalars['uuid']['output']>;
  /** end of the operating date span in the scheduled stop point's local time (inclusive). */
  readonly validity_end?: Maybe<Scalars['date']['output']>;
  /** start of the operating date span in the scheduled stop point's local time (inclusive). */
  readonly validity_start?: Maybe<Scalars['date']['output']>;
};

/** order by min() on columns of table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointMinOrderBy = {
  /** The label is the short code that identifies the stop to the passengers. There can be at most one stop with the same label at a time. The label matches the GTFS stop_code. */
  readonly label?: InputMaybe<OrderBy>;
  /** The infrastructure link on which the stop is located. */
  readonly located_on_infrastructure_link_id?: InputMaybe<OrderBy>;
  readonly priority?: InputMaybe<OrderBy>;
  /** The ID of the scheduled stop point. */
  readonly scheduled_stop_point_id?: InputMaybe<OrderBy>;
  /** The id of the related stop place in stop registry database. */
  readonly stop_place_ref?: InputMaybe<OrderBy>;
  /** Optional reference to a TIMING PLACE. If NULL, the SCHEDULED STOP POINT is not used for timing. */
  readonly timing_place_id?: InputMaybe<OrderBy>;
  /** end of the operating date span in the scheduled stop point's local time (inclusive). */
  readonly validity_end?: InputMaybe<OrderBy>;
  /** start of the operating date span in the scheduled stop point's local time (inclusive). */
  readonly validity_start?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointMutationResponse = {
  readonly __typename?: 'service_pattern_scheduled_stop_point_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<ServicePatternScheduledStopPoint>;
};

/** on_conflict condition type for table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointOnConflict = {
  readonly constraint: ServicePatternScheduledStopPointConstraint;
  readonly update_columns?: ReadonlyArray<ServicePatternScheduledStopPointUpdateColumn>;
  readonly where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};

/** Ordering options when selecting data from "service_pattern.scheduled_stop_point". */
export type ServicePatternScheduledStopPointOrderBy = {
  readonly closest_point_on_infrastructure_link?: InputMaybe<OrderBy>;
  readonly direction?: InputMaybe<OrderBy>;
  readonly label?: InputMaybe<OrderBy>;
  readonly located_on_infrastructure_link?: InputMaybe<InfrastructureNetworkInfrastructureLinkOrderBy>;
  readonly located_on_infrastructure_link_id?: InputMaybe<OrderBy>;
  readonly measured_location?: InputMaybe<OrderBy>;
  readonly other_label_instances_aggregate?: InputMaybe<ServicePatternScheduledStopPointAggregateOrderBy>;
  readonly priority?: InputMaybe<OrderBy>;
  readonly relative_distance_from_infrastructure_link_start?: InputMaybe<OrderBy>;
  readonly scheduled_stop_point_id?: InputMaybe<OrderBy>;
  readonly scheduled_stop_point_in_journey_patterns_aggregate?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternAggregateOrderBy>;
  readonly stop_place_ref?: InputMaybe<OrderBy>;
  readonly timing_place?: InputMaybe<TimingPatternTimingPlaceOrderBy>;
  readonly timing_place_id?: InputMaybe<OrderBy>;
  readonly validity_end?: InputMaybe<OrderBy>;
  readonly validity_start?: InputMaybe<OrderBy>;
  readonly vehicle_mode_on_scheduled_stop_point_aggregate?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointAggregateOrderBy>;
};

/** primary key columns input for table: service_pattern.scheduled_stop_point */
export type ServicePatternScheduledStopPointPkColumnsInput = {
  /** The ID of the scheduled stop point. */
  readonly scheduled_stop_point_id: Scalars['uuid']['input'];
};

/** select columns of table "service_pattern.scheduled_stop_point" */
export enum ServicePatternScheduledStopPointSelectColumn {
  /** column name */
  Direction = 'direction',
  /** column name */
  Label = 'label',
  /** column name */
  LocatedOnInfrastructureLinkId = 'located_on_infrastructure_link_id',
  /** column name */
  MeasuredLocation = 'measured_location',
  /** column name */
  Priority = 'priority',
  /** column name */
  ScheduledStopPointId = 'scheduled_stop_point_id',
  /** column name */
  StopPlaceRef = 'stop_place_ref',
  /** column name */
  TimingPlaceId = 'timing_place_id',
  /** column name */
  ValidityEnd = 'validity_end',
  /** column name */
  ValidityStart = 'validity_start'
}

/** input type for updating data in table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointSetInput = {
  /** The direction(s) of traffic with respect to the digitization, i.e. the direction of the specified line string. */
  readonly direction?: InputMaybe<InfrastructureNetworkDirectionEnum>;
  /** The label is the short code that identifies the stop to the passengers. There can be at most one stop with the same label at a time. The label matches the GTFS stop_code. */
  readonly label?: InputMaybe<Scalars['String']['input']>;
  /** The infrastructure link on which the stop is located. */
  readonly located_on_infrastructure_link_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The measured location describes the physical location of the stop. For some stops this describes the location of the pole-mounted flag. A PostGIS PointZ geography in EPSG:4326. */
  readonly measured_location?: InputMaybe<Scalars['geography_point']['input']>;
  readonly priority?: InputMaybe<Scalars['Int']['input']>;
  /** The ID of the scheduled stop point. */
  readonly scheduled_stop_point_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The id of the related stop place in stop registry database. */
  readonly stop_place_ref?: InputMaybe<Scalars['String']['input']>;
  /** Optional reference to a TIMING PLACE. If NULL, the SCHEDULED STOP POINT is not used for timing. */
  readonly timing_place_id?: InputMaybe<Scalars['uuid']['input']>;
  /** end of the operating date span in the scheduled stop point's local time (inclusive). */
  readonly validity_end?: InputMaybe<Scalars['date']['input']>;
  /** start of the operating date span in the scheduled stop point's local time (inclusive). */
  readonly validity_start?: InputMaybe<Scalars['date']['input']>;
};

/** aggregate stddev on columns */
export type ServicePatternScheduledStopPointStddevFields = {
  readonly __typename?: 'service_pattern_scheduled_stop_point_stddev_fields';
  readonly priority?: Maybe<Scalars['Float']['output']>;
  /** The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]. */
  readonly relative_distance_from_infrastructure_link_start?: Maybe<Scalars['float8']['output']>;
};

/** order by stddev() on columns of table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointStddevOrderBy = {
  readonly priority?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type ServicePatternScheduledStopPointStddevPopFields = {
  readonly __typename?: 'service_pattern_scheduled_stop_point_stddev_pop_fields';
  readonly priority?: Maybe<Scalars['Float']['output']>;
  /** The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]. */
  readonly relative_distance_from_infrastructure_link_start?: Maybe<Scalars['float8']['output']>;
};

/** order by stddev_pop() on columns of table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointStddevPopOrderBy = {
  readonly priority?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type ServicePatternScheduledStopPointStddevSampFields = {
  readonly __typename?: 'service_pattern_scheduled_stop_point_stddev_samp_fields';
  readonly priority?: Maybe<Scalars['Float']['output']>;
  /** The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]. */
  readonly relative_distance_from_infrastructure_link_start?: Maybe<Scalars['float8']['output']>;
};

/** order by stddev_samp() on columns of table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointStddevSampOrderBy = {
  readonly priority?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "service_pattern_scheduled_stop_point" */
export type ServicePatternScheduledStopPointStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: ServicePatternScheduledStopPointStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ServicePatternScheduledStopPointStreamCursorValueInput = {
  /** The direction(s) of traffic with respect to the digitization, i.e. the direction of the specified line string. */
  readonly direction?: InputMaybe<InfrastructureNetworkDirectionEnum>;
  /** The label is the short code that identifies the stop to the passengers. There can be at most one stop with the same label at a time. The label matches the GTFS stop_code. */
  readonly label?: InputMaybe<Scalars['String']['input']>;
  /** The infrastructure link on which the stop is located. */
  readonly located_on_infrastructure_link_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The measured location describes the physical location of the stop. For some stops this describes the location of the pole-mounted flag. A PostGIS PointZ geography in EPSG:4326. */
  readonly measured_location?: InputMaybe<Scalars['geography']['input']>;
  readonly priority?: InputMaybe<Scalars['Int']['input']>;
  /** The ID of the scheduled stop point. */
  readonly scheduled_stop_point_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The id of the related stop place in stop registry database. */
  readonly stop_place_ref?: InputMaybe<Scalars['String']['input']>;
  /** Optional reference to a TIMING PLACE. If NULL, the SCHEDULED STOP POINT is not used for timing. */
  readonly timing_place_id?: InputMaybe<Scalars['uuid']['input']>;
  /** end of the operating date span in the scheduled stop point's local time (inclusive). */
  readonly validity_end?: InputMaybe<Scalars['date']['input']>;
  /** start of the operating date span in the scheduled stop point's local time (inclusive). */
  readonly validity_start?: InputMaybe<Scalars['date']['input']>;
};

/** aggregate sum on columns */
export type ServicePatternScheduledStopPointSumFields = {
  readonly __typename?: 'service_pattern_scheduled_stop_point_sum_fields';
  readonly priority?: Maybe<Scalars['Int']['output']>;
  /** The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]. */
  readonly relative_distance_from_infrastructure_link_start?: Maybe<Scalars['float8']['output']>;
};

/** order by sum() on columns of table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointSumOrderBy = {
  readonly priority?: InputMaybe<OrderBy>;
};

/** update columns of table "service_pattern.scheduled_stop_point" */
export enum ServicePatternScheduledStopPointUpdateColumn {
  /** column name */
  Direction = 'direction',
  /** column name */
  Label = 'label',
  /** column name */
  LocatedOnInfrastructureLinkId = 'located_on_infrastructure_link_id',
  /** column name */
  MeasuredLocation = 'measured_location',
  /** column name */
  Priority = 'priority',
  /** column name */
  ScheduledStopPointId = 'scheduled_stop_point_id',
  /** column name */
  StopPlaceRef = 'stop_place_ref',
  /** column name */
  TimingPlaceId = 'timing_place_id',
  /** column name */
  ValidityEnd = 'validity_end',
  /** column name */
  ValidityStart = 'validity_start'
}

export type ServicePatternScheduledStopPointUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<ServicePatternScheduledStopPointIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<ServicePatternScheduledStopPointSetInput>;
  /** filter the rows which have to be updated */
  readonly where: ServicePatternScheduledStopPointBoolExp;
};

/** aggregate var_pop on columns */
export type ServicePatternScheduledStopPointVarPopFields = {
  readonly __typename?: 'service_pattern_scheduled_stop_point_var_pop_fields';
  readonly priority?: Maybe<Scalars['Float']['output']>;
  /** The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]. */
  readonly relative_distance_from_infrastructure_link_start?: Maybe<Scalars['float8']['output']>;
};

/** order by var_pop() on columns of table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointVarPopOrderBy = {
  readonly priority?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type ServicePatternScheduledStopPointVarSampFields = {
  readonly __typename?: 'service_pattern_scheduled_stop_point_var_samp_fields';
  readonly priority?: Maybe<Scalars['Float']['output']>;
  /** The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]. */
  readonly relative_distance_from_infrastructure_link_start?: Maybe<Scalars['float8']['output']>;
};

/** order by var_samp() on columns of table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointVarSampOrderBy = {
  readonly priority?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type ServicePatternScheduledStopPointVarianceFields = {
  readonly __typename?: 'service_pattern_scheduled_stop_point_variance_fields';
  readonly priority?: Maybe<Scalars['Float']['output']>;
  /** The relative distance of the stop from the start of the linestring along the infrastructure link. Regardless of the specified direction, this value is the distance from the beginning of the linestring. The distance is normalized to the closed interval [0, 1]. */
  readonly relative_distance_from_infrastructure_link_start?: Maybe<Scalars['float8']['output']>;
};

/** order by variance() on columns of table "service_pattern.scheduled_stop_point" */
export type ServicePatternScheduledStopPointVarianceOrderBy = {
  readonly priority?: InputMaybe<OrderBy>;
};

/** Which scheduled stop points are serviced by which vehicle modes? */
export type ServicePatternVehicleModeOnScheduledStopPoint = {
  readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point';
  /** The scheduled stop point that is serviced by the vehicle mode. */
  readonly scheduled_stop_point_id: Scalars['uuid']['output'];
  /** The vehicle mode servicing the scheduled stop point. */
  readonly vehicle_mode: ReusableComponentsVehicleModeEnum;
};

/** aggregated selection of "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export type ServicePatternVehicleModeOnScheduledStopPointAggregate = {
  readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point_aggregate';
  readonly aggregate?: Maybe<ServicePatternVehicleModeOnScheduledStopPointAggregateFields>;
  readonly nodes: ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPoint>;
};

export type ServicePatternVehicleModeOnScheduledStopPointAggregateBoolExp = {
  readonly count?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointAggregateBoolExpCount>;
};

export type ServicePatternVehicleModeOnScheduledStopPointAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPointSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointBoolExp>;
  readonly predicate: IntComparisonExp;
};

/** aggregate fields of "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export type ServicePatternVehicleModeOnScheduledStopPointAggregateFields = {
  readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point_aggregate_fields';
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<ServicePatternVehicleModeOnScheduledStopPointMaxFields>;
  readonly min?: Maybe<ServicePatternVehicleModeOnScheduledStopPointMinFields>;
};


/** aggregate fields of "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export type ServicePatternVehicleModeOnScheduledStopPointAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPointSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export type ServicePatternVehicleModeOnScheduledStopPointAggregateOrderBy = {
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointMaxOrderBy>;
  readonly min?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointMinOrderBy>;
};

/** input type for inserting array relation for remote table "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export type ServicePatternVehicleModeOnScheduledStopPointArrRelInsertInput = {
  readonly data: ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPointInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointOnConflict>;
};

/** Boolean expression to filter rows from the table "service_pattern.vehicle_mode_on_scheduled_stop_point". All fields are combined with a logical 'AND'. */
export type ServicePatternVehicleModeOnScheduledStopPointBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPointBoolExp>>;
  readonly _not?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPointBoolExp>>;
  readonly scheduled_stop_point_id?: InputMaybe<UuidComparisonExp>;
  readonly vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnumComparisonExp>;
};

/** unique or primary key constraints on table "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export enum ServicePatternVehicleModeOnScheduledStopPointConstraint {
  /** unique or primary key constraint on columns "scheduled_stop_point_id", "vehicle_mode" */
  ScheduledStopPointServicedByVehicleModePkey = 'scheduled_stop_point_serviced_by_vehicle_mode_pkey'
}

/** input type for inserting data into table "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export type ServicePatternVehicleModeOnScheduledStopPointInsertInput = {
  /** The scheduled stop point that is serviced by the vehicle mode. */
  readonly scheduled_stop_point_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The vehicle mode servicing the scheduled stop point. */
  readonly vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnum>;
};

/** aggregate max on columns */
export type ServicePatternVehicleModeOnScheduledStopPointMaxFields = {
  readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point_max_fields';
  /** The scheduled stop point that is serviced by the vehicle mode. */
  readonly scheduled_stop_point_id?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export type ServicePatternVehicleModeOnScheduledStopPointMaxOrderBy = {
  /** The scheduled stop point that is serviced by the vehicle mode. */
  readonly scheduled_stop_point_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type ServicePatternVehicleModeOnScheduledStopPointMinFields = {
  readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point_min_fields';
  /** The scheduled stop point that is serviced by the vehicle mode. */
  readonly scheduled_stop_point_id?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export type ServicePatternVehicleModeOnScheduledStopPointMinOrderBy = {
  /** The scheduled stop point that is serviced by the vehicle mode. */
  readonly scheduled_stop_point_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export type ServicePatternVehicleModeOnScheduledStopPointMutationResponse = {
  readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPoint>;
};

/** on_conflict condition type for table "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export type ServicePatternVehicleModeOnScheduledStopPointOnConflict = {
  readonly constraint: ServicePatternVehicleModeOnScheduledStopPointConstraint;
  readonly update_columns?: ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPointUpdateColumn>;
  readonly where?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointBoolExp>;
};

/** Ordering options when selecting data from "service_pattern.vehicle_mode_on_scheduled_stop_point". */
export type ServicePatternVehicleModeOnScheduledStopPointOrderBy = {
  readonly scheduled_stop_point_id?: InputMaybe<OrderBy>;
  readonly vehicle_mode?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: service_pattern.vehicle_mode_on_scheduled_stop_point */
export type ServicePatternVehicleModeOnScheduledStopPointPkColumnsInput = {
  /** The scheduled stop point that is serviced by the vehicle mode. */
  readonly scheduled_stop_point_id: Scalars['uuid']['input'];
  /** The vehicle mode servicing the scheduled stop point. */
  readonly vehicle_mode: ReusableComponentsVehicleModeEnum;
};

/** select columns of table "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export enum ServicePatternVehicleModeOnScheduledStopPointSelectColumn {
  /** column name */
  ScheduledStopPointId = 'scheduled_stop_point_id',
  /** column name */
  VehicleMode = 'vehicle_mode'
}

/** input type for updating data in table "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export type ServicePatternVehicleModeOnScheduledStopPointSetInput = {
  /** The scheduled stop point that is serviced by the vehicle mode. */
  readonly scheduled_stop_point_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The vehicle mode servicing the scheduled stop point. */
  readonly vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnum>;
};

/** Streaming cursor of the table "service_pattern_vehicle_mode_on_scheduled_stop_point" */
export type ServicePatternVehicleModeOnScheduledStopPointStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: ServicePatternVehicleModeOnScheduledStopPointStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ServicePatternVehicleModeOnScheduledStopPointStreamCursorValueInput = {
  /** The scheduled stop point that is serviced by the vehicle mode. */
  readonly scheduled_stop_point_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The vehicle mode servicing the scheduled stop point. */
  readonly vehicle_mode?: InputMaybe<ReusableComponentsVehicleModeEnum>;
};

/** update columns of table "service_pattern.vehicle_mode_on_scheduled_stop_point" */
export enum ServicePatternVehicleModeOnScheduledStopPointUpdateColumn {
  /** column name */
  ScheduledStopPointId = 'scheduled_stop_point_id',
  /** column name */
  VehicleMode = 'vehicle_mode'
}

export type ServicePatternVehicleModeOnScheduledStopPointUpdates = {
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointSetInput>;
  /** filter the rows which have to be updated */
  readonly where: ServicePatternVehicleModeOnScheduledStopPointBoolExp;
};

/** Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'. */
export type SmallintComparisonExp = {
  readonly _eq?: InputMaybe<Scalars['smallint']['input']>;
  readonly _gt?: InputMaybe<Scalars['smallint']['input']>;
  readonly _gte?: InputMaybe<Scalars['smallint']['input']>;
  readonly _in?: InputMaybe<ReadonlyArray<Scalars['smallint']['input']>>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _lt?: InputMaybe<Scalars['smallint']['input']>;
  readonly _lte?: InputMaybe<Scalars['smallint']['input']>;
  readonly _neq?: InputMaybe<Scalars['smallint']['input']>;
  readonly _nin?: InputMaybe<ReadonlyArray<Scalars['smallint']['input']>>;
};

export type StDWithinGeographyInput = {
  readonly distance: Scalars['Float']['input'];
  readonly from: Scalars['geography']['input'];
  readonly use_spheroid?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StDWithinInput = {
  readonly distance: Scalars['Float']['input'];
  readonly from: Scalars['geometry']['input'];
};

export type StopPlaceAccessSpacesAggregateBoolExp = {
  readonly count?: InputMaybe<StopPlaceAccessSpacesAggregateBoolExpCount>;
};

export type StopPlaceAccessSpacesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAccessSpacesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type StopPlaceAlternativeNamesAggregateBoolExp = {
  readonly count?: InputMaybe<StopPlaceAlternativeNamesAggregateBoolExpCount>;
};

export type StopPlaceAlternativeNamesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAlternativeNamesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type StopPlaceChildrenAggregateBoolExp = {
  readonly count?: InputMaybe<StopPlaceChildrenAggregateBoolExpCount>;
};

export type StopPlaceChildrenAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceChildrenSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type StopPlaceEquipmentPlacesAggregateBoolExp = {
  readonly count?: InputMaybe<StopPlaceEquipmentPlacesAggregateBoolExpCount>;
};

export type StopPlaceEquipmentPlacesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlacesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type StopPlaceKeyValuesAggregateBoolExp = {
  readonly count?: InputMaybe<StopPlaceKeyValuesAggregateBoolExpCount>;
};

export type StopPlaceKeyValuesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceKeyValuesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseStopPlaceKeyValuesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type StopPlaceQuaysAggregateBoolExp = {
  readonly count?: InputMaybe<StopPlaceQuaysAggregateBoolExpCount>;
};

export type StopPlaceQuaysAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceQuaysSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseStopPlaceQuaysBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type StopPlaceTariffZonesAggregateBoolExp = {
  readonly count?: InputMaybe<StopPlaceTariffZonesAggregateBoolExpCount>;
};

export type StopPlaceTariffZonesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceTariffZonesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseStopPlaceTariffZonesBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type StopRegistryStopPlaceMutation = {
  readonly __typename?: 'stop_registryStopPlaceMutation';
  /** Adds a StopPlace to an existing ParentStopPlace */
  readonly addToMultiModalStopPlace?: Maybe<StopRegistryParentStopPlace>;
  /** Creates a new multimodal parent StopPlace */
  readonly createMultiModalStopPlace?: Maybe<StopRegistryParentStopPlace>;
  /** Create tag for referenced entity. */
  readonly createTag?: Maybe<StopRegistryTag>;
  /** Hard delete group of stop places by ID */
  readonly deleteGroupOfStopPlaces?: Maybe<Scalars['Boolean']['output']>;
  /** !!! Deletes all versions of Organisation from database - use with caution !!! */
  readonly deleteOrganisation?: Maybe<Scalars['Boolean']['output']>;
  /** !!! Deletes all versions of Parking from database - use with caution !!! */
  readonly deleteParking?: Maybe<Scalars['Boolean']['output']>;
  /** Removes quay from StopPlace */
  readonly deleteQuay?: Maybe<StopRegistryStopPlaceInterface>;
  /** !!! Deletes all versions of StopPlace from database - use with caution !!! */
  readonly deleteStopPlace?: Maybe<Scalars['Boolean']['output']>;
  /** Merges two Quays on a StopPlace. */
  readonly mergeQuays?: Maybe<StopRegistryStopPlaceInterface>;
  /** Merges two StopPlaces by terminating 'from'-StopPlace, and copying quays/values into 'to'-StopPlace */
  readonly mergeStopPlaces?: Maybe<StopRegistryStopPlaceInterface>;
  /** Moves one or more quays to a new or existing stop place. Returns the destination stop place. */
  readonly moveQuaysToStop?: Maybe<StopRegistryStopPlaceInterface>;
  /** Mutate group of stop places */
  readonly mutateGroupOfStopPlaces?: Maybe<StopRegistryGroupOfStopPlaces>;
  /** Create new or update existing infoSpot */
  readonly mutateInfoSpots?: Maybe<ReadonlyArray<Maybe<StopRegistryInfoSpot>>>;
  /** Create new or update existing Organisation */
  readonly mutateOrganisation?: Maybe<ReadonlyArray<Maybe<StopRegistryOrganisation>>>;
  /** Update existing Parent StopPlace */
  readonly mutateParentStopPlace?: Maybe<ReadonlyArray<Maybe<StopRegistryParentStopPlace>>>;
  /** Create new or update existing Parking */
  readonly mutateParking?: Maybe<ReadonlyArray<Maybe<StopRegistryParking>>>;
  /** Create new or update existing PathLink */
  readonly mutatePathlink?: Maybe<ReadonlyArray<Maybe<StopRegistryPathLink>>>;
  /** Mutate purpose of grouping */
  readonly mutatePurposeOfGrouping?: Maybe<StopRegistryPurposeOfGrouping>;
  /** Create new or update existing StopPlace */
  readonly mutateStopPlace?: Maybe<ReadonlyArray<Maybe<StopRegistryStopPlace>>>;
  /** Removes a StopPlace from an existing ParentStopPlace */
  readonly removeFromMultiModalStopPlace?: Maybe<StopRegistryParentStopPlace>;
  /** Remove tag from referenced entity */
  readonly removeTag?: Maybe<StopRegistryTag>;
  /** StopPlace will be reopened and immidiately active. */
  readonly reopenStopPlace?: Maybe<StopRegistryStopPlaceInterface>;
  /** StopPlace will be terminated and no longer be active after the given date. */
  readonly terminateStopPlace?: Maybe<StopRegistryStopPlaceInterface>;
  /** TariffZone will be terminated and no longer be active after the given date. */
  readonly terminateTariffZone?: Maybe<StopRegistryTariffZone>;
};


export type StopRegistryStopPlaceMutationAddToMultiModalStopPlaceArgs = {
  input?: InputMaybe<StopRegistryAddToMultiModalStopPlaceInput>;
};


export type StopRegistryStopPlaceMutationCreateMultiModalStopPlaceArgs = {
  input?: InputMaybe<StopRegistryCreateMultiModalStopPlaceInput>;
};


export type StopRegistryStopPlaceMutationCreateTagArgs = {
  comment?: InputMaybe<Scalars['String']['input']>;
  idReference: Scalars['String']['input'];
  name: Scalars['String']['input'];
};


export type StopRegistryStopPlaceMutationDeleteGroupOfStopPlacesArgs = {
  id: Scalars['String']['input'];
};


export type StopRegistryStopPlaceMutationDeleteOrganisationArgs = {
  organisationId: Scalars['String']['input'];
};


export type StopRegistryStopPlaceMutationDeleteParkingArgs = {
  parkingId: Scalars['String']['input'];
};


export type StopRegistryStopPlaceMutationDeleteQuayArgs = {
  quayId: Scalars['String']['input'];
  stopPlaceId: Scalars['String']['input'];
  versionComment?: InputMaybe<Scalars['String']['input']>;
};


export type StopRegistryStopPlaceMutationDeleteStopPlaceArgs = {
  stopPlaceId: Scalars['String']['input'];
};


export type StopRegistryStopPlaceMutationMergeQuaysArgs = {
  dryRun?: InputMaybe<Scalars['Boolean']['input']>;
  fromQuayId: Scalars['String']['input'];
  stopPlaceId: Scalars['String']['input'];
  toQuayId: Scalars['String']['input'];
  versionComment?: InputMaybe<Scalars['String']['input']>;
};


export type StopRegistryStopPlaceMutationMergeStopPlacesArgs = {
  dryRun?: InputMaybe<Scalars['Boolean']['input']>;
  fromStopPlaceId: Scalars['String']['input'];
  fromVersionComment?: InputMaybe<Scalars['String']['input']>;
  toStopPlaceId: Scalars['String']['input'];
  toVersionComment?: InputMaybe<Scalars['String']['input']>;
};


export type StopRegistryStopPlaceMutationMoveQuaysToStopArgs = {
  fromVersionComment?: InputMaybe<Scalars['String']['input']>;
  moveQuayFromDate?: InputMaybe<Scalars['stop_registry_LocalDate']['input']>;
  quayIds?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  toStopPlaceId?: InputMaybe<Scalars['String']['input']>;
  toVersionComment?: InputMaybe<Scalars['String']['input']>;
};


export type StopRegistryStopPlaceMutationMutateGroupOfStopPlacesArgs = {
  GroupOfStopPlaces?: InputMaybe<StopRegistryGroupOfStopPlacesInput>;
};


export type StopRegistryStopPlaceMutationMutateInfoSpotsArgs = {
  infoSpot?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryInfoSpotInput>>>;
};


export type StopRegistryStopPlaceMutationMutateOrganisationArgs = {
  Organisation?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryOrganisationInput>>>;
};


export type StopRegistryStopPlaceMutationMutateParentStopPlaceArgs = {
  ParentStopPlace?: InputMaybe<StopRegistryParentStopPlaceInput>;
};


export type StopRegistryStopPlaceMutationMutateParkingArgs = {
  Parking?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryParkingInput>>>;
};


export type StopRegistryStopPlaceMutationMutatePathlinkArgs = {
  PathLink?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryPathLinkInput>>>;
};


export type StopRegistryStopPlaceMutationMutatePurposeOfGroupingArgs = {
  PurposeOfGrouping?: InputMaybe<StopRegistryPurposeOfGroupingInput>;
};


export type StopRegistryStopPlaceMutationMutateStopPlaceArgs = {
  StopPlace?: InputMaybe<StopRegistryStopPlaceInput>;
};


export type StopRegistryStopPlaceMutationRemoveFromMultiModalStopPlaceArgs = {
  parentSiteRef: Scalars['String']['input'];
  stopPlaceId?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
};


export type StopRegistryStopPlaceMutationRemoveTagArgs = {
  comment?: InputMaybe<Scalars['String']['input']>;
  idReference: Scalars['String']['input'];
  name: Scalars['String']['input'];
};


export type StopRegistryStopPlaceMutationReopenStopPlaceArgs = {
  stopPlaceId: Scalars['String']['input'];
  versionComment?: InputMaybe<Scalars['String']['input']>;
};


export type StopRegistryStopPlaceMutationTerminateStopPlaceArgs = {
  modificationEnumeration?: InputMaybe<StopRegistryModificationEnumerationType>;
  stopPlaceId: Scalars['String']['input'];
  toDate: Scalars['stop_registry_DateTime']['input'];
  versionComment?: InputMaybe<Scalars['String']['input']>;
};


export type StopRegistryStopPlaceMutationTerminateTariffZoneArgs = {
  tariffZoneId: Scalars['String']['input'];
  toDate: Scalars['stop_registry_DateTime']['input'];
  versionComment?: InputMaybe<Scalars['String']['input']>;
};

export type StopRegistryStopPlaceRegister = {
  readonly __typename?: 'stop_registryStopPlaceRegister';
  /** Fare zones */
  readonly fareZones?: Maybe<ReadonlyArray<Maybe<StopRegistryFareZone>>>;
  /** List all fare zone authorities. */
  readonly fareZonesAuthorities?: Maybe<ReadonlyArray<Maybe<Scalars['String']['output']>>>;
  /** Group of stop places */
  readonly groupOfStopPlaces?: Maybe<ReadonlyArray<Maybe<StopRegistryGroupOfStopPlaces>>>;
  /** Group of tariff zones */
  readonly groupOfTariffZones?: Maybe<ReadonlyArray<Maybe<StopRegistryGroupOfTariffZones>>>;
  /** Info spots */
  readonly infoSpots?: Maybe<ReadonlyArray<Maybe<StopRegistryInfoSpot>>>;
  /** Location permissions */
  readonly locationPermissions?: Maybe<StopRegistryEntityPermissions>;
  /** Find organisation */
  readonly organisation?: Maybe<ReadonlyArray<Maybe<StopRegistryOrganisation>>>;
  /** Find parking */
  readonly parking?: Maybe<ReadonlyArray<Maybe<StopRegistryParking>>>;
  /** Find path links */
  readonly pathLink?: Maybe<ReadonlyArray<Maybe<StopRegistryPathLink>>>;
  /** List all purpose of grouping */
  readonly purposeOfGrouping?: Maybe<ReadonlyArray<Maybe<StopRegistryPurposeOfGrouping>>>;
  /** Search for StopPlaces */
  readonly stopPlace?: Maybe<ReadonlyArray<Maybe<StopRegistryStopPlaceInterface>>>;
  /** Find StopPlaces within given BoundingBox. */
  readonly stopPlaceBBox?: Maybe<ReadonlyArray<Maybe<StopRegistryStopPlaceInterface>>>;
  /** Fetches already used tags by name distinctively */
  readonly tags?: Maybe<ReadonlyArray<Maybe<StopRegistryTag>>>;
  /** Tariff zones */
  readonly tariffZones?: Maybe<ReadonlyArray<Maybe<StopRegistryTariffZone>>>;
  /** Find topographic places */
  readonly topographicPlace?: Maybe<ReadonlyArray<Maybe<StopRegistryTopographicPlace>>>;
  /** User permissions */
  readonly userPermissions?: Maybe<StopRegistryUserPermissions>;
  /** List all valid Transportmode/Submode-combinations. */
  readonly validTransportModes?: Maybe<ReadonlyArray<Maybe<StopRegistryTransportModes>>>;
};


export type StopRegistryStopPlaceRegisterFareZonesArgs = {
  authorityRef?: InputMaybe<Scalars['String']['input']>;
  ids?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  page?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  scopingMethod?: InputMaybe<StopRegistryScopingMethodEnumerationType>;
  size?: InputMaybe<Scalars['Int']['input']>;
  zoneTopology?: InputMaybe<StopRegistryZoneTopologyEnumerationType>;
};


export type StopRegistryStopPlaceRegisterGroupOfStopPlacesArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  stopPlaceId?: InputMaybe<Scalars['String']['input']>;
};


export type StopRegistryStopPlaceRegisterGroupOfTariffZonesArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  tariffZoneId?: InputMaybe<Scalars['String']['input']>;
};


export type StopRegistryStopPlaceRegisterInfoSpotsArgs = {
  allVersions?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};


export type StopRegistryStopPlaceRegisterLocationPermissionsArgs = {
  latitude: Scalars['stop_registry_BigDecimal']['input'];
  longitude: Scalars['stop_registry_BigDecimal']['input'];
};


export type StopRegistryStopPlaceRegisterOrganisationArgs = {
  allVersions?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};


export type StopRegistryStopPlaceRegisterParkingArgs = {
  allVersions?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  stopPlaceId?: InputMaybe<Scalars['String']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};


export type StopRegistryStopPlaceRegisterPathLinkArgs = {
  allVersions?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  stopPlaceId?: InputMaybe<Scalars['String']['input']>;
};


export type StopRegistryStopPlaceRegisterPurposeOfGroupingArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
};


export type StopRegistryStopPlaceRegisterStopPlaceArgs = {
  allVersions?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  countryReference?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  countyReference?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  hasParking?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  importedId?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  municipalityReference?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  onlyMonomodalStopPlaces?: InputMaybe<Scalars['Boolean']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  pointInTime?: InputMaybe<Scalars['stop_registry_DateTime']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  stopPlaceType?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryStopPlaceType>>>;
  tags?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  values?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  version?: InputMaybe<Scalars['Int']['input']>;
  versionValidity?: InputMaybe<StopRegistryVersionValidity>;
  withDuplicatedQuayImportedIds?: InputMaybe<Scalars['Boolean']['input']>;
  withNearbySimilarDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
  withTags?: InputMaybe<Scalars['Boolean']['input']>;
  withoutLocationOnly?: InputMaybe<Scalars['Boolean']['input']>;
  withoutQuaysOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


export type StopRegistryStopPlaceRegisterStopPlaceBBoxArgs = {
  ignoreStopPlaceId?: InputMaybe<Scalars['String']['input']>;
  includeExpired?: InputMaybe<Scalars['Boolean']['input']>;
  latMax: Scalars['stop_registry_BigDecimal']['input'];
  latMin: Scalars['stop_registry_BigDecimal']['input'];
  lonMax: Scalars['stop_registry_BigDecimal']['input'];
  lonMin: Scalars['stop_registry_BigDecimal']['input'];
  page?: InputMaybe<Scalars['Int']['input']>;
  pointInTime?: InputMaybe<Scalars['stop_registry_DateTime']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
};


export type StopRegistryStopPlaceRegisterTagsArgs = {
  name: Scalars['String']['input'];
};


export type StopRegistryStopPlaceRegisterTariffZonesArgs = {
  ids?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  page?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
};


export type StopRegistryStopPlaceRegisterTopographicPlaceArgs = {
  allVersions?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  topographicPlaceType?: InputMaybe<StopRegistryTopographicPlaceType>;
};

export type StopRegistryAccessibilityAssessment = {
  readonly __typename?: 'stop_registry_AccessibilityAssessment';
  readonly hslAccessibilityProperties?: Maybe<StopRegistryHslAccessibilityProperties>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly limitations?: Maybe<StopRegistryAccessibilityLimitations>;
  readonly mobilityImpairedAccess?: Maybe<StopRegistryLimitationStatusType>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type StopRegistryAccessibilityAssessmentInput = {
  readonly hslAccessibilityProperties?: InputMaybe<StopRegistryHslAccessibilityPropertiesInput>;
  readonly id?: InputMaybe<Scalars['String']['input']>;
  readonly limitations?: InputMaybe<StopRegistryAccessibilityLimitationsInput>;
};

export type StopRegistryAccessibilityLimitations = {
  readonly __typename?: 'stop_registry_AccessibilityLimitations';
  readonly audibleSignalsAvailable?: Maybe<StopRegistryLimitationStatusType>;
  readonly escalatorFreeAccess?: Maybe<StopRegistryLimitationStatusType>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly liftFreeAccess?: Maybe<StopRegistryLimitationStatusType>;
  readonly stepFreeAccess?: Maybe<StopRegistryLimitationStatusType>;
  readonly version?: Maybe<Scalars['String']['output']>;
  readonly wheelchairAccess?: Maybe<StopRegistryLimitationStatusType>;
};

export type StopRegistryAccessibilityLimitationsInput = {
  readonly audibleSignalsAvailable: StopRegistryLimitationStatusType;
  readonly escalatorFreeAccess: StopRegistryLimitationStatusType;
  readonly id?: InputMaybe<Scalars['String']['input']>;
  readonly liftFreeAccess: StopRegistryLimitationStatusType;
  readonly stepFreeAccess: StopRegistryLimitationStatusType;
  readonly wheelchairAccess: StopRegistryLimitationStatusType;
};

export type StopRegistryAddressablePlace = {
  readonly __typename?: 'stop_registry_AddressablePlace';
  /** This field is set either on StopPlace (i.e. all Quays are equal), or on every Quay. */
  readonly accessibilityAssessment?: Maybe<StopRegistryAccessibilityAssessment>;
  readonly description?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly geometry?: Maybe<StopRegistryGeoJson>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly importedId?: Maybe<ReadonlyArray<Maybe<Scalars['String']['output']>>>;
  readonly keyValues?: Maybe<ReadonlyArray<Maybe<StopRegistryKeyValues>>>;
  readonly modificationEnumeration?: Maybe<StopRegistryModificationEnumerationType>;
  readonly name?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly placeEquipments?: Maybe<StopRegistryPlaceEquipments>;
  readonly polygon?: Maybe<StopRegistryGeoJson>;
  readonly privateCode?: Maybe<StopRegistryPrivateCode>;
  readonly publicCode?: Maybe<Scalars['String']['output']>;
  readonly shortName?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly validBetween?: Maybe<StopRegistryValidBetween>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type StopRegistryAlternativeName = {
  readonly __typename?: 'stop_registry_AlternativeName';
  readonly name: StopRegistryEmbeddableMultilingualString;
  readonly nameType: StopRegistryNameType;
};

export type StopRegistryAlternativeNameInput = {
  readonly name: StopRegistryEmbeddableMultilingualStringInput;
  readonly nameType?: InputMaybe<StopRegistryNameType>;
};

export type StopRegistryBoardingPosition = {
  readonly __typename?: 'stop_registry_BoardingPosition';
  readonly geometry?: Maybe<StopRegistryGeoJson>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly publicCode?: Maybe<Scalars['String']['output']>;
};

export type StopRegistryBoardingPositionInput = {
  readonly geometry?: InputMaybe<StopRegistryGeoJsonInput>;
  readonly id?: InputMaybe<Scalars['String']['input']>;
  readonly publicCode?: InputMaybe<Scalars['String']['input']>;
};

export type StopRegistryContact = {
  readonly __typename?: 'stop_registry_Contact';
  readonly contactPerson?: Maybe<Scalars['String']['output']>;
  readonly email?: Maybe<Scalars['String']['output']>;
  readonly fax?: Maybe<Scalars['String']['output']>;
  readonly furtherDetails?: Maybe<Scalars['String']['output']>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly phone?: Maybe<Scalars['String']['output']>;
  readonly url?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type StopRegistryContactInput = {
  readonly contactPerson?: InputMaybe<Scalars['String']['input']>;
  readonly email?: InputMaybe<Scalars['String']['input']>;
  readonly fax?: InputMaybe<Scalars['String']['input']>;
  readonly furtherDetails?: InputMaybe<Scalars['String']['input']>;
  readonly id?: InputMaybe<Scalars['String']['input']>;
  readonly phone?: InputMaybe<Scalars['String']['input']>;
  readonly url?: InputMaybe<Scalars['String']['input']>;
};

export type StopRegistryCycleStorageEquipment = {
  readonly __typename?: 'stop_registry_CycleStorageEquipment';
  readonly cycleStorageType?: Maybe<StopRegistryCycleStorageType>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly numberOfSpaces?: Maybe<Scalars['stop_registry_BigInteger']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type StopRegistryCycleStorageEquipmentInput = {
  readonly cycleStorageType?: InputMaybe<StopRegistryCycleStorageType>;
  readonly id?: InputMaybe<Scalars['String']['input']>;
  readonly numberOfSpaces?: InputMaybe<Scalars['stop_registry_BigInteger']['input']>;
};

export type StopRegistryEmbeddableMultilingualString = {
  readonly __typename?: 'stop_registry_EmbeddableMultilingualString';
  readonly lang?: Maybe<Scalars['String']['output']>;
  readonly value?: Maybe<Scalars['String']['output']>;
};

export type StopRegistryEmbeddableMultilingualStringInput = {
  readonly lang?: InputMaybe<Scalars['String']['input']>;
  readonly value?: InputMaybe<Scalars['String']['input']>;
};

export type StopRegistryEntityPermissions = {
  readonly __typename?: 'stop_registry_EntityPermissions';
  readonly allowedStopPlaceTypes?: Maybe<ReadonlyArray<Maybe<StopRegistryStopPlaceType>>>;
  readonly allowedSubmodes?: Maybe<ReadonlyArray<Maybe<StopRegistrySubmode>>>;
  readonly bannedStopPlaceTypes?: Maybe<ReadonlyArray<Maybe<StopRegistryStopPlaceType>>>;
  readonly bannedSubmodes?: Maybe<ReadonlyArray<Maybe<StopRegistrySubmode>>>;
  readonly canDelete?: Maybe<Scalars['Boolean']['output']>;
  readonly canEdit?: Maybe<Scalars['Boolean']['output']>;
};

/** The version of the referenced entity. */
export type StopRegistryEntityRef = {
  readonly __typename?: 'stop_registry_EntityRef';
  readonly addressablePlace?: Maybe<StopRegistryAddressablePlace>;
  readonly ref?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** A reference to an entity with version */
export type StopRegistryEntityRefInput = {
  /** The NeTEx ID of the of the referenced entity. The reference must already exist */
  readonly ref: Scalars['String']['input'];
  /** The version of the referenced entity. */
  readonly version?: InputMaybe<Scalars['String']['input']>;
};

export type StopRegistryFareZone = {
  readonly __typename?: 'stop_registry_FareZone';
  readonly authorityRef?: Maybe<Scalars['String']['output']>;
  readonly description?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly geometry?: Maybe<StopRegistryGeoJson>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly importedId?: Maybe<ReadonlyArray<Maybe<Scalars['String']['output']>>>;
  readonly keyValues?: Maybe<ReadonlyArray<Maybe<StopRegistryKeyValues>>>;
  readonly members?: Maybe<ReadonlyArray<Maybe<StopRegistryStopPlace>>>;
  readonly name?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly neighbours?: Maybe<ReadonlyArray<Maybe<StopRegistryFareZone>>>;
  readonly polygon?: Maybe<StopRegistryGeoJson>;
  readonly privateCode?: Maybe<StopRegistryPrivateCode>;
  readonly scopingMethod?: Maybe<StopRegistryScopingMethodEnumerationType>;
  readonly shortName?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly validBetween?: Maybe<StopRegistryValidBetween>;
  readonly version?: Maybe<Scalars['String']['output']>;
  readonly zoneTopology?: Maybe<StopRegistryZoneTopologyEnumerationType>;
};

export type StopRegistryGeneralSign = {
  readonly __typename?: 'stop_registry_GeneralSign';
  readonly content?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly lineSignage?: Maybe<Scalars['Boolean']['output']>;
  readonly mainLineSign?: Maybe<Scalars['Boolean']['output']>;
  readonly note?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly numberOfFrames?: Maybe<Scalars['Int']['output']>;
  readonly privateCode?: Maybe<StopRegistryPrivateCode>;
  readonly replacesRailSign?: Maybe<Scalars['Boolean']['output']>;
  readonly signContentType?: Maybe<StopRegistrySignContentType>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type StopRegistryGeneralSignInput = {
  readonly content?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  readonly id?: InputMaybe<Scalars['String']['input']>;
  readonly lineSignage?: InputMaybe<Scalars['Boolean']['input']>;
  readonly mainLineSign?: InputMaybe<Scalars['Boolean']['input']>;
  readonly note?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  readonly numberOfFrames?: InputMaybe<Scalars['Int']['input']>;
  readonly privateCode?: InputMaybe<StopRegistryPrivateCodeInput>;
  readonly replacesRailSign?: InputMaybe<Scalars['Boolean']['input']>;
  readonly signContentType?: InputMaybe<StopRegistrySignContentType>;
};

/** Geometry-object as specified in the GeoJSON-standard (https://geojson.org/geojson-spec.html). */
export type StopRegistryGeoJson = {
  readonly __typename?: 'stop_registry_GeoJSON';
  /** GeoJSON-standard coordinates */
  readonly coordinates?: Maybe<Scalars['stop_registry_Coordinates']['output']>;
  /** non standard coordinates */
  readonly legacyCoordinates?: Maybe<Scalars['stop_registry_legacyCoordinates']['output']>;
  readonly type?: Maybe<StopRegistryGeoJsonType>;
};

/** Geometry-object as specified in the GeoJSON-standard (https://geojson.org/geojson-spec.html). */
export type StopRegistryGeoJsonInput = {
  /** GeoJSON coordinates */
  readonly coordinates?: InputMaybe<Scalars['stop_registry_Coordinates']['input']>;
  /** non-standard coordinates */
  readonly legacyCoordinates?: InputMaybe<Scalars['stop_registry_legacyCoordinates']['input']>;
  readonly type: StopRegistryGeoJsonType;
};

export enum StopRegistryGeoJsonType {
  GeometryCollection = 'GeometryCollection',
  LineString = 'LineString',
  MultiLineString = 'MultiLineString',
  MultiPoint = 'MultiPoint',
  MultiPolygon = 'MultiPolygon',
  Point = 'Point',
  Polygon = 'Polygon'
}

export type StopRegistryGroupOfStopPlaces = {
  readonly __typename?: 'stop_registry_GroupOfStopPlaces';
  readonly alternativeNames?: Maybe<ReadonlyArray<Maybe<StopRegistryAlternativeName>>>;
  readonly description?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly geometry?: Maybe<StopRegistryGeoJson>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly members?: Maybe<ReadonlyArray<Maybe<StopRegistryStopPlaceInterface>>>;
  readonly name?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly permissions?: Maybe<StopRegistryEntityPermissions>;
  readonly purposeOfGrouping?: Maybe<StopRegistryPurposeOfGrouping>;
  readonly shortName?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly validBetween?: Maybe<StopRegistryValidBetween>;
  readonly version?: Maybe<Scalars['String']['output']>;
  readonly versionComment?: Maybe<Scalars['String']['output']>;
};

export type StopRegistryGroupOfStopPlacesInput = {
  readonly alternativeNames?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryAlternativeNameInput>>>;
  readonly description?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  readonly geometry?: InputMaybe<StopRegistryGeoJsonInput>;
  /** Ignore ID when creating new */
  readonly id?: InputMaybe<Scalars['String']['input']>;
  /** References to group of stop places members. Stop place IDs. */
  readonly members?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryVersionLessEntityRefInput>>>;
  readonly name: StopRegistryEmbeddableMultilingualStringInput;
  /** References to purpose of grouping */
  readonly purposeOfGrouping?: InputMaybe<StopRegistryVersionLessEntityRefInput>;
  readonly shortName?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  readonly validBetween?: InputMaybe<StopRegistryValidBetweenInput>;
  readonly versionComment?: InputMaybe<Scalars['String']['input']>;
};

export type StopRegistryGroupOfTariffZones = {
  readonly __typename?: 'stop_registry_GroupOfTariffZones';
  readonly description?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly members?: Maybe<ReadonlyArray<Maybe<StopRegistryFareZone>>>;
  readonly name?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly version?: Maybe<Scalars['String']['output']>;
  readonly versionComment?: Maybe<Scalars['String']['output']>;
};

export type StopRegistryHslAccessibilityProperties = {
  readonly __typename?: 'stop_registry_HslAccessibilityProperties';
  /** Esteettömyystaso: Täysin esteetön (fullyAccessible) / Vähäisiä esteitä (mostlyAccessible) / Osittain esteellinen (partiallyInaccessible) / Esteellinen (inaccessible) / Esteettömyystietoja puuttuu (unknown) */
  readonly accessibilityLevel?: Maybe<StopRegistryAccessibilityLevel>;
  /** Reunakiven etäisyys kiskon selästä (cm) */
  readonly curbBackOfRailDistance?: Maybe<Scalars['Float']['output']>;
  /** Reunakiven etäisyys kiskon ajoreunasta (cm) */
  readonly curbDriveSideOfRailDistance?: Maybe<Scalars['Float']['output']>;
  /** Kaareva pysäkki */
  readonly curvedStop?: Maybe<Scalars['Boolean']['output']>;
  /** Päätyluiskan kaltevuus (%) */
  readonly endRampSlope?: Maybe<Scalars['Float']['output']>;
  /** Opasteraita */
  readonly guidanceStripe?: Maybe<Scalars['Boolean']['output']>;
  /** Opaslaatat */
  readonly guidanceTiles?: Maybe<Scalars['Boolean']['output']>;
  /** Opasteiden tyyppi: Pisteopaste (braille) / Ei opastetta (none) / Muu opastus (other) */
  readonly guidanceType?: Maybe<StopRegistryGuidanceType>;
  readonly id?: Maybe<Scalars['String']['output']>;
  /** Alapienan korkeus (cm) */
  readonly lowerCleatHeight?: Maybe<Scalars['Float']['output']>;
  /** Kartan tyyppi: Kohokartta (tactile) / Ei karttaa (none) / Muu kartta (other) */
  readonly mapType?: Maybe<StopRegistryMapType>;
  /** Suojatien luiskaus */
  readonly pedestrianCrossingRampType?: Maybe<StopRegistryPedestrianCrossingRampType>;
  /** Pysäkkialueen varoitusalue */
  readonly platformEdgeWarningArea?: Maybe<Scalars['Boolean']['output']>;
  /** Palvelualueen pituus (m) */
  readonly serviceAreaLength?: Maybe<Scalars['Float']['output']>;
  /** Palvelualueen raidoitus */
  readonly serviceAreaStripes?: Maybe<Scalars['Boolean']['output']>;
  /** Palvelualueen leveys (m) */
  readonly serviceAreaWidth?: Maybe<Scalars['Float']['output']>;
  /** Katoksen ja ajoradan välinen leveys (cm) */
  readonly shelterLaneDistance?: Maybe<Scalars['Float']['output']>;
  /** Katoksen tyyppi: Leveä (wide) / Kapea (narrow) / Muu (other) */
  readonly shelterType?: Maybe<StopRegistryShelterWidthType>;
  /** Esteetön yhteys jalkakäytävältä pysäkille */
  readonly sidewalkAccessibleConnection?: Maybe<Scalars['Boolean']['output']>;
  /** Pysäkkialueen pituuskaltevuus (%) */
  readonly stopAreaLengthwiseSlope?: Maybe<Scalars['Float']['output']>;
  /** Pysäkkialueen sivukaltevuus (%) */
  readonly stopAreaSideSlope?: Maybe<Scalars['Float']['output']>;
  /** Pysäkin ympäristo: Esteellinen / Esteetön */
  readonly stopAreaSurroundingsAccessible?: Maybe<Scalars['Boolean']['output']>;
  /** Pysäkin korotus kiskon ajopintaan nähden (cm) */
  readonly stopElevationFromRailTop?: Maybe<Scalars['Float']['output']>;
  /** Pysäkin korotus jalkakäytävään nähden (cm) */
  readonly stopElevationFromSidewalk?: Maybe<Scalars['Float']['output']>;
  /** Pysäkin tyyppi: Syvennys (pullOut) / Uloke (busBulb) / Ajoradalla (inLane) / Muu (other) */
  readonly stopType?: Maybe<StopRegistryStopType>;
  /** Rakenteiden ja ajoradan välinen pienin leveys (cm) */
  readonly structureLaneDistance?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type StopRegistryHslAccessibilityPropertiesInput = {
  readonly accessibilityLevel?: InputMaybe<StopRegistryAccessibilityLevel>;
  readonly curbBackOfRailDistance?: InputMaybe<Scalars['Float']['input']>;
  readonly curbDriveSideOfRailDistance?: InputMaybe<Scalars['Float']['input']>;
  readonly curvedStop?: InputMaybe<Scalars['Boolean']['input']>;
  readonly endRampSlope?: InputMaybe<Scalars['Float']['input']>;
  readonly guidanceStripe?: InputMaybe<Scalars['Boolean']['input']>;
  readonly guidanceTiles?: InputMaybe<Scalars['Boolean']['input']>;
  readonly guidanceType?: InputMaybe<StopRegistryGuidanceType>;
  readonly id?: InputMaybe<Scalars['String']['input']>;
  readonly lowerCleatHeight?: InputMaybe<Scalars['Float']['input']>;
  readonly mapType?: InputMaybe<StopRegistryMapType>;
  readonly pedestrianCrossingRampType?: InputMaybe<StopRegistryPedestrianCrossingRampType>;
  readonly platformEdgeWarningArea?: InputMaybe<Scalars['Boolean']['input']>;
  readonly serviceAreaLength?: InputMaybe<Scalars['Float']['input']>;
  readonly serviceAreaStripes?: InputMaybe<Scalars['Boolean']['input']>;
  readonly serviceAreaWidth?: InputMaybe<Scalars['Float']['input']>;
  readonly shelterLaneDistance?: InputMaybe<Scalars['Float']['input']>;
  readonly shelterType?: InputMaybe<StopRegistryShelterWidthType>;
  readonly sidewalkAccessibleConnection?: InputMaybe<Scalars['Boolean']['input']>;
  readonly stopAreaLengthwiseSlope?: InputMaybe<Scalars['Float']['input']>;
  readonly stopAreaSideSlope?: InputMaybe<Scalars['Float']['input']>;
  readonly stopAreaSurroundingsAccessible?: InputMaybe<Scalars['Boolean']['input']>;
  readonly stopElevationFromRailTop?: InputMaybe<Scalars['Float']['input']>;
  readonly stopElevationFromSidewalk?: InputMaybe<Scalars['Float']['input']>;
  readonly stopType?: InputMaybe<StopRegistryStopType>;
  readonly structureLaneDistance?: InputMaybe<Scalars['Float']['input']>;
};

export enum StopRegistryInterchangeWeightingType {
  InterchangeAllowed = 'interchangeAllowed',
  NoInterchange = 'noInterchange',
  PreferredInterchange = 'preferredInterchange',
  RecommendedInterchange = 'recommendedInterchange'
}

export type StopRegistryKeyValues = {
  readonly __typename?: 'stop_registry_KeyValues';
  readonly key?: Maybe<Scalars['String']['output']>;
  readonly values?: Maybe<ReadonlyArray<Maybe<Scalars['String']['output']>>>;
};

export type StopRegistryKeyValuesInput = {
  readonly key?: InputMaybe<Scalars['String']['input']>;
  readonly values?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
};

export enum StopRegistryLimitationStatusType {
  False = 'FALSE',
  Partial = 'PARTIAL',
  True = 'TRUE',
  Unknown = 'UNKNOWN'
}

export enum StopRegistryModificationEnumerationType {
  Delete = 'delete',
  Delta = 'delta',
  New = 'new',
  Revise = 'revise'
}

export type StopRegistryOrganisation = {
  readonly __typename?: 'stop_registry_Organisation';
  readonly companyNumber?: Maybe<Scalars['String']['output']>;
  readonly contactDetails?: Maybe<StopRegistryContact>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly legalName?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly name?: Maybe<Scalars['String']['output']>;
  readonly organisationType?: Maybe<StopRegistryOrganisationType>;
  readonly privateCode?: Maybe<Scalars['String']['output']>;
  readonly privateContactDetails?: Maybe<StopRegistryContact>;
  readonly validBetween?: Maybe<StopRegistryValidBetween>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type StopRegistryOrganisationInput = {
  readonly companyNumber?: InputMaybe<Scalars['String']['input']>;
  readonly contactDetails?: InputMaybe<StopRegistryContactInput>;
  readonly id?: InputMaybe<Scalars['String']['input']>;
  readonly legalName?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  readonly name?: InputMaybe<Scalars['String']['input']>;
  readonly organisationType?: InputMaybe<StopRegistryOrganisationType>;
  readonly privateCode?: InputMaybe<Scalars['String']['input']>;
  readonly privateContactDetails?: InputMaybe<StopRegistryContactInput>;
  readonly validBetween?: InputMaybe<StopRegistryValidBetweenInput>;
};

export type StopRegistryParentStopPlace = StopRegistryStopPlaceInterface & {
  readonly __typename?: 'stop_registry_ParentStopPlace';
  /** This field is set either on StopPlace (i.e. all Quays are equal), or on every Quay. */
  readonly accessibilityAssessment?: Maybe<StopRegistryAccessibilityAssessment>;
  readonly alternativeNames?: Maybe<ReadonlyArray<Maybe<StopRegistryAlternativeName>>>;
  readonly changedBy?: Maybe<Scalars['String']['output']>;
  readonly children?: Maybe<ReadonlyArray<Maybe<StopRegistryStopPlace>>>;
  readonly description?: Maybe<StopRegistryEmbeddableMultilingualString>;
  /** External links */
  readonly externalLinks?: Maybe<ReadonlyArray<Maybe<StopRegistryStopPlaceExternalLink>>>;
  readonly fareZones?: Maybe<ReadonlyArray<Maybe<StopRegistryFareZone>>>;
  readonly geometry?: Maybe<StopRegistryGeoJson>;
  readonly groups?: Maybe<ReadonlyArray<Maybe<StopRegistryGroupOfStopPlaces>>>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly importedId?: Maybe<ReadonlyArray<Maybe<Scalars['String']['output']>>>;
  readonly infoSpots?: Maybe<ReadonlyArray<Maybe<StopRegistryInfoSpot>>>;
  readonly keyValues?: Maybe<ReadonlyArray<Maybe<StopRegistryKeyValues>>>;
  readonly modificationEnumeration?: Maybe<StopRegistryModificationEnumerationType>;
  readonly name?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly organisations?: Maybe<ReadonlyArray<Maybe<StopRegistryStopPlaceOrganisationRef>>>;
  readonly permissions?: Maybe<StopRegistryEntityPermissions>;
  readonly placeEquipments?: Maybe<StopRegistryPlaceEquipments>;
  readonly polygon?: Maybe<StopRegistryGeoJson>;
  readonly privateCode?: Maybe<StopRegistryPrivateCode>;
  readonly publicCode?: Maybe<Scalars['String']['output']>;
  readonly shortName?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly tags?: Maybe<ReadonlyArray<Maybe<StopRegistryTag>>>;
  readonly tariffZones?: Maybe<ReadonlyArray<Maybe<StopRegistryTariffZone>>>;
  readonly topographicPlace?: Maybe<StopRegistryTopographicPlace>;
  readonly validBetween?: Maybe<StopRegistryValidBetween>;
  readonly version?: Maybe<Scalars['String']['output']>;
  readonly versionComment?: Maybe<Scalars['String']['output']>;
};

export type StopRegistryParentStopPlaceInput = {
  /** This field is set either on StopPlace (i.e. all Quays are equal), or on every Quay. */
  readonly accessibilityAssessment?: InputMaybe<StopRegistryAccessibilityAssessmentInput>;
  readonly alternativeNames?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryAlternativeNameInput>>>;
  readonly children?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryStopPlaceInput>>>;
  readonly description?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  readonly externalLinks?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryExternalLinkInput>>>;
  readonly geometry?: InputMaybe<StopRegistryGeoJsonInput>;
  /** Ignore when creating new */
  readonly id?: InputMaybe<Scalars['String']['input']>;
  readonly keyValues?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryKeyValuesInput>>>;
  readonly name?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  readonly organisations?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryStopPlaceOrganisationRefInput>>>;
  readonly placeEquipments?: InputMaybe<StopRegistryPlaceEquipmentsInput>;
  readonly privateCode?: InputMaybe<StopRegistryPrivateCodeInput>;
  readonly publicCode?: InputMaybe<Scalars['String']['input']>;
  readonly shortName?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  readonly submode?: InputMaybe<StopRegistrySubmodeType>;
  readonly transportMode?: InputMaybe<StopRegistryTransportModeType>;
  readonly validBetween?: InputMaybe<StopRegistryValidBetweenInput>;
  readonly versionComment?: InputMaybe<Scalars['String']['input']>;
};

export type StopRegistryParking = {
  readonly __typename?: 'stop_registry_Parking';
  readonly bookingUrl?: Maybe<Scalars['String']['output']>;
  readonly freeParkingOutOfHours?: Maybe<Scalars['Boolean']['output']>;
  readonly geometry?: Maybe<StopRegistryGeoJson>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly name?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly overnightParkingPermitted?: Maybe<Scalars['Boolean']['output']>;
  readonly parentSiteRef?: Maybe<Scalars['String']['output']>;
  readonly parkingAreas?: Maybe<ReadonlyArray<Maybe<StopRegistryParkingArea>>>;
  readonly parkingLayout?: Maybe<StopRegistryParkingLayoutType>;
  readonly parkingPaymentProcess?: Maybe<ReadonlyArray<Maybe<StopRegistryParkingPaymentProcessType>>>;
  readonly parkingProperties?: Maybe<ReadonlyArray<Maybe<StopRegistryParkingProperties>>>;
  readonly parkingReservation?: Maybe<StopRegistryParkingReservationType>;
  readonly parkingType?: Maybe<StopRegistryParkingType>;
  readonly parkingVehicleTypes?: Maybe<ReadonlyArray<Maybe<StopRegistryParkingVehicleType>>>;
  readonly principalCapacity?: Maybe<Scalars['stop_registry_BigInteger']['output']>;
  readonly realTimeOccupancyAvailable?: Maybe<Scalars['Boolean']['output']>;
  readonly rechargingAvailable?: Maybe<Scalars['Boolean']['output']>;
  readonly secure?: Maybe<Scalars['Boolean']['output']>;
  readonly totalCapacity?: Maybe<Scalars['stop_registry_BigInteger']['output']>;
  readonly validBetween?: Maybe<StopRegistryValidBetween>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type StopRegistryParkingArea = {
  readonly __typename?: 'stop_registry_ParkingArea';
  readonly label?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly parkingProperties?: Maybe<StopRegistryParkingProperties>;
  readonly totalCapacity?: Maybe<Scalars['stop_registry_BigInteger']['output']>;
};

export type StopRegistryParkingAreaInput = {
  readonly label?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  readonly parkingProperties?: InputMaybe<StopRegistryParkingPropertiesInput>;
  readonly totalCapacity?: InputMaybe<Scalars['stop_registry_BigInteger']['input']>;
};

export type StopRegistryParkingCapacity = {
  readonly __typename?: 'stop_registry_ParkingCapacity';
  readonly numberOfSpaces?: Maybe<Scalars['stop_registry_BigInteger']['output']>;
  readonly numberOfSpacesWithRechargePoint?: Maybe<Scalars['stop_registry_BigInteger']['output']>;
  readonly parkingStayType?: Maybe<StopRegistryParkingStayType>;
  readonly parkingUserType?: Maybe<StopRegistryParkingUserType>;
  readonly parkingVehicleType?: Maybe<StopRegistryParkingVehicleType>;
};

export type StopRegistryParkingCapacityInput = {
  readonly numberOfSpaces?: InputMaybe<Scalars['stop_registry_BigInteger']['input']>;
  readonly numberOfSpacesWithRechargePoint?: InputMaybe<Scalars['stop_registry_BigInteger']['input']>;
  readonly parkingStayType?: InputMaybe<StopRegistryParkingStayType>;
  readonly parkingUserType?: InputMaybe<StopRegistryParkingUserType>;
  readonly parkingVehicleType?: InputMaybe<StopRegistryParkingVehicleType>;
};

export type StopRegistryParkingInput = {
  readonly bookingUrl?: InputMaybe<Scalars['String']['input']>;
  readonly freeParkingOutOfHours?: InputMaybe<Scalars['Boolean']['input']>;
  readonly geometry?: InputMaybe<StopRegistryGeoJsonInput>;
  readonly id?: InputMaybe<Scalars['String']['input']>;
  readonly name?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  readonly overnightParkingPermitted?: InputMaybe<Scalars['Boolean']['input']>;
  readonly parentSiteRef?: InputMaybe<Scalars['String']['input']>;
  readonly parkingAreas?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryParkingAreaInput>>>;
  readonly parkingLayout?: InputMaybe<StopRegistryParkingLayoutType>;
  readonly parkingPaymentProcess?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryParkingPaymentProcessType>>>;
  readonly parkingProperties?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryParkingPropertiesInput>>>;
  readonly parkingReservation?: InputMaybe<StopRegistryParkingReservationType>;
  readonly parkingType?: InputMaybe<StopRegistryParkingType>;
  readonly parkingVehicleTypes?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryParkingVehicleType>>>;
  readonly principalCapacity?: InputMaybe<Scalars['stop_registry_BigInteger']['input']>;
  readonly realTimeOccupancyAvailable?: InputMaybe<Scalars['Boolean']['input']>;
  readonly rechargingAvailable?: InputMaybe<Scalars['Boolean']['input']>;
  readonly secure?: InputMaybe<Scalars['Boolean']['input']>;
  readonly validBetween?: InputMaybe<StopRegistryValidBetweenInput>;
};

export enum StopRegistryParkingLayoutType {
  Covered = 'covered',
  CycleHire = 'cycleHire',
  Multistorey = 'multistorey',
  OpenSpace = 'openSpace',
  Other = 'other',
  Roadside = 'roadside',
  Undefined = 'undefined',
  Underground = 'underground'
}

export enum StopRegistryParkingPaymentProcessType {
  Free = 'free',
  Other = 'other',
  PayAndDisplay = 'payAndDisplay',
  PayAtBay = 'payAtBay',
  PayAtExitBoothManualCollection = 'payAtExitBoothManualCollection',
  PayAtMachineOnFootPriorToExit = 'payAtMachineOnFootPriorToExit',
  PayByMobileDevice = 'payByMobileDevice',
  PayByPrepaidToken = 'payByPrepaidToken',
  Undefined = 'undefined'
}

export type StopRegistryParkingProperties = {
  readonly __typename?: 'stop_registry_ParkingProperties';
  readonly maximumStay?: Maybe<Scalars['stop_registry_BigInteger']['output']>;
  readonly parkingUserTypes?: Maybe<ReadonlyArray<Maybe<StopRegistryParkingUserType>>>;
  readonly spaces?: Maybe<ReadonlyArray<Maybe<StopRegistryParkingCapacity>>>;
};

export type StopRegistryParkingPropertiesInput = {
  readonly maximumStay?: InputMaybe<Scalars['stop_registry_BigInteger']['input']>;
  readonly parkingUserTypes?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryParkingUserType>>>;
  readonly spaces?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryParkingCapacityInput>>>;
};

export enum StopRegistryParkingReservationType {
  NoReservations = 'noReservations',
  Other = 'other',
  RegistrationRequired = 'registrationRequired',
  ReservationAllowed = 'reservationAllowed',
  ReservationRequired = 'reservationRequired'
}

export enum StopRegistryParkingStayType {
  All = 'all',
  Dropoff = 'dropoff',
  LongTerm = 'longTerm',
  MidTerm = 'midTerm',
  Other = 'other',
  ShortStay = 'shortStay',
  Unlimited = 'unlimited'
}

export enum StopRegistryParkingType {
  AirportParking = 'airportParking',
  CycleRental = 'cycleRental',
  ExhibitionCentreParking = 'exhibitionCentreParking',
  LiftShareParking = 'liftShareParking',
  MotorwayParking = 'motorwayParking',
  Other = 'other',
  ParkAndRide = 'parkAndRide',
  ParkingZone = 'parkingZone',
  RentalCarParking = 'rentalCarParking',
  Roadside = 'roadside',
  ShoppingCentreParking = 'shoppingCentreParking',
  TrainStationParking = 'trainStationParking',
  Undefined = 'undefined',
  UrbanParking = 'urbanParking'
}

export enum StopRegistryParkingUserType {
  All = 'all',
  AllUsers = 'allUsers',
  Doctors = 'doctors',
  EmergencyServices = 'emergencyServices',
  Other = 'other',
  Registered = 'registered',
  RegisteredDisabled = 'registeredDisabled',
  Rental = 'rental',
  ReservationHolders = 'reservationHolders',
  ResidentsWithPermits = 'residentsWithPermits',
  Staff = 'staff',
  Visitors = 'visitors'
}

export enum StopRegistryParkingVehicleType {
  AgriculturalVehicle = 'agriculturalVehicle',
  All = 'all',
  AllPassengerVehicles = 'allPassengerVehicles',
  ArticulatedVehicle = 'articulatedVehicle',
  Bus = 'bus',
  CamperCar = 'camperCar',
  Car = 'car',
  CarWithCaravan = 'carWithCaravan',
  CarWithTrailer = 'carWithTrailer',
  FourWheelDrive = 'fourWheelDrive',
  HeavyGoodsVehicle = 'heavyGoodsVehicle',
  HeavyGoodsVehicleWithTrailer = 'heavyGoodsVehicleWithTrailer',
  HighSidedVehicle = 'highSidedVehicle',
  LargeCar = 'largeCar',
  LargeVan = 'largeVan',
  LightGoodsVehicle = 'lightGoodsVehicle',
  LightGoodsVehicleWithTrailer = 'lightGoodsVehicleWithTrailer',
  Minibus = 'minibus',
  Moped = 'moped',
  MotorScooter = 'motorScooter',
  Motorcycle = 'motorcycle',
  MotorcycleWithSidecar = 'motorcycleWithSidecar',
  Other = 'other',
  PassengerCar = 'passengerCar',
  PedalCycle = 'pedalCycle',
  SmallCar = 'smallCar',
  Tanker = 'tanker',
  Taxi = 'taxi',
  ThreeWheeledVehicle = 'threeWheeledVehicle',
  Tram = 'tram',
  Truck = 'truck',
  TwoWheeledVehicle = 'twoWheeledVehicle',
  Undefined = 'undefined',
  Van = 'van',
  VehicleWithTrailer = 'vehicleWithTrailer'
}

export type StopRegistryPathLink = {
  readonly __typename?: 'stop_registry_PathLink';
  readonly from?: Maybe<StopRegistryPathLinkEnd>;
  readonly geometry?: Maybe<StopRegistryGeoJson>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly to?: Maybe<StopRegistryPathLinkEnd>;
  readonly transferDuration?: Maybe<StopRegistryTransferDuration>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type StopRegistryPathLinkEnd = {
  readonly __typename?: 'stop_registry_PathLinkEnd';
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly placeRef?: Maybe<StopRegistryEntityRef>;
};

export type StopRegistryPathLinkEndInput = {
  readonly placeRef?: InputMaybe<StopRegistryEntityRefInput>;
};

/** Transfer durations in seconds */
export type StopRegistryPathLinkInput = {
  readonly from?: InputMaybe<StopRegistryPathLinkEndInput>;
  readonly geometry?: InputMaybe<StopRegistryGeoJsonInput>;
  readonly id?: InputMaybe<Scalars['String']['input']>;
  readonly to?: InputMaybe<StopRegistryPathLinkEndInput>;
  readonly transferDuration?: InputMaybe<StopRegistryTransferDurationInput>;
};

export type StopRegistryPlaceEquipments = {
  readonly __typename?: 'stop_registry_PlaceEquipments';
  readonly cycleStorageEquipment?: Maybe<ReadonlyArray<Maybe<StopRegistryCycleStorageEquipment>>>;
  readonly generalSign?: Maybe<ReadonlyArray<Maybe<StopRegistryGeneralSign>>>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly sanitaryEquipment?: Maybe<ReadonlyArray<Maybe<StopRegistrySanitaryEquipment>>>;
  readonly shelterEquipment?: Maybe<ReadonlyArray<Maybe<StopRegistryShelterEquipment>>>;
  readonly ticketingEquipment?: Maybe<ReadonlyArray<Maybe<StopRegistryTicketingEquipment>>>;
  readonly waitingRoomEquipment?: Maybe<ReadonlyArray<Maybe<StopRegistryWaitingRoomEquipment>>>;
};

export type StopRegistryPlaceEquipmentsInput = {
  readonly cycleStorageEquipment?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryCycleStorageEquipmentInput>>>;
  readonly generalSign?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryGeneralSignInput>>>;
  readonly sanitaryEquipment?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistrySanitaryEquipmentInput>>>;
  readonly shelterEquipment?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryShelterEquipmentInput>>>;
  readonly ticketingEquipment?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryTicketingEquipmentInput>>>;
  readonly waitingRoomEquipment?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryWaitingRoomEquipmentInput>>>;
};

export type StopRegistryPrivateCode = {
  readonly __typename?: 'stop_registry_PrivateCode';
  readonly type?: Maybe<Scalars['String']['output']>;
  readonly value?: Maybe<Scalars['String']['output']>;
};

export type StopRegistryPrivateCodeInput = {
  readonly type?: InputMaybe<Scalars['String']['input']>;
  readonly value: Scalars['String']['input'];
};

export type StopRegistryPurposeOfGrouping = {
  readonly __typename?: 'stop_registry_PurposeOfGrouping';
  readonly description?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly name?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly version?: Maybe<Scalars['String']['output']>;
  readonly versionComment?: Maybe<Scalars['String']['output']>;
};

export type StopRegistryPurposeOfGroupingInput = {
  readonly description?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  /** Ignore ID when creating new */
  readonly id?: InputMaybe<Scalars['String']['input']>;
  readonly name: StopRegistryEmbeddableMultilingualStringInput;
  readonly versionComment?: InputMaybe<Scalars['String']['input']>;
};

export type StopRegistryQuay = {
  readonly __typename?: 'stop_registry_Quay';
  /** This field is set either on StopPlace (i.e. all Quays are equal), or on every Quay. */
  readonly accessibilityAssessment?: Maybe<StopRegistryAccessibilityAssessment>;
  readonly alternativeNames?: Maybe<ReadonlyArray<Maybe<StopRegistryAlternativeName>>>;
  readonly boardingPositions?: Maybe<ReadonlyArray<Maybe<StopRegistryBoardingPosition>>>;
  readonly compassBearing?: Maybe<Scalars['stop_registry_BigDecimal']['output']>;
  readonly description?: Maybe<StopRegistryEmbeddableMultilingualString>;
  /** External links */
  readonly externalLinks?: Maybe<ReadonlyArray<Maybe<StopRegistryExternalLink>>>;
  readonly geometry?: Maybe<StopRegistryGeoJson>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly importedId?: Maybe<ReadonlyArray<Maybe<Scalars['String']['output']>>>;
  /** Info spots */
  readonly infoSpots?: Maybe<ReadonlyArray<Maybe<StopRegistryInfoSpot>>>;
  readonly keyValues?: Maybe<ReadonlyArray<Maybe<StopRegistryKeyValues>>>;
  readonly modificationEnumeration?: Maybe<StopRegistryModificationEnumerationType>;
  readonly name?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly placeEquipments?: Maybe<StopRegistryPlaceEquipments>;
  readonly polygon?: Maybe<StopRegistryGeoJson>;
  readonly privateCode?: Maybe<StopRegistryPrivateCode>;
  readonly publicCode?: Maybe<Scalars['String']['output']>;
  readonly scheduled_stop_point?: Maybe<ServicePatternScheduledStopPoint>;
  readonly shortName?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly validBetween?: Maybe<StopRegistryValidBetween>;
  readonly version?: Maybe<Scalars['String']['output']>;
  readonly versionComment?: Maybe<Scalars['String']['output']>;
};


export type StopRegistryQuayInfoSpotsArgs = {
  allVersions?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

export type StopRegistryQuayInput = {
  /** This field is set either on StopPlace (i.e. all Quays are equal), or on every Quay. */
  readonly accessibilityAssessment?: InputMaybe<StopRegistryAccessibilityAssessmentInput>;
  readonly alternativeNames?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryAlternativeNameInput>>>;
  readonly boardingPositions?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryBoardingPositionInput>>>;
  readonly compassBearing?: InputMaybe<Scalars['stop_registry_BigDecimal']['input']>;
  readonly description?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  readonly externalLinks?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryExternalLinkInput>>>;
  readonly geometry?: InputMaybe<StopRegistryGeoJsonInput>;
  /** Ignore when creating new */
  readonly id?: InputMaybe<Scalars['String']['input']>;
  readonly keyValues?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryKeyValuesInput>>>;
  readonly name?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  readonly placeEquipments?: InputMaybe<StopRegistryPlaceEquipmentsInput>;
  readonly privateCode?: InputMaybe<StopRegistryPrivateCodeInput>;
  readonly publicCode?: InputMaybe<Scalars['String']['input']>;
  readonly shortName?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  readonly versionComment?: InputMaybe<Scalars['String']['input']>;
};

export type StopRegistrySanitaryEquipment = {
  readonly __typename?: 'stop_registry_SanitaryEquipment';
  readonly gender?: Maybe<StopRegistryGender>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly numberOfToilets?: Maybe<Scalars['stop_registry_BigInteger']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type StopRegistrySanitaryEquipmentInput = {
  readonly gender?: InputMaybe<StopRegistryGender>;
  readonly id?: InputMaybe<Scalars['String']['input']>;
  readonly numberOfToilets?: InputMaybe<Scalars['stop_registry_BigInteger']['input']>;
};

export enum StopRegistryScopingMethodEnumerationType {
  ExplicitPeripheryStops = 'explicitPeripheryStops',
  ExplicitStops = 'explicitStops',
  ImplicitSpatialProjection = 'implicitSpatialProjection',
  Other = 'other'
}

export type StopRegistryShelterEquipment = {
  readonly __typename?: 'stop_registry_ShelterEquipment';
  /** Pyöräpysäköinti */
  readonly bicycleParking?: Maybe<Scalars['Boolean']['output']>;
  readonly enclosed?: Maybe<Scalars['Boolean']['output']>;
  readonly id?: Maybe<Scalars['String']['output']>;
  /** Nojailutanko */
  readonly leaningRail?: Maybe<Scalars['Boolean']['output']>;
  /** Ulkopenkki */
  readonly outsideBench?: Maybe<Scalars['Boolean']['output']>;
  readonly seats?: Maybe<Scalars['stop_registry_BigInteger']['output']>;
  /** Katoksen kunto: Hyvä (good), Välttävä (mediocre), Huono (bad) */
  readonly shelterCondition?: Maybe<StopRegistryShelterCondition>;
  /** Katoksen sähköt: Jatkuva sähkö (continuous) / Valosähkö (light) / Jatkuva rakenteilla (continuousUnderConstruction) / Jatkuva suunniteltu (continuousPlanned) / Tilapäisesti pois (temporarilyOff) / Ei sähköä (none) */
  readonly shelterElectricity?: Maybe<StopRegistryShelterElectricity>;
  /** Pysäkkikatoksen varustenumero */
  readonly shelterExternalId?: Maybe<Scalars['String']['output']>;
  /** Pysäkkikatoksen otsalaudan teippaus */
  readonly shelterFasciaBoardTaping?: Maybe<Scalars['Boolean']['output']>;
  /** Katoksesssa näyttö */
  readonly shelterHasDisplay?: Maybe<Scalars['Boolean']['output']>;
  /** Katoksessa valot */
  readonly shelterLighting?: Maybe<Scalars['Boolean']['output']>;
  /** Pysäkkikatoksen numero */
  readonly shelterNumber?: Maybe<Scalars['Int']['output']>;
  /** Katoksen tyyppi: Lasikatos (glass) / Teräskatos (steel) / Tolppa (post) / Urbaanikatos (urban) / Betonikatos (concrete) / Puukatos (wooden) / Virtuaali (virtual) */
  readonly shelterType?: Maybe<StopRegistryShelterType>;
  readonly stepFree?: Maybe<Scalars['Boolean']['output']>;
  /** Aikataulukaappien lukumäärä */
  readonly timetableCabinets?: Maybe<Scalars['Int']['output']>;
  /** Katoksessa roska-astia */
  readonly trashCan?: Maybe<Scalars['Boolean']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type StopRegistryShelterEquipmentInput = {
  /** Pyöräpysäköinti */
  readonly bicycleParking?: InputMaybe<Scalars['Boolean']['input']>;
  readonly enclosed?: InputMaybe<Scalars['Boolean']['input']>;
  readonly id?: InputMaybe<Scalars['String']['input']>;
  /** Nojailutanko */
  readonly leaningRail?: InputMaybe<Scalars['Boolean']['input']>;
  /** Ulkopenkki */
  readonly outsideBench?: InputMaybe<Scalars['Boolean']['input']>;
  readonly seats?: InputMaybe<Scalars['stop_registry_BigInteger']['input']>;
  /** Katoksen kunto: Hyvä (good), Välttävä (mediocre), Huono (bad) */
  readonly shelterCondition?: InputMaybe<StopRegistryShelterCondition>;
  /** Katoksen sähköt: Jatkuva sähkö (continuous) / Valosähkö (light) / Jatkuva rakenteilla (continuousUnderConstruction) / Jatkuva suunniteltu (continuousPlanned) / Tilapäisesti pois (temporarilyOff) / Ei sähköä (none) */
  readonly shelterElectricity?: InputMaybe<StopRegistryShelterElectricity>;
  /** Pysäkkikatoksen varustenumero */
  readonly shelterExternalId?: InputMaybe<Scalars['String']['input']>;
  /** Pysäkkikatoksen otsalaudan teippaus */
  readonly shelterFasciaBoardTaping?: InputMaybe<Scalars['Boolean']['input']>;
  /** Katoksesssa näyttö */
  readonly shelterHasDisplay?: InputMaybe<Scalars['Boolean']['input']>;
  /** Katoksessa valot */
  readonly shelterLighting?: InputMaybe<Scalars['Boolean']['input']>;
  /** Pysäkkikatoksen numero */
  readonly shelterNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Katoksen tyyppi: Lasikatos (glass) / Teräskatos (steel) / Tolppa (post) / Urbaanikatos (urban) / Betonikatos (concrete) / Puukatos (wooden) / Virtuaali (virtual) */
  readonly shelterType?: InputMaybe<StopRegistryShelterType>;
  readonly stepFree?: InputMaybe<Scalars['Boolean']['input']>;
  /** Aikataulukaappien lukumäärä */
  readonly timetableCabinets?: InputMaybe<Scalars['Int']['input']>;
  /** Katoksessa roska-astia */
  readonly trashCan?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StopRegistryStopPlace = StopRegistryStopPlaceInterface & {
  readonly __typename?: 'stop_registry_StopPlace';
  /** This field is set either on StopPlace (i.e. all Quays are equal), or on every Quay. */
  readonly accessibilityAssessment?: Maybe<StopRegistryAccessibilityAssessment>;
  /** Any references to another SITE of which this STOP PLACE is deemed to be a nearby but distinct. */
  readonly adjacentSites?: Maybe<ReadonlyArray<Maybe<StopRegistryVersionLessEntityRef>>>;
  readonly alternativeNames?: Maybe<ReadonlyArray<Maybe<StopRegistryAlternativeName>>>;
  readonly changedBy?: Maybe<Scalars['String']['output']>;
  readonly description?: Maybe<StopRegistryEmbeddableMultilingualString>;
  /** External links */
  readonly externalLinks?: Maybe<ReadonlyArray<Maybe<StopRegistryStopPlaceExternalLink>>>;
  readonly fareZones?: Maybe<ReadonlyArray<Maybe<StopRegistryFareZone>>>;
  readonly geometry?: Maybe<StopRegistryGeoJson>;
  readonly groups?: Maybe<ReadonlyArray<Maybe<StopRegistryGroupOfStopPlaces>>>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly importedId?: Maybe<ReadonlyArray<Maybe<Scalars['String']['output']>>>;
  readonly infoSpots?: Maybe<ReadonlyArray<Maybe<StopRegistryInfoSpot>>>;
  readonly keyValues?: Maybe<ReadonlyArray<Maybe<StopRegistryKeyValues>>>;
  readonly modificationEnumeration?: Maybe<StopRegistryModificationEnumerationType>;
  readonly name?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly organisations?: Maybe<ReadonlyArray<Maybe<StopRegistryStopPlaceOrganisationRef>>>;
  readonly parentSiteRef?: Maybe<Scalars['String']['output']>;
  readonly parentStopPlace?: Maybe<ReadonlyArray<Maybe<StopRegistryStopPlaceInterface>>>;
  readonly permissions?: Maybe<StopRegistryEntityPermissions>;
  readonly placeEquipments?: Maybe<StopRegistryPlaceEquipments>;
  readonly polygon?: Maybe<StopRegistryGeoJson>;
  readonly privateCode?: Maybe<StopRegistryPrivateCode>;
  readonly publicCode?: Maybe<Scalars['String']['output']>;
  readonly quays?: Maybe<ReadonlyArray<Maybe<StopRegistryQuay>>>;
  readonly scheduled_stop_point?: Maybe<ServicePatternScheduledStopPoint>;
  readonly shortName?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly stopPlaceType?: Maybe<StopRegistryStopPlaceType>;
  readonly submode?: Maybe<StopRegistrySubmodeType>;
  readonly tags?: Maybe<ReadonlyArray<Maybe<StopRegistryTag>>>;
  readonly tariffZones?: Maybe<ReadonlyArray<Maybe<StopRegistryTariffZone>>>;
  readonly topographicPlace?: Maybe<StopRegistryTopographicPlace>;
  readonly transportMode?: Maybe<StopRegistryTransportModeType>;
  readonly validBetween?: Maybe<StopRegistryValidBetween>;
  readonly version?: Maybe<Scalars['String']['output']>;
  readonly versionComment?: Maybe<Scalars['String']['output']>;
  readonly weighting?: Maybe<StopRegistryInterchangeWeightingType>;
};


export type StopRegistryStopPlaceParentStopPlaceArgs = {
  allVersions?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  countryReference?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  countyReference?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  hasParking?: InputMaybe<Scalars['Boolean']['input']>;
  importedId?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  municipalityReference?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  onlyMonomodalStopPlaces?: InputMaybe<Scalars['Boolean']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  pointInTime?: InputMaybe<Scalars['stop_registry_DateTime']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  stopPlaceType?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryStopPlaceType>>>;
  tags?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  values?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  version?: InputMaybe<Scalars['Int']['input']>;
  versionValidity?: InputMaybe<StopRegistryVersionValidity>;
  withDuplicatedQuayImportedIds?: InputMaybe<Scalars['Boolean']['input']>;
  withNearbySimilarDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
  withTags?: InputMaybe<Scalars['Boolean']['input']>;
  withoutLocationOnly?: InputMaybe<Scalars['Boolean']['input']>;
  withoutQuaysOnly?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StopRegistryStopPlaceInput = {
  /** This field is set either on StopPlace (i.e. all Quays are equal), or on every Quay. */
  readonly accessibilityAssessment?: InputMaybe<StopRegistryAccessibilityAssessmentInput>;
  /** Any references to another SITE of which this STOP PLACE is deemed to be a nearby but distinct. */
  readonly adjacentSites?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryVersionLessEntityRefInput>>>;
  readonly alternativeNames?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryAlternativeNameInput>>>;
  readonly description?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  readonly externalLinks?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryExternalLinkInput>>>;
  readonly geometry?: InputMaybe<StopRegistryGeoJsonInput>;
  /** Ignore when creating new */
  readonly id?: InputMaybe<Scalars['String']['input']>;
  readonly keyValues?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryKeyValuesInput>>>;
  readonly name?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  readonly organisations?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryStopPlaceOrganisationRefInput>>>;
  readonly parentSiteRef?: InputMaybe<Scalars['String']['input']>;
  readonly placeEquipments?: InputMaybe<StopRegistryPlaceEquipmentsInput>;
  readonly privateCode?: InputMaybe<StopRegistryPrivateCodeInput>;
  readonly publicCode?: InputMaybe<Scalars['String']['input']>;
  readonly quays?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryQuayInput>>>;
  readonly shortName?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  readonly stopPlaceType?: InputMaybe<StopRegistryStopPlaceType>;
  readonly submode?: InputMaybe<StopRegistrySubmodeType>;
  /** List of tariff zone references without version */
  readonly tariffZones?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryVersionLessEntityRefInput>>>;
  readonly topographicPlace?: InputMaybe<StopRegistryTopographicPlaceInput>;
  readonly transportMode?: InputMaybe<StopRegistryTransportModeType>;
  readonly validBetween?: InputMaybe<StopRegistryValidBetweenInput>;
  readonly versionComment?: InputMaybe<Scalars['String']['input']>;
  readonly weighting?: InputMaybe<StopRegistryInterchangeWeightingType>;
};

export type StopRegistryStopPlaceInterface = {
  /** This field is set either on StopPlace (i.e. all Quays are equal), or on every Quay. */
  readonly accessibilityAssessment?: Maybe<StopRegistryAccessibilityAssessment>;
  readonly alternativeNames?: Maybe<ReadonlyArray<Maybe<StopRegistryAlternativeName>>>;
  readonly changedBy?: Maybe<Scalars['String']['output']>;
  readonly description?: Maybe<StopRegistryEmbeddableMultilingualString>;
  /** External links */
  readonly externalLinks?: Maybe<ReadonlyArray<Maybe<StopRegistryStopPlaceExternalLink>>>;
  readonly fareZones?: Maybe<ReadonlyArray<Maybe<StopRegistryFareZone>>>;
  readonly geometry?: Maybe<StopRegistryGeoJson>;
  readonly groups?: Maybe<ReadonlyArray<Maybe<StopRegistryGroupOfStopPlaces>>>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly importedId?: Maybe<ReadonlyArray<Maybe<Scalars['String']['output']>>>;
  readonly infoSpots?: Maybe<ReadonlyArray<Maybe<StopRegistryInfoSpot>>>;
  readonly keyValues?: Maybe<ReadonlyArray<Maybe<StopRegistryKeyValues>>>;
  readonly modificationEnumeration?: Maybe<StopRegistryModificationEnumerationType>;
  readonly name?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly organisations?: Maybe<ReadonlyArray<Maybe<StopRegistryStopPlaceOrganisationRef>>>;
  readonly permissions?: Maybe<StopRegistryEntityPermissions>;
  readonly placeEquipments?: Maybe<StopRegistryPlaceEquipments>;
  readonly polygon?: Maybe<StopRegistryGeoJson>;
  readonly privateCode?: Maybe<StopRegistryPrivateCode>;
  readonly publicCode?: Maybe<Scalars['String']['output']>;
  readonly shortName?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly tags?: Maybe<ReadonlyArray<Maybe<StopRegistryTag>>>;
  readonly tariffZones?: Maybe<ReadonlyArray<Maybe<StopRegistryTariffZone>>>;
  readonly topographicPlace?: Maybe<StopRegistryTopographicPlace>;
  readonly validBetween?: Maybe<StopRegistryValidBetween>;
  readonly version?: Maybe<Scalars['String']['output']>;
  readonly versionComment?: Maybe<Scalars['String']['output']>;
};

export type StopRegistryStopPlaceOrganisationRef = {
  readonly __typename?: 'stop_registry_StopPlaceOrganisationRef';
  readonly organisation?: Maybe<StopRegistryOrganisation>;
  readonly organisationRef: Scalars['String']['output'];
  readonly relationshipType?: Maybe<StopRegistryStopPlaceOrganisationRelationshipType>;
};

export type StopRegistryStopPlaceOrganisationRefInput = {
  /** Id of the referenced organisation */
  readonly organisationRef: Scalars['String']['input'];
  readonly relationshipType?: InputMaybe<StopRegistryStopPlaceOrganisationRelationshipType>;
};

export enum StopRegistryStopPlaceType {
  Airport = 'airport',
  BusStation = 'busStation',
  CoachStation = 'coachStation',
  FerryPort = 'ferryPort',
  FerryStop = 'ferryStop',
  HarbourPort = 'harbourPort',
  LiftStation = 'liftStation',
  MetroStation = 'metroStation',
  OnstreetBus = 'onstreetBus',
  OnstreetTram = 'onstreetTram',
  Other = 'other',
  RailStation = 'railStation',
  TramStation = 'tramStation',
  VehicleRailInterchange = 'vehicleRailInterchange'
}

export enum StopRegistrySubmode {
  RailReplacementBus = 'railReplacementBus'
}

export enum StopRegistrySubmodeType {
  AirportLinkBus = 'airportLinkBus',
  DomesticFlight = 'domesticFlight',
  ExpressBus = 'expressBus',
  Funicular = 'funicular',
  HelicopterService = 'helicopterService',
  HighSpeedPassengerService = 'highSpeedPassengerService',
  HighSpeedVehicleService = 'highSpeedVehicleService',
  InternationalCarFerry = 'internationalCarFerry',
  InternationalFlight = 'internationalFlight',
  InternationalPassengerFerry = 'internationalPassengerFerry',
  InterregionalRail = 'interregionalRail',
  Local = 'local',
  LocalBus = 'localBus',
  LocalCarFerry = 'localCarFerry',
  LocalPassengerFerry = 'localPassengerFerry',
  LocalTram = 'localTram',
  LongDistance = 'longDistance',
  Metro = 'metro',
  NationalCarFerry = 'nationalCarFerry',
  NightBus = 'nightBus',
  NightRail = 'nightRail',
  RailReplacementBus = 'railReplacementBus',
  RegionalBus = 'regionalBus',
  RegionalRail = 'regionalRail',
  SchoolBus = 'schoolBus',
  ShuttleBus = 'shuttleBus',
  SightseeingBus = 'sightseeingBus',
  SightseeingService = 'sightseeingService',
  Telecabin = 'telecabin',
  TouristRailway = 'touristRailway'
}

/** A tag for an entity like StopPlace */
export type StopRegistryTag = {
  readonly __typename?: 'stop_registry_Tag';
  /** A comment for this tag on this entity */
  readonly comment?: Maybe<Scalars['String']['output']>;
  /** When this tag was added to the referenced entity */
  readonly created?: Maybe<Scalars['stop_registry_DateTime']['output']>;
  /** Who created this tag for the referenced entity */
  readonly createdBy?: Maybe<Scalars['String']['output']>;
  /** A reference to a netex ID. For instance: NSR:StopPlace:1. Types supported: StopPlace */
  readonly idReference?: Maybe<Scalars['String']['output']>;
  /** Tag name */
  readonly name?: Maybe<Scalars['String']['output']>;
  /** When this tag was removed. If set, the tag is removed from entity it references in field 'idReference' */
  readonly removed?: Maybe<Scalars['stop_registry_DateTime']['output']>;
  /** Removed by username. Only set if tag has been removed */
  readonly removedBy?: Maybe<Scalars['String']['output']>;
};

export type StopRegistryTariffZone = {
  readonly __typename?: 'stop_registry_TariffZone';
  readonly description?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly geometry?: Maybe<StopRegistryGeoJson>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly importedId?: Maybe<ReadonlyArray<Maybe<Scalars['String']['output']>>>;
  readonly keyValues?: Maybe<ReadonlyArray<Maybe<StopRegistryKeyValues>>>;
  readonly name?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly polygon?: Maybe<StopRegistryGeoJson>;
  readonly shortName?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly validBetween?: Maybe<StopRegistryValidBetween>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type StopRegistryTicketingEquipment = {
  readonly __typename?: 'stop_registry_TicketingEquipment';
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly numberOfMachines?: Maybe<Scalars['stop_registry_BigInteger']['output']>;
  readonly ticketMachines?: Maybe<Scalars['Boolean']['output']>;
  readonly ticketOffice?: Maybe<Scalars['Boolean']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type StopRegistryTicketingEquipmentInput = {
  readonly id?: InputMaybe<Scalars['String']['input']>;
  readonly numberOfMachines?: InputMaybe<Scalars['stop_registry_BigInteger']['input']>;
  readonly ticketMachines?: InputMaybe<Scalars['Boolean']['input']>;
  readonly ticketOffice?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StopRegistryTopographicPlace = {
  readonly __typename?: 'stop_registry_TopographicPlace';
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly name?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly parentTopographicPlace?: Maybe<StopRegistryTopographicPlace>;
  readonly polygon?: Maybe<StopRegistryGeoJson>;
  readonly topographicPlaceType?: Maybe<StopRegistryTopographicPlaceType>;
  readonly version?: Maybe<Scalars['Int']['output']>;
};

export type StopRegistryTopographicPlaceInput = {
  readonly id?: InputMaybe<Scalars['String']['input']>;
};

export enum StopRegistryTopographicPlaceType {
  Area = 'area',
  City = 'city',
  Continent = 'continent',
  Conurbation = 'conurbation',
  Country = 'country',
  County = 'county',
  District = 'district',
  Hamlet = 'hamlet',
  Interregion = 'interregion',
  Municipality = 'municipality',
  Other = 'other',
  Parish = 'parish',
  PlaceOfInterest = 'placeOfInterest',
  Principality = 'principality',
  Province = 'province',
  Quarter = 'quarter',
  Region = 'region',
  State = 'state',
  Suburb = 'suburb',
  Town = 'town',
  Unrecorded = 'unrecorded',
  UrbanCentre = 'urbanCentre',
  Village = 'village'
}

/** Transfer durations in seconds */
export type StopRegistryTransferDuration = {
  readonly __typename?: 'stop_registry_TransferDuration';
  /** Default duration in seconds */
  readonly defaultDuration?: Maybe<Scalars['Int']['output']>;
  /** Frequent traveller duration in seconds */
  readonly frequentTravellerDuration?: Maybe<Scalars['Int']['output']>;
  /** Mobility restriced traveller duration in seconds */
  readonly mobilityRestrictedTravellerDuration?: Maybe<Scalars['Int']['output']>;
  /** Occasional traveller duration in seconds */
  readonly occasionalTravellerDuration?: Maybe<Scalars['Int']['output']>;
};

/** Transfer durations in seconds */
export type StopRegistryTransferDurationInput = {
  /** Default duration in seconds */
  readonly defaultDuration?: InputMaybe<Scalars['Int']['input']>;
  /** Frequent traveller duration in seconds */
  readonly frequentTravellerDuration?: InputMaybe<Scalars['Int']['input']>;
  readonly id?: InputMaybe<Scalars['String']['input']>;
  /** Mobility restriced traveller duration in seconds */
  readonly mobilityRestrictedTravellerDuration?: InputMaybe<Scalars['Int']['input']>;
  /** Occasional traveller duration in seconds */
  readonly occasionalTravellerDuration?: InputMaybe<Scalars['Int']['input']>;
};

export enum StopRegistryTransportModeType {
  Air = 'air',
  Bus = 'bus',
  Cableway = 'cableway',
  Funicular = 'funicular',
  Metro = 'metro',
  Rail = 'rail',
  Tram = 'tram',
  Water = 'water'
}

export type StopRegistryTransportModes = {
  readonly __typename?: 'stop_registry_TransportModes';
  readonly submode?: Maybe<ReadonlyArray<Maybe<Scalars['String']['output']>>>;
  readonly transportMode?: Maybe<Scalars['String']['output']>;
};

export type StopRegistryUserPermissions = {
  readonly __typename?: 'stop_registry_UserPermissions';
  readonly allowNewStopEverywhere?: Maybe<Scalars['Boolean']['output']>;
  readonly isGuest?: Maybe<Scalars['Boolean']['output']>;
};

export type StopRegistryValidBetween = {
  readonly __typename?: 'stop_registry_ValidBetween';
  /** Date time using the format: yyyy-MM-dd'T'HH:mm:ss.SSSXXXX. Example: 2017-04-23T18:25:43.511+0100 */
  readonly fromDate?: Maybe<Scalars['stop_registry_DateTime']['output']>;
  /** Date time using the format: yyyy-MM-dd'T'HH:mm:ss.SSSXXXX. Example: 2017-04-23T18:25:43.511+0100 */
  readonly toDate?: Maybe<Scalars['stop_registry_DateTime']['output']>;
};

export type StopRegistryValidBetweenInput = {
  /** When the new version is valid from */
  readonly fromDate: Scalars['stop_registry_DateTime']['input'];
  /** When the version is no longer valid */
  readonly toDate?: InputMaybe<Scalars['stop_registry_DateTime']['input']>;
};

/** A reference to an entity without version */
export type StopRegistryVersionLessEntityRef = {
  readonly __typename?: 'stop_registry_VersionLessEntityRef';
  /** The NeTEx ID of the of the referenced entity. The reference must already exist */
  readonly ref?: Maybe<Scalars['String']['output']>;
};

/** A reference to an entity without version */
export type StopRegistryVersionLessEntityRefInput = {
  /** The NeTEx ID of the of the referenced entity. The reference must already exist */
  readonly ref: Scalars['String']['input'];
};

export enum StopRegistryVersionValidity {
  All = 'ALL',
  Current = 'CURRENT',
  CurrentFuture = 'CURRENT_FUTURE',
  MaxVersion = 'MAX_VERSION'
}

export type StopRegistryWaitingRoomEquipment = {
  readonly __typename?: 'stop_registry_WaitingRoomEquipment';
  readonly heated?: Maybe<Scalars['Boolean']['output']>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly seats?: Maybe<Scalars['stop_registry_BigInteger']['output']>;
  readonly stepFree?: Maybe<Scalars['Boolean']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

export type StopRegistryWaitingRoomEquipmentInput = {
  readonly heated?: InputMaybe<Scalars['Boolean']['input']>;
  readonly id?: InputMaybe<Scalars['String']['input']>;
  readonly seats?: InputMaybe<Scalars['stop_registry_BigInteger']['input']>;
  readonly stepFree?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum StopRegistryZoneTopologyEnumerationType {
  Annular = 'annular',
  Honeycomb = 'honeycomb',
  Nested = 'nested',
  Other = 'other',
  Overlapping = 'overlapping',
  OverlappingSequence = 'overlappingSequence',
  Ring = 'ring',
  Sequence = 'sequence',
  Tiled = 'tiled'
}

export enum StopRegistryAccessibilityLevel {
  FullyAccessible = 'fullyAccessible',
  Inaccessible = 'inaccessible',
  MostlyAccessible = 'mostlyAccessible',
  PartiallyInaccessible = 'partiallyInaccessible',
  Unknown = 'unknown'
}

export type StopRegistryAddToMultiModalStopPlaceInput = {
  readonly parentSiteRef: Scalars['String']['input'];
  readonly stopPlaceIds: ReadonlyArray<InputMaybe<Scalars['String']['input']>>;
  readonly validBetween?: InputMaybe<StopRegistryValidBetweenInput>;
  readonly versionComment?: InputMaybe<Scalars['String']['input']>;
};

export type StopRegistryCreateMultiModalStopPlaceInput = {
  readonly alternativeNames?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryAlternativeNameInput>>>;
  readonly description?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  readonly geometry?: InputMaybe<StopRegistryGeoJsonInput>;
  readonly keyValues?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryKeyValuesInput>>>;
  readonly name: StopRegistryEmbeddableMultilingualStringInput;
  readonly privateCode?: InputMaybe<StopRegistryPrivateCodeInput>;
  readonly stopPlaceIds: ReadonlyArray<InputMaybe<Scalars['String']['input']>>;
  readonly validBetween?: InputMaybe<StopRegistryValidBetweenInput>;
  readonly versionComment?: InputMaybe<Scalars['String']['input']>;
};

export enum StopRegistryCycleStorageType {
  Bars = 'bars',
  CycleScheme = 'cycleScheme',
  Other = 'other',
  Racks = 'racks',
  Railings = 'railings'
}

export enum StopRegistryDisplayType {
  BatteryEInk = 'batteryEInk',
  BatteryMultiRow = 'batteryMultiRow',
  BatteryOneRow = 'batteryOneRow',
  ChargeableEInk = 'chargeableEInk',
  ElectricTft = 'electricTFT',
  None = 'none'
}

export type StopRegistryExternalLink = {
  readonly __typename?: 'stop_registry_externalLink';
  readonly location?: Maybe<Scalars['String']['output']>;
  readonly name?: Maybe<Scalars['String']['output']>;
  readonly orderNum?: Maybe<Scalars['Int']['output']>;
  readonly quayId?: Maybe<Scalars['Int']['output']>;
};

export type StopRegistryExternalLinkInput = {
  readonly location?: InputMaybe<Scalars['String']['input']>;
  readonly name?: InputMaybe<Scalars['String']['input']>;
};

export enum StopRegistryGender {
  Both = 'both',
  FemaleOnly = 'femaleOnly',
  MaleOnly = 'maleOnly',
  SameSexOnly = 'sameSexOnly'
}

export enum StopRegistryGuidanceType {
  Braille = 'braille',
  None = 'none',
  Other = 'other'
}

export type StopRegistryInfoSpot = {
  readonly __typename?: 'stop_registry_infoSpot';
  readonly backlight?: Maybe<Scalars['Boolean']['output']>;
  readonly description?: Maybe<StopRegistryEmbeddableMultilingualString>;
  readonly displayType?: Maybe<StopRegistryDisplayType>;
  readonly floor?: Maybe<Scalars['String']['output']>;
  readonly geometry?: Maybe<StopRegistryGeoJson>;
  readonly height?: Maybe<Scalars['Int']['output']>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly infoSpotLocations?: Maybe<ReadonlyArray<Maybe<Scalars['String']['output']>>>;
  readonly infoSpotType?: Maybe<StopRegistryInfoSpotType>;
  readonly label?: Maybe<Scalars['String']['output']>;
  readonly maintenance?: Maybe<Scalars['String']['output']>;
  readonly poster?: Maybe<ReadonlyArray<Maybe<StopRegistryPoster>>>;
  readonly posterPlaceSize?: Maybe<StopRegistryPosterPlaceSize>;
  readonly purpose?: Maybe<Scalars['String']['output']>;
  readonly railInformation?: Maybe<Scalars['String']['output']>;
  readonly speechProperty?: Maybe<Scalars['Boolean']['output']>;
  readonly validBetween?: Maybe<StopRegistryValidBetween>;
  readonly version?: Maybe<Scalars['String']['output']>;
  readonly width?: Maybe<Scalars['Int']['output']>;
  readonly zoneLabel?: Maybe<Scalars['String']['output']>;
};

export type StopRegistryInfoSpotInput = {
  readonly backlight?: InputMaybe<Scalars['Boolean']['input']>;
  readonly description?: InputMaybe<StopRegistryEmbeddableMultilingualStringInput>;
  readonly displayType?: InputMaybe<StopRegistryDisplayType>;
  readonly floor?: InputMaybe<Scalars['String']['input']>;
  readonly geometry?: InputMaybe<StopRegistryGeoJsonInput>;
  readonly height?: InputMaybe<Scalars['Int']['input']>;
  readonly id?: InputMaybe<Scalars['String']['input']>;
  readonly infoSpotLocations?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  readonly infoSpotType?: InputMaybe<StopRegistryInfoSpotType>;
  readonly label?: InputMaybe<Scalars['String']['input']>;
  readonly maintenance?: InputMaybe<Scalars['String']['input']>;
  readonly poster?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryPosterInput>>>;
  readonly posterPlaceSize?: InputMaybe<StopRegistryPosterPlaceSize>;
  readonly purpose?: InputMaybe<Scalars['String']['input']>;
  readonly railInformation?: InputMaybe<Scalars['String']['input']>;
  readonly speechProperty?: InputMaybe<Scalars['Boolean']['input']>;
  readonly width?: InputMaybe<Scalars['Int']['input']>;
  readonly zoneLabel?: InputMaybe<Scalars['String']['input']>;
};

export enum StopRegistryInfoSpotType {
  Dynamic = 'dynamic',
  SoundBeacon = 'sound_beacon',
  Static = 'static'
}

export enum StopRegistryMapType {
  None = 'none',
  Other = 'other',
  Tactile = 'tactile'
}

export enum StopRegistryNameType {
  Alias = 'alias',
  Copy = 'copy',
  Label = 'label',
  Other = 'other',
  Translation = 'translation'
}

export enum StopRegistryOrganisationType {
  Authority = 'authority',
  FacilityOperator = 'facilityOperator',
  Operator = 'operator',
  Other = 'other',
  RailFreightOperator = 'railFreightOperator',
  RailOperator = 'railOperator',
  ServicedOrganisation = 'servicedOrganisation',
  StatutoryBody = 'statutoryBody',
  TravelAgent = 'travelAgent'
}

export enum StopRegistryPedestrianCrossingRampType {
  Lr = 'LR',
  Rk4 = 'RK4',
  Rk4Lr = 'RK4_LR',
  Other = 'other'
}

export type StopRegistryPoster = {
  readonly __typename?: 'stop_registry_poster';
  readonly height?: Maybe<Scalars['Int']['output']>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly label?: Maybe<Scalars['String']['output']>;
  readonly lines?: Maybe<Scalars['String']['output']>;
  readonly posterSize?: Maybe<StopRegistryPosterPlaceSize>;
  readonly version?: Maybe<Scalars['String']['output']>;
  readonly width?: Maybe<Scalars['Int']['output']>;
};

export type StopRegistryPosterInput = {
  readonly height?: InputMaybe<Scalars['Int']['input']>;
  readonly label?: InputMaybe<Scalars['String']['input']>;
  readonly lines?: InputMaybe<Scalars['String']['input']>;
  readonly posterSize?: InputMaybe<StopRegistryPosterPlaceSize>;
  readonly width?: InputMaybe<Scalars['Int']['input']>;
};

export enum StopRegistryPosterPlaceSize {
  A3 = 'a3',
  A4 = 'a4',
  Cm80x120 = 'cm80x120'
}

export enum StopRegistryShelterCondition {
  Bad = 'bad',
  Good = 'good',
  Mediocre = 'mediocre'
}

export enum StopRegistryShelterElectricity {
  Continuous = 'continuous',
  ContinuousPlanned = 'continuousPlanned',
  ContinuousUnderConstruction = 'continuousUnderConstruction',
  Light = 'light',
  None = 'none',
  TemporarilyOff = 'temporarilyOff'
}

export enum StopRegistryShelterType {
  Concrete = 'concrete',
  Glass = 'glass',
  Post = 'post',
  Steel = 'steel',
  Urban = 'urban',
  Virtual = 'virtual',
  Wooden = 'wooden'
}

export enum StopRegistryShelterWidthType {
  Narrow = 'narrow',
  Other = 'other',
  Wide = 'wide'
}

export enum StopRegistrySignContentType {
  TransportModePoint = 'TransportModePoint',
  Assistance = 'assistance',
  EmergencyExit = 'emergencyExit',
  Entrance = 'entrance',
  Exit = 'exit',
  MeetingPoint = 'meetingPoint',
  NoSmoking = 'noSmoking',
  Other = 'other',
  SosPhone = 'sosPhone',
  Tickets = 'tickets',
  TouchPoint = 'touchPoint',
  TransportMode = 'transportMode'
}

export type StopRegistryStopPlaceExternalLink = {
  readonly __typename?: 'stop_registry_stopPlaceExternalLink';
  readonly location?: Maybe<Scalars['String']['output']>;
  readonly name?: Maybe<Scalars['String']['output']>;
  readonly orderNum?: Maybe<Scalars['Int']['output']>;
  readonly stopPlaceId?: Maybe<Scalars['Int']['output']>;
};

export enum StopRegistryStopPlaceOrganisationRelationshipType {
  Cleaning = 'cleaning',
  InfoUpkeep = 'infoUpkeep',
  Maintenance = 'maintenance',
  Owner = 'owner',
  WinterMaintenance = 'winterMaintenance'
}

export enum StopRegistryStopType {
  BusBulb = 'busBulb',
  InLane = 'inLane',
  Other = 'other',
  PullOut = 'pullOut'
}

/** Boolean expression to filter rows from the logical model for "TerminalStopSearchResult". All fields are combined with a logical 'AND'. */
export type StopsDatabaseTerminalStopSearchResultBoolExpBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseTerminalStopSearchResultBoolExpBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseTerminalStopSearchResultBoolExpBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseTerminalStopSearchResultBoolExpBoolExp>>;
  readonly cursor?: InputMaybe<BigintComparisonExp>;
  readonly stops?: InputMaybe<JsonbComparisonExp>;
};

/** Ordering options when selecting data from "TerminalStopSearchResult". */
export type StopsDatabaseTerminalStopSearchResultOrderBy = {
  readonly cursor?: InputMaybe<OrderBy>;
  readonly stops?: InputMaybe<OrderBy>;
};

/** columns and relationships of "access_space" */
export type StopsDatabaseAccessSpace = {
  readonly __typename?: 'stops_database_access_space';
  /** An array relationship */
  readonly access_space_alternative_names: ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNames>;
  /** An aggregate relationship */
  readonly access_space_alternative_names_aggregate: StopsDatabaseAccessSpaceAlternativeNamesAggregate;
  /** An array relationship */
  readonly access_space_equipment_places: ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlaces>;
  /** An aggregate relationship */
  readonly access_space_equipment_places_aggregate: StopsDatabaseAccessSpaceEquipmentPlacesAggregate;
  /** An array relationship */
  readonly access_space_key_values: ReadonlyArray<StopsDatabaseAccessSpaceKeyValues>;
  /** An aggregate relationship */
  readonly access_space_key_values_aggregate: StopsDatabaseAccessSpaceKeyValuesAggregate;
  /** An object relationship */
  readonly accessibility_assessment?: Maybe<StopsDatabaseAccessibilityAssessment>;
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly all_areas_wheelchair_accessible?: Maybe<Scalars['Boolean']['output']>;
  readonly centroid?: Maybe<Scalars['geometry']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id: Scalars['bigint']['output'];
  /** An object relationship */
  readonly installed_equipment_version_structure?: Maybe<StopsDatabaseInstalledEquipmentVersionStructure>;
  readonly label_lang?: Maybe<Scalars['String']['output']>;
  readonly label_value?: Maybe<Scalars['String']['output']>;
  readonly level_ref?: Maybe<Scalars['String']['output']>;
  readonly level_ref_version?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  readonly persistable_polygon?: Maybe<StopsDatabasePersistablePolygon>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly site_ref?: Maybe<Scalars['String']['output']>;
  readonly site_ref_version?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "access_space" */
export type StopsDatabaseAccessSpaceAccessSpaceAlternativeNamesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>;
};


/** columns and relationships of "access_space" */
export type StopsDatabaseAccessSpaceAccessSpaceAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>;
};


/** columns and relationships of "access_space" */
export type StopsDatabaseAccessSpaceAccessSpaceEquipmentPlacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>;
};


/** columns and relationships of "access_space" */
export type StopsDatabaseAccessSpaceAccessSpaceEquipmentPlacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>;
};


/** columns and relationships of "access_space" */
export type StopsDatabaseAccessSpaceAccessSpaceKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesBoolExp>;
};


/** columns and relationships of "access_space" */
export type StopsDatabaseAccessSpaceAccessSpaceKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesBoolExp>;
};

/** aggregated selection of "access_space" */
export type StopsDatabaseAccessSpaceAggregate = {
  readonly __typename?: 'stops_database_access_space_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseAccessSpaceAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseAccessSpace>;
};

/** aggregate fields of "access_space" */
export type StopsDatabaseAccessSpaceAggregateFields = {
  readonly __typename?: 'stops_database_access_space_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseAccessSpaceAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseAccessSpaceMaxFields>;
  readonly min?: Maybe<StopsDatabaseAccessSpaceMinFields>;
  readonly stddev?: Maybe<StopsDatabaseAccessSpaceStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseAccessSpaceStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseAccessSpaceStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseAccessSpaceSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseAccessSpaceVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseAccessSpaceVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseAccessSpaceVarianceFields>;
};


/** aggregate fields of "access_space" */
export type StopsDatabaseAccessSpaceAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** columns and relationships of "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNames = {
  readonly __typename?: 'stops_database_access_space_alternative_names';
  readonly access_space_id: Scalars['bigint']['output'];
  /** An object relationship */
  readonly alternative_name: StopsDatabaseAlternativeName;
  readonly alternative_names_id: Scalars['bigint']['output'];
};

/** aggregated selection of "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesAggregate = {
  readonly __typename?: 'stops_database_access_space_alternative_names_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNames>;
};

/** aggregate fields of "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesAggregateFields = {
  readonly __typename?: 'stops_database_access_space_alternative_names_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesMaxFields>;
  readonly min?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesVarianceFields>;
};


/** aggregate fields of "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNamesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNamesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseAccessSpaceAlternativeNamesAvgFields = {
  readonly __typename?: 'stops_database_access_space_alternative_names_avg_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesAvgOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly alternative_names_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "access_space_alternative_names". All fields are combined with a logical 'AND'. */
export type StopsDatabaseAccessSpaceAlternativeNamesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>>;
  readonly access_space_id?: InputMaybe<BigintComparisonExp>;
  readonly alternative_name?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
  readonly alternative_names_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "access_space_alternative_names" */
export enum StopsDatabaseAccessSpaceAlternativeNamesConstraint {
  /** unique or primary key constraint on columns "alternative_names_id" */
  UkQvw904jxmey0b5c2oenaks4o6 = 'uk_qvw904jxmey0b5c2oenaks4o6'
}

/** input type for incrementing numeric columns in table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesIncInput = {
  readonly access_space_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesInsertInput = {
  readonly access_space_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly alternative_name?: InputMaybe<StopsDatabaseAlternativeNameObjRelInsertInput>;
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseAccessSpaceAlternativeNamesMaxFields = {
  readonly __typename?: 'stops_database_access_space_alternative_names_max_fields';
  readonly access_space_id?: Maybe<Scalars['bigint']['output']>;
  readonly alternative_names_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesMaxOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly alternative_names_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseAccessSpaceAlternativeNamesMinFields = {
  readonly __typename?: 'stops_database_access_space_alternative_names_min_fields';
  readonly access_space_id?: Maybe<Scalars['bigint']['output']>;
  readonly alternative_names_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesMinOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly alternative_names_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesMutationResponse = {
  readonly __typename?: 'stops_database_access_space_alternative_names_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNames>;
};

/** on_conflict condition type for table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesOnConflict = {
  readonly constraint: StopsDatabaseAccessSpaceAlternativeNamesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNamesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>;
};

/** Ordering options when selecting data from "access_space_alternative_names". */
export type StopsDatabaseAccessSpaceAlternativeNamesOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly alternative_name?: InputMaybe<StopsDatabaseAlternativeNameOrderBy>;
  readonly alternative_names_id?: InputMaybe<OrderBy>;
};

/** select columns of table "access_space_alternative_names" */
export enum StopsDatabaseAccessSpaceAlternativeNamesSelectColumn {
  /** column name */
  AccessSpaceId = 'access_space_id',
  /** column name */
  AlternativeNamesId = 'alternative_names_id'
}

/** input type for updating data in table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesSetInput = {
  readonly access_space_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseAccessSpaceAlternativeNamesStddevFields = {
  readonly __typename?: 'stops_database_access_space_alternative_names_stddev_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesStddevOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly alternative_names_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseAccessSpaceAlternativeNamesStddevPopFields = {
  readonly __typename?: 'stops_database_access_space_alternative_names_stddev_pop_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesStddevPopOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly alternative_names_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseAccessSpaceAlternativeNamesStddevSampFields = {
  readonly __typename?: 'stops_database_access_space_alternative_names_stddev_samp_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesStddevSampOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly alternative_names_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseAccessSpaceAlternativeNamesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseAccessSpaceAlternativeNamesStreamCursorValueInput = {
  readonly access_space_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseAccessSpaceAlternativeNamesSumFields = {
  readonly __typename?: 'stops_database_access_space_alternative_names_sum_fields';
  readonly access_space_id?: Maybe<Scalars['bigint']['output']>;
  readonly alternative_names_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesSumOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly alternative_names_id?: InputMaybe<OrderBy>;
};

/** update columns of table "access_space_alternative_names" */
export enum StopsDatabaseAccessSpaceAlternativeNamesUpdateColumn {
  /** column name */
  AccessSpaceId = 'access_space_id',
  /** column name */
  AlternativeNamesId = 'alternative_names_id'
}

export type StopsDatabaseAccessSpaceAlternativeNamesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseAccessSpaceAlternativeNamesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseAccessSpaceAlternativeNamesVarPopFields = {
  readonly __typename?: 'stops_database_access_space_alternative_names_var_pop_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesVarPopOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly alternative_names_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseAccessSpaceAlternativeNamesVarSampFields = {
  readonly __typename?: 'stops_database_access_space_alternative_names_var_samp_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesVarSampOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly alternative_names_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseAccessSpaceAlternativeNamesVarianceFields = {
  readonly __typename?: 'stops_database_access_space_alternative_names_variance_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "access_space_alternative_names" */
export type StopsDatabaseAccessSpaceAlternativeNamesVarianceOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly alternative_names_id?: InputMaybe<OrderBy>;
};

/** aggregate avg on columns */
export type StopsDatabaseAccessSpaceAvgFields = {
  readonly __typename?: 'stops_database_access_space_avg_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "access_space". All fields are combined with a logical 'AND'. */
export type StopsDatabaseAccessSpaceBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseAccessSpaceBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceBoolExp>>;
  readonly access_space_alternative_names?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>;
  readonly access_space_alternative_names_aggregate?: InputMaybe<AccessSpaceAlternativeNamesAggregateBoolExp>;
  readonly access_space_equipment_places?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>;
  readonly access_space_equipment_places_aggregate?: InputMaybe<AccessSpaceEquipmentPlacesAggregateBoolExp>;
  readonly access_space_key_values?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesBoolExp>;
  readonly access_space_key_values_aggregate?: InputMaybe<AccessSpaceKeyValuesAggregateBoolExp>;
  readonly accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentBoolExp>;
  readonly accessibility_assessment_id?: InputMaybe<BigintComparisonExp>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<BooleanComparisonExp>;
  readonly centroid?: InputMaybe<GeometryComparisonExp>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly covered?: InputMaybe<IntComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly description_lang?: InputMaybe<StringComparisonExp>;
  readonly description_value?: InputMaybe<StringComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
  readonly label_lang?: InputMaybe<StringComparisonExp>;
  readonly label_value?: InputMaybe<StringComparisonExp>;
  readonly level_ref?: InputMaybe<StringComparisonExp>;
  readonly level_ref_version?: InputMaybe<StringComparisonExp>;
  readonly name_lang?: InputMaybe<StringComparisonExp>;
  readonly name_value?: InputMaybe<StringComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  readonly place_equipments_id?: InputMaybe<BigintComparisonExp>;
  readonly polygon_id?: InputMaybe<BigintComparisonExp>;
  readonly private_code_type?: InputMaybe<StringComparisonExp>;
  readonly private_code_value?: InputMaybe<StringComparisonExp>;
  readonly short_name_lang?: InputMaybe<StringComparisonExp>;
  readonly short_name_value?: InputMaybe<StringComparisonExp>;
  readonly site_ref?: InputMaybe<StringComparisonExp>;
  readonly site_ref_version?: InputMaybe<StringComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
};

/** columns and relationships of "access_space_check_constraints" */
export type StopsDatabaseAccessSpaceCheckConstraints = {
  readonly __typename?: 'stops_database_access_space_check_constraints';
  readonly access_space_id: Scalars['bigint']['output'];
  readonly check_constraints_id: Scalars['bigint']['output'];
};

/** aggregated selection of "access_space_check_constraints" */
export type StopsDatabaseAccessSpaceCheckConstraintsAggregate = {
  readonly __typename?: 'stops_database_access_space_check_constraints_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseAccessSpaceCheckConstraints>;
};

/** aggregate fields of "access_space_check_constraints" */
export type StopsDatabaseAccessSpaceCheckConstraintsAggregateFields = {
  readonly __typename?: 'stops_database_access_space_check_constraints_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsMaxFields>;
  readonly min?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsMinFields>;
  readonly stddev?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsVarianceFields>;
};


/** aggregate fields of "access_space_check_constraints" */
export type StopsDatabaseAccessSpaceCheckConstraintsAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceCheckConstraintsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseAccessSpaceCheckConstraintsAvgFields = {
  readonly __typename?: 'stops_database_access_space_check_constraints_avg_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "access_space_check_constraints". All fields are combined with a logical 'AND'. */
export type StopsDatabaseAccessSpaceCheckConstraintsBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceCheckConstraintsBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceCheckConstraintsBoolExp>>;
  readonly access_space_id?: InputMaybe<BigintComparisonExp>;
  readonly check_constraints_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "access_space_check_constraints" */
export enum StopsDatabaseAccessSpaceCheckConstraintsConstraint {
  /** unique or primary key constraint on columns "check_constraints_id" */
  Uk_35wb7oemdnk85n1hg680228tv = 'uk_35wb7oemdnk85n1hg680228tv'
}

/** input type for incrementing numeric columns in table "access_space_check_constraints" */
export type StopsDatabaseAccessSpaceCheckConstraintsIncInput = {
  readonly access_space_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly check_constraints_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "access_space_check_constraints" */
export type StopsDatabaseAccessSpaceCheckConstraintsInsertInput = {
  readonly access_space_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly check_constraints_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseAccessSpaceCheckConstraintsMaxFields = {
  readonly __typename?: 'stops_database_access_space_check_constraints_max_fields';
  readonly access_space_id?: Maybe<Scalars['bigint']['output']>;
  readonly check_constraints_id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseAccessSpaceCheckConstraintsMinFields = {
  readonly __typename?: 'stops_database_access_space_check_constraints_min_fields';
  readonly access_space_id?: Maybe<Scalars['bigint']['output']>;
  readonly check_constraints_id?: Maybe<Scalars['bigint']['output']>;
};

/** response of any mutation on the table "access_space_check_constraints" */
export type StopsDatabaseAccessSpaceCheckConstraintsMutationResponse = {
  readonly __typename?: 'stops_database_access_space_check_constraints_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseAccessSpaceCheckConstraints>;
};

/** on_conflict condition type for table "access_space_check_constraints" */
export type StopsDatabaseAccessSpaceCheckConstraintsOnConflict = {
  readonly constraint: StopsDatabaseAccessSpaceCheckConstraintsConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseAccessSpaceCheckConstraintsUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsBoolExp>;
};

/** Ordering options when selecting data from "access_space_check_constraints". */
export type StopsDatabaseAccessSpaceCheckConstraintsOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly check_constraints_id?: InputMaybe<OrderBy>;
};

/** select columns of table "access_space_check_constraints" */
export enum StopsDatabaseAccessSpaceCheckConstraintsSelectColumn {
  /** column name */
  AccessSpaceId = 'access_space_id',
  /** column name */
  CheckConstraintsId = 'check_constraints_id'
}

/** input type for updating data in table "access_space_check_constraints" */
export type StopsDatabaseAccessSpaceCheckConstraintsSetInput = {
  readonly access_space_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly check_constraints_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseAccessSpaceCheckConstraintsStddevFields = {
  readonly __typename?: 'stops_database_access_space_check_constraints_stddev_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseAccessSpaceCheckConstraintsStddevPopFields = {
  readonly __typename?: 'stops_database_access_space_check_constraints_stddev_pop_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseAccessSpaceCheckConstraintsStddevSampFields = {
  readonly __typename?: 'stops_database_access_space_check_constraints_stddev_samp_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "access_space_check_constraints" */
export type StopsDatabaseAccessSpaceCheckConstraintsStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseAccessSpaceCheckConstraintsStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseAccessSpaceCheckConstraintsStreamCursorValueInput = {
  readonly access_space_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly check_constraints_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseAccessSpaceCheckConstraintsSumFields = {
  readonly __typename?: 'stops_database_access_space_check_constraints_sum_fields';
  readonly access_space_id?: Maybe<Scalars['bigint']['output']>;
  readonly check_constraints_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "access_space_check_constraints" */
export enum StopsDatabaseAccessSpaceCheckConstraintsUpdateColumn {
  /** column name */
  AccessSpaceId = 'access_space_id',
  /** column name */
  CheckConstraintsId = 'check_constraints_id'
}

export type StopsDatabaseAccessSpaceCheckConstraintsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseAccessSpaceCheckConstraintsBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseAccessSpaceCheckConstraintsVarPopFields = {
  readonly __typename?: 'stops_database_access_space_check_constraints_var_pop_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseAccessSpaceCheckConstraintsVarSampFields = {
  readonly __typename?: 'stops_database_access_space_check_constraints_var_samp_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseAccessSpaceCheckConstraintsVarianceFields = {
  readonly __typename?: 'stops_database_access_space_check_constraints_variance_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
};

/** unique or primary key constraints on table "access_space" */
export enum StopsDatabaseAccessSpaceConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  AccessSpaceNetexIdVersionConstraint = 'access_space_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  AccessSpacePkey = 'access_space_pkey'
}

/** columns and relationships of "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlaces = {
  readonly __typename?: 'stops_database_access_space_equipment_places';
  readonly access_space_id: Scalars['bigint']['output'];
  /** An object relationship */
  readonly equipment_place: StopsDatabaseEquipmentPlace;
  readonly equipment_places_id: Scalars['bigint']['output'];
};

/** aggregated selection of "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesAggregate = {
  readonly __typename?: 'stops_database_access_space_equipment_places_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlaces>;
};

/** aggregate fields of "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesAggregateFields = {
  readonly __typename?: 'stops_database_access_space_equipment_places_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesMaxFields>;
  readonly min?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesVarianceFields>;
};


/** aggregate fields of "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlacesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlacesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseAccessSpaceEquipmentPlacesAvgFields = {
  readonly __typename?: 'stops_database_access_space_equipment_places_avg_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesAvgOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly equipment_places_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "access_space_equipment_places". All fields are combined with a logical 'AND'. */
export type StopsDatabaseAccessSpaceEquipmentPlacesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>>;
  readonly access_space_id?: InputMaybe<BigintComparisonExp>;
  readonly equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceBoolExp>;
  readonly equipment_places_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "access_space_equipment_places" */
export enum StopsDatabaseAccessSpaceEquipmentPlacesConstraint {
  /** unique or primary key constraint on columns "equipment_places_id" */
  Uk_15g5ep156j0s0m3dmh1by6dof = 'uk_15g5ep156j0s0m3dmh1by6dof'
}

/** input type for incrementing numeric columns in table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesIncInput = {
  readonly access_space_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly equipment_places_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesInsertInput = {
  readonly access_space_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceObjRelInsertInput>;
  readonly equipment_places_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseAccessSpaceEquipmentPlacesMaxFields = {
  readonly __typename?: 'stops_database_access_space_equipment_places_max_fields';
  readonly access_space_id?: Maybe<Scalars['bigint']['output']>;
  readonly equipment_places_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesMaxOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly equipment_places_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseAccessSpaceEquipmentPlacesMinFields = {
  readonly __typename?: 'stops_database_access_space_equipment_places_min_fields';
  readonly access_space_id?: Maybe<Scalars['bigint']['output']>;
  readonly equipment_places_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesMinOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly equipment_places_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesMutationResponse = {
  readonly __typename?: 'stops_database_access_space_equipment_places_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlaces>;
};

/** on_conflict condition type for table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesOnConflict = {
  readonly constraint: StopsDatabaseAccessSpaceEquipmentPlacesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlacesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>;
};

/** Ordering options when selecting data from "access_space_equipment_places". */
export type StopsDatabaseAccessSpaceEquipmentPlacesOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceOrderBy>;
  readonly equipment_places_id?: InputMaybe<OrderBy>;
};

/** select columns of table "access_space_equipment_places" */
export enum StopsDatabaseAccessSpaceEquipmentPlacesSelectColumn {
  /** column name */
  AccessSpaceId = 'access_space_id',
  /** column name */
  EquipmentPlacesId = 'equipment_places_id'
}

/** input type for updating data in table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesSetInput = {
  readonly access_space_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly equipment_places_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseAccessSpaceEquipmentPlacesStddevFields = {
  readonly __typename?: 'stops_database_access_space_equipment_places_stddev_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesStddevOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly equipment_places_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseAccessSpaceEquipmentPlacesStddevPopFields = {
  readonly __typename?: 'stops_database_access_space_equipment_places_stddev_pop_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesStddevPopOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly equipment_places_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseAccessSpaceEquipmentPlacesStddevSampFields = {
  readonly __typename?: 'stops_database_access_space_equipment_places_stddev_samp_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesStddevSampOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly equipment_places_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseAccessSpaceEquipmentPlacesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseAccessSpaceEquipmentPlacesStreamCursorValueInput = {
  readonly access_space_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly equipment_places_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseAccessSpaceEquipmentPlacesSumFields = {
  readonly __typename?: 'stops_database_access_space_equipment_places_sum_fields';
  readonly access_space_id?: Maybe<Scalars['bigint']['output']>;
  readonly equipment_places_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesSumOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly equipment_places_id?: InputMaybe<OrderBy>;
};

/** update columns of table "access_space_equipment_places" */
export enum StopsDatabaseAccessSpaceEquipmentPlacesUpdateColumn {
  /** column name */
  AccessSpaceId = 'access_space_id',
  /** column name */
  EquipmentPlacesId = 'equipment_places_id'
}

export type StopsDatabaseAccessSpaceEquipmentPlacesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseAccessSpaceEquipmentPlacesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseAccessSpaceEquipmentPlacesVarPopFields = {
  readonly __typename?: 'stops_database_access_space_equipment_places_var_pop_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesVarPopOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly equipment_places_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseAccessSpaceEquipmentPlacesVarSampFields = {
  readonly __typename?: 'stops_database_access_space_equipment_places_var_samp_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesVarSampOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly equipment_places_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseAccessSpaceEquipmentPlacesVarianceFields = {
  readonly __typename?: 'stops_database_access_space_equipment_places_variance_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "access_space_equipment_places" */
export type StopsDatabaseAccessSpaceEquipmentPlacesVarianceOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly equipment_places_id?: InputMaybe<OrderBy>;
};

/** input type for incrementing numeric columns in table "access_space" */
export type StopsDatabaseAccessSpaceIncInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "access_space" */
export type StopsDatabaseAccessSpaceInsertInput = {
  readonly access_space_alternative_names?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesArrRelInsertInput>;
  readonly access_space_equipment_places?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesArrRelInsertInput>;
  readonly access_space_key_values?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesArrRelInsertInput>;
  readonly accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentObjRelInsertInput>;
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureObjRelInsertInput>;
  readonly label_lang?: InputMaybe<Scalars['String']['input']>;
  readonly label_value?: InputMaybe<Scalars['String']['input']>;
  readonly level_ref?: InputMaybe<Scalars['String']['input']>;
  readonly level_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonObjRelInsertInput>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValues = {
  readonly __typename?: 'stops_database_access_space_key_values';
  readonly access_space_id: Scalars['bigint']['output'];
  readonly key_values_id: Scalars['bigint']['output'];
  readonly key_values_key: Scalars['String']['output'];
  /** An object relationship */
  readonly value: StopsDatabaseValue;
};

/** aggregated selection of "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesAggregate = {
  readonly __typename?: 'stops_database_access_space_key_values_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseAccessSpaceKeyValuesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseAccessSpaceKeyValues>;
};

/** aggregate fields of "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesAggregateFields = {
  readonly __typename?: 'stops_database_access_space_key_values_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseAccessSpaceKeyValuesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseAccessSpaceKeyValuesMaxFields>;
  readonly min?: Maybe<StopsDatabaseAccessSpaceKeyValuesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseAccessSpaceKeyValuesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseAccessSpaceKeyValuesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseAccessSpaceKeyValuesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseAccessSpaceKeyValuesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseAccessSpaceKeyValuesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseAccessSpaceKeyValuesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseAccessSpaceKeyValuesVarianceFields>;
};


/** aggregate fields of "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseAccessSpaceKeyValuesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseAccessSpaceKeyValuesAvgFields = {
  readonly __typename?: 'stops_database_access_space_key_values_avg_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesAvgOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "access_space_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseAccessSpaceKeyValuesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceKeyValuesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceKeyValuesBoolExp>>;
  readonly access_space_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_key?: InputMaybe<StringComparisonExp>;
  readonly value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "access_space_key_values" */
export enum StopsDatabaseAccessSpaceKeyValuesConstraint {
  /** unique or primary key constraint on columns "key_values_key", "access_space_id" */
  AccessSpaceKeyValuesPkey = 'access_space_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkKcsgl47aba68824kjdceo60ql = 'uk_kcsgl47aba68824kjdceo60ql'
}

/** input type for incrementing numeric columns in table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesIncInput = {
  readonly access_space_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesInsertInput = {
  readonly access_space_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseAccessSpaceKeyValuesMaxFields = {
  readonly __typename?: 'stops_database_access_space_key_values_max_fields';
  readonly access_space_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesMaxOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseAccessSpaceKeyValuesMinFields = {
  readonly __typename?: 'stops_database_access_space_key_values_min_fields';
  readonly access_space_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesMinOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesMutationResponse = {
  readonly __typename?: 'stops_database_access_space_key_values_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseAccessSpaceKeyValues>;
};

/** on_conflict condition type for table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesOnConflict = {
  readonly constraint: StopsDatabaseAccessSpaceKeyValuesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseAccessSpaceKeyValuesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "access_space_key_values". */
export type StopsDatabaseAccessSpaceKeyValuesOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: access_space_key_values */
export type StopsDatabaseAccessSpaceKeyValuesPkColumnsInput = {
  readonly access_space_id: Scalars['bigint']['input'];
  readonly key_values_key: Scalars['String']['input'];
};

/** select columns of table "access_space_key_values" */
export enum StopsDatabaseAccessSpaceKeyValuesSelectColumn {
  /** column name */
  AccessSpaceId = 'access_space_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key'
}

/** input type for updating data in table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesSetInput = {
  readonly access_space_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseAccessSpaceKeyValuesStddevFields = {
  readonly __typename?: 'stops_database_access_space_key_values_stddev_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesStddevOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseAccessSpaceKeyValuesStddevPopFields = {
  readonly __typename?: 'stops_database_access_space_key_values_stddev_pop_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesStddevPopOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseAccessSpaceKeyValuesStddevSampFields = {
  readonly __typename?: 'stops_database_access_space_key_values_stddev_samp_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesStddevSampOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseAccessSpaceKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseAccessSpaceKeyValuesStreamCursorValueInput = {
  readonly access_space_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseAccessSpaceKeyValuesSumFields = {
  readonly __typename?: 'stops_database_access_space_key_values_sum_fields';
  readonly access_space_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesSumOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** update columns of table "access_space_key_values" */
export enum StopsDatabaseAccessSpaceKeyValuesUpdateColumn {
  /** column name */
  AccessSpaceId = 'access_space_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key'
}

export type StopsDatabaseAccessSpaceKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseAccessSpaceKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseAccessSpaceKeyValuesVarPopFields = {
  readonly __typename?: 'stops_database_access_space_key_values_var_pop_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesVarPopOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseAccessSpaceKeyValuesVarSampFields = {
  readonly __typename?: 'stops_database_access_space_key_values_var_samp_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesVarSampOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseAccessSpaceKeyValuesVarianceFields = {
  readonly __typename?: 'stops_database_access_space_key_values_variance_fields';
  readonly access_space_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "access_space_key_values" */
export type StopsDatabaseAccessSpaceKeyValuesVarianceOrderBy = {
  readonly access_space_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseAccessSpaceMaxFields = {
  readonly __typename?: 'stops_database_access_space_max_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly label_lang?: Maybe<Scalars['String']['output']>;
  readonly label_value?: Maybe<Scalars['String']['output']>;
  readonly level_ref?: Maybe<Scalars['String']['output']>;
  readonly level_ref_version?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly site_ref?: Maybe<Scalars['String']['output']>;
  readonly site_ref_version?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseAccessSpaceMinFields = {
  readonly __typename?: 'stops_database_access_space_min_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly label_lang?: Maybe<Scalars['String']['output']>;
  readonly label_value?: Maybe<Scalars['String']['output']>;
  readonly level_ref?: Maybe<Scalars['String']['output']>;
  readonly level_ref_version?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly site_ref?: Maybe<Scalars['String']['output']>;
  readonly site_ref_version?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "access_space" */
export type StopsDatabaseAccessSpaceMutationResponse = {
  readonly __typename?: 'stops_database_access_space_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseAccessSpace>;
};

/** input type for inserting object relation for remote table "access_space" */
export type StopsDatabaseAccessSpaceObjRelInsertInput = {
  readonly data: StopsDatabaseAccessSpaceInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseAccessSpaceOnConflict>;
};

/** on_conflict condition type for table "access_space" */
export type StopsDatabaseAccessSpaceOnConflict = {
  readonly constraint: StopsDatabaseAccessSpaceConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseAccessSpaceUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseAccessSpaceBoolExp>;
};

/** Ordering options when selecting data from "access_space". */
export type StopsDatabaseAccessSpaceOrderBy = {
  readonly access_space_alternative_names_aggregate?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesAggregateOrderBy>;
  readonly access_space_equipment_places_aggregate?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesAggregateOrderBy>;
  readonly access_space_key_values_aggregate?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesAggregateOrderBy>;
  readonly accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentOrderBy>;
  readonly accessibility_assessment_id?: InputMaybe<OrderBy>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<OrderBy>;
  readonly centroid?: InputMaybe<OrderBy>;
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly covered?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly description_lang?: InputMaybe<OrderBy>;
  readonly description_value?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureOrderBy>;
  readonly label_lang?: InputMaybe<OrderBy>;
  readonly label_value?: InputMaybe<OrderBy>;
  readonly level_ref?: InputMaybe<OrderBy>;
  readonly level_ref_version?: InputMaybe<OrderBy>;
  readonly name_lang?: InputMaybe<OrderBy>;
  readonly name_value?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonOrderBy>;
  readonly place_equipments_id?: InputMaybe<OrderBy>;
  readonly polygon_id?: InputMaybe<OrderBy>;
  readonly private_code_type?: InputMaybe<OrderBy>;
  readonly private_code_value?: InputMaybe<OrderBy>;
  readonly short_name_lang?: InputMaybe<OrderBy>;
  readonly short_name_value?: InputMaybe<OrderBy>;
  readonly site_ref?: InputMaybe<OrderBy>;
  readonly site_ref_version?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: access_space */
export type StopsDatabaseAccessSpacePkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "access_space" */
export enum StopsDatabaseAccessSpaceSelectColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  LabelLang = 'label_lang',
  /** column name */
  LabelValue = 'label_value',
  /** column name */
  LevelRef = 'level_ref',
  /** column name */
  LevelRefVersion = 'level_ref_version',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  SiteRef = 'site_ref',
  /** column name */
  SiteRefVersion = 'site_ref_version',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

/** input type for updating data in table "access_space" */
export type StopsDatabaseAccessSpaceSetInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly label_lang?: InputMaybe<Scalars['String']['input']>;
  readonly label_value?: InputMaybe<Scalars['String']['input']>;
  readonly level_ref?: InputMaybe<Scalars['String']['input']>;
  readonly level_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseAccessSpaceStddevFields = {
  readonly __typename?: 'stops_database_access_space_stddev_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseAccessSpaceStddevPopFields = {
  readonly __typename?: 'stops_database_access_space_stddev_pop_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseAccessSpaceStddevSampFields = {
  readonly __typename?: 'stops_database_access_space_stddev_samp_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "access_space" */
export type StopsDatabaseAccessSpaceStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseAccessSpaceStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseAccessSpaceStreamCursorValueInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly label_lang?: InputMaybe<Scalars['String']['input']>;
  readonly label_value?: InputMaybe<Scalars['String']['input']>;
  readonly level_ref?: InputMaybe<Scalars['String']['input']>;
  readonly level_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseAccessSpaceSumFields = {
  readonly __typename?: 'stops_database_access_space_sum_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "access_space" */
export enum StopsDatabaseAccessSpaceUpdateColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  LabelLang = 'label_lang',
  /** column name */
  LabelValue = 'label_value',
  /** column name */
  LevelRef = 'level_ref',
  /** column name */
  LevelRefVersion = 'level_ref_version',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  SiteRef = 'site_ref',
  /** column name */
  SiteRefVersion = 'site_ref_version',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

export type StopsDatabaseAccessSpaceUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseAccessSpaceIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseAccessSpaceSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseAccessSpaceBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseAccessSpaceVarPopFields = {
  readonly __typename?: 'stops_database_access_space_var_pop_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseAccessSpaceVarSampFields = {
  readonly __typename?: 'stops_database_access_space_var_samp_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseAccessSpaceVarianceFields = {
  readonly __typename?: 'stops_database_access_space_variance_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessment = {
  readonly __typename?: 'stops_database_accessibility_assessment';
  /** An array relationship */
  readonly accessibility_assessment_limitations: ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitations>;
  /** An aggregate relationship */
  readonly accessibility_assessment_limitations_aggregate: StopsDatabaseAccessibilityAssessmentLimitationsAggregate;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly hsl_accessibility_properties_id?: Maybe<Scalars['bigint']['output']>;
  readonly id: Scalars['bigint']['output'];
  readonly mobility_impaired_access?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessmentAccessibilityAssessmentLimitationsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitationsOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>;
};


/** columns and relationships of "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessmentAccessibilityAssessmentLimitationsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitationsOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>;
};

/** aggregated selection of "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessmentAggregate = {
  readonly __typename?: 'stops_database_accessibility_assessment_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseAccessibilityAssessmentAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseAccessibilityAssessment>;
};

/** aggregate fields of "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessmentAggregateFields = {
  readonly __typename?: 'stops_database_accessibility_assessment_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseAccessibilityAssessmentAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseAccessibilityAssessmentMaxFields>;
  readonly min?: Maybe<StopsDatabaseAccessibilityAssessmentMinFields>;
  readonly stddev?: Maybe<StopsDatabaseAccessibilityAssessmentStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseAccessibilityAssessmentStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseAccessibilityAssessmentStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseAccessibilityAssessmentSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseAccessibilityAssessmentVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseAccessibilityAssessmentVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseAccessibilityAssessmentVarianceFields>;
};


/** aggregate fields of "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessmentAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseAccessibilityAssessmentAvgFields = {
  readonly __typename?: 'stops_database_accessibility_assessment_avg_fields';
  readonly hsl_accessibility_properties_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "accessibility_assessment". All fields are combined with a logical 'AND'. */
export type StopsDatabaseAccessibilityAssessmentBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseAccessibilityAssessmentBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentBoolExp>>;
  readonly accessibility_assessment_limitations?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>;
  readonly accessibility_assessment_limitations_aggregate?: InputMaybe<AccessibilityAssessmentLimitationsAggregateBoolExp>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly hsl_accessibility_properties_id?: InputMaybe<BigintComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly mobility_impaired_access?: InputMaybe<StringComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "accessibility_assessment" */
export enum StopsDatabaseAccessibilityAssessmentConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  AccessibilityAssessmentNetexIdVersionConstraint = 'accessibility_assessment_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  AccessibilityAssessmentPkey = 'accessibility_assessment_pkey'
}

/** input type for incrementing numeric columns in table "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessmentIncInput = {
  readonly hsl_accessibility_properties_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessmentInsertInput = {
  readonly accessibility_assessment_limitations?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsArrRelInsertInput>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly hsl_accessibility_properties_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly mobility_impaired_access?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitations = {
  readonly __typename?: 'stops_database_accessibility_assessment_limitations';
  readonly accessibility_assessment_id: Scalars['bigint']['output'];
  /** An object relationship */
  readonly accessibility_limitation: StopsDatabaseAccessibilityLimitation;
  readonly limitations_id: Scalars['bigint']['output'];
};

/** aggregated selection of "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsAggregate = {
  readonly __typename?: 'stops_database_accessibility_assessment_limitations_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitations>;
};

/** aggregate fields of "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsAggregateFields = {
  readonly __typename?: 'stops_database_accessibility_assessment_limitations_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsMaxFields>;
  readonly min?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsMinFields>;
  readonly stddev?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsVarianceFields>;
};


/** aggregate fields of "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitationsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitationsInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseAccessibilityAssessmentLimitationsAvgFields = {
  readonly __typename?: 'stops_database_accessibility_assessment_limitations_avg_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly limitations_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsAvgOrderBy = {
  readonly accessibility_assessment_id?: InputMaybe<OrderBy>;
  readonly limitations_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "accessibility_assessment_limitations". All fields are combined with a logical 'AND'. */
export type StopsDatabaseAccessibilityAssessmentLimitationsBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>>;
  readonly accessibility_assessment_id?: InputMaybe<BigintComparisonExp>;
  readonly accessibility_limitation?: InputMaybe<StopsDatabaseAccessibilityLimitationBoolExp>;
  readonly limitations_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "accessibility_assessment_limitations" */
export enum StopsDatabaseAccessibilityAssessmentLimitationsConstraint {
  /** unique or primary key constraint on columns "limitations_id" */
  UkAeu5728ehva06k95lioaubr8s = 'uk_aeu5728ehva06k95lioaubr8s'
}

/** input type for incrementing numeric columns in table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsIncInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly limitations_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsInsertInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly accessibility_limitation?: InputMaybe<StopsDatabaseAccessibilityLimitationObjRelInsertInput>;
  readonly limitations_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseAccessibilityAssessmentLimitationsMaxFields = {
  readonly __typename?: 'stops_database_accessibility_assessment_limitations_max_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly limitations_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsMaxOrderBy = {
  readonly accessibility_assessment_id?: InputMaybe<OrderBy>;
  readonly limitations_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseAccessibilityAssessmentLimitationsMinFields = {
  readonly __typename?: 'stops_database_accessibility_assessment_limitations_min_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly limitations_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsMinOrderBy = {
  readonly accessibility_assessment_id?: InputMaybe<OrderBy>;
  readonly limitations_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsMutationResponse = {
  readonly __typename?: 'stops_database_accessibility_assessment_limitations_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitations>;
};

/** on_conflict condition type for table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsOnConflict = {
  readonly constraint: StopsDatabaseAccessibilityAssessmentLimitationsConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitationsUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>;
};

/** Ordering options when selecting data from "accessibility_assessment_limitations". */
export type StopsDatabaseAccessibilityAssessmentLimitationsOrderBy = {
  readonly accessibility_assessment_id?: InputMaybe<OrderBy>;
  readonly accessibility_limitation?: InputMaybe<StopsDatabaseAccessibilityLimitationOrderBy>;
  readonly limitations_id?: InputMaybe<OrderBy>;
};

/** select columns of table "accessibility_assessment_limitations" */
export enum StopsDatabaseAccessibilityAssessmentLimitationsSelectColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  LimitationsId = 'limitations_id'
}

/** input type for updating data in table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsSetInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly limitations_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseAccessibilityAssessmentLimitationsStddevFields = {
  readonly __typename?: 'stops_database_accessibility_assessment_limitations_stddev_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly limitations_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsStddevOrderBy = {
  readonly accessibility_assessment_id?: InputMaybe<OrderBy>;
  readonly limitations_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseAccessibilityAssessmentLimitationsStddevPopFields = {
  readonly __typename?: 'stops_database_accessibility_assessment_limitations_stddev_pop_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly limitations_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsStddevPopOrderBy = {
  readonly accessibility_assessment_id?: InputMaybe<OrderBy>;
  readonly limitations_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseAccessibilityAssessmentLimitationsStddevSampFields = {
  readonly __typename?: 'stops_database_accessibility_assessment_limitations_stddev_samp_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly limitations_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsStddevSampOrderBy = {
  readonly accessibility_assessment_id?: InputMaybe<OrderBy>;
  readonly limitations_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseAccessibilityAssessmentLimitationsStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseAccessibilityAssessmentLimitationsStreamCursorValueInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly limitations_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseAccessibilityAssessmentLimitationsSumFields = {
  readonly __typename?: 'stops_database_accessibility_assessment_limitations_sum_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly limitations_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsSumOrderBy = {
  readonly accessibility_assessment_id?: InputMaybe<OrderBy>;
  readonly limitations_id?: InputMaybe<OrderBy>;
};

/** update columns of table "accessibility_assessment_limitations" */
export enum StopsDatabaseAccessibilityAssessmentLimitationsUpdateColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  LimitationsId = 'limitations_id'
}

export type StopsDatabaseAccessibilityAssessmentLimitationsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseAccessibilityAssessmentLimitationsBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseAccessibilityAssessmentLimitationsVarPopFields = {
  readonly __typename?: 'stops_database_accessibility_assessment_limitations_var_pop_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly limitations_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsVarPopOrderBy = {
  readonly accessibility_assessment_id?: InputMaybe<OrderBy>;
  readonly limitations_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseAccessibilityAssessmentLimitationsVarSampFields = {
  readonly __typename?: 'stops_database_accessibility_assessment_limitations_var_samp_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly limitations_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsVarSampOrderBy = {
  readonly accessibility_assessment_id?: InputMaybe<OrderBy>;
  readonly limitations_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseAccessibilityAssessmentLimitationsVarianceFields = {
  readonly __typename?: 'stops_database_accessibility_assessment_limitations_variance_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly limitations_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "accessibility_assessment_limitations" */
export type StopsDatabaseAccessibilityAssessmentLimitationsVarianceOrderBy = {
  readonly accessibility_assessment_id?: InputMaybe<OrderBy>;
  readonly limitations_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseAccessibilityAssessmentMaxFields = {
  readonly __typename?: 'stops_database_accessibility_assessment_max_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly hsl_accessibility_properties_id?: Maybe<Scalars['bigint']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly mobility_impaired_access?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseAccessibilityAssessmentMinFields = {
  readonly __typename?: 'stops_database_accessibility_assessment_min_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly hsl_accessibility_properties_id?: Maybe<Scalars['bigint']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly mobility_impaired_access?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessmentMutationResponse = {
  readonly __typename?: 'stops_database_accessibility_assessment_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseAccessibilityAssessment>;
};

/** input type for inserting object relation for remote table "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessmentObjRelInsertInput = {
  readonly data: StopsDatabaseAccessibilityAssessmentInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseAccessibilityAssessmentOnConflict>;
};

/** on_conflict condition type for table "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessmentOnConflict = {
  readonly constraint: StopsDatabaseAccessibilityAssessmentConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseAccessibilityAssessmentUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseAccessibilityAssessmentBoolExp>;
};

/** Ordering options when selecting data from "accessibility_assessment". */
export type StopsDatabaseAccessibilityAssessmentOrderBy = {
  readonly accessibility_assessment_limitations_aggregate?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsAggregateOrderBy>;
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly hsl_accessibility_properties_id?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly mobility_impaired_access?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: accessibility_assessment */
export type StopsDatabaseAccessibilityAssessmentPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "accessibility_assessment" */
export enum StopsDatabaseAccessibilityAssessmentSelectColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  HslAccessibilityPropertiesId = 'hsl_accessibility_properties_id',
  /** column name */
  Id = 'id',
  /** column name */
  MobilityImpairedAccess = 'mobility_impaired_access',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

/** input type for updating data in table "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessmentSetInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly hsl_accessibility_properties_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly mobility_impaired_access?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseAccessibilityAssessmentStddevFields = {
  readonly __typename?: 'stops_database_accessibility_assessment_stddev_fields';
  readonly hsl_accessibility_properties_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseAccessibilityAssessmentStddevPopFields = {
  readonly __typename?: 'stops_database_accessibility_assessment_stddev_pop_fields';
  readonly hsl_accessibility_properties_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseAccessibilityAssessmentStddevSampFields = {
  readonly __typename?: 'stops_database_accessibility_assessment_stddev_samp_fields';
  readonly hsl_accessibility_properties_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "accessibility_assessment" */
export type StopsDatabaseAccessibilityAssessmentStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseAccessibilityAssessmentStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseAccessibilityAssessmentStreamCursorValueInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly hsl_accessibility_properties_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly mobility_impaired_access?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseAccessibilityAssessmentSumFields = {
  readonly __typename?: 'stops_database_accessibility_assessment_sum_fields';
  readonly hsl_accessibility_properties_id?: Maybe<Scalars['bigint']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "accessibility_assessment" */
export enum StopsDatabaseAccessibilityAssessmentUpdateColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  HslAccessibilityPropertiesId = 'hsl_accessibility_properties_id',
  /** column name */
  Id = 'id',
  /** column name */
  MobilityImpairedAccess = 'mobility_impaired_access',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

export type StopsDatabaseAccessibilityAssessmentUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseAccessibilityAssessmentIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseAccessibilityAssessmentSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseAccessibilityAssessmentBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseAccessibilityAssessmentVarPopFields = {
  readonly __typename?: 'stops_database_accessibility_assessment_var_pop_fields';
  readonly hsl_accessibility_properties_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseAccessibilityAssessmentVarSampFields = {
  readonly __typename?: 'stops_database_accessibility_assessment_var_samp_fields';
  readonly hsl_accessibility_properties_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseAccessibilityAssessmentVarianceFields = {
  readonly __typename?: 'stops_database_accessibility_assessment_variance_fields';
  readonly hsl_accessibility_properties_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "accessibility_limitation" */
export type StopsDatabaseAccessibilityLimitation = {
  readonly __typename?: 'stops_database_accessibility_limitation';
  readonly audible_signals_available?: Maybe<Scalars['String']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly escalator_free_access?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id: Scalars['bigint']['output'];
  readonly lift_free_access?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly step_free_access?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly visual_signs_available?: Maybe<Scalars['String']['output']>;
  readonly wheelchair_access?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "accessibility_limitation" */
export type StopsDatabaseAccessibilityLimitationAggregate = {
  readonly __typename?: 'stops_database_accessibility_limitation_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseAccessibilityLimitationAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseAccessibilityLimitation>;
};

/** aggregate fields of "accessibility_limitation" */
export type StopsDatabaseAccessibilityLimitationAggregateFields = {
  readonly __typename?: 'stops_database_accessibility_limitation_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseAccessibilityLimitationAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseAccessibilityLimitationMaxFields>;
  readonly min?: Maybe<StopsDatabaseAccessibilityLimitationMinFields>;
  readonly stddev?: Maybe<StopsDatabaseAccessibilityLimitationStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseAccessibilityLimitationStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseAccessibilityLimitationStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseAccessibilityLimitationSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseAccessibilityLimitationVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseAccessibilityLimitationVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseAccessibilityLimitationVarianceFields>;
};


/** aggregate fields of "accessibility_limitation" */
export type StopsDatabaseAccessibilityLimitationAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityLimitationSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseAccessibilityLimitationAvgFields = {
  readonly __typename?: 'stops_database_accessibility_limitation_avg_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "accessibility_limitation". All fields are combined with a logical 'AND'. */
export type StopsDatabaseAccessibilityLimitationBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityLimitationBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseAccessibilityLimitationBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityLimitationBoolExp>>;
  readonly audible_signals_available?: InputMaybe<StringComparisonExp>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly escalator_free_access?: InputMaybe<StringComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly lift_free_access?: InputMaybe<StringComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly step_free_access?: InputMaybe<StringComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
  readonly visual_signs_available?: InputMaybe<StringComparisonExp>;
  readonly wheelchair_access?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "accessibility_limitation" */
export enum StopsDatabaseAccessibilityLimitationConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  AccessibilityLimitationNetexIdVersionConstraint = 'accessibility_limitation_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  AccessibilityLimitationPkey = 'accessibility_limitation_pkey'
}

/** input type for incrementing numeric columns in table "accessibility_limitation" */
export type StopsDatabaseAccessibilityLimitationIncInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "accessibility_limitation" */
export type StopsDatabaseAccessibilityLimitationInsertInput = {
  readonly audible_signals_available?: InputMaybe<Scalars['String']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly escalator_free_access?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly lift_free_access?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly step_free_access?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
  readonly visual_signs_available?: InputMaybe<Scalars['String']['input']>;
  readonly wheelchair_access?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseAccessibilityLimitationMaxFields = {
  readonly __typename?: 'stops_database_accessibility_limitation_max_fields';
  readonly audible_signals_available?: Maybe<Scalars['String']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly escalator_free_access?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly lift_free_access?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly step_free_access?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly visual_signs_available?: Maybe<Scalars['String']['output']>;
  readonly wheelchair_access?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseAccessibilityLimitationMinFields = {
  readonly __typename?: 'stops_database_accessibility_limitation_min_fields';
  readonly audible_signals_available?: Maybe<Scalars['String']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly escalator_free_access?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly lift_free_access?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly step_free_access?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly visual_signs_available?: Maybe<Scalars['String']['output']>;
  readonly wheelchair_access?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "accessibility_limitation" */
export type StopsDatabaseAccessibilityLimitationMutationResponse = {
  readonly __typename?: 'stops_database_accessibility_limitation_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseAccessibilityLimitation>;
};

/** input type for inserting object relation for remote table "accessibility_limitation" */
export type StopsDatabaseAccessibilityLimitationObjRelInsertInput = {
  readonly data: StopsDatabaseAccessibilityLimitationInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseAccessibilityLimitationOnConflict>;
};

/** on_conflict condition type for table "accessibility_limitation" */
export type StopsDatabaseAccessibilityLimitationOnConflict = {
  readonly constraint: StopsDatabaseAccessibilityLimitationConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseAccessibilityLimitationUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseAccessibilityLimitationBoolExp>;
};

/** Ordering options when selecting data from "accessibility_limitation". */
export type StopsDatabaseAccessibilityLimitationOrderBy = {
  readonly audible_signals_available?: InputMaybe<OrderBy>;
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly escalator_free_access?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly lift_free_access?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly step_free_access?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
  readonly visual_signs_available?: InputMaybe<OrderBy>;
  readonly wheelchair_access?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: accessibility_limitation */
export type StopsDatabaseAccessibilityLimitationPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "accessibility_limitation" */
export enum StopsDatabaseAccessibilityLimitationSelectColumn {
  /** column name */
  AudibleSignalsAvailable = 'audible_signals_available',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  EscalatorFreeAccess = 'escalator_free_access',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  LiftFreeAccess = 'lift_free_access',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  StepFreeAccess = 'step_free_access',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  VisualSignsAvailable = 'visual_signs_available',
  /** column name */
  WheelchairAccess = 'wheelchair_access'
}

/** input type for updating data in table "accessibility_limitation" */
export type StopsDatabaseAccessibilityLimitationSetInput = {
  readonly audible_signals_available?: InputMaybe<Scalars['String']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly escalator_free_access?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly lift_free_access?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly step_free_access?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
  readonly visual_signs_available?: InputMaybe<Scalars['String']['input']>;
  readonly wheelchair_access?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseAccessibilityLimitationStddevFields = {
  readonly __typename?: 'stops_database_accessibility_limitation_stddev_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseAccessibilityLimitationStddevPopFields = {
  readonly __typename?: 'stops_database_accessibility_limitation_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseAccessibilityLimitationStddevSampFields = {
  readonly __typename?: 'stops_database_accessibility_limitation_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "accessibility_limitation" */
export type StopsDatabaseAccessibilityLimitationStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseAccessibilityLimitationStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseAccessibilityLimitationStreamCursorValueInput = {
  readonly audible_signals_available?: InputMaybe<Scalars['String']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly escalator_free_access?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly lift_free_access?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly step_free_access?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
  readonly visual_signs_available?: InputMaybe<Scalars['String']['input']>;
  readonly wheelchair_access?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseAccessibilityLimitationSumFields = {
  readonly __typename?: 'stops_database_accessibility_limitation_sum_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "accessibility_limitation" */
export enum StopsDatabaseAccessibilityLimitationUpdateColumn {
  /** column name */
  AudibleSignalsAvailable = 'audible_signals_available',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  EscalatorFreeAccess = 'escalator_free_access',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  LiftFreeAccess = 'lift_free_access',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  StepFreeAccess = 'step_free_access',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  VisualSignsAvailable = 'visual_signs_available',
  /** column name */
  WheelchairAccess = 'wheelchair_access'
}

export type StopsDatabaseAccessibilityLimitationUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseAccessibilityLimitationIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseAccessibilityLimitationSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseAccessibilityLimitationBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseAccessibilityLimitationVarPopFields = {
  readonly __typename?: 'stops_database_accessibility_limitation_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseAccessibilityLimitationVarSampFields = {
  readonly __typename?: 'stops_database_accessibility_limitation_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseAccessibilityLimitationVarianceFields = {
  readonly __typename?: 'stops_database_accessibility_limitation_variance_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "alternative_name" */
export type StopsDatabaseAlternativeName = {
  readonly __typename?: 'stops_database_alternative_name';
  readonly abbreviation_lang?: Maybe<Scalars['String']['output']>;
  readonly abbreviation_value?: Maybe<Scalars['String']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id: Scalars['bigint']['output'];
  readonly lang?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_type?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly named_object_ref?: Maybe<Scalars['bytea']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly qualifier_name_lang?: Maybe<Scalars['String']['output']>;
  readonly qualifier_name_value?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly type_of_name?: Maybe<Scalars['String']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "alternative_name" */
export type StopsDatabaseAlternativeNameAggregate = {
  readonly __typename?: 'stops_database_alternative_name_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseAlternativeNameAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseAlternativeName>;
};

/** aggregate fields of "alternative_name" */
export type StopsDatabaseAlternativeNameAggregateFields = {
  readonly __typename?: 'stops_database_alternative_name_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseAlternativeNameAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseAlternativeNameMaxFields>;
  readonly min?: Maybe<StopsDatabaseAlternativeNameMinFields>;
  readonly stddev?: Maybe<StopsDatabaseAlternativeNameStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseAlternativeNameStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseAlternativeNameStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseAlternativeNameSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseAlternativeNameVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseAlternativeNameVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseAlternativeNameVarianceFields>;
};


/** aggregate fields of "alternative_name" */
export type StopsDatabaseAlternativeNameAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseAlternativeNameSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseAlternativeNameAvgFields = {
  readonly __typename?: 'stops_database_alternative_name_avg_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "alternative_name". All fields are combined with a logical 'AND'. */
export type StopsDatabaseAlternativeNameBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseAlternativeNameBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseAlternativeNameBoolExp>>;
  readonly abbreviation_lang?: InputMaybe<StringComparisonExp>;
  readonly abbreviation_value?: InputMaybe<StringComparisonExp>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly lang?: InputMaybe<StringComparisonExp>;
  readonly name_lang?: InputMaybe<StringComparisonExp>;
  readonly name_type?: InputMaybe<StringComparisonExp>;
  readonly name_value?: InputMaybe<StringComparisonExp>;
  readonly named_object_ref?: InputMaybe<ByteaComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly qualifier_name_lang?: InputMaybe<StringComparisonExp>;
  readonly qualifier_name_value?: InputMaybe<StringComparisonExp>;
  readonly short_name_lang?: InputMaybe<StringComparisonExp>;
  readonly short_name_value?: InputMaybe<StringComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly type_of_name?: InputMaybe<StringComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "alternative_name" */
export enum StopsDatabaseAlternativeNameConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  AlternativeNameNetexIdVersionConstraint = 'alternative_name_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  AlternativeNamePkey = 'alternative_name_pkey'
}

/** input type for incrementing numeric columns in table "alternative_name" */
export type StopsDatabaseAlternativeNameIncInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "alternative_name" */
export type StopsDatabaseAlternativeNameInsertInput = {
  readonly abbreviation_lang?: InputMaybe<Scalars['String']['input']>;
  readonly abbreviation_value?: InputMaybe<Scalars['String']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_type?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly named_object_ref?: InputMaybe<Scalars['bytea']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly qualifier_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly qualifier_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly type_of_name?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseAlternativeNameMaxFields = {
  readonly __typename?: 'stops_database_alternative_name_max_fields';
  readonly abbreviation_lang?: Maybe<Scalars['String']['output']>;
  readonly abbreviation_value?: Maybe<Scalars['String']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly lang?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_type?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly qualifier_name_lang?: Maybe<Scalars['String']['output']>;
  readonly qualifier_name_value?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly type_of_name?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseAlternativeNameMinFields = {
  readonly __typename?: 'stops_database_alternative_name_min_fields';
  readonly abbreviation_lang?: Maybe<Scalars['String']['output']>;
  readonly abbreviation_value?: Maybe<Scalars['String']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly lang?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_type?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly qualifier_name_lang?: Maybe<Scalars['String']['output']>;
  readonly qualifier_name_value?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly type_of_name?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "alternative_name" */
export type StopsDatabaseAlternativeNameMutationResponse = {
  readonly __typename?: 'stops_database_alternative_name_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseAlternativeName>;
};

/** input type for inserting object relation for remote table "alternative_name" */
export type StopsDatabaseAlternativeNameObjRelInsertInput = {
  readonly data: StopsDatabaseAlternativeNameInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseAlternativeNameOnConflict>;
};

/** on_conflict condition type for table "alternative_name" */
export type StopsDatabaseAlternativeNameOnConflict = {
  readonly constraint: StopsDatabaseAlternativeNameConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseAlternativeNameUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
};

/** Ordering options when selecting data from "alternative_name". */
export type StopsDatabaseAlternativeNameOrderBy = {
  readonly abbreviation_lang?: InputMaybe<OrderBy>;
  readonly abbreviation_value?: InputMaybe<OrderBy>;
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly lang?: InputMaybe<OrderBy>;
  readonly name_lang?: InputMaybe<OrderBy>;
  readonly name_type?: InputMaybe<OrderBy>;
  readonly name_value?: InputMaybe<OrderBy>;
  readonly named_object_ref?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly qualifier_name_lang?: InputMaybe<OrderBy>;
  readonly qualifier_name_value?: InputMaybe<OrderBy>;
  readonly short_name_lang?: InputMaybe<OrderBy>;
  readonly short_name_value?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly type_of_name?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: alternative_name */
export type StopsDatabaseAlternativeNamePkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "alternative_name" */
export enum StopsDatabaseAlternativeNameSelectColumn {
  /** column name */
  AbbreviationLang = 'abbreviation_lang',
  /** column name */
  AbbreviationValue = 'abbreviation_value',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  Lang = 'lang',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameType = 'name_type',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NamedObjectRef = 'named_object_ref',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  QualifierNameLang = 'qualifier_name_lang',
  /** column name */
  QualifierNameValue = 'qualifier_name_value',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TypeOfName = 'type_of_name',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

/** input type for updating data in table "alternative_name" */
export type StopsDatabaseAlternativeNameSetInput = {
  readonly abbreviation_lang?: InputMaybe<Scalars['String']['input']>;
  readonly abbreviation_value?: InputMaybe<Scalars['String']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_type?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly named_object_ref?: InputMaybe<Scalars['bytea']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly qualifier_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly qualifier_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly type_of_name?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseAlternativeNameStddevFields = {
  readonly __typename?: 'stops_database_alternative_name_stddev_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseAlternativeNameStddevPopFields = {
  readonly __typename?: 'stops_database_alternative_name_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseAlternativeNameStddevSampFields = {
  readonly __typename?: 'stops_database_alternative_name_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "alternative_name" */
export type StopsDatabaseAlternativeNameStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseAlternativeNameStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseAlternativeNameStreamCursorValueInput = {
  readonly abbreviation_lang?: InputMaybe<Scalars['String']['input']>;
  readonly abbreviation_value?: InputMaybe<Scalars['String']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_type?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly named_object_ref?: InputMaybe<Scalars['bytea']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly qualifier_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly qualifier_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly type_of_name?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseAlternativeNameSumFields = {
  readonly __typename?: 'stops_database_alternative_name_sum_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "alternative_name" */
export enum StopsDatabaseAlternativeNameUpdateColumn {
  /** column name */
  AbbreviationLang = 'abbreviation_lang',
  /** column name */
  AbbreviationValue = 'abbreviation_value',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  Lang = 'lang',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameType = 'name_type',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NamedObjectRef = 'named_object_ref',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  QualifierNameLang = 'qualifier_name_lang',
  /** column name */
  QualifierNameValue = 'qualifier_name_value',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TypeOfName = 'type_of_name',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

export type StopsDatabaseAlternativeNameUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseAlternativeNameIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseAlternativeNameSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseAlternativeNameBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseAlternativeNameVarPopFields = {
  readonly __typename?: 'stops_database_alternative_name_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseAlternativeNameVarSampFields = {
  readonly __typename?: 'stops_database_alternative_name_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseAlternativeNameVarianceFields = {
  readonly __typename?: 'stops_database_alternative_name_variance_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "boarding_position" */
export type StopsDatabaseBoardingPosition = {
  readonly __typename?: 'stops_database_boarding_position';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly all_areas_wheelchair_accessible?: Maybe<Scalars['Boolean']['output']>;
  /** An array relationship */
  readonly boarding_position_alternative_names: ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNames>;
  /** An aggregate relationship */
  readonly boarding_position_alternative_names_aggregate: StopsDatabaseBoardingPositionAlternativeNamesAggregate;
  /** An array relationship */
  readonly boarding_position_equipment_places: ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlaces>;
  /** An aggregate relationship */
  readonly boarding_position_equipment_places_aggregate: StopsDatabaseBoardingPositionEquipmentPlacesAggregate;
  /** An array relationship */
  readonly boarding_position_key_values: ReadonlyArray<StopsDatabaseBoardingPositionKeyValues>;
  /** An aggregate relationship */
  readonly boarding_position_key_values_aggregate: StopsDatabaseBoardingPositionKeyValuesAggregate;
  readonly boarding_position_type?: Maybe<Scalars['String']['output']>;
  readonly centroid?: Maybe<Scalars['geometry']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id: Scalars['bigint']['output'];
  /** An object relationship */
  readonly installed_equipment_version_structure?: Maybe<StopsDatabaseInstalledEquipmentVersionStructure>;
  readonly label_lang?: Maybe<Scalars['String']['output']>;
  readonly label_value?: Maybe<Scalars['String']['output']>;
  readonly level_ref?: Maybe<Scalars['String']['output']>;
  readonly level_ref_version?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  readonly persistable_polygon?: Maybe<StopsDatabasePersistablePolygon>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly public_code?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly site_ref?: Maybe<Scalars['String']['output']>;
  readonly site_ref_version?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "boarding_position" */
export type StopsDatabaseBoardingPositionBoardingPositionAlternativeNamesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>;
};


/** columns and relationships of "boarding_position" */
export type StopsDatabaseBoardingPositionBoardingPositionAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>;
};


/** columns and relationships of "boarding_position" */
export type StopsDatabaseBoardingPositionBoardingPositionEquipmentPlacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>;
};


/** columns and relationships of "boarding_position" */
export type StopsDatabaseBoardingPositionBoardingPositionEquipmentPlacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>;
};


/** columns and relationships of "boarding_position" */
export type StopsDatabaseBoardingPositionBoardingPositionKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesBoolExp>;
};


/** columns and relationships of "boarding_position" */
export type StopsDatabaseBoardingPositionBoardingPositionKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesBoolExp>;
};

/** aggregated selection of "boarding_position" */
export type StopsDatabaseBoardingPositionAggregate = {
  readonly __typename?: 'stops_database_boarding_position_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseBoardingPositionAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseBoardingPosition>;
};

/** aggregate fields of "boarding_position" */
export type StopsDatabaseBoardingPositionAggregateFields = {
  readonly __typename?: 'stops_database_boarding_position_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseBoardingPositionAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseBoardingPositionMaxFields>;
  readonly min?: Maybe<StopsDatabaseBoardingPositionMinFields>;
  readonly stddev?: Maybe<StopsDatabaseBoardingPositionStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseBoardingPositionStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseBoardingPositionStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseBoardingPositionSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseBoardingPositionVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseBoardingPositionVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseBoardingPositionVarianceFields>;
};


/** aggregate fields of "boarding_position" */
export type StopsDatabaseBoardingPositionAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** columns and relationships of "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNames = {
  readonly __typename?: 'stops_database_boarding_position_alternative_names';
  /** An object relationship */
  readonly alternative_name: StopsDatabaseAlternativeName;
  readonly alternative_names_id: Scalars['bigint']['output'];
  readonly boarding_position_id: Scalars['bigint']['output'];
};

/** aggregated selection of "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesAggregate = {
  readonly __typename?: 'stops_database_boarding_position_alternative_names_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNames>;
};

/** aggregate fields of "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesAggregateFields = {
  readonly __typename?: 'stops_database_boarding_position_alternative_names_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesMaxFields>;
  readonly min?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesVarianceFields>;
};


/** aggregate fields of "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNamesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNamesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseBoardingPositionAlternativeNamesAvgFields = {
  readonly __typename?: 'stops_database_boarding_position_alternative_names_avg_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesAvgOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly boarding_position_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "boarding_position_alternative_names". All fields are combined with a logical 'AND'. */
export type StopsDatabaseBoardingPositionAlternativeNamesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>>;
  readonly alternative_name?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
  readonly alternative_names_id?: InputMaybe<BigintComparisonExp>;
  readonly boarding_position_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "boarding_position_alternative_names" */
export enum StopsDatabaseBoardingPositionAlternativeNamesConstraint {
  /** unique or primary key constraint on columns "alternative_names_id" */
  Uk_250rbh3vi00fvoca1dqy5dnwa = 'uk_250rbh3vi00fvoca1dqy5dnwa'
}

/** input type for incrementing numeric columns in table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesIncInput = {
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly boarding_position_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesInsertInput = {
  readonly alternative_name?: InputMaybe<StopsDatabaseAlternativeNameObjRelInsertInput>;
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly boarding_position_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseBoardingPositionAlternativeNamesMaxFields = {
  readonly __typename?: 'stops_database_boarding_position_alternative_names_max_fields';
  readonly alternative_names_id?: Maybe<Scalars['bigint']['output']>;
  readonly boarding_position_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesMaxOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly boarding_position_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseBoardingPositionAlternativeNamesMinFields = {
  readonly __typename?: 'stops_database_boarding_position_alternative_names_min_fields';
  readonly alternative_names_id?: Maybe<Scalars['bigint']['output']>;
  readonly boarding_position_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesMinOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly boarding_position_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesMutationResponse = {
  readonly __typename?: 'stops_database_boarding_position_alternative_names_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNames>;
};

/** on_conflict condition type for table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesOnConflict = {
  readonly constraint: StopsDatabaseBoardingPositionAlternativeNamesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNamesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>;
};

/** Ordering options when selecting data from "boarding_position_alternative_names". */
export type StopsDatabaseBoardingPositionAlternativeNamesOrderBy = {
  readonly alternative_name?: InputMaybe<StopsDatabaseAlternativeNameOrderBy>;
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly boarding_position_id?: InputMaybe<OrderBy>;
};

/** select columns of table "boarding_position_alternative_names" */
export enum StopsDatabaseBoardingPositionAlternativeNamesSelectColumn {
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
  /** column name */
  BoardingPositionId = 'boarding_position_id'
}

/** input type for updating data in table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesSetInput = {
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly boarding_position_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseBoardingPositionAlternativeNamesStddevFields = {
  readonly __typename?: 'stops_database_boarding_position_alternative_names_stddev_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesStddevOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly boarding_position_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseBoardingPositionAlternativeNamesStddevPopFields = {
  readonly __typename?: 'stops_database_boarding_position_alternative_names_stddev_pop_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesStddevPopOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly boarding_position_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseBoardingPositionAlternativeNamesStddevSampFields = {
  readonly __typename?: 'stops_database_boarding_position_alternative_names_stddev_samp_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesStddevSampOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly boarding_position_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseBoardingPositionAlternativeNamesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseBoardingPositionAlternativeNamesStreamCursorValueInput = {
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly boarding_position_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseBoardingPositionAlternativeNamesSumFields = {
  readonly __typename?: 'stops_database_boarding_position_alternative_names_sum_fields';
  readonly alternative_names_id?: Maybe<Scalars['bigint']['output']>;
  readonly boarding_position_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesSumOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly boarding_position_id?: InputMaybe<OrderBy>;
};

/** update columns of table "boarding_position_alternative_names" */
export enum StopsDatabaseBoardingPositionAlternativeNamesUpdateColumn {
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
  /** column name */
  BoardingPositionId = 'boarding_position_id'
}

export type StopsDatabaseBoardingPositionAlternativeNamesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseBoardingPositionAlternativeNamesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseBoardingPositionAlternativeNamesVarPopFields = {
  readonly __typename?: 'stops_database_boarding_position_alternative_names_var_pop_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesVarPopOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly boarding_position_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseBoardingPositionAlternativeNamesVarSampFields = {
  readonly __typename?: 'stops_database_boarding_position_alternative_names_var_samp_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesVarSampOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly boarding_position_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseBoardingPositionAlternativeNamesVarianceFields = {
  readonly __typename?: 'stops_database_boarding_position_alternative_names_variance_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "boarding_position_alternative_names" */
export type StopsDatabaseBoardingPositionAlternativeNamesVarianceOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly boarding_position_id?: InputMaybe<OrderBy>;
};

/** aggregate avg on columns */
export type StopsDatabaseBoardingPositionAvgFields = {
  readonly __typename?: 'stops_database_boarding_position_avg_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "boarding_position". All fields are combined with a logical 'AND'. */
export type StopsDatabaseBoardingPositionBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseBoardingPositionBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionBoolExp>>;
  readonly accessibility_assessment_id?: InputMaybe<BigintComparisonExp>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<BooleanComparisonExp>;
  readonly boarding_position_alternative_names?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>;
  readonly boarding_position_alternative_names_aggregate?: InputMaybe<BoardingPositionAlternativeNamesAggregateBoolExp>;
  readonly boarding_position_equipment_places?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>;
  readonly boarding_position_equipment_places_aggregate?: InputMaybe<BoardingPositionEquipmentPlacesAggregateBoolExp>;
  readonly boarding_position_key_values?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesBoolExp>;
  readonly boarding_position_key_values_aggregate?: InputMaybe<BoardingPositionKeyValuesAggregateBoolExp>;
  readonly boarding_position_type?: InputMaybe<StringComparisonExp>;
  readonly centroid?: InputMaybe<GeometryComparisonExp>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly covered?: InputMaybe<IntComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly description_lang?: InputMaybe<StringComparisonExp>;
  readonly description_value?: InputMaybe<StringComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
  readonly label_lang?: InputMaybe<StringComparisonExp>;
  readonly label_value?: InputMaybe<StringComparisonExp>;
  readonly level_ref?: InputMaybe<StringComparisonExp>;
  readonly level_ref_version?: InputMaybe<StringComparisonExp>;
  readonly name_lang?: InputMaybe<StringComparisonExp>;
  readonly name_value?: InputMaybe<StringComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  readonly place_equipments_id?: InputMaybe<BigintComparisonExp>;
  readonly polygon_id?: InputMaybe<BigintComparisonExp>;
  readonly private_code_type?: InputMaybe<StringComparisonExp>;
  readonly private_code_value?: InputMaybe<StringComparisonExp>;
  readonly public_code?: InputMaybe<StringComparisonExp>;
  readonly short_name_lang?: InputMaybe<StringComparisonExp>;
  readonly short_name_value?: InputMaybe<StringComparisonExp>;
  readonly site_ref?: InputMaybe<StringComparisonExp>;
  readonly site_ref_version?: InputMaybe<StringComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
};

/** columns and relationships of "boarding_position_check_constraints" */
export type StopsDatabaseBoardingPositionCheckConstraints = {
  readonly __typename?: 'stops_database_boarding_position_check_constraints';
  readonly boarding_position_id: Scalars['bigint']['output'];
  readonly check_constraints_id: Scalars['bigint']['output'];
};

/** aggregated selection of "boarding_position_check_constraints" */
export type StopsDatabaseBoardingPositionCheckConstraintsAggregate = {
  readonly __typename?: 'stops_database_boarding_position_check_constraints_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseBoardingPositionCheckConstraints>;
};

/** aggregate fields of "boarding_position_check_constraints" */
export type StopsDatabaseBoardingPositionCheckConstraintsAggregateFields = {
  readonly __typename?: 'stops_database_boarding_position_check_constraints_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsMaxFields>;
  readonly min?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsMinFields>;
  readonly stddev?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsVarianceFields>;
};


/** aggregate fields of "boarding_position_check_constraints" */
export type StopsDatabaseBoardingPositionCheckConstraintsAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionCheckConstraintsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseBoardingPositionCheckConstraintsAvgFields = {
  readonly __typename?: 'stops_database_boarding_position_check_constraints_avg_fields';
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "boarding_position_check_constraints". All fields are combined with a logical 'AND'. */
export type StopsDatabaseBoardingPositionCheckConstraintsBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionCheckConstraintsBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionCheckConstraintsBoolExp>>;
  readonly boarding_position_id?: InputMaybe<BigintComparisonExp>;
  readonly check_constraints_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "boarding_position_check_constraints" */
export enum StopsDatabaseBoardingPositionCheckConstraintsConstraint {
  /** unique or primary key constraint on columns "check_constraints_id" */
  UkPcbtfcjcauaikel1s4uqjfldp = 'uk_pcbtfcjcauaikel1s4uqjfldp'
}

/** input type for incrementing numeric columns in table "boarding_position_check_constraints" */
export type StopsDatabaseBoardingPositionCheckConstraintsIncInput = {
  readonly boarding_position_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly check_constraints_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "boarding_position_check_constraints" */
export type StopsDatabaseBoardingPositionCheckConstraintsInsertInput = {
  readonly boarding_position_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly check_constraints_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseBoardingPositionCheckConstraintsMaxFields = {
  readonly __typename?: 'stops_database_boarding_position_check_constraints_max_fields';
  readonly boarding_position_id?: Maybe<Scalars['bigint']['output']>;
  readonly check_constraints_id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseBoardingPositionCheckConstraintsMinFields = {
  readonly __typename?: 'stops_database_boarding_position_check_constraints_min_fields';
  readonly boarding_position_id?: Maybe<Scalars['bigint']['output']>;
  readonly check_constraints_id?: Maybe<Scalars['bigint']['output']>;
};

/** response of any mutation on the table "boarding_position_check_constraints" */
export type StopsDatabaseBoardingPositionCheckConstraintsMutationResponse = {
  readonly __typename?: 'stops_database_boarding_position_check_constraints_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseBoardingPositionCheckConstraints>;
};

/** on_conflict condition type for table "boarding_position_check_constraints" */
export type StopsDatabaseBoardingPositionCheckConstraintsOnConflict = {
  readonly constraint: StopsDatabaseBoardingPositionCheckConstraintsConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseBoardingPositionCheckConstraintsUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsBoolExp>;
};

/** Ordering options when selecting data from "boarding_position_check_constraints". */
export type StopsDatabaseBoardingPositionCheckConstraintsOrderBy = {
  readonly boarding_position_id?: InputMaybe<OrderBy>;
  readonly check_constraints_id?: InputMaybe<OrderBy>;
};

/** select columns of table "boarding_position_check_constraints" */
export enum StopsDatabaseBoardingPositionCheckConstraintsSelectColumn {
  /** column name */
  BoardingPositionId = 'boarding_position_id',
  /** column name */
  CheckConstraintsId = 'check_constraints_id'
}

/** input type for updating data in table "boarding_position_check_constraints" */
export type StopsDatabaseBoardingPositionCheckConstraintsSetInput = {
  readonly boarding_position_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly check_constraints_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseBoardingPositionCheckConstraintsStddevFields = {
  readonly __typename?: 'stops_database_boarding_position_check_constraints_stddev_fields';
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseBoardingPositionCheckConstraintsStddevPopFields = {
  readonly __typename?: 'stops_database_boarding_position_check_constraints_stddev_pop_fields';
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseBoardingPositionCheckConstraintsStddevSampFields = {
  readonly __typename?: 'stops_database_boarding_position_check_constraints_stddev_samp_fields';
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "boarding_position_check_constraints" */
export type StopsDatabaseBoardingPositionCheckConstraintsStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseBoardingPositionCheckConstraintsStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseBoardingPositionCheckConstraintsStreamCursorValueInput = {
  readonly boarding_position_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly check_constraints_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseBoardingPositionCheckConstraintsSumFields = {
  readonly __typename?: 'stops_database_boarding_position_check_constraints_sum_fields';
  readonly boarding_position_id?: Maybe<Scalars['bigint']['output']>;
  readonly check_constraints_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "boarding_position_check_constraints" */
export enum StopsDatabaseBoardingPositionCheckConstraintsUpdateColumn {
  /** column name */
  BoardingPositionId = 'boarding_position_id',
  /** column name */
  CheckConstraintsId = 'check_constraints_id'
}

export type StopsDatabaseBoardingPositionCheckConstraintsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseBoardingPositionCheckConstraintsBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseBoardingPositionCheckConstraintsVarPopFields = {
  readonly __typename?: 'stops_database_boarding_position_check_constraints_var_pop_fields';
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseBoardingPositionCheckConstraintsVarSampFields = {
  readonly __typename?: 'stops_database_boarding_position_check_constraints_var_samp_fields';
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseBoardingPositionCheckConstraintsVarianceFields = {
  readonly __typename?: 'stops_database_boarding_position_check_constraints_variance_fields';
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
};

/** unique or primary key constraints on table "boarding_position" */
export enum StopsDatabaseBoardingPositionConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  BoardingPositionNetexIdVersionConstraint = 'boarding_position_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  BoardingPositionPkey = 'boarding_position_pkey'
}

/** columns and relationships of "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlaces = {
  readonly __typename?: 'stops_database_boarding_position_equipment_places';
  readonly boarding_position_id: Scalars['bigint']['output'];
  /** An object relationship */
  readonly equipment_place: StopsDatabaseEquipmentPlace;
  readonly equipment_places_id: Scalars['bigint']['output'];
};

/** aggregated selection of "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesAggregate = {
  readonly __typename?: 'stops_database_boarding_position_equipment_places_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlaces>;
};

/** aggregate fields of "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesAggregateFields = {
  readonly __typename?: 'stops_database_boarding_position_equipment_places_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesMaxFields>;
  readonly min?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesVarianceFields>;
};


/** aggregate fields of "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlacesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlacesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseBoardingPositionEquipmentPlacesAvgFields = {
  readonly __typename?: 'stops_database_boarding_position_equipment_places_avg_fields';
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesAvgOrderBy = {
  readonly boarding_position_id?: InputMaybe<OrderBy>;
  readonly equipment_places_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "boarding_position_equipment_places". All fields are combined with a logical 'AND'. */
export type StopsDatabaseBoardingPositionEquipmentPlacesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>>;
  readonly boarding_position_id?: InputMaybe<BigintComparisonExp>;
  readonly equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceBoolExp>;
  readonly equipment_places_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "boarding_position_equipment_places" */
export enum StopsDatabaseBoardingPositionEquipmentPlacesConstraint {
  /** unique or primary key constraint on columns "equipment_places_id" */
  UkGq09mcv5i3kkrwltbnj3120j5 = 'uk_gq09mcv5i3kkrwltbnj3120j5'
}

/** input type for incrementing numeric columns in table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesIncInput = {
  readonly boarding_position_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly equipment_places_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesInsertInput = {
  readonly boarding_position_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceObjRelInsertInput>;
  readonly equipment_places_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseBoardingPositionEquipmentPlacesMaxFields = {
  readonly __typename?: 'stops_database_boarding_position_equipment_places_max_fields';
  readonly boarding_position_id?: Maybe<Scalars['bigint']['output']>;
  readonly equipment_places_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesMaxOrderBy = {
  readonly boarding_position_id?: InputMaybe<OrderBy>;
  readonly equipment_places_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseBoardingPositionEquipmentPlacesMinFields = {
  readonly __typename?: 'stops_database_boarding_position_equipment_places_min_fields';
  readonly boarding_position_id?: Maybe<Scalars['bigint']['output']>;
  readonly equipment_places_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesMinOrderBy = {
  readonly boarding_position_id?: InputMaybe<OrderBy>;
  readonly equipment_places_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesMutationResponse = {
  readonly __typename?: 'stops_database_boarding_position_equipment_places_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlaces>;
};

/** on_conflict condition type for table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesOnConflict = {
  readonly constraint: StopsDatabaseBoardingPositionEquipmentPlacesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlacesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>;
};

/** Ordering options when selecting data from "boarding_position_equipment_places". */
export type StopsDatabaseBoardingPositionEquipmentPlacesOrderBy = {
  readonly boarding_position_id?: InputMaybe<OrderBy>;
  readonly equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceOrderBy>;
  readonly equipment_places_id?: InputMaybe<OrderBy>;
};

/** select columns of table "boarding_position_equipment_places" */
export enum StopsDatabaseBoardingPositionEquipmentPlacesSelectColumn {
  /** column name */
  BoardingPositionId = 'boarding_position_id',
  /** column name */
  EquipmentPlacesId = 'equipment_places_id'
}

/** input type for updating data in table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesSetInput = {
  readonly boarding_position_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly equipment_places_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseBoardingPositionEquipmentPlacesStddevFields = {
  readonly __typename?: 'stops_database_boarding_position_equipment_places_stddev_fields';
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesStddevOrderBy = {
  readonly boarding_position_id?: InputMaybe<OrderBy>;
  readonly equipment_places_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseBoardingPositionEquipmentPlacesStddevPopFields = {
  readonly __typename?: 'stops_database_boarding_position_equipment_places_stddev_pop_fields';
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesStddevPopOrderBy = {
  readonly boarding_position_id?: InputMaybe<OrderBy>;
  readonly equipment_places_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseBoardingPositionEquipmentPlacesStddevSampFields = {
  readonly __typename?: 'stops_database_boarding_position_equipment_places_stddev_samp_fields';
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesStddevSampOrderBy = {
  readonly boarding_position_id?: InputMaybe<OrderBy>;
  readonly equipment_places_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseBoardingPositionEquipmentPlacesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseBoardingPositionEquipmentPlacesStreamCursorValueInput = {
  readonly boarding_position_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly equipment_places_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseBoardingPositionEquipmentPlacesSumFields = {
  readonly __typename?: 'stops_database_boarding_position_equipment_places_sum_fields';
  readonly boarding_position_id?: Maybe<Scalars['bigint']['output']>;
  readonly equipment_places_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesSumOrderBy = {
  readonly boarding_position_id?: InputMaybe<OrderBy>;
  readonly equipment_places_id?: InputMaybe<OrderBy>;
};

/** update columns of table "boarding_position_equipment_places" */
export enum StopsDatabaseBoardingPositionEquipmentPlacesUpdateColumn {
  /** column name */
  BoardingPositionId = 'boarding_position_id',
  /** column name */
  EquipmentPlacesId = 'equipment_places_id'
}

export type StopsDatabaseBoardingPositionEquipmentPlacesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseBoardingPositionEquipmentPlacesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseBoardingPositionEquipmentPlacesVarPopFields = {
  readonly __typename?: 'stops_database_boarding_position_equipment_places_var_pop_fields';
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesVarPopOrderBy = {
  readonly boarding_position_id?: InputMaybe<OrderBy>;
  readonly equipment_places_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseBoardingPositionEquipmentPlacesVarSampFields = {
  readonly __typename?: 'stops_database_boarding_position_equipment_places_var_samp_fields';
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesVarSampOrderBy = {
  readonly boarding_position_id?: InputMaybe<OrderBy>;
  readonly equipment_places_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseBoardingPositionEquipmentPlacesVarianceFields = {
  readonly __typename?: 'stops_database_boarding_position_equipment_places_variance_fields';
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "boarding_position_equipment_places" */
export type StopsDatabaseBoardingPositionEquipmentPlacesVarianceOrderBy = {
  readonly boarding_position_id?: InputMaybe<OrderBy>;
  readonly equipment_places_id?: InputMaybe<OrderBy>;
};

/** input type for incrementing numeric columns in table "boarding_position" */
export type StopsDatabaseBoardingPositionIncInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "boarding_position" */
export type StopsDatabaseBoardingPositionInsertInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  readonly boarding_position_alternative_names?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesArrRelInsertInput>;
  readonly boarding_position_equipment_places?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesArrRelInsertInput>;
  readonly boarding_position_key_values?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesArrRelInsertInput>;
  readonly boarding_position_type?: InputMaybe<Scalars['String']['input']>;
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureObjRelInsertInput>;
  readonly label_lang?: InputMaybe<Scalars['String']['input']>;
  readonly label_value?: InputMaybe<Scalars['String']['input']>;
  readonly level_ref?: InputMaybe<Scalars['String']['input']>;
  readonly level_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonObjRelInsertInput>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly public_code?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValues = {
  readonly __typename?: 'stops_database_boarding_position_key_values';
  readonly boarding_position_id: Scalars['bigint']['output'];
  readonly key_values_id: Scalars['bigint']['output'];
  readonly key_values_key: Scalars['String']['output'];
  /** An object relationship */
  readonly value: StopsDatabaseValue;
};

/** aggregated selection of "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesAggregate = {
  readonly __typename?: 'stops_database_boarding_position_key_values_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseBoardingPositionKeyValuesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseBoardingPositionKeyValues>;
};

/** aggregate fields of "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesAggregateFields = {
  readonly __typename?: 'stops_database_boarding_position_key_values_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseBoardingPositionKeyValuesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseBoardingPositionKeyValuesMaxFields>;
  readonly min?: Maybe<StopsDatabaseBoardingPositionKeyValuesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseBoardingPositionKeyValuesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseBoardingPositionKeyValuesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseBoardingPositionKeyValuesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseBoardingPositionKeyValuesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseBoardingPositionKeyValuesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseBoardingPositionKeyValuesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseBoardingPositionKeyValuesVarianceFields>;
};


/** aggregate fields of "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseBoardingPositionKeyValuesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseBoardingPositionKeyValuesAvgFields = {
  readonly __typename?: 'stops_database_boarding_position_key_values_avg_fields';
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesAvgOrderBy = {
  readonly boarding_position_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "boarding_position_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseBoardingPositionKeyValuesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionKeyValuesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionKeyValuesBoolExp>>;
  readonly boarding_position_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_key?: InputMaybe<StringComparisonExp>;
  readonly value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "boarding_position_key_values" */
export enum StopsDatabaseBoardingPositionKeyValuesConstraint {
  /** unique or primary key constraint on columns "key_values_key", "boarding_position_id" */
  BoardingPositionKeyValuesPkey = 'boarding_position_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkJilhh4jbyloqka3r1xpv88lpb = 'uk_jilhh4jbyloqka3r1xpv88lpb'
}

/** input type for incrementing numeric columns in table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesIncInput = {
  readonly boarding_position_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesInsertInput = {
  readonly boarding_position_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseBoardingPositionKeyValuesMaxFields = {
  readonly __typename?: 'stops_database_boarding_position_key_values_max_fields';
  readonly boarding_position_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesMaxOrderBy = {
  readonly boarding_position_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseBoardingPositionKeyValuesMinFields = {
  readonly __typename?: 'stops_database_boarding_position_key_values_min_fields';
  readonly boarding_position_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesMinOrderBy = {
  readonly boarding_position_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesMutationResponse = {
  readonly __typename?: 'stops_database_boarding_position_key_values_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseBoardingPositionKeyValues>;
};

/** on_conflict condition type for table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesOnConflict = {
  readonly constraint: StopsDatabaseBoardingPositionKeyValuesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseBoardingPositionKeyValuesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "boarding_position_key_values". */
export type StopsDatabaseBoardingPositionKeyValuesOrderBy = {
  readonly boarding_position_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: boarding_position_key_values */
export type StopsDatabaseBoardingPositionKeyValuesPkColumnsInput = {
  readonly boarding_position_id: Scalars['bigint']['input'];
  readonly key_values_key: Scalars['String']['input'];
};

/** select columns of table "boarding_position_key_values" */
export enum StopsDatabaseBoardingPositionKeyValuesSelectColumn {
  /** column name */
  BoardingPositionId = 'boarding_position_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key'
}

/** input type for updating data in table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesSetInput = {
  readonly boarding_position_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseBoardingPositionKeyValuesStddevFields = {
  readonly __typename?: 'stops_database_boarding_position_key_values_stddev_fields';
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesStddevOrderBy = {
  readonly boarding_position_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseBoardingPositionKeyValuesStddevPopFields = {
  readonly __typename?: 'stops_database_boarding_position_key_values_stddev_pop_fields';
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesStddevPopOrderBy = {
  readonly boarding_position_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseBoardingPositionKeyValuesStddevSampFields = {
  readonly __typename?: 'stops_database_boarding_position_key_values_stddev_samp_fields';
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesStddevSampOrderBy = {
  readonly boarding_position_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseBoardingPositionKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseBoardingPositionKeyValuesStreamCursorValueInput = {
  readonly boarding_position_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseBoardingPositionKeyValuesSumFields = {
  readonly __typename?: 'stops_database_boarding_position_key_values_sum_fields';
  readonly boarding_position_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesSumOrderBy = {
  readonly boarding_position_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** update columns of table "boarding_position_key_values" */
export enum StopsDatabaseBoardingPositionKeyValuesUpdateColumn {
  /** column name */
  BoardingPositionId = 'boarding_position_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key'
}

export type StopsDatabaseBoardingPositionKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseBoardingPositionKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseBoardingPositionKeyValuesVarPopFields = {
  readonly __typename?: 'stops_database_boarding_position_key_values_var_pop_fields';
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesVarPopOrderBy = {
  readonly boarding_position_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseBoardingPositionKeyValuesVarSampFields = {
  readonly __typename?: 'stops_database_boarding_position_key_values_var_samp_fields';
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesVarSampOrderBy = {
  readonly boarding_position_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseBoardingPositionKeyValuesVarianceFields = {
  readonly __typename?: 'stops_database_boarding_position_key_values_variance_fields';
  readonly boarding_position_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "boarding_position_key_values" */
export type StopsDatabaseBoardingPositionKeyValuesVarianceOrderBy = {
  readonly boarding_position_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseBoardingPositionMaxFields = {
  readonly __typename?: 'stops_database_boarding_position_max_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly boarding_position_type?: Maybe<Scalars['String']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly label_lang?: Maybe<Scalars['String']['output']>;
  readonly label_value?: Maybe<Scalars['String']['output']>;
  readonly level_ref?: Maybe<Scalars['String']['output']>;
  readonly level_ref_version?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly public_code?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly site_ref?: Maybe<Scalars['String']['output']>;
  readonly site_ref_version?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseBoardingPositionMinFields = {
  readonly __typename?: 'stops_database_boarding_position_min_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly boarding_position_type?: Maybe<Scalars['String']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly label_lang?: Maybe<Scalars['String']['output']>;
  readonly label_value?: Maybe<Scalars['String']['output']>;
  readonly level_ref?: Maybe<Scalars['String']['output']>;
  readonly level_ref_version?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly public_code?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly site_ref?: Maybe<Scalars['String']['output']>;
  readonly site_ref_version?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "boarding_position" */
export type StopsDatabaseBoardingPositionMutationResponse = {
  readonly __typename?: 'stops_database_boarding_position_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseBoardingPosition>;
};

/** input type for inserting object relation for remote table "boarding_position" */
export type StopsDatabaseBoardingPositionObjRelInsertInput = {
  readonly data: StopsDatabaseBoardingPositionInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseBoardingPositionOnConflict>;
};

/** on_conflict condition type for table "boarding_position" */
export type StopsDatabaseBoardingPositionOnConflict = {
  readonly constraint: StopsDatabaseBoardingPositionConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseBoardingPositionUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseBoardingPositionBoolExp>;
};

/** Ordering options when selecting data from "boarding_position". */
export type StopsDatabaseBoardingPositionOrderBy = {
  readonly accessibility_assessment_id?: InputMaybe<OrderBy>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<OrderBy>;
  readonly boarding_position_alternative_names_aggregate?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesAggregateOrderBy>;
  readonly boarding_position_equipment_places_aggregate?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesAggregateOrderBy>;
  readonly boarding_position_key_values_aggregate?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesAggregateOrderBy>;
  readonly boarding_position_type?: InputMaybe<OrderBy>;
  readonly centroid?: InputMaybe<OrderBy>;
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly covered?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly description_lang?: InputMaybe<OrderBy>;
  readonly description_value?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureOrderBy>;
  readonly label_lang?: InputMaybe<OrderBy>;
  readonly label_value?: InputMaybe<OrderBy>;
  readonly level_ref?: InputMaybe<OrderBy>;
  readonly level_ref_version?: InputMaybe<OrderBy>;
  readonly name_lang?: InputMaybe<OrderBy>;
  readonly name_value?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonOrderBy>;
  readonly place_equipments_id?: InputMaybe<OrderBy>;
  readonly polygon_id?: InputMaybe<OrderBy>;
  readonly private_code_type?: InputMaybe<OrderBy>;
  readonly private_code_value?: InputMaybe<OrderBy>;
  readonly public_code?: InputMaybe<OrderBy>;
  readonly short_name_lang?: InputMaybe<OrderBy>;
  readonly short_name_value?: InputMaybe<OrderBy>;
  readonly site_ref?: InputMaybe<OrderBy>;
  readonly site_ref_version?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: boarding_position */
export type StopsDatabaseBoardingPositionPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "boarding_position" */
export enum StopsDatabaseBoardingPositionSelectColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  BoardingPositionType = 'boarding_position_type',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  LabelLang = 'label_lang',
  /** column name */
  LabelValue = 'label_value',
  /** column name */
  LevelRef = 'level_ref',
  /** column name */
  LevelRefVersion = 'level_ref_version',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  PublicCode = 'public_code',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  SiteRef = 'site_ref',
  /** column name */
  SiteRefVersion = 'site_ref_version',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

/** input type for updating data in table "boarding_position" */
export type StopsDatabaseBoardingPositionSetInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  readonly boarding_position_type?: InputMaybe<Scalars['String']['input']>;
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly label_lang?: InputMaybe<Scalars['String']['input']>;
  readonly label_value?: InputMaybe<Scalars['String']['input']>;
  readonly level_ref?: InputMaybe<Scalars['String']['input']>;
  readonly level_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly public_code?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseBoardingPositionStddevFields = {
  readonly __typename?: 'stops_database_boarding_position_stddev_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseBoardingPositionStddevPopFields = {
  readonly __typename?: 'stops_database_boarding_position_stddev_pop_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseBoardingPositionStddevSampFields = {
  readonly __typename?: 'stops_database_boarding_position_stddev_samp_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "boarding_position" */
export type StopsDatabaseBoardingPositionStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseBoardingPositionStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseBoardingPositionStreamCursorValueInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  readonly boarding_position_type?: InputMaybe<Scalars['String']['input']>;
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly label_lang?: InputMaybe<Scalars['String']['input']>;
  readonly label_value?: InputMaybe<Scalars['String']['input']>;
  readonly level_ref?: InputMaybe<Scalars['String']['input']>;
  readonly level_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly public_code?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseBoardingPositionSumFields = {
  readonly __typename?: 'stops_database_boarding_position_sum_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "boarding_position" */
export enum StopsDatabaseBoardingPositionUpdateColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  BoardingPositionType = 'boarding_position_type',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  LabelLang = 'label_lang',
  /** column name */
  LabelValue = 'label_value',
  /** column name */
  LevelRef = 'level_ref',
  /** column name */
  LevelRefVersion = 'level_ref_version',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  PublicCode = 'public_code',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  SiteRef = 'site_ref',
  /** column name */
  SiteRefVersion = 'site_ref_version',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

export type StopsDatabaseBoardingPositionUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseBoardingPositionIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseBoardingPositionSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseBoardingPositionBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseBoardingPositionVarPopFields = {
  readonly __typename?: 'stops_database_boarding_position_var_pop_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseBoardingPositionVarSampFields = {
  readonly __typename?: 'stops_database_boarding_position_var_samp_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseBoardingPositionVarianceFields = {
  readonly __typename?: 'stops_database_boarding_position_variance_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "check_constraint" */
export type StopsDatabaseCheckConstraint = {
  readonly __typename?: 'stops_database_check_constraint';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_id?: Maybe<Scalars['bigint']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id: Scalars['bigint']['output'];
  readonly name_id?: Maybe<Scalars['bigint']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "check_constraint" */
export type StopsDatabaseCheckConstraintAggregate = {
  readonly __typename?: 'stops_database_check_constraint_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseCheckConstraintAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseCheckConstraint>;
};

/** aggregate fields of "check_constraint" */
export type StopsDatabaseCheckConstraintAggregateFields = {
  readonly __typename?: 'stops_database_check_constraint_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseCheckConstraintAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseCheckConstraintMaxFields>;
  readonly min?: Maybe<StopsDatabaseCheckConstraintMinFields>;
  readonly stddev?: Maybe<StopsDatabaseCheckConstraintStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseCheckConstraintStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseCheckConstraintStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseCheckConstraintSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseCheckConstraintVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseCheckConstraintVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseCheckConstraintVarianceFields>;
};


/** aggregate fields of "check_constraint" */
export type StopsDatabaseCheckConstraintAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseCheckConstraintSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseCheckConstraintAvgFields = {
  readonly __typename?: 'stops_database_check_constraint_avg_fields';
  readonly description_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly name_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "check_constraint". All fields are combined with a logical 'AND'. */
export type StopsDatabaseCheckConstraintBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseCheckConstraintBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseCheckConstraintBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseCheckConstraintBoolExp>>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly description_id?: InputMaybe<BigintComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly name_id?: InputMaybe<BigintComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "check_constraint" */
export enum StopsDatabaseCheckConstraintConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  CheckConstraintNetexIdVersionConstraint = 'check_constraint_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  CheckConstraintPkey = 'check_constraint_pkey'
}

/** input type for incrementing numeric columns in table "check_constraint" */
export type StopsDatabaseCheckConstraintIncInput = {
  readonly description_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "check_constraint" */
export type StopsDatabaseCheckConstraintInsertInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "check_constraint_key_values" */
export type StopsDatabaseCheckConstraintKeyValues = {
  readonly __typename?: 'stops_database_check_constraint_key_values';
  readonly check_constraint_id: Scalars['bigint']['output'];
  readonly key_values_id: Scalars['bigint']['output'];
  readonly key_values_key: Scalars['String']['output'];
};

/** aggregated selection of "check_constraint_key_values" */
export type StopsDatabaseCheckConstraintKeyValuesAggregate = {
  readonly __typename?: 'stops_database_check_constraint_key_values_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseCheckConstraintKeyValuesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseCheckConstraintKeyValues>;
};

/** aggregate fields of "check_constraint_key_values" */
export type StopsDatabaseCheckConstraintKeyValuesAggregateFields = {
  readonly __typename?: 'stops_database_check_constraint_key_values_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseCheckConstraintKeyValuesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseCheckConstraintKeyValuesMaxFields>;
  readonly min?: Maybe<StopsDatabaseCheckConstraintKeyValuesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseCheckConstraintKeyValuesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseCheckConstraintKeyValuesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseCheckConstraintKeyValuesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseCheckConstraintKeyValuesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseCheckConstraintKeyValuesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseCheckConstraintKeyValuesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseCheckConstraintKeyValuesVarianceFields>;
};


/** aggregate fields of "check_constraint_key_values" */
export type StopsDatabaseCheckConstraintKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseCheckConstraintKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseCheckConstraintKeyValuesAvgFields = {
  readonly __typename?: 'stops_database_check_constraint_key_values_avg_fields';
  readonly check_constraint_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "check_constraint_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseCheckConstraintKeyValuesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseCheckConstraintKeyValuesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseCheckConstraintKeyValuesBoolExp>>;
  readonly check_constraint_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_key?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "check_constraint_key_values" */
export enum StopsDatabaseCheckConstraintKeyValuesConstraint {
  /** unique or primary key constraint on columns "key_values_key", "check_constraint_id" */
  CheckConstraintKeyValuesPkey = 'check_constraint_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkGsegfx5ipotsd45aqbmq7kux0 = 'uk_gsegfx5ipotsd45aqbmq7kux0'
}

/** input type for incrementing numeric columns in table "check_constraint_key_values" */
export type StopsDatabaseCheckConstraintKeyValuesIncInput = {
  readonly check_constraint_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "check_constraint_key_values" */
export type StopsDatabaseCheckConstraintKeyValuesInsertInput = {
  readonly check_constraint_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseCheckConstraintKeyValuesMaxFields = {
  readonly __typename?: 'stops_database_check_constraint_key_values_max_fields';
  readonly check_constraint_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseCheckConstraintKeyValuesMinFields = {
  readonly __typename?: 'stops_database_check_constraint_key_values_min_fields';
  readonly check_constraint_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "check_constraint_key_values" */
export type StopsDatabaseCheckConstraintKeyValuesMutationResponse = {
  readonly __typename?: 'stops_database_check_constraint_key_values_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseCheckConstraintKeyValues>;
};

/** on_conflict condition type for table "check_constraint_key_values" */
export type StopsDatabaseCheckConstraintKeyValuesOnConflict = {
  readonly constraint: StopsDatabaseCheckConstraintKeyValuesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseCheckConstraintKeyValuesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "check_constraint_key_values". */
export type StopsDatabaseCheckConstraintKeyValuesOrderBy = {
  readonly check_constraint_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: check_constraint_key_values */
export type StopsDatabaseCheckConstraintKeyValuesPkColumnsInput = {
  readonly check_constraint_id: Scalars['bigint']['input'];
  readonly key_values_key: Scalars['String']['input'];
};

/** select columns of table "check_constraint_key_values" */
export enum StopsDatabaseCheckConstraintKeyValuesSelectColumn {
  /** column name */
  CheckConstraintId = 'check_constraint_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key'
}

/** input type for updating data in table "check_constraint_key_values" */
export type StopsDatabaseCheckConstraintKeyValuesSetInput = {
  readonly check_constraint_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseCheckConstraintKeyValuesStddevFields = {
  readonly __typename?: 'stops_database_check_constraint_key_values_stddev_fields';
  readonly check_constraint_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseCheckConstraintKeyValuesStddevPopFields = {
  readonly __typename?: 'stops_database_check_constraint_key_values_stddev_pop_fields';
  readonly check_constraint_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseCheckConstraintKeyValuesStddevSampFields = {
  readonly __typename?: 'stops_database_check_constraint_key_values_stddev_samp_fields';
  readonly check_constraint_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "check_constraint_key_values" */
export type StopsDatabaseCheckConstraintKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseCheckConstraintKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseCheckConstraintKeyValuesStreamCursorValueInput = {
  readonly check_constraint_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseCheckConstraintKeyValuesSumFields = {
  readonly __typename?: 'stops_database_check_constraint_key_values_sum_fields';
  readonly check_constraint_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "check_constraint_key_values" */
export enum StopsDatabaseCheckConstraintKeyValuesUpdateColumn {
  /** column name */
  CheckConstraintId = 'check_constraint_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key'
}

export type StopsDatabaseCheckConstraintKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseCheckConstraintKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseCheckConstraintKeyValuesVarPopFields = {
  readonly __typename?: 'stops_database_check_constraint_key_values_var_pop_fields';
  readonly check_constraint_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseCheckConstraintKeyValuesVarSampFields = {
  readonly __typename?: 'stops_database_check_constraint_key_values_var_samp_fields';
  readonly check_constraint_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseCheckConstraintKeyValuesVarianceFields = {
  readonly __typename?: 'stops_database_check_constraint_key_values_variance_fields';
  readonly check_constraint_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate max on columns */
export type StopsDatabaseCheckConstraintMaxFields = {
  readonly __typename?: 'stops_database_check_constraint_max_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_id?: Maybe<Scalars['bigint']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly name_id?: Maybe<Scalars['bigint']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseCheckConstraintMinFields = {
  readonly __typename?: 'stops_database_check_constraint_min_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_id?: Maybe<Scalars['bigint']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly name_id?: Maybe<Scalars['bigint']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "check_constraint" */
export type StopsDatabaseCheckConstraintMutationResponse = {
  readonly __typename?: 'stops_database_check_constraint_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseCheckConstraint>;
};

/** on_conflict condition type for table "check_constraint" */
export type StopsDatabaseCheckConstraintOnConflict = {
  readonly constraint: StopsDatabaseCheckConstraintConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseCheckConstraintUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseCheckConstraintBoolExp>;
};

/** Ordering options when selecting data from "check_constraint". */
export type StopsDatabaseCheckConstraintOrderBy = {
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly description_id?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly name_id?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: check_constraint */
export type StopsDatabaseCheckConstraintPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "check_constraint" */
export enum StopsDatabaseCheckConstraintSelectColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionId = 'description_id',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameId = 'name_id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

/** input type for updating data in table "check_constraint" */
export type StopsDatabaseCheckConstraintSetInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseCheckConstraintStddevFields = {
  readonly __typename?: 'stops_database_check_constraint_stddev_fields';
  readonly description_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly name_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseCheckConstraintStddevPopFields = {
  readonly __typename?: 'stops_database_check_constraint_stddev_pop_fields';
  readonly description_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly name_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseCheckConstraintStddevSampFields = {
  readonly __typename?: 'stops_database_check_constraint_stddev_samp_fields';
  readonly description_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly name_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "check_constraint" */
export type StopsDatabaseCheckConstraintStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseCheckConstraintStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseCheckConstraintStreamCursorValueInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseCheckConstraintSumFields = {
  readonly __typename?: 'stops_database_check_constraint_sum_fields';
  readonly description_id?: Maybe<Scalars['bigint']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly name_id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "check_constraint" */
export enum StopsDatabaseCheckConstraintUpdateColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionId = 'description_id',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameId = 'name_id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

export type StopsDatabaseCheckConstraintUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseCheckConstraintIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseCheckConstraintSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseCheckConstraintBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseCheckConstraintVarPopFields = {
  readonly __typename?: 'stops_database_check_constraint_var_pop_fields';
  readonly description_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly name_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseCheckConstraintVarSampFields = {
  readonly __typename?: 'stops_database_check_constraint_var_samp_fields';
  readonly description_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly name_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseCheckConstraintVarianceFields = {
  readonly __typename?: 'stops_database_check_constraint_variance_fields';
  readonly description_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly name_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "contact" */
export type StopsDatabaseContact = {
  readonly __typename?: 'stops_database_contact';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly contact_person?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly email?: Maybe<Scalars['String']['output']>;
  readonly fax?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly further_details?: Maybe<Scalars['String']['output']>;
  readonly id: Scalars['bigint']['output'];
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly phone?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly url?: Maybe<Scalars['String']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "contact" */
export type StopsDatabaseContactAggregate = {
  readonly __typename?: 'stops_database_contact_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseContactAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseContact>;
};

/** aggregate fields of "contact" */
export type StopsDatabaseContactAggregateFields = {
  readonly __typename?: 'stops_database_contact_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseContactAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseContactMaxFields>;
  readonly min?: Maybe<StopsDatabaseContactMinFields>;
  readonly stddev?: Maybe<StopsDatabaseContactStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseContactStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseContactStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseContactSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseContactVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseContactVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseContactVarianceFields>;
};


/** aggregate fields of "contact" */
export type StopsDatabaseContactAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseContactSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseContactAvgFields = {
  readonly __typename?: 'stops_database_contact_avg_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "contact". All fields are combined with a logical 'AND'. */
export type StopsDatabaseContactBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseContactBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseContactBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseContactBoolExp>>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly contact_person?: InputMaybe<StringComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly email?: InputMaybe<StringComparisonExp>;
  readonly fax?: InputMaybe<StringComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly further_details?: InputMaybe<StringComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly phone?: InputMaybe<StringComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly url?: InputMaybe<StringComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "contact" */
export enum StopsDatabaseContactConstraint {
  /** unique or primary key constraint on columns "id" */
  ContactPkey = 'contact_pkey'
}

/** input type for incrementing numeric columns in table "contact" */
export type StopsDatabaseContactIncInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "contact" */
export type StopsDatabaseContactInsertInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly contact_person?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly email?: InputMaybe<Scalars['String']['input']>;
  readonly fax?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly further_details?: InputMaybe<Scalars['String']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly phone?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly url?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseContactMaxFields = {
  readonly __typename?: 'stops_database_contact_max_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly contact_person?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly email?: Maybe<Scalars['String']['output']>;
  readonly fax?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly further_details?: Maybe<Scalars['String']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly phone?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly url?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseContactMinFields = {
  readonly __typename?: 'stops_database_contact_min_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly contact_person?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly email?: Maybe<Scalars['String']['output']>;
  readonly fax?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly further_details?: Maybe<Scalars['String']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly phone?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly url?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "contact" */
export type StopsDatabaseContactMutationResponse = {
  readonly __typename?: 'stops_database_contact_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseContact>;
};

/** on_conflict condition type for table "contact" */
export type StopsDatabaseContactOnConflict = {
  readonly constraint: StopsDatabaseContactConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseContactUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseContactBoolExp>;
};

/** Ordering options when selecting data from "contact". */
export type StopsDatabaseContactOrderBy = {
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly contact_person?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly email?: InputMaybe<OrderBy>;
  readonly fax?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly further_details?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly phone?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly url?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: contact */
export type StopsDatabaseContactPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "contact" */
export enum StopsDatabaseContactSelectColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  ContactPerson = 'contact_person',
  /** column name */
  Created = 'created',
  /** column name */
  Email = 'email',
  /** column name */
  Fax = 'fax',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  FurtherDetails = 'further_details',
  /** column name */
  Id = 'id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  Phone = 'phone',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Url = 'url',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

/** input type for updating data in table "contact" */
export type StopsDatabaseContactSetInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly contact_person?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly email?: InputMaybe<Scalars['String']['input']>;
  readonly fax?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly further_details?: InputMaybe<Scalars['String']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly phone?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly url?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseContactStddevFields = {
  readonly __typename?: 'stops_database_contact_stddev_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseContactStddevPopFields = {
  readonly __typename?: 'stops_database_contact_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseContactStddevSampFields = {
  readonly __typename?: 'stops_database_contact_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "contact" */
export type StopsDatabaseContactStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseContactStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseContactStreamCursorValueInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly contact_person?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly email?: InputMaybe<Scalars['String']['input']>;
  readonly fax?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly further_details?: InputMaybe<Scalars['String']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly phone?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly url?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseContactSumFields = {
  readonly __typename?: 'stops_database_contact_sum_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "contact" */
export enum StopsDatabaseContactUpdateColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  ContactPerson = 'contact_person',
  /** column name */
  Created = 'created',
  /** column name */
  Email = 'email',
  /** column name */
  Fax = 'fax',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  FurtherDetails = 'further_details',
  /** column name */
  Id = 'id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  Phone = 'phone',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Url = 'url',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

export type StopsDatabaseContactUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseContactIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseContactSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseContactBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseContactVarPopFields = {
  readonly __typename?: 'stops_database_contact_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseContactVarSampFields = {
  readonly __typename?: 'stops_database_contact_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseContactVarianceFields = {
  readonly __typename?: 'stops_database_contact_variance_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** ordering argument of a cursor */
export enum StopsDatabaseCursorOrdering {
  /** ascending ordering of the cursor */
  Asc = 'ASC',
  /** descending ordering of the cursor */
  Desc = 'DESC'
}

/** columns and relationships of "destination_display_view" */
export type StopsDatabaseDestinationDisplayView = {
  readonly __typename?: 'stops_database_destination_display_view';
  readonly branding_ref?: Maybe<Scalars['bytea']['output']>;
  readonly id: Scalars['bigint']['output'];
  readonly name_id?: Maybe<Scalars['bigint']['output']>;
  readonly public_code?: Maybe<Scalars['String']['output']>;
  readonly short_code?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "destination_display_view" */
export type StopsDatabaseDestinationDisplayViewAggregate = {
  readonly __typename?: 'stops_database_destination_display_view_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseDestinationDisplayViewAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseDestinationDisplayView>;
};

/** aggregate fields of "destination_display_view" */
export type StopsDatabaseDestinationDisplayViewAggregateFields = {
  readonly __typename?: 'stops_database_destination_display_view_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseDestinationDisplayViewAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseDestinationDisplayViewMaxFields>;
  readonly min?: Maybe<StopsDatabaseDestinationDisplayViewMinFields>;
  readonly stddev?: Maybe<StopsDatabaseDestinationDisplayViewStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseDestinationDisplayViewStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseDestinationDisplayViewStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseDestinationDisplayViewSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseDestinationDisplayViewVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseDestinationDisplayViewVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseDestinationDisplayViewVarianceFields>;
};


/** aggregate fields of "destination_display_view" */
export type StopsDatabaseDestinationDisplayViewAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseDestinationDisplayViewSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseDestinationDisplayViewAvgFields = {
  readonly __typename?: 'stops_database_destination_display_view_avg_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly name_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "destination_display_view". All fields are combined with a logical 'AND'. */
export type StopsDatabaseDestinationDisplayViewBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseDestinationDisplayViewBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseDestinationDisplayViewBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseDestinationDisplayViewBoolExp>>;
  readonly branding_ref?: InputMaybe<ByteaComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly name_id?: InputMaybe<BigintComparisonExp>;
  readonly public_code?: InputMaybe<StringComparisonExp>;
  readonly short_code?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "destination_display_view" */
export enum StopsDatabaseDestinationDisplayViewConstraint {
  /** unique or primary key constraint on columns "id" */
  DestinationDisplayViewPkey = 'destination_display_view_pkey'
}

/** input type for incrementing numeric columns in table "destination_display_view" */
export type StopsDatabaseDestinationDisplayViewIncInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "destination_display_view" */
export type StopsDatabaseDestinationDisplayViewInsertInput = {
  readonly branding_ref?: InputMaybe<Scalars['bytea']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly public_code?: InputMaybe<Scalars['String']['input']>;
  readonly short_code?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseDestinationDisplayViewMaxFields = {
  readonly __typename?: 'stops_database_destination_display_view_max_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly name_id?: Maybe<Scalars['bigint']['output']>;
  readonly public_code?: Maybe<Scalars['String']['output']>;
  readonly short_code?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseDestinationDisplayViewMinFields = {
  readonly __typename?: 'stops_database_destination_display_view_min_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly name_id?: Maybe<Scalars['bigint']['output']>;
  readonly public_code?: Maybe<Scalars['String']['output']>;
  readonly short_code?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "destination_display_view" */
export type StopsDatabaseDestinationDisplayViewMutationResponse = {
  readonly __typename?: 'stops_database_destination_display_view_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseDestinationDisplayView>;
};

/** on_conflict condition type for table "destination_display_view" */
export type StopsDatabaseDestinationDisplayViewOnConflict = {
  readonly constraint: StopsDatabaseDestinationDisplayViewConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseDestinationDisplayViewUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseDestinationDisplayViewBoolExp>;
};

/** Ordering options when selecting data from "destination_display_view". */
export type StopsDatabaseDestinationDisplayViewOrderBy = {
  readonly branding_ref?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly name_id?: InputMaybe<OrderBy>;
  readonly public_code?: InputMaybe<OrderBy>;
  readonly short_code?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: destination_display_view */
export type StopsDatabaseDestinationDisplayViewPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "destination_display_view" */
export enum StopsDatabaseDestinationDisplayViewSelectColumn {
  /** column name */
  BrandingRef = 'branding_ref',
  /** column name */
  Id = 'id',
  /** column name */
  NameId = 'name_id',
  /** column name */
  PublicCode = 'public_code',
  /** column name */
  ShortCode = 'short_code'
}

/** input type for updating data in table "destination_display_view" */
export type StopsDatabaseDestinationDisplayViewSetInput = {
  readonly branding_ref?: InputMaybe<Scalars['bytea']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly public_code?: InputMaybe<Scalars['String']['input']>;
  readonly short_code?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseDestinationDisplayViewStddevFields = {
  readonly __typename?: 'stops_database_destination_display_view_stddev_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly name_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseDestinationDisplayViewStddevPopFields = {
  readonly __typename?: 'stops_database_destination_display_view_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly name_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseDestinationDisplayViewStddevSampFields = {
  readonly __typename?: 'stops_database_destination_display_view_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly name_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "destination_display_view" */
export type StopsDatabaseDestinationDisplayViewStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseDestinationDisplayViewStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseDestinationDisplayViewStreamCursorValueInput = {
  readonly branding_ref?: InputMaybe<Scalars['bytea']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly public_code?: InputMaybe<Scalars['String']['input']>;
  readonly short_code?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseDestinationDisplayViewSumFields = {
  readonly __typename?: 'stops_database_destination_display_view_sum_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly name_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "destination_display_view" */
export enum StopsDatabaseDestinationDisplayViewUpdateColumn {
  /** column name */
  BrandingRef = 'branding_ref',
  /** column name */
  Id = 'id',
  /** column name */
  NameId = 'name_id',
  /** column name */
  PublicCode = 'public_code',
  /** column name */
  ShortCode = 'short_code'
}

export type StopsDatabaseDestinationDisplayViewUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseDestinationDisplayViewIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseDestinationDisplayViewSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseDestinationDisplayViewBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseDestinationDisplayViewVarPopFields = {
  readonly __typename?: 'stops_database_destination_display_view_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly name_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseDestinationDisplayViewVarSampFields = {
  readonly __typename?: 'stops_database_destination_display_view_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly name_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseDestinationDisplayViewVarianceFields = {
  readonly __typename?: 'stops_database_destination_display_view_variance_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly name_id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "equipment_place" */
export type StopsDatabaseEquipmentPlace = {
  readonly __typename?: 'stops_database_equipment_place';
  readonly centroid?: Maybe<Scalars['geometry']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  readonly equipment_place_equipment_positions: ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositions>;
  /** An aggregate relationship */
  readonly equipment_place_equipment_positions_aggregate: StopsDatabaseEquipmentPlaceEquipmentPositionsAggregate;
  /** An array relationship */
  readonly equipment_place_key_values: ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValues>;
  /** An aggregate relationship */
  readonly equipment_place_key_values_aggregate: StopsDatabaseEquipmentPlaceKeyValuesAggregate;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id: Scalars['bigint']['output'];
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  readonly persistable_polygon?: Maybe<StopsDatabasePersistablePolygon>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "equipment_place" */
export type StopsDatabaseEquipmentPlaceEquipmentPlaceEquipmentPositionsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositionsOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>;
};


/** columns and relationships of "equipment_place" */
export type StopsDatabaseEquipmentPlaceEquipmentPlaceEquipmentPositionsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositionsOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>;
};


/** columns and relationships of "equipment_place" */
export type StopsDatabaseEquipmentPlaceEquipmentPlaceKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>;
};


/** columns and relationships of "equipment_place" */
export type StopsDatabaseEquipmentPlaceEquipmentPlaceKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>;
};

/** aggregated selection of "equipment_place" */
export type StopsDatabaseEquipmentPlaceAggregate = {
  readonly __typename?: 'stops_database_equipment_place_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseEquipmentPlaceAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseEquipmentPlace>;
};

/** aggregate fields of "equipment_place" */
export type StopsDatabaseEquipmentPlaceAggregateFields = {
  readonly __typename?: 'stops_database_equipment_place_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseEquipmentPlaceAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseEquipmentPlaceMaxFields>;
  readonly min?: Maybe<StopsDatabaseEquipmentPlaceMinFields>;
  readonly stddev?: Maybe<StopsDatabaseEquipmentPlaceStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseEquipmentPlaceStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseEquipmentPlaceStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseEquipmentPlaceSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseEquipmentPlaceVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseEquipmentPlaceVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseEquipmentPlaceVarianceFields>;
};


/** aggregate fields of "equipment_place" */
export type StopsDatabaseEquipmentPlaceAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseEquipmentPlaceAvgFields = {
  readonly __typename?: 'stops_database_equipment_place_avg_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "equipment_place". All fields are combined with a logical 'AND'. */
export type StopsDatabaseEquipmentPlaceBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseEquipmentPlaceBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceBoolExp>>;
  readonly centroid?: InputMaybe<GeometryComparisonExp>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly description_lang?: InputMaybe<StringComparisonExp>;
  readonly description_value?: InputMaybe<StringComparisonExp>;
  readonly equipment_place_equipment_positions?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>;
  readonly equipment_place_equipment_positions_aggregate?: InputMaybe<EquipmentPlaceEquipmentPositionsAggregateBoolExp>;
  readonly equipment_place_key_values?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>;
  readonly equipment_place_key_values_aggregate?: InputMaybe<EquipmentPlaceKeyValuesAggregateBoolExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly name_lang?: InputMaybe<StringComparisonExp>;
  readonly name_value?: InputMaybe<StringComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  readonly polygon_id?: InputMaybe<BigintComparisonExp>;
  readonly private_code_type?: InputMaybe<StringComparisonExp>;
  readonly private_code_value?: InputMaybe<StringComparisonExp>;
  readonly short_name_lang?: InputMaybe<StringComparisonExp>;
  readonly short_name_value?: InputMaybe<StringComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "equipment_place" */
export enum StopsDatabaseEquipmentPlaceConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  EquipmentPlaceNetexIdVersionConstraint = 'equipment_place_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  EquipmentPlacePkey = 'equipment_place_pkey'
}

/** columns and relationships of "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositions = {
  readonly __typename?: 'stops_database_equipment_place_equipment_positions';
  readonly equipment_place_id: Scalars['bigint']['output'];
  /** An object relationship */
  readonly equipment_position: StopsDatabaseEquipmentPosition;
  readonly equipment_positions_id: Scalars['bigint']['output'];
};

/** aggregated selection of "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsAggregate = {
  readonly __typename?: 'stops_database_equipment_place_equipment_positions_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositions>;
};

/** aggregate fields of "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsAggregateFields = {
  readonly __typename?: 'stops_database_equipment_place_equipment_positions_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsMaxFields>;
  readonly min?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsMinFields>;
  readonly stddev?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsVarianceFields>;
};


/** aggregate fields of "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositionsInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsAvgFields = {
  readonly __typename?: 'stops_database_equipment_place_equipment_positions_avg_fields';
  readonly equipment_place_id?: Maybe<Scalars['Float']['output']>;
  readonly equipment_positions_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsAvgOrderBy = {
  readonly equipment_place_id?: InputMaybe<OrderBy>;
  readonly equipment_positions_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "equipment_place_equipment_positions". All fields are combined with a logical 'AND'. */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>>;
  readonly equipment_place_id?: InputMaybe<BigintComparisonExp>;
  readonly equipment_position?: InputMaybe<StopsDatabaseEquipmentPositionBoolExp>;
  readonly equipment_positions_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "equipment_place_equipment_positions" */
export enum StopsDatabaseEquipmentPlaceEquipmentPositionsConstraint {
  /** unique or primary key constraint on columns "equipment_positions_id" */
  UkA3yu015il8xu4ty68idmk8csl = 'uk_a3yu015il8xu4ty68idmk8csl'
}

/** input type for incrementing numeric columns in table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsIncInput = {
  readonly equipment_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly equipment_positions_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsInsertInput = {
  readonly equipment_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly equipment_position?: InputMaybe<StopsDatabaseEquipmentPositionObjRelInsertInput>;
  readonly equipment_positions_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsMaxFields = {
  readonly __typename?: 'stops_database_equipment_place_equipment_positions_max_fields';
  readonly equipment_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly equipment_positions_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsMaxOrderBy = {
  readonly equipment_place_id?: InputMaybe<OrderBy>;
  readonly equipment_positions_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsMinFields = {
  readonly __typename?: 'stops_database_equipment_place_equipment_positions_min_fields';
  readonly equipment_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly equipment_positions_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsMinOrderBy = {
  readonly equipment_place_id?: InputMaybe<OrderBy>;
  readonly equipment_positions_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsMutationResponse = {
  readonly __typename?: 'stops_database_equipment_place_equipment_positions_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositions>;
};

/** on_conflict condition type for table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsOnConflict = {
  readonly constraint: StopsDatabaseEquipmentPlaceEquipmentPositionsConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositionsUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>;
};

/** Ordering options when selecting data from "equipment_place_equipment_positions". */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsOrderBy = {
  readonly equipment_place_id?: InputMaybe<OrderBy>;
  readonly equipment_position?: InputMaybe<StopsDatabaseEquipmentPositionOrderBy>;
  readonly equipment_positions_id?: InputMaybe<OrderBy>;
};

/** select columns of table "equipment_place_equipment_positions" */
export enum StopsDatabaseEquipmentPlaceEquipmentPositionsSelectColumn {
  /** column name */
  EquipmentPlaceId = 'equipment_place_id',
  /** column name */
  EquipmentPositionsId = 'equipment_positions_id'
}

/** input type for updating data in table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsSetInput = {
  readonly equipment_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly equipment_positions_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsStddevFields = {
  readonly __typename?: 'stops_database_equipment_place_equipment_positions_stddev_fields';
  readonly equipment_place_id?: Maybe<Scalars['Float']['output']>;
  readonly equipment_positions_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsStddevOrderBy = {
  readonly equipment_place_id?: InputMaybe<OrderBy>;
  readonly equipment_positions_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsStddevPopFields = {
  readonly __typename?: 'stops_database_equipment_place_equipment_positions_stddev_pop_fields';
  readonly equipment_place_id?: Maybe<Scalars['Float']['output']>;
  readonly equipment_positions_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsStddevPopOrderBy = {
  readonly equipment_place_id?: InputMaybe<OrderBy>;
  readonly equipment_positions_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsStddevSampFields = {
  readonly __typename?: 'stops_database_equipment_place_equipment_positions_stddev_samp_fields';
  readonly equipment_place_id?: Maybe<Scalars['Float']['output']>;
  readonly equipment_positions_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsStddevSampOrderBy = {
  readonly equipment_place_id?: InputMaybe<OrderBy>;
  readonly equipment_positions_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseEquipmentPlaceEquipmentPositionsStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsStreamCursorValueInput = {
  readonly equipment_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly equipment_positions_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsSumFields = {
  readonly __typename?: 'stops_database_equipment_place_equipment_positions_sum_fields';
  readonly equipment_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly equipment_positions_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsSumOrderBy = {
  readonly equipment_place_id?: InputMaybe<OrderBy>;
  readonly equipment_positions_id?: InputMaybe<OrderBy>;
};

/** update columns of table "equipment_place_equipment_positions" */
export enum StopsDatabaseEquipmentPlaceEquipmentPositionsUpdateColumn {
  /** column name */
  EquipmentPlaceId = 'equipment_place_id',
  /** column name */
  EquipmentPositionsId = 'equipment_positions_id'
}

export type StopsDatabaseEquipmentPlaceEquipmentPositionsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsVarPopFields = {
  readonly __typename?: 'stops_database_equipment_place_equipment_positions_var_pop_fields';
  readonly equipment_place_id?: Maybe<Scalars['Float']['output']>;
  readonly equipment_positions_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsVarPopOrderBy = {
  readonly equipment_place_id?: InputMaybe<OrderBy>;
  readonly equipment_positions_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsVarSampFields = {
  readonly __typename?: 'stops_database_equipment_place_equipment_positions_var_samp_fields';
  readonly equipment_place_id?: Maybe<Scalars['Float']['output']>;
  readonly equipment_positions_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsVarSampOrderBy = {
  readonly equipment_place_id?: InputMaybe<OrderBy>;
  readonly equipment_positions_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsVarianceFields = {
  readonly __typename?: 'stops_database_equipment_place_equipment_positions_variance_fields';
  readonly equipment_place_id?: Maybe<Scalars['Float']['output']>;
  readonly equipment_positions_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "equipment_place_equipment_positions" */
export type StopsDatabaseEquipmentPlaceEquipmentPositionsVarianceOrderBy = {
  readonly equipment_place_id?: InputMaybe<OrderBy>;
  readonly equipment_positions_id?: InputMaybe<OrderBy>;
};

/** input type for incrementing numeric columns in table "equipment_place" */
export type StopsDatabaseEquipmentPlaceIncInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "equipment_place" */
export type StopsDatabaseEquipmentPlaceInsertInput = {
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly equipment_place_equipment_positions?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsArrRelInsertInput>;
  readonly equipment_place_key_values?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesArrRelInsertInput>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonObjRelInsertInput>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValues = {
  readonly __typename?: 'stops_database_equipment_place_key_values';
  readonly equipment_place_id: Scalars['bigint']['output'];
  readonly key_values_id: Scalars['bigint']['output'];
  readonly key_values_key: Scalars['String']['output'];
  /** An object relationship */
  readonly value: StopsDatabaseValue;
};

/** aggregated selection of "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesAggregate = {
  readonly __typename?: 'stops_database_equipment_place_key_values_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValues>;
};

/** aggregate fields of "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesAggregateFields = {
  readonly __typename?: 'stops_database_equipment_place_key_values_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesMaxFields>;
  readonly min?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesVarianceFields>;
};


/** aggregate fields of "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValuesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseEquipmentPlaceKeyValuesAvgFields = {
  readonly __typename?: 'stops_database_equipment_place_key_values_avg_fields';
  readonly equipment_place_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesAvgOrderBy = {
  readonly equipment_place_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "equipment_place_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseEquipmentPlaceKeyValuesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>>;
  readonly equipment_place_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_key?: InputMaybe<StringComparisonExp>;
  readonly value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "equipment_place_key_values" */
export enum StopsDatabaseEquipmentPlaceKeyValuesConstraint {
  /** unique or primary key constraint on columns "key_values_key", "equipment_place_id" */
  EquipmentPlaceKeyValuesPkey = 'equipment_place_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkFyyde9f6a3dq1436v1wykpur2 = 'uk_fyyde9f6a3dq1436v1wykpur2'
}

/** input type for incrementing numeric columns in table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesIncInput = {
  readonly equipment_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesInsertInput = {
  readonly equipment_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseEquipmentPlaceKeyValuesMaxFields = {
  readonly __typename?: 'stops_database_equipment_place_key_values_max_fields';
  readonly equipment_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesMaxOrderBy = {
  readonly equipment_place_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseEquipmentPlaceKeyValuesMinFields = {
  readonly __typename?: 'stops_database_equipment_place_key_values_min_fields';
  readonly equipment_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesMinOrderBy = {
  readonly equipment_place_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesMutationResponse = {
  readonly __typename?: 'stops_database_equipment_place_key_values_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValues>;
};

/** on_conflict condition type for table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesOnConflict = {
  readonly constraint: StopsDatabaseEquipmentPlaceKeyValuesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValuesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "equipment_place_key_values". */
export type StopsDatabaseEquipmentPlaceKeyValuesOrderBy = {
  readonly equipment_place_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: equipment_place_key_values */
export type StopsDatabaseEquipmentPlaceKeyValuesPkColumnsInput = {
  readonly equipment_place_id: Scalars['bigint']['input'];
  readonly key_values_key: Scalars['String']['input'];
};

/** select columns of table "equipment_place_key_values" */
export enum StopsDatabaseEquipmentPlaceKeyValuesSelectColumn {
  /** column name */
  EquipmentPlaceId = 'equipment_place_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key'
}

/** input type for updating data in table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesSetInput = {
  readonly equipment_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseEquipmentPlaceKeyValuesStddevFields = {
  readonly __typename?: 'stops_database_equipment_place_key_values_stddev_fields';
  readonly equipment_place_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesStddevOrderBy = {
  readonly equipment_place_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseEquipmentPlaceKeyValuesStddevPopFields = {
  readonly __typename?: 'stops_database_equipment_place_key_values_stddev_pop_fields';
  readonly equipment_place_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesStddevPopOrderBy = {
  readonly equipment_place_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseEquipmentPlaceKeyValuesStddevSampFields = {
  readonly __typename?: 'stops_database_equipment_place_key_values_stddev_samp_fields';
  readonly equipment_place_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesStddevSampOrderBy = {
  readonly equipment_place_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseEquipmentPlaceKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseEquipmentPlaceKeyValuesStreamCursorValueInput = {
  readonly equipment_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseEquipmentPlaceKeyValuesSumFields = {
  readonly __typename?: 'stops_database_equipment_place_key_values_sum_fields';
  readonly equipment_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesSumOrderBy = {
  readonly equipment_place_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** update columns of table "equipment_place_key_values" */
export enum StopsDatabaseEquipmentPlaceKeyValuesUpdateColumn {
  /** column name */
  EquipmentPlaceId = 'equipment_place_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key'
}

export type StopsDatabaseEquipmentPlaceKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseEquipmentPlaceKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseEquipmentPlaceKeyValuesVarPopFields = {
  readonly __typename?: 'stops_database_equipment_place_key_values_var_pop_fields';
  readonly equipment_place_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesVarPopOrderBy = {
  readonly equipment_place_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseEquipmentPlaceKeyValuesVarSampFields = {
  readonly __typename?: 'stops_database_equipment_place_key_values_var_samp_fields';
  readonly equipment_place_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesVarSampOrderBy = {
  readonly equipment_place_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseEquipmentPlaceKeyValuesVarianceFields = {
  readonly __typename?: 'stops_database_equipment_place_key_values_variance_fields';
  readonly equipment_place_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "equipment_place_key_values" */
export type StopsDatabaseEquipmentPlaceKeyValuesVarianceOrderBy = {
  readonly equipment_place_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseEquipmentPlaceMaxFields = {
  readonly __typename?: 'stops_database_equipment_place_max_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseEquipmentPlaceMinFields = {
  readonly __typename?: 'stops_database_equipment_place_min_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "equipment_place" */
export type StopsDatabaseEquipmentPlaceMutationResponse = {
  readonly __typename?: 'stops_database_equipment_place_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseEquipmentPlace>;
};

/** input type for inserting object relation for remote table "equipment_place" */
export type StopsDatabaseEquipmentPlaceObjRelInsertInput = {
  readonly data: StopsDatabaseEquipmentPlaceInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseEquipmentPlaceOnConflict>;
};

/** on_conflict condition type for table "equipment_place" */
export type StopsDatabaseEquipmentPlaceOnConflict = {
  readonly constraint: StopsDatabaseEquipmentPlaceConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseEquipmentPlaceUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseEquipmentPlaceBoolExp>;
};

/** Ordering options when selecting data from "equipment_place". */
export type StopsDatabaseEquipmentPlaceOrderBy = {
  readonly centroid?: InputMaybe<OrderBy>;
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly description_lang?: InputMaybe<OrderBy>;
  readonly description_value?: InputMaybe<OrderBy>;
  readonly equipment_place_equipment_positions_aggregate?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsAggregateOrderBy>;
  readonly equipment_place_key_values_aggregate?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesAggregateOrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly name_lang?: InputMaybe<OrderBy>;
  readonly name_value?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonOrderBy>;
  readonly polygon_id?: InputMaybe<OrderBy>;
  readonly private_code_type?: InputMaybe<OrderBy>;
  readonly private_code_value?: InputMaybe<OrderBy>;
  readonly short_name_lang?: InputMaybe<OrderBy>;
  readonly short_name_value?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: equipment_place */
export type StopsDatabaseEquipmentPlacePkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "equipment_place" */
export enum StopsDatabaseEquipmentPlaceSelectColumn {
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

/** input type for updating data in table "equipment_place" */
export type StopsDatabaseEquipmentPlaceSetInput = {
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseEquipmentPlaceStddevFields = {
  readonly __typename?: 'stops_database_equipment_place_stddev_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseEquipmentPlaceStddevPopFields = {
  readonly __typename?: 'stops_database_equipment_place_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseEquipmentPlaceStddevSampFields = {
  readonly __typename?: 'stops_database_equipment_place_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "equipment_place" */
export type StopsDatabaseEquipmentPlaceStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseEquipmentPlaceStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseEquipmentPlaceStreamCursorValueInput = {
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseEquipmentPlaceSumFields = {
  readonly __typename?: 'stops_database_equipment_place_sum_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "equipment_place" */
export enum StopsDatabaseEquipmentPlaceUpdateColumn {
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

export type StopsDatabaseEquipmentPlaceUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseEquipmentPlaceIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseEquipmentPlaceSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseEquipmentPlaceBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseEquipmentPlaceVarPopFields = {
  readonly __typename?: 'stops_database_equipment_place_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseEquipmentPlaceVarSampFields = {
  readonly __typename?: 'stops_database_equipment_place_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseEquipmentPlaceVarianceFields = {
  readonly __typename?: 'stops_database_equipment_place_variance_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "equipment_position" */
export type StopsDatabaseEquipmentPosition = {
  readonly __typename?: 'stops_database_equipment_position';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_id?: Maybe<Scalars['bigint']['output']>;
  /** An array relationship */
  readonly equipment_position_key_values: ReadonlyArray<StopsDatabaseEquipmentPositionKeyValues>;
  /** An aggregate relationship */
  readonly equipment_position_key_values_aggregate: StopsDatabaseEquipmentPositionKeyValuesAggregate;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id: Scalars['bigint']['output'];
  /** An object relationship */
  readonly multilingual_string_entity?: Maybe<StopsDatabaseMultilingualStringEntity>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly reference_point_ref?: Maybe<Scalars['String']['output']>;
  readonly reference_point_version?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly x_offset?: Maybe<Scalars['numeric']['output']>;
  readonly y_offset?: Maybe<Scalars['numeric']['output']>;
};


/** columns and relationships of "equipment_position" */
export type StopsDatabaseEquipmentPositionEquipmentPositionKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesBoolExp>;
};


/** columns and relationships of "equipment_position" */
export type StopsDatabaseEquipmentPositionEquipmentPositionKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesBoolExp>;
};

/** aggregated selection of "equipment_position" */
export type StopsDatabaseEquipmentPositionAggregate = {
  readonly __typename?: 'stops_database_equipment_position_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseEquipmentPositionAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseEquipmentPosition>;
};

/** aggregate fields of "equipment_position" */
export type StopsDatabaseEquipmentPositionAggregateFields = {
  readonly __typename?: 'stops_database_equipment_position_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseEquipmentPositionAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseEquipmentPositionMaxFields>;
  readonly min?: Maybe<StopsDatabaseEquipmentPositionMinFields>;
  readonly stddev?: Maybe<StopsDatabaseEquipmentPositionStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseEquipmentPositionStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseEquipmentPositionStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseEquipmentPositionSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseEquipmentPositionVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseEquipmentPositionVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseEquipmentPositionVarianceFields>;
};


/** aggregate fields of "equipment_position" */
export type StopsDatabaseEquipmentPositionAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseEquipmentPositionAvgFields = {
  readonly __typename?: 'stops_database_equipment_position_avg_fields';
  readonly description_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly x_offset?: Maybe<Scalars['Float']['output']>;
  readonly y_offset?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "equipment_position". All fields are combined with a logical 'AND'. */
export type StopsDatabaseEquipmentPositionBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseEquipmentPositionBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionBoolExp>>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly description_id?: InputMaybe<BigintComparisonExp>;
  readonly equipment_position_key_values?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesBoolExp>;
  readonly equipment_position_key_values_aggregate?: InputMaybe<EquipmentPositionKeyValuesAggregateBoolExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly multilingual_string_entity?: InputMaybe<StopsDatabaseMultilingualStringEntityBoolExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly reference_point_ref?: InputMaybe<StringComparisonExp>;
  readonly reference_point_version?: InputMaybe<StringComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
  readonly x_offset?: InputMaybe<NumericComparisonExp>;
  readonly y_offset?: InputMaybe<NumericComparisonExp>;
};

/** unique or primary key constraints on table "equipment_position" */
export enum StopsDatabaseEquipmentPositionConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  EquipmentPositionNetexIdVersionConstraint = 'equipment_position_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  EquipmentPositionPkey = 'equipment_position_pkey'
}

/** input type for incrementing numeric columns in table "equipment_position" */
export type StopsDatabaseEquipmentPositionIncInput = {
  readonly description_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly x_offset?: InputMaybe<Scalars['numeric']['input']>;
  readonly y_offset?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "equipment_position" */
export type StopsDatabaseEquipmentPositionInsertInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly equipment_position_key_values?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesArrRelInsertInput>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly multilingual_string_entity?: InputMaybe<StopsDatabaseMultilingualStringEntityObjRelInsertInput>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly reference_point_ref?: InputMaybe<Scalars['String']['input']>;
  readonly reference_point_version?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
  readonly x_offset?: InputMaybe<Scalars['numeric']['input']>;
  readonly y_offset?: InputMaybe<Scalars['numeric']['input']>;
};

/** columns and relationships of "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValues = {
  readonly __typename?: 'stops_database_equipment_position_key_values';
  readonly equipment_position_id: Scalars['bigint']['output'];
  readonly key_values_id: Scalars['bigint']['output'];
  readonly key_values_key: Scalars['String']['output'];
  /** An object relationship */
  readonly value: StopsDatabaseValue;
};

/** aggregated selection of "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesAggregate = {
  readonly __typename?: 'stops_database_equipment_position_key_values_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseEquipmentPositionKeyValuesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseEquipmentPositionKeyValues>;
};

/** aggregate fields of "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesAggregateFields = {
  readonly __typename?: 'stops_database_equipment_position_key_values_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseEquipmentPositionKeyValuesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseEquipmentPositionKeyValuesMaxFields>;
  readonly min?: Maybe<StopsDatabaseEquipmentPositionKeyValuesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseEquipmentPositionKeyValuesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseEquipmentPositionKeyValuesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseEquipmentPositionKeyValuesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseEquipmentPositionKeyValuesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseEquipmentPositionKeyValuesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseEquipmentPositionKeyValuesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseEquipmentPositionKeyValuesVarianceFields>;
};


/** aggregate fields of "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseEquipmentPositionKeyValuesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseEquipmentPositionKeyValuesAvgFields = {
  readonly __typename?: 'stops_database_equipment_position_key_values_avg_fields';
  readonly equipment_position_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesAvgOrderBy = {
  readonly equipment_position_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "equipment_position_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseEquipmentPositionKeyValuesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionKeyValuesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionKeyValuesBoolExp>>;
  readonly equipment_position_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_key?: InputMaybe<StringComparisonExp>;
  readonly value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "equipment_position_key_values" */
export enum StopsDatabaseEquipmentPositionKeyValuesConstraint {
  /** unique or primary key constraint on columns "key_values_key", "equipment_position_id" */
  EquipmentPositionKeyValuesPkey = 'equipment_position_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkHw9nq847b38qyxa25ide9ltyy = 'uk_hw9nq847b38qyxa25ide9ltyy'
}

/** input type for incrementing numeric columns in table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesIncInput = {
  readonly equipment_position_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesInsertInput = {
  readonly equipment_position_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseEquipmentPositionKeyValuesMaxFields = {
  readonly __typename?: 'stops_database_equipment_position_key_values_max_fields';
  readonly equipment_position_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesMaxOrderBy = {
  readonly equipment_position_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseEquipmentPositionKeyValuesMinFields = {
  readonly __typename?: 'stops_database_equipment_position_key_values_min_fields';
  readonly equipment_position_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesMinOrderBy = {
  readonly equipment_position_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesMutationResponse = {
  readonly __typename?: 'stops_database_equipment_position_key_values_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseEquipmentPositionKeyValues>;
};

/** on_conflict condition type for table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesOnConflict = {
  readonly constraint: StopsDatabaseEquipmentPositionKeyValuesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseEquipmentPositionKeyValuesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "equipment_position_key_values". */
export type StopsDatabaseEquipmentPositionKeyValuesOrderBy = {
  readonly equipment_position_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: equipment_position_key_values */
export type StopsDatabaseEquipmentPositionKeyValuesPkColumnsInput = {
  readonly equipment_position_id: Scalars['bigint']['input'];
  readonly key_values_key: Scalars['String']['input'];
};

/** select columns of table "equipment_position_key_values" */
export enum StopsDatabaseEquipmentPositionKeyValuesSelectColumn {
  /** column name */
  EquipmentPositionId = 'equipment_position_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key'
}

/** input type for updating data in table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesSetInput = {
  readonly equipment_position_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseEquipmentPositionKeyValuesStddevFields = {
  readonly __typename?: 'stops_database_equipment_position_key_values_stddev_fields';
  readonly equipment_position_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesStddevOrderBy = {
  readonly equipment_position_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseEquipmentPositionKeyValuesStddevPopFields = {
  readonly __typename?: 'stops_database_equipment_position_key_values_stddev_pop_fields';
  readonly equipment_position_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesStddevPopOrderBy = {
  readonly equipment_position_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseEquipmentPositionKeyValuesStddevSampFields = {
  readonly __typename?: 'stops_database_equipment_position_key_values_stddev_samp_fields';
  readonly equipment_position_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesStddevSampOrderBy = {
  readonly equipment_position_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseEquipmentPositionKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseEquipmentPositionKeyValuesStreamCursorValueInput = {
  readonly equipment_position_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseEquipmentPositionKeyValuesSumFields = {
  readonly __typename?: 'stops_database_equipment_position_key_values_sum_fields';
  readonly equipment_position_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesSumOrderBy = {
  readonly equipment_position_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** update columns of table "equipment_position_key_values" */
export enum StopsDatabaseEquipmentPositionKeyValuesUpdateColumn {
  /** column name */
  EquipmentPositionId = 'equipment_position_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key'
}

export type StopsDatabaseEquipmentPositionKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseEquipmentPositionKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseEquipmentPositionKeyValuesVarPopFields = {
  readonly __typename?: 'stops_database_equipment_position_key_values_var_pop_fields';
  readonly equipment_position_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesVarPopOrderBy = {
  readonly equipment_position_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseEquipmentPositionKeyValuesVarSampFields = {
  readonly __typename?: 'stops_database_equipment_position_key_values_var_samp_fields';
  readonly equipment_position_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesVarSampOrderBy = {
  readonly equipment_position_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseEquipmentPositionKeyValuesVarianceFields = {
  readonly __typename?: 'stops_database_equipment_position_key_values_variance_fields';
  readonly equipment_position_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "equipment_position_key_values" */
export type StopsDatabaseEquipmentPositionKeyValuesVarianceOrderBy = {
  readonly equipment_position_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseEquipmentPositionMaxFields = {
  readonly __typename?: 'stops_database_equipment_position_max_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_id?: Maybe<Scalars['bigint']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly reference_point_ref?: Maybe<Scalars['String']['output']>;
  readonly reference_point_version?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly x_offset?: Maybe<Scalars['numeric']['output']>;
  readonly y_offset?: Maybe<Scalars['numeric']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseEquipmentPositionMinFields = {
  readonly __typename?: 'stops_database_equipment_position_min_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_id?: Maybe<Scalars['bigint']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly reference_point_ref?: Maybe<Scalars['String']['output']>;
  readonly reference_point_version?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly x_offset?: Maybe<Scalars['numeric']['output']>;
  readonly y_offset?: Maybe<Scalars['numeric']['output']>;
};

/** response of any mutation on the table "equipment_position" */
export type StopsDatabaseEquipmentPositionMutationResponse = {
  readonly __typename?: 'stops_database_equipment_position_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseEquipmentPosition>;
};

/** input type for inserting object relation for remote table "equipment_position" */
export type StopsDatabaseEquipmentPositionObjRelInsertInput = {
  readonly data: StopsDatabaseEquipmentPositionInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseEquipmentPositionOnConflict>;
};

/** on_conflict condition type for table "equipment_position" */
export type StopsDatabaseEquipmentPositionOnConflict = {
  readonly constraint: StopsDatabaseEquipmentPositionConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseEquipmentPositionUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseEquipmentPositionBoolExp>;
};

/** Ordering options when selecting data from "equipment_position". */
export type StopsDatabaseEquipmentPositionOrderBy = {
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly description_id?: InputMaybe<OrderBy>;
  readonly equipment_position_key_values_aggregate?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesAggregateOrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly multilingual_string_entity?: InputMaybe<StopsDatabaseMultilingualStringEntityOrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly reference_point_ref?: InputMaybe<OrderBy>;
  readonly reference_point_version?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
  readonly x_offset?: InputMaybe<OrderBy>;
  readonly y_offset?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: equipment_position */
export type StopsDatabaseEquipmentPositionPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "equipment_position" */
export enum StopsDatabaseEquipmentPositionSelectColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionId = 'description_id',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ReferencePointRef = 'reference_point_ref',
  /** column name */
  ReferencePointVersion = 'reference_point_version',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  XOffset = 'x_offset',
  /** column name */
  YOffset = 'y_offset'
}

/** input type for updating data in table "equipment_position" */
export type StopsDatabaseEquipmentPositionSetInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly reference_point_ref?: InputMaybe<Scalars['String']['input']>;
  readonly reference_point_version?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
  readonly x_offset?: InputMaybe<Scalars['numeric']['input']>;
  readonly y_offset?: InputMaybe<Scalars['numeric']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseEquipmentPositionStddevFields = {
  readonly __typename?: 'stops_database_equipment_position_stddev_fields';
  readonly description_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly x_offset?: Maybe<Scalars['Float']['output']>;
  readonly y_offset?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseEquipmentPositionStddevPopFields = {
  readonly __typename?: 'stops_database_equipment_position_stddev_pop_fields';
  readonly description_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly x_offset?: Maybe<Scalars['Float']['output']>;
  readonly y_offset?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseEquipmentPositionStddevSampFields = {
  readonly __typename?: 'stops_database_equipment_position_stddev_samp_fields';
  readonly description_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly x_offset?: Maybe<Scalars['Float']['output']>;
  readonly y_offset?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "equipment_position" */
export type StopsDatabaseEquipmentPositionStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseEquipmentPositionStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseEquipmentPositionStreamCursorValueInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly reference_point_ref?: InputMaybe<Scalars['String']['input']>;
  readonly reference_point_version?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
  readonly x_offset?: InputMaybe<Scalars['numeric']['input']>;
  readonly y_offset?: InputMaybe<Scalars['numeric']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseEquipmentPositionSumFields = {
  readonly __typename?: 'stops_database_equipment_position_sum_fields';
  readonly description_id?: Maybe<Scalars['bigint']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly x_offset?: Maybe<Scalars['numeric']['output']>;
  readonly y_offset?: Maybe<Scalars['numeric']['output']>;
};

/** update columns of table "equipment_position" */
export enum StopsDatabaseEquipmentPositionUpdateColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionId = 'description_id',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ReferencePointRef = 'reference_point_ref',
  /** column name */
  ReferencePointVersion = 'reference_point_version',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  XOffset = 'x_offset',
  /** column name */
  YOffset = 'y_offset'
}

export type StopsDatabaseEquipmentPositionUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseEquipmentPositionIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseEquipmentPositionSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseEquipmentPositionBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseEquipmentPositionVarPopFields = {
  readonly __typename?: 'stops_database_equipment_position_var_pop_fields';
  readonly description_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly x_offset?: Maybe<Scalars['Float']['output']>;
  readonly y_offset?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseEquipmentPositionVarSampFields = {
  readonly __typename?: 'stops_database_equipment_position_var_samp_fields';
  readonly description_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly x_offset?: Maybe<Scalars['Float']['output']>;
  readonly y_offset?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseEquipmentPositionVarianceFields = {
  readonly __typename?: 'stops_database_equipment_position_variance_fields';
  readonly description_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly x_offset?: Maybe<Scalars['Float']['output']>;
  readonly y_offset?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "export_job" */
export type StopsDatabaseExportJob = {
  readonly __typename?: 'stops_database_export_job';
  readonly file_name?: Maybe<Scalars['String']['output']>;
  readonly finished?: Maybe<Scalars['timestamp']['output']>;
  readonly id: Scalars['bigint']['output'];
  readonly job_url?: Maybe<Scalars['String']['output']>;
  readonly message?: Maybe<Scalars['String']['output']>;
  readonly started?: Maybe<Scalars['timestamp']['output']>;
  readonly status?: Maybe<Scalars['Int']['output']>;
  readonly sub_folder?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "export_job" */
export type StopsDatabaseExportJobAggregate = {
  readonly __typename?: 'stops_database_export_job_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseExportJobAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseExportJob>;
};

/** aggregate fields of "export_job" */
export type StopsDatabaseExportJobAggregateFields = {
  readonly __typename?: 'stops_database_export_job_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseExportJobAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseExportJobMaxFields>;
  readonly min?: Maybe<StopsDatabaseExportJobMinFields>;
  readonly stddev?: Maybe<StopsDatabaseExportJobStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseExportJobStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseExportJobStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseExportJobSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseExportJobVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseExportJobVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseExportJobVarianceFields>;
};


/** aggregate fields of "export_job" */
export type StopsDatabaseExportJobAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseExportJobSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseExportJobAvgFields = {
  readonly __typename?: 'stops_database_export_job_avg_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly status?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "export_job". All fields are combined with a logical 'AND'. */
export type StopsDatabaseExportJobBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseExportJobBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseExportJobBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseExportJobBoolExp>>;
  readonly file_name?: InputMaybe<StringComparisonExp>;
  readonly finished?: InputMaybe<TimestampComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly job_url?: InputMaybe<StringComparisonExp>;
  readonly message?: InputMaybe<StringComparisonExp>;
  readonly started?: InputMaybe<TimestampComparisonExp>;
  readonly status?: InputMaybe<IntComparisonExp>;
  readonly sub_folder?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "export_job" */
export enum StopsDatabaseExportJobConstraint {
  /** unique or primary key constraint on columns "id" */
  ExportJobPkey = 'export_job_pkey'
}

/** input type for incrementing numeric columns in table "export_job" */
export type StopsDatabaseExportJobIncInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly status?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "export_job" */
export type StopsDatabaseExportJobInsertInput = {
  readonly file_name?: InputMaybe<Scalars['String']['input']>;
  readonly finished?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly job_url?: InputMaybe<Scalars['String']['input']>;
  readonly message?: InputMaybe<Scalars['String']['input']>;
  readonly started?: InputMaybe<Scalars['timestamp']['input']>;
  readonly status?: InputMaybe<Scalars['Int']['input']>;
  readonly sub_folder?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseExportJobMaxFields = {
  readonly __typename?: 'stops_database_export_job_max_fields';
  readonly file_name?: Maybe<Scalars['String']['output']>;
  readonly finished?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly job_url?: Maybe<Scalars['String']['output']>;
  readonly message?: Maybe<Scalars['String']['output']>;
  readonly started?: Maybe<Scalars['timestamp']['output']>;
  readonly status?: Maybe<Scalars['Int']['output']>;
  readonly sub_folder?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseExportJobMinFields = {
  readonly __typename?: 'stops_database_export_job_min_fields';
  readonly file_name?: Maybe<Scalars['String']['output']>;
  readonly finished?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly job_url?: Maybe<Scalars['String']['output']>;
  readonly message?: Maybe<Scalars['String']['output']>;
  readonly started?: Maybe<Scalars['timestamp']['output']>;
  readonly status?: Maybe<Scalars['Int']['output']>;
  readonly sub_folder?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "export_job" */
export type StopsDatabaseExportJobMutationResponse = {
  readonly __typename?: 'stops_database_export_job_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseExportJob>;
};

/** on_conflict condition type for table "export_job" */
export type StopsDatabaseExportJobOnConflict = {
  readonly constraint: StopsDatabaseExportJobConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseExportJobUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseExportJobBoolExp>;
};

/** Ordering options when selecting data from "export_job". */
export type StopsDatabaseExportJobOrderBy = {
  readonly file_name?: InputMaybe<OrderBy>;
  readonly finished?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly job_url?: InputMaybe<OrderBy>;
  readonly message?: InputMaybe<OrderBy>;
  readonly started?: InputMaybe<OrderBy>;
  readonly status?: InputMaybe<OrderBy>;
  readonly sub_folder?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: export_job */
export type StopsDatabaseExportJobPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "export_job" */
export enum StopsDatabaseExportJobSelectColumn {
  /** column name */
  FileName = 'file_name',
  /** column name */
  Finished = 'finished',
  /** column name */
  Id = 'id',
  /** column name */
  JobUrl = 'job_url',
  /** column name */
  Message = 'message',
  /** column name */
  Started = 'started',
  /** column name */
  Status = 'status',
  /** column name */
  SubFolder = 'sub_folder'
}

/** input type for updating data in table "export_job" */
export type StopsDatabaseExportJobSetInput = {
  readonly file_name?: InputMaybe<Scalars['String']['input']>;
  readonly finished?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly job_url?: InputMaybe<Scalars['String']['input']>;
  readonly message?: InputMaybe<Scalars['String']['input']>;
  readonly started?: InputMaybe<Scalars['timestamp']['input']>;
  readonly status?: InputMaybe<Scalars['Int']['input']>;
  readonly sub_folder?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseExportJobStddevFields = {
  readonly __typename?: 'stops_database_export_job_stddev_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly status?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseExportJobStddevPopFields = {
  readonly __typename?: 'stops_database_export_job_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly status?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseExportJobStddevSampFields = {
  readonly __typename?: 'stops_database_export_job_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly status?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "export_job" */
export type StopsDatabaseExportJobStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseExportJobStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseExportJobStreamCursorValueInput = {
  readonly file_name?: InputMaybe<Scalars['String']['input']>;
  readonly finished?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly job_url?: InputMaybe<Scalars['String']['input']>;
  readonly message?: InputMaybe<Scalars['String']['input']>;
  readonly started?: InputMaybe<Scalars['timestamp']['input']>;
  readonly status?: InputMaybe<Scalars['Int']['input']>;
  readonly sub_folder?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseExportJobSumFields = {
  readonly __typename?: 'stops_database_export_job_sum_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly status?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "export_job" */
export enum StopsDatabaseExportJobUpdateColumn {
  /** column name */
  FileName = 'file_name',
  /** column name */
  Finished = 'finished',
  /** column name */
  Id = 'id',
  /** column name */
  JobUrl = 'job_url',
  /** column name */
  Message = 'message',
  /** column name */
  Started = 'started',
  /** column name */
  Status = 'status',
  /** column name */
  SubFolder = 'sub_folder'
}

export type StopsDatabaseExportJobUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseExportJobIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseExportJobSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseExportJobBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseExportJobVarPopFields = {
  readonly __typename?: 'stops_database_export_job_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly status?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseExportJobVarSampFields = {
  readonly __typename?: 'stops_database_export_job_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly status?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseExportJobVarianceFields = {
  readonly __typename?: 'stops_database_export_job_variance_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly status?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "fare_zone" */
export type StopsDatabaseFareZone = {
  readonly __typename?: 'stops_database_fare_zone';
  readonly centroid?: Maybe<Scalars['geometry']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  readonly fare_zone_key_values: ReadonlyArray<StopsDatabaseFareZoneKeyValues>;
  /** An aggregate relationship */
  readonly fare_zone_key_values_aggregate: StopsDatabaseFareZoneKeyValuesAggregate;
  /** An array relationship */
  readonly fare_zone_members: ReadonlyArray<StopsDatabaseFareZoneMembers>;
  /** An aggregate relationship */
  readonly fare_zone_members_aggregate: StopsDatabaseFareZoneMembersAggregate;
  /** An array relationship */
  readonly fare_zone_neighbours: ReadonlyArray<StopsDatabaseFareZoneNeighbours>;
  /** An aggregate relationship */
  readonly fare_zone_neighbours_aggregate: StopsDatabaseFareZoneNeighboursAggregate;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id: Scalars['bigint']['output'];
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  readonly persistable_polygon?: Maybe<StopsDatabasePersistablePolygon>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly scoping_method?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly transport_organisation_ref?: Maybe<Scalars['String']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly zone_topology?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "fare_zone" */
export type StopsDatabaseFareZoneFareZoneKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneKeyValuesBoolExp>;
};


/** columns and relationships of "fare_zone" */
export type StopsDatabaseFareZoneFareZoneKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneKeyValuesBoolExp>;
};


/** columns and relationships of "fare_zone" */
export type StopsDatabaseFareZoneFareZoneMembersArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneMembersOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneMembersBoolExp>;
};


/** columns and relationships of "fare_zone" */
export type StopsDatabaseFareZoneFareZoneMembersAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneMembersOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneMembersBoolExp>;
};


/** columns and relationships of "fare_zone" */
export type StopsDatabaseFareZoneFareZoneNeighboursArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneNeighboursSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneNeighboursOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneNeighboursBoolExp>;
};


/** columns and relationships of "fare_zone" */
export type StopsDatabaseFareZoneFareZoneNeighboursAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneNeighboursSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneNeighboursOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneNeighboursBoolExp>;
};

/** aggregated selection of "fare_zone" */
export type StopsDatabaseFareZoneAggregate = {
  readonly __typename?: 'stops_database_fare_zone_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseFareZoneAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseFareZone>;
};

/** aggregate fields of "fare_zone" */
export type StopsDatabaseFareZoneAggregateFields = {
  readonly __typename?: 'stops_database_fare_zone_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseFareZoneAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseFareZoneMaxFields>;
  readonly min?: Maybe<StopsDatabaseFareZoneMinFields>;
  readonly stddev?: Maybe<StopsDatabaseFareZoneStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseFareZoneStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseFareZoneStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseFareZoneSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseFareZoneVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseFareZoneVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseFareZoneVarianceFields>;
};


/** aggregate fields of "fare_zone" */
export type StopsDatabaseFareZoneAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseFareZoneAvgFields = {
  readonly __typename?: 'stops_database_fare_zone_avg_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "fare_zone". All fields are combined with a logical 'AND'. */
export type StopsDatabaseFareZoneBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseFareZoneBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneBoolExp>>;
  readonly centroid?: InputMaybe<GeometryComparisonExp>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly description_lang?: InputMaybe<StringComparisonExp>;
  readonly description_value?: InputMaybe<StringComparisonExp>;
  readonly fare_zone_key_values?: InputMaybe<StopsDatabaseFareZoneKeyValuesBoolExp>;
  readonly fare_zone_key_values_aggregate?: InputMaybe<FareZoneKeyValuesAggregateBoolExp>;
  readonly fare_zone_members?: InputMaybe<StopsDatabaseFareZoneMembersBoolExp>;
  readonly fare_zone_members_aggregate?: InputMaybe<FareZoneMembersAggregateBoolExp>;
  readonly fare_zone_neighbours?: InputMaybe<StopsDatabaseFareZoneNeighboursBoolExp>;
  readonly fare_zone_neighbours_aggregate?: InputMaybe<FareZoneNeighboursAggregateBoolExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly name_lang?: InputMaybe<StringComparisonExp>;
  readonly name_value?: InputMaybe<StringComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  readonly polygon_id?: InputMaybe<BigintComparisonExp>;
  readonly private_code_type?: InputMaybe<StringComparisonExp>;
  readonly private_code_value?: InputMaybe<StringComparisonExp>;
  readonly scoping_method?: InputMaybe<StringComparisonExp>;
  readonly short_name_lang?: InputMaybe<StringComparisonExp>;
  readonly short_name_value?: InputMaybe<StringComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly transport_organisation_ref?: InputMaybe<StringComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
  readonly zone_topology?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "fare_zone" */
export enum StopsDatabaseFareZoneConstraint {
  /** unique or primary key constraint on columns "id" */
  FareZonePkey = 'fare_zone_pkey'
}

/** input type for incrementing numeric columns in table "fare_zone" */
export type StopsDatabaseFareZoneIncInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "fare_zone" */
export type StopsDatabaseFareZoneInsertInput = {
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly fare_zone_key_values?: InputMaybe<StopsDatabaseFareZoneKeyValuesArrRelInsertInput>;
  readonly fare_zone_members?: InputMaybe<StopsDatabaseFareZoneMembersArrRelInsertInput>;
  readonly fare_zone_neighbours?: InputMaybe<StopsDatabaseFareZoneNeighboursArrRelInsertInput>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonObjRelInsertInput>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly scoping_method?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly transport_organisation_ref?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
  readonly zone_topology?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValues = {
  readonly __typename?: 'stops_database_fare_zone_key_values';
  readonly fare_zone_id: Scalars['bigint']['output'];
  readonly key_values_id: Scalars['bigint']['output'];
  readonly key_values_key: Scalars['String']['output'];
  /** An object relationship */
  readonly value: StopsDatabaseValue;
};

/** aggregated selection of "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesAggregate = {
  readonly __typename?: 'stops_database_fare_zone_key_values_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseFareZoneKeyValuesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseFareZoneKeyValues>;
};

/** aggregate fields of "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesAggregateFields = {
  readonly __typename?: 'stops_database_fare_zone_key_values_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseFareZoneKeyValuesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseFareZoneKeyValuesMaxFields>;
  readonly min?: Maybe<StopsDatabaseFareZoneKeyValuesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseFareZoneKeyValuesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseFareZoneKeyValuesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseFareZoneKeyValuesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseFareZoneKeyValuesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseFareZoneKeyValuesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseFareZoneKeyValuesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseFareZoneKeyValuesVarianceFields>;
};


/** aggregate fields of "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseFareZoneKeyValuesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseFareZoneKeyValuesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseFareZoneKeyValuesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseFareZoneKeyValuesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseFareZoneKeyValuesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseFareZoneKeyValuesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseFareZoneKeyValuesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseFareZoneKeyValuesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseFareZoneKeyValuesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseFareZoneKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseFareZoneKeyValuesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseFareZoneKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseFareZoneKeyValuesAvgFields = {
  readonly __typename?: 'stops_database_fare_zone_key_values_avg_fields';
  readonly fare_zone_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesAvgOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "fare_zone_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseFareZoneKeyValuesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneKeyValuesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseFareZoneKeyValuesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneKeyValuesBoolExp>>;
  readonly fare_zone_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_key?: InputMaybe<StringComparisonExp>;
  readonly value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "fare_zone_key_values" */
export enum StopsDatabaseFareZoneKeyValuesConstraint {
  /** unique or primary key constraint on columns "key_values_key", "fare_zone_id" */
  FareZoneKeyValuesPkey = 'fare_zone_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkOujfy4iyi1cf3fdquir6jsn0n = 'uk_oujfy4iyi1cf3fdquir6jsn0n'
}

/** input type for incrementing numeric columns in table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesIncInput = {
  readonly fare_zone_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesInsertInput = {
  readonly fare_zone_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseFareZoneKeyValuesMaxFields = {
  readonly __typename?: 'stops_database_fare_zone_key_values_max_fields';
  readonly fare_zone_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesMaxOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseFareZoneKeyValuesMinFields = {
  readonly __typename?: 'stops_database_fare_zone_key_values_min_fields';
  readonly fare_zone_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesMinOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesMutationResponse = {
  readonly __typename?: 'stops_database_fare_zone_key_values_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseFareZoneKeyValues>;
};

/** on_conflict condition type for table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesOnConflict = {
  readonly constraint: StopsDatabaseFareZoneKeyValuesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseFareZoneKeyValuesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseFareZoneKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "fare_zone_key_values". */
export type StopsDatabaseFareZoneKeyValuesOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: fare_zone_key_values */
export type StopsDatabaseFareZoneKeyValuesPkColumnsInput = {
  readonly fare_zone_id: Scalars['bigint']['input'];
  readonly key_values_key: Scalars['String']['input'];
};

/** select columns of table "fare_zone_key_values" */
export enum StopsDatabaseFareZoneKeyValuesSelectColumn {
  /** column name */
  FareZoneId = 'fare_zone_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key'
}

/** input type for updating data in table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesSetInput = {
  readonly fare_zone_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseFareZoneKeyValuesStddevFields = {
  readonly __typename?: 'stops_database_fare_zone_key_values_stddev_fields';
  readonly fare_zone_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesStddevOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseFareZoneKeyValuesStddevPopFields = {
  readonly __typename?: 'stops_database_fare_zone_key_values_stddev_pop_fields';
  readonly fare_zone_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesStddevPopOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseFareZoneKeyValuesStddevSampFields = {
  readonly __typename?: 'stops_database_fare_zone_key_values_stddev_samp_fields';
  readonly fare_zone_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesStddevSampOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseFareZoneKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseFareZoneKeyValuesStreamCursorValueInput = {
  readonly fare_zone_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseFareZoneKeyValuesSumFields = {
  readonly __typename?: 'stops_database_fare_zone_key_values_sum_fields';
  readonly fare_zone_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesSumOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** update columns of table "fare_zone_key_values" */
export enum StopsDatabaseFareZoneKeyValuesUpdateColumn {
  /** column name */
  FareZoneId = 'fare_zone_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key'
}

export type StopsDatabaseFareZoneKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseFareZoneKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseFareZoneKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseFareZoneKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseFareZoneKeyValuesVarPopFields = {
  readonly __typename?: 'stops_database_fare_zone_key_values_var_pop_fields';
  readonly fare_zone_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesVarPopOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseFareZoneKeyValuesVarSampFields = {
  readonly __typename?: 'stops_database_fare_zone_key_values_var_samp_fields';
  readonly fare_zone_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesVarSampOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseFareZoneKeyValuesVarianceFields = {
  readonly __typename?: 'stops_database_fare_zone_key_values_variance_fields';
  readonly fare_zone_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "fare_zone_key_values" */
export type StopsDatabaseFareZoneKeyValuesVarianceOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseFareZoneMaxFields = {
  readonly __typename?: 'stops_database_fare_zone_max_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly scoping_method?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly transport_organisation_ref?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly zone_topology?: Maybe<Scalars['String']['output']>;
};

/** columns and relationships of "fare_zone_members" */
export type StopsDatabaseFareZoneMembers = {
  readonly __typename?: 'stops_database_fare_zone_members';
  /** An object relationship */
  readonly fare_zone: StopsDatabaseFareZone;
  readonly fare_zone_id: Scalars['bigint']['output'];
  readonly ref?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "fare_zone_members" */
export type StopsDatabaseFareZoneMembersAggregate = {
  readonly __typename?: 'stops_database_fare_zone_members_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseFareZoneMembersAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseFareZoneMembers>;
};

/** aggregate fields of "fare_zone_members" */
export type StopsDatabaseFareZoneMembersAggregateFields = {
  readonly __typename?: 'stops_database_fare_zone_members_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseFareZoneMembersAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseFareZoneMembersMaxFields>;
  readonly min?: Maybe<StopsDatabaseFareZoneMembersMinFields>;
  readonly stddev?: Maybe<StopsDatabaseFareZoneMembersStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseFareZoneMembersStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseFareZoneMembersStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseFareZoneMembersSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseFareZoneMembersVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseFareZoneMembersVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseFareZoneMembersVarianceFields>;
};


/** aggregate fields of "fare_zone_members" */
export type StopsDatabaseFareZoneMembersAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneMembersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseFareZoneMembersAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseFareZoneMembersMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseFareZoneMembersMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseFareZoneMembersStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseFareZoneMembersStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseFareZoneMembersStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseFareZoneMembersSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseFareZoneMembersVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseFareZoneMembersVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseFareZoneMembersVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseFareZoneMembersInsertInput>;
};

/** aggregate avg on columns */
export type StopsDatabaseFareZoneMembersAvgFields = {
  readonly __typename?: 'stops_database_fare_zone_members_avg_fields';
  readonly fare_zone_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersAvgOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "fare_zone_members". All fields are combined with a logical 'AND'. */
export type StopsDatabaseFareZoneMembersBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneMembersBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseFareZoneMembersBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneMembersBoolExp>>;
  readonly fare_zone?: InputMaybe<StopsDatabaseFareZoneBoolExp>;
  readonly fare_zone_id?: InputMaybe<BigintComparisonExp>;
  readonly ref?: InputMaybe<StringComparisonExp>;
  readonly version?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersIncInput = {
  readonly fare_zone_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersInsertInput = {
  readonly fare_zone?: InputMaybe<StopsDatabaseFareZoneObjRelInsertInput>;
  readonly fare_zone_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly ref?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseFareZoneMembersMaxFields = {
  readonly __typename?: 'stops_database_fare_zone_members_max_fields';
  readonly fare_zone_id?: Maybe<Scalars['bigint']['output']>;
  readonly ref?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersMaxOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
  readonly ref?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseFareZoneMembersMinFields = {
  readonly __typename?: 'stops_database_fare_zone_members_min_fields';
  readonly fare_zone_id?: Maybe<Scalars['bigint']['output']>;
  readonly ref?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersMinOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
  readonly ref?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersMutationResponse = {
  readonly __typename?: 'stops_database_fare_zone_members_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseFareZoneMembers>;
};

/** Ordering options when selecting data from "fare_zone_members". */
export type StopsDatabaseFareZoneMembersOrderBy = {
  readonly fare_zone?: InputMaybe<StopsDatabaseFareZoneOrderBy>;
  readonly fare_zone_id?: InputMaybe<OrderBy>;
  readonly ref?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
};

/** select columns of table "fare_zone_members" */
export enum StopsDatabaseFareZoneMembersSelectColumn {
  /** column name */
  FareZoneId = 'fare_zone_id',
  /** column name */
  Ref = 'ref',
  /** column name */
  Version = 'version'
}

/** input type for updating data in table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersSetInput = {
  readonly fare_zone_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly ref?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseFareZoneMembersStddevFields = {
  readonly __typename?: 'stops_database_fare_zone_members_stddev_fields';
  readonly fare_zone_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersStddevOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseFareZoneMembersStddevPopFields = {
  readonly __typename?: 'stops_database_fare_zone_members_stddev_pop_fields';
  readonly fare_zone_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersStddevPopOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseFareZoneMembersStddevSampFields = {
  readonly __typename?: 'stops_database_fare_zone_members_stddev_samp_fields';
  readonly fare_zone_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersStddevSampOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseFareZoneMembersStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseFareZoneMembersStreamCursorValueInput = {
  readonly fare_zone_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly ref?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseFareZoneMembersSumFields = {
  readonly __typename?: 'stops_database_fare_zone_members_sum_fields';
  readonly fare_zone_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersSumOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
};

export type StopsDatabaseFareZoneMembersUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseFareZoneMembersIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseFareZoneMembersSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseFareZoneMembersBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseFareZoneMembersVarPopFields = {
  readonly __typename?: 'stops_database_fare_zone_members_var_pop_fields';
  readonly fare_zone_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersVarPopOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseFareZoneMembersVarSampFields = {
  readonly __typename?: 'stops_database_fare_zone_members_var_samp_fields';
  readonly fare_zone_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersVarSampOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseFareZoneMembersVarianceFields = {
  readonly __typename?: 'stops_database_fare_zone_members_variance_fields';
  readonly fare_zone_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "fare_zone_members" */
export type StopsDatabaseFareZoneMembersVarianceOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseFareZoneMinFields = {
  readonly __typename?: 'stops_database_fare_zone_min_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly scoping_method?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly transport_organisation_ref?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly zone_topology?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "fare_zone" */
export type StopsDatabaseFareZoneMutationResponse = {
  readonly __typename?: 'stops_database_fare_zone_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseFareZone>;
};

/** columns and relationships of "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighbours = {
  readonly __typename?: 'stops_database_fare_zone_neighbours';
  /** An object relationship */
  readonly fare_zone: StopsDatabaseFareZone;
  readonly fare_zone_id: Scalars['bigint']['output'];
  readonly ref?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursAggregate = {
  readonly __typename?: 'stops_database_fare_zone_neighbours_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseFareZoneNeighboursAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseFareZoneNeighbours>;
};

/** aggregate fields of "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursAggregateFields = {
  readonly __typename?: 'stops_database_fare_zone_neighbours_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseFareZoneNeighboursAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseFareZoneNeighboursMaxFields>;
  readonly min?: Maybe<StopsDatabaseFareZoneNeighboursMinFields>;
  readonly stddev?: Maybe<StopsDatabaseFareZoneNeighboursStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseFareZoneNeighboursStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseFareZoneNeighboursStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseFareZoneNeighboursSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseFareZoneNeighboursVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseFareZoneNeighboursVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseFareZoneNeighboursVarianceFields>;
};


/** aggregate fields of "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneNeighboursSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseFareZoneNeighboursAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseFareZoneNeighboursMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseFareZoneNeighboursMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseFareZoneNeighboursStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseFareZoneNeighboursStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseFareZoneNeighboursStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseFareZoneNeighboursSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseFareZoneNeighboursVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseFareZoneNeighboursVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseFareZoneNeighboursVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseFareZoneNeighboursInsertInput>;
};

/** aggregate avg on columns */
export type StopsDatabaseFareZoneNeighboursAvgFields = {
  readonly __typename?: 'stops_database_fare_zone_neighbours_avg_fields';
  readonly fare_zone_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursAvgOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "fare_zone_neighbours". All fields are combined with a logical 'AND'. */
export type StopsDatabaseFareZoneNeighboursBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneNeighboursBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseFareZoneNeighboursBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneNeighboursBoolExp>>;
  readonly fare_zone?: InputMaybe<StopsDatabaseFareZoneBoolExp>;
  readonly fare_zone_id?: InputMaybe<BigintComparisonExp>;
  readonly ref?: InputMaybe<StringComparisonExp>;
  readonly version?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursIncInput = {
  readonly fare_zone_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursInsertInput = {
  readonly fare_zone?: InputMaybe<StopsDatabaseFareZoneObjRelInsertInput>;
  readonly fare_zone_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly ref?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseFareZoneNeighboursMaxFields = {
  readonly __typename?: 'stops_database_fare_zone_neighbours_max_fields';
  readonly fare_zone_id?: Maybe<Scalars['bigint']['output']>;
  readonly ref?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursMaxOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
  readonly ref?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseFareZoneNeighboursMinFields = {
  readonly __typename?: 'stops_database_fare_zone_neighbours_min_fields';
  readonly fare_zone_id?: Maybe<Scalars['bigint']['output']>;
  readonly ref?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursMinOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
  readonly ref?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursMutationResponse = {
  readonly __typename?: 'stops_database_fare_zone_neighbours_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseFareZoneNeighbours>;
};

/** Ordering options when selecting data from "fare_zone_neighbours". */
export type StopsDatabaseFareZoneNeighboursOrderBy = {
  readonly fare_zone?: InputMaybe<StopsDatabaseFareZoneOrderBy>;
  readonly fare_zone_id?: InputMaybe<OrderBy>;
  readonly ref?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
};

/** select columns of table "fare_zone_neighbours" */
export enum StopsDatabaseFareZoneNeighboursSelectColumn {
  /** column name */
  FareZoneId = 'fare_zone_id',
  /** column name */
  Ref = 'ref',
  /** column name */
  Version = 'version'
}

/** input type for updating data in table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursSetInput = {
  readonly fare_zone_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly ref?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseFareZoneNeighboursStddevFields = {
  readonly __typename?: 'stops_database_fare_zone_neighbours_stddev_fields';
  readonly fare_zone_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursStddevOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseFareZoneNeighboursStddevPopFields = {
  readonly __typename?: 'stops_database_fare_zone_neighbours_stddev_pop_fields';
  readonly fare_zone_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursStddevPopOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseFareZoneNeighboursStddevSampFields = {
  readonly __typename?: 'stops_database_fare_zone_neighbours_stddev_samp_fields';
  readonly fare_zone_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursStddevSampOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseFareZoneNeighboursStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseFareZoneNeighboursStreamCursorValueInput = {
  readonly fare_zone_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly ref?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseFareZoneNeighboursSumFields = {
  readonly __typename?: 'stops_database_fare_zone_neighbours_sum_fields';
  readonly fare_zone_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursSumOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
};

export type StopsDatabaseFareZoneNeighboursUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseFareZoneNeighboursIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseFareZoneNeighboursSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseFareZoneNeighboursBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseFareZoneNeighboursVarPopFields = {
  readonly __typename?: 'stops_database_fare_zone_neighbours_var_pop_fields';
  readonly fare_zone_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursVarPopOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseFareZoneNeighboursVarSampFields = {
  readonly __typename?: 'stops_database_fare_zone_neighbours_var_samp_fields';
  readonly fare_zone_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursVarSampOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseFareZoneNeighboursVarianceFields = {
  readonly __typename?: 'stops_database_fare_zone_neighbours_variance_fields';
  readonly fare_zone_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "fare_zone_neighbours" */
export type StopsDatabaseFareZoneNeighboursVarianceOrderBy = {
  readonly fare_zone_id?: InputMaybe<OrderBy>;
};

/** input type for inserting object relation for remote table "fare_zone" */
export type StopsDatabaseFareZoneObjRelInsertInput = {
  readonly data: StopsDatabaseFareZoneInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseFareZoneOnConflict>;
};

/** on_conflict condition type for table "fare_zone" */
export type StopsDatabaseFareZoneOnConflict = {
  readonly constraint: StopsDatabaseFareZoneConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseFareZoneUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseFareZoneBoolExp>;
};

/** Ordering options when selecting data from "fare_zone". */
export type StopsDatabaseFareZoneOrderBy = {
  readonly centroid?: InputMaybe<OrderBy>;
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly description_lang?: InputMaybe<OrderBy>;
  readonly description_value?: InputMaybe<OrderBy>;
  readonly fare_zone_key_values_aggregate?: InputMaybe<StopsDatabaseFareZoneKeyValuesAggregateOrderBy>;
  readonly fare_zone_members_aggregate?: InputMaybe<StopsDatabaseFareZoneMembersAggregateOrderBy>;
  readonly fare_zone_neighbours_aggregate?: InputMaybe<StopsDatabaseFareZoneNeighboursAggregateOrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly name_lang?: InputMaybe<OrderBy>;
  readonly name_value?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonOrderBy>;
  readonly polygon_id?: InputMaybe<OrderBy>;
  readonly private_code_type?: InputMaybe<OrderBy>;
  readonly private_code_value?: InputMaybe<OrderBy>;
  readonly scoping_method?: InputMaybe<OrderBy>;
  readonly short_name_lang?: InputMaybe<OrderBy>;
  readonly short_name_value?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly transport_organisation_ref?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
  readonly zone_topology?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: fare_zone */
export type StopsDatabaseFareZonePkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "fare_zone" */
export enum StopsDatabaseFareZoneSelectColumn {
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ScopingMethod = 'scoping_method',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TransportOrganisationRef = 'transport_organisation_ref',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  ZoneTopology = 'zone_topology'
}

/** input type for updating data in table "fare_zone" */
export type StopsDatabaseFareZoneSetInput = {
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly scoping_method?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly transport_organisation_ref?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
  readonly zone_topology?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseFareZoneStddevFields = {
  readonly __typename?: 'stops_database_fare_zone_stddev_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseFareZoneStddevPopFields = {
  readonly __typename?: 'stops_database_fare_zone_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseFareZoneStddevSampFields = {
  readonly __typename?: 'stops_database_fare_zone_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "fare_zone" */
export type StopsDatabaseFareZoneStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseFareZoneStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseFareZoneStreamCursorValueInput = {
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly scoping_method?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly transport_organisation_ref?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
  readonly zone_topology?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseFareZoneSumFields = {
  readonly __typename?: 'stops_database_fare_zone_sum_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "fare_zone" */
export enum StopsDatabaseFareZoneUpdateColumn {
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ScopingMethod = 'scoping_method',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TransportOrganisationRef = 'transport_organisation_ref',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  ZoneTopology = 'zone_topology'
}

export type StopsDatabaseFareZoneUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseFareZoneIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseFareZoneSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseFareZoneBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseFareZoneVarPopFields = {
  readonly __typename?: 'stops_database_fare_zone_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseFareZoneVarSampFields = {
  readonly __typename?: 'stops_database_fare_zone_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseFareZoneVarianceFields = {
  readonly __typename?: 'stops_database_fare_zone_variance_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "geography_columns" */
export type StopsDatabaseGeographyColumns = {
  readonly __typename?: 'stops_database_geography_columns';
  readonly coord_dimension?: Maybe<Scalars['Int']['output']>;
  readonly f_geography_column?: Maybe<Scalars['name']['output']>;
  readonly f_table_catalog?: Maybe<Scalars['name']['output']>;
  readonly f_table_name?: Maybe<Scalars['name']['output']>;
  readonly f_table_schema?: Maybe<Scalars['name']['output']>;
  readonly srid?: Maybe<Scalars['Int']['output']>;
  readonly type?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "geography_columns" */
export type StopsDatabaseGeographyColumnsAggregate = {
  readonly __typename?: 'stops_database_geography_columns_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseGeographyColumnsAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseGeographyColumns>;
};

/** aggregate fields of "geography_columns" */
export type StopsDatabaseGeographyColumnsAggregateFields = {
  readonly __typename?: 'stops_database_geography_columns_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseGeographyColumnsAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseGeographyColumnsMaxFields>;
  readonly min?: Maybe<StopsDatabaseGeographyColumnsMinFields>;
  readonly stddev?: Maybe<StopsDatabaseGeographyColumnsStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseGeographyColumnsStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseGeographyColumnsStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseGeographyColumnsSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseGeographyColumnsVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseGeographyColumnsVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseGeographyColumnsVarianceFields>;
};


/** aggregate fields of "geography_columns" */
export type StopsDatabaseGeographyColumnsAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseGeographyColumnsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseGeographyColumnsAvgFields = {
  readonly __typename?: 'stops_database_geography_columns_avg_fields';
  readonly coord_dimension?: Maybe<Scalars['Float']['output']>;
  readonly srid?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "geography_columns". All fields are combined with a logical 'AND'. */
export type StopsDatabaseGeographyColumnsBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseGeographyColumnsBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseGeographyColumnsBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseGeographyColumnsBoolExp>>;
  readonly coord_dimension?: InputMaybe<IntComparisonExp>;
  readonly f_geography_column?: InputMaybe<NameComparisonExp>;
  readonly f_table_catalog?: InputMaybe<NameComparisonExp>;
  readonly f_table_name?: InputMaybe<NameComparisonExp>;
  readonly f_table_schema?: InputMaybe<NameComparisonExp>;
  readonly srid?: InputMaybe<IntComparisonExp>;
  readonly type?: InputMaybe<StringComparisonExp>;
};

/** aggregate max on columns */
export type StopsDatabaseGeographyColumnsMaxFields = {
  readonly __typename?: 'stops_database_geography_columns_max_fields';
  readonly coord_dimension?: Maybe<Scalars['Int']['output']>;
  readonly srid?: Maybe<Scalars['Int']['output']>;
  readonly type?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseGeographyColumnsMinFields = {
  readonly __typename?: 'stops_database_geography_columns_min_fields';
  readonly coord_dimension?: Maybe<Scalars['Int']['output']>;
  readonly srid?: Maybe<Scalars['Int']['output']>;
  readonly type?: Maybe<Scalars['String']['output']>;
};

/** Ordering options when selecting data from "geography_columns". */
export type StopsDatabaseGeographyColumnsOrderBy = {
  readonly coord_dimension?: InputMaybe<OrderBy>;
  readonly f_geography_column?: InputMaybe<OrderBy>;
  readonly f_table_catalog?: InputMaybe<OrderBy>;
  readonly f_table_name?: InputMaybe<OrderBy>;
  readonly f_table_schema?: InputMaybe<OrderBy>;
  readonly srid?: InputMaybe<OrderBy>;
  readonly type?: InputMaybe<OrderBy>;
};

/** select columns of table "geography_columns" */
export enum StopsDatabaseGeographyColumnsSelectColumn {
  /** column name */
  CoordDimension = 'coord_dimension',
  /** column name */
  FGeographyColumn = 'f_geography_column',
  /** column name */
  FTableCatalog = 'f_table_catalog',
  /** column name */
  FTableName = 'f_table_name',
  /** column name */
  FTableSchema = 'f_table_schema',
  /** column name */
  Srid = 'srid',
  /** column name */
  Type = 'type'
}

/** aggregate stddev on columns */
export type StopsDatabaseGeographyColumnsStddevFields = {
  readonly __typename?: 'stops_database_geography_columns_stddev_fields';
  readonly coord_dimension?: Maybe<Scalars['Float']['output']>;
  readonly srid?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseGeographyColumnsStddevPopFields = {
  readonly __typename?: 'stops_database_geography_columns_stddev_pop_fields';
  readonly coord_dimension?: Maybe<Scalars['Float']['output']>;
  readonly srid?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseGeographyColumnsStddevSampFields = {
  readonly __typename?: 'stops_database_geography_columns_stddev_samp_fields';
  readonly coord_dimension?: Maybe<Scalars['Float']['output']>;
  readonly srid?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "geography_columns" */
export type StopsDatabaseGeographyColumnsStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseGeographyColumnsStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseGeographyColumnsStreamCursorValueInput = {
  readonly coord_dimension?: InputMaybe<Scalars['Int']['input']>;
  readonly f_geography_column?: InputMaybe<Scalars['name']['input']>;
  readonly f_table_catalog?: InputMaybe<Scalars['name']['input']>;
  readonly f_table_name?: InputMaybe<Scalars['name']['input']>;
  readonly f_table_schema?: InputMaybe<Scalars['name']['input']>;
  readonly srid?: InputMaybe<Scalars['Int']['input']>;
  readonly type?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseGeographyColumnsSumFields = {
  readonly __typename?: 'stops_database_geography_columns_sum_fields';
  readonly coord_dimension?: Maybe<Scalars['Int']['output']>;
  readonly srid?: Maybe<Scalars['Int']['output']>;
};

/** aggregate var_pop on columns */
export type StopsDatabaseGeographyColumnsVarPopFields = {
  readonly __typename?: 'stops_database_geography_columns_var_pop_fields';
  readonly coord_dimension?: Maybe<Scalars['Float']['output']>;
  readonly srid?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseGeographyColumnsVarSampFields = {
  readonly __typename?: 'stops_database_geography_columns_var_samp_fields';
  readonly coord_dimension?: Maybe<Scalars['Float']['output']>;
  readonly srid?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseGeographyColumnsVarianceFields = {
  readonly __typename?: 'stops_database_geography_columns_variance_fields';
  readonly coord_dimension?: Maybe<Scalars['Float']['output']>;
  readonly srid?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "geometry_columns" */
export type StopsDatabaseGeometryColumns = {
  readonly __typename?: 'stops_database_geometry_columns';
  readonly coord_dimension?: Maybe<Scalars['Int']['output']>;
  readonly f_geometry_column?: Maybe<Scalars['name']['output']>;
  readonly f_table_catalog?: Maybe<Scalars['String']['output']>;
  readonly f_table_name?: Maybe<Scalars['name']['output']>;
  readonly f_table_schema?: Maybe<Scalars['name']['output']>;
  readonly srid?: Maybe<Scalars['Int']['output']>;
  readonly type?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "geometry_columns" */
export type StopsDatabaseGeometryColumnsAggregate = {
  readonly __typename?: 'stops_database_geometry_columns_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseGeometryColumnsAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseGeometryColumns>;
};

/** aggregate fields of "geometry_columns" */
export type StopsDatabaseGeometryColumnsAggregateFields = {
  readonly __typename?: 'stops_database_geometry_columns_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseGeometryColumnsAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseGeometryColumnsMaxFields>;
  readonly min?: Maybe<StopsDatabaseGeometryColumnsMinFields>;
  readonly stddev?: Maybe<StopsDatabaseGeometryColumnsStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseGeometryColumnsStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseGeometryColumnsStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseGeometryColumnsSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseGeometryColumnsVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseGeometryColumnsVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseGeometryColumnsVarianceFields>;
};


/** aggregate fields of "geometry_columns" */
export type StopsDatabaseGeometryColumnsAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseGeometryColumnsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseGeometryColumnsAvgFields = {
  readonly __typename?: 'stops_database_geometry_columns_avg_fields';
  readonly coord_dimension?: Maybe<Scalars['Float']['output']>;
  readonly srid?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "geometry_columns". All fields are combined with a logical 'AND'. */
export type StopsDatabaseGeometryColumnsBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseGeometryColumnsBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseGeometryColumnsBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseGeometryColumnsBoolExp>>;
  readonly coord_dimension?: InputMaybe<IntComparisonExp>;
  readonly f_geometry_column?: InputMaybe<NameComparisonExp>;
  readonly f_table_catalog?: InputMaybe<StringComparisonExp>;
  readonly f_table_name?: InputMaybe<NameComparisonExp>;
  readonly f_table_schema?: InputMaybe<NameComparisonExp>;
  readonly srid?: InputMaybe<IntComparisonExp>;
  readonly type?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "geometry_columns" */
export type StopsDatabaseGeometryColumnsIncInput = {
  readonly coord_dimension?: InputMaybe<Scalars['Int']['input']>;
  readonly srid?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "geometry_columns" */
export type StopsDatabaseGeometryColumnsInsertInput = {
  readonly coord_dimension?: InputMaybe<Scalars['Int']['input']>;
  readonly f_geometry_column?: InputMaybe<Scalars['name']['input']>;
  readonly f_table_catalog?: InputMaybe<Scalars['String']['input']>;
  readonly f_table_name?: InputMaybe<Scalars['name']['input']>;
  readonly f_table_schema?: InputMaybe<Scalars['name']['input']>;
  readonly srid?: InputMaybe<Scalars['Int']['input']>;
  readonly type?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseGeometryColumnsMaxFields = {
  readonly __typename?: 'stops_database_geometry_columns_max_fields';
  readonly coord_dimension?: Maybe<Scalars['Int']['output']>;
  readonly f_table_catalog?: Maybe<Scalars['String']['output']>;
  readonly srid?: Maybe<Scalars['Int']['output']>;
  readonly type?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseGeometryColumnsMinFields = {
  readonly __typename?: 'stops_database_geometry_columns_min_fields';
  readonly coord_dimension?: Maybe<Scalars['Int']['output']>;
  readonly f_table_catalog?: Maybe<Scalars['String']['output']>;
  readonly srid?: Maybe<Scalars['Int']['output']>;
  readonly type?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "geometry_columns" */
export type StopsDatabaseGeometryColumnsMutationResponse = {
  readonly __typename?: 'stops_database_geometry_columns_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseGeometryColumns>;
};

/** Ordering options when selecting data from "geometry_columns". */
export type StopsDatabaseGeometryColumnsOrderBy = {
  readonly coord_dimension?: InputMaybe<OrderBy>;
  readonly f_geometry_column?: InputMaybe<OrderBy>;
  readonly f_table_catalog?: InputMaybe<OrderBy>;
  readonly f_table_name?: InputMaybe<OrderBy>;
  readonly f_table_schema?: InputMaybe<OrderBy>;
  readonly srid?: InputMaybe<OrderBy>;
  readonly type?: InputMaybe<OrderBy>;
};

/** select columns of table "geometry_columns" */
export enum StopsDatabaseGeometryColumnsSelectColumn {
  /** column name */
  CoordDimension = 'coord_dimension',
  /** column name */
  FGeometryColumn = 'f_geometry_column',
  /** column name */
  FTableCatalog = 'f_table_catalog',
  /** column name */
  FTableName = 'f_table_name',
  /** column name */
  FTableSchema = 'f_table_schema',
  /** column name */
  Srid = 'srid',
  /** column name */
  Type = 'type'
}

/** input type for updating data in table "geometry_columns" */
export type StopsDatabaseGeometryColumnsSetInput = {
  readonly coord_dimension?: InputMaybe<Scalars['Int']['input']>;
  readonly f_geometry_column?: InputMaybe<Scalars['name']['input']>;
  readonly f_table_catalog?: InputMaybe<Scalars['String']['input']>;
  readonly f_table_name?: InputMaybe<Scalars['name']['input']>;
  readonly f_table_schema?: InputMaybe<Scalars['name']['input']>;
  readonly srid?: InputMaybe<Scalars['Int']['input']>;
  readonly type?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseGeometryColumnsStddevFields = {
  readonly __typename?: 'stops_database_geometry_columns_stddev_fields';
  readonly coord_dimension?: Maybe<Scalars['Float']['output']>;
  readonly srid?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseGeometryColumnsStddevPopFields = {
  readonly __typename?: 'stops_database_geometry_columns_stddev_pop_fields';
  readonly coord_dimension?: Maybe<Scalars['Float']['output']>;
  readonly srid?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseGeometryColumnsStddevSampFields = {
  readonly __typename?: 'stops_database_geometry_columns_stddev_samp_fields';
  readonly coord_dimension?: Maybe<Scalars['Float']['output']>;
  readonly srid?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "geometry_columns" */
export type StopsDatabaseGeometryColumnsStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseGeometryColumnsStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseGeometryColumnsStreamCursorValueInput = {
  readonly coord_dimension?: InputMaybe<Scalars['Int']['input']>;
  readonly f_geometry_column?: InputMaybe<Scalars['name']['input']>;
  readonly f_table_catalog?: InputMaybe<Scalars['String']['input']>;
  readonly f_table_name?: InputMaybe<Scalars['name']['input']>;
  readonly f_table_schema?: InputMaybe<Scalars['name']['input']>;
  readonly srid?: InputMaybe<Scalars['Int']['input']>;
  readonly type?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseGeometryColumnsSumFields = {
  readonly __typename?: 'stops_database_geometry_columns_sum_fields';
  readonly coord_dimension?: Maybe<Scalars['Int']['output']>;
  readonly srid?: Maybe<Scalars['Int']['output']>;
};

export type StopsDatabaseGeometryColumnsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseGeometryColumnsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseGeometryColumnsSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseGeometryColumnsBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseGeometryColumnsVarPopFields = {
  readonly __typename?: 'stops_database_geometry_columns_var_pop_fields';
  readonly coord_dimension?: Maybe<Scalars['Float']['output']>;
  readonly srid?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseGeometryColumnsVarSampFields = {
  readonly __typename?: 'stops_database_geometry_columns_var_samp_fields';
  readonly coord_dimension?: Maybe<Scalars['Float']['output']>;
  readonly srid?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseGeometryColumnsVarianceFields = {
  readonly __typename?: 'stops_database_geometry_columns_variance_fields';
  readonly coord_dimension?: Maybe<Scalars['Float']['output']>;
  readonly srid?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlaces = {
  readonly __typename?: 'stops_database_group_of_stop_places';
  readonly centroid?: Maybe<Scalars['geometry']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  /** An array relationship */
  readonly group_of_stop_places_alternative_names: ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNames>;
  /** An aggregate relationship */
  readonly group_of_stop_places_alternative_names_aggregate: StopsDatabaseGroupOfStopPlacesAlternativeNamesAggregate;
  /** An array relationship */
  readonly group_of_stop_places_key_values: ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValues>;
  /** An aggregate relationship */
  readonly group_of_stop_places_key_values_aggregate: StopsDatabaseGroupOfStopPlacesKeyValuesAggregate;
  /** An array relationship */
  readonly group_of_stop_places_members: ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembers>;
  /** An aggregate relationship */
  readonly group_of_stop_places_members_aggregate: StopsDatabaseGroupOfStopPlacesMembersAggregate;
  readonly id: Scalars['bigint']['output'];
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly purpose_of_grouping_id?: Maybe<Scalars['bigint']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesGroupOfStopPlacesAlternativeNamesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>;
};


/** columns and relationships of "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesGroupOfStopPlacesAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>;
};


/** columns and relationships of "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesGroupOfStopPlacesKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>;
};


/** columns and relationships of "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesGroupOfStopPlacesKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>;
};


/** columns and relationships of "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesGroupOfStopPlacesMembersArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembersOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersBoolExp>;
};


/** columns and relationships of "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesGroupOfStopPlacesMembersAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembersOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersBoolExp>;
};

/** aggregated selection of "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesAggregate = {
  readonly __typename?: 'stops_database_group_of_stop_places_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseGroupOfStopPlacesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseGroupOfStopPlaces>;
};

/** aggregate fields of "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesAggregateFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseGroupOfStopPlacesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseGroupOfStopPlacesMaxFields>;
  readonly min?: Maybe<StopsDatabaseGroupOfStopPlacesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseGroupOfStopPlacesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseGroupOfStopPlacesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseGroupOfStopPlacesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseGroupOfStopPlacesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseGroupOfStopPlacesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseGroupOfStopPlacesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseGroupOfStopPlacesVarianceFields>;
};


/** aggregate fields of "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** columns and relationships of "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNames = {
  readonly __typename?: 'stops_database_group_of_stop_places_alternative_names';
  /** An object relationship */
  readonly alternative_name: StopsDatabaseAlternativeName;
  readonly alternative_names_id: Scalars['bigint']['output'];
  readonly group_of_stop_places_id: Scalars['bigint']['output'];
};

/** aggregated selection of "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesAggregate = {
  readonly __typename?: 'stops_database_group_of_stop_places_alternative_names_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNames>;
};

/** aggregate fields of "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesAggregateFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_alternative_names_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesMaxFields>;
  readonly min?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesVarianceFields>;
};


/** aggregate fields of "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNamesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNamesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesAvgFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_alternative_names_avg_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly group_of_stop_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesAvgOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "group_of_stop_places_alternative_names". All fields are combined with a logical 'AND'. */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>>;
  readonly alternative_name?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
  readonly alternative_names_id?: InputMaybe<BigintComparisonExp>;
  readonly group_of_stop_places_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "group_of_stop_places_alternative_names" */
export enum StopsDatabaseGroupOfStopPlacesAlternativeNamesConstraint {
  /** unique or primary key constraint on columns "alternative_names_id" */
  GroupOfStopPlacesAlternativeNamesIdKey = 'group_of_stop_places_alternative_names_id_key'
}

/** input type for incrementing numeric columns in table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesIncInput = {
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly group_of_stop_places_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesInsertInput = {
  readonly alternative_name?: InputMaybe<StopsDatabaseAlternativeNameObjRelInsertInput>;
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly group_of_stop_places_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesMaxFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_alternative_names_max_fields';
  readonly alternative_names_id?: Maybe<Scalars['bigint']['output']>;
  readonly group_of_stop_places_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesMaxOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesMinFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_alternative_names_min_fields';
  readonly alternative_names_id?: Maybe<Scalars['bigint']['output']>;
  readonly group_of_stop_places_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesMinOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesMutationResponse = {
  readonly __typename?: 'stops_database_group_of_stop_places_alternative_names_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNames>;
};

/** on_conflict condition type for table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesOnConflict = {
  readonly constraint: StopsDatabaseGroupOfStopPlacesAlternativeNamesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNamesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>;
};

/** Ordering options when selecting data from "group_of_stop_places_alternative_names". */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesOrderBy = {
  readonly alternative_name?: InputMaybe<StopsDatabaseAlternativeNameOrderBy>;
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** select columns of table "group_of_stop_places_alternative_names" */
export enum StopsDatabaseGroupOfStopPlacesAlternativeNamesSelectColumn {
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
  /** column name */
  GroupOfStopPlacesId = 'group_of_stop_places_id'
}

/** input type for updating data in table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesSetInput = {
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly group_of_stop_places_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesStddevFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_alternative_names_stddev_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly group_of_stop_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesStddevOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesStddevPopFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_alternative_names_stddev_pop_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly group_of_stop_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesStddevPopOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesStddevSampFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_alternative_names_stddev_samp_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly group_of_stop_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesStddevSampOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseGroupOfStopPlacesAlternativeNamesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesStreamCursorValueInput = {
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly group_of_stop_places_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesSumFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_alternative_names_sum_fields';
  readonly alternative_names_id?: Maybe<Scalars['bigint']['output']>;
  readonly group_of_stop_places_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesSumOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** update columns of table "group_of_stop_places_alternative_names" */
export enum StopsDatabaseGroupOfStopPlacesAlternativeNamesUpdateColumn {
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
  /** column name */
  GroupOfStopPlacesId = 'group_of_stop_places_id'
}

export type StopsDatabaseGroupOfStopPlacesAlternativeNamesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesVarPopFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_alternative_names_var_pop_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly group_of_stop_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesVarPopOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesVarSampFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_alternative_names_var_samp_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly group_of_stop_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesVarSampOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesVarianceFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_alternative_names_variance_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly group_of_stop_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "group_of_stop_places_alternative_names" */
export type StopsDatabaseGroupOfStopPlacesAlternativeNamesVarianceOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** aggregate avg on columns */
export type StopsDatabaseGroupOfStopPlacesAvgFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_avg_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly purpose_of_grouping_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "group_of_stop_places". All fields are combined with a logical 'AND'. */
export type StopsDatabaseGroupOfStopPlacesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseGroupOfStopPlacesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesBoolExp>>;
  readonly centroid?: InputMaybe<GeometryComparisonExp>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly description_lang?: InputMaybe<StringComparisonExp>;
  readonly description_value?: InputMaybe<StringComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly group_of_stop_places_alternative_names?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>;
  readonly group_of_stop_places_alternative_names_aggregate?: InputMaybe<GroupOfStopPlacesAlternativeNamesAggregateBoolExp>;
  readonly group_of_stop_places_key_values?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>;
  readonly group_of_stop_places_key_values_aggregate?: InputMaybe<GroupOfStopPlacesKeyValuesAggregateBoolExp>;
  readonly group_of_stop_places_members?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersBoolExp>;
  readonly group_of_stop_places_members_aggregate?: InputMaybe<GroupOfStopPlacesMembersAggregateBoolExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly name_lang?: InputMaybe<StringComparisonExp>;
  readonly name_value?: InputMaybe<StringComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly private_code_type?: InputMaybe<StringComparisonExp>;
  readonly private_code_value?: InputMaybe<StringComparisonExp>;
  readonly purpose_of_grouping_id?: InputMaybe<BigintComparisonExp>;
  readonly short_name_lang?: InputMaybe<StringComparisonExp>;
  readonly short_name_value?: InputMaybe<StringComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "group_of_stop_places" */
export enum StopsDatabaseGroupOfStopPlacesConstraint {
  /** unique or primary key constraint on columns "id" */
  GroupOfStopPlacesPkey = 'group_of_stop_places_pkey'
}

/** input type for incrementing numeric columns in table "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesIncInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly purpose_of_grouping_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesInsertInput = {
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly group_of_stop_places_alternative_names?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesArrRelInsertInput>;
  readonly group_of_stop_places_key_values?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesArrRelInsertInput>;
  readonly group_of_stop_places_members?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersArrRelInsertInput>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly purpose_of_grouping_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValues = {
  readonly __typename?: 'stops_database_group_of_stop_places_key_values';
  readonly group_of_stop_places_id: Scalars['bigint']['output'];
  readonly key_values_id: Scalars['bigint']['output'];
  readonly key_values_key: Scalars['String']['output'];
  /** An object relationship */
  readonly value: StopsDatabaseValue;
};

/** aggregated selection of "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesAggregate = {
  readonly __typename?: 'stops_database_group_of_stop_places_key_values_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValues>;
};

/** aggregate fields of "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesAggregateFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_key_values_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesMaxFields>;
  readonly min?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesVarianceFields>;
};


/** aggregate fields of "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValuesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseGroupOfStopPlacesKeyValuesAvgFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_key_values_avg_fields';
  readonly group_of_stop_places_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesAvgOrderBy = {
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "group_of_stop_places_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>>;
  readonly group_of_stop_places_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_key?: InputMaybe<StringComparisonExp>;
  readonly value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "group_of_stop_places_key_values" */
export enum StopsDatabaseGroupOfStopPlacesKeyValuesConstraint {
  /** unique or primary key constraint on columns "key_values_id" */
  GroupOfStopPlacesKeyValuesIdKey = 'group_of_stop_places_key_values_id_key',
  /** unique or primary key constraint on columns "key_values_key", "group_of_stop_places_id" */
  GroupOfStopPlacesKeyValuesPkey = 'group_of_stop_places_key_values_pkey'
}

/** input type for incrementing numeric columns in table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesIncInput = {
  readonly group_of_stop_places_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesInsertInput = {
  readonly group_of_stop_places_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseGroupOfStopPlacesKeyValuesMaxFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_key_values_max_fields';
  readonly group_of_stop_places_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesMaxOrderBy = {
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseGroupOfStopPlacesKeyValuesMinFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_key_values_min_fields';
  readonly group_of_stop_places_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesMinOrderBy = {
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesMutationResponse = {
  readonly __typename?: 'stops_database_group_of_stop_places_key_values_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValues>;
};

/** on_conflict condition type for table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesOnConflict = {
  readonly constraint: StopsDatabaseGroupOfStopPlacesKeyValuesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValuesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "group_of_stop_places_key_values". */
export type StopsDatabaseGroupOfStopPlacesKeyValuesOrderBy = {
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: group_of_stop_places_key_values */
export type StopsDatabaseGroupOfStopPlacesKeyValuesPkColumnsInput = {
  readonly group_of_stop_places_id: Scalars['bigint']['input'];
  readonly key_values_key: Scalars['String']['input'];
};

/** select columns of table "group_of_stop_places_key_values" */
export enum StopsDatabaseGroupOfStopPlacesKeyValuesSelectColumn {
  /** column name */
  GroupOfStopPlacesId = 'group_of_stop_places_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key'
}

/** input type for updating data in table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesSetInput = {
  readonly group_of_stop_places_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseGroupOfStopPlacesKeyValuesStddevFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_key_values_stddev_fields';
  readonly group_of_stop_places_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesStddevOrderBy = {
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseGroupOfStopPlacesKeyValuesStddevPopFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_key_values_stddev_pop_fields';
  readonly group_of_stop_places_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesStddevPopOrderBy = {
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseGroupOfStopPlacesKeyValuesStddevSampFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_key_values_stddev_samp_fields';
  readonly group_of_stop_places_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesStddevSampOrderBy = {
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseGroupOfStopPlacesKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseGroupOfStopPlacesKeyValuesStreamCursorValueInput = {
  readonly group_of_stop_places_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseGroupOfStopPlacesKeyValuesSumFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_key_values_sum_fields';
  readonly group_of_stop_places_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesSumOrderBy = {
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** update columns of table "group_of_stop_places_key_values" */
export enum StopsDatabaseGroupOfStopPlacesKeyValuesUpdateColumn {
  /** column name */
  GroupOfStopPlacesId = 'group_of_stop_places_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key'
}

export type StopsDatabaseGroupOfStopPlacesKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseGroupOfStopPlacesKeyValuesVarPopFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_key_values_var_pop_fields';
  readonly group_of_stop_places_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesVarPopOrderBy = {
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseGroupOfStopPlacesKeyValuesVarSampFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_key_values_var_samp_fields';
  readonly group_of_stop_places_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesVarSampOrderBy = {
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseGroupOfStopPlacesKeyValuesVarianceFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_key_values_variance_fields';
  readonly group_of_stop_places_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "group_of_stop_places_key_values" */
export type StopsDatabaseGroupOfStopPlacesKeyValuesVarianceOrderBy = {
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseGroupOfStopPlacesMaxFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_max_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly purpose_of_grouping_id?: Maybe<Scalars['bigint']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** columns and relationships of "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembers = {
  readonly __typename?: 'stops_database_group_of_stop_places_members';
  /** An object relationship */
  readonly group_of_stop_place: StopsDatabaseGroupOfStopPlaces;
  readonly group_of_stop_places_id: Scalars['bigint']['output'];
  readonly ref?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  readonly stop_place_newest_version?: Maybe<StopsDatabaseStopPlaceNewestVersion>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersAggregate = {
  readonly __typename?: 'stops_database_group_of_stop_places_members_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseGroupOfStopPlacesMembersAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembers>;
};

/** aggregate fields of "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersAggregateFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_members_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseGroupOfStopPlacesMembersAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseGroupOfStopPlacesMembersMaxFields>;
  readonly min?: Maybe<StopsDatabaseGroupOfStopPlacesMembersMinFields>;
  readonly stddev?: Maybe<StopsDatabaseGroupOfStopPlacesMembersStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseGroupOfStopPlacesMembersStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseGroupOfStopPlacesMembersStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseGroupOfStopPlacesMembersSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseGroupOfStopPlacesMembersVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseGroupOfStopPlacesMembersVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseGroupOfStopPlacesMembersVarianceFields>;
};


/** aggregate fields of "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembersInsertInput>;
};

/** aggregate avg on columns */
export type StopsDatabaseGroupOfStopPlacesMembersAvgFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_members_avg_fields';
  readonly group_of_stop_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersAvgOrderBy = {
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "group_of_stop_places_members". All fields are combined with a logical 'AND'. */
export type StopsDatabaseGroupOfStopPlacesMembersBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembersBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembersBoolExp>>;
  readonly group_of_stop_place?: InputMaybe<StopsDatabaseGroupOfStopPlacesBoolExp>;
  readonly group_of_stop_places_id?: InputMaybe<BigintComparisonExp>;
  readonly ref?: InputMaybe<StringComparisonExp>;
  readonly stop_place_newest_version?: InputMaybe<StopsDatabaseStopPlaceNewestVersionBoolExp>;
  readonly version?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersIncInput = {
  readonly group_of_stop_places_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersInsertInput = {
  readonly group_of_stop_place?: InputMaybe<StopsDatabaseGroupOfStopPlacesObjRelInsertInput>;
  readonly group_of_stop_places_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly ref?: InputMaybe<Scalars['String']['input']>;
  readonly stop_place_newest_version?: InputMaybe<StopsDatabaseStopPlaceNewestVersionObjRelInsertInput>;
  readonly version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseGroupOfStopPlacesMembersMaxFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_members_max_fields';
  readonly group_of_stop_places_id?: Maybe<Scalars['bigint']['output']>;
  readonly ref?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersMaxOrderBy = {
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
  readonly ref?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseGroupOfStopPlacesMembersMinFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_members_min_fields';
  readonly group_of_stop_places_id?: Maybe<Scalars['bigint']['output']>;
  readonly ref?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersMinOrderBy = {
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
  readonly ref?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersMutationResponse = {
  readonly __typename?: 'stops_database_group_of_stop_places_members_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembers>;
};

/** Ordering options when selecting data from "group_of_stop_places_members". */
export type StopsDatabaseGroupOfStopPlacesMembersOrderBy = {
  readonly group_of_stop_place?: InputMaybe<StopsDatabaseGroupOfStopPlacesOrderBy>;
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
  readonly ref?: InputMaybe<OrderBy>;
  readonly stop_place_newest_version?: InputMaybe<StopsDatabaseStopPlaceNewestVersionOrderBy>;
  readonly version?: InputMaybe<OrderBy>;
};

/** select columns of table "group_of_stop_places_members" */
export enum StopsDatabaseGroupOfStopPlacesMembersSelectColumn {
  /** column name */
  GroupOfStopPlacesId = 'group_of_stop_places_id',
  /** column name */
  Ref = 'ref',
  /** column name */
  Version = 'version'
}

/** input type for updating data in table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersSetInput = {
  readonly group_of_stop_places_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly ref?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseGroupOfStopPlacesMembersStddevFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_members_stddev_fields';
  readonly group_of_stop_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersStddevOrderBy = {
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseGroupOfStopPlacesMembersStddevPopFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_members_stddev_pop_fields';
  readonly group_of_stop_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersStddevPopOrderBy = {
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseGroupOfStopPlacesMembersStddevSampFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_members_stddev_samp_fields';
  readonly group_of_stop_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersStddevSampOrderBy = {
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseGroupOfStopPlacesMembersStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseGroupOfStopPlacesMembersStreamCursorValueInput = {
  readonly group_of_stop_places_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly ref?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseGroupOfStopPlacesMembersSumFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_members_sum_fields';
  readonly group_of_stop_places_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersSumOrderBy = {
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
};

export type StopsDatabaseGroupOfStopPlacesMembersUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseGroupOfStopPlacesMembersBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseGroupOfStopPlacesMembersVarPopFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_members_var_pop_fields';
  readonly group_of_stop_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersVarPopOrderBy = {
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseGroupOfStopPlacesMembersVarSampFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_members_var_samp_fields';
  readonly group_of_stop_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersVarSampOrderBy = {
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseGroupOfStopPlacesMembersVarianceFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_members_variance_fields';
  readonly group_of_stop_places_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "group_of_stop_places_members" */
export type StopsDatabaseGroupOfStopPlacesMembersVarianceOrderBy = {
  readonly group_of_stop_places_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseGroupOfStopPlacesMinFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_min_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly purpose_of_grouping_id?: Maybe<Scalars['bigint']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesMutationResponse = {
  readonly __typename?: 'stops_database_group_of_stop_places_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseGroupOfStopPlaces>;
};

/** input type for inserting object relation for remote table "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesObjRelInsertInput = {
  readonly data: StopsDatabaseGroupOfStopPlacesInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseGroupOfStopPlacesOnConflict>;
};

/** on_conflict condition type for table "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesOnConflict = {
  readonly constraint: StopsDatabaseGroupOfStopPlacesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseGroupOfStopPlacesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseGroupOfStopPlacesBoolExp>;
};

/** Ordering options when selecting data from "group_of_stop_places". */
export type StopsDatabaseGroupOfStopPlacesOrderBy = {
  readonly centroid?: InputMaybe<OrderBy>;
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly description_lang?: InputMaybe<OrderBy>;
  readonly description_value?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly group_of_stop_places_alternative_names_aggregate?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesAggregateOrderBy>;
  readonly group_of_stop_places_key_values_aggregate?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesAggregateOrderBy>;
  readonly group_of_stop_places_members_aggregate?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersAggregateOrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly name_lang?: InputMaybe<OrderBy>;
  readonly name_value?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly private_code_type?: InputMaybe<OrderBy>;
  readonly private_code_value?: InputMaybe<OrderBy>;
  readonly purpose_of_grouping_id?: InputMaybe<OrderBy>;
  readonly short_name_lang?: InputMaybe<OrderBy>;
  readonly short_name_value?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: group_of_stop_places */
export type StopsDatabaseGroupOfStopPlacesPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "group_of_stop_places" */
export enum StopsDatabaseGroupOfStopPlacesSelectColumn {
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  PurposeOfGroupingId = 'purpose_of_grouping_id',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

/** input type for updating data in table "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesSetInput = {
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly purpose_of_grouping_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseGroupOfStopPlacesStddevFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_stddev_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly purpose_of_grouping_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseGroupOfStopPlacesStddevPopFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly purpose_of_grouping_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseGroupOfStopPlacesStddevSampFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly purpose_of_grouping_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "group_of_stop_places" */
export type StopsDatabaseGroupOfStopPlacesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseGroupOfStopPlacesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseGroupOfStopPlacesStreamCursorValueInput = {
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly purpose_of_grouping_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseGroupOfStopPlacesSumFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_sum_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly purpose_of_grouping_id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "group_of_stop_places" */
export enum StopsDatabaseGroupOfStopPlacesUpdateColumn {
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  PurposeOfGroupingId = 'purpose_of_grouping_id',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

export type StopsDatabaseGroupOfStopPlacesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseGroupOfStopPlacesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseGroupOfStopPlacesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseGroupOfStopPlacesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseGroupOfStopPlacesVarPopFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly purpose_of_grouping_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseGroupOfStopPlacesVarSampFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly purpose_of_grouping_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseGroupOfStopPlacesVarianceFields = {
  readonly __typename?: 'stops_database_group_of_stop_places_variance_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly purpose_of_grouping_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZones = {
  readonly __typename?: 'stops_database_group_of_tariff_zones';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  /** An array relationship */
  readonly group_of_tariff_zones_key_values: ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValues>;
  /** An aggregate relationship */
  readonly group_of_tariff_zones_key_values_aggregate: StopsDatabaseGroupOfTariffZonesKeyValuesAggregate;
  /** An array relationship */
  readonly group_of_tariff_zones_members: ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembers>;
  /** An aggregate relationship */
  readonly group_of_tariff_zones_members_aggregate: StopsDatabaseGroupOfTariffZonesMembersAggregate;
  readonly id: Scalars['bigint']['output'];
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly purpose_of_grouping_ref?: Maybe<Scalars['String']['output']>;
  readonly purpose_of_grouping_ref_version?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesGroupOfTariffZonesKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>;
};


/** columns and relationships of "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesGroupOfTariffZonesKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>;
};


/** columns and relationships of "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesGroupOfTariffZonesMembersArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembersOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersBoolExp>;
};


/** columns and relationships of "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesGroupOfTariffZonesMembersAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembersOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersBoolExp>;
};

/** aggregated selection of "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesAggregate = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseGroupOfTariffZonesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseGroupOfTariffZones>;
};

/** aggregate fields of "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesAggregateFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseGroupOfTariffZonesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseGroupOfTariffZonesMaxFields>;
  readonly min?: Maybe<StopsDatabaseGroupOfTariffZonesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseGroupOfTariffZonesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseGroupOfTariffZonesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseGroupOfTariffZonesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseGroupOfTariffZonesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseGroupOfTariffZonesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseGroupOfTariffZonesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseGroupOfTariffZonesVarianceFields>;
};


/** aggregate fields of "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseGroupOfTariffZonesAvgFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_avg_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "group_of_tariff_zones". All fields are combined with a logical 'AND'. */
export type StopsDatabaseGroupOfTariffZonesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseGroupOfTariffZonesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesBoolExp>>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly description_lang?: InputMaybe<StringComparisonExp>;
  readonly description_value?: InputMaybe<StringComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly group_of_tariff_zones_key_values?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>;
  readonly group_of_tariff_zones_key_values_aggregate?: InputMaybe<GroupOfTariffZonesKeyValuesAggregateBoolExp>;
  readonly group_of_tariff_zones_members?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersBoolExp>;
  readonly group_of_tariff_zones_members_aggregate?: InputMaybe<GroupOfTariffZonesMembersAggregateBoolExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly name_lang?: InputMaybe<StringComparisonExp>;
  readonly name_value?: InputMaybe<StringComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly private_code_type?: InputMaybe<StringComparisonExp>;
  readonly private_code_value?: InputMaybe<StringComparisonExp>;
  readonly purpose_of_grouping_ref?: InputMaybe<StringComparisonExp>;
  readonly purpose_of_grouping_ref_version?: InputMaybe<StringComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "group_of_tariff_zones" */
export enum StopsDatabaseGroupOfTariffZonesConstraint {
  /** unique or primary key constraint on columns "id" */
  GroupOfTariffZonesPkey = 'group_of_tariff_zones_pkey'
}

/** input type for incrementing numeric columns in table "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesIncInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesInsertInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly group_of_tariff_zones_key_values?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesArrRelInsertInput>;
  readonly group_of_tariff_zones_members?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersArrRelInsertInput>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly purpose_of_grouping_ref?: InputMaybe<Scalars['String']['input']>;
  readonly purpose_of_grouping_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValues = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_key_values';
  readonly group_of_tariff_zones_id: Scalars['bigint']['output'];
  readonly key_values_id: Scalars['bigint']['output'];
  readonly key_values_key: Scalars['String']['output'];
  /** An object relationship */
  readonly value: StopsDatabaseValue;
};

/** aggregated selection of "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesAggregate = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_key_values_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValues>;
};

/** aggregate fields of "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesAggregateFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_key_values_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesMaxFields>;
  readonly min?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesVarianceFields>;
};


/** aggregate fields of "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValuesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseGroupOfTariffZonesKeyValuesAvgFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_key_values_avg_fields';
  readonly group_of_tariff_zones_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesAvgOrderBy = {
  readonly group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "group_of_tariff_zones_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>>;
  readonly group_of_tariff_zones_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_key?: InputMaybe<StringComparisonExp>;
  readonly value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "group_of_tariff_zones_key_values" */
export enum StopsDatabaseGroupOfTariffZonesKeyValuesConstraint {
  /** unique or primary key constraint on columns "key_values_key", "group_of_tariff_zones_id" */
  GroupOfTariffZonesKeyValuesPkey = 'group_of_tariff_zones_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkPfy12mpgyt1qevehecnwh5vq2 = 'uk_pfy12mpgyt1qevehecnwh5vq2'
}

/** input type for incrementing numeric columns in table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesIncInput = {
  readonly group_of_tariff_zones_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesInsertInput = {
  readonly group_of_tariff_zones_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseGroupOfTariffZonesKeyValuesMaxFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_key_values_max_fields';
  readonly group_of_tariff_zones_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesMaxOrderBy = {
  readonly group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseGroupOfTariffZonesKeyValuesMinFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_key_values_min_fields';
  readonly group_of_tariff_zones_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesMinOrderBy = {
  readonly group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesMutationResponse = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_key_values_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValues>;
};

/** on_conflict condition type for table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesOnConflict = {
  readonly constraint: StopsDatabaseGroupOfTariffZonesKeyValuesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValuesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "group_of_tariff_zones_key_values". */
export type StopsDatabaseGroupOfTariffZonesKeyValuesOrderBy = {
  readonly group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: group_of_tariff_zones_key_values */
export type StopsDatabaseGroupOfTariffZonesKeyValuesPkColumnsInput = {
  readonly group_of_tariff_zones_id: Scalars['bigint']['input'];
  readonly key_values_key: Scalars['String']['input'];
};

/** select columns of table "group_of_tariff_zones_key_values" */
export enum StopsDatabaseGroupOfTariffZonesKeyValuesSelectColumn {
  /** column name */
  GroupOfTariffZonesId = 'group_of_tariff_zones_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key'
}

/** input type for updating data in table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesSetInput = {
  readonly group_of_tariff_zones_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseGroupOfTariffZonesKeyValuesStddevFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_key_values_stddev_fields';
  readonly group_of_tariff_zones_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesStddevOrderBy = {
  readonly group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseGroupOfTariffZonesKeyValuesStddevPopFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_key_values_stddev_pop_fields';
  readonly group_of_tariff_zones_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesStddevPopOrderBy = {
  readonly group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseGroupOfTariffZonesKeyValuesStddevSampFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_key_values_stddev_samp_fields';
  readonly group_of_tariff_zones_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesStddevSampOrderBy = {
  readonly group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseGroupOfTariffZonesKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseGroupOfTariffZonesKeyValuesStreamCursorValueInput = {
  readonly group_of_tariff_zones_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseGroupOfTariffZonesKeyValuesSumFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_key_values_sum_fields';
  readonly group_of_tariff_zones_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesSumOrderBy = {
  readonly group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** update columns of table "group_of_tariff_zones_key_values" */
export enum StopsDatabaseGroupOfTariffZonesKeyValuesUpdateColumn {
  /** column name */
  GroupOfTariffZonesId = 'group_of_tariff_zones_id',
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key'
}

export type StopsDatabaseGroupOfTariffZonesKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseGroupOfTariffZonesKeyValuesVarPopFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_key_values_var_pop_fields';
  readonly group_of_tariff_zones_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesVarPopOrderBy = {
  readonly group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseGroupOfTariffZonesKeyValuesVarSampFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_key_values_var_samp_fields';
  readonly group_of_tariff_zones_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesVarSampOrderBy = {
  readonly group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseGroupOfTariffZonesKeyValuesVarianceFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_key_values_variance_fields';
  readonly group_of_tariff_zones_id?: Maybe<Scalars['Float']['output']>;
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "group_of_tariff_zones_key_values" */
export type StopsDatabaseGroupOfTariffZonesKeyValuesVarianceOrderBy = {
  readonly group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  readonly key_values_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseGroupOfTariffZonesMaxFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_max_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly purpose_of_grouping_ref?: Maybe<Scalars['String']['output']>;
  readonly purpose_of_grouping_ref_version?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** columns and relationships of "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembers = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_members';
  /** An object relationship */
  readonly group_of_tariff_zone: StopsDatabaseGroupOfTariffZones;
  readonly group_of_tariff_zones_id: Scalars['bigint']['output'];
  readonly ref: Scalars['String']['output'];
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersAggregate = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_members_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseGroupOfTariffZonesMembersAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembers>;
};

/** aggregate fields of "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersAggregateFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_members_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseGroupOfTariffZonesMembersAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseGroupOfTariffZonesMembersMaxFields>;
  readonly min?: Maybe<StopsDatabaseGroupOfTariffZonesMembersMinFields>;
  readonly stddev?: Maybe<StopsDatabaseGroupOfTariffZonesMembersStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseGroupOfTariffZonesMembersStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseGroupOfTariffZonesMembersStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseGroupOfTariffZonesMembersSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseGroupOfTariffZonesMembersVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseGroupOfTariffZonesMembersVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseGroupOfTariffZonesMembersVarianceFields>;
};


/** aggregate fields of "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembersInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseGroupOfTariffZonesMembersAvgFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_members_avg_fields';
  readonly group_of_tariff_zones_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersAvgOrderBy = {
  readonly group_of_tariff_zones_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "group_of_tariff_zones_members". All fields are combined with a logical 'AND'. */
export type StopsDatabaseGroupOfTariffZonesMembersBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembersBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembersBoolExp>>;
  readonly group_of_tariff_zone?: InputMaybe<StopsDatabaseGroupOfTariffZonesBoolExp>;
  readonly group_of_tariff_zones_id?: InputMaybe<BigintComparisonExp>;
  readonly ref?: InputMaybe<StringComparisonExp>;
  readonly version?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "group_of_tariff_zones_members" */
export enum StopsDatabaseGroupOfTariffZonesMembersConstraint {
  /** unique or primary key constraint on columns "ref", "group_of_tariff_zones_id" */
  GroupOfTariffZonesMembersPkey = 'group_of_tariff_zones_members_pkey'
}

/** input type for incrementing numeric columns in table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersIncInput = {
  readonly group_of_tariff_zones_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersInsertInput = {
  readonly group_of_tariff_zone?: InputMaybe<StopsDatabaseGroupOfTariffZonesObjRelInsertInput>;
  readonly group_of_tariff_zones_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly ref?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseGroupOfTariffZonesMembersMaxFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_members_max_fields';
  readonly group_of_tariff_zones_id?: Maybe<Scalars['bigint']['output']>;
  readonly ref?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersMaxOrderBy = {
  readonly group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  readonly ref?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseGroupOfTariffZonesMembersMinFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_members_min_fields';
  readonly group_of_tariff_zones_id?: Maybe<Scalars['bigint']['output']>;
  readonly ref?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersMinOrderBy = {
  readonly group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  readonly ref?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersMutationResponse = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_members_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembers>;
};

/** on_conflict condition type for table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersOnConflict = {
  readonly constraint: StopsDatabaseGroupOfTariffZonesMembersConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembersUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersBoolExp>;
};

/** Ordering options when selecting data from "group_of_tariff_zones_members". */
export type StopsDatabaseGroupOfTariffZonesMembersOrderBy = {
  readonly group_of_tariff_zone?: InputMaybe<StopsDatabaseGroupOfTariffZonesOrderBy>;
  readonly group_of_tariff_zones_id?: InputMaybe<OrderBy>;
  readonly ref?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: group_of_tariff_zones_members */
export type StopsDatabaseGroupOfTariffZonesMembersPkColumnsInput = {
  readonly group_of_tariff_zones_id: Scalars['bigint']['input'];
  readonly ref: Scalars['String']['input'];
};

/** select columns of table "group_of_tariff_zones_members" */
export enum StopsDatabaseGroupOfTariffZonesMembersSelectColumn {
  /** column name */
  GroupOfTariffZonesId = 'group_of_tariff_zones_id',
  /** column name */
  Ref = 'ref',
  /** column name */
  Version = 'version'
}

/** input type for updating data in table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersSetInput = {
  readonly group_of_tariff_zones_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly ref?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseGroupOfTariffZonesMembersStddevFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_members_stddev_fields';
  readonly group_of_tariff_zones_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersStddevOrderBy = {
  readonly group_of_tariff_zones_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseGroupOfTariffZonesMembersStddevPopFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_members_stddev_pop_fields';
  readonly group_of_tariff_zones_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersStddevPopOrderBy = {
  readonly group_of_tariff_zones_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseGroupOfTariffZonesMembersStddevSampFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_members_stddev_samp_fields';
  readonly group_of_tariff_zones_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersStddevSampOrderBy = {
  readonly group_of_tariff_zones_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseGroupOfTariffZonesMembersStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseGroupOfTariffZonesMembersStreamCursorValueInput = {
  readonly group_of_tariff_zones_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly ref?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseGroupOfTariffZonesMembersSumFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_members_sum_fields';
  readonly group_of_tariff_zones_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersSumOrderBy = {
  readonly group_of_tariff_zones_id?: InputMaybe<OrderBy>;
};

/** update columns of table "group_of_tariff_zones_members" */
export enum StopsDatabaseGroupOfTariffZonesMembersUpdateColumn {
  /** column name */
  GroupOfTariffZonesId = 'group_of_tariff_zones_id',
  /** column name */
  Ref = 'ref',
  /** column name */
  Version = 'version'
}

export type StopsDatabaseGroupOfTariffZonesMembersUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseGroupOfTariffZonesMembersBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseGroupOfTariffZonesMembersVarPopFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_members_var_pop_fields';
  readonly group_of_tariff_zones_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersVarPopOrderBy = {
  readonly group_of_tariff_zones_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseGroupOfTariffZonesMembersVarSampFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_members_var_samp_fields';
  readonly group_of_tariff_zones_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersVarSampOrderBy = {
  readonly group_of_tariff_zones_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseGroupOfTariffZonesMembersVarianceFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_members_variance_fields';
  readonly group_of_tariff_zones_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "group_of_tariff_zones_members" */
export type StopsDatabaseGroupOfTariffZonesMembersVarianceOrderBy = {
  readonly group_of_tariff_zones_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseGroupOfTariffZonesMinFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_min_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly purpose_of_grouping_ref?: Maybe<Scalars['String']['output']>;
  readonly purpose_of_grouping_ref_version?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesMutationResponse = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseGroupOfTariffZones>;
};

/** input type for inserting object relation for remote table "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesObjRelInsertInput = {
  readonly data: StopsDatabaseGroupOfTariffZonesInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseGroupOfTariffZonesOnConflict>;
};

/** on_conflict condition type for table "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesOnConflict = {
  readonly constraint: StopsDatabaseGroupOfTariffZonesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseGroupOfTariffZonesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseGroupOfTariffZonesBoolExp>;
};

/** Ordering options when selecting data from "group_of_tariff_zones". */
export type StopsDatabaseGroupOfTariffZonesOrderBy = {
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly description_lang?: InputMaybe<OrderBy>;
  readonly description_value?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly group_of_tariff_zones_key_values_aggregate?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesAggregateOrderBy>;
  readonly group_of_tariff_zones_members_aggregate?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersAggregateOrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly name_lang?: InputMaybe<OrderBy>;
  readonly name_value?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly private_code_type?: InputMaybe<OrderBy>;
  readonly private_code_value?: InputMaybe<OrderBy>;
  readonly purpose_of_grouping_ref?: InputMaybe<OrderBy>;
  readonly purpose_of_grouping_ref_version?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: group_of_tariff_zones */
export type StopsDatabaseGroupOfTariffZonesPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "group_of_tariff_zones" */
export enum StopsDatabaseGroupOfTariffZonesSelectColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  PurposeOfGroupingRef = 'purpose_of_grouping_ref',
  /** column name */
  PurposeOfGroupingRefVersion = 'purpose_of_grouping_ref_version',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

/** input type for updating data in table "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesSetInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly purpose_of_grouping_ref?: InputMaybe<Scalars['String']['input']>;
  readonly purpose_of_grouping_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseGroupOfTariffZonesStddevFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_stddev_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseGroupOfTariffZonesStddevPopFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseGroupOfTariffZonesStddevSampFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "group_of_tariff_zones" */
export type StopsDatabaseGroupOfTariffZonesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseGroupOfTariffZonesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseGroupOfTariffZonesStreamCursorValueInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly purpose_of_grouping_ref?: InputMaybe<Scalars['String']['input']>;
  readonly purpose_of_grouping_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseGroupOfTariffZonesSumFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_sum_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "group_of_tariff_zones" */
export enum StopsDatabaseGroupOfTariffZonesUpdateColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  PurposeOfGroupingRef = 'purpose_of_grouping_ref',
  /** column name */
  PurposeOfGroupingRefVersion = 'purpose_of_grouping_ref_version',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

export type StopsDatabaseGroupOfTariffZonesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseGroupOfTariffZonesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseGroupOfTariffZonesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseGroupOfTariffZonesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseGroupOfTariffZonesVarPopFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseGroupOfTariffZonesVarSampFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseGroupOfTariffZonesVarianceFields = {
  readonly __typename?: 'stops_database_group_of_tariff_zones_variance_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "hsl_accessibility_properties" */
export type StopsDatabaseHslAccessibilityProperties = {
  readonly __typename?: 'stops_database_hsl_accessibility_properties';
  /** Esteettömyystaso: Täysin esteetön (fullyAccessible) / Vähäisiä esteitä (mostlyAccessible) / Osittain esteellinen (partiallyInaccessible) / Esteellinen (inaccessible) / Esteettömyystietoja puuttuu (unknown) */
  readonly accessibility_level: Scalars['String']['output'];
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  /** Reunakiven etäisyys kiskon selästä (cm) */
  readonly curb_back_of_rail_distance?: Maybe<Scalars['numeric']['output']>;
  /** Reunakiven etäisyys kiskon ajoreunasta (cm) */
  readonly curb_drive_side_of_rail_distance?: Maybe<Scalars['numeric']['output']>;
  /** Kaareva pysäkki */
  readonly curved_stop?: Maybe<Scalars['Boolean']['output']>;
  /** Päätyluiskan kaltevuus (%) */
  readonly end_ramp_slope?: Maybe<Scalars['numeric']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  /** Opasteraita */
  readonly guidance_stripe?: Maybe<Scalars['Boolean']['output']>;
  /** Opaslaatat */
  readonly guidance_tiles?: Maybe<Scalars['Boolean']['output']>;
  /** Opasteiden tyyppi: Pisteopaste (braille) / Ei opastetta (none) / Muu opastus (other) */
  readonly guidance_type?: Maybe<Scalars['String']['output']>;
  readonly id: Scalars['bigint']['output'];
  /** Alapienan korkeus (cm) */
  readonly lower_cleat_height?: Maybe<Scalars['numeric']['output']>;
  /** Kartan tyyppi: Kohokartta (tactile) / Ei karttaa (none) / Muu kartta (other) */
  readonly map_type?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  /** Suojatien luiskaus */
  readonly pedestrian_crossing_ramp_type?: Maybe<Scalars['String']['output']>;
  /** Pysäkkialueen varoitusalue */
  readonly platform_edge_warning_area?: Maybe<Scalars['Boolean']['output']>;
  /** Palvelualueen pituus (m) */
  readonly service_area_length?: Maybe<Scalars['numeric']['output']>;
  /** Palvelualueen raidoitus */
  readonly service_area_stripes?: Maybe<Scalars['Boolean']['output']>;
  /** Palvelualueen leveys (m) */
  readonly service_area_width?: Maybe<Scalars['numeric']['output']>;
  /** Katoksen ja ajoradan välinen leveys (cm) */
  readonly shelter_lane_distance?: Maybe<Scalars['numeric']['output']>;
  /** Katoksen tyyppi: Leveä (wide) / Kapea (narrow) / Muu (other) */
  readonly shelter_type?: Maybe<Scalars['String']['output']>;
  /** Esteetön yhteys jalkakäytävältä pysäkille */
  readonly sidewalk_accessible_connection?: Maybe<Scalars['Boolean']['output']>;
  /** Pysäkkialueen pituuskaltevuus (%) */
  readonly stop_area_lengthwise_slope?: Maybe<Scalars['numeric']['output']>;
  /** Pysäkkialueen sivukaltevuus (%) */
  readonly stop_area_side_slope?: Maybe<Scalars['numeric']['output']>;
  /** Pysäkin ympäristo: Esteellinen / Esteetön */
  readonly stop_area_surroundings_accessible?: Maybe<Scalars['Boolean']['output']>;
  /** Pysäkin korotus kiskon ajopintaan nähden (cm) */
  readonly stop_elevation_from_rail_top?: Maybe<Scalars['numeric']['output']>;
  /** Pysäkin korotus jalkakäytävään nähden (cm) */
  readonly stop_elevation_from_sidewalk?: Maybe<Scalars['numeric']['output']>;
  /** Pysäkin tyyppi: Syvennys (pullOut) / Uloke (busBulb) / Ajoradalla (inLane) / Muu (other) */
  readonly stop_type?: Maybe<Scalars['String']['output']>;
  /** Rakenteiden ja ajoradan välinen pienin leveys (cm) */
  readonly structure_lane_distance?: Maybe<Scalars['numeric']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "hsl_accessibility_properties" */
export type StopsDatabaseHslAccessibilityPropertiesAggregate = {
  readonly __typename?: 'stops_database_hsl_accessibility_properties_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseHslAccessibilityPropertiesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseHslAccessibilityProperties>;
};

/** aggregate fields of "hsl_accessibility_properties" */
export type StopsDatabaseHslAccessibilityPropertiesAggregateFields = {
  readonly __typename?: 'stops_database_hsl_accessibility_properties_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseHslAccessibilityPropertiesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseHslAccessibilityPropertiesMaxFields>;
  readonly min?: Maybe<StopsDatabaseHslAccessibilityPropertiesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseHslAccessibilityPropertiesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseHslAccessibilityPropertiesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseHslAccessibilityPropertiesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseHslAccessibilityPropertiesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseHslAccessibilityPropertiesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseHslAccessibilityPropertiesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseHslAccessibilityPropertiesVarianceFields>;
};


/** aggregate fields of "hsl_accessibility_properties" */
export type StopsDatabaseHslAccessibilityPropertiesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseHslAccessibilityPropertiesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseHslAccessibilityPropertiesAvgFields = {
  readonly __typename?: 'stops_database_hsl_accessibility_properties_avg_fields';
  /** Reunakiven etäisyys kiskon selästä (cm) */
  readonly curb_back_of_rail_distance?: Maybe<Scalars['Float']['output']>;
  /** Reunakiven etäisyys kiskon ajoreunasta (cm) */
  readonly curb_drive_side_of_rail_distance?: Maybe<Scalars['Float']['output']>;
  /** Päätyluiskan kaltevuus (%) */
  readonly end_ramp_slope?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  /** Alapienan korkeus (cm) */
  readonly lower_cleat_height?: Maybe<Scalars['Float']['output']>;
  /** Palvelualueen pituus (m) */
  readonly service_area_length?: Maybe<Scalars['Float']['output']>;
  /** Palvelualueen leveys (m) */
  readonly service_area_width?: Maybe<Scalars['Float']['output']>;
  /** Katoksen ja ajoradan välinen leveys (cm) */
  readonly shelter_lane_distance?: Maybe<Scalars['Float']['output']>;
  /** Pysäkkialueen pituuskaltevuus (%) */
  readonly stop_area_lengthwise_slope?: Maybe<Scalars['Float']['output']>;
  /** Pysäkkialueen sivukaltevuus (%) */
  readonly stop_area_side_slope?: Maybe<Scalars['Float']['output']>;
  /** Pysäkin korotus kiskon ajopintaan nähden (cm) */
  readonly stop_elevation_from_rail_top?: Maybe<Scalars['Float']['output']>;
  /** Pysäkin korotus jalkakäytävään nähden (cm) */
  readonly stop_elevation_from_sidewalk?: Maybe<Scalars['Float']['output']>;
  /** Rakenteiden ja ajoradan välinen pienin leveys (cm) */
  readonly structure_lane_distance?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "hsl_accessibility_properties". All fields are combined with a logical 'AND'. */
export type StopsDatabaseHslAccessibilityPropertiesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseHslAccessibilityPropertiesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseHslAccessibilityPropertiesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseHslAccessibilityPropertiesBoolExp>>;
  readonly accessibility_level?: InputMaybe<StringComparisonExp>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly curb_back_of_rail_distance?: InputMaybe<NumericComparisonExp>;
  readonly curb_drive_side_of_rail_distance?: InputMaybe<NumericComparisonExp>;
  readonly curved_stop?: InputMaybe<BooleanComparisonExp>;
  readonly end_ramp_slope?: InputMaybe<NumericComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly guidance_stripe?: InputMaybe<BooleanComparisonExp>;
  readonly guidance_tiles?: InputMaybe<BooleanComparisonExp>;
  readonly guidance_type?: InputMaybe<StringComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly lower_cleat_height?: InputMaybe<NumericComparisonExp>;
  readonly map_type?: InputMaybe<StringComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly pedestrian_crossing_ramp_type?: InputMaybe<StringComparisonExp>;
  readonly platform_edge_warning_area?: InputMaybe<BooleanComparisonExp>;
  readonly service_area_length?: InputMaybe<NumericComparisonExp>;
  readonly service_area_stripes?: InputMaybe<BooleanComparisonExp>;
  readonly service_area_width?: InputMaybe<NumericComparisonExp>;
  readonly shelter_lane_distance?: InputMaybe<NumericComparisonExp>;
  readonly shelter_type?: InputMaybe<StringComparisonExp>;
  readonly sidewalk_accessible_connection?: InputMaybe<BooleanComparisonExp>;
  readonly stop_area_lengthwise_slope?: InputMaybe<NumericComparisonExp>;
  readonly stop_area_side_slope?: InputMaybe<NumericComparisonExp>;
  readonly stop_area_surroundings_accessible?: InputMaybe<BooleanComparisonExp>;
  readonly stop_elevation_from_rail_top?: InputMaybe<NumericComparisonExp>;
  readonly stop_elevation_from_sidewalk?: InputMaybe<NumericComparisonExp>;
  readonly stop_type?: InputMaybe<StringComparisonExp>;
  readonly structure_lane_distance?: InputMaybe<NumericComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "hsl_accessibility_properties" */
export enum StopsDatabaseHslAccessibilityPropertiesConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  HslAccessibilityPropertiesNetexIdVersionConstraint = 'hsl_accessibility_properties_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  HslAccessibilityPropertiesPkey = 'hsl_accessibility_properties_pkey'
}

/** input type for incrementing numeric columns in table "hsl_accessibility_properties" */
export type StopsDatabaseHslAccessibilityPropertiesIncInput = {
  /** Reunakiven etäisyys kiskon selästä (cm) */
  readonly curb_back_of_rail_distance?: InputMaybe<Scalars['numeric']['input']>;
  /** Reunakiven etäisyys kiskon ajoreunasta (cm) */
  readonly curb_drive_side_of_rail_distance?: InputMaybe<Scalars['numeric']['input']>;
  /** Päätyluiskan kaltevuus (%) */
  readonly end_ramp_slope?: InputMaybe<Scalars['numeric']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  /** Alapienan korkeus (cm) */
  readonly lower_cleat_height?: InputMaybe<Scalars['numeric']['input']>;
  /** Palvelualueen pituus (m) */
  readonly service_area_length?: InputMaybe<Scalars['numeric']['input']>;
  /** Palvelualueen leveys (m) */
  readonly service_area_width?: InputMaybe<Scalars['numeric']['input']>;
  /** Katoksen ja ajoradan välinen leveys (cm) */
  readonly shelter_lane_distance?: InputMaybe<Scalars['numeric']['input']>;
  /** Pysäkkialueen pituuskaltevuus (%) */
  readonly stop_area_lengthwise_slope?: InputMaybe<Scalars['numeric']['input']>;
  /** Pysäkkialueen sivukaltevuus (%) */
  readonly stop_area_side_slope?: InputMaybe<Scalars['numeric']['input']>;
  /** Pysäkin korotus kiskon ajopintaan nähden (cm) */
  readonly stop_elevation_from_rail_top?: InputMaybe<Scalars['numeric']['input']>;
  /** Pysäkin korotus jalkakäytävään nähden (cm) */
  readonly stop_elevation_from_sidewalk?: InputMaybe<Scalars['numeric']['input']>;
  /** Rakenteiden ja ajoradan välinen pienin leveys (cm) */
  readonly structure_lane_distance?: InputMaybe<Scalars['numeric']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "hsl_accessibility_properties" */
export type StopsDatabaseHslAccessibilityPropertiesInsertInput = {
  /** Esteettömyystaso: Täysin esteetön (fullyAccessible) / Vähäisiä esteitä (mostlyAccessible) / Osittain esteellinen (partiallyInaccessible) / Esteellinen (inaccessible) / Esteettömyystietoja puuttuu (unknown) */
  readonly accessibility_level?: InputMaybe<Scalars['String']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  /** Reunakiven etäisyys kiskon selästä (cm) */
  readonly curb_back_of_rail_distance?: InputMaybe<Scalars['numeric']['input']>;
  /** Reunakiven etäisyys kiskon ajoreunasta (cm) */
  readonly curb_drive_side_of_rail_distance?: InputMaybe<Scalars['numeric']['input']>;
  /** Kaareva pysäkki */
  readonly curved_stop?: InputMaybe<Scalars['Boolean']['input']>;
  /** Päätyluiskan kaltevuus (%) */
  readonly end_ramp_slope?: InputMaybe<Scalars['numeric']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  /** Opasteraita */
  readonly guidance_stripe?: InputMaybe<Scalars['Boolean']['input']>;
  /** Opaslaatat */
  readonly guidance_tiles?: InputMaybe<Scalars['Boolean']['input']>;
  /** Opasteiden tyyppi: Pisteopaste (braille) / Ei opastetta (none) / Muu opastus (other) */
  readonly guidance_type?: InputMaybe<Scalars['String']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  /** Alapienan korkeus (cm) */
  readonly lower_cleat_height?: InputMaybe<Scalars['numeric']['input']>;
  /** Kartan tyyppi: Kohokartta (tactile) / Ei karttaa (none) / Muu kartta (other) */
  readonly map_type?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  /** Suojatien luiskaus */
  readonly pedestrian_crossing_ramp_type?: InputMaybe<Scalars['String']['input']>;
  /** Pysäkkialueen varoitusalue */
  readonly platform_edge_warning_area?: InputMaybe<Scalars['Boolean']['input']>;
  /** Palvelualueen pituus (m) */
  readonly service_area_length?: InputMaybe<Scalars['numeric']['input']>;
  /** Palvelualueen raidoitus */
  readonly service_area_stripes?: InputMaybe<Scalars['Boolean']['input']>;
  /** Palvelualueen leveys (m) */
  readonly service_area_width?: InputMaybe<Scalars['numeric']['input']>;
  /** Katoksen ja ajoradan välinen leveys (cm) */
  readonly shelter_lane_distance?: InputMaybe<Scalars['numeric']['input']>;
  /** Katoksen tyyppi: Leveä (wide) / Kapea (narrow) / Muu (other) */
  readonly shelter_type?: InputMaybe<Scalars['String']['input']>;
  /** Esteetön yhteys jalkakäytävältä pysäkille */
  readonly sidewalk_accessible_connection?: InputMaybe<Scalars['Boolean']['input']>;
  /** Pysäkkialueen pituuskaltevuus (%) */
  readonly stop_area_lengthwise_slope?: InputMaybe<Scalars['numeric']['input']>;
  /** Pysäkkialueen sivukaltevuus (%) */
  readonly stop_area_side_slope?: InputMaybe<Scalars['numeric']['input']>;
  /** Pysäkin ympäristo: Esteellinen / Esteetön */
  readonly stop_area_surroundings_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  /** Pysäkin korotus kiskon ajopintaan nähden (cm) */
  readonly stop_elevation_from_rail_top?: InputMaybe<Scalars['numeric']['input']>;
  /** Pysäkin korotus jalkakäytävään nähden (cm) */
  readonly stop_elevation_from_sidewalk?: InputMaybe<Scalars['numeric']['input']>;
  /** Pysäkin tyyppi: Syvennys (pullOut) / Uloke (busBulb) / Ajoradalla (inLane) / Muu (other) */
  readonly stop_type?: InputMaybe<Scalars['String']['input']>;
  /** Rakenteiden ja ajoradan välinen pienin leveys (cm) */
  readonly structure_lane_distance?: InputMaybe<Scalars['numeric']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseHslAccessibilityPropertiesMaxFields = {
  readonly __typename?: 'stops_database_hsl_accessibility_properties_max_fields';
  /** Esteettömyystaso: Täysin esteetön (fullyAccessible) / Vähäisiä esteitä (mostlyAccessible) / Osittain esteellinen (partiallyInaccessible) / Esteellinen (inaccessible) / Esteettömyystietoja puuttuu (unknown) */
  readonly accessibility_level?: Maybe<Scalars['String']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  /** Reunakiven etäisyys kiskon selästä (cm) */
  readonly curb_back_of_rail_distance?: Maybe<Scalars['numeric']['output']>;
  /** Reunakiven etäisyys kiskon ajoreunasta (cm) */
  readonly curb_drive_side_of_rail_distance?: Maybe<Scalars['numeric']['output']>;
  /** Päätyluiskan kaltevuus (%) */
  readonly end_ramp_slope?: Maybe<Scalars['numeric']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  /** Opasteiden tyyppi: Pisteopaste (braille) / Ei opastetta (none) / Muu opastus (other) */
  readonly guidance_type?: Maybe<Scalars['String']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  /** Alapienan korkeus (cm) */
  readonly lower_cleat_height?: Maybe<Scalars['numeric']['output']>;
  /** Kartan tyyppi: Kohokartta (tactile) / Ei karttaa (none) / Muu kartta (other) */
  readonly map_type?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  /** Suojatien luiskaus */
  readonly pedestrian_crossing_ramp_type?: Maybe<Scalars['String']['output']>;
  /** Palvelualueen pituus (m) */
  readonly service_area_length?: Maybe<Scalars['numeric']['output']>;
  /** Palvelualueen leveys (m) */
  readonly service_area_width?: Maybe<Scalars['numeric']['output']>;
  /** Katoksen ja ajoradan välinen leveys (cm) */
  readonly shelter_lane_distance?: Maybe<Scalars['numeric']['output']>;
  /** Katoksen tyyppi: Leveä (wide) / Kapea (narrow) / Muu (other) */
  readonly shelter_type?: Maybe<Scalars['String']['output']>;
  /** Pysäkkialueen pituuskaltevuus (%) */
  readonly stop_area_lengthwise_slope?: Maybe<Scalars['numeric']['output']>;
  /** Pysäkkialueen sivukaltevuus (%) */
  readonly stop_area_side_slope?: Maybe<Scalars['numeric']['output']>;
  /** Pysäkin korotus kiskon ajopintaan nähden (cm) */
  readonly stop_elevation_from_rail_top?: Maybe<Scalars['numeric']['output']>;
  /** Pysäkin korotus jalkakäytävään nähden (cm) */
  readonly stop_elevation_from_sidewalk?: Maybe<Scalars['numeric']['output']>;
  /** Pysäkin tyyppi: Syvennys (pullOut) / Uloke (busBulb) / Ajoradalla (inLane) / Muu (other) */
  readonly stop_type?: Maybe<Scalars['String']['output']>;
  /** Rakenteiden ja ajoradan välinen pienin leveys (cm) */
  readonly structure_lane_distance?: Maybe<Scalars['numeric']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseHslAccessibilityPropertiesMinFields = {
  readonly __typename?: 'stops_database_hsl_accessibility_properties_min_fields';
  /** Esteettömyystaso: Täysin esteetön (fullyAccessible) / Vähäisiä esteitä (mostlyAccessible) / Osittain esteellinen (partiallyInaccessible) / Esteellinen (inaccessible) / Esteettömyystietoja puuttuu (unknown) */
  readonly accessibility_level?: Maybe<Scalars['String']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  /** Reunakiven etäisyys kiskon selästä (cm) */
  readonly curb_back_of_rail_distance?: Maybe<Scalars['numeric']['output']>;
  /** Reunakiven etäisyys kiskon ajoreunasta (cm) */
  readonly curb_drive_side_of_rail_distance?: Maybe<Scalars['numeric']['output']>;
  /** Päätyluiskan kaltevuus (%) */
  readonly end_ramp_slope?: Maybe<Scalars['numeric']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  /** Opasteiden tyyppi: Pisteopaste (braille) / Ei opastetta (none) / Muu opastus (other) */
  readonly guidance_type?: Maybe<Scalars['String']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  /** Alapienan korkeus (cm) */
  readonly lower_cleat_height?: Maybe<Scalars['numeric']['output']>;
  /** Kartan tyyppi: Kohokartta (tactile) / Ei karttaa (none) / Muu kartta (other) */
  readonly map_type?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  /** Suojatien luiskaus */
  readonly pedestrian_crossing_ramp_type?: Maybe<Scalars['String']['output']>;
  /** Palvelualueen pituus (m) */
  readonly service_area_length?: Maybe<Scalars['numeric']['output']>;
  /** Palvelualueen leveys (m) */
  readonly service_area_width?: Maybe<Scalars['numeric']['output']>;
  /** Katoksen ja ajoradan välinen leveys (cm) */
  readonly shelter_lane_distance?: Maybe<Scalars['numeric']['output']>;
  /** Katoksen tyyppi: Leveä (wide) / Kapea (narrow) / Muu (other) */
  readonly shelter_type?: Maybe<Scalars['String']['output']>;
  /** Pysäkkialueen pituuskaltevuus (%) */
  readonly stop_area_lengthwise_slope?: Maybe<Scalars['numeric']['output']>;
  /** Pysäkkialueen sivukaltevuus (%) */
  readonly stop_area_side_slope?: Maybe<Scalars['numeric']['output']>;
  /** Pysäkin korotus kiskon ajopintaan nähden (cm) */
  readonly stop_elevation_from_rail_top?: Maybe<Scalars['numeric']['output']>;
  /** Pysäkin korotus jalkakäytävään nähden (cm) */
  readonly stop_elevation_from_sidewalk?: Maybe<Scalars['numeric']['output']>;
  /** Pysäkin tyyppi: Syvennys (pullOut) / Uloke (busBulb) / Ajoradalla (inLane) / Muu (other) */
  readonly stop_type?: Maybe<Scalars['String']['output']>;
  /** Rakenteiden ja ajoradan välinen pienin leveys (cm) */
  readonly structure_lane_distance?: Maybe<Scalars['numeric']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "hsl_accessibility_properties" */
export type StopsDatabaseHslAccessibilityPropertiesMutationResponse = {
  readonly __typename?: 'stops_database_hsl_accessibility_properties_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseHslAccessibilityProperties>;
};

/** on_conflict condition type for table "hsl_accessibility_properties" */
export type StopsDatabaseHslAccessibilityPropertiesOnConflict = {
  readonly constraint: StopsDatabaseHslAccessibilityPropertiesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseHslAccessibilityPropertiesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseHslAccessibilityPropertiesBoolExp>;
};

/** Ordering options when selecting data from "hsl_accessibility_properties". */
export type StopsDatabaseHslAccessibilityPropertiesOrderBy = {
  readonly accessibility_level?: InputMaybe<OrderBy>;
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly curb_back_of_rail_distance?: InputMaybe<OrderBy>;
  readonly curb_drive_side_of_rail_distance?: InputMaybe<OrderBy>;
  readonly curved_stop?: InputMaybe<OrderBy>;
  readonly end_ramp_slope?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly guidance_stripe?: InputMaybe<OrderBy>;
  readonly guidance_tiles?: InputMaybe<OrderBy>;
  readonly guidance_type?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly lower_cleat_height?: InputMaybe<OrderBy>;
  readonly map_type?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly pedestrian_crossing_ramp_type?: InputMaybe<OrderBy>;
  readonly platform_edge_warning_area?: InputMaybe<OrderBy>;
  readonly service_area_length?: InputMaybe<OrderBy>;
  readonly service_area_stripes?: InputMaybe<OrderBy>;
  readonly service_area_width?: InputMaybe<OrderBy>;
  readonly shelter_lane_distance?: InputMaybe<OrderBy>;
  readonly shelter_type?: InputMaybe<OrderBy>;
  readonly sidewalk_accessible_connection?: InputMaybe<OrderBy>;
  readonly stop_area_lengthwise_slope?: InputMaybe<OrderBy>;
  readonly stop_area_side_slope?: InputMaybe<OrderBy>;
  readonly stop_area_surroundings_accessible?: InputMaybe<OrderBy>;
  readonly stop_elevation_from_rail_top?: InputMaybe<OrderBy>;
  readonly stop_elevation_from_sidewalk?: InputMaybe<OrderBy>;
  readonly stop_type?: InputMaybe<OrderBy>;
  readonly structure_lane_distance?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: hsl_accessibility_properties */
export type StopsDatabaseHslAccessibilityPropertiesPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "hsl_accessibility_properties" */
export enum StopsDatabaseHslAccessibilityPropertiesSelectColumn {
  /** column name */
  AccessibilityLevel = 'accessibility_level',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  CurbBackOfRailDistance = 'curb_back_of_rail_distance',
  /** column name */
  CurbDriveSideOfRailDistance = 'curb_drive_side_of_rail_distance',
  /** column name */
  CurvedStop = 'curved_stop',
  /** column name */
  EndRampSlope = 'end_ramp_slope',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  GuidanceStripe = 'guidance_stripe',
  /** column name */
  GuidanceTiles = 'guidance_tiles',
  /** column name */
  GuidanceType = 'guidance_type',
  /** column name */
  Id = 'id',
  /** column name */
  LowerCleatHeight = 'lower_cleat_height',
  /** column name */
  MapType = 'map_type',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PedestrianCrossingRampType = 'pedestrian_crossing_ramp_type',
  /** column name */
  PlatformEdgeWarningArea = 'platform_edge_warning_area',
  /** column name */
  ServiceAreaLength = 'service_area_length',
  /** column name */
  ServiceAreaStripes = 'service_area_stripes',
  /** column name */
  ServiceAreaWidth = 'service_area_width',
  /** column name */
  ShelterLaneDistance = 'shelter_lane_distance',
  /** column name */
  ShelterType = 'shelter_type',
  /** column name */
  SidewalkAccessibleConnection = 'sidewalk_accessible_connection',
  /** column name */
  StopAreaLengthwiseSlope = 'stop_area_lengthwise_slope',
  /** column name */
  StopAreaSideSlope = 'stop_area_side_slope',
  /** column name */
  StopAreaSurroundingsAccessible = 'stop_area_surroundings_accessible',
  /** column name */
  StopElevationFromRailTop = 'stop_elevation_from_rail_top',
  /** column name */
  StopElevationFromSidewalk = 'stop_elevation_from_sidewalk',
  /** column name */
  StopType = 'stop_type',
  /** column name */
  StructureLaneDistance = 'structure_lane_distance',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

/** input type for updating data in table "hsl_accessibility_properties" */
export type StopsDatabaseHslAccessibilityPropertiesSetInput = {
  /** Esteettömyystaso: Täysin esteetön (fullyAccessible) / Vähäisiä esteitä (mostlyAccessible) / Osittain esteellinen (partiallyInaccessible) / Esteellinen (inaccessible) / Esteettömyystietoja puuttuu (unknown) */
  readonly accessibility_level?: InputMaybe<Scalars['String']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  /** Reunakiven etäisyys kiskon selästä (cm) */
  readonly curb_back_of_rail_distance?: InputMaybe<Scalars['numeric']['input']>;
  /** Reunakiven etäisyys kiskon ajoreunasta (cm) */
  readonly curb_drive_side_of_rail_distance?: InputMaybe<Scalars['numeric']['input']>;
  /** Kaareva pysäkki */
  readonly curved_stop?: InputMaybe<Scalars['Boolean']['input']>;
  /** Päätyluiskan kaltevuus (%) */
  readonly end_ramp_slope?: InputMaybe<Scalars['numeric']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  /** Opasteraita */
  readonly guidance_stripe?: InputMaybe<Scalars['Boolean']['input']>;
  /** Opaslaatat */
  readonly guidance_tiles?: InputMaybe<Scalars['Boolean']['input']>;
  /** Opasteiden tyyppi: Pisteopaste (braille) / Ei opastetta (none) / Muu opastus (other) */
  readonly guidance_type?: InputMaybe<Scalars['String']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  /** Alapienan korkeus (cm) */
  readonly lower_cleat_height?: InputMaybe<Scalars['numeric']['input']>;
  /** Kartan tyyppi: Kohokartta (tactile) / Ei karttaa (none) / Muu kartta (other) */
  readonly map_type?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  /** Suojatien luiskaus */
  readonly pedestrian_crossing_ramp_type?: InputMaybe<Scalars['String']['input']>;
  /** Pysäkkialueen varoitusalue */
  readonly platform_edge_warning_area?: InputMaybe<Scalars['Boolean']['input']>;
  /** Palvelualueen pituus (m) */
  readonly service_area_length?: InputMaybe<Scalars['numeric']['input']>;
  /** Palvelualueen raidoitus */
  readonly service_area_stripes?: InputMaybe<Scalars['Boolean']['input']>;
  /** Palvelualueen leveys (m) */
  readonly service_area_width?: InputMaybe<Scalars['numeric']['input']>;
  /** Katoksen ja ajoradan välinen leveys (cm) */
  readonly shelter_lane_distance?: InputMaybe<Scalars['numeric']['input']>;
  /** Katoksen tyyppi: Leveä (wide) / Kapea (narrow) / Muu (other) */
  readonly shelter_type?: InputMaybe<Scalars['String']['input']>;
  /** Esteetön yhteys jalkakäytävältä pysäkille */
  readonly sidewalk_accessible_connection?: InputMaybe<Scalars['Boolean']['input']>;
  /** Pysäkkialueen pituuskaltevuus (%) */
  readonly stop_area_lengthwise_slope?: InputMaybe<Scalars['numeric']['input']>;
  /** Pysäkkialueen sivukaltevuus (%) */
  readonly stop_area_side_slope?: InputMaybe<Scalars['numeric']['input']>;
  /** Pysäkin ympäristo: Esteellinen / Esteetön */
  readonly stop_area_surroundings_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  /** Pysäkin korotus kiskon ajopintaan nähden (cm) */
  readonly stop_elevation_from_rail_top?: InputMaybe<Scalars['numeric']['input']>;
  /** Pysäkin korotus jalkakäytävään nähden (cm) */
  readonly stop_elevation_from_sidewalk?: InputMaybe<Scalars['numeric']['input']>;
  /** Pysäkin tyyppi: Syvennys (pullOut) / Uloke (busBulb) / Ajoradalla (inLane) / Muu (other) */
  readonly stop_type?: InputMaybe<Scalars['String']['input']>;
  /** Rakenteiden ja ajoradan välinen pienin leveys (cm) */
  readonly structure_lane_distance?: InputMaybe<Scalars['numeric']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseHslAccessibilityPropertiesStddevFields = {
  readonly __typename?: 'stops_database_hsl_accessibility_properties_stddev_fields';
  /** Reunakiven etäisyys kiskon selästä (cm) */
  readonly curb_back_of_rail_distance?: Maybe<Scalars['Float']['output']>;
  /** Reunakiven etäisyys kiskon ajoreunasta (cm) */
  readonly curb_drive_side_of_rail_distance?: Maybe<Scalars['Float']['output']>;
  /** Päätyluiskan kaltevuus (%) */
  readonly end_ramp_slope?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  /** Alapienan korkeus (cm) */
  readonly lower_cleat_height?: Maybe<Scalars['Float']['output']>;
  /** Palvelualueen pituus (m) */
  readonly service_area_length?: Maybe<Scalars['Float']['output']>;
  /** Palvelualueen leveys (m) */
  readonly service_area_width?: Maybe<Scalars['Float']['output']>;
  /** Katoksen ja ajoradan välinen leveys (cm) */
  readonly shelter_lane_distance?: Maybe<Scalars['Float']['output']>;
  /** Pysäkkialueen pituuskaltevuus (%) */
  readonly stop_area_lengthwise_slope?: Maybe<Scalars['Float']['output']>;
  /** Pysäkkialueen sivukaltevuus (%) */
  readonly stop_area_side_slope?: Maybe<Scalars['Float']['output']>;
  /** Pysäkin korotus kiskon ajopintaan nähden (cm) */
  readonly stop_elevation_from_rail_top?: Maybe<Scalars['Float']['output']>;
  /** Pysäkin korotus jalkakäytävään nähden (cm) */
  readonly stop_elevation_from_sidewalk?: Maybe<Scalars['Float']['output']>;
  /** Rakenteiden ja ajoradan välinen pienin leveys (cm) */
  readonly structure_lane_distance?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseHslAccessibilityPropertiesStddevPopFields = {
  readonly __typename?: 'stops_database_hsl_accessibility_properties_stddev_pop_fields';
  /** Reunakiven etäisyys kiskon selästä (cm) */
  readonly curb_back_of_rail_distance?: Maybe<Scalars['Float']['output']>;
  /** Reunakiven etäisyys kiskon ajoreunasta (cm) */
  readonly curb_drive_side_of_rail_distance?: Maybe<Scalars['Float']['output']>;
  /** Päätyluiskan kaltevuus (%) */
  readonly end_ramp_slope?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  /** Alapienan korkeus (cm) */
  readonly lower_cleat_height?: Maybe<Scalars['Float']['output']>;
  /** Palvelualueen pituus (m) */
  readonly service_area_length?: Maybe<Scalars['Float']['output']>;
  /** Palvelualueen leveys (m) */
  readonly service_area_width?: Maybe<Scalars['Float']['output']>;
  /** Katoksen ja ajoradan välinen leveys (cm) */
  readonly shelter_lane_distance?: Maybe<Scalars['Float']['output']>;
  /** Pysäkkialueen pituuskaltevuus (%) */
  readonly stop_area_lengthwise_slope?: Maybe<Scalars['Float']['output']>;
  /** Pysäkkialueen sivukaltevuus (%) */
  readonly stop_area_side_slope?: Maybe<Scalars['Float']['output']>;
  /** Pysäkin korotus kiskon ajopintaan nähden (cm) */
  readonly stop_elevation_from_rail_top?: Maybe<Scalars['Float']['output']>;
  /** Pysäkin korotus jalkakäytävään nähden (cm) */
  readonly stop_elevation_from_sidewalk?: Maybe<Scalars['Float']['output']>;
  /** Rakenteiden ja ajoradan välinen pienin leveys (cm) */
  readonly structure_lane_distance?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseHslAccessibilityPropertiesStddevSampFields = {
  readonly __typename?: 'stops_database_hsl_accessibility_properties_stddev_samp_fields';
  /** Reunakiven etäisyys kiskon selästä (cm) */
  readonly curb_back_of_rail_distance?: Maybe<Scalars['Float']['output']>;
  /** Reunakiven etäisyys kiskon ajoreunasta (cm) */
  readonly curb_drive_side_of_rail_distance?: Maybe<Scalars['Float']['output']>;
  /** Päätyluiskan kaltevuus (%) */
  readonly end_ramp_slope?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  /** Alapienan korkeus (cm) */
  readonly lower_cleat_height?: Maybe<Scalars['Float']['output']>;
  /** Palvelualueen pituus (m) */
  readonly service_area_length?: Maybe<Scalars['Float']['output']>;
  /** Palvelualueen leveys (m) */
  readonly service_area_width?: Maybe<Scalars['Float']['output']>;
  /** Katoksen ja ajoradan välinen leveys (cm) */
  readonly shelter_lane_distance?: Maybe<Scalars['Float']['output']>;
  /** Pysäkkialueen pituuskaltevuus (%) */
  readonly stop_area_lengthwise_slope?: Maybe<Scalars['Float']['output']>;
  /** Pysäkkialueen sivukaltevuus (%) */
  readonly stop_area_side_slope?: Maybe<Scalars['Float']['output']>;
  /** Pysäkin korotus kiskon ajopintaan nähden (cm) */
  readonly stop_elevation_from_rail_top?: Maybe<Scalars['Float']['output']>;
  /** Pysäkin korotus jalkakäytävään nähden (cm) */
  readonly stop_elevation_from_sidewalk?: Maybe<Scalars['Float']['output']>;
  /** Rakenteiden ja ajoradan välinen pienin leveys (cm) */
  readonly structure_lane_distance?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "hsl_accessibility_properties" */
export type StopsDatabaseHslAccessibilityPropertiesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseHslAccessibilityPropertiesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseHslAccessibilityPropertiesStreamCursorValueInput = {
  /** Esteettömyystaso: Täysin esteetön (fullyAccessible) / Vähäisiä esteitä (mostlyAccessible) / Osittain esteellinen (partiallyInaccessible) / Esteellinen (inaccessible) / Esteettömyystietoja puuttuu (unknown) */
  readonly accessibility_level?: InputMaybe<Scalars['String']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  /** Reunakiven etäisyys kiskon selästä (cm) */
  readonly curb_back_of_rail_distance?: InputMaybe<Scalars['numeric']['input']>;
  /** Reunakiven etäisyys kiskon ajoreunasta (cm) */
  readonly curb_drive_side_of_rail_distance?: InputMaybe<Scalars['numeric']['input']>;
  /** Kaareva pysäkki */
  readonly curved_stop?: InputMaybe<Scalars['Boolean']['input']>;
  /** Päätyluiskan kaltevuus (%) */
  readonly end_ramp_slope?: InputMaybe<Scalars['numeric']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  /** Opasteraita */
  readonly guidance_stripe?: InputMaybe<Scalars['Boolean']['input']>;
  /** Opaslaatat */
  readonly guidance_tiles?: InputMaybe<Scalars['Boolean']['input']>;
  /** Opasteiden tyyppi: Pisteopaste (braille) / Ei opastetta (none) / Muu opastus (other) */
  readonly guidance_type?: InputMaybe<Scalars['String']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  /** Alapienan korkeus (cm) */
  readonly lower_cleat_height?: InputMaybe<Scalars['numeric']['input']>;
  /** Kartan tyyppi: Kohokartta (tactile) / Ei karttaa (none) / Muu kartta (other) */
  readonly map_type?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  /** Suojatien luiskaus */
  readonly pedestrian_crossing_ramp_type?: InputMaybe<Scalars['String']['input']>;
  /** Pysäkkialueen varoitusalue */
  readonly platform_edge_warning_area?: InputMaybe<Scalars['Boolean']['input']>;
  /** Palvelualueen pituus (m) */
  readonly service_area_length?: InputMaybe<Scalars['numeric']['input']>;
  /** Palvelualueen raidoitus */
  readonly service_area_stripes?: InputMaybe<Scalars['Boolean']['input']>;
  /** Palvelualueen leveys (m) */
  readonly service_area_width?: InputMaybe<Scalars['numeric']['input']>;
  /** Katoksen ja ajoradan välinen leveys (cm) */
  readonly shelter_lane_distance?: InputMaybe<Scalars['numeric']['input']>;
  /** Katoksen tyyppi: Leveä (wide) / Kapea (narrow) / Muu (other) */
  readonly shelter_type?: InputMaybe<Scalars['String']['input']>;
  /** Esteetön yhteys jalkakäytävältä pysäkille */
  readonly sidewalk_accessible_connection?: InputMaybe<Scalars['Boolean']['input']>;
  /** Pysäkkialueen pituuskaltevuus (%) */
  readonly stop_area_lengthwise_slope?: InputMaybe<Scalars['numeric']['input']>;
  /** Pysäkkialueen sivukaltevuus (%) */
  readonly stop_area_side_slope?: InputMaybe<Scalars['numeric']['input']>;
  /** Pysäkin ympäristo: Esteellinen / Esteetön */
  readonly stop_area_surroundings_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  /** Pysäkin korotus kiskon ajopintaan nähden (cm) */
  readonly stop_elevation_from_rail_top?: InputMaybe<Scalars['numeric']['input']>;
  /** Pysäkin korotus jalkakäytävään nähden (cm) */
  readonly stop_elevation_from_sidewalk?: InputMaybe<Scalars['numeric']['input']>;
  /** Pysäkin tyyppi: Syvennys (pullOut) / Uloke (busBulb) / Ajoradalla (inLane) / Muu (other) */
  readonly stop_type?: InputMaybe<Scalars['String']['input']>;
  /** Rakenteiden ja ajoradan välinen pienin leveys (cm) */
  readonly structure_lane_distance?: InputMaybe<Scalars['numeric']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseHslAccessibilityPropertiesSumFields = {
  readonly __typename?: 'stops_database_hsl_accessibility_properties_sum_fields';
  /** Reunakiven etäisyys kiskon selästä (cm) */
  readonly curb_back_of_rail_distance?: Maybe<Scalars['numeric']['output']>;
  /** Reunakiven etäisyys kiskon ajoreunasta (cm) */
  readonly curb_drive_side_of_rail_distance?: Maybe<Scalars['numeric']['output']>;
  /** Päätyluiskan kaltevuus (%) */
  readonly end_ramp_slope?: Maybe<Scalars['numeric']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  /** Alapienan korkeus (cm) */
  readonly lower_cleat_height?: Maybe<Scalars['numeric']['output']>;
  /** Palvelualueen pituus (m) */
  readonly service_area_length?: Maybe<Scalars['numeric']['output']>;
  /** Palvelualueen leveys (m) */
  readonly service_area_width?: Maybe<Scalars['numeric']['output']>;
  /** Katoksen ja ajoradan välinen leveys (cm) */
  readonly shelter_lane_distance?: Maybe<Scalars['numeric']['output']>;
  /** Pysäkkialueen pituuskaltevuus (%) */
  readonly stop_area_lengthwise_slope?: Maybe<Scalars['numeric']['output']>;
  /** Pysäkkialueen sivukaltevuus (%) */
  readonly stop_area_side_slope?: Maybe<Scalars['numeric']['output']>;
  /** Pysäkin korotus kiskon ajopintaan nähden (cm) */
  readonly stop_elevation_from_rail_top?: Maybe<Scalars['numeric']['output']>;
  /** Pysäkin korotus jalkakäytävään nähden (cm) */
  readonly stop_elevation_from_sidewalk?: Maybe<Scalars['numeric']['output']>;
  /** Rakenteiden ja ajoradan välinen pienin leveys (cm) */
  readonly structure_lane_distance?: Maybe<Scalars['numeric']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "hsl_accessibility_properties" */
export enum StopsDatabaseHslAccessibilityPropertiesUpdateColumn {
  /** column name */
  AccessibilityLevel = 'accessibility_level',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  CurbBackOfRailDistance = 'curb_back_of_rail_distance',
  /** column name */
  CurbDriveSideOfRailDistance = 'curb_drive_side_of_rail_distance',
  /** column name */
  CurvedStop = 'curved_stop',
  /** column name */
  EndRampSlope = 'end_ramp_slope',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  GuidanceStripe = 'guidance_stripe',
  /** column name */
  GuidanceTiles = 'guidance_tiles',
  /** column name */
  GuidanceType = 'guidance_type',
  /** column name */
  Id = 'id',
  /** column name */
  LowerCleatHeight = 'lower_cleat_height',
  /** column name */
  MapType = 'map_type',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PedestrianCrossingRampType = 'pedestrian_crossing_ramp_type',
  /** column name */
  PlatformEdgeWarningArea = 'platform_edge_warning_area',
  /** column name */
  ServiceAreaLength = 'service_area_length',
  /** column name */
  ServiceAreaStripes = 'service_area_stripes',
  /** column name */
  ServiceAreaWidth = 'service_area_width',
  /** column name */
  ShelterLaneDistance = 'shelter_lane_distance',
  /** column name */
  ShelterType = 'shelter_type',
  /** column name */
  SidewalkAccessibleConnection = 'sidewalk_accessible_connection',
  /** column name */
  StopAreaLengthwiseSlope = 'stop_area_lengthwise_slope',
  /** column name */
  StopAreaSideSlope = 'stop_area_side_slope',
  /** column name */
  StopAreaSurroundingsAccessible = 'stop_area_surroundings_accessible',
  /** column name */
  StopElevationFromRailTop = 'stop_elevation_from_rail_top',
  /** column name */
  StopElevationFromSidewalk = 'stop_elevation_from_sidewalk',
  /** column name */
  StopType = 'stop_type',
  /** column name */
  StructureLaneDistance = 'structure_lane_distance',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

export type StopsDatabaseHslAccessibilityPropertiesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseHslAccessibilityPropertiesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseHslAccessibilityPropertiesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseHslAccessibilityPropertiesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseHslAccessibilityPropertiesVarPopFields = {
  readonly __typename?: 'stops_database_hsl_accessibility_properties_var_pop_fields';
  /** Reunakiven etäisyys kiskon selästä (cm) */
  readonly curb_back_of_rail_distance?: Maybe<Scalars['Float']['output']>;
  /** Reunakiven etäisyys kiskon ajoreunasta (cm) */
  readonly curb_drive_side_of_rail_distance?: Maybe<Scalars['Float']['output']>;
  /** Päätyluiskan kaltevuus (%) */
  readonly end_ramp_slope?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  /** Alapienan korkeus (cm) */
  readonly lower_cleat_height?: Maybe<Scalars['Float']['output']>;
  /** Palvelualueen pituus (m) */
  readonly service_area_length?: Maybe<Scalars['Float']['output']>;
  /** Palvelualueen leveys (m) */
  readonly service_area_width?: Maybe<Scalars['Float']['output']>;
  /** Katoksen ja ajoradan välinen leveys (cm) */
  readonly shelter_lane_distance?: Maybe<Scalars['Float']['output']>;
  /** Pysäkkialueen pituuskaltevuus (%) */
  readonly stop_area_lengthwise_slope?: Maybe<Scalars['Float']['output']>;
  /** Pysäkkialueen sivukaltevuus (%) */
  readonly stop_area_side_slope?: Maybe<Scalars['Float']['output']>;
  /** Pysäkin korotus kiskon ajopintaan nähden (cm) */
  readonly stop_elevation_from_rail_top?: Maybe<Scalars['Float']['output']>;
  /** Pysäkin korotus jalkakäytävään nähden (cm) */
  readonly stop_elevation_from_sidewalk?: Maybe<Scalars['Float']['output']>;
  /** Rakenteiden ja ajoradan välinen pienin leveys (cm) */
  readonly structure_lane_distance?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseHslAccessibilityPropertiesVarSampFields = {
  readonly __typename?: 'stops_database_hsl_accessibility_properties_var_samp_fields';
  /** Reunakiven etäisyys kiskon selästä (cm) */
  readonly curb_back_of_rail_distance?: Maybe<Scalars['Float']['output']>;
  /** Reunakiven etäisyys kiskon ajoreunasta (cm) */
  readonly curb_drive_side_of_rail_distance?: Maybe<Scalars['Float']['output']>;
  /** Päätyluiskan kaltevuus (%) */
  readonly end_ramp_slope?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  /** Alapienan korkeus (cm) */
  readonly lower_cleat_height?: Maybe<Scalars['Float']['output']>;
  /** Palvelualueen pituus (m) */
  readonly service_area_length?: Maybe<Scalars['Float']['output']>;
  /** Palvelualueen leveys (m) */
  readonly service_area_width?: Maybe<Scalars['Float']['output']>;
  /** Katoksen ja ajoradan välinen leveys (cm) */
  readonly shelter_lane_distance?: Maybe<Scalars['Float']['output']>;
  /** Pysäkkialueen pituuskaltevuus (%) */
  readonly stop_area_lengthwise_slope?: Maybe<Scalars['Float']['output']>;
  /** Pysäkkialueen sivukaltevuus (%) */
  readonly stop_area_side_slope?: Maybe<Scalars['Float']['output']>;
  /** Pysäkin korotus kiskon ajopintaan nähden (cm) */
  readonly stop_elevation_from_rail_top?: Maybe<Scalars['Float']['output']>;
  /** Pysäkin korotus jalkakäytävään nähden (cm) */
  readonly stop_elevation_from_sidewalk?: Maybe<Scalars['Float']['output']>;
  /** Rakenteiden ja ajoradan välinen pienin leveys (cm) */
  readonly structure_lane_distance?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseHslAccessibilityPropertiesVarianceFields = {
  readonly __typename?: 'stops_database_hsl_accessibility_properties_variance_fields';
  /** Reunakiven etäisyys kiskon selästä (cm) */
  readonly curb_back_of_rail_distance?: Maybe<Scalars['Float']['output']>;
  /** Reunakiven etäisyys kiskon ajoreunasta (cm) */
  readonly curb_drive_side_of_rail_distance?: Maybe<Scalars['Float']['output']>;
  /** Päätyluiskan kaltevuus (%) */
  readonly end_ramp_slope?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  /** Alapienan korkeus (cm) */
  readonly lower_cleat_height?: Maybe<Scalars['Float']['output']>;
  /** Palvelualueen pituus (m) */
  readonly service_area_length?: Maybe<Scalars['Float']['output']>;
  /** Palvelualueen leveys (m) */
  readonly service_area_width?: Maybe<Scalars['Float']['output']>;
  /** Katoksen ja ajoradan välinen leveys (cm) */
  readonly shelter_lane_distance?: Maybe<Scalars['Float']['output']>;
  /** Pysäkkialueen pituuskaltevuus (%) */
  readonly stop_area_lengthwise_slope?: Maybe<Scalars['Float']['output']>;
  /** Pysäkkialueen sivukaltevuus (%) */
  readonly stop_area_side_slope?: Maybe<Scalars['Float']['output']>;
  /** Pysäkin korotus kiskon ajopintaan nähden (cm) */
  readonly stop_elevation_from_rail_top?: Maybe<Scalars['Float']['output']>;
  /** Pysäkin korotus jalkakäytävään nähden (cm) */
  readonly stop_elevation_from_sidewalk?: Maybe<Scalars['Float']['output']>;
  /** Rakenteiden ja ajoradan välinen pienin leveys (cm) */
  readonly structure_lane_distance?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "id_generator" */
export type StopsDatabaseIdGenerator = {
  readonly __typename?: 'stops_database_id_generator';
  readonly id_value?: Maybe<Scalars['bigint']['output']>;
  readonly table_name?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "id_generator" */
export type StopsDatabaseIdGeneratorAggregate = {
  readonly __typename?: 'stops_database_id_generator_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseIdGeneratorAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseIdGenerator>;
};

/** aggregate fields of "id_generator" */
export type StopsDatabaseIdGeneratorAggregateFields = {
  readonly __typename?: 'stops_database_id_generator_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseIdGeneratorAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseIdGeneratorMaxFields>;
  readonly min?: Maybe<StopsDatabaseIdGeneratorMinFields>;
  readonly stddev?: Maybe<StopsDatabaseIdGeneratorStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseIdGeneratorStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseIdGeneratorStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseIdGeneratorSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseIdGeneratorVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseIdGeneratorVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseIdGeneratorVarianceFields>;
};


/** aggregate fields of "id_generator" */
export type StopsDatabaseIdGeneratorAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseIdGeneratorSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseIdGeneratorAvgFields = {
  readonly __typename?: 'stops_database_id_generator_avg_fields';
  readonly id_value?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "id_generator". All fields are combined with a logical 'AND'. */
export type StopsDatabaseIdGeneratorBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseIdGeneratorBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseIdGeneratorBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseIdGeneratorBoolExp>>;
  readonly id_value?: InputMaybe<BigintComparisonExp>;
  readonly table_name?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "id_generator" */
export enum StopsDatabaseIdGeneratorConstraint {
  /** unique or primary key constraint on columns "table_name", "id_value" */
  IdConstraint = 'id_constraint'
}

/** input type for incrementing numeric columns in table "id_generator" */
export type StopsDatabaseIdGeneratorIncInput = {
  readonly id_value?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "id_generator" */
export type StopsDatabaseIdGeneratorInsertInput = {
  readonly id_value?: InputMaybe<Scalars['bigint']['input']>;
  readonly table_name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseIdGeneratorMaxFields = {
  readonly __typename?: 'stops_database_id_generator_max_fields';
  readonly id_value?: Maybe<Scalars['bigint']['output']>;
  readonly table_name?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseIdGeneratorMinFields = {
  readonly __typename?: 'stops_database_id_generator_min_fields';
  readonly id_value?: Maybe<Scalars['bigint']['output']>;
  readonly table_name?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "id_generator" */
export type StopsDatabaseIdGeneratorMutationResponse = {
  readonly __typename?: 'stops_database_id_generator_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseIdGenerator>;
};

/** on_conflict condition type for table "id_generator" */
export type StopsDatabaseIdGeneratorOnConflict = {
  readonly constraint: StopsDatabaseIdGeneratorConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseIdGeneratorUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseIdGeneratorBoolExp>;
};

/** Ordering options when selecting data from "id_generator". */
export type StopsDatabaseIdGeneratorOrderBy = {
  readonly id_value?: InputMaybe<OrderBy>;
  readonly table_name?: InputMaybe<OrderBy>;
};

/** select columns of table "id_generator" */
export enum StopsDatabaseIdGeneratorSelectColumn {
  /** column name */
  IdValue = 'id_value',
  /** column name */
  TableName = 'table_name'
}

/** input type for updating data in table "id_generator" */
export type StopsDatabaseIdGeneratorSetInput = {
  readonly id_value?: InputMaybe<Scalars['bigint']['input']>;
  readonly table_name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseIdGeneratorStddevFields = {
  readonly __typename?: 'stops_database_id_generator_stddev_fields';
  readonly id_value?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseIdGeneratorStddevPopFields = {
  readonly __typename?: 'stops_database_id_generator_stddev_pop_fields';
  readonly id_value?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseIdGeneratorStddevSampFields = {
  readonly __typename?: 'stops_database_id_generator_stddev_samp_fields';
  readonly id_value?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "id_generator" */
export type StopsDatabaseIdGeneratorStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseIdGeneratorStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseIdGeneratorStreamCursorValueInput = {
  readonly id_value?: InputMaybe<Scalars['bigint']['input']>;
  readonly table_name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseIdGeneratorSumFields = {
  readonly __typename?: 'stops_database_id_generator_sum_fields';
  readonly id_value?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "id_generator" */
export enum StopsDatabaseIdGeneratorUpdateColumn {
  /** column name */
  IdValue = 'id_value',
  /** column name */
  TableName = 'table_name'
}

export type StopsDatabaseIdGeneratorUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseIdGeneratorIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseIdGeneratorSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseIdGeneratorBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseIdGeneratorVarPopFields = {
  readonly __typename?: 'stops_database_id_generator_var_pop_fields';
  readonly id_value?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseIdGeneratorVarSampFields = {
  readonly __typename?: 'stops_database_id_generator_var_samp_fields';
  readonly id_value?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseIdGeneratorVarianceFields = {
  readonly __typename?: 'stops_database_id_generator_variance_fields';
  readonly id_value?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "info_spot" */
export type StopsDatabaseInfoSpot = {
  readonly __typename?: 'stops_database_info_spot';
  readonly backlight?: Maybe<Scalars['Boolean']['output']>;
  readonly centroid?: Maybe<Scalars['geometry']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly display_type?: Maybe<Scalars['String']['output']>;
  readonly floor?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly height?: Maybe<Scalars['Int']['output']>;
  readonly id: Scalars['bigint']['output'];
  readonly info_spot_location?: Maybe<Scalars['String']['output']>;
  readonly info_spot_type?: Maybe<Scalars['String']['output']>;
  readonly label?: Maybe<Scalars['String']['output']>;
  readonly maintenance?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly purpose?: Maybe<Scalars['String']['output']>;
  readonly rail_information?: Maybe<Scalars['String']['output']>;
  readonly speech_property?: Maybe<Scalars['Boolean']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly width?: Maybe<Scalars['Int']['output']>;
  readonly zone_label?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "info_spot" */
export type StopsDatabaseInfoSpotAggregate = {
  readonly __typename?: 'stops_database_info_spot_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseInfoSpotAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseInfoSpot>;
};

/** aggregate fields of "info_spot" */
export type StopsDatabaseInfoSpotAggregateFields = {
  readonly __typename?: 'stops_database_info_spot_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseInfoSpotAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseInfoSpotMaxFields>;
  readonly min?: Maybe<StopsDatabaseInfoSpotMinFields>;
  readonly stddev?: Maybe<StopsDatabaseInfoSpotStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseInfoSpotStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseInfoSpotStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseInfoSpotSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseInfoSpotVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseInfoSpotVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseInfoSpotVarianceFields>;
};


/** aggregate fields of "info_spot" */
export type StopsDatabaseInfoSpotAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseInfoSpotSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseInfoSpotAvgFields = {
  readonly __typename?: 'stops_database_info_spot_avg_fields';
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "info_spot". All fields are combined with a logical 'AND'. */
export type StopsDatabaseInfoSpotBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseInfoSpotBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseInfoSpotBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseInfoSpotBoolExp>>;
  readonly backlight?: InputMaybe<BooleanComparisonExp>;
  readonly centroid?: InputMaybe<GeometryComparisonExp>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly description_lang?: InputMaybe<StringComparisonExp>;
  readonly description_value?: InputMaybe<StringComparisonExp>;
  readonly display_type?: InputMaybe<StringComparisonExp>;
  readonly floor?: InputMaybe<StringComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly height?: InputMaybe<IntComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly info_spot_location?: InputMaybe<StringComparisonExp>;
  readonly info_spot_type?: InputMaybe<StringComparisonExp>;
  readonly label?: InputMaybe<StringComparisonExp>;
  readonly maintenance?: InputMaybe<StringComparisonExp>;
  readonly name_lang?: InputMaybe<StringComparisonExp>;
  readonly name_value?: InputMaybe<StringComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly polygon_id?: InputMaybe<BigintComparisonExp>;
  readonly private_code_type?: InputMaybe<StringComparisonExp>;
  readonly private_code_value?: InputMaybe<StringComparisonExp>;
  readonly purpose?: InputMaybe<StringComparisonExp>;
  readonly rail_information?: InputMaybe<StringComparisonExp>;
  readonly speech_property?: InputMaybe<BooleanComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
  readonly width?: InputMaybe<IntComparisonExp>;
  readonly zone_label?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "info_spot" */
export enum StopsDatabaseInfoSpotConstraint {
  /** unique or primary key constraint on columns "id" */
  InfoSpotPkey = 'info_spot_pkey'
}

/** input type for incrementing numeric columns in table "info_spot" */
export type StopsDatabaseInfoSpotIncInput = {
  readonly height?: InputMaybe<Scalars['Int']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly width?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "info_spot" */
export type StopsDatabaseInfoSpotInsertInput = {
  readonly backlight?: InputMaybe<Scalars['Boolean']['input']>;
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly display_type?: InputMaybe<Scalars['String']['input']>;
  readonly floor?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly height?: InputMaybe<Scalars['Int']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly info_spot_location?: InputMaybe<Scalars['String']['input']>;
  readonly info_spot_type?: InputMaybe<Scalars['String']['input']>;
  readonly label?: InputMaybe<Scalars['String']['input']>;
  readonly maintenance?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly purpose?: InputMaybe<Scalars['String']['input']>;
  readonly rail_information?: InputMaybe<Scalars['String']['input']>;
  readonly speech_property?: InputMaybe<Scalars['Boolean']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
  readonly width?: InputMaybe<Scalars['Int']['input']>;
  readonly zone_label?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseInfoSpotMaxFields = {
  readonly __typename?: 'stops_database_info_spot_max_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly display_type?: Maybe<Scalars['String']['output']>;
  readonly floor?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly height?: Maybe<Scalars['Int']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly info_spot_location?: Maybe<Scalars['String']['output']>;
  readonly info_spot_type?: Maybe<Scalars['String']['output']>;
  readonly label?: Maybe<Scalars['String']['output']>;
  readonly maintenance?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly purpose?: Maybe<Scalars['String']['output']>;
  readonly rail_information?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly width?: Maybe<Scalars['Int']['output']>;
  readonly zone_label?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseInfoSpotMinFields = {
  readonly __typename?: 'stops_database_info_spot_min_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly display_type?: Maybe<Scalars['String']['output']>;
  readonly floor?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly height?: Maybe<Scalars['Int']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly info_spot_location?: Maybe<Scalars['String']['output']>;
  readonly info_spot_type?: Maybe<Scalars['String']['output']>;
  readonly label?: Maybe<Scalars['String']['output']>;
  readonly maintenance?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly purpose?: Maybe<Scalars['String']['output']>;
  readonly rail_information?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly width?: Maybe<Scalars['Int']['output']>;
  readonly zone_label?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "info_spot" */
export type StopsDatabaseInfoSpotMutationResponse = {
  readonly __typename?: 'stops_database_info_spot_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseInfoSpot>;
};

/** on_conflict condition type for table "info_spot" */
export type StopsDatabaseInfoSpotOnConflict = {
  readonly constraint: StopsDatabaseInfoSpotConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseInfoSpotUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseInfoSpotBoolExp>;
};

/** Ordering options when selecting data from "info_spot". */
export type StopsDatabaseInfoSpotOrderBy = {
  readonly backlight?: InputMaybe<OrderBy>;
  readonly centroid?: InputMaybe<OrderBy>;
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly description_lang?: InputMaybe<OrderBy>;
  readonly description_value?: InputMaybe<OrderBy>;
  readonly display_type?: InputMaybe<OrderBy>;
  readonly floor?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly height?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly info_spot_location?: InputMaybe<OrderBy>;
  readonly info_spot_type?: InputMaybe<OrderBy>;
  readonly label?: InputMaybe<OrderBy>;
  readonly maintenance?: InputMaybe<OrderBy>;
  readonly name_lang?: InputMaybe<OrderBy>;
  readonly name_value?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly polygon_id?: InputMaybe<OrderBy>;
  readonly private_code_type?: InputMaybe<OrderBy>;
  readonly private_code_value?: InputMaybe<OrderBy>;
  readonly purpose?: InputMaybe<OrderBy>;
  readonly rail_information?: InputMaybe<OrderBy>;
  readonly speech_property?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
  readonly width?: InputMaybe<OrderBy>;
  readonly zone_label?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: info_spot */
export type StopsDatabaseInfoSpotPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** columns and relationships of "info_spot_poster" */
export type StopsDatabaseInfoSpotPoster = {
  readonly __typename?: 'stops_database_info_spot_poster';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly height?: Maybe<Scalars['Int']['output']>;
  readonly id: Scalars['bigint']['output'];
  readonly label?: Maybe<Scalars['String']['output']>;
  readonly lines?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly width?: Maybe<Scalars['Int']['output']>;
};

/** aggregated selection of "info_spot_poster" */
export type StopsDatabaseInfoSpotPosterAggregate = {
  readonly __typename?: 'stops_database_info_spot_poster_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseInfoSpotPosterAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseInfoSpotPoster>;
};

/** aggregate fields of "info_spot_poster" */
export type StopsDatabaseInfoSpotPosterAggregateFields = {
  readonly __typename?: 'stops_database_info_spot_poster_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseInfoSpotPosterAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseInfoSpotPosterMaxFields>;
  readonly min?: Maybe<StopsDatabaseInfoSpotPosterMinFields>;
  readonly stddev?: Maybe<StopsDatabaseInfoSpotPosterStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseInfoSpotPosterStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseInfoSpotPosterStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseInfoSpotPosterSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseInfoSpotPosterVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseInfoSpotPosterVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseInfoSpotPosterVarianceFields>;
};


/** aggregate fields of "info_spot_poster" */
export type StopsDatabaseInfoSpotPosterAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseInfoSpotPosterSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseInfoSpotPosterAvgFields = {
  readonly __typename?: 'stops_database_info_spot_poster_avg_fields';
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "info_spot_poster". All fields are combined with a logical 'AND'. */
export type StopsDatabaseInfoSpotPosterBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseInfoSpotPosterBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseInfoSpotPosterBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseInfoSpotPosterBoolExp>>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly height?: InputMaybe<IntComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly label?: InputMaybe<StringComparisonExp>;
  readonly lines?: InputMaybe<StringComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
  readonly width?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "info_spot_poster" */
export enum StopsDatabaseInfoSpotPosterConstraint {
  /** unique or primary key constraint on columns "id" */
  InfoSpotPosterPkey = 'info_spot_poster_pkey'
}

/** input type for incrementing numeric columns in table "info_spot_poster" */
export type StopsDatabaseInfoSpotPosterIncInput = {
  readonly height?: InputMaybe<Scalars['Int']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly width?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "info_spot_poster" */
export type StopsDatabaseInfoSpotPosterInsertInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly height?: InputMaybe<Scalars['Int']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly label?: InputMaybe<Scalars['String']['input']>;
  readonly lines?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
  readonly width?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseInfoSpotPosterMaxFields = {
  readonly __typename?: 'stops_database_info_spot_poster_max_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly height?: Maybe<Scalars['Int']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly label?: Maybe<Scalars['String']['output']>;
  readonly lines?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly width?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseInfoSpotPosterMinFields = {
  readonly __typename?: 'stops_database_info_spot_poster_min_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly height?: Maybe<Scalars['Int']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly label?: Maybe<Scalars['String']['output']>;
  readonly lines?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly width?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "info_spot_poster" */
export type StopsDatabaseInfoSpotPosterMutationResponse = {
  readonly __typename?: 'stops_database_info_spot_poster_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseInfoSpotPoster>;
};

/** on_conflict condition type for table "info_spot_poster" */
export type StopsDatabaseInfoSpotPosterOnConflict = {
  readonly constraint: StopsDatabaseInfoSpotPosterConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseInfoSpotPosterUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseInfoSpotPosterBoolExp>;
};

/** Ordering options when selecting data from "info_spot_poster". */
export type StopsDatabaseInfoSpotPosterOrderBy = {
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly height?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly label?: InputMaybe<OrderBy>;
  readonly lines?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
  readonly width?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: info_spot_poster */
export type StopsDatabaseInfoSpotPosterPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "info_spot_poster" */
export enum StopsDatabaseInfoSpotPosterSelectColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Height = 'height',
  /** column name */
  Id = 'id',
  /** column name */
  Label = 'label',
  /** column name */
  Lines = 'lines',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  Width = 'width'
}

/** input type for updating data in table "info_spot_poster" */
export type StopsDatabaseInfoSpotPosterSetInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly height?: InputMaybe<Scalars['Int']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly label?: InputMaybe<Scalars['String']['input']>;
  readonly lines?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
  readonly width?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseInfoSpotPosterStddevFields = {
  readonly __typename?: 'stops_database_info_spot_poster_stddev_fields';
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseInfoSpotPosterStddevPopFields = {
  readonly __typename?: 'stops_database_info_spot_poster_stddev_pop_fields';
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseInfoSpotPosterStddevSampFields = {
  readonly __typename?: 'stops_database_info_spot_poster_stddev_samp_fields';
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "info_spot_poster" */
export type StopsDatabaseInfoSpotPosterStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseInfoSpotPosterStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseInfoSpotPosterStreamCursorValueInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly height?: InputMaybe<Scalars['Int']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly label?: InputMaybe<Scalars['String']['input']>;
  readonly lines?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
  readonly width?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseInfoSpotPosterSumFields = {
  readonly __typename?: 'stops_database_info_spot_poster_sum_fields';
  readonly height?: Maybe<Scalars['Int']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly width?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "info_spot_poster" */
export enum StopsDatabaseInfoSpotPosterUpdateColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Height = 'height',
  /** column name */
  Id = 'id',
  /** column name */
  Label = 'label',
  /** column name */
  Lines = 'lines',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  Width = 'width'
}

export type StopsDatabaseInfoSpotPosterUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseInfoSpotPosterIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseInfoSpotPosterSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseInfoSpotPosterBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseInfoSpotPosterVarPopFields = {
  readonly __typename?: 'stops_database_info_spot_poster_var_pop_fields';
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseInfoSpotPosterVarSampFields = {
  readonly __typename?: 'stops_database_info_spot_poster_var_samp_fields';
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseInfoSpotPosterVarianceFields = {
  readonly __typename?: 'stops_database_info_spot_poster_variance_fields';
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** select columns of table "info_spot" */
export enum StopsDatabaseInfoSpotSelectColumn {
  /** column name */
  Backlight = 'backlight',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  DisplayType = 'display_type',
  /** column name */
  Floor = 'floor',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Height = 'height',
  /** column name */
  Id = 'id',
  /** column name */
  InfoSpotLocation = 'info_spot_location',
  /** column name */
  InfoSpotType = 'info_spot_type',
  /** column name */
  Label = 'label',
  /** column name */
  Maintenance = 'maintenance',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  Purpose = 'purpose',
  /** column name */
  RailInformation = 'rail_information',
  /** column name */
  SpeechProperty = 'speech_property',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  Width = 'width',
  /** column name */
  ZoneLabel = 'zone_label'
}

/** input type for updating data in table "info_spot" */
export type StopsDatabaseInfoSpotSetInput = {
  readonly backlight?: InputMaybe<Scalars['Boolean']['input']>;
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly display_type?: InputMaybe<Scalars['String']['input']>;
  readonly floor?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly height?: InputMaybe<Scalars['Int']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly info_spot_location?: InputMaybe<Scalars['String']['input']>;
  readonly info_spot_type?: InputMaybe<Scalars['String']['input']>;
  readonly label?: InputMaybe<Scalars['String']['input']>;
  readonly maintenance?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly purpose?: InputMaybe<Scalars['String']['input']>;
  readonly rail_information?: InputMaybe<Scalars['String']['input']>;
  readonly speech_property?: InputMaybe<Scalars['Boolean']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
  readonly width?: InputMaybe<Scalars['Int']['input']>;
  readonly zone_label?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseInfoSpotStddevFields = {
  readonly __typename?: 'stops_database_info_spot_stddev_fields';
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseInfoSpotStddevPopFields = {
  readonly __typename?: 'stops_database_info_spot_stddev_pop_fields';
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseInfoSpotStddevSampFields = {
  readonly __typename?: 'stops_database_info_spot_stddev_samp_fields';
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "info_spot" */
export type StopsDatabaseInfoSpotStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseInfoSpotStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseInfoSpotStreamCursorValueInput = {
  readonly backlight?: InputMaybe<Scalars['Boolean']['input']>;
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly display_type?: InputMaybe<Scalars['String']['input']>;
  readonly floor?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly height?: InputMaybe<Scalars['Int']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly info_spot_location?: InputMaybe<Scalars['String']['input']>;
  readonly info_spot_type?: InputMaybe<Scalars['String']['input']>;
  readonly label?: InputMaybe<Scalars['String']['input']>;
  readonly maintenance?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly purpose?: InputMaybe<Scalars['String']['input']>;
  readonly rail_information?: InputMaybe<Scalars['String']['input']>;
  readonly speech_property?: InputMaybe<Scalars['Boolean']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
  readonly width?: InputMaybe<Scalars['Int']['input']>;
  readonly zone_label?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseInfoSpotSumFields = {
  readonly __typename?: 'stops_database_info_spot_sum_fields';
  readonly height?: Maybe<Scalars['Int']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly width?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "info_spot" */
export enum StopsDatabaseInfoSpotUpdateColumn {
  /** column name */
  Backlight = 'backlight',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  DisplayType = 'display_type',
  /** column name */
  Floor = 'floor',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Height = 'height',
  /** column name */
  Id = 'id',
  /** column name */
  InfoSpotLocation = 'info_spot_location',
  /** column name */
  InfoSpotType = 'info_spot_type',
  /** column name */
  Label = 'label',
  /** column name */
  Maintenance = 'maintenance',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  Purpose = 'purpose',
  /** column name */
  RailInformation = 'rail_information',
  /** column name */
  SpeechProperty = 'speech_property',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  Width = 'width',
  /** column name */
  ZoneLabel = 'zone_label'
}

export type StopsDatabaseInfoSpotUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseInfoSpotIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseInfoSpotSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseInfoSpotBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseInfoSpotVarPopFields = {
  readonly __typename?: 'stops_database_info_spot_var_pop_fields';
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseInfoSpotVarSampFields = {
  readonly __typename?: 'stops_database_info_spot_var_samp_fields';
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseInfoSpotVarianceFields = {
  readonly __typename?: 'stops_database_info_spot_variance_fields';
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "installed_equipment" */
export type StopsDatabaseInstalledEquipment = {
  readonly __typename?: 'stops_database_installed_equipment';
  readonly equipment_id: Scalars['Int']['output'];
  readonly id: Scalars['String']['output'];
  readonly item_type?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "installed_equipment" */
export type StopsDatabaseInstalledEquipmentAggregate = {
  readonly __typename?: 'stops_database_installed_equipment_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseInstalledEquipmentAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseInstalledEquipment>;
};

/** aggregate fields of "installed_equipment" */
export type StopsDatabaseInstalledEquipmentAggregateFields = {
  readonly __typename?: 'stops_database_installed_equipment_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseInstalledEquipmentAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseInstalledEquipmentMaxFields>;
  readonly min?: Maybe<StopsDatabaseInstalledEquipmentMinFields>;
  readonly stddev?: Maybe<StopsDatabaseInstalledEquipmentStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseInstalledEquipmentStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseInstalledEquipmentStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseInstalledEquipmentSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseInstalledEquipmentVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseInstalledEquipmentVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseInstalledEquipmentVarianceFields>;
};


/** aggregate fields of "installed_equipment" */
export type StopsDatabaseInstalledEquipmentAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseInstalledEquipmentAvgFields = {
  readonly __typename?: 'stops_database_installed_equipment_avg_fields';
  readonly equipment_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "installed_equipment". All fields are combined with a logical 'AND'. */
export type StopsDatabaseInstalledEquipmentBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseInstalledEquipmentBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentBoolExp>>;
  readonly equipment_id?: InputMaybe<IntComparisonExp>;
  readonly id?: InputMaybe<StringComparisonExp>;
  readonly item_type?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "installed_equipment" */
export type StopsDatabaseInstalledEquipmentIncInput = {
  readonly equipment_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "installed_equipment" */
export type StopsDatabaseInstalledEquipmentInsertInput = {
  readonly equipment_id?: InputMaybe<Scalars['Int']['input']>;
  readonly id?: InputMaybe<Scalars['String']['input']>;
  readonly item_type?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseInstalledEquipmentMaxFields = {
  readonly __typename?: 'stops_database_installed_equipment_max_fields';
  readonly equipment_id?: Maybe<Scalars['Int']['output']>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly item_type?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseInstalledEquipmentMinFields = {
  readonly __typename?: 'stops_database_installed_equipment_min_fields';
  readonly equipment_id?: Maybe<Scalars['Int']['output']>;
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly item_type?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "installed_equipment" */
export type StopsDatabaseInstalledEquipmentMutationResponse = {
  readonly __typename?: 'stops_database_installed_equipment_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseInstalledEquipment>;
};

/** Ordering options when selecting data from "installed_equipment". */
export type StopsDatabaseInstalledEquipmentOrderBy = {
  readonly equipment_id?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly item_type?: InputMaybe<OrderBy>;
};

/** select columns of table "installed_equipment" */
export enum StopsDatabaseInstalledEquipmentSelectColumn {
  /** column name */
  EquipmentId = 'equipment_id',
  /** column name */
  Id = 'id',
  /** column name */
  ItemType = 'item_type'
}

/** input type for updating data in table "installed_equipment" */
export type StopsDatabaseInstalledEquipmentSetInput = {
  readonly equipment_id?: InputMaybe<Scalars['Int']['input']>;
  readonly id?: InputMaybe<Scalars['String']['input']>;
  readonly item_type?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseInstalledEquipmentStddevFields = {
  readonly __typename?: 'stops_database_installed_equipment_stddev_fields';
  readonly equipment_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseInstalledEquipmentStddevPopFields = {
  readonly __typename?: 'stops_database_installed_equipment_stddev_pop_fields';
  readonly equipment_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseInstalledEquipmentStddevSampFields = {
  readonly __typename?: 'stops_database_installed_equipment_stddev_samp_fields';
  readonly equipment_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "installed_equipment" */
export type StopsDatabaseInstalledEquipmentStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseInstalledEquipmentStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseInstalledEquipmentStreamCursorValueInput = {
  readonly equipment_id?: InputMaybe<Scalars['Int']['input']>;
  readonly id?: InputMaybe<Scalars['String']['input']>;
  readonly item_type?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseInstalledEquipmentSumFields = {
  readonly __typename?: 'stops_database_installed_equipment_sum_fields';
  readonly equipment_id?: Maybe<Scalars['Int']['output']>;
};

export type StopsDatabaseInstalledEquipmentUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseInstalledEquipmentIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseInstalledEquipmentSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseInstalledEquipmentBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseInstalledEquipmentVarPopFields = {
  readonly __typename?: 'stops_database_installed_equipment_var_pop_fields';
  readonly equipment_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseInstalledEquipmentVarSampFields = {
  readonly __typename?: 'stops_database_installed_equipment_var_samp_fields';
  readonly equipment_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseInstalledEquipmentVarianceFields = {
  readonly __typename?: 'stops_database_installed_equipment_variance_fields';
  readonly equipment_id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructure = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure';
  readonly air_conditioned?: Maybe<Scalars['Boolean']['output']>;
  /** Pyöräpysäköinti */
  readonly bicycle_parking?: Maybe<Scalars['Boolean']['output']>;
  readonly brand_graphic?: Maybe<Scalars['String']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly class_of_use_ref?: Maybe<Scalars['bytea']['output']>;
  readonly content_lang?: Maybe<Scalars['String']['output']>;
  readonly content_value?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly cycle_storage_type?: Maybe<Scalars['Int']['output']>;
  readonly dtype: Scalars['String']['output'];
  readonly enclosed?: Maybe<Scalars['Boolean']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly gender?: Maybe<Scalars['Int']['output']>;
  readonly heated?: Maybe<Scalars['Boolean']['output']>;
  readonly height?: Maybe<Scalars['numeric']['output']>;
  readonly height_from_floor?: Maybe<Scalars['numeric']['output']>;
  readonly id: Scalars['bigint']['output'];
  /** An array relationship */
  readonly installed_equipment_version_structure_installed_equipments: ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipment>;
  /** An aggregate relationship */
  readonly installed_equipment_version_structure_installed_equipments_aggregate: StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAggregate;
  /** Nojailutanko */
  readonly leaning_rail?: Maybe<Scalars['Boolean']['output']>;
  readonly length?: Maybe<Scalars['numeric']['output']>;
  readonly line_signage?: Maybe<Scalars['Boolean']['output']>;
  readonly machine_readable?: Maybe<Scalars['Boolean']['output']>;
  readonly main_line_sign?: Maybe<Scalars['Boolean']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly note_lang?: Maybe<Scalars['String']['output']>;
  readonly note_value?: Maybe<Scalars['String']['output']>;
  readonly number_of_frames?: Maybe<Scalars['Int']['output']>;
  readonly number_of_machines?: Maybe<Scalars['numeric']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['numeric']['output']>;
  readonly number_of_toilets?: Maybe<Scalars['numeric']['output']>;
  readonly out_of_service?: Maybe<Scalars['Boolean']['output']>;
  /** Ulkopenkki */
  readonly outside_bench?: Maybe<Scalars['Boolean']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly replaces_rail_sign?: Maybe<Scalars['Boolean']['output']>;
  readonly seats?: Maybe<Scalars['numeric']['output']>;
  /** Katoksen kunto: Hyvä (good), Välttävä (mediocre), Huono (bad) */
  readonly shelter_condition?: Maybe<Scalars['String']['output']>;
  /** Katoksen sähköt: Jatkuva sähkö (continuous) / Valosähkö (light) / Jatkuva rakenteilla (continuousUnderConstruction) / Jatkuva suunniteltu (continuousPlanned) / Tilapäisesti pois (temporarilyOff) / Ei sähköä (none) */
  readonly shelter_electricity?: Maybe<Scalars['String']['output']>;
  /** Extrernal shelter id */
  readonly shelter_external_id?: Maybe<Scalars['String']['output']>;
  /** Pysäkkikatoksen otsalaudan teippaus */
  readonly shelter_fascia_board_taping?: Maybe<Scalars['Boolean']['output']>;
  /** Katoksesssa näyttö */
  readonly shelter_has_display?: Maybe<Scalars['Boolean']['output']>;
  /** Katoksessa valot */
  readonly shelter_lighting?: Maybe<Scalars['Boolean']['output']>;
  /** Internal shelter number */
  readonly shelter_number?: Maybe<Scalars['Int']['output']>;
  /** Katoksen tyyppi: Lasikatos (glass) / Teräskatos (steel) / Tolppa (post) / Urbaanikatos (urban) / Betonikatos (concrete) / Puukatos (wooden) / Virtuaali (virtual) */
  readonly shelter_type?: Maybe<Scalars['String']['output']>;
  readonly sign_content_type?: Maybe<Scalars['String']['output']>;
  readonly sign_graphic?: Maybe<Scalars['String']['output']>;
  readonly smoking_allowed?: Maybe<Scalars['Boolean']['output']>;
  readonly step_free?: Maybe<Scalars['Boolean']['output']>;
  readonly ticket_machines?: Maybe<Scalars['Boolean']['output']>;
  readonly ticket_office?: Maybe<Scalars['Boolean']['output']>;
  /** Aikataulukaappien lukumäärä */
  readonly timetable_cabinets?: Maybe<Scalars['Int']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  /** Katoksessa roska-astia */
  readonly trash_can?: Maybe<Scalars['Boolean']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly wheelchair_area_length?: Maybe<Scalars['numeric']['output']>;
  readonly wheelchair_area_width?: Maybe<Scalars['numeric']['output']>;
  readonly width?: Maybe<Scalars['numeric']['output']>;
  readonly women_only?: Maybe<Scalars['Boolean']['output']>;
};


/** columns and relationships of "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVersionStructureInstalledEquipmentsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentOrderBy>>;
  where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>;
};


/** columns and relationships of "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVersionStructureInstalledEquipmentsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentOrderBy>>;
  where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>;
};

/** aggregated selection of "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructureAggregate = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructure>;
};

/** aggregate fields of "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructureAggregateFields = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureMaxFields>;
  readonly min?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureMinFields>;
  readonly stddev?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureVarianceFields>;
};


/** aggregate fields of "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructureAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureAvgFields = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_avg_fields';
  readonly cycle_storage_type?: Maybe<Scalars['Float']['output']>;
  readonly gender?: Maybe<Scalars['Float']['output']>;
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly height_from_floor?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly length?: Maybe<Scalars['Float']['output']>;
  readonly number_of_frames?: Maybe<Scalars['Float']['output']>;
  readonly number_of_machines?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['Float']['output']>;
  readonly number_of_toilets?: Maybe<Scalars['Float']['output']>;
  readonly seats?: Maybe<Scalars['Float']['output']>;
  /** Internal shelter number */
  readonly shelter_number?: Maybe<Scalars['Float']['output']>;
  /** Aikataulukaappien lukumäärä */
  readonly timetable_cabinets?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_length?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_width?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "installed_equipment_version_structure". All fields are combined with a logical 'AND'. */
export type StopsDatabaseInstalledEquipmentVersionStructureBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>>;
  readonly air_conditioned?: InputMaybe<BooleanComparisonExp>;
  readonly bicycle_parking?: InputMaybe<BooleanComparisonExp>;
  readonly brand_graphic?: InputMaybe<StringComparisonExp>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly class_of_use_ref?: InputMaybe<ByteaComparisonExp>;
  readonly content_lang?: InputMaybe<StringComparisonExp>;
  readonly content_value?: InputMaybe<StringComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly cycle_storage_type?: InputMaybe<IntComparisonExp>;
  readonly dtype?: InputMaybe<StringComparisonExp>;
  readonly enclosed?: InputMaybe<BooleanComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly gender?: InputMaybe<IntComparisonExp>;
  readonly heated?: InputMaybe<BooleanComparisonExp>;
  readonly height?: InputMaybe<NumericComparisonExp>;
  readonly height_from_floor?: InputMaybe<NumericComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly installed_equipment_version_structure_installed_equipments?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>;
  readonly installed_equipment_version_structure_installed_equipments_aggregate?: InputMaybe<InstalledEquipmentVersionStructureInstalledEquipmentAggregateBoolExp>;
  readonly leaning_rail?: InputMaybe<BooleanComparisonExp>;
  readonly length?: InputMaybe<NumericComparisonExp>;
  readonly line_signage?: InputMaybe<BooleanComparisonExp>;
  readonly machine_readable?: InputMaybe<BooleanComparisonExp>;
  readonly main_line_sign?: InputMaybe<BooleanComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly note_lang?: InputMaybe<StringComparisonExp>;
  readonly note_value?: InputMaybe<StringComparisonExp>;
  readonly number_of_frames?: InputMaybe<IntComparisonExp>;
  readonly number_of_machines?: InputMaybe<NumericComparisonExp>;
  readonly number_of_spaces?: InputMaybe<NumericComparisonExp>;
  readonly number_of_toilets?: InputMaybe<NumericComparisonExp>;
  readonly out_of_service?: InputMaybe<BooleanComparisonExp>;
  readonly outside_bench?: InputMaybe<BooleanComparisonExp>;
  readonly private_code_type?: InputMaybe<StringComparisonExp>;
  readonly private_code_value?: InputMaybe<StringComparisonExp>;
  readonly replaces_rail_sign?: InputMaybe<BooleanComparisonExp>;
  readonly seats?: InputMaybe<NumericComparisonExp>;
  readonly shelter_condition?: InputMaybe<StringComparisonExp>;
  readonly shelter_electricity?: InputMaybe<StringComparisonExp>;
  readonly shelter_external_id?: InputMaybe<StringComparisonExp>;
  readonly shelter_fascia_board_taping?: InputMaybe<BooleanComparisonExp>;
  readonly shelter_has_display?: InputMaybe<BooleanComparisonExp>;
  readonly shelter_lighting?: InputMaybe<BooleanComparisonExp>;
  readonly shelter_number?: InputMaybe<IntComparisonExp>;
  readonly shelter_type?: InputMaybe<StringComparisonExp>;
  readonly sign_content_type?: InputMaybe<StringComparisonExp>;
  readonly sign_graphic?: InputMaybe<StringComparisonExp>;
  readonly smoking_allowed?: InputMaybe<BooleanComparisonExp>;
  readonly step_free?: InputMaybe<BooleanComparisonExp>;
  readonly ticket_machines?: InputMaybe<BooleanComparisonExp>;
  readonly ticket_office?: InputMaybe<BooleanComparisonExp>;
  readonly timetable_cabinets?: InputMaybe<IntComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly trash_can?: InputMaybe<BooleanComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
  readonly wheelchair_area_length?: InputMaybe<NumericComparisonExp>;
  readonly wheelchair_area_width?: InputMaybe<NumericComparisonExp>;
  readonly width?: InputMaybe<NumericComparisonExp>;
  readonly women_only?: InputMaybe<BooleanComparisonExp>;
};

/** unique or primary key constraints on table "installed_equipment_version_structure" */
export enum StopsDatabaseInstalledEquipmentVersionStructureConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  InstalledEquipmentNetexIdVersionConstraint = 'installed_equipment_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  InstalledEquipmentVersionStructurePkey = 'installed_equipment_version_structure_pkey'
}

/** input type for incrementing numeric columns in table "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructureIncInput = {
  readonly cycle_storage_type?: InputMaybe<Scalars['Int']['input']>;
  readonly gender?: InputMaybe<Scalars['Int']['input']>;
  readonly height?: InputMaybe<Scalars['numeric']['input']>;
  readonly height_from_floor?: InputMaybe<Scalars['numeric']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly length?: InputMaybe<Scalars['numeric']['input']>;
  readonly number_of_frames?: InputMaybe<Scalars['Int']['input']>;
  readonly number_of_machines?: InputMaybe<Scalars['numeric']['input']>;
  readonly number_of_spaces?: InputMaybe<Scalars['numeric']['input']>;
  readonly number_of_toilets?: InputMaybe<Scalars['numeric']['input']>;
  readonly seats?: InputMaybe<Scalars['numeric']['input']>;
  /** Internal shelter number */
  readonly shelter_number?: InputMaybe<Scalars['Int']['input']>;
  /** Aikataulukaappien lukumäärä */
  readonly timetable_cabinets?: InputMaybe<Scalars['Int']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly wheelchair_area_length?: InputMaybe<Scalars['numeric']['input']>;
  readonly wheelchair_area_width?: InputMaybe<Scalars['numeric']['input']>;
  readonly width?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructureInsertInput = {
  readonly air_conditioned?: InputMaybe<Scalars['Boolean']['input']>;
  /** Pyöräpysäköinti */
  readonly bicycle_parking?: InputMaybe<Scalars['Boolean']['input']>;
  readonly brand_graphic?: InputMaybe<Scalars['String']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly class_of_use_ref?: InputMaybe<Scalars['bytea']['input']>;
  readonly content_lang?: InputMaybe<Scalars['String']['input']>;
  readonly content_value?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly cycle_storage_type?: InputMaybe<Scalars['Int']['input']>;
  readonly dtype?: InputMaybe<Scalars['String']['input']>;
  readonly enclosed?: InputMaybe<Scalars['Boolean']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly gender?: InputMaybe<Scalars['Int']['input']>;
  readonly heated?: InputMaybe<Scalars['Boolean']['input']>;
  readonly height?: InputMaybe<Scalars['numeric']['input']>;
  readonly height_from_floor?: InputMaybe<Scalars['numeric']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly installed_equipment_version_structure_installed_equipments?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentArrRelInsertInput>;
  /** Nojailutanko */
  readonly leaning_rail?: InputMaybe<Scalars['Boolean']['input']>;
  readonly length?: InputMaybe<Scalars['numeric']['input']>;
  readonly line_signage?: InputMaybe<Scalars['Boolean']['input']>;
  readonly machine_readable?: InputMaybe<Scalars['Boolean']['input']>;
  readonly main_line_sign?: InputMaybe<Scalars['Boolean']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly note_lang?: InputMaybe<Scalars['String']['input']>;
  readonly note_value?: InputMaybe<Scalars['String']['input']>;
  readonly number_of_frames?: InputMaybe<Scalars['Int']['input']>;
  readonly number_of_machines?: InputMaybe<Scalars['numeric']['input']>;
  readonly number_of_spaces?: InputMaybe<Scalars['numeric']['input']>;
  readonly number_of_toilets?: InputMaybe<Scalars['numeric']['input']>;
  readonly out_of_service?: InputMaybe<Scalars['Boolean']['input']>;
  /** Ulkopenkki */
  readonly outside_bench?: InputMaybe<Scalars['Boolean']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly replaces_rail_sign?: InputMaybe<Scalars['Boolean']['input']>;
  readonly seats?: InputMaybe<Scalars['numeric']['input']>;
  /** Katoksen kunto: Hyvä (good), Välttävä (mediocre), Huono (bad) */
  readonly shelter_condition?: InputMaybe<Scalars['String']['input']>;
  /** Katoksen sähköt: Jatkuva sähkö (continuous) / Valosähkö (light) / Jatkuva rakenteilla (continuousUnderConstruction) / Jatkuva suunniteltu (continuousPlanned) / Tilapäisesti pois (temporarilyOff) / Ei sähköä (none) */
  readonly shelter_electricity?: InputMaybe<Scalars['String']['input']>;
  /** Extrernal shelter id */
  readonly shelter_external_id?: InputMaybe<Scalars['String']['input']>;
  /** Pysäkkikatoksen otsalaudan teippaus */
  readonly shelter_fascia_board_taping?: InputMaybe<Scalars['Boolean']['input']>;
  /** Katoksesssa näyttö */
  readonly shelter_has_display?: InputMaybe<Scalars['Boolean']['input']>;
  /** Katoksessa valot */
  readonly shelter_lighting?: InputMaybe<Scalars['Boolean']['input']>;
  /** Internal shelter number */
  readonly shelter_number?: InputMaybe<Scalars['Int']['input']>;
  /** Katoksen tyyppi: Lasikatos (glass) / Teräskatos (steel) / Tolppa (post) / Urbaanikatos (urban) / Betonikatos (concrete) / Puukatos (wooden) / Virtuaali (virtual) */
  readonly shelter_type?: InputMaybe<Scalars['String']['input']>;
  readonly sign_content_type?: InputMaybe<Scalars['String']['input']>;
  readonly sign_graphic?: InputMaybe<Scalars['String']['input']>;
  readonly smoking_allowed?: InputMaybe<Scalars['Boolean']['input']>;
  readonly step_free?: InputMaybe<Scalars['Boolean']['input']>;
  readonly ticket_machines?: InputMaybe<Scalars['Boolean']['input']>;
  readonly ticket_office?: InputMaybe<Scalars['Boolean']['input']>;
  /** Aikataulukaappien lukumäärä */
  readonly timetable_cabinets?: InputMaybe<Scalars['Int']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  /** Katoksessa roska-astia */
  readonly trash_can?: InputMaybe<Scalars['Boolean']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
  readonly wheelchair_area_length?: InputMaybe<Scalars['numeric']['input']>;
  readonly wheelchair_area_width?: InputMaybe<Scalars['numeric']['input']>;
  readonly width?: InputMaybe<Scalars['numeric']['input']>;
  readonly women_only?: InputMaybe<Scalars['Boolean']['input']>;
};

/** columns and relationships of "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipment = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment';
  /** An object relationship */
  readonly installedEquipmentVersionStructureByPlaceEquipmentId: StopsDatabaseInstalledEquipmentVersionStructure;
  readonly installed_equipment_id: Scalars['bigint']['output'];
  /** An object relationship */
  readonly installed_equipment_version_structure: StopsDatabaseInstalledEquipmentVersionStructure;
  readonly place_equipment_id: Scalars['bigint']['output'];
};

/** aggregated selection of "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAggregate = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipment>;
};

/** aggregate fields of "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAggregateFields = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMaxFields>;
  readonly min?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMinFields>;
  readonly stddev?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVarianceFields>;
};


/** aggregate fields of "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAvgFields = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_avg_fields';
  readonly installed_equipment_id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipment_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAvgOrderBy = {
  readonly installed_equipment_id?: InputMaybe<OrderBy>;
  readonly place_equipment_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "installed_equipment_version_structure_installed_equipment". All fields are combined with a logical 'AND'. */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>>;
  readonly installedEquipmentVersionStructureByPlaceEquipmentId?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
  readonly installed_equipment_id?: InputMaybe<BigintComparisonExp>;
  readonly installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
  readonly place_equipment_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "installed_equipment_version_structure_installed_equipment" */
export enum StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentConstraint {
  /** unique or primary key constraint on columns "installed_equipment_id" */
  UkS4px36fd2jutbf4p8lagcocbd = 'uk_s4px36fd2jutbf4p8lagcocbd'
}

/** input type for incrementing numeric columns in table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentIncInput = {
  readonly installed_equipment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly place_equipment_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentInsertInput = {
  readonly installedEquipmentVersionStructureByPlaceEquipmentId?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureObjRelInsertInput>;
  readonly installed_equipment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureObjRelInsertInput>;
  readonly place_equipment_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMaxFields = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_max_fields';
  readonly installed_equipment_id?: Maybe<Scalars['bigint']['output']>;
  readonly place_equipment_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMaxOrderBy = {
  readonly installed_equipment_id?: InputMaybe<OrderBy>;
  readonly place_equipment_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMinFields = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_min_fields';
  readonly installed_equipment_id?: Maybe<Scalars['bigint']['output']>;
  readonly place_equipment_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMinOrderBy = {
  readonly installed_equipment_id?: InputMaybe<OrderBy>;
  readonly place_equipment_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMutationResponse = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipment>;
};

/** on_conflict condition type for table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentOnConflict = {
  readonly constraint: StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>;
};

/** Ordering options when selecting data from "installed_equipment_version_structure_installed_equipment". */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentOrderBy = {
  readonly installedEquipmentVersionStructureByPlaceEquipmentId?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureOrderBy>;
  readonly installed_equipment_id?: InputMaybe<OrderBy>;
  readonly installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureOrderBy>;
  readonly place_equipment_id?: InputMaybe<OrderBy>;
};

/** select columns of table "installed_equipment_version_structure_installed_equipment" */
export enum StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSelectColumn {
  /** column name */
  InstalledEquipmentId = 'installed_equipment_id',
  /** column name */
  PlaceEquipmentId = 'place_equipment_id'
}

/** input type for updating data in table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSetInput = {
  readonly installed_equipment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly place_equipment_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStddevFields = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_stddev_fields';
  readonly installed_equipment_id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipment_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStddevOrderBy = {
  readonly installed_equipment_id?: InputMaybe<OrderBy>;
  readonly place_equipment_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStddevPopFields = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_stddev_pop_fields';
  readonly installed_equipment_id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipment_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStddevPopOrderBy = {
  readonly installed_equipment_id?: InputMaybe<OrderBy>;
  readonly place_equipment_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStddevSampFields = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_stddev_samp_fields';
  readonly installed_equipment_id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipment_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStddevSampOrderBy = {
  readonly installed_equipment_id?: InputMaybe<OrderBy>;
  readonly place_equipment_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStreamCursorValueInput = {
  readonly installed_equipment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly place_equipment_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSumFields = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_sum_fields';
  readonly installed_equipment_id?: Maybe<Scalars['bigint']['output']>;
  readonly place_equipment_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSumOrderBy = {
  readonly installed_equipment_id?: InputMaybe<OrderBy>;
  readonly place_equipment_id?: InputMaybe<OrderBy>;
};

/** update columns of table "installed_equipment_version_structure_installed_equipment" */
export enum StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentUpdateColumn {
  /** column name */
  InstalledEquipmentId = 'installed_equipment_id',
  /** column name */
  PlaceEquipmentId = 'place_equipment_id'
}

export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVarPopFields = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_var_pop_fields';
  readonly installed_equipment_id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipment_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVarPopOrderBy = {
  readonly installed_equipment_id?: InputMaybe<OrderBy>;
  readonly place_equipment_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVarSampFields = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_var_samp_fields';
  readonly installed_equipment_id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipment_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVarSampOrderBy = {
  readonly installed_equipment_id?: InputMaybe<OrderBy>;
  readonly place_equipment_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVarianceFields = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_installed_equipment_variance_fields';
  readonly installed_equipment_id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipment_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "installed_equipment_version_structure_installed_equipment" */
export type StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentVarianceOrderBy = {
  readonly installed_equipment_id?: InputMaybe<OrderBy>;
  readonly place_equipment_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureMaxFields = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_max_fields';
  readonly brand_graphic?: Maybe<Scalars['String']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly content_lang?: Maybe<Scalars['String']['output']>;
  readonly content_value?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly cycle_storage_type?: Maybe<Scalars['Int']['output']>;
  readonly dtype?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly gender?: Maybe<Scalars['Int']['output']>;
  readonly height?: Maybe<Scalars['numeric']['output']>;
  readonly height_from_floor?: Maybe<Scalars['numeric']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly length?: Maybe<Scalars['numeric']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly note_lang?: Maybe<Scalars['String']['output']>;
  readonly note_value?: Maybe<Scalars['String']['output']>;
  readonly number_of_frames?: Maybe<Scalars['Int']['output']>;
  readonly number_of_machines?: Maybe<Scalars['numeric']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['numeric']['output']>;
  readonly number_of_toilets?: Maybe<Scalars['numeric']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly seats?: Maybe<Scalars['numeric']['output']>;
  /** Katoksen kunto: Hyvä (good), Välttävä (mediocre), Huono (bad) */
  readonly shelter_condition?: Maybe<Scalars['String']['output']>;
  /** Katoksen sähköt: Jatkuva sähkö (continuous) / Valosähkö (light) / Jatkuva rakenteilla (continuousUnderConstruction) / Jatkuva suunniteltu (continuousPlanned) / Tilapäisesti pois (temporarilyOff) / Ei sähköä (none) */
  readonly shelter_electricity?: Maybe<Scalars['String']['output']>;
  /** Extrernal shelter id */
  readonly shelter_external_id?: Maybe<Scalars['String']['output']>;
  /** Internal shelter number */
  readonly shelter_number?: Maybe<Scalars['Int']['output']>;
  /** Katoksen tyyppi: Lasikatos (glass) / Teräskatos (steel) / Tolppa (post) / Urbaanikatos (urban) / Betonikatos (concrete) / Puukatos (wooden) / Virtuaali (virtual) */
  readonly shelter_type?: Maybe<Scalars['String']['output']>;
  readonly sign_content_type?: Maybe<Scalars['String']['output']>;
  readonly sign_graphic?: Maybe<Scalars['String']['output']>;
  /** Aikataulukaappien lukumäärä */
  readonly timetable_cabinets?: Maybe<Scalars['Int']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly wheelchair_area_length?: Maybe<Scalars['numeric']['output']>;
  readonly wheelchair_area_width?: Maybe<Scalars['numeric']['output']>;
  readonly width?: Maybe<Scalars['numeric']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureMinFields = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_min_fields';
  readonly brand_graphic?: Maybe<Scalars['String']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly content_lang?: Maybe<Scalars['String']['output']>;
  readonly content_value?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly cycle_storage_type?: Maybe<Scalars['Int']['output']>;
  readonly dtype?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly gender?: Maybe<Scalars['Int']['output']>;
  readonly height?: Maybe<Scalars['numeric']['output']>;
  readonly height_from_floor?: Maybe<Scalars['numeric']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly length?: Maybe<Scalars['numeric']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly note_lang?: Maybe<Scalars['String']['output']>;
  readonly note_value?: Maybe<Scalars['String']['output']>;
  readonly number_of_frames?: Maybe<Scalars['Int']['output']>;
  readonly number_of_machines?: Maybe<Scalars['numeric']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['numeric']['output']>;
  readonly number_of_toilets?: Maybe<Scalars['numeric']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly seats?: Maybe<Scalars['numeric']['output']>;
  /** Katoksen kunto: Hyvä (good), Välttävä (mediocre), Huono (bad) */
  readonly shelter_condition?: Maybe<Scalars['String']['output']>;
  /** Katoksen sähköt: Jatkuva sähkö (continuous) / Valosähkö (light) / Jatkuva rakenteilla (continuousUnderConstruction) / Jatkuva suunniteltu (continuousPlanned) / Tilapäisesti pois (temporarilyOff) / Ei sähköä (none) */
  readonly shelter_electricity?: Maybe<Scalars['String']['output']>;
  /** Extrernal shelter id */
  readonly shelter_external_id?: Maybe<Scalars['String']['output']>;
  /** Internal shelter number */
  readonly shelter_number?: Maybe<Scalars['Int']['output']>;
  /** Katoksen tyyppi: Lasikatos (glass) / Teräskatos (steel) / Tolppa (post) / Urbaanikatos (urban) / Betonikatos (concrete) / Puukatos (wooden) / Virtuaali (virtual) */
  readonly shelter_type?: Maybe<Scalars['String']['output']>;
  readonly sign_content_type?: Maybe<Scalars['String']['output']>;
  readonly sign_graphic?: Maybe<Scalars['String']['output']>;
  /** Aikataulukaappien lukumäärä */
  readonly timetable_cabinets?: Maybe<Scalars['Int']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly wheelchair_area_length?: Maybe<Scalars['numeric']['output']>;
  readonly wheelchair_area_width?: Maybe<Scalars['numeric']['output']>;
  readonly width?: Maybe<Scalars['numeric']['output']>;
};

/** response of any mutation on the table "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructureMutationResponse = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructure>;
};

/** input type for inserting object relation for remote table "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructureObjRelInsertInput = {
  readonly data: StopsDatabaseInstalledEquipmentVersionStructureInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureOnConflict>;
};

/** on_conflict condition type for table "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructureOnConflict = {
  readonly constraint: StopsDatabaseInstalledEquipmentVersionStructureConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
};

/** Ordering options when selecting data from "installed_equipment_version_structure". */
export type StopsDatabaseInstalledEquipmentVersionStructureOrderBy = {
  readonly air_conditioned?: InputMaybe<OrderBy>;
  readonly bicycle_parking?: InputMaybe<OrderBy>;
  readonly brand_graphic?: InputMaybe<OrderBy>;
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly class_of_use_ref?: InputMaybe<OrderBy>;
  readonly content_lang?: InputMaybe<OrderBy>;
  readonly content_value?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly cycle_storage_type?: InputMaybe<OrderBy>;
  readonly dtype?: InputMaybe<OrderBy>;
  readonly enclosed?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly gender?: InputMaybe<OrderBy>;
  readonly heated?: InputMaybe<OrderBy>;
  readonly height?: InputMaybe<OrderBy>;
  readonly height_from_floor?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly installed_equipment_version_structure_installed_equipments_aggregate?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAggregateOrderBy>;
  readonly leaning_rail?: InputMaybe<OrderBy>;
  readonly length?: InputMaybe<OrderBy>;
  readonly line_signage?: InputMaybe<OrderBy>;
  readonly machine_readable?: InputMaybe<OrderBy>;
  readonly main_line_sign?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly note_lang?: InputMaybe<OrderBy>;
  readonly note_value?: InputMaybe<OrderBy>;
  readonly number_of_frames?: InputMaybe<OrderBy>;
  readonly number_of_machines?: InputMaybe<OrderBy>;
  readonly number_of_spaces?: InputMaybe<OrderBy>;
  readonly number_of_toilets?: InputMaybe<OrderBy>;
  readonly out_of_service?: InputMaybe<OrderBy>;
  readonly outside_bench?: InputMaybe<OrderBy>;
  readonly private_code_type?: InputMaybe<OrderBy>;
  readonly private_code_value?: InputMaybe<OrderBy>;
  readonly replaces_rail_sign?: InputMaybe<OrderBy>;
  readonly seats?: InputMaybe<OrderBy>;
  readonly shelter_condition?: InputMaybe<OrderBy>;
  readonly shelter_electricity?: InputMaybe<OrderBy>;
  readonly shelter_external_id?: InputMaybe<OrderBy>;
  readonly shelter_fascia_board_taping?: InputMaybe<OrderBy>;
  readonly shelter_has_display?: InputMaybe<OrderBy>;
  readonly shelter_lighting?: InputMaybe<OrderBy>;
  readonly shelter_number?: InputMaybe<OrderBy>;
  readonly shelter_type?: InputMaybe<OrderBy>;
  readonly sign_content_type?: InputMaybe<OrderBy>;
  readonly sign_graphic?: InputMaybe<OrderBy>;
  readonly smoking_allowed?: InputMaybe<OrderBy>;
  readonly step_free?: InputMaybe<OrderBy>;
  readonly ticket_machines?: InputMaybe<OrderBy>;
  readonly ticket_office?: InputMaybe<OrderBy>;
  readonly timetable_cabinets?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly trash_can?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
  readonly wheelchair_area_length?: InputMaybe<OrderBy>;
  readonly wheelchair_area_width?: InputMaybe<OrderBy>;
  readonly width?: InputMaybe<OrderBy>;
  readonly women_only?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: installed_equipment_version_structure */
export type StopsDatabaseInstalledEquipmentVersionStructurePkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "installed_equipment_version_structure" */
export enum StopsDatabaseInstalledEquipmentVersionStructureSelectColumn {
  /** column name */
  AirConditioned = 'air_conditioned',
  /** column name */
  BicycleParking = 'bicycle_parking',
  /** column name */
  BrandGraphic = 'brand_graphic',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  ClassOfUseRef = 'class_of_use_ref',
  /** column name */
  ContentLang = 'content_lang',
  /** column name */
  ContentValue = 'content_value',
  /** column name */
  Created = 'created',
  /** column name */
  CycleStorageType = 'cycle_storage_type',
  /** column name */
  Dtype = 'dtype',
  /** column name */
  Enclosed = 'enclosed',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Gender = 'gender',
  /** column name */
  Heated = 'heated',
  /** column name */
  Height = 'height',
  /** column name */
  HeightFromFloor = 'height_from_floor',
  /** column name */
  Id = 'id',
  /** column name */
  LeaningRail = 'leaning_rail',
  /** column name */
  Length = 'length',
  /** column name */
  LineSignage = 'line_signage',
  /** column name */
  MachineReadable = 'machine_readable',
  /** column name */
  MainLineSign = 'main_line_sign',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  NoteLang = 'note_lang',
  /** column name */
  NoteValue = 'note_value',
  /** column name */
  NumberOfFrames = 'number_of_frames',
  /** column name */
  NumberOfMachines = 'number_of_machines',
  /** column name */
  NumberOfSpaces = 'number_of_spaces',
  /** column name */
  NumberOfToilets = 'number_of_toilets',
  /** column name */
  OutOfService = 'out_of_service',
  /** column name */
  OutsideBench = 'outside_bench',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ReplacesRailSign = 'replaces_rail_sign',
  /** column name */
  Seats = 'seats',
  /** column name */
  ShelterCondition = 'shelter_condition',
  /** column name */
  ShelterElectricity = 'shelter_electricity',
  /** column name */
  ShelterExternalId = 'shelter_external_id',
  /** column name */
  ShelterFasciaBoardTaping = 'shelter_fascia_board_taping',
  /** column name */
  ShelterHasDisplay = 'shelter_has_display',
  /** column name */
  ShelterLighting = 'shelter_lighting',
  /** column name */
  ShelterNumber = 'shelter_number',
  /** column name */
  ShelterType = 'shelter_type',
  /** column name */
  SignContentType = 'sign_content_type',
  /** column name */
  SignGraphic = 'sign_graphic',
  /** column name */
  SmokingAllowed = 'smoking_allowed',
  /** column name */
  StepFree = 'step_free',
  /** column name */
  TicketMachines = 'ticket_machines',
  /** column name */
  TicketOffice = 'ticket_office',
  /** column name */
  TimetableCabinets = 'timetable_cabinets',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TrashCan = 'trash_can',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  WheelchairAreaLength = 'wheelchair_area_length',
  /** column name */
  WheelchairAreaWidth = 'wheelchair_area_width',
  /** column name */
  Width = 'width',
  /** column name */
  WomenOnly = 'women_only'
}

/** input type for updating data in table "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructureSetInput = {
  readonly air_conditioned?: InputMaybe<Scalars['Boolean']['input']>;
  /** Pyöräpysäköinti */
  readonly bicycle_parking?: InputMaybe<Scalars['Boolean']['input']>;
  readonly brand_graphic?: InputMaybe<Scalars['String']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly class_of_use_ref?: InputMaybe<Scalars['bytea']['input']>;
  readonly content_lang?: InputMaybe<Scalars['String']['input']>;
  readonly content_value?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly cycle_storage_type?: InputMaybe<Scalars['Int']['input']>;
  readonly dtype?: InputMaybe<Scalars['String']['input']>;
  readonly enclosed?: InputMaybe<Scalars['Boolean']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly gender?: InputMaybe<Scalars['Int']['input']>;
  readonly heated?: InputMaybe<Scalars['Boolean']['input']>;
  readonly height?: InputMaybe<Scalars['numeric']['input']>;
  readonly height_from_floor?: InputMaybe<Scalars['numeric']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  /** Nojailutanko */
  readonly leaning_rail?: InputMaybe<Scalars['Boolean']['input']>;
  readonly length?: InputMaybe<Scalars['numeric']['input']>;
  readonly line_signage?: InputMaybe<Scalars['Boolean']['input']>;
  readonly machine_readable?: InputMaybe<Scalars['Boolean']['input']>;
  readonly main_line_sign?: InputMaybe<Scalars['Boolean']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly note_lang?: InputMaybe<Scalars['String']['input']>;
  readonly note_value?: InputMaybe<Scalars['String']['input']>;
  readonly number_of_frames?: InputMaybe<Scalars['Int']['input']>;
  readonly number_of_machines?: InputMaybe<Scalars['numeric']['input']>;
  readonly number_of_spaces?: InputMaybe<Scalars['numeric']['input']>;
  readonly number_of_toilets?: InputMaybe<Scalars['numeric']['input']>;
  readonly out_of_service?: InputMaybe<Scalars['Boolean']['input']>;
  /** Ulkopenkki */
  readonly outside_bench?: InputMaybe<Scalars['Boolean']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly replaces_rail_sign?: InputMaybe<Scalars['Boolean']['input']>;
  readonly seats?: InputMaybe<Scalars['numeric']['input']>;
  /** Katoksen kunto: Hyvä (good), Välttävä (mediocre), Huono (bad) */
  readonly shelter_condition?: InputMaybe<Scalars['String']['input']>;
  /** Katoksen sähköt: Jatkuva sähkö (continuous) / Valosähkö (light) / Jatkuva rakenteilla (continuousUnderConstruction) / Jatkuva suunniteltu (continuousPlanned) / Tilapäisesti pois (temporarilyOff) / Ei sähköä (none) */
  readonly shelter_electricity?: InputMaybe<Scalars['String']['input']>;
  /** Extrernal shelter id */
  readonly shelter_external_id?: InputMaybe<Scalars['String']['input']>;
  /** Pysäkkikatoksen otsalaudan teippaus */
  readonly shelter_fascia_board_taping?: InputMaybe<Scalars['Boolean']['input']>;
  /** Katoksesssa näyttö */
  readonly shelter_has_display?: InputMaybe<Scalars['Boolean']['input']>;
  /** Katoksessa valot */
  readonly shelter_lighting?: InputMaybe<Scalars['Boolean']['input']>;
  /** Internal shelter number */
  readonly shelter_number?: InputMaybe<Scalars['Int']['input']>;
  /** Katoksen tyyppi: Lasikatos (glass) / Teräskatos (steel) / Tolppa (post) / Urbaanikatos (urban) / Betonikatos (concrete) / Puukatos (wooden) / Virtuaali (virtual) */
  readonly shelter_type?: InputMaybe<Scalars['String']['input']>;
  readonly sign_content_type?: InputMaybe<Scalars['String']['input']>;
  readonly sign_graphic?: InputMaybe<Scalars['String']['input']>;
  readonly smoking_allowed?: InputMaybe<Scalars['Boolean']['input']>;
  readonly step_free?: InputMaybe<Scalars['Boolean']['input']>;
  readonly ticket_machines?: InputMaybe<Scalars['Boolean']['input']>;
  readonly ticket_office?: InputMaybe<Scalars['Boolean']['input']>;
  /** Aikataulukaappien lukumäärä */
  readonly timetable_cabinets?: InputMaybe<Scalars['Int']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  /** Katoksessa roska-astia */
  readonly trash_can?: InputMaybe<Scalars['Boolean']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
  readonly wheelchair_area_length?: InputMaybe<Scalars['numeric']['input']>;
  readonly wheelchair_area_width?: InputMaybe<Scalars['numeric']['input']>;
  readonly width?: InputMaybe<Scalars['numeric']['input']>;
  readonly women_only?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureStddevFields = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_stddev_fields';
  readonly cycle_storage_type?: Maybe<Scalars['Float']['output']>;
  readonly gender?: Maybe<Scalars['Float']['output']>;
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly height_from_floor?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly length?: Maybe<Scalars['Float']['output']>;
  readonly number_of_frames?: Maybe<Scalars['Float']['output']>;
  readonly number_of_machines?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['Float']['output']>;
  readonly number_of_toilets?: Maybe<Scalars['Float']['output']>;
  readonly seats?: Maybe<Scalars['Float']['output']>;
  /** Internal shelter number */
  readonly shelter_number?: Maybe<Scalars['Float']['output']>;
  /** Aikataulukaappien lukumäärä */
  readonly timetable_cabinets?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_length?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_width?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureStddevPopFields = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_stddev_pop_fields';
  readonly cycle_storage_type?: Maybe<Scalars['Float']['output']>;
  readonly gender?: Maybe<Scalars['Float']['output']>;
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly height_from_floor?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly length?: Maybe<Scalars['Float']['output']>;
  readonly number_of_frames?: Maybe<Scalars['Float']['output']>;
  readonly number_of_machines?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['Float']['output']>;
  readonly number_of_toilets?: Maybe<Scalars['Float']['output']>;
  readonly seats?: Maybe<Scalars['Float']['output']>;
  /** Internal shelter number */
  readonly shelter_number?: Maybe<Scalars['Float']['output']>;
  /** Aikataulukaappien lukumäärä */
  readonly timetable_cabinets?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_length?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_width?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureStddevSampFields = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_stddev_samp_fields';
  readonly cycle_storage_type?: Maybe<Scalars['Float']['output']>;
  readonly gender?: Maybe<Scalars['Float']['output']>;
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly height_from_floor?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly length?: Maybe<Scalars['Float']['output']>;
  readonly number_of_frames?: Maybe<Scalars['Float']['output']>;
  readonly number_of_machines?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['Float']['output']>;
  readonly number_of_toilets?: Maybe<Scalars['Float']['output']>;
  readonly seats?: Maybe<Scalars['Float']['output']>;
  /** Internal shelter number */
  readonly shelter_number?: Maybe<Scalars['Float']['output']>;
  /** Aikataulukaappien lukumäärä */
  readonly timetable_cabinets?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_length?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_width?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "installed_equipment_version_structure" */
export type StopsDatabaseInstalledEquipmentVersionStructureStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseInstalledEquipmentVersionStructureStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseInstalledEquipmentVersionStructureStreamCursorValueInput = {
  readonly air_conditioned?: InputMaybe<Scalars['Boolean']['input']>;
  /** Pyöräpysäköinti */
  readonly bicycle_parking?: InputMaybe<Scalars['Boolean']['input']>;
  readonly brand_graphic?: InputMaybe<Scalars['String']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly class_of_use_ref?: InputMaybe<Scalars['bytea']['input']>;
  readonly content_lang?: InputMaybe<Scalars['String']['input']>;
  readonly content_value?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly cycle_storage_type?: InputMaybe<Scalars['Int']['input']>;
  readonly dtype?: InputMaybe<Scalars['String']['input']>;
  readonly enclosed?: InputMaybe<Scalars['Boolean']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly gender?: InputMaybe<Scalars['Int']['input']>;
  readonly heated?: InputMaybe<Scalars['Boolean']['input']>;
  readonly height?: InputMaybe<Scalars['numeric']['input']>;
  readonly height_from_floor?: InputMaybe<Scalars['numeric']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  /** Nojailutanko */
  readonly leaning_rail?: InputMaybe<Scalars['Boolean']['input']>;
  readonly length?: InputMaybe<Scalars['numeric']['input']>;
  readonly line_signage?: InputMaybe<Scalars['Boolean']['input']>;
  readonly machine_readable?: InputMaybe<Scalars['Boolean']['input']>;
  readonly main_line_sign?: InputMaybe<Scalars['Boolean']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly note_lang?: InputMaybe<Scalars['String']['input']>;
  readonly note_value?: InputMaybe<Scalars['String']['input']>;
  readonly number_of_frames?: InputMaybe<Scalars['Int']['input']>;
  readonly number_of_machines?: InputMaybe<Scalars['numeric']['input']>;
  readonly number_of_spaces?: InputMaybe<Scalars['numeric']['input']>;
  readonly number_of_toilets?: InputMaybe<Scalars['numeric']['input']>;
  readonly out_of_service?: InputMaybe<Scalars['Boolean']['input']>;
  /** Ulkopenkki */
  readonly outside_bench?: InputMaybe<Scalars['Boolean']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly replaces_rail_sign?: InputMaybe<Scalars['Boolean']['input']>;
  readonly seats?: InputMaybe<Scalars['numeric']['input']>;
  /** Katoksen kunto: Hyvä (good), Välttävä (mediocre), Huono (bad) */
  readonly shelter_condition?: InputMaybe<Scalars['String']['input']>;
  /** Katoksen sähköt: Jatkuva sähkö (continuous) / Valosähkö (light) / Jatkuva rakenteilla (continuousUnderConstruction) / Jatkuva suunniteltu (continuousPlanned) / Tilapäisesti pois (temporarilyOff) / Ei sähköä (none) */
  readonly shelter_electricity?: InputMaybe<Scalars['String']['input']>;
  /** Extrernal shelter id */
  readonly shelter_external_id?: InputMaybe<Scalars['String']['input']>;
  /** Pysäkkikatoksen otsalaudan teippaus */
  readonly shelter_fascia_board_taping?: InputMaybe<Scalars['Boolean']['input']>;
  /** Katoksesssa näyttö */
  readonly shelter_has_display?: InputMaybe<Scalars['Boolean']['input']>;
  /** Katoksessa valot */
  readonly shelter_lighting?: InputMaybe<Scalars['Boolean']['input']>;
  /** Internal shelter number */
  readonly shelter_number?: InputMaybe<Scalars['Int']['input']>;
  /** Katoksen tyyppi: Lasikatos (glass) / Teräskatos (steel) / Tolppa (post) / Urbaanikatos (urban) / Betonikatos (concrete) / Puukatos (wooden) / Virtuaali (virtual) */
  readonly shelter_type?: InputMaybe<Scalars['String']['input']>;
  readonly sign_content_type?: InputMaybe<Scalars['String']['input']>;
  readonly sign_graphic?: InputMaybe<Scalars['String']['input']>;
  readonly smoking_allowed?: InputMaybe<Scalars['Boolean']['input']>;
  readonly step_free?: InputMaybe<Scalars['Boolean']['input']>;
  readonly ticket_machines?: InputMaybe<Scalars['Boolean']['input']>;
  readonly ticket_office?: InputMaybe<Scalars['Boolean']['input']>;
  /** Aikataulukaappien lukumäärä */
  readonly timetable_cabinets?: InputMaybe<Scalars['Int']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  /** Katoksessa roska-astia */
  readonly trash_can?: InputMaybe<Scalars['Boolean']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
  readonly wheelchair_area_length?: InputMaybe<Scalars['numeric']['input']>;
  readonly wheelchair_area_width?: InputMaybe<Scalars['numeric']['input']>;
  readonly width?: InputMaybe<Scalars['numeric']['input']>;
  readonly women_only?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureSumFields = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_sum_fields';
  readonly cycle_storage_type?: Maybe<Scalars['Int']['output']>;
  readonly gender?: Maybe<Scalars['Int']['output']>;
  readonly height?: Maybe<Scalars['numeric']['output']>;
  readonly height_from_floor?: Maybe<Scalars['numeric']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly length?: Maybe<Scalars['numeric']['output']>;
  readonly number_of_frames?: Maybe<Scalars['Int']['output']>;
  readonly number_of_machines?: Maybe<Scalars['numeric']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['numeric']['output']>;
  readonly number_of_toilets?: Maybe<Scalars['numeric']['output']>;
  readonly seats?: Maybe<Scalars['numeric']['output']>;
  /** Internal shelter number */
  readonly shelter_number?: Maybe<Scalars['Int']['output']>;
  /** Aikataulukaappien lukumäärä */
  readonly timetable_cabinets?: Maybe<Scalars['Int']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly wheelchair_area_length?: Maybe<Scalars['numeric']['output']>;
  readonly wheelchair_area_width?: Maybe<Scalars['numeric']['output']>;
  readonly width?: Maybe<Scalars['numeric']['output']>;
};

/** update columns of table "installed_equipment_version_structure" */
export enum StopsDatabaseInstalledEquipmentVersionStructureUpdateColumn {
  /** column name */
  AirConditioned = 'air_conditioned',
  /** column name */
  BicycleParking = 'bicycle_parking',
  /** column name */
  BrandGraphic = 'brand_graphic',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  ClassOfUseRef = 'class_of_use_ref',
  /** column name */
  ContentLang = 'content_lang',
  /** column name */
  ContentValue = 'content_value',
  /** column name */
  Created = 'created',
  /** column name */
  CycleStorageType = 'cycle_storage_type',
  /** column name */
  Dtype = 'dtype',
  /** column name */
  Enclosed = 'enclosed',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Gender = 'gender',
  /** column name */
  Heated = 'heated',
  /** column name */
  Height = 'height',
  /** column name */
  HeightFromFloor = 'height_from_floor',
  /** column name */
  Id = 'id',
  /** column name */
  LeaningRail = 'leaning_rail',
  /** column name */
  Length = 'length',
  /** column name */
  LineSignage = 'line_signage',
  /** column name */
  MachineReadable = 'machine_readable',
  /** column name */
  MainLineSign = 'main_line_sign',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  NoteLang = 'note_lang',
  /** column name */
  NoteValue = 'note_value',
  /** column name */
  NumberOfFrames = 'number_of_frames',
  /** column name */
  NumberOfMachines = 'number_of_machines',
  /** column name */
  NumberOfSpaces = 'number_of_spaces',
  /** column name */
  NumberOfToilets = 'number_of_toilets',
  /** column name */
  OutOfService = 'out_of_service',
  /** column name */
  OutsideBench = 'outside_bench',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ReplacesRailSign = 'replaces_rail_sign',
  /** column name */
  Seats = 'seats',
  /** column name */
  ShelterCondition = 'shelter_condition',
  /** column name */
  ShelterElectricity = 'shelter_electricity',
  /** column name */
  ShelterExternalId = 'shelter_external_id',
  /** column name */
  ShelterFasciaBoardTaping = 'shelter_fascia_board_taping',
  /** column name */
  ShelterHasDisplay = 'shelter_has_display',
  /** column name */
  ShelterLighting = 'shelter_lighting',
  /** column name */
  ShelterNumber = 'shelter_number',
  /** column name */
  ShelterType = 'shelter_type',
  /** column name */
  SignContentType = 'sign_content_type',
  /** column name */
  SignGraphic = 'sign_graphic',
  /** column name */
  SmokingAllowed = 'smoking_allowed',
  /** column name */
  StepFree = 'step_free',
  /** column name */
  TicketMachines = 'ticket_machines',
  /** column name */
  TicketOffice = 'ticket_office',
  /** column name */
  TimetableCabinets = 'timetable_cabinets',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TrashCan = 'trash_can',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  WheelchairAreaLength = 'wheelchair_area_length',
  /** column name */
  WheelchairAreaWidth = 'wheelchair_area_width',
  /** column name */
  Width = 'width',
  /** column name */
  WomenOnly = 'women_only'
}

export type StopsDatabaseInstalledEquipmentVersionStructureUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseInstalledEquipmentVersionStructureBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureVarPopFields = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_var_pop_fields';
  readonly cycle_storage_type?: Maybe<Scalars['Float']['output']>;
  readonly gender?: Maybe<Scalars['Float']['output']>;
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly height_from_floor?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly length?: Maybe<Scalars['Float']['output']>;
  readonly number_of_frames?: Maybe<Scalars['Float']['output']>;
  readonly number_of_machines?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['Float']['output']>;
  readonly number_of_toilets?: Maybe<Scalars['Float']['output']>;
  readonly seats?: Maybe<Scalars['Float']['output']>;
  /** Internal shelter number */
  readonly shelter_number?: Maybe<Scalars['Float']['output']>;
  /** Aikataulukaappien lukumäärä */
  readonly timetable_cabinets?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_length?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_width?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureVarSampFields = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_var_samp_fields';
  readonly cycle_storage_type?: Maybe<Scalars['Float']['output']>;
  readonly gender?: Maybe<Scalars['Float']['output']>;
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly height_from_floor?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly length?: Maybe<Scalars['Float']['output']>;
  readonly number_of_frames?: Maybe<Scalars['Float']['output']>;
  readonly number_of_machines?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['Float']['output']>;
  readonly number_of_toilets?: Maybe<Scalars['Float']['output']>;
  readonly seats?: Maybe<Scalars['Float']['output']>;
  /** Internal shelter number */
  readonly shelter_number?: Maybe<Scalars['Float']['output']>;
  /** Aikataulukaappien lukumäärä */
  readonly timetable_cabinets?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_length?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_width?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseInstalledEquipmentVersionStructureVarianceFields = {
  readonly __typename?: 'stops_database_installed_equipment_version_structure_variance_fields';
  readonly cycle_storage_type?: Maybe<Scalars['Float']['output']>;
  readonly gender?: Maybe<Scalars['Float']['output']>;
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly height_from_floor?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly length?: Maybe<Scalars['Float']['output']>;
  readonly number_of_frames?: Maybe<Scalars['Float']['output']>;
  readonly number_of_machines?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['Float']['output']>;
  readonly number_of_toilets?: Maybe<Scalars['Float']['output']>;
  readonly seats?: Maybe<Scalars['Float']['output']>;
  /** Internal shelter number */
  readonly shelter_number?: Maybe<Scalars['Float']['output']>;
  /** Aikataulukaappien lukumäärä */
  readonly timetable_cabinets?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_length?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_width?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "level" */
export type StopsDatabaseLevel = {
  readonly __typename?: 'stops_database_level';
  readonly all_areas_wheelchair_accessible?: Maybe<Scalars['Boolean']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_id?: Maybe<Scalars['bigint']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id: Scalars['bigint']['output'];
  /** An array relationship */
  readonly level_key_values: ReadonlyArray<StopsDatabaseLevelKeyValues>;
  /** An aggregate relationship */
  readonly level_key_values_aggregate: StopsDatabaseLevelKeyValuesAggregate;
  /** An object relationship */
  readonly multilingualStringEntityByNameId?: Maybe<StopsDatabaseMultilingualStringEntity>;
  /** An object relationship */
  readonly multilingualStringEntityByShortNameId?: Maybe<StopsDatabaseMultilingualStringEntity>;
  /** An object relationship */
  readonly multilingual_string_entity?: Maybe<StopsDatabaseMultilingualStringEntity>;
  readonly name_id?: Maybe<Scalars['bigint']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly public_code?: Maybe<Scalars['String']['output']>;
  readonly public_use?: Maybe<Scalars['Boolean']['output']>;
  readonly short_name_id?: Maybe<Scalars['bigint']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "level" */
export type StopsDatabaseLevelLevelKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseLevelKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseLevelKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseLevelKeyValuesBoolExp>;
};


/** columns and relationships of "level" */
export type StopsDatabaseLevelLevelKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseLevelKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseLevelKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseLevelKeyValuesBoolExp>;
};

/** aggregated selection of "level" */
export type StopsDatabaseLevelAggregate = {
  readonly __typename?: 'stops_database_level_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseLevelAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseLevel>;
};

/** aggregate fields of "level" */
export type StopsDatabaseLevelAggregateFields = {
  readonly __typename?: 'stops_database_level_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseLevelAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseLevelMaxFields>;
  readonly min?: Maybe<StopsDatabaseLevelMinFields>;
  readonly stddev?: Maybe<StopsDatabaseLevelStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseLevelStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseLevelStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseLevelSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseLevelVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseLevelVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseLevelVarianceFields>;
};


/** aggregate fields of "level" */
export type StopsDatabaseLevelAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseLevelSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseLevelAvgFields = {
  readonly __typename?: 'stops_database_level_avg_fields';
  readonly description_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly name_id?: Maybe<Scalars['Float']['output']>;
  readonly short_name_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "level". All fields are combined with a logical 'AND'. */
export type StopsDatabaseLevelBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseLevelBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseLevelBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseLevelBoolExp>>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<BooleanComparisonExp>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly description_id?: InputMaybe<BigintComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly level_key_values?: InputMaybe<StopsDatabaseLevelKeyValuesBoolExp>;
  readonly level_key_values_aggregate?: InputMaybe<LevelKeyValuesAggregateBoolExp>;
  readonly multilingualStringEntityByNameId?: InputMaybe<StopsDatabaseMultilingualStringEntityBoolExp>;
  readonly multilingualStringEntityByShortNameId?: InputMaybe<StopsDatabaseMultilingualStringEntityBoolExp>;
  readonly multilingual_string_entity?: InputMaybe<StopsDatabaseMultilingualStringEntityBoolExp>;
  readonly name_id?: InputMaybe<BigintComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly public_code?: InputMaybe<StringComparisonExp>;
  readonly public_use?: InputMaybe<BooleanComparisonExp>;
  readonly short_name_id?: InputMaybe<BigintComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "level" */
export enum StopsDatabaseLevelConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  LevelNetexIdVersionConstraint = 'level_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  LevelPkey = 'level_pkey'
}

/** input type for incrementing numeric columns in table "level" */
export type StopsDatabaseLevelIncInput = {
  readonly description_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly short_name_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "level" */
export type StopsDatabaseLevelInsertInput = {
  readonly all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly level_key_values?: InputMaybe<StopsDatabaseLevelKeyValuesArrRelInsertInput>;
  readonly multilingualStringEntityByNameId?: InputMaybe<StopsDatabaseMultilingualStringEntityObjRelInsertInput>;
  readonly multilingualStringEntityByShortNameId?: InputMaybe<StopsDatabaseMultilingualStringEntityObjRelInsertInput>;
  readonly multilingual_string_entity?: InputMaybe<StopsDatabaseMultilingualStringEntityObjRelInsertInput>;
  readonly name_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly public_code?: InputMaybe<Scalars['String']['input']>;
  readonly public_use?: InputMaybe<Scalars['Boolean']['input']>;
  readonly short_name_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "level_key_values" */
export type StopsDatabaseLevelKeyValues = {
  readonly __typename?: 'stops_database_level_key_values';
  readonly key_values_id: Scalars['bigint']['output'];
  readonly key_values_key: Scalars['String']['output'];
  readonly level_id: Scalars['bigint']['output'];
  /** An object relationship */
  readonly value: StopsDatabaseValue;
};

/** aggregated selection of "level_key_values" */
export type StopsDatabaseLevelKeyValuesAggregate = {
  readonly __typename?: 'stops_database_level_key_values_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseLevelKeyValuesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseLevelKeyValues>;
};

/** aggregate fields of "level_key_values" */
export type StopsDatabaseLevelKeyValuesAggregateFields = {
  readonly __typename?: 'stops_database_level_key_values_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseLevelKeyValuesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseLevelKeyValuesMaxFields>;
  readonly min?: Maybe<StopsDatabaseLevelKeyValuesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseLevelKeyValuesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseLevelKeyValuesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseLevelKeyValuesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseLevelKeyValuesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseLevelKeyValuesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseLevelKeyValuesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseLevelKeyValuesVarianceFields>;
};


/** aggregate fields of "level_key_values" */
export type StopsDatabaseLevelKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseLevelKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "level_key_values" */
export type StopsDatabaseLevelKeyValuesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseLevelKeyValuesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseLevelKeyValuesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseLevelKeyValuesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseLevelKeyValuesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseLevelKeyValuesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseLevelKeyValuesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseLevelKeyValuesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseLevelKeyValuesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseLevelKeyValuesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseLevelKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "level_key_values" */
export type StopsDatabaseLevelKeyValuesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseLevelKeyValuesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseLevelKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseLevelKeyValuesAvgFields = {
  readonly __typename?: 'stops_database_level_key_values_avg_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly level_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "level_key_values" */
export type StopsDatabaseLevelKeyValuesAvgOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly level_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "level_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseLevelKeyValuesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseLevelKeyValuesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseLevelKeyValuesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseLevelKeyValuesBoolExp>>;
  readonly key_values_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_key?: InputMaybe<StringComparisonExp>;
  readonly level_id?: InputMaybe<BigintComparisonExp>;
  readonly value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "level_key_values" */
export enum StopsDatabaseLevelKeyValuesConstraint {
  /** unique or primary key constraint on columns "key_values_key", "level_id" */
  LevelKeyValuesPkey = 'level_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  Uk_4eghmku46yje2lg3f1u6p949e = 'uk_4eghmku46yje2lg3f1u6p949e'
}

/** input type for incrementing numeric columns in table "level_key_values" */
export type StopsDatabaseLevelKeyValuesIncInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly level_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "level_key_values" */
export type StopsDatabaseLevelKeyValuesInsertInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly level_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseLevelKeyValuesMaxFields = {
  readonly __typename?: 'stops_database_level_key_values_max_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
  readonly level_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "level_key_values" */
export type StopsDatabaseLevelKeyValuesMaxOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly level_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseLevelKeyValuesMinFields = {
  readonly __typename?: 'stops_database_level_key_values_min_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
  readonly level_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "level_key_values" */
export type StopsDatabaseLevelKeyValuesMinOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly level_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "level_key_values" */
export type StopsDatabaseLevelKeyValuesMutationResponse = {
  readonly __typename?: 'stops_database_level_key_values_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseLevelKeyValues>;
};

/** on_conflict condition type for table "level_key_values" */
export type StopsDatabaseLevelKeyValuesOnConflict = {
  readonly constraint: StopsDatabaseLevelKeyValuesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseLevelKeyValuesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseLevelKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "level_key_values". */
export type StopsDatabaseLevelKeyValuesOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly level_id?: InputMaybe<OrderBy>;
  readonly value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: level_key_values */
export type StopsDatabaseLevelKeyValuesPkColumnsInput = {
  readonly key_values_key: Scalars['String']['input'];
  readonly level_id: Scalars['bigint']['input'];
};

/** select columns of table "level_key_values" */
export enum StopsDatabaseLevelKeyValuesSelectColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  LevelId = 'level_id'
}

/** input type for updating data in table "level_key_values" */
export type StopsDatabaseLevelKeyValuesSetInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly level_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseLevelKeyValuesStddevFields = {
  readonly __typename?: 'stops_database_level_key_values_stddev_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly level_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "level_key_values" */
export type StopsDatabaseLevelKeyValuesStddevOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly level_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseLevelKeyValuesStddevPopFields = {
  readonly __typename?: 'stops_database_level_key_values_stddev_pop_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly level_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "level_key_values" */
export type StopsDatabaseLevelKeyValuesStddevPopOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly level_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseLevelKeyValuesStddevSampFields = {
  readonly __typename?: 'stops_database_level_key_values_stddev_samp_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly level_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "level_key_values" */
export type StopsDatabaseLevelKeyValuesStddevSampOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly level_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "level_key_values" */
export type StopsDatabaseLevelKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseLevelKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseLevelKeyValuesStreamCursorValueInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly level_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseLevelKeyValuesSumFields = {
  readonly __typename?: 'stops_database_level_key_values_sum_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly level_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "level_key_values" */
export type StopsDatabaseLevelKeyValuesSumOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly level_id?: InputMaybe<OrderBy>;
};

/** update columns of table "level_key_values" */
export enum StopsDatabaseLevelKeyValuesUpdateColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  LevelId = 'level_id'
}

export type StopsDatabaseLevelKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseLevelKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseLevelKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseLevelKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseLevelKeyValuesVarPopFields = {
  readonly __typename?: 'stops_database_level_key_values_var_pop_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly level_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "level_key_values" */
export type StopsDatabaseLevelKeyValuesVarPopOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly level_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseLevelKeyValuesVarSampFields = {
  readonly __typename?: 'stops_database_level_key_values_var_samp_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly level_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "level_key_values" */
export type StopsDatabaseLevelKeyValuesVarSampOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly level_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseLevelKeyValuesVarianceFields = {
  readonly __typename?: 'stops_database_level_key_values_variance_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly level_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "level_key_values" */
export type StopsDatabaseLevelKeyValuesVarianceOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly level_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseLevelMaxFields = {
  readonly __typename?: 'stops_database_level_max_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_id?: Maybe<Scalars['bigint']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly name_id?: Maybe<Scalars['bigint']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly public_code?: Maybe<Scalars['String']['output']>;
  readonly short_name_id?: Maybe<Scalars['bigint']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseLevelMinFields = {
  readonly __typename?: 'stops_database_level_min_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_id?: Maybe<Scalars['bigint']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly name_id?: Maybe<Scalars['bigint']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly public_code?: Maybe<Scalars['String']['output']>;
  readonly short_name_id?: Maybe<Scalars['bigint']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "level" */
export type StopsDatabaseLevelMutationResponse = {
  readonly __typename?: 'stops_database_level_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseLevel>;
};

/** on_conflict condition type for table "level" */
export type StopsDatabaseLevelOnConflict = {
  readonly constraint: StopsDatabaseLevelConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseLevelUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseLevelBoolExp>;
};

/** Ordering options when selecting data from "level". */
export type StopsDatabaseLevelOrderBy = {
  readonly all_areas_wheelchair_accessible?: InputMaybe<OrderBy>;
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly description_id?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly level_key_values_aggregate?: InputMaybe<StopsDatabaseLevelKeyValuesAggregateOrderBy>;
  readonly multilingualStringEntityByNameId?: InputMaybe<StopsDatabaseMultilingualStringEntityOrderBy>;
  readonly multilingualStringEntityByShortNameId?: InputMaybe<StopsDatabaseMultilingualStringEntityOrderBy>;
  readonly multilingual_string_entity?: InputMaybe<StopsDatabaseMultilingualStringEntityOrderBy>;
  readonly name_id?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly public_code?: InputMaybe<OrderBy>;
  readonly public_use?: InputMaybe<OrderBy>;
  readonly short_name_id?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: level */
export type StopsDatabaseLevelPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "level" */
export enum StopsDatabaseLevelSelectColumn {
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionId = 'description_id',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameId = 'name_id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PublicCode = 'public_code',
  /** column name */
  PublicUse = 'public_use',
  /** column name */
  ShortNameId = 'short_name_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

/** input type for updating data in table "level" */
export type StopsDatabaseLevelSetInput = {
  readonly all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly public_code?: InputMaybe<Scalars['String']['input']>;
  readonly public_use?: InputMaybe<Scalars['Boolean']['input']>;
  readonly short_name_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseLevelStddevFields = {
  readonly __typename?: 'stops_database_level_stddev_fields';
  readonly description_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly name_id?: Maybe<Scalars['Float']['output']>;
  readonly short_name_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseLevelStddevPopFields = {
  readonly __typename?: 'stops_database_level_stddev_pop_fields';
  readonly description_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly name_id?: Maybe<Scalars['Float']['output']>;
  readonly short_name_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseLevelStddevSampFields = {
  readonly __typename?: 'stops_database_level_stddev_samp_fields';
  readonly description_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly name_id?: Maybe<Scalars['Float']['output']>;
  readonly short_name_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "level" */
export type StopsDatabaseLevelStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseLevelStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseLevelStreamCursorValueInput = {
  readonly all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly public_code?: InputMaybe<Scalars['String']['input']>;
  readonly public_use?: InputMaybe<Scalars['Boolean']['input']>;
  readonly short_name_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseLevelSumFields = {
  readonly __typename?: 'stops_database_level_sum_fields';
  readonly description_id?: Maybe<Scalars['bigint']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly name_id?: Maybe<Scalars['bigint']['output']>;
  readonly short_name_id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "level" */
export enum StopsDatabaseLevelUpdateColumn {
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionId = 'description_id',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameId = 'name_id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PublicCode = 'public_code',
  /** column name */
  PublicUse = 'public_use',
  /** column name */
  ShortNameId = 'short_name_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

export type StopsDatabaseLevelUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseLevelIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseLevelSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseLevelBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseLevelVarPopFields = {
  readonly __typename?: 'stops_database_level_var_pop_fields';
  readonly description_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly name_id?: Maybe<Scalars['Float']['output']>;
  readonly short_name_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseLevelVarSampFields = {
  readonly __typename?: 'stops_database_level_var_samp_fields';
  readonly description_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly name_id?: Maybe<Scalars['Float']['output']>;
  readonly short_name_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseLevelVarianceFields = {
  readonly __typename?: 'stops_database_level_variance_fields';
  readonly description_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly name_id?: Maybe<Scalars['Float']['output']>;
  readonly short_name_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "multilingual_string_entity" */
export type StopsDatabaseMultilingualStringEntity = {
  readonly __typename?: 'stops_database_multilingual_string_entity';
  readonly id: Scalars['bigint']['output'];
  readonly lang?: Maybe<Scalars['String']['output']>;
  readonly value?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "multilingual_string_entity" */
export type StopsDatabaseMultilingualStringEntityAggregate = {
  readonly __typename?: 'stops_database_multilingual_string_entity_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseMultilingualStringEntityAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseMultilingualStringEntity>;
};

/** aggregate fields of "multilingual_string_entity" */
export type StopsDatabaseMultilingualStringEntityAggregateFields = {
  readonly __typename?: 'stops_database_multilingual_string_entity_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseMultilingualStringEntityAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseMultilingualStringEntityMaxFields>;
  readonly min?: Maybe<StopsDatabaseMultilingualStringEntityMinFields>;
  readonly stddev?: Maybe<StopsDatabaseMultilingualStringEntityStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseMultilingualStringEntityStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseMultilingualStringEntityStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseMultilingualStringEntitySumFields>;
  readonly var_pop?: Maybe<StopsDatabaseMultilingualStringEntityVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseMultilingualStringEntityVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseMultilingualStringEntityVarianceFields>;
};


/** aggregate fields of "multilingual_string_entity" */
export type StopsDatabaseMultilingualStringEntityAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseMultilingualStringEntitySelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseMultilingualStringEntityAvgFields = {
  readonly __typename?: 'stops_database_multilingual_string_entity_avg_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "multilingual_string_entity". All fields are combined with a logical 'AND'. */
export type StopsDatabaseMultilingualStringEntityBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseMultilingualStringEntityBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseMultilingualStringEntityBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseMultilingualStringEntityBoolExp>>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly lang?: InputMaybe<StringComparisonExp>;
  readonly value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "multilingual_string_entity" */
export enum StopsDatabaseMultilingualStringEntityConstraint {
  /** unique or primary key constraint on columns "id" */
  MultilingualStringEntityPkey = 'multilingual_string_entity_pkey'
}

/** input type for incrementing numeric columns in table "multilingual_string_entity" */
export type StopsDatabaseMultilingualStringEntityIncInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "multilingual_string_entity" */
export type StopsDatabaseMultilingualStringEntityInsertInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly lang?: InputMaybe<Scalars['String']['input']>;
  readonly value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseMultilingualStringEntityMaxFields = {
  readonly __typename?: 'stops_database_multilingual_string_entity_max_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly lang?: Maybe<Scalars['String']['output']>;
  readonly value?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseMultilingualStringEntityMinFields = {
  readonly __typename?: 'stops_database_multilingual_string_entity_min_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly lang?: Maybe<Scalars['String']['output']>;
  readonly value?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "multilingual_string_entity" */
export type StopsDatabaseMultilingualStringEntityMutationResponse = {
  readonly __typename?: 'stops_database_multilingual_string_entity_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseMultilingualStringEntity>;
};

/** input type for inserting object relation for remote table "multilingual_string_entity" */
export type StopsDatabaseMultilingualStringEntityObjRelInsertInput = {
  readonly data: StopsDatabaseMultilingualStringEntityInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseMultilingualStringEntityOnConflict>;
};

/** on_conflict condition type for table "multilingual_string_entity" */
export type StopsDatabaseMultilingualStringEntityOnConflict = {
  readonly constraint: StopsDatabaseMultilingualStringEntityConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseMultilingualStringEntityUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseMultilingualStringEntityBoolExp>;
};

/** Ordering options when selecting data from "multilingual_string_entity". */
export type StopsDatabaseMultilingualStringEntityOrderBy = {
  readonly id?: InputMaybe<OrderBy>;
  readonly lang?: InputMaybe<OrderBy>;
  readonly value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: multilingual_string_entity */
export type StopsDatabaseMultilingualStringEntityPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "multilingual_string_entity" */
export enum StopsDatabaseMultilingualStringEntitySelectColumn {
  /** column name */
  Id = 'id',
  /** column name */
  Lang = 'lang',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "multilingual_string_entity" */
export type StopsDatabaseMultilingualStringEntitySetInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly lang?: InputMaybe<Scalars['String']['input']>;
  readonly value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseMultilingualStringEntityStddevFields = {
  readonly __typename?: 'stops_database_multilingual_string_entity_stddev_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseMultilingualStringEntityStddevPopFields = {
  readonly __typename?: 'stops_database_multilingual_string_entity_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseMultilingualStringEntityStddevSampFields = {
  readonly __typename?: 'stops_database_multilingual_string_entity_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "multilingual_string_entity" */
export type StopsDatabaseMultilingualStringEntityStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseMultilingualStringEntityStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseMultilingualStringEntityStreamCursorValueInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly lang?: InputMaybe<Scalars['String']['input']>;
  readonly value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseMultilingualStringEntitySumFields = {
  readonly __typename?: 'stops_database_multilingual_string_entity_sum_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "multilingual_string_entity" */
export enum StopsDatabaseMultilingualStringEntityUpdateColumn {
  /** column name */
  Id = 'id',
  /** column name */
  Lang = 'lang',
  /** column name */
  Value = 'value'
}

export type StopsDatabaseMultilingualStringEntityUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseMultilingualStringEntityIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseMultilingualStringEntitySetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseMultilingualStringEntityBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseMultilingualStringEntityVarPopFields = {
  readonly __typename?: 'stops_database_multilingual_string_entity_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseMultilingualStringEntityVarSampFields = {
  readonly __typename?: 'stops_database_multilingual_string_entity_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseMultilingualStringEntityVarianceFields = {
  readonly __typename?: 'stops_database_multilingual_string_entity_variance_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "navigation_path" */
export type StopsDatabaseNavigationPath = {
  readonly __typename?: 'stops_database_navigation_path';
  readonly id: Scalars['String']['output'];
  readonly item_type?: Maybe<Scalars['String']['output']>;
  readonly path_id: Scalars['Int']['output'];
};

/** aggregated selection of "navigation_path" */
export type StopsDatabaseNavigationPathAggregate = {
  readonly __typename?: 'stops_database_navigation_path_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseNavigationPathAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseNavigationPath>;
};

/** aggregate fields of "navigation_path" */
export type StopsDatabaseNavigationPathAggregateFields = {
  readonly __typename?: 'stops_database_navigation_path_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseNavigationPathAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseNavigationPathMaxFields>;
  readonly min?: Maybe<StopsDatabaseNavigationPathMinFields>;
  readonly stddev?: Maybe<StopsDatabaseNavigationPathStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseNavigationPathStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseNavigationPathStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseNavigationPathSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseNavigationPathVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseNavigationPathVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseNavigationPathVarianceFields>;
};


/** aggregate fields of "navigation_path" */
export type StopsDatabaseNavigationPathAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseNavigationPathSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseNavigationPathAvgFields = {
  readonly __typename?: 'stops_database_navigation_path_avg_fields';
  readonly path_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "navigation_path". All fields are combined with a logical 'AND'. */
export type StopsDatabaseNavigationPathBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseNavigationPathBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseNavigationPathBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseNavigationPathBoolExp>>;
  readonly id?: InputMaybe<StringComparisonExp>;
  readonly item_type?: InputMaybe<StringComparisonExp>;
  readonly path_id?: InputMaybe<IntComparisonExp>;
};

/** input type for incrementing numeric columns in table "navigation_path" */
export type StopsDatabaseNavigationPathIncInput = {
  readonly path_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "navigation_path" */
export type StopsDatabaseNavigationPathInsertInput = {
  readonly id?: InputMaybe<Scalars['String']['input']>;
  readonly item_type?: InputMaybe<Scalars['String']['input']>;
  readonly path_id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseNavigationPathMaxFields = {
  readonly __typename?: 'stops_database_navigation_path_max_fields';
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly item_type?: Maybe<Scalars['String']['output']>;
  readonly path_id?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseNavigationPathMinFields = {
  readonly __typename?: 'stops_database_navigation_path_min_fields';
  readonly id?: Maybe<Scalars['String']['output']>;
  readonly item_type?: Maybe<Scalars['String']['output']>;
  readonly path_id?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "navigation_path" */
export type StopsDatabaseNavigationPathMutationResponse = {
  readonly __typename?: 'stops_database_navigation_path_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseNavigationPath>;
};

/** Ordering options when selecting data from "navigation_path". */
export type StopsDatabaseNavigationPathOrderBy = {
  readonly id?: InputMaybe<OrderBy>;
  readonly item_type?: InputMaybe<OrderBy>;
  readonly path_id?: InputMaybe<OrderBy>;
};

/** select columns of table "navigation_path" */
export enum StopsDatabaseNavigationPathSelectColumn {
  /** column name */
  Id = 'id',
  /** column name */
  ItemType = 'item_type',
  /** column name */
  PathId = 'path_id'
}

/** input type for updating data in table "navigation_path" */
export type StopsDatabaseNavigationPathSetInput = {
  readonly id?: InputMaybe<Scalars['String']['input']>;
  readonly item_type?: InputMaybe<Scalars['String']['input']>;
  readonly path_id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseNavigationPathStddevFields = {
  readonly __typename?: 'stops_database_navigation_path_stddev_fields';
  readonly path_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseNavigationPathStddevPopFields = {
  readonly __typename?: 'stops_database_navigation_path_stddev_pop_fields';
  readonly path_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseNavigationPathStddevSampFields = {
  readonly __typename?: 'stops_database_navigation_path_stddev_samp_fields';
  readonly path_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "navigation_path" */
export type StopsDatabaseNavigationPathStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseNavigationPathStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseNavigationPathStreamCursorValueInput = {
  readonly id?: InputMaybe<Scalars['String']['input']>;
  readonly item_type?: InputMaybe<Scalars['String']['input']>;
  readonly path_id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseNavigationPathSumFields = {
  readonly __typename?: 'stops_database_navigation_path_sum_fields';
  readonly path_id?: Maybe<Scalars['Int']['output']>;
};

export type StopsDatabaseNavigationPathUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseNavigationPathIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseNavigationPathSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseNavigationPathBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseNavigationPathVarPopFields = {
  readonly __typename?: 'stops_database_navigation_path_var_pop_fields';
  readonly path_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseNavigationPathVarSampFields = {
  readonly __typename?: 'stops_database_navigation_path_var_samp_fields';
  readonly path_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseNavigationPathVarianceFields = {
  readonly __typename?: 'stops_database_navigation_path_variance_fields';
  readonly path_id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "organisation" */
export type StopsDatabaseOrganisation = {
  readonly __typename?: 'stops_database_organisation';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly company_number?: Maybe<Scalars['String']['output']>;
  readonly contact_details_id?: Maybe<Scalars['bigint']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id: Scalars['bigint']['output'];
  readonly legal_name_lang?: Maybe<Scalars['String']['output']>;
  readonly legal_name_value?: Maybe<Scalars['String']['output']>;
  readonly name?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly organisation_type?: Maybe<Scalars['String']['output']>;
  readonly private_code?: Maybe<Scalars['String']['output']>;
  readonly private_contact_details_id?: Maybe<Scalars['bigint']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "organisation" */
export type StopsDatabaseOrganisationAggregate = {
  readonly __typename?: 'stops_database_organisation_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseOrganisationAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseOrganisation>;
};

/** aggregate fields of "organisation" */
export type StopsDatabaseOrganisationAggregateFields = {
  readonly __typename?: 'stops_database_organisation_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseOrganisationAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseOrganisationMaxFields>;
  readonly min?: Maybe<StopsDatabaseOrganisationMinFields>;
  readonly stddev?: Maybe<StopsDatabaseOrganisationStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseOrganisationStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseOrganisationStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseOrganisationSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseOrganisationVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseOrganisationVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseOrganisationVarianceFields>;
};


/** aggregate fields of "organisation" */
export type StopsDatabaseOrganisationAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseOrganisationSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseOrganisationAvgFields = {
  readonly __typename?: 'stops_database_organisation_avg_fields';
  readonly contact_details_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly private_contact_details_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "organisation". All fields are combined with a logical 'AND'. */
export type StopsDatabaseOrganisationBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseOrganisationBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseOrganisationBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseOrganisationBoolExp>>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly company_number?: InputMaybe<StringComparisonExp>;
  readonly contact_details_id?: InputMaybe<BigintComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly legal_name_lang?: InputMaybe<StringComparisonExp>;
  readonly legal_name_value?: InputMaybe<StringComparisonExp>;
  readonly name?: InputMaybe<StringComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly organisation_type?: InputMaybe<StringComparisonExp>;
  readonly private_code?: InputMaybe<StringComparisonExp>;
  readonly private_contact_details_id?: InputMaybe<BigintComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "organisation" */
export enum StopsDatabaseOrganisationConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  OrganisationNetexIdVersionConstraint = 'organisation_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  OrganisationPkey = 'organisation_pkey'
}

/** input type for incrementing numeric columns in table "organisation" */
export type StopsDatabaseOrganisationIncInput = {
  readonly contact_details_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_contact_details_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "organisation" */
export type StopsDatabaseOrganisationInsertInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly company_number?: InputMaybe<Scalars['String']['input']>;
  readonly contact_details_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly legal_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly legal_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly name?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly organisation_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code?: InputMaybe<Scalars['String']['input']>;
  readonly private_contact_details_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "organisation_key_values" */
export type StopsDatabaseOrganisationKeyValues = {
  readonly __typename?: 'stops_database_organisation_key_values';
  readonly key_values_id: Scalars['bigint']['output'];
  readonly key_values_key: Scalars['String']['output'];
  readonly organisation_id: Scalars['bigint']['output'];
};

/** aggregated selection of "organisation_key_values" */
export type StopsDatabaseOrganisationKeyValuesAggregate = {
  readonly __typename?: 'stops_database_organisation_key_values_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseOrganisationKeyValuesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseOrganisationKeyValues>;
};

/** aggregate fields of "organisation_key_values" */
export type StopsDatabaseOrganisationKeyValuesAggregateFields = {
  readonly __typename?: 'stops_database_organisation_key_values_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseOrganisationKeyValuesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseOrganisationKeyValuesMaxFields>;
  readonly min?: Maybe<StopsDatabaseOrganisationKeyValuesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseOrganisationKeyValuesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseOrganisationKeyValuesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseOrganisationKeyValuesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseOrganisationKeyValuesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseOrganisationKeyValuesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseOrganisationKeyValuesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseOrganisationKeyValuesVarianceFields>;
};


/** aggregate fields of "organisation_key_values" */
export type StopsDatabaseOrganisationKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseOrganisationKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseOrganisationKeyValuesAvgFields = {
  readonly __typename?: 'stops_database_organisation_key_values_avg_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly organisation_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "organisation_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseOrganisationKeyValuesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseOrganisationKeyValuesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseOrganisationKeyValuesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseOrganisationKeyValuesBoolExp>>;
  readonly key_values_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_key?: InputMaybe<StringComparisonExp>;
  readonly organisation_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "organisation_key_values" */
export enum StopsDatabaseOrganisationKeyValuesConstraint {
  /** unique or primary key constraint on columns "key_values_id" */
  OrganisationKeyValuesKeyValuesIdKey = 'organisation_key_values_key_values_id_key',
  /** unique or primary key constraint on columns "key_values_key", "organisation_id" */
  OrganisationKeyValuesPkey = 'organisation_key_values_pkey'
}

/** input type for incrementing numeric columns in table "organisation_key_values" */
export type StopsDatabaseOrganisationKeyValuesIncInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly organisation_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "organisation_key_values" */
export type StopsDatabaseOrganisationKeyValuesInsertInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly organisation_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseOrganisationKeyValuesMaxFields = {
  readonly __typename?: 'stops_database_organisation_key_values_max_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
  readonly organisation_id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseOrganisationKeyValuesMinFields = {
  readonly __typename?: 'stops_database_organisation_key_values_min_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
  readonly organisation_id?: Maybe<Scalars['bigint']['output']>;
};

/** response of any mutation on the table "organisation_key_values" */
export type StopsDatabaseOrganisationKeyValuesMutationResponse = {
  readonly __typename?: 'stops_database_organisation_key_values_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseOrganisationKeyValues>;
};

/** on_conflict condition type for table "organisation_key_values" */
export type StopsDatabaseOrganisationKeyValuesOnConflict = {
  readonly constraint: StopsDatabaseOrganisationKeyValuesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseOrganisationKeyValuesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseOrganisationKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "organisation_key_values". */
export type StopsDatabaseOrganisationKeyValuesOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly organisation_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: organisation_key_values */
export type StopsDatabaseOrganisationKeyValuesPkColumnsInput = {
  readonly key_values_key: Scalars['String']['input'];
  readonly organisation_id: Scalars['bigint']['input'];
};

/** select columns of table "organisation_key_values" */
export enum StopsDatabaseOrganisationKeyValuesSelectColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  OrganisationId = 'organisation_id'
}

/** input type for updating data in table "organisation_key_values" */
export type StopsDatabaseOrganisationKeyValuesSetInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly organisation_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseOrganisationKeyValuesStddevFields = {
  readonly __typename?: 'stops_database_organisation_key_values_stddev_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly organisation_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseOrganisationKeyValuesStddevPopFields = {
  readonly __typename?: 'stops_database_organisation_key_values_stddev_pop_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly organisation_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseOrganisationKeyValuesStddevSampFields = {
  readonly __typename?: 'stops_database_organisation_key_values_stddev_samp_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly organisation_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "organisation_key_values" */
export type StopsDatabaseOrganisationKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseOrganisationKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseOrganisationKeyValuesStreamCursorValueInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly organisation_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseOrganisationKeyValuesSumFields = {
  readonly __typename?: 'stops_database_organisation_key_values_sum_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly organisation_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "organisation_key_values" */
export enum StopsDatabaseOrganisationKeyValuesUpdateColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  OrganisationId = 'organisation_id'
}

export type StopsDatabaseOrganisationKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseOrganisationKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseOrganisationKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseOrganisationKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseOrganisationKeyValuesVarPopFields = {
  readonly __typename?: 'stops_database_organisation_key_values_var_pop_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly organisation_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseOrganisationKeyValuesVarSampFields = {
  readonly __typename?: 'stops_database_organisation_key_values_var_samp_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly organisation_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseOrganisationKeyValuesVarianceFields = {
  readonly __typename?: 'stops_database_organisation_key_values_variance_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly organisation_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate max on columns */
export type StopsDatabaseOrganisationMaxFields = {
  readonly __typename?: 'stops_database_organisation_max_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly company_number?: Maybe<Scalars['String']['output']>;
  readonly contact_details_id?: Maybe<Scalars['bigint']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly legal_name_lang?: Maybe<Scalars['String']['output']>;
  readonly legal_name_value?: Maybe<Scalars['String']['output']>;
  readonly name?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly organisation_type?: Maybe<Scalars['String']['output']>;
  readonly private_code?: Maybe<Scalars['String']['output']>;
  readonly private_contact_details_id?: Maybe<Scalars['bigint']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseOrganisationMinFields = {
  readonly __typename?: 'stops_database_organisation_min_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly company_number?: Maybe<Scalars['String']['output']>;
  readonly contact_details_id?: Maybe<Scalars['bigint']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly legal_name_lang?: Maybe<Scalars['String']['output']>;
  readonly legal_name_value?: Maybe<Scalars['String']['output']>;
  readonly name?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly organisation_type?: Maybe<Scalars['String']['output']>;
  readonly private_code?: Maybe<Scalars['String']['output']>;
  readonly private_contact_details_id?: Maybe<Scalars['bigint']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "organisation" */
export type StopsDatabaseOrganisationMutationResponse = {
  readonly __typename?: 'stops_database_organisation_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseOrganisation>;
};

/** on_conflict condition type for table "organisation" */
export type StopsDatabaseOrganisationOnConflict = {
  readonly constraint: StopsDatabaseOrganisationConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseOrganisationUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseOrganisationBoolExp>;
};

/** Ordering options when selecting data from "organisation". */
export type StopsDatabaseOrganisationOrderBy = {
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly company_number?: InputMaybe<OrderBy>;
  readonly contact_details_id?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly legal_name_lang?: InputMaybe<OrderBy>;
  readonly legal_name_value?: InputMaybe<OrderBy>;
  readonly name?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly organisation_type?: InputMaybe<OrderBy>;
  readonly private_code?: InputMaybe<OrderBy>;
  readonly private_contact_details_id?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: organisation */
export type StopsDatabaseOrganisationPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "organisation" */
export enum StopsDatabaseOrganisationSelectColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  CompanyNumber = 'company_number',
  /** column name */
  ContactDetailsId = 'contact_details_id',
  /** column name */
  Created = 'created',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  LegalNameLang = 'legal_name_lang',
  /** column name */
  LegalNameValue = 'legal_name_value',
  /** column name */
  Name = 'name',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  OrganisationType = 'organisation_type',
  /** column name */
  PrivateCode = 'private_code',
  /** column name */
  PrivateContactDetailsId = 'private_contact_details_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

/** input type for updating data in table "organisation" */
export type StopsDatabaseOrganisationSetInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly company_number?: InputMaybe<Scalars['String']['input']>;
  readonly contact_details_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly legal_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly legal_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly name?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly organisation_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code?: InputMaybe<Scalars['String']['input']>;
  readonly private_contact_details_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseOrganisationStddevFields = {
  readonly __typename?: 'stops_database_organisation_stddev_fields';
  readonly contact_details_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly private_contact_details_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseOrganisationStddevPopFields = {
  readonly __typename?: 'stops_database_organisation_stddev_pop_fields';
  readonly contact_details_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly private_contact_details_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseOrganisationStddevSampFields = {
  readonly __typename?: 'stops_database_organisation_stddev_samp_fields';
  readonly contact_details_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly private_contact_details_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "organisation" */
export type StopsDatabaseOrganisationStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseOrganisationStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseOrganisationStreamCursorValueInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly company_number?: InputMaybe<Scalars['String']['input']>;
  readonly contact_details_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly legal_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly legal_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly name?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly organisation_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code?: InputMaybe<Scalars['String']['input']>;
  readonly private_contact_details_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseOrganisationSumFields = {
  readonly __typename?: 'stops_database_organisation_sum_fields';
  readonly contact_details_id?: Maybe<Scalars['bigint']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly private_contact_details_id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "organisation" */
export enum StopsDatabaseOrganisationUpdateColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  CompanyNumber = 'company_number',
  /** column name */
  ContactDetailsId = 'contact_details_id',
  /** column name */
  Created = 'created',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  LegalNameLang = 'legal_name_lang',
  /** column name */
  LegalNameValue = 'legal_name_value',
  /** column name */
  Name = 'name',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  OrganisationType = 'organisation_type',
  /** column name */
  PrivateCode = 'private_code',
  /** column name */
  PrivateContactDetailsId = 'private_contact_details_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

export type StopsDatabaseOrganisationUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseOrganisationIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseOrganisationSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseOrganisationBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseOrganisationVarPopFields = {
  readonly __typename?: 'stops_database_organisation_var_pop_fields';
  readonly contact_details_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly private_contact_details_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseOrganisationVarSampFields = {
  readonly __typename?: 'stops_database_organisation_var_samp_fields';
  readonly contact_details_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly private_contact_details_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseOrganisationVarianceFields = {
  readonly __typename?: 'stops_database_organisation_variance_fields';
  readonly contact_details_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly private_contact_details_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "parking" */
export type StopsDatabaseParking = {
  readonly __typename?: 'stops_database_parking';
  /** An object relationship */
  readonly accessibility_assessment?: Maybe<StopsDatabaseAccessibilityAssessment>;
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly all_areas_wheelchair_accessible?: Maybe<Scalars['Boolean']['output']>;
  readonly booking_url?: Maybe<Scalars['String']['output']>;
  readonly centroid?: Maybe<Scalars['geometry']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly free_parking_out_of_hours?: Maybe<Scalars['Boolean']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id: Scalars['bigint']['output'];
  /** An object relationship */
  readonly installed_equipment_version_structure?: Maybe<StopsDatabaseInstalledEquipmentVersionStructure>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly number_of_parking_levels?: Maybe<Scalars['numeric']['output']>;
  readonly overnight_parking_permitted?: Maybe<Scalars['Boolean']['output']>;
  readonly parent_site_ref?: Maybe<Scalars['String']['output']>;
  readonly parent_site_ref_version?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  readonly parking_alternative_names: ReadonlyArray<StopsDatabaseParkingAlternativeNames>;
  /** An aggregate relationship */
  readonly parking_alternative_names_aggregate: StopsDatabaseParkingAlternativeNamesAggregate;
  /** An array relationship */
  readonly parking_equipment_places: ReadonlyArray<StopsDatabaseParkingEquipmentPlaces>;
  /** An aggregate relationship */
  readonly parking_equipment_places_aggregate: StopsDatabaseParkingEquipmentPlacesAggregate;
  /** An array relationship */
  readonly parking_key_values: ReadonlyArray<StopsDatabaseParkingKeyValues>;
  /** An aggregate relationship */
  readonly parking_key_values_aggregate: StopsDatabaseParkingKeyValuesAggregate;
  readonly parking_layout?: Maybe<Scalars['Int']['output']>;
  /** An array relationship */
  readonly parking_parking_areas: ReadonlyArray<StopsDatabaseParkingParkingAreas>;
  /** An aggregate relationship */
  readonly parking_parking_areas_aggregate: StopsDatabaseParkingParkingAreasAggregate;
  /** An array relationship */
  readonly parking_parking_payment_processes: ReadonlyArray<StopsDatabaseParkingParkingPaymentProcess>;
  /** An aggregate relationship */
  readonly parking_parking_payment_processes_aggregate: StopsDatabaseParkingParkingPaymentProcessAggregate;
  /** An array relationship */
  readonly parking_parking_properties: ReadonlyArray<StopsDatabaseParkingParkingProperties>;
  /** An aggregate relationship */
  readonly parking_parking_properties_aggregate: StopsDatabaseParkingParkingPropertiesAggregate;
  /** An array relationship */
  readonly parking_parking_vehicle_types: ReadonlyArray<StopsDatabaseParkingParkingVehicleTypes>;
  /** An aggregate relationship */
  readonly parking_parking_vehicle_types_aggregate: StopsDatabaseParkingParkingVehicleTypesAggregate;
  readonly parking_reservation?: Maybe<Scalars['Int']['output']>;
  readonly parking_type?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  readonly persistable_polygon?: Maybe<StopsDatabasePersistablePolygon>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly principal_capacity?: Maybe<Scalars['numeric']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly prohibited_for_hazardous_materials?: Maybe<Scalars['Boolean']['output']>;
  readonly real_time_occupancy_available?: Maybe<Scalars['Boolean']['output']>;
  readonly recharging_available?: Maybe<Scalars['Boolean']['output']>;
  readonly secure?: Maybe<Scalars['Boolean']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  /** An object relationship */
  readonly topographic_place?: Maybe<StopsDatabaseTopographicPlace>;
  readonly topographic_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly total_capacity?: Maybe<Scalars['numeric']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingAlternativeNamesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAlternativeNamesBoolExp>;
};


/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAlternativeNamesBoolExp>;
};


/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingEquipmentPlacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingEquipmentPlacesBoolExp>;
};


/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingEquipmentPlacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingEquipmentPlacesBoolExp>;
};


/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingKeyValuesBoolExp>;
};


/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingKeyValuesBoolExp>;
};


/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingParkingAreasArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingAreasSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingAreasOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingAreasBoolExp>;
};


/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingParkingAreasAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingAreasSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingAreasOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingAreasBoolExp>;
};


/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingParkingPaymentProcessesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPaymentProcessSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPaymentProcessOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessBoolExp>;
};


/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingParkingPaymentProcessesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPaymentProcessSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPaymentProcessOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessBoolExp>;
};


/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingParkingPropertiesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPropertiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPropertiesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingPropertiesBoolExp>;
};


/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingParkingPropertiesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPropertiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPropertiesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingPropertiesBoolExp>;
};


/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingParkingVehicleTypesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingVehicleTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingVehicleTypesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesBoolExp>;
};


/** columns and relationships of "parking" */
export type StopsDatabaseParkingParkingParkingVehicleTypesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingVehicleTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingVehicleTypesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesBoolExp>;
};

/** columns and relationships of "parking_adjacent_sites" */
export type StopsDatabaseParkingAdjacentSites = {
  readonly __typename?: 'stops_database_parking_adjacent_sites';
  readonly parking_id: Scalars['bigint']['output'];
  readonly ref?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "parking_adjacent_sites" */
export type StopsDatabaseParkingAdjacentSitesAggregate = {
  readonly __typename?: 'stops_database_parking_adjacent_sites_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseParkingAdjacentSitesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseParkingAdjacentSites>;
};

/** aggregate fields of "parking_adjacent_sites" */
export type StopsDatabaseParkingAdjacentSitesAggregateFields = {
  readonly __typename?: 'stops_database_parking_adjacent_sites_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseParkingAdjacentSitesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseParkingAdjacentSitesMaxFields>;
  readonly min?: Maybe<StopsDatabaseParkingAdjacentSitesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseParkingAdjacentSitesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseParkingAdjacentSitesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseParkingAdjacentSitesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseParkingAdjacentSitesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseParkingAdjacentSitesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseParkingAdjacentSitesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseParkingAdjacentSitesVarianceFields>;
};


/** aggregate fields of "parking_adjacent_sites" */
export type StopsDatabaseParkingAdjacentSitesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAdjacentSitesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingAdjacentSitesAvgFields = {
  readonly __typename?: 'stops_database_parking_adjacent_sites_avg_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "parking_adjacent_sites". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingAdjacentSitesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAdjacentSitesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseParkingAdjacentSitesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAdjacentSitesBoolExp>>;
  readonly parking_id?: InputMaybe<BigintComparisonExp>;
  readonly ref?: InputMaybe<StringComparisonExp>;
  readonly version?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "parking_adjacent_sites" */
export type StopsDatabaseParkingAdjacentSitesIncInput = {
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "parking_adjacent_sites" */
export type StopsDatabaseParkingAdjacentSitesInsertInput = {
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly ref?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingAdjacentSitesMaxFields = {
  readonly __typename?: 'stops_database_parking_adjacent_sites_max_fields';
  readonly parking_id?: Maybe<Scalars['bigint']['output']>;
  readonly ref?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingAdjacentSitesMinFields = {
  readonly __typename?: 'stops_database_parking_adjacent_sites_min_fields';
  readonly parking_id?: Maybe<Scalars['bigint']['output']>;
  readonly ref?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "parking_adjacent_sites" */
export type StopsDatabaseParkingAdjacentSitesMutationResponse = {
  readonly __typename?: 'stops_database_parking_adjacent_sites_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseParkingAdjacentSites>;
};

/** Ordering options when selecting data from "parking_adjacent_sites". */
export type StopsDatabaseParkingAdjacentSitesOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
  readonly ref?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
};

/** select columns of table "parking_adjacent_sites" */
export enum StopsDatabaseParkingAdjacentSitesSelectColumn {
  /** column name */
  ParkingId = 'parking_id',
  /** column name */
  Ref = 'ref',
  /** column name */
  Version = 'version'
}

/** input type for updating data in table "parking_adjacent_sites" */
export type StopsDatabaseParkingAdjacentSitesSetInput = {
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly ref?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingAdjacentSitesStddevFields = {
  readonly __typename?: 'stops_database_parking_adjacent_sites_stddev_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingAdjacentSitesStddevPopFields = {
  readonly __typename?: 'stops_database_parking_adjacent_sites_stddev_pop_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingAdjacentSitesStddevSampFields = {
  readonly __typename?: 'stops_database_parking_adjacent_sites_stddev_samp_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "parking_adjacent_sites" */
export type StopsDatabaseParkingAdjacentSitesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseParkingAdjacentSitesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingAdjacentSitesStreamCursorValueInput = {
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly ref?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingAdjacentSitesSumFields = {
  readonly __typename?: 'stops_database_parking_adjacent_sites_sum_fields';
  readonly parking_id?: Maybe<Scalars['bigint']['output']>;
};

export type StopsDatabaseParkingAdjacentSitesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseParkingAdjacentSitesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseParkingAdjacentSitesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseParkingAdjacentSitesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingAdjacentSitesVarPopFields = {
  readonly __typename?: 'stops_database_parking_adjacent_sites_var_pop_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingAdjacentSitesVarSampFields = {
  readonly __typename?: 'stops_database_parking_adjacent_sites_var_samp_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingAdjacentSitesVarianceFields = {
  readonly __typename?: 'stops_database_parking_adjacent_sites_variance_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregated selection of "parking" */
export type StopsDatabaseParkingAggregate = {
  readonly __typename?: 'stops_database_parking_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseParkingAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseParking>;
};

/** aggregate fields of "parking" */
export type StopsDatabaseParkingAggregateFields = {
  readonly __typename?: 'stops_database_parking_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseParkingAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseParkingMaxFields>;
  readonly min?: Maybe<StopsDatabaseParkingMinFields>;
  readonly stddev?: Maybe<StopsDatabaseParkingStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseParkingStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseParkingStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseParkingSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseParkingVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseParkingVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseParkingVarianceFields>;
};


/** aggregate fields of "parking" */
export type StopsDatabaseParkingAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseParkingSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** columns and relationships of "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNames = {
  readonly __typename?: 'stops_database_parking_alternative_names';
  /** An object relationship */
  readonly alternative_name: StopsDatabaseAlternativeName;
  readonly alternative_names_id: Scalars['bigint']['output'];
  readonly parking_id: Scalars['bigint']['output'];
};

/** aggregated selection of "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesAggregate = {
  readonly __typename?: 'stops_database_parking_alternative_names_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseParkingAlternativeNamesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseParkingAlternativeNames>;
};

/** aggregate fields of "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesAggregateFields = {
  readonly __typename?: 'stops_database_parking_alternative_names_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseParkingAlternativeNamesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseParkingAlternativeNamesMaxFields>;
  readonly min?: Maybe<StopsDatabaseParkingAlternativeNamesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseParkingAlternativeNamesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseParkingAlternativeNamesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseParkingAlternativeNamesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseParkingAlternativeNamesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseParkingAlternativeNamesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseParkingAlternativeNamesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseParkingAlternativeNamesVarianceFields>;
};


/** aggregate fields of "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAlternativeNamesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseParkingAlternativeNamesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseParkingAlternativeNamesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseParkingAlternativeNamesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseParkingAlternativeNamesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseParkingAlternativeNamesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseParkingAlternativeNamesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseParkingAlternativeNamesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseParkingAlternativeNamesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseParkingAlternativeNamesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseParkingAlternativeNamesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseParkingAlternativeNamesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseParkingAlternativeNamesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingAlternativeNamesAvgFields = {
  readonly __typename?: 'stops_database_parking_alternative_names_avg_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesAvgOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "parking_alternative_names". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingAlternativeNamesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAlternativeNamesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseParkingAlternativeNamesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAlternativeNamesBoolExp>>;
  readonly alternative_name?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
  readonly alternative_names_id?: InputMaybe<BigintComparisonExp>;
  readonly parking_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "parking_alternative_names" */
export enum StopsDatabaseParkingAlternativeNamesConstraint {
  /** unique or primary key constraint on columns "alternative_names_id" */
  UkRlf4rns9qabhhdins8l3y89fo = 'uk_rlf4rns9qabhhdins8l3y89fo'
}

/** input type for incrementing numeric columns in table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesIncInput = {
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesInsertInput = {
  readonly alternative_name?: InputMaybe<StopsDatabaseAlternativeNameObjRelInsertInput>;
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingAlternativeNamesMaxFields = {
  readonly __typename?: 'stops_database_parking_alternative_names_max_fields';
  readonly alternative_names_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesMaxOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingAlternativeNamesMinFields = {
  readonly __typename?: 'stops_database_parking_alternative_names_min_fields';
  readonly alternative_names_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesMinOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesMutationResponse = {
  readonly __typename?: 'stops_database_parking_alternative_names_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseParkingAlternativeNames>;
};

/** on_conflict condition type for table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesOnConflict = {
  readonly constraint: StopsDatabaseParkingAlternativeNamesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseParkingAlternativeNamesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseParkingAlternativeNamesBoolExp>;
};

/** Ordering options when selecting data from "parking_alternative_names". */
export type StopsDatabaseParkingAlternativeNamesOrderBy = {
  readonly alternative_name?: InputMaybe<StopsDatabaseAlternativeNameOrderBy>;
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** select columns of table "parking_alternative_names" */
export enum StopsDatabaseParkingAlternativeNamesSelectColumn {
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
  /** column name */
  ParkingId = 'parking_id'
}

/** input type for updating data in table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesSetInput = {
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingAlternativeNamesStddevFields = {
  readonly __typename?: 'stops_database_parking_alternative_names_stddev_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesStddevOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingAlternativeNamesStddevPopFields = {
  readonly __typename?: 'stops_database_parking_alternative_names_stddev_pop_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesStddevPopOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingAlternativeNamesStddevSampFields = {
  readonly __typename?: 'stops_database_parking_alternative_names_stddev_samp_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesStddevSampOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseParkingAlternativeNamesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingAlternativeNamesStreamCursorValueInput = {
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingAlternativeNamesSumFields = {
  readonly __typename?: 'stops_database_parking_alternative_names_sum_fields';
  readonly alternative_names_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesSumOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** update columns of table "parking_alternative_names" */
export enum StopsDatabaseParkingAlternativeNamesUpdateColumn {
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
  /** column name */
  ParkingId = 'parking_id'
}

export type StopsDatabaseParkingAlternativeNamesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseParkingAlternativeNamesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseParkingAlternativeNamesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseParkingAlternativeNamesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingAlternativeNamesVarPopFields = {
  readonly __typename?: 'stops_database_parking_alternative_names_var_pop_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesVarPopOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingAlternativeNamesVarSampFields = {
  readonly __typename?: 'stops_database_parking_alternative_names_var_samp_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesVarSampOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingAlternativeNamesVarianceFields = {
  readonly __typename?: 'stops_database_parking_alternative_names_variance_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "parking_alternative_names" */
export type StopsDatabaseParkingAlternativeNamesVarianceOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** columns and relationships of "parking_area" */
export type StopsDatabaseParkingArea = {
  readonly __typename?: 'stops_database_parking_area';
  /** An object relationship */
  readonly accessibility_assessment?: Maybe<StopsDatabaseAccessibilityAssessment>;
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly all_areas_wheelchair_accessible?: Maybe<Scalars['Boolean']['output']>;
  readonly centroid?: Maybe<Scalars['geometry']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id: Scalars['bigint']['output'];
  /** An object relationship */
  readonly installed_equipment_version_structure?: Maybe<StopsDatabaseInstalledEquipmentVersionStructure>;
  readonly level_ref?: Maybe<Scalars['String']['output']>;
  readonly level_ref_version?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  readonly parking_area_alternative_names: ReadonlyArray<StopsDatabaseParkingAreaAlternativeNames>;
  /** An aggregate relationship */
  readonly parking_area_alternative_names_aggregate: StopsDatabaseParkingAreaAlternativeNamesAggregate;
  /** An array relationship */
  readonly parking_area_equipment_places: ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlaces>;
  /** An aggregate relationship */
  readonly parking_area_equipment_places_aggregate: StopsDatabaseParkingAreaEquipmentPlacesAggregate;
  /** An array relationship */
  readonly parking_area_key_values: ReadonlyArray<StopsDatabaseParkingAreaKeyValues>;
  /** An aggregate relationship */
  readonly parking_area_key_values_aggregate: StopsDatabaseParkingAreaKeyValuesAggregate;
  /** An object relationship */
  readonly parking_parking_area?: Maybe<StopsDatabaseParkingParkingAreas>;
  readonly parking_properties_id?: Maybe<Scalars['bigint']['output']>;
  /** An object relationship */
  readonly parking_property?: Maybe<StopsDatabaseParkingProperties>;
  /** An object relationship */
  readonly persistable_polygon?: Maybe<StopsDatabasePersistablePolygon>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly site_ref?: Maybe<Scalars['String']['output']>;
  readonly site_ref_version?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly total_capacity?: Maybe<Scalars['numeric']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "parking_area" */
export type StopsDatabaseParkingAreaParkingAreaAlternativeNamesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesBoolExp>;
};


/** columns and relationships of "parking_area" */
export type StopsDatabaseParkingAreaParkingAreaAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesBoolExp>;
};


/** columns and relationships of "parking_area" */
export type StopsDatabaseParkingAreaParkingAreaEquipmentPlacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>;
};


/** columns and relationships of "parking_area" */
export type StopsDatabaseParkingAreaParkingAreaEquipmentPlacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>;
};


/** columns and relationships of "parking_area" */
export type StopsDatabaseParkingAreaParkingAreaKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaKeyValuesBoolExp>;
};


/** columns and relationships of "parking_area" */
export type StopsDatabaseParkingAreaParkingAreaKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaKeyValuesBoolExp>;
};

/** aggregated selection of "parking_area" */
export type StopsDatabaseParkingAreaAggregate = {
  readonly __typename?: 'stops_database_parking_area_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseParkingAreaAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseParkingArea>;
};

/** aggregate fields of "parking_area" */
export type StopsDatabaseParkingAreaAggregateFields = {
  readonly __typename?: 'stops_database_parking_area_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseParkingAreaAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseParkingAreaMaxFields>;
  readonly min?: Maybe<StopsDatabaseParkingAreaMinFields>;
  readonly stddev?: Maybe<StopsDatabaseParkingAreaStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseParkingAreaStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseParkingAreaStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseParkingAreaSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseParkingAreaVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseParkingAreaVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseParkingAreaVarianceFields>;
};


/** aggregate fields of "parking_area" */
export type StopsDatabaseParkingAreaAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** columns and relationships of "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNames = {
  readonly __typename?: 'stops_database_parking_area_alternative_names';
  /** An object relationship */
  readonly alternative_name: StopsDatabaseAlternativeName;
  readonly alternative_names_id: Scalars['bigint']['output'];
  readonly parking_area_id: Scalars['bigint']['output'];
};

/** aggregated selection of "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesAggregate = {
  readonly __typename?: 'stops_database_parking_area_alternative_names_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseParkingAreaAlternativeNamesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseParkingAreaAlternativeNames>;
};

/** aggregate fields of "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesAggregateFields = {
  readonly __typename?: 'stops_database_parking_area_alternative_names_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseParkingAreaAlternativeNamesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseParkingAreaAlternativeNamesMaxFields>;
  readonly min?: Maybe<StopsDatabaseParkingAreaAlternativeNamesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseParkingAreaAlternativeNamesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseParkingAreaAlternativeNamesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseParkingAreaAlternativeNamesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseParkingAreaAlternativeNamesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseParkingAreaAlternativeNamesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseParkingAreaAlternativeNamesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseParkingAreaAlternativeNamesVarianceFields>;
};


/** aggregate fields of "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaAlternativeNamesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseParkingAreaAlternativeNamesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingAreaAlternativeNamesAvgFields = {
  readonly __typename?: 'stops_database_parking_area_alternative_names_avg_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesAvgOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "parking_area_alternative_names". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingAreaAlternativeNamesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaAlternativeNamesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaAlternativeNamesBoolExp>>;
  readonly alternative_name?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
  readonly alternative_names_id?: InputMaybe<BigintComparisonExp>;
  readonly parking_area_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "parking_area_alternative_names" */
export enum StopsDatabaseParkingAreaAlternativeNamesConstraint {
  /** unique or primary key constraint on columns "alternative_names_id" */
  UkHb8tvxumnj3j12b5i3a161lcm = 'uk_hb8tvxumnj3j12b5i3a161lcm'
}

/** input type for incrementing numeric columns in table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesIncInput = {
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_area_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesInsertInput = {
  readonly alternative_name?: InputMaybe<StopsDatabaseAlternativeNameObjRelInsertInput>;
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_area_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingAreaAlternativeNamesMaxFields = {
  readonly __typename?: 'stops_database_parking_area_alternative_names_max_fields';
  readonly alternative_names_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_area_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesMaxOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingAreaAlternativeNamesMinFields = {
  readonly __typename?: 'stops_database_parking_area_alternative_names_min_fields';
  readonly alternative_names_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_area_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesMinOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesMutationResponse = {
  readonly __typename?: 'stops_database_parking_area_alternative_names_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseParkingAreaAlternativeNames>;
};

/** on_conflict condition type for table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesOnConflict = {
  readonly constraint: StopsDatabaseParkingAreaAlternativeNamesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseParkingAreaAlternativeNamesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesBoolExp>;
};

/** Ordering options when selecting data from "parking_area_alternative_names". */
export type StopsDatabaseParkingAreaAlternativeNamesOrderBy = {
  readonly alternative_name?: InputMaybe<StopsDatabaseAlternativeNameOrderBy>;
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** select columns of table "parking_area_alternative_names" */
export enum StopsDatabaseParkingAreaAlternativeNamesSelectColumn {
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
  /** column name */
  ParkingAreaId = 'parking_area_id'
}

/** input type for updating data in table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesSetInput = {
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_area_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingAreaAlternativeNamesStddevFields = {
  readonly __typename?: 'stops_database_parking_area_alternative_names_stddev_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesStddevOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingAreaAlternativeNamesStddevPopFields = {
  readonly __typename?: 'stops_database_parking_area_alternative_names_stddev_pop_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesStddevPopOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingAreaAlternativeNamesStddevSampFields = {
  readonly __typename?: 'stops_database_parking_area_alternative_names_stddev_samp_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesStddevSampOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseParkingAreaAlternativeNamesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingAreaAlternativeNamesStreamCursorValueInput = {
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_area_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingAreaAlternativeNamesSumFields = {
  readonly __typename?: 'stops_database_parking_area_alternative_names_sum_fields';
  readonly alternative_names_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_area_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesSumOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** update columns of table "parking_area_alternative_names" */
export enum StopsDatabaseParkingAreaAlternativeNamesUpdateColumn {
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
  /** column name */
  ParkingAreaId = 'parking_area_id'
}

export type StopsDatabaseParkingAreaAlternativeNamesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseParkingAreaAlternativeNamesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingAreaAlternativeNamesVarPopFields = {
  readonly __typename?: 'stops_database_parking_area_alternative_names_var_pop_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesVarPopOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingAreaAlternativeNamesVarSampFields = {
  readonly __typename?: 'stops_database_parking_area_alternative_names_var_samp_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesVarSampOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingAreaAlternativeNamesVarianceFields = {
  readonly __typename?: 'stops_database_parking_area_alternative_names_variance_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "parking_area_alternative_names" */
export type StopsDatabaseParkingAreaAlternativeNamesVarianceOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingAreaAvgFields = {
  readonly __typename?: 'stops_database_parking_area_avg_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly total_capacity?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "parking_area". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingAreaBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseParkingAreaBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaBoolExp>>;
  readonly accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentBoolExp>;
  readonly accessibility_assessment_id?: InputMaybe<BigintComparisonExp>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<BooleanComparisonExp>;
  readonly centroid?: InputMaybe<GeometryComparisonExp>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly covered?: InputMaybe<IntComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly description_lang?: InputMaybe<StringComparisonExp>;
  readonly description_value?: InputMaybe<StringComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
  readonly level_ref?: InputMaybe<StringComparisonExp>;
  readonly level_ref_version?: InputMaybe<StringComparisonExp>;
  readonly name_lang?: InputMaybe<StringComparisonExp>;
  readonly name_value?: InputMaybe<StringComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly parking_area_alternative_names?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesBoolExp>;
  readonly parking_area_alternative_names_aggregate?: InputMaybe<ParkingAreaAlternativeNamesAggregateBoolExp>;
  readonly parking_area_equipment_places?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>;
  readonly parking_area_equipment_places_aggregate?: InputMaybe<ParkingAreaEquipmentPlacesAggregateBoolExp>;
  readonly parking_area_key_values?: InputMaybe<StopsDatabaseParkingAreaKeyValuesBoolExp>;
  readonly parking_area_key_values_aggregate?: InputMaybe<ParkingAreaKeyValuesAggregateBoolExp>;
  readonly parking_parking_area?: InputMaybe<StopsDatabaseParkingParkingAreasBoolExp>;
  readonly parking_properties_id?: InputMaybe<BigintComparisonExp>;
  readonly parking_property?: InputMaybe<StopsDatabaseParkingPropertiesBoolExp>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  readonly place_equipments_id?: InputMaybe<BigintComparisonExp>;
  readonly polygon_id?: InputMaybe<BigintComparisonExp>;
  readonly private_code_type?: InputMaybe<StringComparisonExp>;
  readonly private_code_value?: InputMaybe<StringComparisonExp>;
  readonly short_name_lang?: InputMaybe<StringComparisonExp>;
  readonly short_name_value?: InputMaybe<StringComparisonExp>;
  readonly site_ref?: InputMaybe<StringComparisonExp>;
  readonly site_ref_version?: InputMaybe<StringComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly total_capacity?: InputMaybe<NumericComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
};

/** columns and relationships of "parking_area_check_constraints" */
export type StopsDatabaseParkingAreaCheckConstraints = {
  readonly __typename?: 'stops_database_parking_area_check_constraints';
  readonly check_constraints_id: Scalars['bigint']['output'];
  readonly parking_area_id: Scalars['bigint']['output'];
};

/** aggregated selection of "parking_area_check_constraints" */
export type StopsDatabaseParkingAreaCheckConstraintsAggregate = {
  readonly __typename?: 'stops_database_parking_area_check_constraints_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseParkingAreaCheckConstraintsAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseParkingAreaCheckConstraints>;
};

/** aggregate fields of "parking_area_check_constraints" */
export type StopsDatabaseParkingAreaCheckConstraintsAggregateFields = {
  readonly __typename?: 'stops_database_parking_area_check_constraints_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseParkingAreaCheckConstraintsAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseParkingAreaCheckConstraintsMaxFields>;
  readonly min?: Maybe<StopsDatabaseParkingAreaCheckConstraintsMinFields>;
  readonly stddev?: Maybe<StopsDatabaseParkingAreaCheckConstraintsStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseParkingAreaCheckConstraintsStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseParkingAreaCheckConstraintsStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseParkingAreaCheckConstraintsSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseParkingAreaCheckConstraintsVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseParkingAreaCheckConstraintsVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseParkingAreaCheckConstraintsVarianceFields>;
};


/** aggregate fields of "parking_area_check_constraints" */
export type StopsDatabaseParkingAreaCheckConstraintsAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaCheckConstraintsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingAreaCheckConstraintsAvgFields = {
  readonly __typename?: 'stops_database_parking_area_check_constraints_avg_fields';
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "parking_area_check_constraints". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingAreaCheckConstraintsBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaCheckConstraintsBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaCheckConstraintsBoolExp>>;
  readonly check_constraints_id?: InputMaybe<BigintComparisonExp>;
  readonly parking_area_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "parking_area_check_constraints" */
export enum StopsDatabaseParkingAreaCheckConstraintsConstraint {
  /** unique or primary key constraint on columns "check_constraints_id" */
  Uk_1vh5s3bg8ag28aip9fbx1l32r = 'uk_1vh5s3bg8ag28aip9fbx1l32r'
}

/** input type for incrementing numeric columns in table "parking_area_check_constraints" */
export type StopsDatabaseParkingAreaCheckConstraintsIncInput = {
  readonly check_constraints_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_area_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "parking_area_check_constraints" */
export type StopsDatabaseParkingAreaCheckConstraintsInsertInput = {
  readonly check_constraints_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_area_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingAreaCheckConstraintsMaxFields = {
  readonly __typename?: 'stops_database_parking_area_check_constraints_max_fields';
  readonly check_constraints_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_area_id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingAreaCheckConstraintsMinFields = {
  readonly __typename?: 'stops_database_parking_area_check_constraints_min_fields';
  readonly check_constraints_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_area_id?: Maybe<Scalars['bigint']['output']>;
};

/** response of any mutation on the table "parking_area_check_constraints" */
export type StopsDatabaseParkingAreaCheckConstraintsMutationResponse = {
  readonly __typename?: 'stops_database_parking_area_check_constraints_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseParkingAreaCheckConstraints>;
};

/** on_conflict condition type for table "parking_area_check_constraints" */
export type StopsDatabaseParkingAreaCheckConstraintsOnConflict = {
  readonly constraint: StopsDatabaseParkingAreaCheckConstraintsConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseParkingAreaCheckConstraintsUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsBoolExp>;
};

/** Ordering options when selecting data from "parking_area_check_constraints". */
export type StopsDatabaseParkingAreaCheckConstraintsOrderBy = {
  readonly check_constraints_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** select columns of table "parking_area_check_constraints" */
export enum StopsDatabaseParkingAreaCheckConstraintsSelectColumn {
  /** column name */
  CheckConstraintsId = 'check_constraints_id',
  /** column name */
  ParkingAreaId = 'parking_area_id'
}

/** input type for updating data in table "parking_area_check_constraints" */
export type StopsDatabaseParkingAreaCheckConstraintsSetInput = {
  readonly check_constraints_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_area_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingAreaCheckConstraintsStddevFields = {
  readonly __typename?: 'stops_database_parking_area_check_constraints_stddev_fields';
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingAreaCheckConstraintsStddevPopFields = {
  readonly __typename?: 'stops_database_parking_area_check_constraints_stddev_pop_fields';
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingAreaCheckConstraintsStddevSampFields = {
  readonly __typename?: 'stops_database_parking_area_check_constraints_stddev_samp_fields';
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "parking_area_check_constraints" */
export type StopsDatabaseParkingAreaCheckConstraintsStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseParkingAreaCheckConstraintsStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingAreaCheckConstraintsStreamCursorValueInput = {
  readonly check_constraints_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_area_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingAreaCheckConstraintsSumFields = {
  readonly __typename?: 'stops_database_parking_area_check_constraints_sum_fields';
  readonly check_constraints_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_area_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "parking_area_check_constraints" */
export enum StopsDatabaseParkingAreaCheckConstraintsUpdateColumn {
  /** column name */
  CheckConstraintsId = 'check_constraints_id',
  /** column name */
  ParkingAreaId = 'parking_area_id'
}

export type StopsDatabaseParkingAreaCheckConstraintsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseParkingAreaCheckConstraintsBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingAreaCheckConstraintsVarPopFields = {
  readonly __typename?: 'stops_database_parking_area_check_constraints_var_pop_fields';
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingAreaCheckConstraintsVarSampFields = {
  readonly __typename?: 'stops_database_parking_area_check_constraints_var_samp_fields';
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingAreaCheckConstraintsVarianceFields = {
  readonly __typename?: 'stops_database_parking_area_check_constraints_variance_fields';
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** unique or primary key constraints on table "parking_area" */
export enum StopsDatabaseParkingAreaConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  ParkingAreaNetexIdVersionConstraint = 'parking_area_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  ParkingAreaPkey = 'parking_area_pkey'
}

/** columns and relationships of "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlaces = {
  readonly __typename?: 'stops_database_parking_area_equipment_places';
  /** An object relationship */
  readonly equipment_place: StopsDatabaseEquipmentPlace;
  readonly equipment_places_id: Scalars['bigint']['output'];
  readonly parking_area_id: Scalars['bigint']['output'];
};

/** aggregated selection of "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesAggregate = {
  readonly __typename?: 'stops_database_parking_area_equipment_places_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlaces>;
};

/** aggregate fields of "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesAggregateFields = {
  readonly __typename?: 'stops_database_parking_area_equipment_places_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesMaxFields>;
  readonly min?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesVarianceFields>;
};


/** aggregate fields of "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlacesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlacesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingAreaEquipmentPlacesAvgFields = {
  readonly __typename?: 'stops_database_parking_area_equipment_places_avg_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesAvgOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "parking_area_equipment_places". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingAreaEquipmentPlacesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>>;
  readonly equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceBoolExp>;
  readonly equipment_places_id?: InputMaybe<BigintComparisonExp>;
  readonly parking_area_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "parking_area_equipment_places" */
export enum StopsDatabaseParkingAreaEquipmentPlacesConstraint {
  /** unique or primary key constraint on columns "equipment_places_id" */
  UkLpu10934dkewquqflehpo95ye = 'uk_lpu10934dkewquqflehpo95ye'
}

/** input type for incrementing numeric columns in table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesIncInput = {
  readonly equipment_places_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_area_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesInsertInput = {
  readonly equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceObjRelInsertInput>;
  readonly equipment_places_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_area_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingAreaEquipmentPlacesMaxFields = {
  readonly __typename?: 'stops_database_parking_area_equipment_places_max_fields';
  readonly equipment_places_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_area_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesMaxOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingAreaEquipmentPlacesMinFields = {
  readonly __typename?: 'stops_database_parking_area_equipment_places_min_fields';
  readonly equipment_places_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_area_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesMinOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesMutationResponse = {
  readonly __typename?: 'stops_database_parking_area_equipment_places_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlaces>;
};

/** on_conflict condition type for table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesOnConflict = {
  readonly constraint: StopsDatabaseParkingAreaEquipmentPlacesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlacesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>;
};

/** Ordering options when selecting data from "parking_area_equipment_places". */
export type StopsDatabaseParkingAreaEquipmentPlacesOrderBy = {
  readonly equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceOrderBy>;
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** select columns of table "parking_area_equipment_places" */
export enum StopsDatabaseParkingAreaEquipmentPlacesSelectColumn {
  /** column name */
  EquipmentPlacesId = 'equipment_places_id',
  /** column name */
  ParkingAreaId = 'parking_area_id'
}

/** input type for updating data in table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesSetInput = {
  readonly equipment_places_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_area_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingAreaEquipmentPlacesStddevFields = {
  readonly __typename?: 'stops_database_parking_area_equipment_places_stddev_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesStddevOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingAreaEquipmentPlacesStddevPopFields = {
  readonly __typename?: 'stops_database_parking_area_equipment_places_stddev_pop_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesStddevPopOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingAreaEquipmentPlacesStddevSampFields = {
  readonly __typename?: 'stops_database_parking_area_equipment_places_stddev_samp_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesStddevSampOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseParkingAreaEquipmentPlacesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingAreaEquipmentPlacesStreamCursorValueInput = {
  readonly equipment_places_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_area_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingAreaEquipmentPlacesSumFields = {
  readonly __typename?: 'stops_database_parking_area_equipment_places_sum_fields';
  readonly equipment_places_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_area_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesSumOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** update columns of table "parking_area_equipment_places" */
export enum StopsDatabaseParkingAreaEquipmentPlacesUpdateColumn {
  /** column name */
  EquipmentPlacesId = 'equipment_places_id',
  /** column name */
  ParkingAreaId = 'parking_area_id'
}

export type StopsDatabaseParkingAreaEquipmentPlacesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseParkingAreaEquipmentPlacesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingAreaEquipmentPlacesVarPopFields = {
  readonly __typename?: 'stops_database_parking_area_equipment_places_var_pop_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesVarPopOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingAreaEquipmentPlacesVarSampFields = {
  readonly __typename?: 'stops_database_parking_area_equipment_places_var_samp_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesVarSampOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingAreaEquipmentPlacesVarianceFields = {
  readonly __typename?: 'stops_database_parking_area_equipment_places_variance_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "parking_area_equipment_places" */
export type StopsDatabaseParkingAreaEquipmentPlacesVarianceOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** input type for incrementing numeric columns in table "parking_area" */
export type StopsDatabaseParkingAreaIncInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_properties_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly total_capacity?: InputMaybe<Scalars['numeric']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "parking_area" */
export type StopsDatabaseParkingAreaInsertInput = {
  readonly accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentObjRelInsertInput>;
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureObjRelInsertInput>;
  readonly level_ref?: InputMaybe<Scalars['String']['input']>;
  readonly level_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly parking_area_alternative_names?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesArrRelInsertInput>;
  readonly parking_area_equipment_places?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesArrRelInsertInput>;
  readonly parking_area_key_values?: InputMaybe<StopsDatabaseParkingAreaKeyValuesArrRelInsertInput>;
  readonly parking_parking_area?: InputMaybe<StopsDatabaseParkingParkingAreasObjRelInsertInput>;
  readonly parking_properties_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_property?: InputMaybe<StopsDatabaseParkingPropertiesObjRelInsertInput>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonObjRelInsertInput>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly total_capacity?: InputMaybe<Scalars['numeric']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValues = {
  readonly __typename?: 'stops_database_parking_area_key_values';
  readonly key_values_id: Scalars['bigint']['output'];
  readonly key_values_key: Scalars['String']['output'];
  readonly parking_area_id: Scalars['bigint']['output'];
  /** An object relationship */
  readonly value: StopsDatabaseValue;
};

/** aggregated selection of "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesAggregate = {
  readonly __typename?: 'stops_database_parking_area_key_values_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseParkingAreaKeyValuesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseParkingAreaKeyValues>;
};

/** aggregate fields of "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesAggregateFields = {
  readonly __typename?: 'stops_database_parking_area_key_values_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseParkingAreaKeyValuesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseParkingAreaKeyValuesMaxFields>;
  readonly min?: Maybe<StopsDatabaseParkingAreaKeyValuesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseParkingAreaKeyValuesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseParkingAreaKeyValuesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseParkingAreaKeyValuesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseParkingAreaKeyValuesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseParkingAreaKeyValuesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseParkingAreaKeyValuesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseParkingAreaKeyValuesVarianceFields>;
};


/** aggregate fields of "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseParkingAreaKeyValuesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseParkingAreaKeyValuesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseParkingAreaKeyValuesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseParkingAreaKeyValuesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseParkingAreaKeyValuesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseParkingAreaKeyValuesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseParkingAreaKeyValuesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseParkingAreaKeyValuesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseParkingAreaKeyValuesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseParkingAreaKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseParkingAreaKeyValuesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseParkingAreaKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingAreaKeyValuesAvgFields = {
  readonly __typename?: 'stops_database_parking_area_key_values_avg_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesAvgOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "parking_area_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingAreaKeyValuesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaKeyValuesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseParkingAreaKeyValuesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaKeyValuesBoolExp>>;
  readonly key_values_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_key?: InputMaybe<StringComparisonExp>;
  readonly parking_area_id?: InputMaybe<BigintComparisonExp>;
  readonly value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "parking_area_key_values" */
export enum StopsDatabaseParkingAreaKeyValuesConstraint {
  /** unique or primary key constraint on columns "key_values_key", "parking_area_id" */
  ParkingAreaKeyValuesPkey = 'parking_area_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkRxv53i59u1pf70kxtdchlxird = 'uk_rxv53i59u1pf70kxtdchlxird'
}

/** input type for incrementing numeric columns in table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesIncInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_area_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesInsertInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly parking_area_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingAreaKeyValuesMaxFields = {
  readonly __typename?: 'stops_database_parking_area_key_values_max_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
  readonly parking_area_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesMaxOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingAreaKeyValuesMinFields = {
  readonly __typename?: 'stops_database_parking_area_key_values_min_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
  readonly parking_area_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesMinOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesMutationResponse = {
  readonly __typename?: 'stops_database_parking_area_key_values_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseParkingAreaKeyValues>;
};

/** on_conflict condition type for table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesOnConflict = {
  readonly constraint: StopsDatabaseParkingAreaKeyValuesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseParkingAreaKeyValuesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseParkingAreaKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "parking_area_key_values". */
export type StopsDatabaseParkingAreaKeyValuesOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
  readonly value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: parking_area_key_values */
export type StopsDatabaseParkingAreaKeyValuesPkColumnsInput = {
  readonly key_values_key: Scalars['String']['input'];
  readonly parking_area_id: Scalars['bigint']['input'];
};

/** select columns of table "parking_area_key_values" */
export enum StopsDatabaseParkingAreaKeyValuesSelectColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  ParkingAreaId = 'parking_area_id'
}

/** input type for updating data in table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesSetInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly parking_area_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingAreaKeyValuesStddevFields = {
  readonly __typename?: 'stops_database_parking_area_key_values_stddev_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesStddevOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingAreaKeyValuesStddevPopFields = {
  readonly __typename?: 'stops_database_parking_area_key_values_stddev_pop_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesStddevPopOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingAreaKeyValuesStddevSampFields = {
  readonly __typename?: 'stops_database_parking_area_key_values_stddev_samp_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesStddevSampOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseParkingAreaKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingAreaKeyValuesStreamCursorValueInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly parking_area_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingAreaKeyValuesSumFields = {
  readonly __typename?: 'stops_database_parking_area_key_values_sum_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_area_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesSumOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** update columns of table "parking_area_key_values" */
export enum StopsDatabaseParkingAreaKeyValuesUpdateColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  ParkingAreaId = 'parking_area_id'
}

export type StopsDatabaseParkingAreaKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseParkingAreaKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseParkingAreaKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseParkingAreaKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingAreaKeyValuesVarPopFields = {
  readonly __typename?: 'stops_database_parking_area_key_values_var_pop_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesVarPopOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingAreaKeyValuesVarSampFields = {
  readonly __typename?: 'stops_database_parking_area_key_values_var_samp_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesVarSampOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingAreaKeyValuesVarianceFields = {
  readonly __typename?: 'stops_database_parking_area_key_values_variance_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_area_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "parking_area_key_values" */
export type StopsDatabaseParkingAreaKeyValuesVarianceOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly parking_area_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingAreaMaxFields = {
  readonly __typename?: 'stops_database_parking_area_max_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly level_ref?: Maybe<Scalars['String']['output']>;
  readonly level_ref_version?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly parking_properties_id?: Maybe<Scalars['bigint']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly site_ref?: Maybe<Scalars['String']['output']>;
  readonly site_ref_version?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly total_capacity?: Maybe<Scalars['numeric']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingAreaMinFields = {
  readonly __typename?: 'stops_database_parking_area_min_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly level_ref?: Maybe<Scalars['String']['output']>;
  readonly level_ref_version?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly parking_properties_id?: Maybe<Scalars['bigint']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly site_ref?: Maybe<Scalars['String']['output']>;
  readonly site_ref_version?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly total_capacity?: Maybe<Scalars['numeric']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "parking_area" */
export type StopsDatabaseParkingAreaMutationResponse = {
  readonly __typename?: 'stops_database_parking_area_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseParkingArea>;
};

/** on_conflict condition type for table "parking_area" */
export type StopsDatabaseParkingAreaOnConflict = {
  readonly constraint: StopsDatabaseParkingAreaConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseParkingAreaUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseParkingAreaBoolExp>;
};

/** Ordering options when selecting data from "parking_area". */
export type StopsDatabaseParkingAreaOrderBy = {
  readonly accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentOrderBy>;
  readonly accessibility_assessment_id?: InputMaybe<OrderBy>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<OrderBy>;
  readonly centroid?: InputMaybe<OrderBy>;
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly covered?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly description_lang?: InputMaybe<OrderBy>;
  readonly description_value?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureOrderBy>;
  readonly level_ref?: InputMaybe<OrderBy>;
  readonly level_ref_version?: InputMaybe<OrderBy>;
  readonly name_lang?: InputMaybe<OrderBy>;
  readonly name_value?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly parking_area_alternative_names_aggregate?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesAggregateOrderBy>;
  readonly parking_area_equipment_places_aggregate?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesAggregateOrderBy>;
  readonly parking_area_key_values_aggregate?: InputMaybe<StopsDatabaseParkingAreaKeyValuesAggregateOrderBy>;
  readonly parking_parking_area?: InputMaybe<StopsDatabaseParkingParkingAreasOrderBy>;
  readonly parking_properties_id?: InputMaybe<OrderBy>;
  readonly parking_property?: InputMaybe<StopsDatabaseParkingPropertiesOrderBy>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonOrderBy>;
  readonly place_equipments_id?: InputMaybe<OrderBy>;
  readonly polygon_id?: InputMaybe<OrderBy>;
  readonly private_code_type?: InputMaybe<OrderBy>;
  readonly private_code_value?: InputMaybe<OrderBy>;
  readonly short_name_lang?: InputMaybe<OrderBy>;
  readonly short_name_value?: InputMaybe<OrderBy>;
  readonly site_ref?: InputMaybe<OrderBy>;
  readonly site_ref_version?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly total_capacity?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: parking_area */
export type StopsDatabaseParkingAreaPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "parking_area" */
export enum StopsDatabaseParkingAreaSelectColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  LevelRef = 'level_ref',
  /** column name */
  LevelRefVersion = 'level_ref_version',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ParkingPropertiesId = 'parking_properties_id',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  SiteRef = 'site_ref',
  /** column name */
  SiteRefVersion = 'site_ref_version',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TotalCapacity = 'total_capacity',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

/** input type for updating data in table "parking_area" */
export type StopsDatabaseParkingAreaSetInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly level_ref?: InputMaybe<Scalars['String']['input']>;
  readonly level_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly parking_properties_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly total_capacity?: InputMaybe<Scalars['numeric']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingAreaStddevFields = {
  readonly __typename?: 'stops_database_parking_area_stddev_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly total_capacity?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingAreaStddevPopFields = {
  readonly __typename?: 'stops_database_parking_area_stddev_pop_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly total_capacity?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingAreaStddevSampFields = {
  readonly __typename?: 'stops_database_parking_area_stddev_samp_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly total_capacity?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "parking_area" */
export type StopsDatabaseParkingAreaStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseParkingAreaStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingAreaStreamCursorValueInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly level_ref?: InputMaybe<Scalars['String']['input']>;
  readonly level_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly parking_properties_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly total_capacity?: InputMaybe<Scalars['numeric']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingAreaSumFields = {
  readonly __typename?: 'stops_database_parking_area_sum_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_properties_id?: Maybe<Scalars['bigint']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly total_capacity?: Maybe<Scalars['numeric']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "parking_area" */
export enum StopsDatabaseParkingAreaUpdateColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  LevelRef = 'level_ref',
  /** column name */
  LevelRefVersion = 'level_ref_version',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ParkingPropertiesId = 'parking_properties_id',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  SiteRef = 'site_ref',
  /** column name */
  SiteRefVersion = 'site_ref_version',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TotalCapacity = 'total_capacity',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

export type StopsDatabaseParkingAreaUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseParkingAreaIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseParkingAreaSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseParkingAreaBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingAreaVarPopFields = {
  readonly __typename?: 'stops_database_parking_area_var_pop_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly total_capacity?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingAreaVarSampFields = {
  readonly __typename?: 'stops_database_parking_area_var_samp_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly total_capacity?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingAreaVarianceFields = {
  readonly __typename?: 'stops_database_parking_area_variance_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly total_capacity?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingAvgFields = {
  readonly __typename?: 'stops_database_parking_avg_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly number_of_parking_levels?: Maybe<Scalars['Float']['output']>;
  readonly parking_layout?: Maybe<Scalars['Float']['output']>;
  readonly parking_reservation?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly principal_capacity?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
  readonly total_capacity?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "parking". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseParkingBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseParkingBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseParkingBoolExp>>;
  readonly accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentBoolExp>;
  readonly accessibility_assessment_id?: InputMaybe<BigintComparisonExp>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<BooleanComparisonExp>;
  readonly booking_url?: InputMaybe<StringComparisonExp>;
  readonly centroid?: InputMaybe<GeometryComparisonExp>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly covered?: InputMaybe<IntComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly description_lang?: InputMaybe<StringComparisonExp>;
  readonly description_value?: InputMaybe<StringComparisonExp>;
  readonly free_parking_out_of_hours?: InputMaybe<BooleanComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
  readonly name_lang?: InputMaybe<StringComparisonExp>;
  readonly name_value?: InputMaybe<StringComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly number_of_parking_levels?: InputMaybe<NumericComparisonExp>;
  readonly overnight_parking_permitted?: InputMaybe<BooleanComparisonExp>;
  readonly parent_site_ref?: InputMaybe<StringComparisonExp>;
  readonly parent_site_ref_version?: InputMaybe<StringComparisonExp>;
  readonly parking_alternative_names?: InputMaybe<StopsDatabaseParkingAlternativeNamesBoolExp>;
  readonly parking_alternative_names_aggregate?: InputMaybe<ParkingAlternativeNamesAggregateBoolExp>;
  readonly parking_equipment_places?: InputMaybe<StopsDatabaseParkingEquipmentPlacesBoolExp>;
  readonly parking_equipment_places_aggregate?: InputMaybe<ParkingEquipmentPlacesAggregateBoolExp>;
  readonly parking_key_values?: InputMaybe<StopsDatabaseParkingKeyValuesBoolExp>;
  readonly parking_key_values_aggregate?: InputMaybe<ParkingKeyValuesAggregateBoolExp>;
  readonly parking_layout?: InputMaybe<IntComparisonExp>;
  readonly parking_parking_areas?: InputMaybe<StopsDatabaseParkingParkingAreasBoolExp>;
  readonly parking_parking_areas_aggregate?: InputMaybe<ParkingParkingAreasAggregateBoolExp>;
  readonly parking_parking_payment_processes?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessBoolExp>;
  readonly parking_parking_payment_processes_aggregate?: InputMaybe<ParkingParkingPaymentProcessAggregateBoolExp>;
  readonly parking_parking_properties?: InputMaybe<StopsDatabaseParkingParkingPropertiesBoolExp>;
  readonly parking_parking_properties_aggregate?: InputMaybe<ParkingParkingPropertiesAggregateBoolExp>;
  readonly parking_parking_vehicle_types?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesBoolExp>;
  readonly parking_parking_vehicle_types_aggregate?: InputMaybe<ParkingParkingVehicleTypesAggregateBoolExp>;
  readonly parking_reservation?: InputMaybe<IntComparisonExp>;
  readonly parking_type?: InputMaybe<StringComparisonExp>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  readonly place_equipments_id?: InputMaybe<BigintComparisonExp>;
  readonly polygon_id?: InputMaybe<BigintComparisonExp>;
  readonly principal_capacity?: InputMaybe<NumericComparisonExp>;
  readonly private_code_type?: InputMaybe<StringComparisonExp>;
  readonly private_code_value?: InputMaybe<StringComparisonExp>;
  readonly prohibited_for_hazardous_materials?: InputMaybe<BooleanComparisonExp>;
  readonly real_time_occupancy_available?: InputMaybe<BooleanComparisonExp>;
  readonly recharging_available?: InputMaybe<BooleanComparisonExp>;
  readonly secure?: InputMaybe<BooleanComparisonExp>;
  readonly short_name_lang?: InputMaybe<StringComparisonExp>;
  readonly short_name_value?: InputMaybe<StringComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly topographic_place?: InputMaybe<StopsDatabaseTopographicPlaceBoolExp>;
  readonly topographic_place_id?: InputMaybe<BigintComparisonExp>;
  readonly total_capacity?: InputMaybe<NumericComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
};

/** columns and relationships of "parking_capacity" */
export type StopsDatabaseParkingCapacity = {
  readonly __typename?: 'stops_database_parking_capacity';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id: Scalars['bigint']['output'];
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['numeric']['output']>;
  readonly number_of_spaces_with_recharge_point?: Maybe<Scalars['numeric']['output']>;
  readonly parent_ref?: Maybe<Scalars['bytea']['output']>;
  readonly parking_stay_type?: Maybe<Scalars['String']['output']>;
  readonly parking_user_type?: Maybe<Scalars['String']['output']>;
  readonly parking_vehicle_type?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "parking_capacity" */
export type StopsDatabaseParkingCapacityAggregate = {
  readonly __typename?: 'stops_database_parking_capacity_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseParkingCapacityAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseParkingCapacity>;
};

/** aggregate fields of "parking_capacity" */
export type StopsDatabaseParkingCapacityAggregateFields = {
  readonly __typename?: 'stops_database_parking_capacity_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseParkingCapacityAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseParkingCapacityMaxFields>;
  readonly min?: Maybe<StopsDatabaseParkingCapacityMinFields>;
  readonly stddev?: Maybe<StopsDatabaseParkingCapacityStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseParkingCapacityStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseParkingCapacityStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseParkingCapacitySumFields>;
  readonly var_pop?: Maybe<StopsDatabaseParkingCapacityVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseParkingCapacityVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseParkingCapacityVarianceFields>;
};


/** aggregate fields of "parking_capacity" */
export type StopsDatabaseParkingCapacityAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseParkingCapacitySelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingCapacityAvgFields = {
  readonly __typename?: 'stops_database_parking_capacity_avg_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces_with_recharge_point?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "parking_capacity". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingCapacityBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseParkingCapacityBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseParkingCapacityBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseParkingCapacityBoolExp>>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly number_of_spaces?: InputMaybe<NumericComparisonExp>;
  readonly number_of_spaces_with_recharge_point?: InputMaybe<NumericComparisonExp>;
  readonly parent_ref?: InputMaybe<ByteaComparisonExp>;
  readonly parking_stay_type?: InputMaybe<StringComparisonExp>;
  readonly parking_user_type?: InputMaybe<StringComparisonExp>;
  readonly parking_vehicle_type?: InputMaybe<StringComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "parking_capacity" */
export enum StopsDatabaseParkingCapacityConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  ParkingCapacityNetexIdVersionConstraint = 'parking_capacity_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  ParkingCapacityPkey = 'parking_capacity_pkey'
}

/** input type for incrementing numeric columns in table "parking_capacity" */
export type StopsDatabaseParkingCapacityIncInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly number_of_spaces?: InputMaybe<Scalars['numeric']['input']>;
  readonly number_of_spaces_with_recharge_point?: InputMaybe<Scalars['numeric']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "parking_capacity" */
export type StopsDatabaseParkingCapacityInsertInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly number_of_spaces?: InputMaybe<Scalars['numeric']['input']>;
  readonly number_of_spaces_with_recharge_point?: InputMaybe<Scalars['numeric']['input']>;
  readonly parent_ref?: InputMaybe<Scalars['bytea']['input']>;
  readonly parking_stay_type?: InputMaybe<Scalars['String']['input']>;
  readonly parking_user_type?: InputMaybe<Scalars['String']['input']>;
  readonly parking_vehicle_type?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingCapacityMaxFields = {
  readonly __typename?: 'stops_database_parking_capacity_max_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['numeric']['output']>;
  readonly number_of_spaces_with_recharge_point?: Maybe<Scalars['numeric']['output']>;
  readonly parking_stay_type?: Maybe<Scalars['String']['output']>;
  readonly parking_user_type?: Maybe<Scalars['String']['output']>;
  readonly parking_vehicle_type?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingCapacityMinFields = {
  readonly __typename?: 'stops_database_parking_capacity_min_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['numeric']['output']>;
  readonly number_of_spaces_with_recharge_point?: Maybe<Scalars['numeric']['output']>;
  readonly parking_stay_type?: Maybe<Scalars['String']['output']>;
  readonly parking_user_type?: Maybe<Scalars['String']['output']>;
  readonly parking_vehicle_type?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "parking_capacity" */
export type StopsDatabaseParkingCapacityMutationResponse = {
  readonly __typename?: 'stops_database_parking_capacity_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseParkingCapacity>;
};

/** on_conflict condition type for table "parking_capacity" */
export type StopsDatabaseParkingCapacityOnConflict = {
  readonly constraint: StopsDatabaseParkingCapacityConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseParkingCapacityUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseParkingCapacityBoolExp>;
};

/** Ordering options when selecting data from "parking_capacity". */
export type StopsDatabaseParkingCapacityOrderBy = {
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly number_of_spaces?: InputMaybe<OrderBy>;
  readonly number_of_spaces_with_recharge_point?: InputMaybe<OrderBy>;
  readonly parent_ref?: InputMaybe<OrderBy>;
  readonly parking_stay_type?: InputMaybe<OrderBy>;
  readonly parking_user_type?: InputMaybe<OrderBy>;
  readonly parking_vehicle_type?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: parking_capacity */
export type StopsDatabaseParkingCapacityPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "parking_capacity" */
export enum StopsDatabaseParkingCapacitySelectColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  NumberOfSpaces = 'number_of_spaces',
  /** column name */
  NumberOfSpacesWithRechargePoint = 'number_of_spaces_with_recharge_point',
  /** column name */
  ParentRef = 'parent_ref',
  /** column name */
  ParkingStayType = 'parking_stay_type',
  /** column name */
  ParkingUserType = 'parking_user_type',
  /** column name */
  ParkingVehicleType = 'parking_vehicle_type',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

/** input type for updating data in table "parking_capacity" */
export type StopsDatabaseParkingCapacitySetInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly number_of_spaces?: InputMaybe<Scalars['numeric']['input']>;
  readonly number_of_spaces_with_recharge_point?: InputMaybe<Scalars['numeric']['input']>;
  readonly parent_ref?: InputMaybe<Scalars['bytea']['input']>;
  readonly parking_stay_type?: InputMaybe<Scalars['String']['input']>;
  readonly parking_user_type?: InputMaybe<Scalars['String']['input']>;
  readonly parking_vehicle_type?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingCapacityStddevFields = {
  readonly __typename?: 'stops_database_parking_capacity_stddev_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces_with_recharge_point?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingCapacityStddevPopFields = {
  readonly __typename?: 'stops_database_parking_capacity_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces_with_recharge_point?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingCapacityStddevSampFields = {
  readonly __typename?: 'stops_database_parking_capacity_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces_with_recharge_point?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "parking_capacity" */
export type StopsDatabaseParkingCapacityStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseParkingCapacityStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingCapacityStreamCursorValueInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly number_of_spaces?: InputMaybe<Scalars['numeric']['input']>;
  readonly number_of_spaces_with_recharge_point?: InputMaybe<Scalars['numeric']['input']>;
  readonly parent_ref?: InputMaybe<Scalars['bytea']['input']>;
  readonly parking_stay_type?: InputMaybe<Scalars['String']['input']>;
  readonly parking_user_type?: InputMaybe<Scalars['String']['input']>;
  readonly parking_vehicle_type?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingCapacitySumFields = {
  readonly __typename?: 'stops_database_parking_capacity_sum_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['numeric']['output']>;
  readonly number_of_spaces_with_recharge_point?: Maybe<Scalars['numeric']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "parking_capacity" */
export enum StopsDatabaseParkingCapacityUpdateColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  NumberOfSpaces = 'number_of_spaces',
  /** column name */
  NumberOfSpacesWithRechargePoint = 'number_of_spaces_with_recharge_point',
  /** column name */
  ParentRef = 'parent_ref',
  /** column name */
  ParkingStayType = 'parking_stay_type',
  /** column name */
  ParkingUserType = 'parking_user_type',
  /** column name */
  ParkingVehicleType = 'parking_vehicle_type',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

export type StopsDatabaseParkingCapacityUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseParkingCapacityIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseParkingCapacitySetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseParkingCapacityBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingCapacityVarPopFields = {
  readonly __typename?: 'stops_database_parking_capacity_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces_with_recharge_point?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingCapacityVarSampFields = {
  readonly __typename?: 'stops_database_parking_capacity_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces_with_recharge_point?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingCapacityVarianceFields = {
  readonly __typename?: 'stops_database_parking_capacity_variance_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces_with_recharge_point?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** unique or primary key constraints on table "parking" */
export enum StopsDatabaseParkingConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  ParkingNetexIdVersionConstraint = 'parking_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  ParkingPkey = 'parking_pkey'
}

/** columns and relationships of "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlaces = {
  readonly __typename?: 'stops_database_parking_equipment_places';
  readonly equipment_places_id: Scalars['bigint']['output'];
  readonly parking_id: Scalars['bigint']['output'];
};

/** aggregated selection of "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesAggregate = {
  readonly __typename?: 'stops_database_parking_equipment_places_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseParkingEquipmentPlacesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseParkingEquipmentPlaces>;
};

/** aggregate fields of "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesAggregateFields = {
  readonly __typename?: 'stops_database_parking_equipment_places_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseParkingEquipmentPlacesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseParkingEquipmentPlacesMaxFields>;
  readonly min?: Maybe<StopsDatabaseParkingEquipmentPlacesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseParkingEquipmentPlacesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseParkingEquipmentPlacesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseParkingEquipmentPlacesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseParkingEquipmentPlacesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseParkingEquipmentPlacesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseParkingEquipmentPlacesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseParkingEquipmentPlacesVarianceFields>;
};


/** aggregate fields of "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseParkingEquipmentPlacesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseParkingEquipmentPlacesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseParkingEquipmentPlacesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseParkingEquipmentPlacesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseParkingEquipmentPlacesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseParkingEquipmentPlacesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseParkingEquipmentPlacesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseParkingEquipmentPlacesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseParkingEquipmentPlacesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseParkingEquipmentPlacesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseParkingEquipmentPlacesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseParkingEquipmentPlacesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseParkingEquipmentPlacesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingEquipmentPlacesAvgFields = {
  readonly __typename?: 'stops_database_parking_equipment_places_avg_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesAvgOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "parking_equipment_places". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingEquipmentPlacesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseParkingEquipmentPlacesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseParkingEquipmentPlacesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseParkingEquipmentPlacesBoolExp>>;
  readonly equipment_places_id?: InputMaybe<BigintComparisonExp>;
  readonly parking_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "parking_equipment_places" */
export enum StopsDatabaseParkingEquipmentPlacesConstraint {
  /** unique or primary key constraint on columns "equipment_places_id" */
  Uk_9sg6v3vst7yq7nvli7tt317wg = 'uk_9sg6v3vst7yq7nvli7tt317wg'
}

/** input type for incrementing numeric columns in table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesIncInput = {
  readonly equipment_places_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesInsertInput = {
  readonly equipment_places_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingEquipmentPlacesMaxFields = {
  readonly __typename?: 'stops_database_parking_equipment_places_max_fields';
  readonly equipment_places_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesMaxOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingEquipmentPlacesMinFields = {
  readonly __typename?: 'stops_database_parking_equipment_places_min_fields';
  readonly equipment_places_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesMinOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesMutationResponse = {
  readonly __typename?: 'stops_database_parking_equipment_places_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseParkingEquipmentPlaces>;
};

/** on_conflict condition type for table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesOnConflict = {
  readonly constraint: StopsDatabaseParkingEquipmentPlacesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseParkingEquipmentPlacesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseParkingEquipmentPlacesBoolExp>;
};

/** Ordering options when selecting data from "parking_equipment_places". */
export type StopsDatabaseParkingEquipmentPlacesOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** select columns of table "parking_equipment_places" */
export enum StopsDatabaseParkingEquipmentPlacesSelectColumn {
  /** column name */
  EquipmentPlacesId = 'equipment_places_id',
  /** column name */
  ParkingId = 'parking_id'
}

/** input type for updating data in table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesSetInput = {
  readonly equipment_places_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingEquipmentPlacesStddevFields = {
  readonly __typename?: 'stops_database_parking_equipment_places_stddev_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesStddevOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingEquipmentPlacesStddevPopFields = {
  readonly __typename?: 'stops_database_parking_equipment_places_stddev_pop_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesStddevPopOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingEquipmentPlacesStddevSampFields = {
  readonly __typename?: 'stops_database_parking_equipment_places_stddev_samp_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesStddevSampOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseParkingEquipmentPlacesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingEquipmentPlacesStreamCursorValueInput = {
  readonly equipment_places_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingEquipmentPlacesSumFields = {
  readonly __typename?: 'stops_database_parking_equipment_places_sum_fields';
  readonly equipment_places_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesSumOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** update columns of table "parking_equipment_places" */
export enum StopsDatabaseParkingEquipmentPlacesUpdateColumn {
  /** column name */
  EquipmentPlacesId = 'equipment_places_id',
  /** column name */
  ParkingId = 'parking_id'
}

export type StopsDatabaseParkingEquipmentPlacesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseParkingEquipmentPlacesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseParkingEquipmentPlacesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseParkingEquipmentPlacesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingEquipmentPlacesVarPopFields = {
  readonly __typename?: 'stops_database_parking_equipment_places_var_pop_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesVarPopOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingEquipmentPlacesVarSampFields = {
  readonly __typename?: 'stops_database_parking_equipment_places_var_samp_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesVarSampOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingEquipmentPlacesVarianceFields = {
  readonly __typename?: 'stops_database_parking_equipment_places_variance_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "parking_equipment_places" */
export type StopsDatabaseParkingEquipmentPlacesVarianceOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** input type for incrementing numeric columns in table "parking" */
export type StopsDatabaseParkingIncInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly number_of_parking_levels?: InputMaybe<Scalars['numeric']['input']>;
  readonly parking_layout?: InputMaybe<Scalars['Int']['input']>;
  readonly parking_reservation?: InputMaybe<Scalars['Int']['input']>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly principal_capacity?: InputMaybe<Scalars['numeric']['input']>;
  readonly topographic_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly total_capacity?: InputMaybe<Scalars['numeric']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "parking" */
export type StopsDatabaseParkingInsertInput = {
  readonly accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentObjRelInsertInput>;
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  readonly booking_url?: InputMaybe<Scalars['String']['input']>;
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly free_parking_out_of_hours?: InputMaybe<Scalars['Boolean']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureObjRelInsertInput>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly number_of_parking_levels?: InputMaybe<Scalars['numeric']['input']>;
  readonly overnight_parking_permitted?: InputMaybe<Scalars['Boolean']['input']>;
  readonly parent_site_ref?: InputMaybe<Scalars['String']['input']>;
  readonly parent_site_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly parking_alternative_names?: InputMaybe<StopsDatabaseParkingAlternativeNamesArrRelInsertInput>;
  readonly parking_equipment_places?: InputMaybe<StopsDatabaseParkingEquipmentPlacesArrRelInsertInput>;
  readonly parking_key_values?: InputMaybe<StopsDatabaseParkingKeyValuesArrRelInsertInput>;
  readonly parking_layout?: InputMaybe<Scalars['Int']['input']>;
  readonly parking_parking_areas?: InputMaybe<StopsDatabaseParkingParkingAreasArrRelInsertInput>;
  readonly parking_parking_payment_processes?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessArrRelInsertInput>;
  readonly parking_parking_properties?: InputMaybe<StopsDatabaseParkingParkingPropertiesArrRelInsertInput>;
  readonly parking_parking_vehicle_types?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesArrRelInsertInput>;
  readonly parking_reservation?: InputMaybe<Scalars['Int']['input']>;
  readonly parking_type?: InputMaybe<Scalars['String']['input']>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonObjRelInsertInput>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly principal_capacity?: InputMaybe<Scalars['numeric']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly prohibited_for_hazardous_materials?: InputMaybe<Scalars['Boolean']['input']>;
  readonly real_time_occupancy_available?: InputMaybe<Scalars['Boolean']['input']>;
  readonly recharging_available?: InputMaybe<Scalars['Boolean']['input']>;
  readonly secure?: InputMaybe<Scalars['Boolean']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly topographic_place?: InputMaybe<StopsDatabaseTopographicPlaceObjRelInsertInput>;
  readonly topographic_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly total_capacity?: InputMaybe<Scalars['numeric']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "parking_key_values" */
export type StopsDatabaseParkingKeyValues = {
  readonly __typename?: 'stops_database_parking_key_values';
  readonly key_values_id: Scalars['bigint']['output'];
  readonly key_values_key: Scalars['String']['output'];
  readonly parking_id: Scalars['bigint']['output'];
};

/** aggregated selection of "parking_key_values" */
export type StopsDatabaseParkingKeyValuesAggregate = {
  readonly __typename?: 'stops_database_parking_key_values_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseParkingKeyValuesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseParkingKeyValues>;
};

/** aggregate fields of "parking_key_values" */
export type StopsDatabaseParkingKeyValuesAggregateFields = {
  readonly __typename?: 'stops_database_parking_key_values_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseParkingKeyValuesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseParkingKeyValuesMaxFields>;
  readonly min?: Maybe<StopsDatabaseParkingKeyValuesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseParkingKeyValuesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseParkingKeyValuesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseParkingKeyValuesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseParkingKeyValuesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseParkingKeyValuesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseParkingKeyValuesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseParkingKeyValuesVarianceFields>;
};


/** aggregate fields of "parking_key_values" */
export type StopsDatabaseParkingKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseParkingKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseParkingKeyValuesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseParkingKeyValuesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseParkingKeyValuesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseParkingKeyValuesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseParkingKeyValuesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseParkingKeyValuesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseParkingKeyValuesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseParkingKeyValuesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseParkingKeyValuesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseParkingKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseParkingKeyValuesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseParkingKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingKeyValuesAvgFields = {
  readonly __typename?: 'stops_database_parking_key_values_avg_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesAvgOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "parking_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingKeyValuesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseParkingKeyValuesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseParkingKeyValuesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseParkingKeyValuesBoolExp>>;
  readonly key_values_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_key?: InputMaybe<StringComparisonExp>;
  readonly parking_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "parking_key_values" */
export enum StopsDatabaseParkingKeyValuesConstraint {
  /** unique or primary key constraint on columns "key_values_key", "parking_id" */
  ParkingKeyValuesPkey = 'parking_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkIteh0to4gqim61p74lq2ugc2k = 'uk_iteh0to4gqim61p74lq2ugc2k'
}

/** input type for incrementing numeric columns in table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesIncInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesInsertInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingKeyValuesMaxFields = {
  readonly __typename?: 'stops_database_parking_key_values_max_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
  readonly parking_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesMaxOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingKeyValuesMinFields = {
  readonly __typename?: 'stops_database_parking_key_values_min_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
  readonly parking_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesMinOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesMutationResponse = {
  readonly __typename?: 'stops_database_parking_key_values_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseParkingKeyValues>;
};

/** on_conflict condition type for table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesOnConflict = {
  readonly constraint: StopsDatabaseParkingKeyValuesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseParkingKeyValuesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseParkingKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "parking_key_values". */
export type StopsDatabaseParkingKeyValuesOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: parking_key_values */
export type StopsDatabaseParkingKeyValuesPkColumnsInput = {
  readonly key_values_key: Scalars['String']['input'];
  readonly parking_id: Scalars['bigint']['input'];
};

/** select columns of table "parking_key_values" */
export enum StopsDatabaseParkingKeyValuesSelectColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  ParkingId = 'parking_id'
}

/** input type for updating data in table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesSetInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingKeyValuesStddevFields = {
  readonly __typename?: 'stops_database_parking_key_values_stddev_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesStddevOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingKeyValuesStddevPopFields = {
  readonly __typename?: 'stops_database_parking_key_values_stddev_pop_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesStddevPopOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingKeyValuesStddevSampFields = {
  readonly __typename?: 'stops_database_parking_key_values_stddev_samp_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesStddevSampOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseParkingKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingKeyValuesStreamCursorValueInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingKeyValuesSumFields = {
  readonly __typename?: 'stops_database_parking_key_values_sum_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesSumOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** update columns of table "parking_key_values" */
export enum StopsDatabaseParkingKeyValuesUpdateColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  ParkingId = 'parking_id'
}

export type StopsDatabaseParkingKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseParkingKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseParkingKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseParkingKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingKeyValuesVarPopFields = {
  readonly __typename?: 'stops_database_parking_key_values_var_pop_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesVarPopOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingKeyValuesVarSampFields = {
  readonly __typename?: 'stops_database_parking_key_values_var_samp_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesVarSampOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingKeyValuesVarianceFields = {
  readonly __typename?: 'stops_database_parking_key_values_variance_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "parking_key_values" */
export type StopsDatabaseParkingKeyValuesVarianceOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingMaxFields = {
  readonly __typename?: 'stops_database_parking_max_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly booking_url?: Maybe<Scalars['String']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly number_of_parking_levels?: Maybe<Scalars['numeric']['output']>;
  readonly parent_site_ref?: Maybe<Scalars['String']['output']>;
  readonly parent_site_ref_version?: Maybe<Scalars['String']['output']>;
  readonly parking_layout?: Maybe<Scalars['Int']['output']>;
  readonly parking_reservation?: Maybe<Scalars['Int']['output']>;
  readonly parking_type?: Maybe<Scalars['String']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly principal_capacity?: Maybe<Scalars['numeric']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly total_capacity?: Maybe<Scalars['numeric']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingMinFields = {
  readonly __typename?: 'stops_database_parking_min_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly booking_url?: Maybe<Scalars['String']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly number_of_parking_levels?: Maybe<Scalars['numeric']['output']>;
  readonly parent_site_ref?: Maybe<Scalars['String']['output']>;
  readonly parent_site_ref_version?: Maybe<Scalars['String']['output']>;
  readonly parking_layout?: Maybe<Scalars['Int']['output']>;
  readonly parking_reservation?: Maybe<Scalars['Int']['output']>;
  readonly parking_type?: Maybe<Scalars['String']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly principal_capacity?: Maybe<Scalars['numeric']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly total_capacity?: Maybe<Scalars['numeric']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "parking" */
export type StopsDatabaseParkingMutationResponse = {
  readonly __typename?: 'stops_database_parking_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseParking>;
};

/** on_conflict condition type for table "parking" */
export type StopsDatabaseParkingOnConflict = {
  readonly constraint: StopsDatabaseParkingConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseParkingUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseParkingBoolExp>;
};

/** Ordering options when selecting data from "parking". */
export type StopsDatabaseParkingOrderBy = {
  readonly accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentOrderBy>;
  readonly accessibility_assessment_id?: InputMaybe<OrderBy>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<OrderBy>;
  readonly booking_url?: InputMaybe<OrderBy>;
  readonly centroid?: InputMaybe<OrderBy>;
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly covered?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly description_lang?: InputMaybe<OrderBy>;
  readonly description_value?: InputMaybe<OrderBy>;
  readonly free_parking_out_of_hours?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureOrderBy>;
  readonly name_lang?: InputMaybe<OrderBy>;
  readonly name_value?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly number_of_parking_levels?: InputMaybe<OrderBy>;
  readonly overnight_parking_permitted?: InputMaybe<OrderBy>;
  readonly parent_site_ref?: InputMaybe<OrderBy>;
  readonly parent_site_ref_version?: InputMaybe<OrderBy>;
  readonly parking_alternative_names_aggregate?: InputMaybe<StopsDatabaseParkingAlternativeNamesAggregateOrderBy>;
  readonly parking_equipment_places_aggregate?: InputMaybe<StopsDatabaseParkingEquipmentPlacesAggregateOrderBy>;
  readonly parking_key_values_aggregate?: InputMaybe<StopsDatabaseParkingKeyValuesAggregateOrderBy>;
  readonly parking_layout?: InputMaybe<OrderBy>;
  readonly parking_parking_areas_aggregate?: InputMaybe<StopsDatabaseParkingParkingAreasAggregateOrderBy>;
  readonly parking_parking_payment_processes_aggregate?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessAggregateOrderBy>;
  readonly parking_parking_properties_aggregate?: InputMaybe<StopsDatabaseParkingParkingPropertiesAggregateOrderBy>;
  readonly parking_parking_vehicle_types_aggregate?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesAggregateOrderBy>;
  readonly parking_reservation?: InputMaybe<OrderBy>;
  readonly parking_type?: InputMaybe<OrderBy>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonOrderBy>;
  readonly place_equipments_id?: InputMaybe<OrderBy>;
  readonly polygon_id?: InputMaybe<OrderBy>;
  readonly principal_capacity?: InputMaybe<OrderBy>;
  readonly private_code_type?: InputMaybe<OrderBy>;
  readonly private_code_value?: InputMaybe<OrderBy>;
  readonly prohibited_for_hazardous_materials?: InputMaybe<OrderBy>;
  readonly real_time_occupancy_available?: InputMaybe<OrderBy>;
  readonly recharging_available?: InputMaybe<OrderBy>;
  readonly secure?: InputMaybe<OrderBy>;
  readonly short_name_lang?: InputMaybe<OrderBy>;
  readonly short_name_value?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly topographic_place?: InputMaybe<StopsDatabaseTopographicPlaceOrderBy>;
  readonly topographic_place_id?: InputMaybe<OrderBy>;
  readonly total_capacity?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
};

/** columns and relationships of "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreas = {
  readonly __typename?: 'stops_database_parking_parking_areas';
  readonly parking_areas_id: Scalars['bigint']['output'];
  readonly parking_id: Scalars['bigint']['output'];
};

/** aggregated selection of "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasAggregate = {
  readonly __typename?: 'stops_database_parking_parking_areas_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseParkingParkingAreasAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseParkingParkingAreas>;
};

/** aggregate fields of "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasAggregateFields = {
  readonly __typename?: 'stops_database_parking_parking_areas_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseParkingParkingAreasAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseParkingParkingAreasMaxFields>;
  readonly min?: Maybe<StopsDatabaseParkingParkingAreasMinFields>;
  readonly stddev?: Maybe<StopsDatabaseParkingParkingAreasStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseParkingParkingAreasStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseParkingParkingAreasStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseParkingParkingAreasSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseParkingParkingAreasVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseParkingParkingAreasVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseParkingParkingAreasVarianceFields>;
};


/** aggregate fields of "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingAreasSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseParkingParkingAreasAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseParkingParkingAreasMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseParkingParkingAreasMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseParkingParkingAreasStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseParkingParkingAreasStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseParkingParkingAreasStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseParkingParkingAreasSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseParkingParkingAreasVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseParkingParkingAreasVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseParkingParkingAreasVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseParkingParkingAreasInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseParkingParkingAreasOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingParkingAreasAvgFields = {
  readonly __typename?: 'stops_database_parking_parking_areas_avg_fields';
  readonly parking_areas_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasAvgOrderBy = {
  readonly parking_areas_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "parking_parking_areas". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingParkingAreasBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingAreasBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseParkingParkingAreasBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingAreasBoolExp>>;
  readonly parking_areas_id?: InputMaybe<BigintComparisonExp>;
  readonly parking_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "parking_parking_areas" */
export enum StopsDatabaseParkingParkingAreasConstraint {
  /** unique or primary key constraint on columns "parking_areas_id" */
  Uk_66npakygxb5mjymo8x06yf9sj = 'uk_66npakygxb5mjymo8x06yf9sj'
}

/** input type for incrementing numeric columns in table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasIncInput = {
  readonly parking_areas_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasInsertInput = {
  readonly parking_areas_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingParkingAreasMaxFields = {
  readonly __typename?: 'stops_database_parking_parking_areas_max_fields';
  readonly parking_areas_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasMaxOrderBy = {
  readonly parking_areas_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingParkingAreasMinFields = {
  readonly __typename?: 'stops_database_parking_parking_areas_min_fields';
  readonly parking_areas_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasMinOrderBy = {
  readonly parking_areas_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasMutationResponse = {
  readonly __typename?: 'stops_database_parking_parking_areas_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseParkingParkingAreas>;
};

/** input type for inserting object relation for remote table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasObjRelInsertInput = {
  readonly data: StopsDatabaseParkingParkingAreasInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseParkingParkingAreasOnConflict>;
};

/** on_conflict condition type for table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasOnConflict = {
  readonly constraint: StopsDatabaseParkingParkingAreasConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseParkingParkingAreasUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseParkingParkingAreasBoolExp>;
};

/** Ordering options when selecting data from "parking_parking_areas". */
export type StopsDatabaseParkingParkingAreasOrderBy = {
  readonly parking_areas_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** select columns of table "parking_parking_areas" */
export enum StopsDatabaseParkingParkingAreasSelectColumn {
  /** column name */
  ParkingAreasId = 'parking_areas_id',
  /** column name */
  ParkingId = 'parking_id'
}

/** input type for updating data in table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasSetInput = {
  readonly parking_areas_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingParkingAreasStddevFields = {
  readonly __typename?: 'stops_database_parking_parking_areas_stddev_fields';
  readonly parking_areas_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasStddevOrderBy = {
  readonly parking_areas_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingParkingAreasStddevPopFields = {
  readonly __typename?: 'stops_database_parking_parking_areas_stddev_pop_fields';
  readonly parking_areas_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasStddevPopOrderBy = {
  readonly parking_areas_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingParkingAreasStddevSampFields = {
  readonly __typename?: 'stops_database_parking_parking_areas_stddev_samp_fields';
  readonly parking_areas_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasStddevSampOrderBy = {
  readonly parking_areas_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseParkingParkingAreasStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingParkingAreasStreamCursorValueInput = {
  readonly parking_areas_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingParkingAreasSumFields = {
  readonly __typename?: 'stops_database_parking_parking_areas_sum_fields';
  readonly parking_areas_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasSumOrderBy = {
  readonly parking_areas_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** update columns of table "parking_parking_areas" */
export enum StopsDatabaseParkingParkingAreasUpdateColumn {
  /** column name */
  ParkingAreasId = 'parking_areas_id',
  /** column name */
  ParkingId = 'parking_id'
}

export type StopsDatabaseParkingParkingAreasUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseParkingParkingAreasIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseParkingParkingAreasSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseParkingParkingAreasBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingParkingAreasVarPopFields = {
  readonly __typename?: 'stops_database_parking_parking_areas_var_pop_fields';
  readonly parking_areas_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasVarPopOrderBy = {
  readonly parking_areas_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingParkingAreasVarSampFields = {
  readonly __typename?: 'stops_database_parking_parking_areas_var_samp_fields';
  readonly parking_areas_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasVarSampOrderBy = {
  readonly parking_areas_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingParkingAreasVarianceFields = {
  readonly __typename?: 'stops_database_parking_parking_areas_variance_fields';
  readonly parking_areas_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "parking_parking_areas" */
export type StopsDatabaseParkingParkingAreasVarianceOrderBy = {
  readonly parking_areas_id?: InputMaybe<OrderBy>;
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** columns and relationships of "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcess = {
  readonly __typename?: 'stops_database_parking_parking_payment_process';
  readonly parking_id: Scalars['bigint']['output'];
  readonly parking_payment_process?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessAggregate = {
  readonly __typename?: 'stops_database_parking_parking_payment_process_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseParkingParkingPaymentProcessAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseParkingParkingPaymentProcess>;
};

/** aggregate fields of "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessAggregateFields = {
  readonly __typename?: 'stops_database_parking_parking_payment_process_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseParkingParkingPaymentProcessAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseParkingParkingPaymentProcessMaxFields>;
  readonly min?: Maybe<StopsDatabaseParkingParkingPaymentProcessMinFields>;
  readonly stddev?: Maybe<StopsDatabaseParkingParkingPaymentProcessStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseParkingParkingPaymentProcessStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseParkingParkingPaymentProcessStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseParkingParkingPaymentProcessSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseParkingParkingPaymentProcessVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseParkingParkingPaymentProcessVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseParkingParkingPaymentProcessVarianceFields>;
};


/** aggregate fields of "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPaymentProcessSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseParkingParkingPaymentProcessInsertInput>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingParkingPaymentProcessAvgFields = {
  readonly __typename?: 'stops_database_parking_parking_payment_process_avg_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessAvgOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "parking_parking_payment_process". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingParkingPaymentProcessBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPaymentProcessBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPaymentProcessBoolExp>>;
  readonly parking_id?: InputMaybe<BigintComparisonExp>;
  readonly parking_payment_process?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessIncInput = {
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessInsertInput = {
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_payment_process?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingParkingPaymentProcessMaxFields = {
  readonly __typename?: 'stops_database_parking_parking_payment_process_max_fields';
  readonly parking_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_payment_process?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessMaxOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
  readonly parking_payment_process?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingParkingPaymentProcessMinFields = {
  readonly __typename?: 'stops_database_parking_parking_payment_process_min_fields';
  readonly parking_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_payment_process?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessMinOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
  readonly parking_payment_process?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessMutationResponse = {
  readonly __typename?: 'stops_database_parking_parking_payment_process_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseParkingParkingPaymentProcess>;
};

/** Ordering options when selecting data from "parking_parking_payment_process". */
export type StopsDatabaseParkingParkingPaymentProcessOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
  readonly parking_payment_process?: InputMaybe<OrderBy>;
};

/** select columns of table "parking_parking_payment_process" */
export enum StopsDatabaseParkingParkingPaymentProcessSelectColumn {
  /** column name */
  ParkingId = 'parking_id',
  /** column name */
  ParkingPaymentProcess = 'parking_payment_process'
}

/** input type for updating data in table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessSetInput = {
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_payment_process?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingParkingPaymentProcessStddevFields = {
  readonly __typename?: 'stops_database_parking_parking_payment_process_stddev_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessStddevOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingParkingPaymentProcessStddevPopFields = {
  readonly __typename?: 'stops_database_parking_parking_payment_process_stddev_pop_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessStddevPopOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingParkingPaymentProcessStddevSampFields = {
  readonly __typename?: 'stops_database_parking_parking_payment_process_stddev_samp_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessStddevSampOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseParkingParkingPaymentProcessStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingParkingPaymentProcessStreamCursorValueInput = {
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_payment_process?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingParkingPaymentProcessSumFields = {
  readonly __typename?: 'stops_database_parking_parking_payment_process_sum_fields';
  readonly parking_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessSumOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
};

export type StopsDatabaseParkingParkingPaymentProcessUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseParkingParkingPaymentProcessBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingParkingPaymentProcessVarPopFields = {
  readonly __typename?: 'stops_database_parking_parking_payment_process_var_pop_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessVarPopOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingParkingPaymentProcessVarSampFields = {
  readonly __typename?: 'stops_database_parking_parking_payment_process_var_samp_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessVarSampOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingParkingPaymentProcessVarianceFields = {
  readonly __typename?: 'stops_database_parking_parking_payment_process_variance_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "parking_parking_payment_process" */
export type StopsDatabaseParkingParkingPaymentProcessVarianceOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** columns and relationships of "parking_parking_properties" */
export type StopsDatabaseParkingParkingProperties = {
  readonly __typename?: 'stops_database_parking_parking_properties';
  readonly parking_id: Scalars['bigint']['output'];
  readonly parking_properties_id: Scalars['bigint']['output'];
};

/** aggregated selection of "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesAggregate = {
  readonly __typename?: 'stops_database_parking_parking_properties_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseParkingParkingPropertiesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseParkingParkingProperties>;
};

/** aggregate fields of "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesAggregateFields = {
  readonly __typename?: 'stops_database_parking_parking_properties_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseParkingParkingPropertiesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseParkingParkingPropertiesMaxFields>;
  readonly min?: Maybe<StopsDatabaseParkingParkingPropertiesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseParkingParkingPropertiesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseParkingParkingPropertiesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseParkingParkingPropertiesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseParkingParkingPropertiesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseParkingParkingPropertiesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseParkingParkingPropertiesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseParkingParkingPropertiesVarianceFields>;
};


/** aggregate fields of "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPropertiesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseParkingParkingPropertiesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseParkingParkingPropertiesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseParkingParkingPropertiesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseParkingParkingPropertiesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseParkingParkingPropertiesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseParkingParkingPropertiesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseParkingParkingPropertiesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseParkingParkingPropertiesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseParkingParkingPropertiesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseParkingParkingPropertiesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseParkingParkingPropertiesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseParkingParkingPropertiesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingParkingPropertiesAvgFields = {
  readonly __typename?: 'stops_database_parking_parking_properties_avg_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesAvgOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
  readonly parking_properties_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "parking_parking_properties". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingParkingPropertiesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPropertiesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseParkingParkingPropertiesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPropertiesBoolExp>>;
  readonly parking_id?: InputMaybe<BigintComparisonExp>;
  readonly parking_properties_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "parking_parking_properties" */
export enum StopsDatabaseParkingParkingPropertiesConstraint {
  /** unique or primary key constraint on columns "parking_properties_id" */
  UkJ9vtca7vmg7ee8588wdseipvv = 'uk_j9vtca7vmg7ee8588wdseipvv'
}

/** input type for incrementing numeric columns in table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesIncInput = {
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_properties_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesInsertInput = {
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_properties_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingParkingPropertiesMaxFields = {
  readonly __typename?: 'stops_database_parking_parking_properties_max_fields';
  readonly parking_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_properties_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesMaxOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
  readonly parking_properties_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingParkingPropertiesMinFields = {
  readonly __typename?: 'stops_database_parking_parking_properties_min_fields';
  readonly parking_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_properties_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesMinOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
  readonly parking_properties_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesMutationResponse = {
  readonly __typename?: 'stops_database_parking_parking_properties_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseParkingParkingProperties>;
};

/** on_conflict condition type for table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesOnConflict = {
  readonly constraint: StopsDatabaseParkingParkingPropertiesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseParkingParkingPropertiesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseParkingParkingPropertiesBoolExp>;
};

/** Ordering options when selecting data from "parking_parking_properties". */
export type StopsDatabaseParkingParkingPropertiesOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
  readonly parking_properties_id?: InputMaybe<OrderBy>;
};

/** select columns of table "parking_parking_properties" */
export enum StopsDatabaseParkingParkingPropertiesSelectColumn {
  /** column name */
  ParkingId = 'parking_id',
  /** column name */
  ParkingPropertiesId = 'parking_properties_id'
}

/** input type for updating data in table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesSetInput = {
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_properties_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingParkingPropertiesStddevFields = {
  readonly __typename?: 'stops_database_parking_parking_properties_stddev_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesStddevOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
  readonly parking_properties_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingParkingPropertiesStddevPopFields = {
  readonly __typename?: 'stops_database_parking_parking_properties_stddev_pop_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesStddevPopOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
  readonly parking_properties_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingParkingPropertiesStddevSampFields = {
  readonly __typename?: 'stops_database_parking_parking_properties_stddev_samp_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesStddevSampOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
  readonly parking_properties_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseParkingParkingPropertiesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingParkingPropertiesStreamCursorValueInput = {
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_properties_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingParkingPropertiesSumFields = {
  readonly __typename?: 'stops_database_parking_parking_properties_sum_fields';
  readonly parking_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_properties_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesSumOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
  readonly parking_properties_id?: InputMaybe<OrderBy>;
};

/** update columns of table "parking_parking_properties" */
export enum StopsDatabaseParkingParkingPropertiesUpdateColumn {
  /** column name */
  ParkingId = 'parking_id',
  /** column name */
  ParkingPropertiesId = 'parking_properties_id'
}

export type StopsDatabaseParkingParkingPropertiesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseParkingParkingPropertiesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseParkingParkingPropertiesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseParkingParkingPropertiesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingParkingPropertiesVarPopFields = {
  readonly __typename?: 'stops_database_parking_parking_properties_var_pop_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesVarPopOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
  readonly parking_properties_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingParkingPropertiesVarSampFields = {
  readonly __typename?: 'stops_database_parking_parking_properties_var_samp_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesVarSampOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
  readonly parking_properties_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingParkingPropertiesVarianceFields = {
  readonly __typename?: 'stops_database_parking_parking_properties_variance_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "parking_parking_properties" */
export type StopsDatabaseParkingParkingPropertiesVarianceOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
  readonly parking_properties_id?: InputMaybe<OrderBy>;
};

/** columns and relationships of "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypes = {
  readonly __typename?: 'stops_database_parking_parking_vehicle_types';
  readonly parking_id: Scalars['bigint']['output'];
  readonly parking_vehicle_types?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesAggregate = {
  readonly __typename?: 'stops_database_parking_parking_vehicle_types_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseParkingParkingVehicleTypesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseParkingParkingVehicleTypes>;
};

/** aggregate fields of "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesAggregateFields = {
  readonly __typename?: 'stops_database_parking_parking_vehicle_types_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseParkingParkingVehicleTypesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseParkingParkingVehicleTypesMaxFields>;
  readonly min?: Maybe<StopsDatabaseParkingParkingVehicleTypesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseParkingParkingVehicleTypesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseParkingParkingVehicleTypesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseParkingParkingVehicleTypesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseParkingParkingVehicleTypesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseParkingParkingVehicleTypesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseParkingParkingVehicleTypesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseParkingParkingVehicleTypesVarianceFields>;
};


/** aggregate fields of "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingVehicleTypesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseParkingParkingVehicleTypesInsertInput>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingParkingVehicleTypesAvgFields = {
  readonly __typename?: 'stops_database_parking_parking_vehicle_types_avg_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesAvgOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "parking_parking_vehicle_types". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingParkingVehicleTypesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingVehicleTypesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingVehicleTypesBoolExp>>;
  readonly parking_id?: InputMaybe<BigintComparisonExp>;
  readonly parking_vehicle_types?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesIncInput = {
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesInsertInput = {
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_vehicle_types?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingParkingVehicleTypesMaxFields = {
  readonly __typename?: 'stops_database_parking_parking_vehicle_types_max_fields';
  readonly parking_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_vehicle_types?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesMaxOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
  readonly parking_vehicle_types?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingParkingVehicleTypesMinFields = {
  readonly __typename?: 'stops_database_parking_parking_vehicle_types_min_fields';
  readonly parking_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_vehicle_types?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesMinOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
  readonly parking_vehicle_types?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesMutationResponse = {
  readonly __typename?: 'stops_database_parking_parking_vehicle_types_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseParkingParkingVehicleTypes>;
};

/** Ordering options when selecting data from "parking_parking_vehicle_types". */
export type StopsDatabaseParkingParkingVehicleTypesOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
  readonly parking_vehicle_types?: InputMaybe<OrderBy>;
};

/** select columns of table "parking_parking_vehicle_types" */
export enum StopsDatabaseParkingParkingVehicleTypesSelectColumn {
  /** column name */
  ParkingId = 'parking_id',
  /** column name */
  ParkingVehicleTypes = 'parking_vehicle_types'
}

/** input type for updating data in table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesSetInput = {
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_vehicle_types?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingParkingVehicleTypesStddevFields = {
  readonly __typename?: 'stops_database_parking_parking_vehicle_types_stddev_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesStddevOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingParkingVehicleTypesStddevPopFields = {
  readonly __typename?: 'stops_database_parking_parking_vehicle_types_stddev_pop_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesStddevPopOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingParkingVehicleTypesStddevSampFields = {
  readonly __typename?: 'stops_database_parking_parking_vehicle_types_stddev_samp_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesStddevSampOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseParkingParkingVehicleTypesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingParkingVehicleTypesStreamCursorValueInput = {
  readonly parking_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_vehicle_types?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingParkingVehicleTypesSumFields = {
  readonly __typename?: 'stops_database_parking_parking_vehicle_types_sum_fields';
  readonly parking_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesSumOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
};

export type StopsDatabaseParkingParkingVehicleTypesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseParkingParkingVehicleTypesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingParkingVehicleTypesVarPopFields = {
  readonly __typename?: 'stops_database_parking_parking_vehicle_types_var_pop_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesVarPopOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingParkingVehicleTypesVarSampFields = {
  readonly __typename?: 'stops_database_parking_parking_vehicle_types_var_samp_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesVarSampOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingParkingVehicleTypesVarianceFields = {
  readonly __typename?: 'stops_database_parking_parking_vehicle_types_variance_fields';
  readonly parking_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "parking_parking_vehicle_types" */
export type StopsDatabaseParkingParkingVehicleTypesVarianceOrderBy = {
  readonly parking_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: parking */
export type StopsDatabaseParkingPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** columns and relationships of "parking_properties" */
export type StopsDatabaseParkingProperties = {
  readonly __typename?: 'stops_database_parking_properties';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id: Scalars['bigint']['output'];
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "parking_properties" */
export type StopsDatabaseParkingPropertiesAggregate = {
  readonly __typename?: 'stops_database_parking_properties_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseParkingPropertiesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseParkingProperties>;
};

/** aggregate fields of "parking_properties" */
export type StopsDatabaseParkingPropertiesAggregateFields = {
  readonly __typename?: 'stops_database_parking_properties_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseParkingPropertiesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseParkingPropertiesMaxFields>;
  readonly min?: Maybe<StopsDatabaseParkingPropertiesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseParkingPropertiesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseParkingPropertiesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseParkingPropertiesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseParkingPropertiesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseParkingPropertiesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseParkingPropertiesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseParkingPropertiesVarianceFields>;
};


/** aggregate fields of "parking_properties" */
export type StopsDatabaseParkingPropertiesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingPropertiesAvgFields = {
  readonly __typename?: 'stops_database_parking_properties_avg_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "parking_properties". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingPropertiesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseParkingPropertiesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesBoolExp>>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "parking_properties" */
export enum StopsDatabaseParkingPropertiesConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  ParkingPropertiesNetexIdVersionConstraint = 'parking_properties_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  ParkingPropertiesPkey = 'parking_properties_pkey'
}

/** input type for incrementing numeric columns in table "parking_properties" */
export type StopsDatabaseParkingPropertiesIncInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "parking_properties" */
export type StopsDatabaseParkingPropertiesInsertInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingPropertiesMaxFields = {
  readonly __typename?: 'stops_database_parking_properties_max_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingPropertiesMinFields = {
  readonly __typename?: 'stops_database_parking_properties_min_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "parking_properties" */
export type StopsDatabaseParkingPropertiesMutationResponse = {
  readonly __typename?: 'stops_database_parking_properties_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseParkingProperties>;
};

/** input type for inserting object relation for remote table "parking_properties" */
export type StopsDatabaseParkingPropertiesObjRelInsertInput = {
  readonly data: StopsDatabaseParkingPropertiesInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseParkingPropertiesOnConflict>;
};

/** on_conflict condition type for table "parking_properties" */
export type StopsDatabaseParkingPropertiesOnConflict = {
  readonly constraint: StopsDatabaseParkingPropertiesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseParkingPropertiesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseParkingPropertiesBoolExp>;
};

/** Ordering options when selecting data from "parking_properties". */
export type StopsDatabaseParkingPropertiesOrderBy = {
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
};

/** columns and relationships of "parking_properties_parking_user_types" */
export type StopsDatabaseParkingPropertiesParkingUserTypes = {
  readonly __typename?: 'stops_database_parking_properties_parking_user_types';
  readonly parking_properties_id: Scalars['bigint']['output'];
  readonly parking_user_types?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "parking_properties_parking_user_types" */
export type StopsDatabaseParkingPropertiesParkingUserTypesAggregate = {
  readonly __typename?: 'stops_database_parking_properties_parking_user_types_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseParkingPropertiesParkingUserTypes>;
};

/** aggregate fields of "parking_properties_parking_user_types" */
export type StopsDatabaseParkingPropertiesParkingUserTypesAggregateFields = {
  readonly __typename?: 'stops_database_parking_properties_parking_user_types_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesMaxFields>;
  readonly min?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesVarianceFields>;
};


/** aggregate fields of "parking_properties_parking_user_types" */
export type StopsDatabaseParkingPropertiesParkingUserTypesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesParkingUserTypesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingPropertiesParkingUserTypesAvgFields = {
  readonly __typename?: 'stops_database_parking_properties_parking_user_types_avg_fields';
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "parking_properties_parking_user_types". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingPropertiesParkingUserTypesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesParkingUserTypesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseParkingPropertiesParkingUserTypesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesParkingUserTypesBoolExp>>;
  readonly parking_properties_id?: InputMaybe<BigintComparisonExp>;
  readonly parking_user_types?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "parking_properties_parking_user_types" */
export type StopsDatabaseParkingPropertiesParkingUserTypesIncInput = {
  readonly parking_properties_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "parking_properties_parking_user_types" */
export type StopsDatabaseParkingPropertiesParkingUserTypesInsertInput = {
  readonly parking_properties_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_user_types?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingPropertiesParkingUserTypesMaxFields = {
  readonly __typename?: 'stops_database_parking_properties_parking_user_types_max_fields';
  readonly parking_properties_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_user_types?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingPropertiesParkingUserTypesMinFields = {
  readonly __typename?: 'stops_database_parking_properties_parking_user_types_min_fields';
  readonly parking_properties_id?: Maybe<Scalars['bigint']['output']>;
  readonly parking_user_types?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "parking_properties_parking_user_types" */
export type StopsDatabaseParkingPropertiesParkingUserTypesMutationResponse = {
  readonly __typename?: 'stops_database_parking_properties_parking_user_types_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseParkingPropertiesParkingUserTypes>;
};

/** Ordering options when selecting data from "parking_properties_parking_user_types". */
export type StopsDatabaseParkingPropertiesParkingUserTypesOrderBy = {
  readonly parking_properties_id?: InputMaybe<OrderBy>;
  readonly parking_user_types?: InputMaybe<OrderBy>;
};

/** select columns of table "parking_properties_parking_user_types" */
export enum StopsDatabaseParkingPropertiesParkingUserTypesSelectColumn {
  /** column name */
  ParkingPropertiesId = 'parking_properties_id',
  /** column name */
  ParkingUserTypes = 'parking_user_types'
}

/** input type for updating data in table "parking_properties_parking_user_types" */
export type StopsDatabaseParkingPropertiesParkingUserTypesSetInput = {
  readonly parking_properties_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_user_types?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingPropertiesParkingUserTypesStddevFields = {
  readonly __typename?: 'stops_database_parking_properties_parking_user_types_stddev_fields';
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingPropertiesParkingUserTypesStddevPopFields = {
  readonly __typename?: 'stops_database_parking_properties_parking_user_types_stddev_pop_fields';
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingPropertiesParkingUserTypesStddevSampFields = {
  readonly __typename?: 'stops_database_parking_properties_parking_user_types_stddev_samp_fields';
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "parking_properties_parking_user_types" */
export type StopsDatabaseParkingPropertiesParkingUserTypesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseParkingPropertiesParkingUserTypesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingPropertiesParkingUserTypesStreamCursorValueInput = {
  readonly parking_properties_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parking_user_types?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingPropertiesParkingUserTypesSumFields = {
  readonly __typename?: 'stops_database_parking_properties_parking_user_types_sum_fields';
  readonly parking_properties_id?: Maybe<Scalars['bigint']['output']>;
};

export type StopsDatabaseParkingPropertiesParkingUserTypesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseParkingPropertiesParkingUserTypesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseParkingPropertiesParkingUserTypesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseParkingPropertiesParkingUserTypesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingPropertiesParkingUserTypesVarPopFields = {
  readonly __typename?: 'stops_database_parking_properties_parking_user_types_var_pop_fields';
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingPropertiesParkingUserTypesVarSampFields = {
  readonly __typename?: 'stops_database_parking_properties_parking_user_types_var_samp_fields';
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingPropertiesParkingUserTypesVarianceFields = {
  readonly __typename?: 'stops_database_parking_properties_parking_user_types_variance_fields';
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
};

/** primary key columns input for table: parking_properties */
export type StopsDatabaseParkingPropertiesPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "parking_properties" */
export enum StopsDatabaseParkingPropertiesSelectColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

/** input type for updating data in table "parking_properties" */
export type StopsDatabaseParkingPropertiesSetInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "parking_properties_spaces" */
export type StopsDatabaseParkingPropertiesSpaces = {
  readonly __typename?: 'stops_database_parking_properties_spaces';
  readonly parking_properties_id: Scalars['bigint']['output'];
  readonly spaces_id: Scalars['bigint']['output'];
};

/** aggregated selection of "parking_properties_spaces" */
export type StopsDatabaseParkingPropertiesSpacesAggregate = {
  readonly __typename?: 'stops_database_parking_properties_spaces_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseParkingPropertiesSpacesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseParkingPropertiesSpaces>;
};

/** aggregate fields of "parking_properties_spaces" */
export type StopsDatabaseParkingPropertiesSpacesAggregateFields = {
  readonly __typename?: 'stops_database_parking_properties_spaces_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseParkingPropertiesSpacesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseParkingPropertiesSpacesMaxFields>;
  readonly min?: Maybe<StopsDatabaseParkingPropertiesSpacesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseParkingPropertiesSpacesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseParkingPropertiesSpacesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseParkingPropertiesSpacesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseParkingPropertiesSpacesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseParkingPropertiesSpacesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseParkingPropertiesSpacesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseParkingPropertiesSpacesVarianceFields>;
};


/** aggregate fields of "parking_properties_spaces" */
export type StopsDatabaseParkingPropertiesSpacesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesSpacesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseParkingPropertiesSpacesAvgFields = {
  readonly __typename?: 'stops_database_parking_properties_spaces_avg_fields';
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
  readonly spaces_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "parking_properties_spaces". All fields are combined with a logical 'AND'. */
export type StopsDatabaseParkingPropertiesSpacesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesSpacesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseParkingPropertiesSpacesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesSpacesBoolExp>>;
  readonly parking_properties_id?: InputMaybe<BigintComparisonExp>;
  readonly spaces_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "parking_properties_spaces" */
export enum StopsDatabaseParkingPropertiesSpacesConstraint {
  /** unique or primary key constraint on columns "spaces_id" */
  Uk_2rhu1u10q5achulke0kwg4e0o = 'uk_2rhu1u10q5achulke0kwg4e0o'
}

/** input type for incrementing numeric columns in table "parking_properties_spaces" */
export type StopsDatabaseParkingPropertiesSpacesIncInput = {
  readonly parking_properties_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly spaces_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "parking_properties_spaces" */
export type StopsDatabaseParkingPropertiesSpacesInsertInput = {
  readonly parking_properties_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly spaces_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseParkingPropertiesSpacesMaxFields = {
  readonly __typename?: 'stops_database_parking_properties_spaces_max_fields';
  readonly parking_properties_id?: Maybe<Scalars['bigint']['output']>;
  readonly spaces_id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseParkingPropertiesSpacesMinFields = {
  readonly __typename?: 'stops_database_parking_properties_spaces_min_fields';
  readonly parking_properties_id?: Maybe<Scalars['bigint']['output']>;
  readonly spaces_id?: Maybe<Scalars['bigint']['output']>;
};

/** response of any mutation on the table "parking_properties_spaces" */
export type StopsDatabaseParkingPropertiesSpacesMutationResponse = {
  readonly __typename?: 'stops_database_parking_properties_spaces_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseParkingPropertiesSpaces>;
};

/** on_conflict condition type for table "parking_properties_spaces" */
export type StopsDatabaseParkingPropertiesSpacesOnConflict = {
  readonly constraint: StopsDatabaseParkingPropertiesSpacesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseParkingPropertiesSpacesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseParkingPropertiesSpacesBoolExp>;
};

/** Ordering options when selecting data from "parking_properties_spaces". */
export type StopsDatabaseParkingPropertiesSpacesOrderBy = {
  readonly parking_properties_id?: InputMaybe<OrderBy>;
  readonly spaces_id?: InputMaybe<OrderBy>;
};

/** select columns of table "parking_properties_spaces" */
export enum StopsDatabaseParkingPropertiesSpacesSelectColumn {
  /** column name */
  ParkingPropertiesId = 'parking_properties_id',
  /** column name */
  SpacesId = 'spaces_id'
}

/** input type for updating data in table "parking_properties_spaces" */
export type StopsDatabaseParkingPropertiesSpacesSetInput = {
  readonly parking_properties_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly spaces_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingPropertiesSpacesStddevFields = {
  readonly __typename?: 'stops_database_parking_properties_spaces_stddev_fields';
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
  readonly spaces_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingPropertiesSpacesStddevPopFields = {
  readonly __typename?: 'stops_database_parking_properties_spaces_stddev_pop_fields';
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
  readonly spaces_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingPropertiesSpacesStddevSampFields = {
  readonly __typename?: 'stops_database_parking_properties_spaces_stddev_samp_fields';
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
  readonly spaces_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "parking_properties_spaces" */
export type StopsDatabaseParkingPropertiesSpacesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseParkingPropertiesSpacesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingPropertiesSpacesStreamCursorValueInput = {
  readonly parking_properties_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly spaces_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingPropertiesSpacesSumFields = {
  readonly __typename?: 'stops_database_parking_properties_spaces_sum_fields';
  readonly parking_properties_id?: Maybe<Scalars['bigint']['output']>;
  readonly spaces_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "parking_properties_spaces" */
export enum StopsDatabaseParkingPropertiesSpacesUpdateColumn {
  /** column name */
  ParkingPropertiesId = 'parking_properties_id',
  /** column name */
  SpacesId = 'spaces_id'
}

export type StopsDatabaseParkingPropertiesSpacesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseParkingPropertiesSpacesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseParkingPropertiesSpacesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseParkingPropertiesSpacesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingPropertiesSpacesVarPopFields = {
  readonly __typename?: 'stops_database_parking_properties_spaces_var_pop_fields';
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
  readonly spaces_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingPropertiesSpacesVarSampFields = {
  readonly __typename?: 'stops_database_parking_properties_spaces_var_samp_fields';
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
  readonly spaces_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingPropertiesSpacesVarianceFields = {
  readonly __typename?: 'stops_database_parking_properties_spaces_variance_fields';
  readonly parking_properties_id?: Maybe<Scalars['Float']['output']>;
  readonly spaces_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingPropertiesStddevFields = {
  readonly __typename?: 'stops_database_parking_properties_stddev_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingPropertiesStddevPopFields = {
  readonly __typename?: 'stops_database_parking_properties_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingPropertiesStddevSampFields = {
  readonly __typename?: 'stops_database_parking_properties_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "parking_properties" */
export type StopsDatabaseParkingPropertiesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseParkingPropertiesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingPropertiesStreamCursorValueInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingPropertiesSumFields = {
  readonly __typename?: 'stops_database_parking_properties_sum_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "parking_properties" */
export enum StopsDatabaseParkingPropertiesUpdateColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

export type StopsDatabaseParkingPropertiesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseParkingPropertiesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseParkingPropertiesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseParkingPropertiesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingPropertiesVarPopFields = {
  readonly __typename?: 'stops_database_parking_properties_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingPropertiesVarSampFields = {
  readonly __typename?: 'stops_database_parking_properties_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingPropertiesVarianceFields = {
  readonly __typename?: 'stops_database_parking_properties_variance_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** select columns of table "parking" */
export enum StopsDatabaseParkingSelectColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  BookingUrl = 'booking_url',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FreeParkingOutOfHours = 'free_parking_out_of_hours',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  NumberOfParkingLevels = 'number_of_parking_levels',
  /** column name */
  OvernightParkingPermitted = 'overnight_parking_permitted',
  /** column name */
  ParentSiteRef = 'parent_site_ref',
  /** column name */
  ParentSiteRefVersion = 'parent_site_ref_version',
  /** column name */
  ParkingLayout = 'parking_layout',
  /** column name */
  ParkingReservation = 'parking_reservation',
  /** column name */
  ParkingType = 'parking_type',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrincipalCapacity = 'principal_capacity',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ProhibitedForHazardousMaterials = 'prohibited_for_hazardous_materials',
  /** column name */
  RealTimeOccupancyAvailable = 'real_time_occupancy_available',
  /** column name */
  RechargingAvailable = 'recharging_available',
  /** column name */
  Secure = 'secure',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TopographicPlaceId = 'topographic_place_id',
  /** column name */
  TotalCapacity = 'total_capacity',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

/** input type for updating data in table "parking" */
export type StopsDatabaseParkingSetInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  readonly booking_url?: InputMaybe<Scalars['String']['input']>;
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly free_parking_out_of_hours?: InputMaybe<Scalars['Boolean']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly number_of_parking_levels?: InputMaybe<Scalars['numeric']['input']>;
  readonly overnight_parking_permitted?: InputMaybe<Scalars['Boolean']['input']>;
  readonly parent_site_ref?: InputMaybe<Scalars['String']['input']>;
  readonly parent_site_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly parking_layout?: InputMaybe<Scalars['Int']['input']>;
  readonly parking_reservation?: InputMaybe<Scalars['Int']['input']>;
  readonly parking_type?: InputMaybe<Scalars['String']['input']>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly principal_capacity?: InputMaybe<Scalars['numeric']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly prohibited_for_hazardous_materials?: InputMaybe<Scalars['Boolean']['input']>;
  readonly real_time_occupancy_available?: InputMaybe<Scalars['Boolean']['input']>;
  readonly recharging_available?: InputMaybe<Scalars['Boolean']['input']>;
  readonly secure?: InputMaybe<Scalars['Boolean']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly topographic_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly total_capacity?: InputMaybe<Scalars['numeric']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseParkingStddevFields = {
  readonly __typename?: 'stops_database_parking_stddev_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly number_of_parking_levels?: Maybe<Scalars['Float']['output']>;
  readonly parking_layout?: Maybe<Scalars['Float']['output']>;
  readonly parking_reservation?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly principal_capacity?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
  readonly total_capacity?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseParkingStddevPopFields = {
  readonly __typename?: 'stops_database_parking_stddev_pop_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly number_of_parking_levels?: Maybe<Scalars['Float']['output']>;
  readonly parking_layout?: Maybe<Scalars['Float']['output']>;
  readonly parking_reservation?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly principal_capacity?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
  readonly total_capacity?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseParkingStddevSampFields = {
  readonly __typename?: 'stops_database_parking_stddev_samp_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly number_of_parking_levels?: Maybe<Scalars['Float']['output']>;
  readonly parking_layout?: Maybe<Scalars['Float']['output']>;
  readonly parking_reservation?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly principal_capacity?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
  readonly total_capacity?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "parking" */
export type StopsDatabaseParkingStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseParkingStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseParkingStreamCursorValueInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  readonly booking_url?: InputMaybe<Scalars['String']['input']>;
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly free_parking_out_of_hours?: InputMaybe<Scalars['Boolean']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly number_of_parking_levels?: InputMaybe<Scalars['numeric']['input']>;
  readonly overnight_parking_permitted?: InputMaybe<Scalars['Boolean']['input']>;
  readonly parent_site_ref?: InputMaybe<Scalars['String']['input']>;
  readonly parent_site_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly parking_layout?: InputMaybe<Scalars['Int']['input']>;
  readonly parking_reservation?: InputMaybe<Scalars['Int']['input']>;
  readonly parking_type?: InputMaybe<Scalars['String']['input']>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly principal_capacity?: InputMaybe<Scalars['numeric']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly prohibited_for_hazardous_materials?: InputMaybe<Scalars['Boolean']['input']>;
  readonly real_time_occupancy_available?: InputMaybe<Scalars['Boolean']['input']>;
  readonly recharging_available?: InputMaybe<Scalars['Boolean']['input']>;
  readonly secure?: InputMaybe<Scalars['Boolean']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly topographic_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly total_capacity?: InputMaybe<Scalars['numeric']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseParkingSumFields = {
  readonly __typename?: 'stops_database_parking_sum_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly number_of_parking_levels?: Maybe<Scalars['numeric']['output']>;
  readonly parking_layout?: Maybe<Scalars['Int']['output']>;
  readonly parking_reservation?: Maybe<Scalars['Int']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly principal_capacity?: Maybe<Scalars['numeric']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly total_capacity?: Maybe<Scalars['numeric']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "parking" */
export enum StopsDatabaseParkingUpdateColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  BookingUrl = 'booking_url',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FreeParkingOutOfHours = 'free_parking_out_of_hours',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  NumberOfParkingLevels = 'number_of_parking_levels',
  /** column name */
  OvernightParkingPermitted = 'overnight_parking_permitted',
  /** column name */
  ParentSiteRef = 'parent_site_ref',
  /** column name */
  ParentSiteRefVersion = 'parent_site_ref_version',
  /** column name */
  ParkingLayout = 'parking_layout',
  /** column name */
  ParkingReservation = 'parking_reservation',
  /** column name */
  ParkingType = 'parking_type',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrincipalCapacity = 'principal_capacity',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ProhibitedForHazardousMaterials = 'prohibited_for_hazardous_materials',
  /** column name */
  RealTimeOccupancyAvailable = 'real_time_occupancy_available',
  /** column name */
  RechargingAvailable = 'recharging_available',
  /** column name */
  Secure = 'secure',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TopographicPlaceId = 'topographic_place_id',
  /** column name */
  TotalCapacity = 'total_capacity',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

export type StopsDatabaseParkingUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseParkingIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseParkingSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseParkingBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseParkingVarPopFields = {
  readonly __typename?: 'stops_database_parking_var_pop_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly number_of_parking_levels?: Maybe<Scalars['Float']['output']>;
  readonly parking_layout?: Maybe<Scalars['Float']['output']>;
  readonly parking_reservation?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly principal_capacity?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
  readonly total_capacity?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseParkingVarSampFields = {
  readonly __typename?: 'stops_database_parking_var_samp_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly number_of_parking_levels?: Maybe<Scalars['Float']['output']>;
  readonly parking_layout?: Maybe<Scalars['Float']['output']>;
  readonly parking_reservation?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly principal_capacity?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
  readonly total_capacity?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseParkingVarianceFields = {
  readonly __typename?: 'stops_database_parking_variance_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly number_of_parking_levels?: Maybe<Scalars['Float']['output']>;
  readonly parking_layout?: Maybe<Scalars['Float']['output']>;
  readonly parking_reservation?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly principal_capacity?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
  readonly total_capacity?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "path_junction" */
export type StopsDatabasePathJunction = {
  readonly __typename?: 'stops_database_path_junction';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id: Scalars['bigint']['output'];
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "path_junction" */
export type StopsDatabasePathJunctionAggregate = {
  readonly __typename?: 'stops_database_path_junction_aggregate';
  readonly aggregate?: Maybe<StopsDatabasePathJunctionAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabasePathJunction>;
};

/** aggregate fields of "path_junction" */
export type StopsDatabasePathJunctionAggregateFields = {
  readonly __typename?: 'stops_database_path_junction_aggregate_fields';
  readonly avg?: Maybe<StopsDatabasePathJunctionAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabasePathJunctionMaxFields>;
  readonly min?: Maybe<StopsDatabasePathJunctionMinFields>;
  readonly stddev?: Maybe<StopsDatabasePathJunctionStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabasePathJunctionStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabasePathJunctionStddevSampFields>;
  readonly sum?: Maybe<StopsDatabasePathJunctionSumFields>;
  readonly var_pop?: Maybe<StopsDatabasePathJunctionVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabasePathJunctionVarSampFields>;
  readonly variance?: Maybe<StopsDatabasePathJunctionVarianceFields>;
};


/** aggregate fields of "path_junction" */
export type StopsDatabasePathJunctionAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabasePathJunctionSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabasePathJunctionAvgFields = {
  readonly __typename?: 'stops_database_path_junction_avg_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "path_junction". All fields are combined with a logical 'AND'. */
export type StopsDatabasePathJunctionBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabasePathJunctionBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabasePathJunctionBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabasePathJunctionBoolExp>>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "path_junction" */
export enum StopsDatabasePathJunctionConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  PathJunctionNetexIdVersionConstraint = 'path_junction_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  PathJunctionPkey = 'path_junction_pkey'
}

/** input type for incrementing numeric columns in table "path_junction" */
export type StopsDatabasePathJunctionIncInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "path_junction" */
export type StopsDatabasePathJunctionInsertInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "path_junction_key_values" */
export type StopsDatabasePathJunctionKeyValues = {
  readonly __typename?: 'stops_database_path_junction_key_values';
  readonly key_values_id: Scalars['bigint']['output'];
  readonly key_values_key: Scalars['String']['output'];
  readonly path_junction_id: Scalars['bigint']['output'];
};

/** aggregated selection of "path_junction_key_values" */
export type StopsDatabasePathJunctionKeyValuesAggregate = {
  readonly __typename?: 'stops_database_path_junction_key_values_aggregate';
  readonly aggregate?: Maybe<StopsDatabasePathJunctionKeyValuesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabasePathJunctionKeyValues>;
};

/** aggregate fields of "path_junction_key_values" */
export type StopsDatabasePathJunctionKeyValuesAggregateFields = {
  readonly __typename?: 'stops_database_path_junction_key_values_aggregate_fields';
  readonly avg?: Maybe<StopsDatabasePathJunctionKeyValuesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabasePathJunctionKeyValuesMaxFields>;
  readonly min?: Maybe<StopsDatabasePathJunctionKeyValuesMinFields>;
  readonly stddev?: Maybe<StopsDatabasePathJunctionKeyValuesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabasePathJunctionKeyValuesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabasePathJunctionKeyValuesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabasePathJunctionKeyValuesSumFields>;
  readonly var_pop?: Maybe<StopsDatabasePathJunctionKeyValuesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabasePathJunctionKeyValuesVarSampFields>;
  readonly variance?: Maybe<StopsDatabasePathJunctionKeyValuesVarianceFields>;
};


/** aggregate fields of "path_junction_key_values" */
export type StopsDatabasePathJunctionKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabasePathJunctionKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabasePathJunctionKeyValuesAvgFields = {
  readonly __typename?: 'stops_database_path_junction_key_values_avg_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly path_junction_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "path_junction_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabasePathJunctionKeyValuesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabasePathJunctionKeyValuesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabasePathJunctionKeyValuesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabasePathJunctionKeyValuesBoolExp>>;
  readonly key_values_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_key?: InputMaybe<StringComparisonExp>;
  readonly path_junction_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "path_junction_key_values" */
export enum StopsDatabasePathJunctionKeyValuesConstraint {
  /** unique or primary key constraint on columns "key_values_key", "path_junction_id" */
  PathJunctionKeyValuesPkey = 'path_junction_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  Uk_8au15celles62v9ug5bvq2t4x = 'uk_8au15celles62v9ug5bvq2t4x'
}

/** input type for incrementing numeric columns in table "path_junction_key_values" */
export type StopsDatabasePathJunctionKeyValuesIncInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly path_junction_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "path_junction_key_values" */
export type StopsDatabasePathJunctionKeyValuesInsertInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly path_junction_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabasePathJunctionKeyValuesMaxFields = {
  readonly __typename?: 'stops_database_path_junction_key_values_max_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
  readonly path_junction_id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type StopsDatabasePathJunctionKeyValuesMinFields = {
  readonly __typename?: 'stops_database_path_junction_key_values_min_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
  readonly path_junction_id?: Maybe<Scalars['bigint']['output']>;
};

/** response of any mutation on the table "path_junction_key_values" */
export type StopsDatabasePathJunctionKeyValuesMutationResponse = {
  readonly __typename?: 'stops_database_path_junction_key_values_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabasePathJunctionKeyValues>;
};

/** on_conflict condition type for table "path_junction_key_values" */
export type StopsDatabasePathJunctionKeyValuesOnConflict = {
  readonly constraint: StopsDatabasePathJunctionKeyValuesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabasePathJunctionKeyValuesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabasePathJunctionKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "path_junction_key_values". */
export type StopsDatabasePathJunctionKeyValuesOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly path_junction_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: path_junction_key_values */
export type StopsDatabasePathJunctionKeyValuesPkColumnsInput = {
  readonly key_values_key: Scalars['String']['input'];
  readonly path_junction_id: Scalars['bigint']['input'];
};

/** select columns of table "path_junction_key_values" */
export enum StopsDatabasePathJunctionKeyValuesSelectColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  PathJunctionId = 'path_junction_id'
}

/** input type for updating data in table "path_junction_key_values" */
export type StopsDatabasePathJunctionKeyValuesSetInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly path_junction_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabasePathJunctionKeyValuesStddevFields = {
  readonly __typename?: 'stops_database_path_junction_key_values_stddev_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly path_junction_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabasePathJunctionKeyValuesStddevPopFields = {
  readonly __typename?: 'stops_database_path_junction_key_values_stddev_pop_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly path_junction_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabasePathJunctionKeyValuesStddevSampFields = {
  readonly __typename?: 'stops_database_path_junction_key_values_stddev_samp_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly path_junction_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "path_junction_key_values" */
export type StopsDatabasePathJunctionKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabasePathJunctionKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabasePathJunctionKeyValuesStreamCursorValueInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly path_junction_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabasePathJunctionKeyValuesSumFields = {
  readonly __typename?: 'stops_database_path_junction_key_values_sum_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly path_junction_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "path_junction_key_values" */
export enum StopsDatabasePathJunctionKeyValuesUpdateColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  PathJunctionId = 'path_junction_id'
}

export type StopsDatabasePathJunctionKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabasePathJunctionKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabasePathJunctionKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabasePathJunctionKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabasePathJunctionKeyValuesVarPopFields = {
  readonly __typename?: 'stops_database_path_junction_key_values_var_pop_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly path_junction_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabasePathJunctionKeyValuesVarSampFields = {
  readonly __typename?: 'stops_database_path_junction_key_values_var_samp_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly path_junction_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabasePathJunctionKeyValuesVarianceFields = {
  readonly __typename?: 'stops_database_path_junction_key_values_variance_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly path_junction_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate max on columns */
export type StopsDatabasePathJunctionMaxFields = {
  readonly __typename?: 'stops_database_path_junction_max_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabasePathJunctionMinFields = {
  readonly __typename?: 'stops_database_path_junction_min_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "path_junction" */
export type StopsDatabasePathJunctionMutationResponse = {
  readonly __typename?: 'stops_database_path_junction_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabasePathJunction>;
};

/** on_conflict condition type for table "path_junction" */
export type StopsDatabasePathJunctionOnConflict = {
  readonly constraint: StopsDatabasePathJunctionConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabasePathJunctionUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabasePathJunctionBoolExp>;
};

/** Ordering options when selecting data from "path_junction". */
export type StopsDatabasePathJunctionOrderBy = {
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: path_junction */
export type StopsDatabasePathJunctionPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "path_junction" */
export enum StopsDatabasePathJunctionSelectColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

/** input type for updating data in table "path_junction" */
export type StopsDatabasePathJunctionSetInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabasePathJunctionStddevFields = {
  readonly __typename?: 'stops_database_path_junction_stddev_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabasePathJunctionStddevPopFields = {
  readonly __typename?: 'stops_database_path_junction_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabasePathJunctionStddevSampFields = {
  readonly __typename?: 'stops_database_path_junction_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "path_junction" */
export type StopsDatabasePathJunctionStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabasePathJunctionStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabasePathJunctionStreamCursorValueInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabasePathJunctionSumFields = {
  readonly __typename?: 'stops_database_path_junction_sum_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "path_junction" */
export enum StopsDatabasePathJunctionUpdateColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

export type StopsDatabasePathJunctionUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabasePathJunctionIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabasePathJunctionSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabasePathJunctionBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabasePathJunctionVarPopFields = {
  readonly __typename?: 'stops_database_path_junction_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabasePathJunctionVarSampFields = {
  readonly __typename?: 'stops_database_path_junction_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabasePathJunctionVarianceFields = {
  readonly __typename?: 'stops_database_path_junction_variance_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "path_link" */
export type StopsDatabasePathLink = {
  readonly __typename?: 'stops_database_path_link';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly default_duration?: Maybe<Scalars['bytea']['output']>;
  readonly frequent_traveller_duration?: Maybe<Scalars['bytea']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly from_id: Scalars['bigint']['output'];
  readonly id: Scalars['bigint']['output'];
  readonly line_string?: Maybe<Scalars['geometry']['output']>;
  readonly mobility_restricted_traveller_duration?: Maybe<Scalars['bytea']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly occasional_traveller_duration?: Maybe<Scalars['bytea']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly to_id: Scalars['bigint']['output'];
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "path_link" */
export type StopsDatabasePathLinkAggregate = {
  readonly __typename?: 'stops_database_path_link_aggregate';
  readonly aggregate?: Maybe<StopsDatabasePathLinkAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabasePathLink>;
};

/** aggregate fields of "path_link" */
export type StopsDatabasePathLinkAggregateFields = {
  readonly __typename?: 'stops_database_path_link_aggregate_fields';
  readonly avg?: Maybe<StopsDatabasePathLinkAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabasePathLinkMaxFields>;
  readonly min?: Maybe<StopsDatabasePathLinkMinFields>;
  readonly stddev?: Maybe<StopsDatabasePathLinkStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabasePathLinkStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabasePathLinkStddevSampFields>;
  readonly sum?: Maybe<StopsDatabasePathLinkSumFields>;
  readonly var_pop?: Maybe<StopsDatabasePathLinkVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabasePathLinkVarSampFields>;
  readonly variance?: Maybe<StopsDatabasePathLinkVarianceFields>;
};


/** aggregate fields of "path_link" */
export type StopsDatabasePathLinkAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabasePathLinkAvgFields = {
  readonly __typename?: 'stops_database_path_link_avg_fields';
  readonly from_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly to_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "path_link". All fields are combined with a logical 'AND'. */
export type StopsDatabasePathLinkBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabasePathLinkBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkBoolExp>>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly default_duration?: InputMaybe<ByteaComparisonExp>;
  readonly frequent_traveller_duration?: InputMaybe<ByteaComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly from_id?: InputMaybe<BigintComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly line_string?: InputMaybe<GeometryComparisonExp>;
  readonly mobility_restricted_traveller_duration?: InputMaybe<ByteaComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly occasional_traveller_duration?: InputMaybe<ByteaComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly to_id?: InputMaybe<BigintComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "path_link" */
export enum StopsDatabasePathLinkConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  PathLinkNetexIdVersionConstraint = 'path_link_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  PathLinkPkey = 'path_link_pkey'
}

/** columns and relationships of "path_link_end" */
export type StopsDatabasePathLinkEnd = {
  readonly __typename?: 'stops_database_path_link_end';
  readonly id: Scalars['bigint']['output'];
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly path_junction_id?: Maybe<Scalars['bigint']['output']>;
  readonly place_ref?: Maybe<Scalars['String']['output']>;
  readonly place_version?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "path_link_end" */
export type StopsDatabasePathLinkEndAggregate = {
  readonly __typename?: 'stops_database_path_link_end_aggregate';
  readonly aggregate?: Maybe<StopsDatabasePathLinkEndAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabasePathLinkEnd>;
};

/** aggregate fields of "path_link_end" */
export type StopsDatabasePathLinkEndAggregateFields = {
  readonly __typename?: 'stops_database_path_link_end_aggregate_fields';
  readonly avg?: Maybe<StopsDatabasePathLinkEndAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabasePathLinkEndMaxFields>;
  readonly min?: Maybe<StopsDatabasePathLinkEndMinFields>;
  readonly stddev?: Maybe<StopsDatabasePathLinkEndStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabasePathLinkEndStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabasePathLinkEndStddevSampFields>;
  readonly sum?: Maybe<StopsDatabasePathLinkEndSumFields>;
  readonly var_pop?: Maybe<StopsDatabasePathLinkEndVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabasePathLinkEndVarSampFields>;
  readonly variance?: Maybe<StopsDatabasePathLinkEndVarianceFields>;
};


/** aggregate fields of "path_link_end" */
export type StopsDatabasePathLinkEndAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkEndSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabasePathLinkEndAvgFields = {
  readonly __typename?: 'stops_database_path_link_end_avg_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly path_junction_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "path_link_end". All fields are combined with a logical 'AND'. */
export type StopsDatabasePathLinkEndBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkEndBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabasePathLinkEndBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkEndBoolExp>>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly path_junction_id?: InputMaybe<BigintComparisonExp>;
  readonly place_ref?: InputMaybe<StringComparisonExp>;
  readonly place_version?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "path_link_end" */
export enum StopsDatabasePathLinkEndConstraint {
  /** unique or primary key constraint on columns "netex_id" */
  PathLinkEndNetexIdConstraint = 'path_link_end_netex_id_constraint',
  /** unique or primary key constraint on columns "id" */
  PathLinkEndPkey = 'path_link_end_pkey'
}

/** input type for incrementing numeric columns in table "path_link_end" */
export type StopsDatabasePathLinkEndIncInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly path_junction_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "path_link_end" */
export type StopsDatabasePathLinkEndInsertInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly path_junction_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly place_ref?: InputMaybe<Scalars['String']['input']>;
  readonly place_version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabasePathLinkEndMaxFields = {
  readonly __typename?: 'stops_database_path_link_end_max_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly path_junction_id?: Maybe<Scalars['bigint']['output']>;
  readonly place_ref?: Maybe<Scalars['String']['output']>;
  readonly place_version?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabasePathLinkEndMinFields = {
  readonly __typename?: 'stops_database_path_link_end_min_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly path_junction_id?: Maybe<Scalars['bigint']['output']>;
  readonly place_ref?: Maybe<Scalars['String']['output']>;
  readonly place_version?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "path_link_end" */
export type StopsDatabasePathLinkEndMutationResponse = {
  readonly __typename?: 'stops_database_path_link_end_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabasePathLinkEnd>;
};

/** on_conflict condition type for table "path_link_end" */
export type StopsDatabasePathLinkEndOnConflict = {
  readonly constraint: StopsDatabasePathLinkEndConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabasePathLinkEndUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabasePathLinkEndBoolExp>;
};

/** Ordering options when selecting data from "path_link_end". */
export type StopsDatabasePathLinkEndOrderBy = {
  readonly id?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly path_junction_id?: InputMaybe<OrderBy>;
  readonly place_ref?: InputMaybe<OrderBy>;
  readonly place_version?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: path_link_end */
export type StopsDatabasePathLinkEndPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "path_link_end" */
export enum StopsDatabasePathLinkEndSelectColumn {
  /** column name */
  Id = 'id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PathJunctionId = 'path_junction_id',
  /** column name */
  PlaceRef = 'place_ref',
  /** column name */
  PlaceVersion = 'place_version'
}

/** input type for updating data in table "path_link_end" */
export type StopsDatabasePathLinkEndSetInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly path_junction_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly place_ref?: InputMaybe<Scalars['String']['input']>;
  readonly place_version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabasePathLinkEndStddevFields = {
  readonly __typename?: 'stops_database_path_link_end_stddev_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly path_junction_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabasePathLinkEndStddevPopFields = {
  readonly __typename?: 'stops_database_path_link_end_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly path_junction_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabasePathLinkEndStddevSampFields = {
  readonly __typename?: 'stops_database_path_link_end_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly path_junction_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "path_link_end" */
export type StopsDatabasePathLinkEndStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabasePathLinkEndStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabasePathLinkEndStreamCursorValueInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly path_junction_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly place_ref?: InputMaybe<Scalars['String']['input']>;
  readonly place_version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabasePathLinkEndSumFields = {
  readonly __typename?: 'stops_database_path_link_end_sum_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly path_junction_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "path_link_end" */
export enum StopsDatabasePathLinkEndUpdateColumn {
  /** column name */
  Id = 'id',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PathJunctionId = 'path_junction_id',
  /** column name */
  PlaceRef = 'place_ref',
  /** column name */
  PlaceVersion = 'place_version'
}

export type StopsDatabasePathLinkEndUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabasePathLinkEndIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabasePathLinkEndSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabasePathLinkEndBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabasePathLinkEndVarPopFields = {
  readonly __typename?: 'stops_database_path_link_end_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly path_junction_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabasePathLinkEndVarSampFields = {
  readonly __typename?: 'stops_database_path_link_end_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly path_junction_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabasePathLinkEndVarianceFields = {
  readonly __typename?: 'stops_database_path_link_end_variance_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly path_junction_id?: Maybe<Scalars['Float']['output']>;
};

/** input type for incrementing numeric columns in table "path_link" */
export type StopsDatabasePathLinkIncInput = {
  readonly from_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly to_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "path_link" */
export type StopsDatabasePathLinkInsertInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly default_duration?: InputMaybe<Scalars['bytea']['input']>;
  readonly frequent_traveller_duration?: InputMaybe<Scalars['bytea']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly from_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly line_string?: InputMaybe<Scalars['geometry']['input']>;
  readonly mobility_restricted_traveller_duration?: InputMaybe<Scalars['bytea']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly occasional_traveller_duration?: InputMaybe<Scalars['bytea']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly to_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "path_link_key_values" */
export type StopsDatabasePathLinkKeyValues = {
  readonly __typename?: 'stops_database_path_link_key_values';
  readonly key_values_id: Scalars['bigint']['output'];
  readonly key_values_key: Scalars['String']['output'];
  readonly path_link_id: Scalars['bigint']['output'];
};

/** aggregated selection of "path_link_key_values" */
export type StopsDatabasePathLinkKeyValuesAggregate = {
  readonly __typename?: 'stops_database_path_link_key_values_aggregate';
  readonly aggregate?: Maybe<StopsDatabasePathLinkKeyValuesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabasePathLinkKeyValues>;
};

/** aggregate fields of "path_link_key_values" */
export type StopsDatabasePathLinkKeyValuesAggregateFields = {
  readonly __typename?: 'stops_database_path_link_key_values_aggregate_fields';
  readonly avg?: Maybe<StopsDatabasePathLinkKeyValuesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabasePathLinkKeyValuesMaxFields>;
  readonly min?: Maybe<StopsDatabasePathLinkKeyValuesMinFields>;
  readonly stddev?: Maybe<StopsDatabasePathLinkKeyValuesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabasePathLinkKeyValuesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabasePathLinkKeyValuesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabasePathLinkKeyValuesSumFields>;
  readonly var_pop?: Maybe<StopsDatabasePathLinkKeyValuesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabasePathLinkKeyValuesVarSampFields>;
  readonly variance?: Maybe<StopsDatabasePathLinkKeyValuesVarianceFields>;
};


/** aggregate fields of "path_link_key_values" */
export type StopsDatabasePathLinkKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabasePathLinkKeyValuesAvgFields = {
  readonly __typename?: 'stops_database_path_link_key_values_avg_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly path_link_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "path_link_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabasePathLinkKeyValuesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkKeyValuesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabasePathLinkKeyValuesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkKeyValuesBoolExp>>;
  readonly key_values_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_key?: InputMaybe<StringComparisonExp>;
  readonly path_link_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "path_link_key_values" */
export enum StopsDatabasePathLinkKeyValuesConstraint {
  /** unique or primary key constraint on columns "key_values_key", "path_link_id" */
  PathLinkKeyValuesPkey = 'path_link_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkKn4m9f3l3gdgyg7mdus6qd1r1 = 'uk_kn4m9f3l3gdgyg7mdus6qd1r1'
}

/** input type for incrementing numeric columns in table "path_link_key_values" */
export type StopsDatabasePathLinkKeyValuesIncInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly path_link_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "path_link_key_values" */
export type StopsDatabasePathLinkKeyValuesInsertInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly path_link_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabasePathLinkKeyValuesMaxFields = {
  readonly __typename?: 'stops_database_path_link_key_values_max_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
  readonly path_link_id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type StopsDatabasePathLinkKeyValuesMinFields = {
  readonly __typename?: 'stops_database_path_link_key_values_min_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
  readonly path_link_id?: Maybe<Scalars['bigint']['output']>;
};

/** response of any mutation on the table "path_link_key_values" */
export type StopsDatabasePathLinkKeyValuesMutationResponse = {
  readonly __typename?: 'stops_database_path_link_key_values_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabasePathLinkKeyValues>;
};

/** on_conflict condition type for table "path_link_key_values" */
export type StopsDatabasePathLinkKeyValuesOnConflict = {
  readonly constraint: StopsDatabasePathLinkKeyValuesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabasePathLinkKeyValuesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabasePathLinkKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "path_link_key_values". */
export type StopsDatabasePathLinkKeyValuesOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly path_link_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: path_link_key_values */
export type StopsDatabasePathLinkKeyValuesPkColumnsInput = {
  readonly key_values_key: Scalars['String']['input'];
  readonly path_link_id: Scalars['bigint']['input'];
};

/** select columns of table "path_link_key_values" */
export enum StopsDatabasePathLinkKeyValuesSelectColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  PathLinkId = 'path_link_id'
}

/** input type for updating data in table "path_link_key_values" */
export type StopsDatabasePathLinkKeyValuesSetInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly path_link_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabasePathLinkKeyValuesStddevFields = {
  readonly __typename?: 'stops_database_path_link_key_values_stddev_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly path_link_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabasePathLinkKeyValuesStddevPopFields = {
  readonly __typename?: 'stops_database_path_link_key_values_stddev_pop_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly path_link_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabasePathLinkKeyValuesStddevSampFields = {
  readonly __typename?: 'stops_database_path_link_key_values_stddev_samp_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly path_link_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "path_link_key_values" */
export type StopsDatabasePathLinkKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabasePathLinkKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabasePathLinkKeyValuesStreamCursorValueInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly path_link_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabasePathLinkKeyValuesSumFields = {
  readonly __typename?: 'stops_database_path_link_key_values_sum_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly path_link_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "path_link_key_values" */
export enum StopsDatabasePathLinkKeyValuesUpdateColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  PathLinkId = 'path_link_id'
}

export type StopsDatabasePathLinkKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabasePathLinkKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabasePathLinkKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabasePathLinkKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabasePathLinkKeyValuesVarPopFields = {
  readonly __typename?: 'stops_database_path_link_key_values_var_pop_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly path_link_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabasePathLinkKeyValuesVarSampFields = {
  readonly __typename?: 'stops_database_path_link_key_values_var_samp_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly path_link_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabasePathLinkKeyValuesVarianceFields = {
  readonly __typename?: 'stops_database_path_link_key_values_variance_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly path_link_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate max on columns */
export type StopsDatabasePathLinkMaxFields = {
  readonly __typename?: 'stops_database_path_link_max_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly from_id?: Maybe<Scalars['bigint']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly to_id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabasePathLinkMinFields = {
  readonly __typename?: 'stops_database_path_link_min_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly from_id?: Maybe<Scalars['bigint']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly to_id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "path_link" */
export type StopsDatabasePathLinkMutationResponse = {
  readonly __typename?: 'stops_database_path_link_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabasePathLink>;
};

/** on_conflict condition type for table "path_link" */
export type StopsDatabasePathLinkOnConflict = {
  readonly constraint: StopsDatabasePathLinkConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabasePathLinkUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabasePathLinkBoolExp>;
};

/** Ordering options when selecting data from "path_link". */
export type StopsDatabasePathLinkOrderBy = {
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly default_duration?: InputMaybe<OrderBy>;
  readonly frequent_traveller_duration?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly from_id?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly line_string?: InputMaybe<OrderBy>;
  readonly mobility_restricted_traveller_duration?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly occasional_traveller_duration?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly to_id?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: path_link */
export type StopsDatabasePathLinkPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "path_link" */
export enum StopsDatabasePathLinkSelectColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DefaultDuration = 'default_duration',
  /** column name */
  FrequentTravellerDuration = 'frequent_traveller_duration',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  FromId = 'from_id',
  /** column name */
  Id = 'id',
  /** column name */
  LineString = 'line_string',
  /** column name */
  MobilityRestrictedTravellerDuration = 'mobility_restricted_traveller_duration',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  OccasionalTravellerDuration = 'occasional_traveller_duration',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  ToId = 'to_id',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

/** input type for updating data in table "path_link" */
export type StopsDatabasePathLinkSetInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly default_duration?: InputMaybe<Scalars['bytea']['input']>;
  readonly frequent_traveller_duration?: InputMaybe<Scalars['bytea']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly from_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly line_string?: InputMaybe<Scalars['geometry']['input']>;
  readonly mobility_restricted_traveller_duration?: InputMaybe<Scalars['bytea']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly occasional_traveller_duration?: InputMaybe<Scalars['bytea']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly to_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabasePathLinkStddevFields = {
  readonly __typename?: 'stops_database_path_link_stddev_fields';
  readonly from_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly to_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabasePathLinkStddevPopFields = {
  readonly __typename?: 'stops_database_path_link_stddev_pop_fields';
  readonly from_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly to_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabasePathLinkStddevSampFields = {
  readonly __typename?: 'stops_database_path_link_stddev_samp_fields';
  readonly from_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly to_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "path_link" */
export type StopsDatabasePathLinkStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabasePathLinkStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabasePathLinkStreamCursorValueInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly default_duration?: InputMaybe<Scalars['bytea']['input']>;
  readonly frequent_traveller_duration?: InputMaybe<Scalars['bytea']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly from_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly line_string?: InputMaybe<Scalars['geometry']['input']>;
  readonly mobility_restricted_traveller_duration?: InputMaybe<Scalars['bytea']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly occasional_traveller_duration?: InputMaybe<Scalars['bytea']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly to_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabasePathLinkSumFields = {
  readonly __typename?: 'stops_database_path_link_sum_fields';
  readonly from_id?: Maybe<Scalars['bigint']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly to_id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "path_link" */
export enum StopsDatabasePathLinkUpdateColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DefaultDuration = 'default_duration',
  /** column name */
  FrequentTravellerDuration = 'frequent_traveller_duration',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  FromId = 'from_id',
  /** column name */
  Id = 'id',
  /** column name */
  LineString = 'line_string',
  /** column name */
  MobilityRestrictedTravellerDuration = 'mobility_restricted_traveller_duration',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  OccasionalTravellerDuration = 'occasional_traveller_duration',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  ToId = 'to_id',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

export type StopsDatabasePathLinkUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabasePathLinkIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabasePathLinkSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabasePathLinkBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabasePathLinkVarPopFields = {
  readonly __typename?: 'stops_database_path_link_var_pop_fields';
  readonly from_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly to_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabasePathLinkVarSampFields = {
  readonly __typename?: 'stops_database_path_link_var_samp_fields';
  readonly from_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly to_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabasePathLinkVarianceFields = {
  readonly __typename?: 'stops_database_path_link_variance_fields';
  readonly from_id?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly to_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "persistable_polygon" */
export type StopsDatabasePersistablePolygon = {
  readonly __typename?: 'stops_database_persistable_polygon';
  readonly id: Scalars['bigint']['output'];
  readonly polygon?: Maybe<Scalars['geometry']['output']>;
};

/** aggregated selection of "persistable_polygon" */
export type StopsDatabasePersistablePolygonAggregate = {
  readonly __typename?: 'stops_database_persistable_polygon_aggregate';
  readonly aggregate?: Maybe<StopsDatabasePersistablePolygonAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabasePersistablePolygon>;
};

/** aggregate fields of "persistable_polygon" */
export type StopsDatabasePersistablePolygonAggregateFields = {
  readonly __typename?: 'stops_database_persistable_polygon_aggregate_fields';
  readonly avg?: Maybe<StopsDatabasePersistablePolygonAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabasePersistablePolygonMaxFields>;
  readonly min?: Maybe<StopsDatabasePersistablePolygonMinFields>;
  readonly stddev?: Maybe<StopsDatabasePersistablePolygonStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabasePersistablePolygonStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabasePersistablePolygonStddevSampFields>;
  readonly sum?: Maybe<StopsDatabasePersistablePolygonSumFields>;
  readonly var_pop?: Maybe<StopsDatabasePersistablePolygonVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabasePersistablePolygonVarSampFields>;
  readonly variance?: Maybe<StopsDatabasePersistablePolygonVarianceFields>;
};


/** aggregate fields of "persistable_polygon" */
export type StopsDatabasePersistablePolygonAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabasePersistablePolygonSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabasePersistablePolygonAvgFields = {
  readonly __typename?: 'stops_database_persistable_polygon_avg_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "persistable_polygon". All fields are combined with a logical 'AND'. */
export type StopsDatabasePersistablePolygonBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabasePersistablePolygonBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabasePersistablePolygonBoolExp>>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly polygon?: InputMaybe<GeometryComparisonExp>;
};

/** unique or primary key constraints on table "persistable_polygon" */
export enum StopsDatabasePersistablePolygonConstraint {
  /** unique or primary key constraint on columns "id" */
  PersistablePolygonPkey = 'persistable_polygon_pkey'
}

/** input type for incrementing numeric columns in table "persistable_polygon" */
export type StopsDatabasePersistablePolygonIncInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "persistable_polygon" */
export type StopsDatabasePersistablePolygonInsertInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon?: InputMaybe<Scalars['geometry']['input']>;
};

/** aggregate max on columns */
export type StopsDatabasePersistablePolygonMaxFields = {
  readonly __typename?: 'stops_database_persistable_polygon_max_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type StopsDatabasePersistablePolygonMinFields = {
  readonly __typename?: 'stops_database_persistable_polygon_min_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
};

/** response of any mutation on the table "persistable_polygon" */
export type StopsDatabasePersistablePolygonMutationResponse = {
  readonly __typename?: 'stops_database_persistable_polygon_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabasePersistablePolygon>;
};

/** input type for inserting object relation for remote table "persistable_polygon" */
export type StopsDatabasePersistablePolygonObjRelInsertInput = {
  readonly data: StopsDatabasePersistablePolygonInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabasePersistablePolygonOnConflict>;
};

/** on_conflict condition type for table "persistable_polygon" */
export type StopsDatabasePersistablePolygonOnConflict = {
  readonly constraint: StopsDatabasePersistablePolygonConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabasePersistablePolygonUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
};

/** Ordering options when selecting data from "persistable_polygon". */
export type StopsDatabasePersistablePolygonOrderBy = {
  readonly id?: InputMaybe<OrderBy>;
  readonly polygon?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: persistable_polygon */
export type StopsDatabasePersistablePolygonPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "persistable_polygon" */
export enum StopsDatabasePersistablePolygonSelectColumn {
  /** column name */
  Id = 'id',
  /** column name */
  Polygon = 'polygon'
}

/** input type for updating data in table "persistable_polygon" */
export type StopsDatabasePersistablePolygonSetInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon?: InputMaybe<Scalars['geometry']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabasePersistablePolygonStddevFields = {
  readonly __typename?: 'stops_database_persistable_polygon_stddev_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabasePersistablePolygonStddevPopFields = {
  readonly __typename?: 'stops_database_persistable_polygon_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabasePersistablePolygonStddevSampFields = {
  readonly __typename?: 'stops_database_persistable_polygon_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "persistable_polygon" */
export type StopsDatabasePersistablePolygonStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabasePersistablePolygonStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabasePersistablePolygonStreamCursorValueInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon?: InputMaybe<Scalars['geometry']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabasePersistablePolygonSumFields = {
  readonly __typename?: 'stops_database_persistable_polygon_sum_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "persistable_polygon" */
export enum StopsDatabasePersistablePolygonUpdateColumn {
  /** column name */
  Id = 'id',
  /** column name */
  Polygon = 'polygon'
}

export type StopsDatabasePersistablePolygonUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabasePersistablePolygonIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabasePersistablePolygonSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabasePersistablePolygonBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabasePersistablePolygonVarPopFields = {
  readonly __typename?: 'stops_database_persistable_polygon_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabasePersistablePolygonVarSampFields = {
  readonly __typename?: 'stops_database_persistable_polygon_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabasePersistablePolygonVarianceFields = {
  readonly __typename?: 'stops_database_persistable_polygon_variance_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "place_equipment" */
export type StopsDatabasePlaceEquipment = {
  readonly __typename?: 'stops_database_place_equipment';
  readonly air_conditioned?: Maybe<Scalars['Boolean']['output']>;
  readonly bicycle_parking?: Maybe<Scalars['Boolean']['output']>;
  readonly brand_graphic?: Maybe<Scalars['String']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly class_of_use_ref?: Maybe<Scalars['bytea']['output']>;
  readonly content_lang?: Maybe<Scalars['String']['output']>;
  readonly content_value?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly cycle_storage_type?: Maybe<Scalars['Int']['output']>;
  readonly dtype?: Maybe<Scalars['String']['output']>;
  readonly enclosed?: Maybe<Scalars['Boolean']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly gender?: Maybe<Scalars['Int']['output']>;
  readonly heated?: Maybe<Scalars['Boolean']['output']>;
  readonly height?: Maybe<Scalars['numeric']['output']>;
  readonly height_from_floor?: Maybe<Scalars['numeric']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly leaning_rail?: Maybe<Scalars['Boolean']['output']>;
  readonly length?: Maybe<Scalars['numeric']['output']>;
  readonly line_signage?: Maybe<Scalars['Boolean']['output']>;
  readonly machine_readable?: Maybe<Scalars['Boolean']['output']>;
  readonly main_line_sign?: Maybe<Scalars['Boolean']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly note_lang?: Maybe<Scalars['String']['output']>;
  readonly note_value?: Maybe<Scalars['String']['output']>;
  readonly number_of_frames?: Maybe<Scalars['Int']['output']>;
  readonly number_of_machines?: Maybe<Scalars['numeric']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['numeric']['output']>;
  readonly number_of_toilets?: Maybe<Scalars['numeric']['output']>;
  readonly out_of_service?: Maybe<Scalars['Boolean']['output']>;
  readonly outside_bench?: Maybe<Scalars['Boolean']['output']>;
  readonly place_equipment_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly replaces_rail_sign?: Maybe<Scalars['Boolean']['output']>;
  readonly seats?: Maybe<Scalars['numeric']['output']>;
  readonly shelter_condition?: Maybe<Scalars['String']['output']>;
  readonly shelter_electricity?: Maybe<Scalars['String']['output']>;
  readonly shelter_external_id?: Maybe<Scalars['String']['output']>;
  readonly shelter_fascia_board_taping?: Maybe<Scalars['Boolean']['output']>;
  readonly shelter_has_display?: Maybe<Scalars['Boolean']['output']>;
  readonly shelter_lighting?: Maybe<Scalars['Boolean']['output']>;
  readonly shelter_number?: Maybe<Scalars['Int']['output']>;
  readonly shelter_type?: Maybe<Scalars['String']['output']>;
  readonly sign_content_type?: Maybe<Scalars['String']['output']>;
  readonly sign_graphic?: Maybe<Scalars['String']['output']>;
  readonly smoking_allowed?: Maybe<Scalars['Boolean']['output']>;
  readonly step_free?: Maybe<Scalars['Boolean']['output']>;
  readonly ticket_machines?: Maybe<Scalars['Boolean']['output']>;
  readonly ticket_office?: Maybe<Scalars['Boolean']['output']>;
  readonly timetable_cabinets?: Maybe<Scalars['Int']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly trash_can?: Maybe<Scalars['Boolean']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly wheelchair_area_length?: Maybe<Scalars['numeric']['output']>;
  readonly wheelchair_area_width?: Maybe<Scalars['numeric']['output']>;
  readonly width?: Maybe<Scalars['numeric']['output']>;
  readonly women_only?: Maybe<Scalars['Boolean']['output']>;
};

/** aggregated selection of "place_equipment" */
export type StopsDatabasePlaceEquipmentAggregate = {
  readonly __typename?: 'stops_database_place_equipment_aggregate';
  readonly aggregate?: Maybe<StopsDatabasePlaceEquipmentAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabasePlaceEquipment>;
};

/** aggregate fields of "place_equipment" */
export type StopsDatabasePlaceEquipmentAggregateFields = {
  readonly __typename?: 'stops_database_place_equipment_aggregate_fields';
  readonly avg?: Maybe<StopsDatabasePlaceEquipmentAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabasePlaceEquipmentMaxFields>;
  readonly min?: Maybe<StopsDatabasePlaceEquipmentMinFields>;
  readonly stddev?: Maybe<StopsDatabasePlaceEquipmentStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabasePlaceEquipmentStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabasePlaceEquipmentStddevSampFields>;
  readonly sum?: Maybe<StopsDatabasePlaceEquipmentSumFields>;
  readonly var_pop?: Maybe<StopsDatabasePlaceEquipmentVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabasePlaceEquipmentVarSampFields>;
  readonly variance?: Maybe<StopsDatabasePlaceEquipmentVarianceFields>;
};


/** aggregate fields of "place_equipment" */
export type StopsDatabasePlaceEquipmentAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabasePlaceEquipmentSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabasePlaceEquipmentAvgFields = {
  readonly __typename?: 'stops_database_place_equipment_avg_fields';
  readonly cycle_storage_type?: Maybe<Scalars['Float']['output']>;
  readonly gender?: Maybe<Scalars['Float']['output']>;
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly height_from_floor?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly length?: Maybe<Scalars['Float']['output']>;
  readonly number_of_frames?: Maybe<Scalars['Float']['output']>;
  readonly number_of_machines?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['Float']['output']>;
  readonly number_of_toilets?: Maybe<Scalars['Float']['output']>;
  readonly place_equipment_id?: Maybe<Scalars['Float']['output']>;
  readonly seats?: Maybe<Scalars['Float']['output']>;
  readonly shelter_number?: Maybe<Scalars['Float']['output']>;
  readonly timetable_cabinets?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_length?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_width?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "place_equipment". All fields are combined with a logical 'AND'. */
export type StopsDatabasePlaceEquipmentBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabasePlaceEquipmentBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabasePlaceEquipmentBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabasePlaceEquipmentBoolExp>>;
  readonly air_conditioned?: InputMaybe<BooleanComparisonExp>;
  readonly bicycle_parking?: InputMaybe<BooleanComparisonExp>;
  readonly brand_graphic?: InputMaybe<StringComparisonExp>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly class_of_use_ref?: InputMaybe<ByteaComparisonExp>;
  readonly content_lang?: InputMaybe<StringComparisonExp>;
  readonly content_value?: InputMaybe<StringComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly cycle_storage_type?: InputMaybe<IntComparisonExp>;
  readonly dtype?: InputMaybe<StringComparisonExp>;
  readonly enclosed?: InputMaybe<BooleanComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly gender?: InputMaybe<IntComparisonExp>;
  readonly heated?: InputMaybe<BooleanComparisonExp>;
  readonly height?: InputMaybe<NumericComparisonExp>;
  readonly height_from_floor?: InputMaybe<NumericComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly leaning_rail?: InputMaybe<BooleanComparisonExp>;
  readonly length?: InputMaybe<NumericComparisonExp>;
  readonly line_signage?: InputMaybe<BooleanComparisonExp>;
  readonly machine_readable?: InputMaybe<BooleanComparisonExp>;
  readonly main_line_sign?: InputMaybe<BooleanComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly note_lang?: InputMaybe<StringComparisonExp>;
  readonly note_value?: InputMaybe<StringComparisonExp>;
  readonly number_of_frames?: InputMaybe<IntComparisonExp>;
  readonly number_of_machines?: InputMaybe<NumericComparisonExp>;
  readonly number_of_spaces?: InputMaybe<NumericComparisonExp>;
  readonly number_of_toilets?: InputMaybe<NumericComparisonExp>;
  readonly out_of_service?: InputMaybe<BooleanComparisonExp>;
  readonly outside_bench?: InputMaybe<BooleanComparisonExp>;
  readonly place_equipment_id?: InputMaybe<BigintComparisonExp>;
  readonly private_code_type?: InputMaybe<StringComparisonExp>;
  readonly private_code_value?: InputMaybe<StringComparisonExp>;
  readonly replaces_rail_sign?: InputMaybe<BooleanComparisonExp>;
  readonly seats?: InputMaybe<NumericComparisonExp>;
  readonly shelter_condition?: InputMaybe<StringComparisonExp>;
  readonly shelter_electricity?: InputMaybe<StringComparisonExp>;
  readonly shelter_external_id?: InputMaybe<StringComparisonExp>;
  readonly shelter_fascia_board_taping?: InputMaybe<BooleanComparisonExp>;
  readonly shelter_has_display?: InputMaybe<BooleanComparisonExp>;
  readonly shelter_lighting?: InputMaybe<BooleanComparisonExp>;
  readonly shelter_number?: InputMaybe<IntComparisonExp>;
  readonly shelter_type?: InputMaybe<StringComparisonExp>;
  readonly sign_content_type?: InputMaybe<StringComparisonExp>;
  readonly sign_graphic?: InputMaybe<StringComparisonExp>;
  readonly smoking_allowed?: InputMaybe<BooleanComparisonExp>;
  readonly step_free?: InputMaybe<BooleanComparisonExp>;
  readonly ticket_machines?: InputMaybe<BooleanComparisonExp>;
  readonly ticket_office?: InputMaybe<BooleanComparisonExp>;
  readonly timetable_cabinets?: InputMaybe<IntComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly trash_can?: InputMaybe<BooleanComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
  readonly wheelchair_area_length?: InputMaybe<NumericComparisonExp>;
  readonly wheelchair_area_width?: InputMaybe<NumericComparisonExp>;
  readonly width?: InputMaybe<NumericComparisonExp>;
  readonly women_only?: InputMaybe<BooleanComparisonExp>;
};

/** aggregate max on columns */
export type StopsDatabasePlaceEquipmentMaxFields = {
  readonly __typename?: 'stops_database_place_equipment_max_fields';
  readonly brand_graphic?: Maybe<Scalars['String']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly content_lang?: Maybe<Scalars['String']['output']>;
  readonly content_value?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly cycle_storage_type?: Maybe<Scalars['Int']['output']>;
  readonly dtype?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly gender?: Maybe<Scalars['Int']['output']>;
  readonly height?: Maybe<Scalars['numeric']['output']>;
  readonly height_from_floor?: Maybe<Scalars['numeric']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly length?: Maybe<Scalars['numeric']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly note_lang?: Maybe<Scalars['String']['output']>;
  readonly note_value?: Maybe<Scalars['String']['output']>;
  readonly number_of_frames?: Maybe<Scalars['Int']['output']>;
  readonly number_of_machines?: Maybe<Scalars['numeric']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['numeric']['output']>;
  readonly number_of_toilets?: Maybe<Scalars['numeric']['output']>;
  readonly place_equipment_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly seats?: Maybe<Scalars['numeric']['output']>;
  readonly shelter_condition?: Maybe<Scalars['String']['output']>;
  readonly shelter_electricity?: Maybe<Scalars['String']['output']>;
  readonly shelter_external_id?: Maybe<Scalars['String']['output']>;
  readonly shelter_number?: Maybe<Scalars['Int']['output']>;
  readonly shelter_type?: Maybe<Scalars['String']['output']>;
  readonly sign_content_type?: Maybe<Scalars['String']['output']>;
  readonly sign_graphic?: Maybe<Scalars['String']['output']>;
  readonly timetable_cabinets?: Maybe<Scalars['Int']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly wheelchair_area_length?: Maybe<Scalars['numeric']['output']>;
  readonly wheelchair_area_width?: Maybe<Scalars['numeric']['output']>;
  readonly width?: Maybe<Scalars['numeric']['output']>;
};

/** aggregate min on columns */
export type StopsDatabasePlaceEquipmentMinFields = {
  readonly __typename?: 'stops_database_place_equipment_min_fields';
  readonly brand_graphic?: Maybe<Scalars['String']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly content_lang?: Maybe<Scalars['String']['output']>;
  readonly content_value?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly cycle_storage_type?: Maybe<Scalars['Int']['output']>;
  readonly dtype?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly gender?: Maybe<Scalars['Int']['output']>;
  readonly height?: Maybe<Scalars['numeric']['output']>;
  readonly height_from_floor?: Maybe<Scalars['numeric']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly length?: Maybe<Scalars['numeric']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly note_lang?: Maybe<Scalars['String']['output']>;
  readonly note_value?: Maybe<Scalars['String']['output']>;
  readonly number_of_frames?: Maybe<Scalars['Int']['output']>;
  readonly number_of_machines?: Maybe<Scalars['numeric']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['numeric']['output']>;
  readonly number_of_toilets?: Maybe<Scalars['numeric']['output']>;
  readonly place_equipment_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly seats?: Maybe<Scalars['numeric']['output']>;
  readonly shelter_condition?: Maybe<Scalars['String']['output']>;
  readonly shelter_electricity?: Maybe<Scalars['String']['output']>;
  readonly shelter_external_id?: Maybe<Scalars['String']['output']>;
  readonly shelter_number?: Maybe<Scalars['Int']['output']>;
  readonly shelter_type?: Maybe<Scalars['String']['output']>;
  readonly sign_content_type?: Maybe<Scalars['String']['output']>;
  readonly sign_graphic?: Maybe<Scalars['String']['output']>;
  readonly timetable_cabinets?: Maybe<Scalars['Int']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly wheelchair_area_length?: Maybe<Scalars['numeric']['output']>;
  readonly wheelchair_area_width?: Maybe<Scalars['numeric']['output']>;
  readonly width?: Maybe<Scalars['numeric']['output']>;
};

/** Ordering options when selecting data from "place_equipment". */
export type StopsDatabasePlaceEquipmentOrderBy = {
  readonly air_conditioned?: InputMaybe<OrderBy>;
  readonly bicycle_parking?: InputMaybe<OrderBy>;
  readonly brand_graphic?: InputMaybe<OrderBy>;
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly class_of_use_ref?: InputMaybe<OrderBy>;
  readonly content_lang?: InputMaybe<OrderBy>;
  readonly content_value?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly cycle_storage_type?: InputMaybe<OrderBy>;
  readonly dtype?: InputMaybe<OrderBy>;
  readonly enclosed?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly gender?: InputMaybe<OrderBy>;
  readonly heated?: InputMaybe<OrderBy>;
  readonly height?: InputMaybe<OrderBy>;
  readonly height_from_floor?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly leaning_rail?: InputMaybe<OrderBy>;
  readonly length?: InputMaybe<OrderBy>;
  readonly line_signage?: InputMaybe<OrderBy>;
  readonly machine_readable?: InputMaybe<OrderBy>;
  readonly main_line_sign?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly note_lang?: InputMaybe<OrderBy>;
  readonly note_value?: InputMaybe<OrderBy>;
  readonly number_of_frames?: InputMaybe<OrderBy>;
  readonly number_of_machines?: InputMaybe<OrderBy>;
  readonly number_of_spaces?: InputMaybe<OrderBy>;
  readonly number_of_toilets?: InputMaybe<OrderBy>;
  readonly out_of_service?: InputMaybe<OrderBy>;
  readonly outside_bench?: InputMaybe<OrderBy>;
  readonly place_equipment_id?: InputMaybe<OrderBy>;
  readonly private_code_type?: InputMaybe<OrderBy>;
  readonly private_code_value?: InputMaybe<OrderBy>;
  readonly replaces_rail_sign?: InputMaybe<OrderBy>;
  readonly seats?: InputMaybe<OrderBy>;
  readonly shelter_condition?: InputMaybe<OrderBy>;
  readonly shelter_electricity?: InputMaybe<OrderBy>;
  readonly shelter_external_id?: InputMaybe<OrderBy>;
  readonly shelter_fascia_board_taping?: InputMaybe<OrderBy>;
  readonly shelter_has_display?: InputMaybe<OrderBy>;
  readonly shelter_lighting?: InputMaybe<OrderBy>;
  readonly shelter_number?: InputMaybe<OrderBy>;
  readonly shelter_type?: InputMaybe<OrderBy>;
  readonly sign_content_type?: InputMaybe<OrderBy>;
  readonly sign_graphic?: InputMaybe<OrderBy>;
  readonly smoking_allowed?: InputMaybe<OrderBy>;
  readonly step_free?: InputMaybe<OrderBy>;
  readonly ticket_machines?: InputMaybe<OrderBy>;
  readonly ticket_office?: InputMaybe<OrderBy>;
  readonly timetable_cabinets?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly trash_can?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
  readonly wheelchair_area_length?: InputMaybe<OrderBy>;
  readonly wheelchair_area_width?: InputMaybe<OrderBy>;
  readonly width?: InputMaybe<OrderBy>;
  readonly women_only?: InputMaybe<OrderBy>;
};

/** select columns of table "place_equipment" */
export enum StopsDatabasePlaceEquipmentSelectColumn {
  /** column name */
  AirConditioned = 'air_conditioned',
  /** column name */
  BicycleParking = 'bicycle_parking',
  /** column name */
  BrandGraphic = 'brand_graphic',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  ClassOfUseRef = 'class_of_use_ref',
  /** column name */
  ContentLang = 'content_lang',
  /** column name */
  ContentValue = 'content_value',
  /** column name */
  Created = 'created',
  /** column name */
  CycleStorageType = 'cycle_storage_type',
  /** column name */
  Dtype = 'dtype',
  /** column name */
  Enclosed = 'enclosed',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Gender = 'gender',
  /** column name */
  Heated = 'heated',
  /** column name */
  Height = 'height',
  /** column name */
  HeightFromFloor = 'height_from_floor',
  /** column name */
  Id = 'id',
  /** column name */
  LeaningRail = 'leaning_rail',
  /** column name */
  Length = 'length',
  /** column name */
  LineSignage = 'line_signage',
  /** column name */
  MachineReadable = 'machine_readable',
  /** column name */
  MainLineSign = 'main_line_sign',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  NoteLang = 'note_lang',
  /** column name */
  NoteValue = 'note_value',
  /** column name */
  NumberOfFrames = 'number_of_frames',
  /** column name */
  NumberOfMachines = 'number_of_machines',
  /** column name */
  NumberOfSpaces = 'number_of_spaces',
  /** column name */
  NumberOfToilets = 'number_of_toilets',
  /** column name */
  OutOfService = 'out_of_service',
  /** column name */
  OutsideBench = 'outside_bench',
  /** column name */
  PlaceEquipmentId = 'place_equipment_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ReplacesRailSign = 'replaces_rail_sign',
  /** column name */
  Seats = 'seats',
  /** column name */
  ShelterCondition = 'shelter_condition',
  /** column name */
  ShelterElectricity = 'shelter_electricity',
  /** column name */
  ShelterExternalId = 'shelter_external_id',
  /** column name */
  ShelterFasciaBoardTaping = 'shelter_fascia_board_taping',
  /** column name */
  ShelterHasDisplay = 'shelter_has_display',
  /** column name */
  ShelterLighting = 'shelter_lighting',
  /** column name */
  ShelterNumber = 'shelter_number',
  /** column name */
  ShelterType = 'shelter_type',
  /** column name */
  SignContentType = 'sign_content_type',
  /** column name */
  SignGraphic = 'sign_graphic',
  /** column name */
  SmokingAllowed = 'smoking_allowed',
  /** column name */
  StepFree = 'step_free',
  /** column name */
  TicketMachines = 'ticket_machines',
  /** column name */
  TicketOffice = 'ticket_office',
  /** column name */
  TimetableCabinets = 'timetable_cabinets',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TrashCan = 'trash_can',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  WheelchairAreaLength = 'wheelchair_area_length',
  /** column name */
  WheelchairAreaWidth = 'wheelchair_area_width',
  /** column name */
  Width = 'width',
  /** column name */
  WomenOnly = 'women_only'
}

/** aggregate stddev on columns */
export type StopsDatabasePlaceEquipmentStddevFields = {
  readonly __typename?: 'stops_database_place_equipment_stddev_fields';
  readonly cycle_storage_type?: Maybe<Scalars['Float']['output']>;
  readonly gender?: Maybe<Scalars['Float']['output']>;
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly height_from_floor?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly length?: Maybe<Scalars['Float']['output']>;
  readonly number_of_frames?: Maybe<Scalars['Float']['output']>;
  readonly number_of_machines?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['Float']['output']>;
  readonly number_of_toilets?: Maybe<Scalars['Float']['output']>;
  readonly place_equipment_id?: Maybe<Scalars['Float']['output']>;
  readonly seats?: Maybe<Scalars['Float']['output']>;
  readonly shelter_number?: Maybe<Scalars['Float']['output']>;
  readonly timetable_cabinets?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_length?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_width?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabasePlaceEquipmentStddevPopFields = {
  readonly __typename?: 'stops_database_place_equipment_stddev_pop_fields';
  readonly cycle_storage_type?: Maybe<Scalars['Float']['output']>;
  readonly gender?: Maybe<Scalars['Float']['output']>;
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly height_from_floor?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly length?: Maybe<Scalars['Float']['output']>;
  readonly number_of_frames?: Maybe<Scalars['Float']['output']>;
  readonly number_of_machines?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['Float']['output']>;
  readonly number_of_toilets?: Maybe<Scalars['Float']['output']>;
  readonly place_equipment_id?: Maybe<Scalars['Float']['output']>;
  readonly seats?: Maybe<Scalars['Float']['output']>;
  readonly shelter_number?: Maybe<Scalars['Float']['output']>;
  readonly timetable_cabinets?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_length?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_width?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabasePlaceEquipmentStddevSampFields = {
  readonly __typename?: 'stops_database_place_equipment_stddev_samp_fields';
  readonly cycle_storage_type?: Maybe<Scalars['Float']['output']>;
  readonly gender?: Maybe<Scalars['Float']['output']>;
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly height_from_floor?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly length?: Maybe<Scalars['Float']['output']>;
  readonly number_of_frames?: Maybe<Scalars['Float']['output']>;
  readonly number_of_machines?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['Float']['output']>;
  readonly number_of_toilets?: Maybe<Scalars['Float']['output']>;
  readonly place_equipment_id?: Maybe<Scalars['Float']['output']>;
  readonly seats?: Maybe<Scalars['Float']['output']>;
  readonly shelter_number?: Maybe<Scalars['Float']['output']>;
  readonly timetable_cabinets?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_length?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_width?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "place_equipment" */
export type StopsDatabasePlaceEquipmentStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabasePlaceEquipmentStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabasePlaceEquipmentStreamCursorValueInput = {
  readonly air_conditioned?: InputMaybe<Scalars['Boolean']['input']>;
  readonly bicycle_parking?: InputMaybe<Scalars['Boolean']['input']>;
  readonly brand_graphic?: InputMaybe<Scalars['String']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly class_of_use_ref?: InputMaybe<Scalars['bytea']['input']>;
  readonly content_lang?: InputMaybe<Scalars['String']['input']>;
  readonly content_value?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly cycle_storage_type?: InputMaybe<Scalars['Int']['input']>;
  readonly dtype?: InputMaybe<Scalars['String']['input']>;
  readonly enclosed?: InputMaybe<Scalars['Boolean']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly gender?: InputMaybe<Scalars['Int']['input']>;
  readonly heated?: InputMaybe<Scalars['Boolean']['input']>;
  readonly height?: InputMaybe<Scalars['numeric']['input']>;
  readonly height_from_floor?: InputMaybe<Scalars['numeric']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly leaning_rail?: InputMaybe<Scalars['Boolean']['input']>;
  readonly length?: InputMaybe<Scalars['numeric']['input']>;
  readonly line_signage?: InputMaybe<Scalars['Boolean']['input']>;
  readonly machine_readable?: InputMaybe<Scalars['Boolean']['input']>;
  readonly main_line_sign?: InputMaybe<Scalars['Boolean']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly note_lang?: InputMaybe<Scalars['String']['input']>;
  readonly note_value?: InputMaybe<Scalars['String']['input']>;
  readonly number_of_frames?: InputMaybe<Scalars['Int']['input']>;
  readonly number_of_machines?: InputMaybe<Scalars['numeric']['input']>;
  readonly number_of_spaces?: InputMaybe<Scalars['numeric']['input']>;
  readonly number_of_toilets?: InputMaybe<Scalars['numeric']['input']>;
  readonly out_of_service?: InputMaybe<Scalars['Boolean']['input']>;
  readonly outside_bench?: InputMaybe<Scalars['Boolean']['input']>;
  readonly place_equipment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly replaces_rail_sign?: InputMaybe<Scalars['Boolean']['input']>;
  readonly seats?: InputMaybe<Scalars['numeric']['input']>;
  readonly shelter_condition?: InputMaybe<Scalars['String']['input']>;
  readonly shelter_electricity?: InputMaybe<Scalars['String']['input']>;
  readonly shelter_external_id?: InputMaybe<Scalars['String']['input']>;
  readonly shelter_fascia_board_taping?: InputMaybe<Scalars['Boolean']['input']>;
  readonly shelter_has_display?: InputMaybe<Scalars['Boolean']['input']>;
  readonly shelter_lighting?: InputMaybe<Scalars['Boolean']['input']>;
  readonly shelter_number?: InputMaybe<Scalars['Int']['input']>;
  readonly shelter_type?: InputMaybe<Scalars['String']['input']>;
  readonly sign_content_type?: InputMaybe<Scalars['String']['input']>;
  readonly sign_graphic?: InputMaybe<Scalars['String']['input']>;
  readonly smoking_allowed?: InputMaybe<Scalars['Boolean']['input']>;
  readonly step_free?: InputMaybe<Scalars['Boolean']['input']>;
  readonly ticket_machines?: InputMaybe<Scalars['Boolean']['input']>;
  readonly ticket_office?: InputMaybe<Scalars['Boolean']['input']>;
  readonly timetable_cabinets?: InputMaybe<Scalars['Int']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly trash_can?: InputMaybe<Scalars['Boolean']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
  readonly wheelchair_area_length?: InputMaybe<Scalars['numeric']['input']>;
  readonly wheelchair_area_width?: InputMaybe<Scalars['numeric']['input']>;
  readonly width?: InputMaybe<Scalars['numeric']['input']>;
  readonly women_only?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabasePlaceEquipmentSumFields = {
  readonly __typename?: 'stops_database_place_equipment_sum_fields';
  readonly cycle_storage_type?: Maybe<Scalars['Int']['output']>;
  readonly gender?: Maybe<Scalars['Int']['output']>;
  readonly height?: Maybe<Scalars['numeric']['output']>;
  readonly height_from_floor?: Maybe<Scalars['numeric']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly length?: Maybe<Scalars['numeric']['output']>;
  readonly number_of_frames?: Maybe<Scalars['Int']['output']>;
  readonly number_of_machines?: Maybe<Scalars['numeric']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['numeric']['output']>;
  readonly number_of_toilets?: Maybe<Scalars['numeric']['output']>;
  readonly place_equipment_id?: Maybe<Scalars['bigint']['output']>;
  readonly seats?: Maybe<Scalars['numeric']['output']>;
  readonly shelter_number?: Maybe<Scalars['Int']['output']>;
  readonly timetable_cabinets?: Maybe<Scalars['Int']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly wheelchair_area_length?: Maybe<Scalars['numeric']['output']>;
  readonly wheelchair_area_width?: Maybe<Scalars['numeric']['output']>;
  readonly width?: Maybe<Scalars['numeric']['output']>;
};

/** aggregate var_pop on columns */
export type StopsDatabasePlaceEquipmentVarPopFields = {
  readonly __typename?: 'stops_database_place_equipment_var_pop_fields';
  readonly cycle_storage_type?: Maybe<Scalars['Float']['output']>;
  readonly gender?: Maybe<Scalars['Float']['output']>;
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly height_from_floor?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly length?: Maybe<Scalars['Float']['output']>;
  readonly number_of_frames?: Maybe<Scalars['Float']['output']>;
  readonly number_of_machines?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['Float']['output']>;
  readonly number_of_toilets?: Maybe<Scalars['Float']['output']>;
  readonly place_equipment_id?: Maybe<Scalars['Float']['output']>;
  readonly seats?: Maybe<Scalars['Float']['output']>;
  readonly shelter_number?: Maybe<Scalars['Float']['output']>;
  readonly timetable_cabinets?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_length?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_width?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabasePlaceEquipmentVarSampFields = {
  readonly __typename?: 'stops_database_place_equipment_var_samp_fields';
  readonly cycle_storage_type?: Maybe<Scalars['Float']['output']>;
  readonly gender?: Maybe<Scalars['Float']['output']>;
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly height_from_floor?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly length?: Maybe<Scalars['Float']['output']>;
  readonly number_of_frames?: Maybe<Scalars['Float']['output']>;
  readonly number_of_machines?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['Float']['output']>;
  readonly number_of_toilets?: Maybe<Scalars['Float']['output']>;
  readonly place_equipment_id?: Maybe<Scalars['Float']['output']>;
  readonly seats?: Maybe<Scalars['Float']['output']>;
  readonly shelter_number?: Maybe<Scalars['Float']['output']>;
  readonly timetable_cabinets?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_length?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_width?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabasePlaceEquipmentVarianceFields = {
  readonly __typename?: 'stops_database_place_equipment_variance_fields';
  readonly cycle_storage_type?: Maybe<Scalars['Float']['output']>;
  readonly gender?: Maybe<Scalars['Float']['output']>;
  readonly height?: Maybe<Scalars['Float']['output']>;
  readonly height_from_floor?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly length?: Maybe<Scalars['Float']['output']>;
  readonly number_of_frames?: Maybe<Scalars['Float']['output']>;
  readonly number_of_machines?: Maybe<Scalars['Float']['output']>;
  readonly number_of_spaces?: Maybe<Scalars['Float']['output']>;
  readonly number_of_toilets?: Maybe<Scalars['Float']['output']>;
  readonly place_equipment_id?: Maybe<Scalars['Float']['output']>;
  readonly seats?: Maybe<Scalars['Float']['output']>;
  readonly shelter_number?: Maybe<Scalars['Float']['output']>;
  readonly timetable_cabinets?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_length?: Maybe<Scalars['Float']['output']>;
  readonly wheelchair_area_width?: Maybe<Scalars['Float']['output']>;
  readonly width?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "purpose_of_grouping" */
export type StopsDatabasePurposeOfGrouping = {
  readonly __typename?: 'stops_database_purpose_of_grouping';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id: Scalars['bigint']['output'];
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "purpose_of_grouping" */
export type StopsDatabasePurposeOfGroupingAggregate = {
  readonly __typename?: 'stops_database_purpose_of_grouping_aggregate';
  readonly aggregate?: Maybe<StopsDatabasePurposeOfGroupingAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabasePurposeOfGrouping>;
};

/** aggregate fields of "purpose_of_grouping" */
export type StopsDatabasePurposeOfGroupingAggregateFields = {
  readonly __typename?: 'stops_database_purpose_of_grouping_aggregate_fields';
  readonly avg?: Maybe<StopsDatabasePurposeOfGroupingAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabasePurposeOfGroupingMaxFields>;
  readonly min?: Maybe<StopsDatabasePurposeOfGroupingMinFields>;
  readonly stddev?: Maybe<StopsDatabasePurposeOfGroupingStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabasePurposeOfGroupingStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabasePurposeOfGroupingStddevSampFields>;
  readonly sum?: Maybe<StopsDatabasePurposeOfGroupingSumFields>;
  readonly var_pop?: Maybe<StopsDatabasePurposeOfGroupingVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabasePurposeOfGroupingVarSampFields>;
  readonly variance?: Maybe<StopsDatabasePurposeOfGroupingVarianceFields>;
};


/** aggregate fields of "purpose_of_grouping" */
export type StopsDatabasePurposeOfGroupingAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabasePurposeOfGroupingSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabasePurposeOfGroupingAvgFields = {
  readonly __typename?: 'stops_database_purpose_of_grouping_avg_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "purpose_of_grouping". All fields are combined with a logical 'AND'. */
export type StopsDatabasePurposeOfGroupingBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabasePurposeOfGroupingBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabasePurposeOfGroupingBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabasePurposeOfGroupingBoolExp>>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly description_lang?: InputMaybe<StringComparisonExp>;
  readonly description_value?: InputMaybe<StringComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly name_lang?: InputMaybe<StringComparisonExp>;
  readonly name_value?: InputMaybe<StringComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "purpose_of_grouping" */
export enum StopsDatabasePurposeOfGroupingConstraint {
  /** unique or primary key constraint on columns "name_value" */
  PurposeOfGroupingNameValueConstraint = 'purpose_of_grouping_name_value_constraint',
  /** unique or primary key constraint on columns "netex_id" */
  PurposeOfGroupingNetexIdVersionConstraint = 'purpose_of_grouping_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  PurposeOfGroupingPkey = 'purpose_of_grouping_pkey'
}

/** input type for incrementing numeric columns in table "purpose_of_grouping" */
export type StopsDatabasePurposeOfGroupingIncInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "purpose_of_grouping" */
export type StopsDatabasePurposeOfGroupingInsertInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "purpose_of_grouping_key_values" */
export type StopsDatabasePurposeOfGroupingKeyValues = {
  readonly __typename?: 'stops_database_purpose_of_grouping_key_values';
  readonly key_values_id: Scalars['bigint']['output'];
  readonly key_values_key: Scalars['String']['output'];
  readonly purpose_of_grouping_id: Scalars['bigint']['output'];
};

/** aggregated selection of "purpose_of_grouping_key_values" */
export type StopsDatabasePurposeOfGroupingKeyValuesAggregate = {
  readonly __typename?: 'stops_database_purpose_of_grouping_key_values_aggregate';
  readonly aggregate?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabasePurposeOfGroupingKeyValues>;
};

/** aggregate fields of "purpose_of_grouping_key_values" */
export type StopsDatabasePurposeOfGroupingKeyValuesAggregateFields = {
  readonly __typename?: 'stops_database_purpose_of_grouping_key_values_aggregate_fields';
  readonly avg?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesMaxFields>;
  readonly min?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesMinFields>;
  readonly stddev?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesSumFields>;
  readonly var_pop?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesVarSampFields>;
  readonly variance?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesVarianceFields>;
};


/** aggregate fields of "purpose_of_grouping_key_values" */
export type StopsDatabasePurposeOfGroupingKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabasePurposeOfGroupingKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabasePurposeOfGroupingKeyValuesAvgFields = {
  readonly __typename?: 'stops_database_purpose_of_grouping_key_values_avg_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly purpose_of_grouping_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "purpose_of_grouping_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabasePurposeOfGroupingKeyValuesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabasePurposeOfGroupingKeyValuesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabasePurposeOfGroupingKeyValuesBoolExp>>;
  readonly key_values_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_key?: InputMaybe<StringComparisonExp>;
  readonly purpose_of_grouping_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "purpose_of_grouping_key_values" */
export enum StopsDatabasePurposeOfGroupingKeyValuesConstraint {
  /** unique or primary key constraint on columns "purpose_of_grouping_id", "key_values_key" */
  PurposeOfGroupingKeyValuesPkey = 'purpose_of_grouping_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  PurposeOfGroupingKeyValuesUniqueKey = 'purpose_of_grouping_key_values_unique_key'
}

/** input type for incrementing numeric columns in table "purpose_of_grouping_key_values" */
export type StopsDatabasePurposeOfGroupingKeyValuesIncInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly purpose_of_grouping_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "purpose_of_grouping_key_values" */
export type StopsDatabasePurposeOfGroupingKeyValuesInsertInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly purpose_of_grouping_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabasePurposeOfGroupingKeyValuesMaxFields = {
  readonly __typename?: 'stops_database_purpose_of_grouping_key_values_max_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
  readonly purpose_of_grouping_id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type StopsDatabasePurposeOfGroupingKeyValuesMinFields = {
  readonly __typename?: 'stops_database_purpose_of_grouping_key_values_min_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
  readonly purpose_of_grouping_id?: Maybe<Scalars['bigint']['output']>;
};

/** response of any mutation on the table "purpose_of_grouping_key_values" */
export type StopsDatabasePurposeOfGroupingKeyValuesMutationResponse = {
  readonly __typename?: 'stops_database_purpose_of_grouping_key_values_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabasePurposeOfGroupingKeyValues>;
};

/** on_conflict condition type for table "purpose_of_grouping_key_values" */
export type StopsDatabasePurposeOfGroupingKeyValuesOnConflict = {
  readonly constraint: StopsDatabasePurposeOfGroupingKeyValuesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabasePurposeOfGroupingKeyValuesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "purpose_of_grouping_key_values". */
export type StopsDatabasePurposeOfGroupingKeyValuesOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly purpose_of_grouping_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: purpose_of_grouping_key_values */
export type StopsDatabasePurposeOfGroupingKeyValuesPkColumnsInput = {
  readonly key_values_key: Scalars['String']['input'];
  readonly purpose_of_grouping_id: Scalars['bigint']['input'];
};

/** select columns of table "purpose_of_grouping_key_values" */
export enum StopsDatabasePurposeOfGroupingKeyValuesSelectColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  PurposeOfGroupingId = 'purpose_of_grouping_id'
}

/** input type for updating data in table "purpose_of_grouping_key_values" */
export type StopsDatabasePurposeOfGroupingKeyValuesSetInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly purpose_of_grouping_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabasePurposeOfGroupingKeyValuesStddevFields = {
  readonly __typename?: 'stops_database_purpose_of_grouping_key_values_stddev_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly purpose_of_grouping_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabasePurposeOfGroupingKeyValuesStddevPopFields = {
  readonly __typename?: 'stops_database_purpose_of_grouping_key_values_stddev_pop_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly purpose_of_grouping_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabasePurposeOfGroupingKeyValuesStddevSampFields = {
  readonly __typename?: 'stops_database_purpose_of_grouping_key_values_stddev_samp_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly purpose_of_grouping_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "purpose_of_grouping_key_values" */
export type StopsDatabasePurposeOfGroupingKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabasePurposeOfGroupingKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabasePurposeOfGroupingKeyValuesStreamCursorValueInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly purpose_of_grouping_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabasePurposeOfGroupingKeyValuesSumFields = {
  readonly __typename?: 'stops_database_purpose_of_grouping_key_values_sum_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly purpose_of_grouping_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "purpose_of_grouping_key_values" */
export enum StopsDatabasePurposeOfGroupingKeyValuesUpdateColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  PurposeOfGroupingId = 'purpose_of_grouping_id'
}

export type StopsDatabasePurposeOfGroupingKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabasePurposeOfGroupingKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabasePurposeOfGroupingKeyValuesVarPopFields = {
  readonly __typename?: 'stops_database_purpose_of_grouping_key_values_var_pop_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly purpose_of_grouping_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabasePurposeOfGroupingKeyValuesVarSampFields = {
  readonly __typename?: 'stops_database_purpose_of_grouping_key_values_var_samp_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly purpose_of_grouping_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabasePurposeOfGroupingKeyValuesVarianceFields = {
  readonly __typename?: 'stops_database_purpose_of_grouping_key_values_variance_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly purpose_of_grouping_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate max on columns */
export type StopsDatabasePurposeOfGroupingMaxFields = {
  readonly __typename?: 'stops_database_purpose_of_grouping_max_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabasePurposeOfGroupingMinFields = {
  readonly __typename?: 'stops_database_purpose_of_grouping_min_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "purpose_of_grouping" */
export type StopsDatabasePurposeOfGroupingMutationResponse = {
  readonly __typename?: 'stops_database_purpose_of_grouping_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabasePurposeOfGrouping>;
};

/** on_conflict condition type for table "purpose_of_grouping" */
export type StopsDatabasePurposeOfGroupingOnConflict = {
  readonly constraint: StopsDatabasePurposeOfGroupingConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabasePurposeOfGroupingUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabasePurposeOfGroupingBoolExp>;
};

/** Ordering options when selecting data from "purpose_of_grouping". */
export type StopsDatabasePurposeOfGroupingOrderBy = {
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly description_lang?: InputMaybe<OrderBy>;
  readonly description_value?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly name_lang?: InputMaybe<OrderBy>;
  readonly name_value?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: purpose_of_grouping */
export type StopsDatabasePurposeOfGroupingPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "purpose_of_grouping" */
export enum StopsDatabasePurposeOfGroupingSelectColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

/** input type for updating data in table "purpose_of_grouping" */
export type StopsDatabasePurposeOfGroupingSetInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabasePurposeOfGroupingStddevFields = {
  readonly __typename?: 'stops_database_purpose_of_grouping_stddev_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabasePurposeOfGroupingStddevPopFields = {
  readonly __typename?: 'stops_database_purpose_of_grouping_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabasePurposeOfGroupingStddevSampFields = {
  readonly __typename?: 'stops_database_purpose_of_grouping_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "purpose_of_grouping" */
export type StopsDatabasePurposeOfGroupingStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabasePurposeOfGroupingStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabasePurposeOfGroupingStreamCursorValueInput = {
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabasePurposeOfGroupingSumFields = {
  readonly __typename?: 'stops_database_purpose_of_grouping_sum_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "purpose_of_grouping" */
export enum StopsDatabasePurposeOfGroupingUpdateColumn {
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

export type StopsDatabasePurposeOfGroupingUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabasePurposeOfGroupingIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabasePurposeOfGroupingSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabasePurposeOfGroupingBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabasePurposeOfGroupingVarPopFields = {
  readonly __typename?: 'stops_database_purpose_of_grouping_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabasePurposeOfGroupingVarSampFields = {
  readonly __typename?: 'stops_database_purpose_of_grouping_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabasePurposeOfGroupingVarianceFields = {
  readonly __typename?: 'stops_database_purpose_of_grouping_variance_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "quay" */
export type StopsDatabaseQuay = {
  readonly __typename?: 'stops_database_quay';
  /** An object relationship */
  readonly accessibility_assessment?: Maybe<StopsDatabaseAccessibilityAssessment>;
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly all_areas_wheelchair_accessible?: Maybe<Scalars['Boolean']['output']>;
  readonly centroid?: Maybe<Scalars['geometry']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly compass_bearing?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id: Scalars['bigint']['output'];
  /** An object relationship */
  readonly installed_equipment_version_structure?: Maybe<StopsDatabaseInstalledEquipmentVersionStructure>;
  readonly label_lang?: Maybe<Scalars['String']['output']>;
  readonly label_value?: Maybe<Scalars['String']['output']>;
  readonly level_ref?: Maybe<Scalars['String']['output']>;
  readonly level_ref_version?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  readonly persistable_polygon?: Maybe<StopsDatabasePersistablePolygon>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly public_code?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  readonly quay_alternative_names: ReadonlyArray<StopsDatabaseQuayAlternativeNames>;
  /** An aggregate relationship */
  readonly quay_alternative_names_aggregate: StopsDatabaseQuayAlternativeNamesAggregate;
  /** An array relationship */
  readonly quay_boarding_positions: ReadonlyArray<StopsDatabaseQuayBoardingPositions>;
  /** An aggregate relationship */
  readonly quay_boarding_positions_aggregate: StopsDatabaseQuayBoardingPositionsAggregate;
  /** An array relationship */
  readonly quay_equipment_places: ReadonlyArray<StopsDatabaseQuayEquipmentPlaces>;
  /** An aggregate relationship */
  readonly quay_equipment_places_aggregate: StopsDatabaseQuayEquipmentPlacesAggregate;
  /** An array relationship */
  readonly quay_key_values: ReadonlyArray<StopsDatabaseQuayKeyValues>;
  /** An aggregate relationship */
  readonly quay_key_values_aggregate: StopsDatabaseQuayKeyValuesAggregate;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly site_ref?: Maybe<Scalars['String']['output']>;
  readonly site_ref_version?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "quay" */
export type StopsDatabaseQuayQuayAlternativeNamesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayAlternativeNamesBoolExp>;
};


/** columns and relationships of "quay" */
export type StopsDatabaseQuayQuayAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayAlternativeNamesBoolExp>;
};


/** columns and relationships of "quay" */
export type StopsDatabaseQuayQuayBoardingPositionsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayBoardingPositionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayBoardingPositionsOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayBoardingPositionsBoolExp>;
};


/** columns and relationships of "quay" */
export type StopsDatabaseQuayQuayBoardingPositionsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayBoardingPositionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayBoardingPositionsOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayBoardingPositionsBoolExp>;
};


/** columns and relationships of "quay" */
export type StopsDatabaseQuayQuayEquipmentPlacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayEquipmentPlacesBoolExp>;
};


/** columns and relationships of "quay" */
export type StopsDatabaseQuayQuayEquipmentPlacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayEquipmentPlacesBoolExp>;
};


/** columns and relationships of "quay" */
export type StopsDatabaseQuayQuayKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayKeyValuesBoolExp>;
};


/** columns and relationships of "quay" */
export type StopsDatabaseQuayQuayKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayKeyValuesBoolExp>;
};

/** aggregated selection of "quay" */
export type StopsDatabaseQuayAggregate = {
  readonly __typename?: 'stops_database_quay_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseQuayAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseQuay>;
};

/** aggregate fields of "quay" */
export type StopsDatabaseQuayAggregateFields = {
  readonly __typename?: 'stops_database_quay_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseQuayAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseQuayMaxFields>;
  readonly min?: Maybe<StopsDatabaseQuayMinFields>;
  readonly stddev?: Maybe<StopsDatabaseQuayStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseQuayStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseQuayStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseQuaySumFields>;
  readonly var_pop?: Maybe<StopsDatabaseQuayVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseQuayVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseQuayVarianceFields>;
};


/** aggregate fields of "quay" */
export type StopsDatabaseQuayAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseQuaySelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** columns and relationships of "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNames = {
  readonly __typename?: 'stops_database_quay_alternative_names';
  /** An object relationship */
  readonly alternative_name: StopsDatabaseAlternativeName;
  readonly alternative_names_id: Scalars['bigint']['output'];
  readonly quay_id: Scalars['bigint']['output'];
};

/** aggregated selection of "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesAggregate = {
  readonly __typename?: 'stops_database_quay_alternative_names_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseQuayAlternativeNamesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseQuayAlternativeNames>;
};

/** aggregate fields of "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesAggregateFields = {
  readonly __typename?: 'stops_database_quay_alternative_names_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseQuayAlternativeNamesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseQuayAlternativeNamesMaxFields>;
  readonly min?: Maybe<StopsDatabaseQuayAlternativeNamesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseQuayAlternativeNamesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseQuayAlternativeNamesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseQuayAlternativeNamesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseQuayAlternativeNamesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseQuayAlternativeNamesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseQuayAlternativeNamesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseQuayAlternativeNamesVarianceFields>;
};


/** aggregate fields of "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseQuayAlternativeNamesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseQuayAlternativeNamesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseQuayAlternativeNamesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseQuayAlternativeNamesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseQuayAlternativeNamesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseQuayAlternativeNamesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseQuayAlternativeNamesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseQuayAlternativeNamesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseQuayAlternativeNamesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseQuayAlternativeNamesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseQuayAlternativeNamesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseQuayAlternativeNamesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseQuayAlternativeNamesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseQuayAlternativeNamesAvgFields = {
  readonly __typename?: 'stops_database_quay_alternative_names_avg_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesAvgOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "quay_alternative_names". All fields are combined with a logical 'AND'. */
export type StopsDatabaseQuayAlternativeNamesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseQuayAlternativeNamesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseQuayAlternativeNamesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseQuayAlternativeNamesBoolExp>>;
  readonly alternative_name?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
  readonly alternative_names_id?: InputMaybe<BigintComparisonExp>;
  readonly quay_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "quay_alternative_names" */
export enum StopsDatabaseQuayAlternativeNamesConstraint {
  /** unique or primary key constraint on columns "alternative_names_id" */
  Uk_6h2bs7xhqq2ca64hjpp8can1w = 'uk_6h2bs7xhqq2ca64hjpp8can1w'
}

/** input type for incrementing numeric columns in table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesIncInput = {
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly quay_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesInsertInput = {
  readonly alternative_name?: InputMaybe<StopsDatabaseAlternativeNameObjRelInsertInput>;
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly quay_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseQuayAlternativeNamesMaxFields = {
  readonly __typename?: 'stops_database_quay_alternative_names_max_fields';
  readonly alternative_names_id?: Maybe<Scalars['bigint']['output']>;
  readonly quay_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesMaxOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseQuayAlternativeNamesMinFields = {
  readonly __typename?: 'stops_database_quay_alternative_names_min_fields';
  readonly alternative_names_id?: Maybe<Scalars['bigint']['output']>;
  readonly quay_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesMinOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesMutationResponse = {
  readonly __typename?: 'stops_database_quay_alternative_names_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseQuayAlternativeNames>;
};

/** on_conflict condition type for table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesOnConflict = {
  readonly constraint: StopsDatabaseQuayAlternativeNamesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseQuayAlternativeNamesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseQuayAlternativeNamesBoolExp>;
};

/** Ordering options when selecting data from "quay_alternative_names". */
export type StopsDatabaseQuayAlternativeNamesOrderBy = {
  readonly alternative_name?: InputMaybe<StopsDatabaseAlternativeNameOrderBy>;
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** select columns of table "quay_alternative_names" */
export enum StopsDatabaseQuayAlternativeNamesSelectColumn {
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
  /** column name */
  QuayId = 'quay_id'
}

/** input type for updating data in table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesSetInput = {
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly quay_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseQuayAlternativeNamesStddevFields = {
  readonly __typename?: 'stops_database_quay_alternative_names_stddev_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesStddevOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseQuayAlternativeNamesStddevPopFields = {
  readonly __typename?: 'stops_database_quay_alternative_names_stddev_pop_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesStddevPopOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseQuayAlternativeNamesStddevSampFields = {
  readonly __typename?: 'stops_database_quay_alternative_names_stddev_samp_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesStddevSampOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseQuayAlternativeNamesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseQuayAlternativeNamesStreamCursorValueInput = {
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly quay_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseQuayAlternativeNamesSumFields = {
  readonly __typename?: 'stops_database_quay_alternative_names_sum_fields';
  readonly alternative_names_id?: Maybe<Scalars['bigint']['output']>;
  readonly quay_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesSumOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** update columns of table "quay_alternative_names" */
export enum StopsDatabaseQuayAlternativeNamesUpdateColumn {
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
  /** column name */
  QuayId = 'quay_id'
}

export type StopsDatabaseQuayAlternativeNamesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseQuayAlternativeNamesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseQuayAlternativeNamesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseQuayAlternativeNamesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseQuayAlternativeNamesVarPopFields = {
  readonly __typename?: 'stops_database_quay_alternative_names_var_pop_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesVarPopOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseQuayAlternativeNamesVarSampFields = {
  readonly __typename?: 'stops_database_quay_alternative_names_var_samp_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesVarSampOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseQuayAlternativeNamesVarianceFields = {
  readonly __typename?: 'stops_database_quay_alternative_names_variance_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "quay_alternative_names" */
export type StopsDatabaseQuayAlternativeNamesVarianceOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** aggregate avg on columns */
export type StopsDatabaseQuayAvgFields = {
  readonly __typename?: 'stops_database_quay_avg_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly compass_bearing?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositions = {
  readonly __typename?: 'stops_database_quay_boarding_positions';
  /** An object relationship */
  readonly boarding_position: StopsDatabaseBoardingPosition;
  readonly boarding_positions_id: Scalars['bigint']['output'];
  readonly quay_id: Scalars['bigint']['output'];
};

/** aggregated selection of "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsAggregate = {
  readonly __typename?: 'stops_database_quay_boarding_positions_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseQuayBoardingPositionsAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseQuayBoardingPositions>;
};

/** aggregate fields of "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsAggregateFields = {
  readonly __typename?: 'stops_database_quay_boarding_positions_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseQuayBoardingPositionsAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseQuayBoardingPositionsMaxFields>;
  readonly min?: Maybe<StopsDatabaseQuayBoardingPositionsMinFields>;
  readonly stddev?: Maybe<StopsDatabaseQuayBoardingPositionsStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseQuayBoardingPositionsStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseQuayBoardingPositionsStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseQuayBoardingPositionsSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseQuayBoardingPositionsVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseQuayBoardingPositionsVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseQuayBoardingPositionsVarianceFields>;
};


/** aggregate fields of "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseQuayBoardingPositionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseQuayBoardingPositionsAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseQuayBoardingPositionsMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseQuayBoardingPositionsMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseQuayBoardingPositionsStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseQuayBoardingPositionsStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseQuayBoardingPositionsStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseQuayBoardingPositionsSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseQuayBoardingPositionsVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseQuayBoardingPositionsVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseQuayBoardingPositionsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseQuayBoardingPositionsInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseQuayBoardingPositionsOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseQuayBoardingPositionsAvgFields = {
  readonly __typename?: 'stops_database_quay_boarding_positions_avg_fields';
  readonly boarding_positions_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsAvgOrderBy = {
  readonly boarding_positions_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "quay_boarding_positions". All fields are combined with a logical 'AND'. */
export type StopsDatabaseQuayBoardingPositionsBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseQuayBoardingPositionsBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseQuayBoardingPositionsBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseQuayBoardingPositionsBoolExp>>;
  readonly boarding_position?: InputMaybe<StopsDatabaseBoardingPositionBoolExp>;
  readonly boarding_positions_id?: InputMaybe<BigintComparisonExp>;
  readonly quay_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "quay_boarding_positions" */
export enum StopsDatabaseQuayBoardingPositionsConstraint {
  /** unique or primary key constraint on columns "boarding_positions_id" */
  UkLx6ql0b834b5l0agvouh1w860 = 'uk_lx6ql0b834b5l0agvouh1w860'
}

/** input type for incrementing numeric columns in table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsIncInput = {
  readonly boarding_positions_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly quay_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsInsertInput = {
  readonly boarding_position?: InputMaybe<StopsDatabaseBoardingPositionObjRelInsertInput>;
  readonly boarding_positions_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly quay_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseQuayBoardingPositionsMaxFields = {
  readonly __typename?: 'stops_database_quay_boarding_positions_max_fields';
  readonly boarding_positions_id?: Maybe<Scalars['bigint']['output']>;
  readonly quay_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsMaxOrderBy = {
  readonly boarding_positions_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseQuayBoardingPositionsMinFields = {
  readonly __typename?: 'stops_database_quay_boarding_positions_min_fields';
  readonly boarding_positions_id?: Maybe<Scalars['bigint']['output']>;
  readonly quay_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsMinOrderBy = {
  readonly boarding_positions_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsMutationResponse = {
  readonly __typename?: 'stops_database_quay_boarding_positions_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseQuayBoardingPositions>;
};

/** on_conflict condition type for table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsOnConflict = {
  readonly constraint: StopsDatabaseQuayBoardingPositionsConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseQuayBoardingPositionsUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseQuayBoardingPositionsBoolExp>;
};

/** Ordering options when selecting data from "quay_boarding_positions". */
export type StopsDatabaseQuayBoardingPositionsOrderBy = {
  readonly boarding_position?: InputMaybe<StopsDatabaseBoardingPositionOrderBy>;
  readonly boarding_positions_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** select columns of table "quay_boarding_positions" */
export enum StopsDatabaseQuayBoardingPositionsSelectColumn {
  /** column name */
  BoardingPositionsId = 'boarding_positions_id',
  /** column name */
  QuayId = 'quay_id'
}

/** input type for updating data in table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsSetInput = {
  readonly boarding_positions_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly quay_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseQuayBoardingPositionsStddevFields = {
  readonly __typename?: 'stops_database_quay_boarding_positions_stddev_fields';
  readonly boarding_positions_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsStddevOrderBy = {
  readonly boarding_positions_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseQuayBoardingPositionsStddevPopFields = {
  readonly __typename?: 'stops_database_quay_boarding_positions_stddev_pop_fields';
  readonly boarding_positions_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsStddevPopOrderBy = {
  readonly boarding_positions_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseQuayBoardingPositionsStddevSampFields = {
  readonly __typename?: 'stops_database_quay_boarding_positions_stddev_samp_fields';
  readonly boarding_positions_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsStddevSampOrderBy = {
  readonly boarding_positions_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseQuayBoardingPositionsStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseQuayBoardingPositionsStreamCursorValueInput = {
  readonly boarding_positions_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly quay_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseQuayBoardingPositionsSumFields = {
  readonly __typename?: 'stops_database_quay_boarding_positions_sum_fields';
  readonly boarding_positions_id?: Maybe<Scalars['bigint']['output']>;
  readonly quay_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsSumOrderBy = {
  readonly boarding_positions_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** update columns of table "quay_boarding_positions" */
export enum StopsDatabaseQuayBoardingPositionsUpdateColumn {
  /** column name */
  BoardingPositionsId = 'boarding_positions_id',
  /** column name */
  QuayId = 'quay_id'
}

export type StopsDatabaseQuayBoardingPositionsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseQuayBoardingPositionsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseQuayBoardingPositionsSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseQuayBoardingPositionsBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseQuayBoardingPositionsVarPopFields = {
  readonly __typename?: 'stops_database_quay_boarding_positions_var_pop_fields';
  readonly boarding_positions_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsVarPopOrderBy = {
  readonly boarding_positions_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseQuayBoardingPositionsVarSampFields = {
  readonly __typename?: 'stops_database_quay_boarding_positions_var_samp_fields';
  readonly boarding_positions_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsVarSampOrderBy = {
  readonly boarding_positions_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseQuayBoardingPositionsVarianceFields = {
  readonly __typename?: 'stops_database_quay_boarding_positions_variance_fields';
  readonly boarding_positions_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "quay_boarding_positions" */
export type StopsDatabaseQuayBoardingPositionsVarianceOrderBy = {
  readonly boarding_positions_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "quay". All fields are combined with a logical 'AND'. */
export type StopsDatabaseQuayBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseQuayBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseQuayBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseQuayBoolExp>>;
  readonly accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentBoolExp>;
  readonly accessibility_assessment_id?: InputMaybe<BigintComparisonExp>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<BooleanComparisonExp>;
  readonly centroid?: InputMaybe<GeometryComparisonExp>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly compass_bearing?: InputMaybe<FloatComparisonExp>;
  readonly covered?: InputMaybe<IntComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly description_lang?: InputMaybe<StringComparisonExp>;
  readonly description_value?: InputMaybe<StringComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
  readonly label_lang?: InputMaybe<StringComparisonExp>;
  readonly label_value?: InputMaybe<StringComparisonExp>;
  readonly level_ref?: InputMaybe<StringComparisonExp>;
  readonly level_ref_version?: InputMaybe<StringComparisonExp>;
  readonly name_lang?: InputMaybe<StringComparisonExp>;
  readonly name_value?: InputMaybe<StringComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  readonly place_equipments_id?: InputMaybe<BigintComparisonExp>;
  readonly polygon_id?: InputMaybe<BigintComparisonExp>;
  readonly private_code_type?: InputMaybe<StringComparisonExp>;
  readonly private_code_value?: InputMaybe<StringComparisonExp>;
  readonly public_code?: InputMaybe<StringComparisonExp>;
  readonly quay_alternative_names?: InputMaybe<StopsDatabaseQuayAlternativeNamesBoolExp>;
  readonly quay_alternative_names_aggregate?: InputMaybe<QuayAlternativeNamesAggregateBoolExp>;
  readonly quay_boarding_positions?: InputMaybe<StopsDatabaseQuayBoardingPositionsBoolExp>;
  readonly quay_boarding_positions_aggregate?: InputMaybe<QuayBoardingPositionsAggregateBoolExp>;
  readonly quay_equipment_places?: InputMaybe<StopsDatabaseQuayEquipmentPlacesBoolExp>;
  readonly quay_equipment_places_aggregate?: InputMaybe<QuayEquipmentPlacesAggregateBoolExp>;
  readonly quay_key_values?: InputMaybe<StopsDatabaseQuayKeyValuesBoolExp>;
  readonly quay_key_values_aggregate?: InputMaybe<QuayKeyValuesAggregateBoolExp>;
  readonly short_name_lang?: InputMaybe<StringComparisonExp>;
  readonly short_name_value?: InputMaybe<StringComparisonExp>;
  readonly site_ref?: InputMaybe<StringComparisonExp>;
  readonly site_ref_version?: InputMaybe<StringComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
};

/** columns and relationships of "quay_check_constraints" */
export type StopsDatabaseQuayCheckConstraints = {
  readonly __typename?: 'stops_database_quay_check_constraints';
  readonly check_constraints_id: Scalars['bigint']['output'];
  readonly quay_id: Scalars['bigint']['output'];
};

/** aggregated selection of "quay_check_constraints" */
export type StopsDatabaseQuayCheckConstraintsAggregate = {
  readonly __typename?: 'stops_database_quay_check_constraints_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseQuayCheckConstraintsAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseQuayCheckConstraints>;
};

/** aggregate fields of "quay_check_constraints" */
export type StopsDatabaseQuayCheckConstraintsAggregateFields = {
  readonly __typename?: 'stops_database_quay_check_constraints_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseQuayCheckConstraintsAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseQuayCheckConstraintsMaxFields>;
  readonly min?: Maybe<StopsDatabaseQuayCheckConstraintsMinFields>;
  readonly stddev?: Maybe<StopsDatabaseQuayCheckConstraintsStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseQuayCheckConstraintsStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseQuayCheckConstraintsStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseQuayCheckConstraintsSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseQuayCheckConstraintsVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseQuayCheckConstraintsVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseQuayCheckConstraintsVarianceFields>;
};


/** aggregate fields of "quay_check_constraints" */
export type StopsDatabaseQuayCheckConstraintsAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseQuayCheckConstraintsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseQuayCheckConstraintsAvgFields = {
  readonly __typename?: 'stops_database_quay_check_constraints_avg_fields';
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "quay_check_constraints". All fields are combined with a logical 'AND'. */
export type StopsDatabaseQuayCheckConstraintsBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseQuayCheckConstraintsBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseQuayCheckConstraintsBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseQuayCheckConstraintsBoolExp>>;
  readonly check_constraints_id?: InputMaybe<BigintComparisonExp>;
  readonly quay_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "quay_check_constraints" */
export enum StopsDatabaseQuayCheckConstraintsConstraint {
  /** unique or primary key constraint on columns "check_constraints_id" */
  Uk_1tirlnmtpwtd5i69kn8hy05v6 = 'uk_1tirlnmtpwtd5i69kn8hy05v6'
}

/** input type for incrementing numeric columns in table "quay_check_constraints" */
export type StopsDatabaseQuayCheckConstraintsIncInput = {
  readonly check_constraints_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly quay_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "quay_check_constraints" */
export type StopsDatabaseQuayCheckConstraintsInsertInput = {
  readonly check_constraints_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly quay_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseQuayCheckConstraintsMaxFields = {
  readonly __typename?: 'stops_database_quay_check_constraints_max_fields';
  readonly check_constraints_id?: Maybe<Scalars['bigint']['output']>;
  readonly quay_id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseQuayCheckConstraintsMinFields = {
  readonly __typename?: 'stops_database_quay_check_constraints_min_fields';
  readonly check_constraints_id?: Maybe<Scalars['bigint']['output']>;
  readonly quay_id?: Maybe<Scalars['bigint']['output']>;
};

/** response of any mutation on the table "quay_check_constraints" */
export type StopsDatabaseQuayCheckConstraintsMutationResponse = {
  readonly __typename?: 'stops_database_quay_check_constraints_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseQuayCheckConstraints>;
};

/** on_conflict condition type for table "quay_check_constraints" */
export type StopsDatabaseQuayCheckConstraintsOnConflict = {
  readonly constraint: StopsDatabaseQuayCheckConstraintsConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseQuayCheckConstraintsUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseQuayCheckConstraintsBoolExp>;
};

/** Ordering options when selecting data from "quay_check_constraints". */
export type StopsDatabaseQuayCheckConstraintsOrderBy = {
  readonly check_constraints_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** select columns of table "quay_check_constraints" */
export enum StopsDatabaseQuayCheckConstraintsSelectColumn {
  /** column name */
  CheckConstraintsId = 'check_constraints_id',
  /** column name */
  QuayId = 'quay_id'
}

/** input type for updating data in table "quay_check_constraints" */
export type StopsDatabaseQuayCheckConstraintsSetInput = {
  readonly check_constraints_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly quay_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseQuayCheckConstraintsStddevFields = {
  readonly __typename?: 'stops_database_quay_check_constraints_stddev_fields';
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseQuayCheckConstraintsStddevPopFields = {
  readonly __typename?: 'stops_database_quay_check_constraints_stddev_pop_fields';
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseQuayCheckConstraintsStddevSampFields = {
  readonly __typename?: 'stops_database_quay_check_constraints_stddev_samp_fields';
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "quay_check_constraints" */
export type StopsDatabaseQuayCheckConstraintsStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseQuayCheckConstraintsStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseQuayCheckConstraintsStreamCursorValueInput = {
  readonly check_constraints_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly quay_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseQuayCheckConstraintsSumFields = {
  readonly __typename?: 'stops_database_quay_check_constraints_sum_fields';
  readonly check_constraints_id?: Maybe<Scalars['bigint']['output']>;
  readonly quay_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "quay_check_constraints" */
export enum StopsDatabaseQuayCheckConstraintsUpdateColumn {
  /** column name */
  CheckConstraintsId = 'check_constraints_id',
  /** column name */
  QuayId = 'quay_id'
}

export type StopsDatabaseQuayCheckConstraintsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseQuayCheckConstraintsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseQuayCheckConstraintsSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseQuayCheckConstraintsBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseQuayCheckConstraintsVarPopFields = {
  readonly __typename?: 'stops_database_quay_check_constraints_var_pop_fields';
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseQuayCheckConstraintsVarSampFields = {
  readonly __typename?: 'stops_database_quay_check_constraints_var_samp_fields';
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseQuayCheckConstraintsVarianceFields = {
  readonly __typename?: 'stops_database_quay_check_constraints_variance_fields';
  readonly check_constraints_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** unique or primary key constraints on table "quay" */
export enum StopsDatabaseQuayConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  QuayNetexIdVersionConstraint = 'quay_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  QuayPkey = 'quay_pkey'
}

/** columns and relationships of "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlaces = {
  readonly __typename?: 'stops_database_quay_equipment_places';
  /** An object relationship */
  readonly equipment_place: StopsDatabaseEquipmentPlace;
  readonly equipment_places_id: Scalars['bigint']['output'];
  readonly quay_id: Scalars['bigint']['output'];
};

/** aggregated selection of "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesAggregate = {
  readonly __typename?: 'stops_database_quay_equipment_places_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseQuayEquipmentPlacesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseQuayEquipmentPlaces>;
};

/** aggregate fields of "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesAggregateFields = {
  readonly __typename?: 'stops_database_quay_equipment_places_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseQuayEquipmentPlacesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseQuayEquipmentPlacesMaxFields>;
  readonly min?: Maybe<StopsDatabaseQuayEquipmentPlacesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseQuayEquipmentPlacesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseQuayEquipmentPlacesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseQuayEquipmentPlacesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseQuayEquipmentPlacesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseQuayEquipmentPlacesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseQuayEquipmentPlacesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseQuayEquipmentPlacesVarianceFields>;
};


/** aggregate fields of "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseQuayEquipmentPlacesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseQuayEquipmentPlacesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseQuayEquipmentPlacesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseQuayEquipmentPlacesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseQuayEquipmentPlacesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseQuayEquipmentPlacesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseQuayEquipmentPlacesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseQuayEquipmentPlacesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseQuayEquipmentPlacesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseQuayEquipmentPlacesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseQuayEquipmentPlacesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseQuayEquipmentPlacesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseQuayEquipmentPlacesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseQuayEquipmentPlacesAvgFields = {
  readonly __typename?: 'stops_database_quay_equipment_places_avg_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesAvgOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "quay_equipment_places". All fields are combined with a logical 'AND'. */
export type StopsDatabaseQuayEquipmentPlacesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseQuayEquipmentPlacesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseQuayEquipmentPlacesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseQuayEquipmentPlacesBoolExp>>;
  readonly equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceBoolExp>;
  readonly equipment_places_id?: InputMaybe<BigintComparisonExp>;
  readonly quay_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "quay_equipment_places" */
export enum StopsDatabaseQuayEquipmentPlacesConstraint {
  /** unique or primary key constraint on columns "equipment_places_id" */
  Uk_2kygsfeskolk0dcv3580xknh4 = 'uk_2kygsfeskolk0dcv3580xknh4'
}

/** input type for incrementing numeric columns in table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesIncInput = {
  readonly equipment_places_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly quay_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesInsertInput = {
  readonly equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceObjRelInsertInput>;
  readonly equipment_places_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly quay_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseQuayEquipmentPlacesMaxFields = {
  readonly __typename?: 'stops_database_quay_equipment_places_max_fields';
  readonly equipment_places_id?: Maybe<Scalars['bigint']['output']>;
  readonly quay_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesMaxOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseQuayEquipmentPlacesMinFields = {
  readonly __typename?: 'stops_database_quay_equipment_places_min_fields';
  readonly equipment_places_id?: Maybe<Scalars['bigint']['output']>;
  readonly quay_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesMinOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesMutationResponse = {
  readonly __typename?: 'stops_database_quay_equipment_places_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseQuayEquipmentPlaces>;
};

/** on_conflict condition type for table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesOnConflict = {
  readonly constraint: StopsDatabaseQuayEquipmentPlacesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseQuayEquipmentPlacesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseQuayEquipmentPlacesBoolExp>;
};

/** Ordering options when selecting data from "quay_equipment_places". */
export type StopsDatabaseQuayEquipmentPlacesOrderBy = {
  readonly equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceOrderBy>;
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** select columns of table "quay_equipment_places" */
export enum StopsDatabaseQuayEquipmentPlacesSelectColumn {
  /** column name */
  EquipmentPlacesId = 'equipment_places_id',
  /** column name */
  QuayId = 'quay_id'
}

/** input type for updating data in table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesSetInput = {
  readonly equipment_places_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly quay_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseQuayEquipmentPlacesStddevFields = {
  readonly __typename?: 'stops_database_quay_equipment_places_stddev_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesStddevOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseQuayEquipmentPlacesStddevPopFields = {
  readonly __typename?: 'stops_database_quay_equipment_places_stddev_pop_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesStddevPopOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseQuayEquipmentPlacesStddevSampFields = {
  readonly __typename?: 'stops_database_quay_equipment_places_stddev_samp_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesStddevSampOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseQuayEquipmentPlacesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseQuayEquipmentPlacesStreamCursorValueInput = {
  readonly equipment_places_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly quay_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseQuayEquipmentPlacesSumFields = {
  readonly __typename?: 'stops_database_quay_equipment_places_sum_fields';
  readonly equipment_places_id?: Maybe<Scalars['bigint']['output']>;
  readonly quay_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesSumOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** update columns of table "quay_equipment_places" */
export enum StopsDatabaseQuayEquipmentPlacesUpdateColumn {
  /** column name */
  EquipmentPlacesId = 'equipment_places_id',
  /** column name */
  QuayId = 'quay_id'
}

export type StopsDatabaseQuayEquipmentPlacesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseQuayEquipmentPlacesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseQuayEquipmentPlacesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseQuayEquipmentPlacesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseQuayEquipmentPlacesVarPopFields = {
  readonly __typename?: 'stops_database_quay_equipment_places_var_pop_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesVarPopOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseQuayEquipmentPlacesVarSampFields = {
  readonly __typename?: 'stops_database_quay_equipment_places_var_samp_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesVarSampOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseQuayEquipmentPlacesVarianceFields = {
  readonly __typename?: 'stops_database_quay_equipment_places_variance_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "quay_equipment_places" */
export type StopsDatabaseQuayEquipmentPlacesVarianceOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** input type for incrementing numeric columns in table "quay" */
export type StopsDatabaseQuayIncInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly compass_bearing?: InputMaybe<Scalars['Float']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "quay" */
export type StopsDatabaseQuayInsertInput = {
  readonly accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentObjRelInsertInput>;
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly compass_bearing?: InputMaybe<Scalars['Float']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureObjRelInsertInput>;
  readonly label_lang?: InputMaybe<Scalars['String']['input']>;
  readonly label_value?: InputMaybe<Scalars['String']['input']>;
  readonly level_ref?: InputMaybe<Scalars['String']['input']>;
  readonly level_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonObjRelInsertInput>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly public_code?: InputMaybe<Scalars['String']['input']>;
  readonly quay_alternative_names?: InputMaybe<StopsDatabaseQuayAlternativeNamesArrRelInsertInput>;
  readonly quay_boarding_positions?: InputMaybe<StopsDatabaseQuayBoardingPositionsArrRelInsertInput>;
  readonly quay_equipment_places?: InputMaybe<StopsDatabaseQuayEquipmentPlacesArrRelInsertInput>;
  readonly quay_key_values?: InputMaybe<StopsDatabaseQuayKeyValuesArrRelInsertInput>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "quay_key_values" */
export type StopsDatabaseQuayKeyValues = {
  readonly __typename?: 'stops_database_quay_key_values';
  readonly key_values_id: Scalars['bigint']['output'];
  readonly key_values_key: Scalars['String']['output'];
  readonly quay_id: Scalars['bigint']['output'];
  /** An object relationship */
  readonly value: StopsDatabaseValue;
};

/** aggregated selection of "quay_key_values" */
export type StopsDatabaseQuayKeyValuesAggregate = {
  readonly __typename?: 'stops_database_quay_key_values_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseQuayKeyValuesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseQuayKeyValues>;
};

/** aggregate fields of "quay_key_values" */
export type StopsDatabaseQuayKeyValuesAggregateFields = {
  readonly __typename?: 'stops_database_quay_key_values_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseQuayKeyValuesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseQuayKeyValuesMaxFields>;
  readonly min?: Maybe<StopsDatabaseQuayKeyValuesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseQuayKeyValuesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseQuayKeyValuesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseQuayKeyValuesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseQuayKeyValuesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseQuayKeyValuesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseQuayKeyValuesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseQuayKeyValuesVarianceFields>;
};


/** aggregate fields of "quay_key_values" */
export type StopsDatabaseQuayKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseQuayKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseQuayKeyValuesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseQuayKeyValuesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseQuayKeyValuesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseQuayKeyValuesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseQuayKeyValuesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseQuayKeyValuesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseQuayKeyValuesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseQuayKeyValuesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseQuayKeyValuesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseQuayKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseQuayKeyValuesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseQuayKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseQuayKeyValuesAvgFields = {
  readonly __typename?: 'stops_database_quay_key_values_avg_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesAvgOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "quay_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseQuayKeyValuesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseQuayKeyValuesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseQuayKeyValuesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseQuayKeyValuesBoolExp>>;
  readonly key_values_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_key?: InputMaybe<StringComparisonExp>;
  readonly quay_id?: InputMaybe<BigintComparisonExp>;
  readonly value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "quay_key_values" */
export enum StopsDatabaseQuayKeyValuesConstraint {
  /** unique or primary key constraint on columns "key_values_key", "quay_id" */
  QuayKeyValuesPkey = 'quay_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkPlgcx1aoolr4vngts8ifkrse6 = 'uk_plgcx1aoolr4vngts8ifkrse6'
}

/** input type for incrementing numeric columns in table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesIncInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly quay_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesInsertInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly quay_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseQuayKeyValuesMaxFields = {
  readonly __typename?: 'stops_database_quay_key_values_max_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
  readonly quay_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesMaxOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseQuayKeyValuesMinFields = {
  readonly __typename?: 'stops_database_quay_key_values_min_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
  readonly quay_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesMinOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesMutationResponse = {
  readonly __typename?: 'stops_database_quay_key_values_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseQuayKeyValues>;
};

/** on_conflict condition type for table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesOnConflict = {
  readonly constraint: StopsDatabaseQuayKeyValuesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseQuayKeyValuesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseQuayKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "quay_key_values". */
export type StopsDatabaseQuayKeyValuesOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
  readonly value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: quay_key_values */
export type StopsDatabaseQuayKeyValuesPkColumnsInput = {
  readonly key_values_key: Scalars['String']['input'];
  readonly quay_id: Scalars['bigint']['input'];
};

/** select columns of table "quay_key_values" */
export enum StopsDatabaseQuayKeyValuesSelectColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  QuayId = 'quay_id'
}

/** input type for updating data in table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesSetInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly quay_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseQuayKeyValuesStddevFields = {
  readonly __typename?: 'stops_database_quay_key_values_stddev_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesStddevOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseQuayKeyValuesStddevPopFields = {
  readonly __typename?: 'stops_database_quay_key_values_stddev_pop_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesStddevPopOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseQuayKeyValuesStddevSampFields = {
  readonly __typename?: 'stops_database_quay_key_values_stddev_samp_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesStddevSampOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseQuayKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseQuayKeyValuesStreamCursorValueInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly quay_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseQuayKeyValuesSumFields = {
  readonly __typename?: 'stops_database_quay_key_values_sum_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly quay_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesSumOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** update columns of table "quay_key_values" */
export enum StopsDatabaseQuayKeyValuesUpdateColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  QuayId = 'quay_id'
}

export type StopsDatabaseQuayKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseQuayKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseQuayKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseQuayKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseQuayKeyValuesVarPopFields = {
  readonly __typename?: 'stops_database_quay_key_values_var_pop_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesVarPopOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseQuayKeyValuesVarSampFields = {
  readonly __typename?: 'stops_database_quay_key_values_var_samp_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesVarSampOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseQuayKeyValuesVarianceFields = {
  readonly __typename?: 'stops_database_quay_key_values_variance_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly quay_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "quay_key_values" */
export type StopsDatabaseQuayKeyValuesVarianceOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly quay_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseQuayMaxFields = {
  readonly __typename?: 'stops_database_quay_max_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly compass_bearing?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly label_lang?: Maybe<Scalars['String']['output']>;
  readonly label_value?: Maybe<Scalars['String']['output']>;
  readonly level_ref?: Maybe<Scalars['String']['output']>;
  readonly level_ref_version?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly public_code?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly site_ref?: Maybe<Scalars['String']['output']>;
  readonly site_ref_version?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseQuayMinFields = {
  readonly __typename?: 'stops_database_quay_min_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly compass_bearing?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly label_lang?: Maybe<Scalars['String']['output']>;
  readonly label_value?: Maybe<Scalars['String']['output']>;
  readonly level_ref?: Maybe<Scalars['String']['output']>;
  readonly level_ref_version?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly public_code?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly site_ref?: Maybe<Scalars['String']['output']>;
  readonly site_ref_version?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "quay" */
export type StopsDatabaseQuayMutationResponse = {
  readonly __typename?: 'stops_database_quay_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseQuay>;
};

/** columns and relationships of "quay_newest_version" */
export type StopsDatabaseQuayNewestVersion = {
  readonly __typename?: 'stops_database_quay_newest_version';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly all_areas_wheelchair_accessible?: Maybe<Scalars['Boolean']['output']>;
  readonly centroid?: Maybe<Scalars['geometry']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly compass_bearing?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly ely_code?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  readonly equipment?: Maybe<StopsDatabasePlaceEquipment>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly functional_area?: Maybe<Scalars['String']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly label_lang?: Maybe<Scalars['String']['output']>;
  readonly label_value?: Maybe<Scalars['String']['output']>;
  readonly level_ref?: Maybe<Scalars['String']['output']>;
  readonly level_ref_version?: Maybe<Scalars['String']['output']>;
  readonly location_swe?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly postal_code?: Maybe<Scalars['String']['output']>;
  readonly priority?: Maybe<Scalars['String']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly public_code?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  readonly quay_alternative_names: ReadonlyArray<StopsDatabaseQuayAlternativeNames>;
  /** An aggregate relationship */
  readonly quay_alternative_names_aggregate: StopsDatabaseQuayAlternativeNamesAggregate;
  /** An array relationship */
  readonly quay_key_values: ReadonlyArray<StopsDatabaseQuayKeyValues>;
  /** An aggregate relationship */
  readonly quay_key_values_aggregate: StopsDatabaseQuayKeyValuesAggregate;
  readonly scheduled_stop_point_instance?: Maybe<ServicePatternScheduledStopPoint>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly site_ref?: Maybe<Scalars['String']['output']>;
  readonly site_ref_version?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  readonly stopPlaceParent?: Maybe<StopsDatabaseStopPlaceChildren>;
  /** An object relationship */
  readonly stop_place?: Maybe<StopsDatabaseStopPlace>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly stop_place_netex_id?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  readonly stop_place_newest_version?: Maybe<StopsDatabaseStopPlaceNewestVersion>;
  readonly stop_place_version?: Maybe<Scalars['bigint']['output']>;
  readonly street_address?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly validity_end?: Maybe<Scalars['String']['output']>;
  readonly validity_start?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "quay_newest_version" */
export type StopsDatabaseQuayNewestVersionQuayAlternativeNamesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayAlternativeNamesBoolExp>;
};


/** columns and relationships of "quay_newest_version" */
export type StopsDatabaseQuayNewestVersionQuayAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayAlternativeNamesBoolExp>;
};


/** columns and relationships of "quay_newest_version" */
export type StopsDatabaseQuayNewestVersionQuayKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayKeyValuesBoolExp>;
};


/** columns and relationships of "quay_newest_version" */
export type StopsDatabaseQuayNewestVersionQuayKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayKeyValuesBoolExp>;
};

/** aggregated selection of "quay_newest_version" */
export type StopsDatabaseQuayNewestVersionAggregate = {
  readonly __typename?: 'stops_database_quay_newest_version_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseQuayNewestVersionAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseQuayNewestVersion>;
};

/** aggregate fields of "quay_newest_version" */
export type StopsDatabaseQuayNewestVersionAggregateFields = {
  readonly __typename?: 'stops_database_quay_newest_version_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseQuayNewestVersionAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseQuayNewestVersionMaxFields>;
  readonly min?: Maybe<StopsDatabaseQuayNewestVersionMinFields>;
  readonly stddev?: Maybe<StopsDatabaseQuayNewestVersionStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseQuayNewestVersionStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseQuayNewestVersionStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseQuayNewestVersionSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseQuayNewestVersionVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseQuayNewestVersionVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseQuayNewestVersionVarianceFields>;
};


/** aggregate fields of "quay_newest_version" */
export type StopsDatabaseQuayNewestVersionAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseQuayNewestVersionSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseQuayNewestVersionAvgFields = {
  readonly __typename?: 'stops_database_quay_newest_version_avg_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly compass_bearing?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_version?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "quay_newest_version". All fields are combined with a logical 'AND'. */
export type StopsDatabaseQuayNewestVersionBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseQuayNewestVersionBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseQuayNewestVersionBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseQuayNewestVersionBoolExp>>;
  readonly accessibility_assessment_id?: InputMaybe<BigintComparisonExp>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<BooleanComparisonExp>;
  readonly centroid?: InputMaybe<GeometryComparisonExp>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly compass_bearing?: InputMaybe<FloatComparisonExp>;
  readonly covered?: InputMaybe<IntComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly description_lang?: InputMaybe<StringComparisonExp>;
  readonly description_value?: InputMaybe<StringComparisonExp>;
  readonly ely_code?: InputMaybe<StringComparisonExp>;
  readonly equipment?: InputMaybe<StopsDatabasePlaceEquipmentBoolExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly functional_area?: InputMaybe<StringComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly label_lang?: InputMaybe<StringComparisonExp>;
  readonly label_value?: InputMaybe<StringComparisonExp>;
  readonly level_ref?: InputMaybe<StringComparisonExp>;
  readonly level_ref_version?: InputMaybe<StringComparisonExp>;
  readonly location_swe?: InputMaybe<StringComparisonExp>;
  readonly name_lang?: InputMaybe<StringComparisonExp>;
  readonly name_value?: InputMaybe<StringComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly place_equipments_id?: InputMaybe<BigintComparisonExp>;
  readonly polygon_id?: InputMaybe<BigintComparisonExp>;
  readonly postal_code?: InputMaybe<StringComparisonExp>;
  readonly priority?: InputMaybe<StringComparisonExp>;
  readonly private_code_type?: InputMaybe<StringComparisonExp>;
  readonly private_code_value?: InputMaybe<StringComparisonExp>;
  readonly public_code?: InputMaybe<StringComparisonExp>;
  readonly quay_alternative_names?: InputMaybe<StopsDatabaseQuayAlternativeNamesBoolExp>;
  readonly quay_alternative_names_aggregate?: InputMaybe<QuayAlternativeNamesAggregateBoolExp>;
  readonly quay_key_values?: InputMaybe<StopsDatabaseQuayKeyValuesBoolExp>;
  readonly quay_key_values_aggregate?: InputMaybe<QuayKeyValuesAggregateBoolExp>;
  readonly short_name_lang?: InputMaybe<StringComparisonExp>;
  readonly short_name_value?: InputMaybe<StringComparisonExp>;
  readonly site_ref?: InputMaybe<StringComparisonExp>;
  readonly site_ref_version?: InputMaybe<StringComparisonExp>;
  readonly stopPlaceParent?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
  readonly stop_place?: InputMaybe<StopsDatabaseStopPlaceBoolExp>;
  readonly stop_place_id?: InputMaybe<BigintComparisonExp>;
  readonly stop_place_netex_id?: InputMaybe<StringComparisonExp>;
  readonly stop_place_newest_version?: InputMaybe<StopsDatabaseStopPlaceNewestVersionBoolExp>;
  readonly stop_place_version?: InputMaybe<BigintComparisonExp>;
  readonly street_address?: InputMaybe<StringComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly validity_end?: InputMaybe<StringComparisonExp>;
  readonly validity_start?: InputMaybe<StringComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
};

/** aggregate max on columns */
export type StopsDatabaseQuayNewestVersionMaxFields = {
  readonly __typename?: 'stops_database_quay_newest_version_max_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly compass_bearing?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly ely_code?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly functional_area?: Maybe<Scalars['String']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly label_lang?: Maybe<Scalars['String']['output']>;
  readonly label_value?: Maybe<Scalars['String']['output']>;
  readonly level_ref?: Maybe<Scalars['String']['output']>;
  readonly level_ref_version?: Maybe<Scalars['String']['output']>;
  readonly location_swe?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly postal_code?: Maybe<Scalars['String']['output']>;
  readonly priority?: Maybe<Scalars['String']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly public_code?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly site_ref?: Maybe<Scalars['String']['output']>;
  readonly site_ref_version?: Maybe<Scalars['String']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly stop_place_netex_id?: Maybe<Scalars['String']['output']>;
  readonly stop_place_version?: Maybe<Scalars['bigint']['output']>;
  readonly street_address?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly validity_end?: Maybe<Scalars['String']['output']>;
  readonly validity_start?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseQuayNewestVersionMinFields = {
  readonly __typename?: 'stops_database_quay_newest_version_min_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly compass_bearing?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly ely_code?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly functional_area?: Maybe<Scalars['String']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly label_lang?: Maybe<Scalars['String']['output']>;
  readonly label_value?: Maybe<Scalars['String']['output']>;
  readonly level_ref?: Maybe<Scalars['String']['output']>;
  readonly level_ref_version?: Maybe<Scalars['String']['output']>;
  readonly location_swe?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly postal_code?: Maybe<Scalars['String']['output']>;
  readonly priority?: Maybe<Scalars['String']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly public_code?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly site_ref?: Maybe<Scalars['String']['output']>;
  readonly site_ref_version?: Maybe<Scalars['String']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly stop_place_netex_id?: Maybe<Scalars['String']['output']>;
  readonly stop_place_version?: Maybe<Scalars['bigint']['output']>;
  readonly street_address?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly validity_end?: Maybe<Scalars['String']['output']>;
  readonly validity_start?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** Ordering options when selecting data from "quay_newest_version". */
export type StopsDatabaseQuayNewestVersionOrderBy = {
  readonly accessibility_assessment_id?: InputMaybe<OrderBy>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<OrderBy>;
  readonly centroid?: InputMaybe<OrderBy>;
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly compass_bearing?: InputMaybe<OrderBy>;
  readonly covered?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly description_lang?: InputMaybe<OrderBy>;
  readonly description_value?: InputMaybe<OrderBy>;
  readonly ely_code?: InputMaybe<OrderBy>;
  readonly equipment?: InputMaybe<StopsDatabasePlaceEquipmentOrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly functional_area?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly label_lang?: InputMaybe<OrderBy>;
  readonly label_value?: InputMaybe<OrderBy>;
  readonly level_ref?: InputMaybe<OrderBy>;
  readonly level_ref_version?: InputMaybe<OrderBy>;
  readonly location_swe?: InputMaybe<OrderBy>;
  readonly name_lang?: InputMaybe<OrderBy>;
  readonly name_value?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly place_equipments_id?: InputMaybe<OrderBy>;
  readonly polygon_id?: InputMaybe<OrderBy>;
  readonly postal_code?: InputMaybe<OrderBy>;
  readonly priority?: InputMaybe<OrderBy>;
  readonly private_code_type?: InputMaybe<OrderBy>;
  readonly private_code_value?: InputMaybe<OrderBy>;
  readonly public_code?: InputMaybe<OrderBy>;
  readonly quay_alternative_names_aggregate?: InputMaybe<StopsDatabaseQuayAlternativeNamesAggregateOrderBy>;
  readonly quay_key_values_aggregate?: InputMaybe<StopsDatabaseQuayKeyValuesAggregateOrderBy>;
  readonly short_name_lang?: InputMaybe<OrderBy>;
  readonly short_name_value?: InputMaybe<OrderBy>;
  readonly site_ref?: InputMaybe<OrderBy>;
  readonly site_ref_version?: InputMaybe<OrderBy>;
  readonly stopPlaceParent?: InputMaybe<StopsDatabaseStopPlaceChildrenOrderBy>;
  readonly stop_place?: InputMaybe<StopsDatabaseStopPlaceOrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
  readonly stop_place_netex_id?: InputMaybe<OrderBy>;
  readonly stop_place_newest_version?: InputMaybe<StopsDatabaseStopPlaceNewestVersionOrderBy>;
  readonly stop_place_version?: InputMaybe<OrderBy>;
  readonly street_address?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly validity_end?: InputMaybe<OrderBy>;
  readonly validity_start?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
};

/** select columns of table "quay_newest_version" */
export enum StopsDatabaseQuayNewestVersionSelectColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  CompassBearing = 'compass_bearing',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  ElyCode = 'ely_code',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  FunctionalArea = 'functional_area',
  /** column name */
  Id = 'id',
  /** column name */
  LabelLang = 'label_lang',
  /** column name */
  LabelValue = 'label_value',
  /** column name */
  LevelRef = 'level_ref',
  /** column name */
  LevelRefVersion = 'level_ref_version',
  /** column name */
  LocationSwe = 'location_swe',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PostalCode = 'postal_code',
  /** column name */
  Priority = 'priority',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  PublicCode = 'public_code',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  SiteRef = 'site_ref',
  /** column name */
  SiteRefVersion = 'site_ref_version',
  /** column name */
  StopPlaceId = 'stop_place_id',
  /** column name */
  StopPlaceNetexId = 'stop_place_netex_id',
  /** column name */
  StopPlaceVersion = 'stop_place_version',
  /** column name */
  StreetAddress = 'street_address',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  ValidityEnd = 'validity_end',
  /** column name */
  ValidityStart = 'validity_start',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

/** aggregate stddev on columns */
export type StopsDatabaseQuayNewestVersionStddevFields = {
  readonly __typename?: 'stops_database_quay_newest_version_stddev_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly compass_bearing?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_version?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseQuayNewestVersionStddevPopFields = {
  readonly __typename?: 'stops_database_quay_newest_version_stddev_pop_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly compass_bearing?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_version?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseQuayNewestVersionStddevSampFields = {
  readonly __typename?: 'stops_database_quay_newest_version_stddev_samp_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly compass_bearing?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_version?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "quay_newest_version" */
export type StopsDatabaseQuayNewestVersionStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseQuayNewestVersionStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseQuayNewestVersionStreamCursorValueInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly compass_bearing?: InputMaybe<Scalars['Float']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly ely_code?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly functional_area?: InputMaybe<Scalars['String']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly label_lang?: InputMaybe<Scalars['String']['input']>;
  readonly label_value?: InputMaybe<Scalars['String']['input']>;
  readonly level_ref?: InputMaybe<Scalars['String']['input']>;
  readonly level_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly location_swe?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly postal_code?: InputMaybe<Scalars['String']['input']>;
  readonly priority?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly public_code?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly stop_place_netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly stop_place_version?: InputMaybe<Scalars['bigint']['input']>;
  readonly street_address?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly validity_end?: InputMaybe<Scalars['String']['input']>;
  readonly validity_start?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseQuayNewestVersionSumFields = {
  readonly __typename?: 'stops_database_quay_newest_version_sum_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly compass_bearing?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly stop_place_version?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate var_pop on columns */
export type StopsDatabaseQuayNewestVersionVarPopFields = {
  readonly __typename?: 'stops_database_quay_newest_version_var_pop_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly compass_bearing?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_version?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseQuayNewestVersionVarSampFields = {
  readonly __typename?: 'stops_database_quay_newest_version_var_samp_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly compass_bearing?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_version?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseQuayNewestVersionVarianceFields = {
  readonly __typename?: 'stops_database_quay_newest_version_variance_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly compass_bearing?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_version?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** input type for inserting object relation for remote table "quay" */
export type StopsDatabaseQuayObjRelInsertInput = {
  readonly data: StopsDatabaseQuayInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseQuayOnConflict>;
};

/** on_conflict condition type for table "quay" */
export type StopsDatabaseQuayOnConflict = {
  readonly constraint: StopsDatabaseQuayConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseQuayUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseQuayBoolExp>;
};

/** Ordering options when selecting data from "quay". */
export type StopsDatabaseQuayOrderBy = {
  readonly accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentOrderBy>;
  readonly accessibility_assessment_id?: InputMaybe<OrderBy>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<OrderBy>;
  readonly centroid?: InputMaybe<OrderBy>;
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly compass_bearing?: InputMaybe<OrderBy>;
  readonly covered?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly description_lang?: InputMaybe<OrderBy>;
  readonly description_value?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureOrderBy>;
  readonly label_lang?: InputMaybe<OrderBy>;
  readonly label_value?: InputMaybe<OrderBy>;
  readonly level_ref?: InputMaybe<OrderBy>;
  readonly level_ref_version?: InputMaybe<OrderBy>;
  readonly name_lang?: InputMaybe<OrderBy>;
  readonly name_value?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonOrderBy>;
  readonly place_equipments_id?: InputMaybe<OrderBy>;
  readonly polygon_id?: InputMaybe<OrderBy>;
  readonly private_code_type?: InputMaybe<OrderBy>;
  readonly private_code_value?: InputMaybe<OrderBy>;
  readonly public_code?: InputMaybe<OrderBy>;
  readonly quay_alternative_names_aggregate?: InputMaybe<StopsDatabaseQuayAlternativeNamesAggregateOrderBy>;
  readonly quay_boarding_positions_aggregate?: InputMaybe<StopsDatabaseQuayBoardingPositionsAggregateOrderBy>;
  readonly quay_equipment_places_aggregate?: InputMaybe<StopsDatabaseQuayEquipmentPlacesAggregateOrderBy>;
  readonly quay_key_values_aggregate?: InputMaybe<StopsDatabaseQuayKeyValuesAggregateOrderBy>;
  readonly short_name_lang?: InputMaybe<OrderBy>;
  readonly short_name_value?: InputMaybe<OrderBy>;
  readonly site_ref?: InputMaybe<OrderBy>;
  readonly site_ref_version?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: quay */
export type StopsDatabaseQuayPkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "quay" */
export enum StopsDatabaseQuaySelectColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  CompassBearing = 'compass_bearing',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  LabelLang = 'label_lang',
  /** column name */
  LabelValue = 'label_value',
  /** column name */
  LevelRef = 'level_ref',
  /** column name */
  LevelRefVersion = 'level_ref_version',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  PublicCode = 'public_code',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  SiteRef = 'site_ref',
  /** column name */
  SiteRefVersion = 'site_ref_version',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

/** input type for updating data in table "quay" */
export type StopsDatabaseQuaySetInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly compass_bearing?: InputMaybe<Scalars['Float']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly label_lang?: InputMaybe<Scalars['String']['input']>;
  readonly label_value?: InputMaybe<Scalars['String']['input']>;
  readonly level_ref?: InputMaybe<Scalars['String']['input']>;
  readonly level_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly public_code?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseQuayStddevFields = {
  readonly __typename?: 'stops_database_quay_stddev_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly compass_bearing?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseQuayStddevPopFields = {
  readonly __typename?: 'stops_database_quay_stddev_pop_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly compass_bearing?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseQuayStddevSampFields = {
  readonly __typename?: 'stops_database_quay_stddev_samp_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly compass_bearing?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "quay" */
export type StopsDatabaseQuayStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseQuayStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseQuayStreamCursorValueInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly compass_bearing?: InputMaybe<Scalars['Float']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly label_lang?: InputMaybe<Scalars['String']['input']>;
  readonly label_value?: InputMaybe<Scalars['String']['input']>;
  readonly level_ref?: InputMaybe<Scalars['String']['input']>;
  readonly level_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly public_code?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref?: InputMaybe<Scalars['String']['input']>;
  readonly site_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseQuaySumFields = {
  readonly __typename?: 'stops_database_quay_sum_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly compass_bearing?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "quay" */
export enum StopsDatabaseQuayUpdateColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  CompassBearing = 'compass_bearing',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  LabelLang = 'label_lang',
  /** column name */
  LabelValue = 'label_value',
  /** column name */
  LevelRef = 'level_ref',
  /** column name */
  LevelRefVersion = 'level_ref_version',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  PublicCode = 'public_code',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  SiteRef = 'site_ref',
  /** column name */
  SiteRefVersion = 'site_ref_version',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

export type StopsDatabaseQuayUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseQuayIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseQuaySetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseQuayBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseQuayVarPopFields = {
  readonly __typename?: 'stops_database_quay_var_pop_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly compass_bearing?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseQuayVarSampFields = {
  readonly __typename?: 'stops_database_quay_var_samp_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly compass_bearing?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseQuayVarianceFields = {
  readonly __typename?: 'stops_database_quay_variance_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly compass_bearing?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "schema_version" */
export type StopsDatabaseSchemaVersion = {
  readonly __typename?: 'stops_database_schema_version';
  readonly checksum?: Maybe<Scalars['Int']['output']>;
  readonly description: Scalars['String']['output'];
  readonly execution_time: Scalars['Int']['output'];
  readonly installed_by: Scalars['String']['output'];
  readonly installed_on: Scalars['timestamp']['output'];
  readonly installed_rank: Scalars['Int']['output'];
  readonly script: Scalars['String']['output'];
  readonly success: Scalars['Boolean']['output'];
  readonly type: Scalars['String']['output'];
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "schema_version" */
export type StopsDatabaseSchemaVersionAggregate = {
  readonly __typename?: 'stops_database_schema_version_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseSchemaVersionAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseSchemaVersion>;
};

/** aggregate fields of "schema_version" */
export type StopsDatabaseSchemaVersionAggregateFields = {
  readonly __typename?: 'stops_database_schema_version_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseSchemaVersionAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseSchemaVersionMaxFields>;
  readonly min?: Maybe<StopsDatabaseSchemaVersionMinFields>;
  readonly stddev?: Maybe<StopsDatabaseSchemaVersionStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseSchemaVersionStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseSchemaVersionStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseSchemaVersionSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseSchemaVersionVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseSchemaVersionVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseSchemaVersionVarianceFields>;
};


/** aggregate fields of "schema_version" */
export type StopsDatabaseSchemaVersionAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseSchemaVersionSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseSchemaVersionAvgFields = {
  readonly __typename?: 'stops_database_schema_version_avg_fields';
  readonly checksum?: Maybe<Scalars['Float']['output']>;
  readonly execution_time?: Maybe<Scalars['Float']['output']>;
  readonly installed_rank?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "schema_version". All fields are combined with a logical 'AND'. */
export type StopsDatabaseSchemaVersionBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseSchemaVersionBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseSchemaVersionBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseSchemaVersionBoolExp>>;
  readonly checksum?: InputMaybe<IntComparisonExp>;
  readonly description?: InputMaybe<StringComparisonExp>;
  readonly execution_time?: InputMaybe<IntComparisonExp>;
  readonly installed_by?: InputMaybe<StringComparisonExp>;
  readonly installed_on?: InputMaybe<TimestampComparisonExp>;
  readonly installed_rank?: InputMaybe<IntComparisonExp>;
  readonly script?: InputMaybe<StringComparisonExp>;
  readonly success?: InputMaybe<BooleanComparisonExp>;
  readonly type?: InputMaybe<StringComparisonExp>;
  readonly version?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "schema_version" */
export enum StopsDatabaseSchemaVersionConstraint {
  /** unique or primary key constraint on columns "installed_rank" */
  SchemaVersionPk = 'schema_version_pk'
}

/** input type for incrementing numeric columns in table "schema_version" */
export type StopsDatabaseSchemaVersionIncInput = {
  readonly checksum?: InputMaybe<Scalars['Int']['input']>;
  readonly execution_time?: InputMaybe<Scalars['Int']['input']>;
  readonly installed_rank?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "schema_version" */
export type StopsDatabaseSchemaVersionInsertInput = {
  readonly checksum?: InputMaybe<Scalars['Int']['input']>;
  readonly description?: InputMaybe<Scalars['String']['input']>;
  readonly execution_time?: InputMaybe<Scalars['Int']['input']>;
  readonly installed_by?: InputMaybe<Scalars['String']['input']>;
  readonly installed_on?: InputMaybe<Scalars['timestamp']['input']>;
  readonly installed_rank?: InputMaybe<Scalars['Int']['input']>;
  readonly script?: InputMaybe<Scalars['String']['input']>;
  readonly success?: InputMaybe<Scalars['Boolean']['input']>;
  readonly type?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseSchemaVersionMaxFields = {
  readonly __typename?: 'stops_database_schema_version_max_fields';
  readonly checksum?: Maybe<Scalars['Int']['output']>;
  readonly description?: Maybe<Scalars['String']['output']>;
  readonly execution_time?: Maybe<Scalars['Int']['output']>;
  readonly installed_by?: Maybe<Scalars['String']['output']>;
  readonly installed_on?: Maybe<Scalars['timestamp']['output']>;
  readonly installed_rank?: Maybe<Scalars['Int']['output']>;
  readonly script?: Maybe<Scalars['String']['output']>;
  readonly type?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseSchemaVersionMinFields = {
  readonly __typename?: 'stops_database_schema_version_min_fields';
  readonly checksum?: Maybe<Scalars['Int']['output']>;
  readonly description?: Maybe<Scalars['String']['output']>;
  readonly execution_time?: Maybe<Scalars['Int']['output']>;
  readonly installed_by?: Maybe<Scalars['String']['output']>;
  readonly installed_on?: Maybe<Scalars['timestamp']['output']>;
  readonly installed_rank?: Maybe<Scalars['Int']['output']>;
  readonly script?: Maybe<Scalars['String']['output']>;
  readonly type?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "schema_version" */
export type StopsDatabaseSchemaVersionMutationResponse = {
  readonly __typename?: 'stops_database_schema_version_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseSchemaVersion>;
};

/** on_conflict condition type for table "schema_version" */
export type StopsDatabaseSchemaVersionOnConflict = {
  readonly constraint: StopsDatabaseSchemaVersionConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseSchemaVersionUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseSchemaVersionBoolExp>;
};

/** Ordering options when selecting data from "schema_version". */
export type StopsDatabaseSchemaVersionOrderBy = {
  readonly checksum?: InputMaybe<OrderBy>;
  readonly description?: InputMaybe<OrderBy>;
  readonly execution_time?: InputMaybe<OrderBy>;
  readonly installed_by?: InputMaybe<OrderBy>;
  readonly installed_on?: InputMaybe<OrderBy>;
  readonly installed_rank?: InputMaybe<OrderBy>;
  readonly script?: InputMaybe<OrderBy>;
  readonly success?: InputMaybe<OrderBy>;
  readonly type?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: schema_version */
export type StopsDatabaseSchemaVersionPkColumnsInput = {
  readonly installed_rank: Scalars['Int']['input'];
};

/** select columns of table "schema_version" */
export enum StopsDatabaseSchemaVersionSelectColumn {
  /** column name */
  Checksum = 'checksum',
  /** column name */
  Description = 'description',
  /** column name */
  ExecutionTime = 'execution_time',
  /** column name */
  InstalledBy = 'installed_by',
  /** column name */
  InstalledOn = 'installed_on',
  /** column name */
  InstalledRank = 'installed_rank',
  /** column name */
  Script = 'script',
  /** column name */
  Success = 'success',
  /** column name */
  Type = 'type',
  /** column name */
  Version = 'version'
}

/** input type for updating data in table "schema_version" */
export type StopsDatabaseSchemaVersionSetInput = {
  readonly checksum?: InputMaybe<Scalars['Int']['input']>;
  readonly description?: InputMaybe<Scalars['String']['input']>;
  readonly execution_time?: InputMaybe<Scalars['Int']['input']>;
  readonly installed_by?: InputMaybe<Scalars['String']['input']>;
  readonly installed_on?: InputMaybe<Scalars['timestamp']['input']>;
  readonly installed_rank?: InputMaybe<Scalars['Int']['input']>;
  readonly script?: InputMaybe<Scalars['String']['input']>;
  readonly success?: InputMaybe<Scalars['Boolean']['input']>;
  readonly type?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseSchemaVersionStddevFields = {
  readonly __typename?: 'stops_database_schema_version_stddev_fields';
  readonly checksum?: Maybe<Scalars['Float']['output']>;
  readonly execution_time?: Maybe<Scalars['Float']['output']>;
  readonly installed_rank?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseSchemaVersionStddevPopFields = {
  readonly __typename?: 'stops_database_schema_version_stddev_pop_fields';
  readonly checksum?: Maybe<Scalars['Float']['output']>;
  readonly execution_time?: Maybe<Scalars['Float']['output']>;
  readonly installed_rank?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseSchemaVersionStddevSampFields = {
  readonly __typename?: 'stops_database_schema_version_stddev_samp_fields';
  readonly checksum?: Maybe<Scalars['Float']['output']>;
  readonly execution_time?: Maybe<Scalars['Float']['output']>;
  readonly installed_rank?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "schema_version" */
export type StopsDatabaseSchemaVersionStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseSchemaVersionStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseSchemaVersionStreamCursorValueInput = {
  readonly checksum?: InputMaybe<Scalars['Int']['input']>;
  readonly description?: InputMaybe<Scalars['String']['input']>;
  readonly execution_time?: InputMaybe<Scalars['Int']['input']>;
  readonly installed_by?: InputMaybe<Scalars['String']['input']>;
  readonly installed_on?: InputMaybe<Scalars['timestamp']['input']>;
  readonly installed_rank?: InputMaybe<Scalars['Int']['input']>;
  readonly script?: InputMaybe<Scalars['String']['input']>;
  readonly success?: InputMaybe<Scalars['Boolean']['input']>;
  readonly type?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseSchemaVersionSumFields = {
  readonly __typename?: 'stops_database_schema_version_sum_fields';
  readonly checksum?: Maybe<Scalars['Int']['output']>;
  readonly execution_time?: Maybe<Scalars['Int']['output']>;
  readonly installed_rank?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "schema_version" */
export enum StopsDatabaseSchemaVersionUpdateColumn {
  /** column name */
  Checksum = 'checksum',
  /** column name */
  Description = 'description',
  /** column name */
  ExecutionTime = 'execution_time',
  /** column name */
  InstalledBy = 'installed_by',
  /** column name */
  InstalledOn = 'installed_on',
  /** column name */
  InstalledRank = 'installed_rank',
  /** column name */
  Script = 'script',
  /** column name */
  Success = 'success',
  /** column name */
  Type = 'type',
  /** column name */
  Version = 'version'
}

export type StopsDatabaseSchemaVersionUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseSchemaVersionIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseSchemaVersionSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseSchemaVersionBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseSchemaVersionVarPopFields = {
  readonly __typename?: 'stops_database_schema_version_var_pop_fields';
  readonly checksum?: Maybe<Scalars['Float']['output']>;
  readonly execution_time?: Maybe<Scalars['Float']['output']>;
  readonly installed_rank?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseSchemaVersionVarSampFields = {
  readonly __typename?: 'stops_database_schema_version_var_samp_fields';
  readonly checksum?: Maybe<Scalars['Float']['output']>;
  readonly execution_time?: Maybe<Scalars['Float']['output']>;
  readonly installed_rank?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseSchemaVersionVarianceFields = {
  readonly __typename?: 'stops_database_schema_version_variance_fields';
  readonly checksum?: Maybe<Scalars['Float']['output']>;
  readonly execution_time?: Maybe<Scalars['Float']['output']>;
  readonly installed_rank?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "spatial_ref_sys" */
export type StopsDatabaseSpatialRefSys = {
  readonly __typename?: 'stops_database_spatial_ref_sys';
  readonly auth_name?: Maybe<Scalars['String']['output']>;
  readonly auth_srid?: Maybe<Scalars['Int']['output']>;
  readonly proj4text?: Maybe<Scalars['String']['output']>;
  readonly srid: Scalars['Int']['output'];
  readonly srtext?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "spatial_ref_sys" */
export type StopsDatabaseSpatialRefSysAggregate = {
  readonly __typename?: 'stops_database_spatial_ref_sys_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseSpatialRefSysAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseSpatialRefSys>;
};

/** aggregate fields of "spatial_ref_sys" */
export type StopsDatabaseSpatialRefSysAggregateFields = {
  readonly __typename?: 'stops_database_spatial_ref_sys_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseSpatialRefSysAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseSpatialRefSysMaxFields>;
  readonly min?: Maybe<StopsDatabaseSpatialRefSysMinFields>;
  readonly stddev?: Maybe<StopsDatabaseSpatialRefSysStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseSpatialRefSysStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseSpatialRefSysStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseSpatialRefSysSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseSpatialRefSysVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseSpatialRefSysVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseSpatialRefSysVarianceFields>;
};


/** aggregate fields of "spatial_ref_sys" */
export type StopsDatabaseSpatialRefSysAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseSpatialRefSysSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseSpatialRefSysAvgFields = {
  readonly __typename?: 'stops_database_spatial_ref_sys_avg_fields';
  readonly auth_srid?: Maybe<Scalars['Float']['output']>;
  readonly srid?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "spatial_ref_sys". All fields are combined with a logical 'AND'. */
export type StopsDatabaseSpatialRefSysBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseSpatialRefSysBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseSpatialRefSysBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseSpatialRefSysBoolExp>>;
  readonly auth_name?: InputMaybe<StringComparisonExp>;
  readonly auth_srid?: InputMaybe<IntComparisonExp>;
  readonly proj4text?: InputMaybe<StringComparisonExp>;
  readonly srid?: InputMaybe<IntComparisonExp>;
  readonly srtext?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "spatial_ref_sys" */
export enum StopsDatabaseSpatialRefSysConstraint {
  /** unique or primary key constraint on columns "srid" */
  SpatialRefSysPkey = 'spatial_ref_sys_pkey'
}

/** input type for incrementing numeric columns in table "spatial_ref_sys" */
export type StopsDatabaseSpatialRefSysIncInput = {
  readonly auth_srid?: InputMaybe<Scalars['Int']['input']>;
  readonly srid?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "spatial_ref_sys" */
export type StopsDatabaseSpatialRefSysInsertInput = {
  readonly auth_name?: InputMaybe<Scalars['String']['input']>;
  readonly auth_srid?: InputMaybe<Scalars['Int']['input']>;
  readonly proj4text?: InputMaybe<Scalars['String']['input']>;
  readonly srid?: InputMaybe<Scalars['Int']['input']>;
  readonly srtext?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseSpatialRefSysMaxFields = {
  readonly __typename?: 'stops_database_spatial_ref_sys_max_fields';
  readonly auth_name?: Maybe<Scalars['String']['output']>;
  readonly auth_srid?: Maybe<Scalars['Int']['output']>;
  readonly proj4text?: Maybe<Scalars['String']['output']>;
  readonly srid?: Maybe<Scalars['Int']['output']>;
  readonly srtext?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseSpatialRefSysMinFields = {
  readonly __typename?: 'stops_database_spatial_ref_sys_min_fields';
  readonly auth_name?: Maybe<Scalars['String']['output']>;
  readonly auth_srid?: Maybe<Scalars['Int']['output']>;
  readonly proj4text?: Maybe<Scalars['String']['output']>;
  readonly srid?: Maybe<Scalars['Int']['output']>;
  readonly srtext?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "spatial_ref_sys" */
export type StopsDatabaseSpatialRefSysMutationResponse = {
  readonly __typename?: 'stops_database_spatial_ref_sys_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseSpatialRefSys>;
};

/** on_conflict condition type for table "spatial_ref_sys" */
export type StopsDatabaseSpatialRefSysOnConflict = {
  readonly constraint: StopsDatabaseSpatialRefSysConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseSpatialRefSysUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseSpatialRefSysBoolExp>;
};

/** Ordering options when selecting data from "spatial_ref_sys". */
export type StopsDatabaseSpatialRefSysOrderBy = {
  readonly auth_name?: InputMaybe<OrderBy>;
  readonly auth_srid?: InputMaybe<OrderBy>;
  readonly proj4text?: InputMaybe<OrderBy>;
  readonly srid?: InputMaybe<OrderBy>;
  readonly srtext?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: spatial_ref_sys */
export type StopsDatabaseSpatialRefSysPkColumnsInput = {
  readonly srid: Scalars['Int']['input'];
};

/** select columns of table "spatial_ref_sys" */
export enum StopsDatabaseSpatialRefSysSelectColumn {
  /** column name */
  AuthName = 'auth_name',
  /** column name */
  AuthSrid = 'auth_srid',
  /** column name */
  Proj4text = 'proj4text',
  /** column name */
  Srid = 'srid',
  /** column name */
  Srtext = 'srtext'
}

/** input type for updating data in table "spatial_ref_sys" */
export type StopsDatabaseSpatialRefSysSetInput = {
  readonly auth_name?: InputMaybe<Scalars['String']['input']>;
  readonly auth_srid?: InputMaybe<Scalars['Int']['input']>;
  readonly proj4text?: InputMaybe<Scalars['String']['input']>;
  readonly srid?: InputMaybe<Scalars['Int']['input']>;
  readonly srtext?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseSpatialRefSysStddevFields = {
  readonly __typename?: 'stops_database_spatial_ref_sys_stddev_fields';
  readonly auth_srid?: Maybe<Scalars['Float']['output']>;
  readonly srid?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseSpatialRefSysStddevPopFields = {
  readonly __typename?: 'stops_database_spatial_ref_sys_stddev_pop_fields';
  readonly auth_srid?: Maybe<Scalars['Float']['output']>;
  readonly srid?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseSpatialRefSysStddevSampFields = {
  readonly __typename?: 'stops_database_spatial_ref_sys_stddev_samp_fields';
  readonly auth_srid?: Maybe<Scalars['Float']['output']>;
  readonly srid?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "spatial_ref_sys" */
export type StopsDatabaseSpatialRefSysStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseSpatialRefSysStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseSpatialRefSysStreamCursorValueInput = {
  readonly auth_name?: InputMaybe<Scalars['String']['input']>;
  readonly auth_srid?: InputMaybe<Scalars['Int']['input']>;
  readonly proj4text?: InputMaybe<Scalars['String']['input']>;
  readonly srid?: InputMaybe<Scalars['Int']['input']>;
  readonly srtext?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseSpatialRefSysSumFields = {
  readonly __typename?: 'stops_database_spatial_ref_sys_sum_fields';
  readonly auth_srid?: Maybe<Scalars['Int']['output']>;
  readonly srid?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "spatial_ref_sys" */
export enum StopsDatabaseSpatialRefSysUpdateColumn {
  /** column name */
  AuthName = 'auth_name',
  /** column name */
  AuthSrid = 'auth_srid',
  /** column name */
  Proj4text = 'proj4text',
  /** column name */
  Srid = 'srid',
  /** column name */
  Srtext = 'srtext'
}

export type StopsDatabaseSpatialRefSysUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseSpatialRefSysIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseSpatialRefSysSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseSpatialRefSysBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseSpatialRefSysVarPopFields = {
  readonly __typename?: 'stops_database_spatial_ref_sys_var_pop_fields';
  readonly auth_srid?: Maybe<Scalars['Float']['output']>;
  readonly srid?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseSpatialRefSysVarSampFields = {
  readonly __typename?: 'stops_database_spatial_ref_sys_var_samp_fields';
  readonly auth_srid?: Maybe<Scalars['Float']['output']>;
  readonly srid?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseSpatialRefSysVarianceFields = {
  readonly __typename?: 'stops_database_spatial_ref_sys_variance_fields';
  readonly auth_srid?: Maybe<Scalars['Float']['output']>;
  readonly srid?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlace = {
  readonly __typename?: 'stops_database_stop_place';
  /** An object relationship */
  readonly accessibility_assessment?: Maybe<StopsDatabaseAccessibilityAssessment>;
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly air_submode?: Maybe<Scalars['String']['output']>;
  readonly all_areas_wheelchair_accessible?: Maybe<Scalars['Boolean']['output']>;
  readonly border_crossing?: Maybe<Scalars['Boolean']['output']>;
  readonly bus_submode?: Maybe<Scalars['String']['output']>;
  readonly centroid?: Maybe<Scalars['geometry']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly coach_submode?: Maybe<Scalars['String']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly funicular_submode?: Maybe<Scalars['String']['output']>;
  readonly id: Scalars['bigint']['output'];
  /** An object relationship */
  readonly installed_equipment_version_structure?: Maybe<StopsDatabaseInstalledEquipmentVersionStructure>;
  readonly metro_submode?: Maybe<Scalars['String']['output']>;
  readonly modification_enumeration?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly parent_site_ref?: Maybe<Scalars['String']['output']>;
  readonly parent_site_ref_version?: Maybe<Scalars['String']['output']>;
  readonly parent_stop_place: Scalars['Boolean']['output'];
  /** An object relationship */
  readonly persistable_polygon?: Maybe<StopsDatabasePersistablePolygon>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly public_code?: Maybe<Scalars['String']['output']>;
  readonly rail_submode?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  readonly stop_place_access_spaces: ReadonlyArray<StopsDatabaseStopPlaceAccessSpaces>;
  /** An aggregate relationship */
  readonly stop_place_access_spaces_aggregate: StopsDatabaseStopPlaceAccessSpacesAggregate;
  /** An array relationship */
  readonly stop_place_alternative_names: ReadonlyArray<StopsDatabaseStopPlaceAlternativeNames>;
  /** An aggregate relationship */
  readonly stop_place_alternative_names_aggregate: StopsDatabaseStopPlaceAlternativeNamesAggregate;
  /** An object relationship */
  readonly stop_place_child?: Maybe<StopsDatabaseStopPlaceChildren>;
  /** An array relationship */
  readonly stop_place_children: ReadonlyArray<StopsDatabaseStopPlaceChildren>;
  /** An aggregate relationship */
  readonly stop_place_children_aggregate: StopsDatabaseStopPlaceChildrenAggregate;
  /** An array relationship */
  readonly stop_place_equipment_places: ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlaces>;
  /** An aggregate relationship */
  readonly stop_place_equipment_places_aggregate: StopsDatabaseStopPlaceEquipmentPlacesAggregate;
  /** An array relationship */
  readonly stop_place_key_values: ReadonlyArray<StopsDatabaseStopPlaceKeyValues>;
  /** An aggregate relationship */
  readonly stop_place_key_values_aggregate: StopsDatabaseStopPlaceKeyValuesAggregate;
  /** An array relationship */
  readonly stop_place_quays: ReadonlyArray<StopsDatabaseStopPlaceQuays>;
  /** An aggregate relationship */
  readonly stop_place_quays_aggregate: StopsDatabaseStopPlaceQuaysAggregate;
  /** An array relationship */
  readonly stop_place_tariff_zones: ReadonlyArray<StopsDatabaseStopPlaceTariffZones>;
  /** An aggregate relationship */
  readonly stop_place_tariff_zones_aggregate: StopsDatabaseStopPlaceTariffZonesAggregate;
  readonly stop_place_type?: Maybe<Scalars['String']['output']>;
  readonly telecabin_submode?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  /** An object relationship */
  readonly topographic_place?: Maybe<StopsDatabaseTopographicPlace>;
  readonly topographic_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly tram_submode?: Maybe<Scalars['String']['output']>;
  readonly transport_mode?: Maybe<Scalars['String']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly water_submode?: Maybe<Scalars['String']['output']>;
  readonly weighting?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceAccessSpacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAccessSpacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAccessSpacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesBoolExp>;
};


/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceAccessSpacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAccessSpacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAccessSpacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesBoolExp>;
};


/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceAlternativeNamesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesBoolExp>;
};


/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesBoolExp>;
};


/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceChildrenArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceChildrenSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceChildrenOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
};


/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceChildrenAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceChildrenSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceChildrenOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
};


/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceEquipmentPlacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>;
};


/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceEquipmentPlacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>;
};


/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceKeyValuesBoolExp>;
};


/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceKeyValuesBoolExp>;
};


/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceQuaysArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceQuaysSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceQuaysOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceQuaysBoolExp>;
};


/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceQuaysAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceQuaysSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceQuaysOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceQuaysBoolExp>;
};


/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceTariffZonesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceTariffZonesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceTariffZonesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceTariffZonesBoolExp>;
};


/** columns and relationships of "stop_place" */
export type StopsDatabaseStopPlaceStopPlaceTariffZonesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceTariffZonesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceTariffZonesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceTariffZonesBoolExp>;
};

/** columns and relationships of "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpaces = {
  readonly __typename?: 'stops_database_stop_place_access_spaces';
  /** An object relationship */
  readonly access_space: StopsDatabaseAccessSpace;
  readonly access_spaces_id: Scalars['bigint']['output'];
  readonly stop_place_id: Scalars['bigint']['output'];
};

/** aggregated selection of "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesAggregate = {
  readonly __typename?: 'stops_database_stop_place_access_spaces_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseStopPlaceAccessSpacesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseStopPlaceAccessSpaces>;
};

/** aggregate fields of "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesAggregateFields = {
  readonly __typename?: 'stops_database_stop_place_access_spaces_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseStopPlaceAccessSpacesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseStopPlaceAccessSpacesMaxFields>;
  readonly min?: Maybe<StopsDatabaseStopPlaceAccessSpacesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseStopPlaceAccessSpacesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseStopPlaceAccessSpacesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseStopPlaceAccessSpacesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseStopPlaceAccessSpacesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseStopPlaceAccessSpacesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseStopPlaceAccessSpacesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseStopPlaceAccessSpacesVarianceFields>;
};


/** aggregate fields of "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAccessSpacesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseStopPlaceAccessSpacesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseStopPlaceAccessSpacesAvgFields = {
  readonly __typename?: 'stops_database_stop_place_access_spaces_avg_fields';
  readonly access_spaces_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesAvgOrderBy = {
  readonly access_spaces_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "stop_place_access_spaces". All fields are combined with a logical 'AND'. */
export type StopsDatabaseStopPlaceAccessSpacesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAccessSpacesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAccessSpacesBoolExp>>;
  readonly access_space?: InputMaybe<StopsDatabaseAccessSpaceBoolExp>;
  readonly access_spaces_id?: InputMaybe<BigintComparisonExp>;
  readonly stop_place_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "stop_place_access_spaces" */
export enum StopsDatabaseStopPlaceAccessSpacesConstraint {
  /** unique or primary key constraint on columns "access_spaces_id" */
  UkStiis59w04hmptq2wkpsfjpb8 = 'uk_stiis59w04hmptq2wkpsfjpb8'
}

/** input type for incrementing numeric columns in table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesIncInput = {
  readonly access_spaces_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesInsertInput = {
  readonly access_space?: InputMaybe<StopsDatabaseAccessSpaceObjRelInsertInput>;
  readonly access_spaces_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseStopPlaceAccessSpacesMaxFields = {
  readonly __typename?: 'stops_database_stop_place_access_spaces_max_fields';
  readonly access_spaces_id?: Maybe<Scalars['bigint']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesMaxOrderBy = {
  readonly access_spaces_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseStopPlaceAccessSpacesMinFields = {
  readonly __typename?: 'stops_database_stop_place_access_spaces_min_fields';
  readonly access_spaces_id?: Maybe<Scalars['bigint']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesMinOrderBy = {
  readonly access_spaces_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesMutationResponse = {
  readonly __typename?: 'stops_database_stop_place_access_spaces_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseStopPlaceAccessSpaces>;
};

/** on_conflict condition type for table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesOnConflict = {
  readonly constraint: StopsDatabaseStopPlaceAccessSpacesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseStopPlaceAccessSpacesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesBoolExp>;
};

/** Ordering options when selecting data from "stop_place_access_spaces". */
export type StopsDatabaseStopPlaceAccessSpacesOrderBy = {
  readonly access_space?: InputMaybe<StopsDatabaseAccessSpaceOrderBy>;
  readonly access_spaces_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** select columns of table "stop_place_access_spaces" */
export enum StopsDatabaseStopPlaceAccessSpacesSelectColumn {
  /** column name */
  AccessSpacesId = 'access_spaces_id',
  /** column name */
  StopPlaceId = 'stop_place_id'
}

/** input type for updating data in table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesSetInput = {
  readonly access_spaces_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseStopPlaceAccessSpacesStddevFields = {
  readonly __typename?: 'stops_database_stop_place_access_spaces_stddev_fields';
  readonly access_spaces_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesStddevOrderBy = {
  readonly access_spaces_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseStopPlaceAccessSpacesStddevPopFields = {
  readonly __typename?: 'stops_database_stop_place_access_spaces_stddev_pop_fields';
  readonly access_spaces_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesStddevPopOrderBy = {
  readonly access_spaces_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseStopPlaceAccessSpacesStddevSampFields = {
  readonly __typename?: 'stops_database_stop_place_access_spaces_stddev_samp_fields';
  readonly access_spaces_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesStddevSampOrderBy = {
  readonly access_spaces_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseStopPlaceAccessSpacesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseStopPlaceAccessSpacesStreamCursorValueInput = {
  readonly access_spaces_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseStopPlaceAccessSpacesSumFields = {
  readonly __typename?: 'stops_database_stop_place_access_spaces_sum_fields';
  readonly access_spaces_id?: Maybe<Scalars['bigint']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesSumOrderBy = {
  readonly access_spaces_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** update columns of table "stop_place_access_spaces" */
export enum StopsDatabaseStopPlaceAccessSpacesUpdateColumn {
  /** column name */
  AccessSpacesId = 'access_spaces_id',
  /** column name */
  StopPlaceId = 'stop_place_id'
}

export type StopsDatabaseStopPlaceAccessSpacesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseStopPlaceAccessSpacesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseStopPlaceAccessSpacesVarPopFields = {
  readonly __typename?: 'stops_database_stop_place_access_spaces_var_pop_fields';
  readonly access_spaces_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesVarPopOrderBy = {
  readonly access_spaces_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseStopPlaceAccessSpacesVarSampFields = {
  readonly __typename?: 'stops_database_stop_place_access_spaces_var_samp_fields';
  readonly access_spaces_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesVarSampOrderBy = {
  readonly access_spaces_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseStopPlaceAccessSpacesVarianceFields = {
  readonly __typename?: 'stops_database_stop_place_access_spaces_variance_fields';
  readonly access_spaces_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "stop_place_access_spaces" */
export type StopsDatabaseStopPlaceAccessSpacesVarianceOrderBy = {
  readonly access_spaces_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** columns and relationships of "stop_place_adjacent_sites" */
export type StopsDatabaseStopPlaceAdjacentSites = {
  readonly __typename?: 'stops_database_stop_place_adjacent_sites';
  readonly ref?: Maybe<Scalars['String']['output']>;
  readonly stop_place_id: Scalars['bigint']['output'];
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "stop_place_adjacent_sites" */
export type StopsDatabaseStopPlaceAdjacentSitesAggregate = {
  readonly __typename?: 'stops_database_stop_place_adjacent_sites_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseStopPlaceAdjacentSitesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseStopPlaceAdjacentSites>;
};

/** aggregate fields of "stop_place_adjacent_sites" */
export type StopsDatabaseStopPlaceAdjacentSitesAggregateFields = {
  readonly __typename?: 'stops_database_stop_place_adjacent_sites_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseStopPlaceAdjacentSitesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseStopPlaceAdjacentSitesMaxFields>;
  readonly min?: Maybe<StopsDatabaseStopPlaceAdjacentSitesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseStopPlaceAdjacentSitesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseStopPlaceAdjacentSitesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseStopPlaceAdjacentSitesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseStopPlaceAdjacentSitesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseStopPlaceAdjacentSitesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseStopPlaceAdjacentSitesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseStopPlaceAdjacentSitesVarianceFields>;
};


/** aggregate fields of "stop_place_adjacent_sites" */
export type StopsDatabaseStopPlaceAdjacentSitesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAdjacentSitesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseStopPlaceAdjacentSitesAvgFields = {
  readonly __typename?: 'stops_database_stop_place_adjacent_sites_avg_fields';
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "stop_place_adjacent_sites". All fields are combined with a logical 'AND'. */
export type StopsDatabaseStopPlaceAdjacentSitesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAdjacentSitesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseStopPlaceAdjacentSitesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAdjacentSitesBoolExp>>;
  readonly ref?: InputMaybe<StringComparisonExp>;
  readonly stop_place_id?: InputMaybe<BigintComparisonExp>;
  readonly version?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "stop_place_adjacent_sites" */
export type StopsDatabaseStopPlaceAdjacentSitesIncInput = {
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "stop_place_adjacent_sites" */
export type StopsDatabaseStopPlaceAdjacentSitesInsertInput = {
  readonly ref?: InputMaybe<Scalars['String']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseStopPlaceAdjacentSitesMaxFields = {
  readonly __typename?: 'stops_database_stop_place_adjacent_sites_max_fields';
  readonly ref?: Maybe<Scalars['String']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseStopPlaceAdjacentSitesMinFields = {
  readonly __typename?: 'stops_database_stop_place_adjacent_sites_min_fields';
  readonly ref?: Maybe<Scalars['String']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "stop_place_adjacent_sites" */
export type StopsDatabaseStopPlaceAdjacentSitesMutationResponse = {
  readonly __typename?: 'stops_database_stop_place_adjacent_sites_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseStopPlaceAdjacentSites>;
};

/** Ordering options when selecting data from "stop_place_adjacent_sites". */
export type StopsDatabaseStopPlaceAdjacentSitesOrderBy = {
  readonly ref?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
};

/** select columns of table "stop_place_adjacent_sites" */
export enum StopsDatabaseStopPlaceAdjacentSitesSelectColumn {
  /** column name */
  Ref = 'ref',
  /** column name */
  StopPlaceId = 'stop_place_id',
  /** column name */
  Version = 'version'
}

/** input type for updating data in table "stop_place_adjacent_sites" */
export type StopsDatabaseStopPlaceAdjacentSitesSetInput = {
  readonly ref?: InputMaybe<Scalars['String']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseStopPlaceAdjacentSitesStddevFields = {
  readonly __typename?: 'stops_database_stop_place_adjacent_sites_stddev_fields';
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseStopPlaceAdjacentSitesStddevPopFields = {
  readonly __typename?: 'stops_database_stop_place_adjacent_sites_stddev_pop_fields';
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseStopPlaceAdjacentSitesStddevSampFields = {
  readonly __typename?: 'stops_database_stop_place_adjacent_sites_stddev_samp_fields';
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "stop_place_adjacent_sites" */
export type StopsDatabaseStopPlaceAdjacentSitesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseStopPlaceAdjacentSitesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseStopPlaceAdjacentSitesStreamCursorValueInput = {
  readonly ref?: InputMaybe<Scalars['String']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseStopPlaceAdjacentSitesSumFields = {
  readonly __typename?: 'stops_database_stop_place_adjacent_sites_sum_fields';
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
};

export type StopsDatabaseStopPlaceAdjacentSitesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseStopPlaceAdjacentSitesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseStopPlaceAdjacentSitesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseStopPlaceAdjacentSitesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseStopPlaceAdjacentSitesVarPopFields = {
  readonly __typename?: 'stops_database_stop_place_adjacent_sites_var_pop_fields';
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseStopPlaceAdjacentSitesVarSampFields = {
  readonly __typename?: 'stops_database_stop_place_adjacent_sites_var_samp_fields';
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseStopPlaceAdjacentSitesVarianceFields = {
  readonly __typename?: 'stops_database_stop_place_adjacent_sites_variance_fields';
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregated selection of "stop_place" */
export type StopsDatabaseStopPlaceAggregate = {
  readonly __typename?: 'stops_database_stop_place_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseStopPlaceAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseStopPlace>;
};

/** aggregate fields of "stop_place" */
export type StopsDatabaseStopPlaceAggregateFields = {
  readonly __typename?: 'stops_database_stop_place_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseStopPlaceAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseStopPlaceMaxFields>;
  readonly min?: Maybe<StopsDatabaseStopPlaceMinFields>;
  readonly stddev?: Maybe<StopsDatabaseStopPlaceStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseStopPlaceStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseStopPlaceStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseStopPlaceSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseStopPlaceVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseStopPlaceVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseStopPlaceVarianceFields>;
};


/** aggregate fields of "stop_place" */
export type StopsDatabaseStopPlaceAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** columns and relationships of "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNames = {
  readonly __typename?: 'stops_database_stop_place_alternative_names';
  /** An object relationship */
  readonly alternative_name: StopsDatabaseAlternativeName;
  readonly alternative_names_id: Scalars['bigint']['output'];
  readonly stop_place_id: Scalars['bigint']['output'];
};

/** aggregated selection of "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesAggregate = {
  readonly __typename?: 'stops_database_stop_place_alternative_names_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseStopPlaceAlternativeNamesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseStopPlaceAlternativeNames>;
};

/** aggregate fields of "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesAggregateFields = {
  readonly __typename?: 'stops_database_stop_place_alternative_names_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseStopPlaceAlternativeNamesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseStopPlaceAlternativeNamesMaxFields>;
  readonly min?: Maybe<StopsDatabaseStopPlaceAlternativeNamesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseStopPlaceAlternativeNamesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseStopPlaceAlternativeNamesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseStopPlaceAlternativeNamesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseStopPlaceAlternativeNamesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseStopPlaceAlternativeNamesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseStopPlaceAlternativeNamesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseStopPlaceAlternativeNamesVarianceFields>;
};


/** aggregate fields of "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAlternativeNamesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseStopPlaceAlternativeNamesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseStopPlaceAlternativeNamesAvgFields = {
  readonly __typename?: 'stops_database_stop_place_alternative_names_avg_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesAvgOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "stop_place_alternative_names". All fields are combined with a logical 'AND'. */
export type StopsDatabaseStopPlaceAlternativeNamesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAlternativeNamesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAlternativeNamesBoolExp>>;
  readonly alternative_name?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
  readonly alternative_names_id?: InputMaybe<BigintComparisonExp>;
  readonly stop_place_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "stop_place_alternative_names" */
export enum StopsDatabaseStopPlaceAlternativeNamesConstraint {
  /** unique or primary key constraint on columns "alternative_names_id" */
  Uk_2mabhvrur7dd4xuqf7be5tq6h = 'uk_2mabhvrur7dd4xuqf7be5tq6h'
}

/** input type for incrementing numeric columns in table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesIncInput = {
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesInsertInput = {
  readonly alternative_name?: InputMaybe<StopsDatabaseAlternativeNameObjRelInsertInput>;
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseStopPlaceAlternativeNamesMaxFields = {
  readonly __typename?: 'stops_database_stop_place_alternative_names_max_fields';
  readonly alternative_names_id?: Maybe<Scalars['bigint']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesMaxOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseStopPlaceAlternativeNamesMinFields = {
  readonly __typename?: 'stops_database_stop_place_alternative_names_min_fields';
  readonly alternative_names_id?: Maybe<Scalars['bigint']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesMinOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesMutationResponse = {
  readonly __typename?: 'stops_database_stop_place_alternative_names_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseStopPlaceAlternativeNames>;
};

/** on_conflict condition type for table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesOnConflict = {
  readonly constraint: StopsDatabaseStopPlaceAlternativeNamesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseStopPlaceAlternativeNamesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesBoolExp>;
};

/** Ordering options when selecting data from "stop_place_alternative_names". */
export type StopsDatabaseStopPlaceAlternativeNamesOrderBy = {
  readonly alternative_name?: InputMaybe<StopsDatabaseAlternativeNameOrderBy>;
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** select columns of table "stop_place_alternative_names" */
export enum StopsDatabaseStopPlaceAlternativeNamesSelectColumn {
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
  /** column name */
  StopPlaceId = 'stop_place_id'
}

/** input type for updating data in table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesSetInput = {
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseStopPlaceAlternativeNamesStddevFields = {
  readonly __typename?: 'stops_database_stop_place_alternative_names_stddev_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesStddevOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseStopPlaceAlternativeNamesStddevPopFields = {
  readonly __typename?: 'stops_database_stop_place_alternative_names_stddev_pop_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesStddevPopOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseStopPlaceAlternativeNamesStddevSampFields = {
  readonly __typename?: 'stops_database_stop_place_alternative_names_stddev_samp_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesStddevSampOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseStopPlaceAlternativeNamesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseStopPlaceAlternativeNamesStreamCursorValueInput = {
  readonly alternative_names_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseStopPlaceAlternativeNamesSumFields = {
  readonly __typename?: 'stops_database_stop_place_alternative_names_sum_fields';
  readonly alternative_names_id?: Maybe<Scalars['bigint']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesSumOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** update columns of table "stop_place_alternative_names" */
export enum StopsDatabaseStopPlaceAlternativeNamesUpdateColumn {
  /** column name */
  AlternativeNamesId = 'alternative_names_id',
  /** column name */
  StopPlaceId = 'stop_place_id'
}

export type StopsDatabaseStopPlaceAlternativeNamesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseStopPlaceAlternativeNamesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseStopPlaceAlternativeNamesVarPopFields = {
  readonly __typename?: 'stops_database_stop_place_alternative_names_var_pop_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesVarPopOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseStopPlaceAlternativeNamesVarSampFields = {
  readonly __typename?: 'stops_database_stop_place_alternative_names_var_samp_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesVarSampOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseStopPlaceAlternativeNamesVarianceFields = {
  readonly __typename?: 'stops_database_stop_place_alternative_names_variance_fields';
  readonly alternative_names_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "stop_place_alternative_names" */
export type StopsDatabaseStopPlaceAlternativeNamesVarianceOrderBy = {
  readonly alternative_names_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate avg on columns */
export type StopsDatabaseStopPlaceAvgFields = {
  readonly __typename?: 'stops_database_stop_place_avg_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "stop_place". All fields are combined with a logical 'AND'. */
export type StopsDatabaseStopPlaceBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseStopPlaceBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceBoolExp>>;
  readonly accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentBoolExp>;
  readonly accessibility_assessment_id?: InputMaybe<BigintComparisonExp>;
  readonly air_submode?: InputMaybe<StringComparisonExp>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<BooleanComparisonExp>;
  readonly border_crossing?: InputMaybe<BooleanComparisonExp>;
  readonly bus_submode?: InputMaybe<StringComparisonExp>;
  readonly centroid?: InputMaybe<GeometryComparisonExp>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly coach_submode?: InputMaybe<StringComparisonExp>;
  readonly covered?: InputMaybe<IntComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly description_lang?: InputMaybe<StringComparisonExp>;
  readonly description_value?: InputMaybe<StringComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly funicular_submode?: InputMaybe<StringComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
  readonly metro_submode?: InputMaybe<StringComparisonExp>;
  readonly modification_enumeration?: InputMaybe<StringComparisonExp>;
  readonly name_lang?: InputMaybe<StringComparisonExp>;
  readonly name_value?: InputMaybe<StringComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly parent_site_ref?: InputMaybe<StringComparisonExp>;
  readonly parent_site_ref_version?: InputMaybe<StringComparisonExp>;
  readonly parent_stop_place?: InputMaybe<BooleanComparisonExp>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  readonly place_equipments_id?: InputMaybe<BigintComparisonExp>;
  readonly polygon_id?: InputMaybe<BigintComparisonExp>;
  readonly private_code_type?: InputMaybe<StringComparisonExp>;
  readonly private_code_value?: InputMaybe<StringComparisonExp>;
  readonly public_code?: InputMaybe<StringComparisonExp>;
  readonly rail_submode?: InputMaybe<StringComparisonExp>;
  readonly short_name_lang?: InputMaybe<StringComparisonExp>;
  readonly short_name_value?: InputMaybe<StringComparisonExp>;
  readonly stop_place_access_spaces?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesBoolExp>;
  readonly stop_place_access_spaces_aggregate?: InputMaybe<StopPlaceAccessSpacesAggregateBoolExp>;
  readonly stop_place_alternative_names?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesBoolExp>;
  readonly stop_place_alternative_names_aggregate?: InputMaybe<StopPlaceAlternativeNamesAggregateBoolExp>;
  readonly stop_place_child?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
  readonly stop_place_children?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
  readonly stop_place_children_aggregate?: InputMaybe<StopPlaceChildrenAggregateBoolExp>;
  readonly stop_place_equipment_places?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>;
  readonly stop_place_equipment_places_aggregate?: InputMaybe<StopPlaceEquipmentPlacesAggregateBoolExp>;
  readonly stop_place_key_values?: InputMaybe<StopsDatabaseStopPlaceKeyValuesBoolExp>;
  readonly stop_place_key_values_aggregate?: InputMaybe<StopPlaceKeyValuesAggregateBoolExp>;
  readonly stop_place_quays?: InputMaybe<StopsDatabaseStopPlaceQuaysBoolExp>;
  readonly stop_place_quays_aggregate?: InputMaybe<StopPlaceQuaysAggregateBoolExp>;
  readonly stop_place_tariff_zones?: InputMaybe<StopsDatabaseStopPlaceTariffZonesBoolExp>;
  readonly stop_place_tariff_zones_aggregate?: InputMaybe<StopPlaceTariffZonesAggregateBoolExp>;
  readonly stop_place_type?: InputMaybe<StringComparisonExp>;
  readonly telecabin_submode?: InputMaybe<StringComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly topographic_place?: InputMaybe<StopsDatabaseTopographicPlaceBoolExp>;
  readonly topographic_place_id?: InputMaybe<BigintComparisonExp>;
  readonly tram_submode?: InputMaybe<StringComparisonExp>;
  readonly transport_mode?: InputMaybe<StringComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
  readonly water_submode?: InputMaybe<StringComparisonExp>;
  readonly weighting?: InputMaybe<StringComparisonExp>;
};

/** columns and relationships of "stop_place_children" */
export type StopsDatabaseStopPlaceChildren = {
  readonly __typename?: 'stops_database_stop_place_children';
  /** An object relationship */
  readonly child: StopsDatabaseStopPlace;
  readonly children_id: Scalars['bigint']['output'];
  /** An object relationship */
  readonly parent: StopsDatabaseStopPlace;
  readonly stop_place_id: Scalars['bigint']['output'];
};

/** aggregated selection of "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenAggregate = {
  readonly __typename?: 'stops_database_stop_place_children_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseStopPlaceChildrenAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseStopPlaceChildren>;
};

/** aggregate fields of "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenAggregateFields = {
  readonly __typename?: 'stops_database_stop_place_children_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseStopPlaceChildrenAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseStopPlaceChildrenMaxFields>;
  readonly min?: Maybe<StopsDatabaseStopPlaceChildrenMinFields>;
  readonly stddev?: Maybe<StopsDatabaseStopPlaceChildrenStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseStopPlaceChildrenStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseStopPlaceChildrenStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseStopPlaceChildrenSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseStopPlaceChildrenVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseStopPlaceChildrenVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseStopPlaceChildrenVarianceFields>;
};


/** aggregate fields of "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceChildrenSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseStopPlaceChildrenAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseStopPlaceChildrenMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseStopPlaceChildrenMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseStopPlaceChildrenStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseStopPlaceChildrenStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseStopPlaceChildrenStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseStopPlaceChildrenSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseStopPlaceChildrenVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseStopPlaceChildrenVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseStopPlaceChildrenVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseStopPlaceChildrenInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseStopPlaceChildrenOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseStopPlaceChildrenAvgFields = {
  readonly __typename?: 'stops_database_stop_place_children_avg_fields';
  readonly children_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenAvgOrderBy = {
  readonly children_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "stop_place_children". All fields are combined with a logical 'AND'. */
export type StopsDatabaseStopPlaceChildrenBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceChildrenBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceChildrenBoolExp>>;
  readonly child?: InputMaybe<StopsDatabaseStopPlaceBoolExp>;
  readonly children_id?: InputMaybe<BigintComparisonExp>;
  readonly parent?: InputMaybe<StopsDatabaseStopPlaceBoolExp>;
  readonly stop_place_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "stop_place_children" */
export enum StopsDatabaseStopPlaceChildrenConstraint {
  /** unique or primary key constraint on columns "children_id", "stop_place_id" */
  StopPlaceChildrenPkey = 'stop_place_children_pkey',
  /** unique or primary key constraint on columns "children_id" */
  UkKj0a7ruk5k2bub2028nbkqwtw = 'uk_kj0a7ruk5k2bub2028nbkqwtw'
}

/** input type for incrementing numeric columns in table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenIncInput = {
  readonly children_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenInsertInput = {
  readonly child?: InputMaybe<StopsDatabaseStopPlaceObjRelInsertInput>;
  readonly children_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly parent?: InputMaybe<StopsDatabaseStopPlaceObjRelInsertInput>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseStopPlaceChildrenMaxFields = {
  readonly __typename?: 'stops_database_stop_place_children_max_fields';
  readonly children_id?: Maybe<Scalars['bigint']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenMaxOrderBy = {
  readonly children_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseStopPlaceChildrenMinFields = {
  readonly __typename?: 'stops_database_stop_place_children_min_fields';
  readonly children_id?: Maybe<Scalars['bigint']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenMinOrderBy = {
  readonly children_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenMutationResponse = {
  readonly __typename?: 'stops_database_stop_place_children_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseStopPlaceChildren>;
};

/** input type for inserting object relation for remote table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenObjRelInsertInput = {
  readonly data: StopsDatabaseStopPlaceChildrenInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseStopPlaceChildrenOnConflict>;
};

/** on_conflict condition type for table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenOnConflict = {
  readonly constraint: StopsDatabaseStopPlaceChildrenConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseStopPlaceChildrenUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
};

/** Ordering options when selecting data from "stop_place_children". */
export type StopsDatabaseStopPlaceChildrenOrderBy = {
  readonly child?: InputMaybe<StopsDatabaseStopPlaceOrderBy>;
  readonly children_id?: InputMaybe<OrderBy>;
  readonly parent?: InputMaybe<StopsDatabaseStopPlaceOrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: stop_place_children */
export type StopsDatabaseStopPlaceChildrenPkColumnsInput = {
  readonly children_id: Scalars['bigint']['input'];
  readonly stop_place_id: Scalars['bigint']['input'];
};

/** select columns of table "stop_place_children" */
export enum StopsDatabaseStopPlaceChildrenSelectColumn {
  /** column name */
  ChildrenId = 'children_id',
  /** column name */
  StopPlaceId = 'stop_place_id'
}

/** input type for updating data in table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenSetInput = {
  readonly children_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseStopPlaceChildrenStddevFields = {
  readonly __typename?: 'stops_database_stop_place_children_stddev_fields';
  readonly children_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenStddevOrderBy = {
  readonly children_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseStopPlaceChildrenStddevPopFields = {
  readonly __typename?: 'stops_database_stop_place_children_stddev_pop_fields';
  readonly children_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenStddevPopOrderBy = {
  readonly children_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseStopPlaceChildrenStddevSampFields = {
  readonly __typename?: 'stops_database_stop_place_children_stddev_samp_fields';
  readonly children_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenStddevSampOrderBy = {
  readonly children_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseStopPlaceChildrenStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseStopPlaceChildrenStreamCursorValueInput = {
  readonly children_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseStopPlaceChildrenSumFields = {
  readonly __typename?: 'stops_database_stop_place_children_sum_fields';
  readonly children_id?: Maybe<Scalars['bigint']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenSumOrderBy = {
  readonly children_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** update columns of table "stop_place_children" */
export enum StopsDatabaseStopPlaceChildrenUpdateColumn {
  /** column name */
  ChildrenId = 'children_id',
  /** column name */
  StopPlaceId = 'stop_place_id'
}

export type StopsDatabaseStopPlaceChildrenUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseStopPlaceChildrenIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseStopPlaceChildrenSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseStopPlaceChildrenBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseStopPlaceChildrenVarPopFields = {
  readonly __typename?: 'stops_database_stop_place_children_var_pop_fields';
  readonly children_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenVarPopOrderBy = {
  readonly children_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseStopPlaceChildrenVarSampFields = {
  readonly __typename?: 'stops_database_stop_place_children_var_samp_fields';
  readonly children_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenVarSampOrderBy = {
  readonly children_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseStopPlaceChildrenVarianceFields = {
  readonly __typename?: 'stops_database_stop_place_children_variance_fields';
  readonly children_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "stop_place_children" */
export type StopsDatabaseStopPlaceChildrenVarianceOrderBy = {
  readonly children_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** unique or primary key constraints on table "stop_place" */
export enum StopsDatabaseStopPlaceConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  StopPlaceNetexIdVersionConstraint = 'stop_place_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  StopPlacePkey = 'stop_place_pkey'
}

/** columns and relationships of "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlaces = {
  readonly __typename?: 'stops_database_stop_place_equipment_places';
  /** An object relationship */
  readonly equipment_place: StopsDatabaseEquipmentPlace;
  readonly equipment_places_id: Scalars['bigint']['output'];
  readonly stop_place_id: Scalars['bigint']['output'];
};

/** aggregated selection of "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesAggregate = {
  readonly __typename?: 'stops_database_stop_place_equipment_places_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlaces>;
};

/** aggregate fields of "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesAggregateFields = {
  readonly __typename?: 'stops_database_stop_place_equipment_places_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesMaxFields>;
  readonly min?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesVarianceFields>;
};


/** aggregate fields of "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlacesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlacesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseStopPlaceEquipmentPlacesAvgFields = {
  readonly __typename?: 'stops_database_stop_place_equipment_places_avg_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesAvgOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "stop_place_equipment_places". All fields are combined with a logical 'AND'. */
export type StopsDatabaseStopPlaceEquipmentPlacesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>>;
  readonly equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceBoolExp>;
  readonly equipment_places_id?: InputMaybe<BigintComparisonExp>;
  readonly stop_place_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "stop_place_equipment_places" */
export enum StopsDatabaseStopPlaceEquipmentPlacesConstraint {
  /** unique or primary key constraint on columns "equipment_places_id" */
  UkMnksrduwpe1bfxskob1pkbi28 = 'uk_mnksrduwpe1bfxskob1pkbi28'
}

/** input type for incrementing numeric columns in table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesIncInput = {
  readonly equipment_places_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesInsertInput = {
  readonly equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceObjRelInsertInput>;
  readonly equipment_places_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseStopPlaceEquipmentPlacesMaxFields = {
  readonly __typename?: 'stops_database_stop_place_equipment_places_max_fields';
  readonly equipment_places_id?: Maybe<Scalars['bigint']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesMaxOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseStopPlaceEquipmentPlacesMinFields = {
  readonly __typename?: 'stops_database_stop_place_equipment_places_min_fields';
  readonly equipment_places_id?: Maybe<Scalars['bigint']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesMinOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesMutationResponse = {
  readonly __typename?: 'stops_database_stop_place_equipment_places_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlaces>;
};

/** on_conflict condition type for table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesOnConflict = {
  readonly constraint: StopsDatabaseStopPlaceEquipmentPlacesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlacesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>;
};

/** Ordering options when selecting data from "stop_place_equipment_places". */
export type StopsDatabaseStopPlaceEquipmentPlacesOrderBy = {
  readonly equipment_place?: InputMaybe<StopsDatabaseEquipmentPlaceOrderBy>;
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** select columns of table "stop_place_equipment_places" */
export enum StopsDatabaseStopPlaceEquipmentPlacesSelectColumn {
  /** column name */
  EquipmentPlacesId = 'equipment_places_id',
  /** column name */
  StopPlaceId = 'stop_place_id'
}

/** input type for updating data in table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesSetInput = {
  readonly equipment_places_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseStopPlaceEquipmentPlacesStddevFields = {
  readonly __typename?: 'stops_database_stop_place_equipment_places_stddev_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesStddevOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseStopPlaceEquipmentPlacesStddevPopFields = {
  readonly __typename?: 'stops_database_stop_place_equipment_places_stddev_pop_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesStddevPopOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseStopPlaceEquipmentPlacesStddevSampFields = {
  readonly __typename?: 'stops_database_stop_place_equipment_places_stddev_samp_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesStddevSampOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseStopPlaceEquipmentPlacesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseStopPlaceEquipmentPlacesStreamCursorValueInput = {
  readonly equipment_places_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseStopPlaceEquipmentPlacesSumFields = {
  readonly __typename?: 'stops_database_stop_place_equipment_places_sum_fields';
  readonly equipment_places_id?: Maybe<Scalars['bigint']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesSumOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** update columns of table "stop_place_equipment_places" */
export enum StopsDatabaseStopPlaceEquipmentPlacesUpdateColumn {
  /** column name */
  EquipmentPlacesId = 'equipment_places_id',
  /** column name */
  StopPlaceId = 'stop_place_id'
}

export type StopsDatabaseStopPlaceEquipmentPlacesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseStopPlaceEquipmentPlacesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseStopPlaceEquipmentPlacesVarPopFields = {
  readonly __typename?: 'stops_database_stop_place_equipment_places_var_pop_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesVarPopOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseStopPlaceEquipmentPlacesVarSampFields = {
  readonly __typename?: 'stops_database_stop_place_equipment_places_var_samp_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesVarSampOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseStopPlaceEquipmentPlacesVarianceFields = {
  readonly __typename?: 'stops_database_stop_place_equipment_places_variance_fields';
  readonly equipment_places_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "stop_place_equipment_places" */
export type StopsDatabaseStopPlaceEquipmentPlacesVarianceOrderBy = {
  readonly equipment_places_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** input type for incrementing numeric columns in table "stop_place" */
export type StopsDatabaseStopPlaceIncInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly topographic_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "stop_place" */
export type StopsDatabaseStopPlaceInsertInput = {
  readonly accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentObjRelInsertInput>;
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly air_submode?: InputMaybe<Scalars['String']['input']>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  readonly border_crossing?: InputMaybe<Scalars['Boolean']['input']>;
  readonly bus_submode?: InputMaybe<Scalars['String']['input']>;
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly coach_submode?: InputMaybe<Scalars['String']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly funicular_submode?: InputMaybe<Scalars['String']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureObjRelInsertInput>;
  readonly metro_submode?: InputMaybe<Scalars['String']['input']>;
  readonly modification_enumeration?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly parent_site_ref?: InputMaybe<Scalars['String']['input']>;
  readonly parent_site_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly parent_stop_place?: InputMaybe<Scalars['Boolean']['input']>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonObjRelInsertInput>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly public_code?: InputMaybe<Scalars['String']['input']>;
  readonly rail_submode?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly stop_place_access_spaces?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesArrRelInsertInput>;
  readonly stop_place_alternative_names?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesArrRelInsertInput>;
  readonly stop_place_child?: InputMaybe<StopsDatabaseStopPlaceChildrenObjRelInsertInput>;
  readonly stop_place_children?: InputMaybe<StopsDatabaseStopPlaceChildrenArrRelInsertInput>;
  readonly stop_place_equipment_places?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesArrRelInsertInput>;
  readonly stop_place_key_values?: InputMaybe<StopsDatabaseStopPlaceKeyValuesArrRelInsertInput>;
  readonly stop_place_quays?: InputMaybe<StopsDatabaseStopPlaceQuaysArrRelInsertInput>;
  readonly stop_place_tariff_zones?: InputMaybe<StopsDatabaseStopPlaceTariffZonesArrRelInsertInput>;
  readonly stop_place_type?: InputMaybe<Scalars['String']['input']>;
  readonly telecabin_submode?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly topographic_place?: InputMaybe<StopsDatabaseTopographicPlaceObjRelInsertInput>;
  readonly topographic_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly tram_submode?: InputMaybe<Scalars['String']['input']>;
  readonly transport_mode?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
  readonly water_submode?: InputMaybe<Scalars['String']['input']>;
  readonly weighting?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValues = {
  readonly __typename?: 'stops_database_stop_place_key_values';
  readonly key_values_id: Scalars['bigint']['output'];
  readonly key_values_key: Scalars['String']['output'];
  readonly stop_place_id: Scalars['bigint']['output'];
  /** An object relationship */
  readonly value: StopsDatabaseValue;
};

/** aggregated selection of "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesAggregate = {
  readonly __typename?: 'stops_database_stop_place_key_values_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseStopPlaceKeyValuesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseStopPlaceKeyValues>;
};

/** aggregate fields of "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesAggregateFields = {
  readonly __typename?: 'stops_database_stop_place_key_values_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseStopPlaceKeyValuesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseStopPlaceKeyValuesMaxFields>;
  readonly min?: Maybe<StopsDatabaseStopPlaceKeyValuesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseStopPlaceKeyValuesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseStopPlaceKeyValuesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseStopPlaceKeyValuesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseStopPlaceKeyValuesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseStopPlaceKeyValuesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseStopPlaceKeyValuesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseStopPlaceKeyValuesVarianceFields>;
};


/** aggregate fields of "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseStopPlaceKeyValuesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseStopPlaceKeyValuesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseStopPlaceKeyValuesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseStopPlaceKeyValuesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseStopPlaceKeyValuesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseStopPlaceKeyValuesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseStopPlaceKeyValuesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseStopPlaceKeyValuesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseStopPlaceKeyValuesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseStopPlaceKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseStopPlaceKeyValuesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseStopPlaceKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseStopPlaceKeyValuesAvgFields = {
  readonly __typename?: 'stops_database_stop_place_key_values_avg_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesAvgOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "stop_place_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseStopPlaceKeyValuesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceKeyValuesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseStopPlaceKeyValuesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceKeyValuesBoolExp>>;
  readonly key_values_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_key?: InputMaybe<StringComparisonExp>;
  readonly stop_place_id?: InputMaybe<BigintComparisonExp>;
  readonly value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "stop_place_key_values" */
export enum StopsDatabaseStopPlaceKeyValuesConstraint {
  /** unique or primary key constraint on columns "key_values_key", "stop_place_id" */
  StopPlaceKeyValuesPkey = 'stop_place_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  Uk_54aj7c8yuc5751x4c7qly6e5t = 'uk_54aj7c8yuc5751x4c7qly6e5t'
}

/** input type for incrementing numeric columns in table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesIncInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesInsertInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseStopPlaceKeyValuesMaxFields = {
  readonly __typename?: 'stops_database_stop_place_key_values_max_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesMaxOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseStopPlaceKeyValuesMinFields = {
  readonly __typename?: 'stops_database_stop_place_key_values_min_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesMinOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesMutationResponse = {
  readonly __typename?: 'stops_database_stop_place_key_values_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseStopPlaceKeyValues>;
};

/** on_conflict condition type for table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesOnConflict = {
  readonly constraint: StopsDatabaseStopPlaceKeyValuesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseStopPlaceKeyValuesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseStopPlaceKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "stop_place_key_values". */
export type StopsDatabaseStopPlaceKeyValuesOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
  readonly value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: stop_place_key_values */
export type StopsDatabaseStopPlaceKeyValuesPkColumnsInput = {
  readonly key_values_key: Scalars['String']['input'];
  readonly stop_place_id: Scalars['bigint']['input'];
};

/** select columns of table "stop_place_key_values" */
export enum StopsDatabaseStopPlaceKeyValuesSelectColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  StopPlaceId = 'stop_place_id'
}

/** input type for updating data in table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesSetInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseStopPlaceKeyValuesStddevFields = {
  readonly __typename?: 'stops_database_stop_place_key_values_stddev_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesStddevOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseStopPlaceKeyValuesStddevPopFields = {
  readonly __typename?: 'stops_database_stop_place_key_values_stddev_pop_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesStddevPopOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseStopPlaceKeyValuesStddevSampFields = {
  readonly __typename?: 'stops_database_stop_place_key_values_stddev_samp_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesStddevSampOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseStopPlaceKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseStopPlaceKeyValuesStreamCursorValueInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseStopPlaceKeyValuesSumFields = {
  readonly __typename?: 'stops_database_stop_place_key_values_sum_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesSumOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** update columns of table "stop_place_key_values" */
export enum StopsDatabaseStopPlaceKeyValuesUpdateColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  StopPlaceId = 'stop_place_id'
}

export type StopsDatabaseStopPlaceKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseStopPlaceKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseStopPlaceKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseStopPlaceKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseStopPlaceKeyValuesVarPopFields = {
  readonly __typename?: 'stops_database_stop_place_key_values_var_pop_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesVarPopOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseStopPlaceKeyValuesVarSampFields = {
  readonly __typename?: 'stops_database_stop_place_key_values_var_samp_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesVarSampOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseStopPlaceKeyValuesVarianceFields = {
  readonly __typename?: 'stops_database_stop_place_key_values_variance_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "stop_place_key_values" */
export type StopsDatabaseStopPlaceKeyValuesVarianceOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseStopPlaceMaxFields = {
  readonly __typename?: 'stops_database_stop_place_max_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly air_submode?: Maybe<Scalars['String']['output']>;
  readonly bus_submode?: Maybe<Scalars['String']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly coach_submode?: Maybe<Scalars['String']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly funicular_submode?: Maybe<Scalars['String']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly metro_submode?: Maybe<Scalars['String']['output']>;
  readonly modification_enumeration?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly parent_site_ref?: Maybe<Scalars['String']['output']>;
  readonly parent_site_ref_version?: Maybe<Scalars['String']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly public_code?: Maybe<Scalars['String']['output']>;
  readonly rail_submode?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly stop_place_type?: Maybe<Scalars['String']['output']>;
  readonly telecabin_submode?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly tram_submode?: Maybe<Scalars['String']['output']>;
  readonly transport_mode?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly water_submode?: Maybe<Scalars['String']['output']>;
  readonly weighting?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseStopPlaceMinFields = {
  readonly __typename?: 'stops_database_stop_place_min_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly air_submode?: Maybe<Scalars['String']['output']>;
  readonly bus_submode?: Maybe<Scalars['String']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly coach_submode?: Maybe<Scalars['String']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly funicular_submode?: Maybe<Scalars['String']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly metro_submode?: Maybe<Scalars['String']['output']>;
  readonly modification_enumeration?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly parent_site_ref?: Maybe<Scalars['String']['output']>;
  readonly parent_site_ref_version?: Maybe<Scalars['String']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly public_code?: Maybe<Scalars['String']['output']>;
  readonly rail_submode?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly stop_place_type?: Maybe<Scalars['String']['output']>;
  readonly telecabin_submode?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly tram_submode?: Maybe<Scalars['String']['output']>;
  readonly transport_mode?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly water_submode?: Maybe<Scalars['String']['output']>;
  readonly weighting?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "stop_place" */
export type StopsDatabaseStopPlaceMutationResponse = {
  readonly __typename?: 'stops_database_stop_place_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseStopPlace>;
};

/** columns and relationships of "stop_place_newest_version" */
export type StopsDatabaseStopPlaceNewestVersion = {
  readonly __typename?: 'stops_database_stop_place_newest_version';
  readonly TiamatStopPlace?: Maybe<ReadonlyArray<Maybe<StopRegistryStopPlaceInterface>>>;
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly air_submode?: Maybe<Scalars['String']['output']>;
  readonly all_areas_wheelchair_accessible?: Maybe<Scalars['Boolean']['output']>;
  readonly border_crossing?: Maybe<Scalars['Boolean']['output']>;
  readonly bus_submode?: Maybe<Scalars['String']['output']>;
  readonly centroid?: Maybe<Scalars['geometry']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  readonly children: ReadonlyArray<StopsDatabaseStopPlaceChildren>;
  /** An aggregate relationship */
  readonly children_aggregate: StopsDatabaseStopPlaceChildrenAggregate;
  readonly coach_submode?: Maybe<Scalars['String']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly funicular_submode?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  readonly group_of_stop_places_members: ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembers>;
  /** An aggregate relationship */
  readonly group_of_stop_places_members_aggregate: StopsDatabaseGroupOfStopPlacesMembersAggregate;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly is_area?: Maybe<Scalars['Boolean']['output']>;
  readonly is_terminal?: Maybe<Scalars['Boolean']['output']>;
  readonly metro_submode?: Maybe<Scalars['String']['output']>;
  readonly modification_enumeration?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  readonly parent?: Maybe<StopsDatabaseStopPlaceChildren>;
  readonly parent_site_ref?: Maybe<Scalars['String']['output']>;
  readonly parent_site_ref_version?: Maybe<Scalars['String']['output']>;
  readonly parent_stop_place?: Maybe<Scalars['Boolean']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly priority?: Maybe<Scalars['String']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly public_code?: Maybe<Scalars['String']['output']>;
  readonly rail_submode?: Maybe<Scalars['String']['output']>;
  readonly scheduled_stop_point_instance?: Maybe<ServicePatternScheduledStopPoint>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  readonly stop_place_access_spaces: ReadonlyArray<StopsDatabaseStopPlaceAccessSpaces>;
  /** An aggregate relationship */
  readonly stop_place_access_spaces_aggregate: StopsDatabaseStopPlaceAccessSpacesAggregate;
  /** An array relationship */
  readonly stop_place_alternative_names: ReadonlyArray<StopsDatabaseStopPlaceAlternativeNames>;
  /** An aggregate relationship */
  readonly stop_place_alternative_names_aggregate: StopsDatabaseStopPlaceAlternativeNamesAggregate;
  /** An array relationship */
  readonly stop_place_equipment_places: ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlaces>;
  /** An aggregate relationship */
  readonly stop_place_equipment_places_aggregate: StopsDatabaseStopPlaceEquipmentPlacesAggregate;
  /** An array relationship */
  readonly stop_place_key_values: ReadonlyArray<StopsDatabaseStopPlaceKeyValues>;
  /** An aggregate relationship */
  readonly stop_place_key_values_aggregate: StopsDatabaseStopPlaceKeyValuesAggregate;
  /** An array relationship */
  readonly stop_place_quays: ReadonlyArray<StopsDatabaseStopPlaceQuays>;
  /** An aggregate relationship */
  readonly stop_place_quays_aggregate: StopsDatabaseStopPlaceQuaysAggregate;
  /** An array relationship */
  readonly stop_place_tariff_zones: ReadonlyArray<StopsDatabaseStopPlaceTariffZones>;
  /** An aggregate relationship */
  readonly stop_place_tariff_zones_aggregate: StopsDatabaseStopPlaceTariffZonesAggregate;
  readonly stop_place_type?: Maybe<Scalars['String']['output']>;
  readonly street_address?: Maybe<Scalars['String']['output']>;
  readonly telecabin_submode?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly tram_submode?: Maybe<Scalars['String']['output']>;
  readonly transport_mode?: Maybe<Scalars['String']['output']>;
  readonly validity_end?: Maybe<Scalars['String']['output']>;
  readonly validity_start?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly water_submode?: Maybe<Scalars['String']['output']>;
  readonly weighting?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "stop_place_newest_version" */
export type StopsDatabaseStopPlaceNewestVersionTiamatStopPlaceArgs = {
  allVersions?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  countryReference?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  countyReference?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  hasParking?: InputMaybe<Scalars['Boolean']['input']>;
  importedId?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  municipalityReference?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  page?: InputMaybe<Scalars['Int']['input']>;
  pointInTime?: InputMaybe<Scalars['stop_registry_DateTime']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  stopPlaceType?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryStopPlaceType>>>;
  tags?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  values?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>>>;
  version?: InputMaybe<Scalars['Int']['input']>;
  versionValidity?: InputMaybe<StopRegistryVersionValidity>;
  withDuplicatedQuayImportedIds?: InputMaybe<Scalars['Boolean']['input']>;
  withNearbySimilarDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
  withTags?: InputMaybe<Scalars['Boolean']['input']>;
  withoutLocationOnly?: InputMaybe<Scalars['Boolean']['input']>;
  withoutQuaysOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


/** columns and relationships of "stop_place_newest_version" */
export type StopsDatabaseStopPlaceNewestVersionChildrenArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceChildrenSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceChildrenOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
};


/** columns and relationships of "stop_place_newest_version" */
export type StopsDatabaseStopPlaceNewestVersionChildrenAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceChildrenSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceChildrenOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
};


/** columns and relationships of "stop_place_newest_version" */
export type StopsDatabaseStopPlaceNewestVersionGroupOfStopPlacesMembersArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembersOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersBoolExp>;
};


/** columns and relationships of "stop_place_newest_version" */
export type StopsDatabaseStopPlaceNewestVersionGroupOfStopPlacesMembersAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembersOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersBoolExp>;
};


/** columns and relationships of "stop_place_newest_version" */
export type StopsDatabaseStopPlaceNewestVersionStopPlaceAccessSpacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAccessSpacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAccessSpacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesBoolExp>;
};


/** columns and relationships of "stop_place_newest_version" */
export type StopsDatabaseStopPlaceNewestVersionStopPlaceAccessSpacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAccessSpacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAccessSpacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesBoolExp>;
};


/** columns and relationships of "stop_place_newest_version" */
export type StopsDatabaseStopPlaceNewestVersionStopPlaceAlternativeNamesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesBoolExp>;
};


/** columns and relationships of "stop_place_newest_version" */
export type StopsDatabaseStopPlaceNewestVersionStopPlaceAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesBoolExp>;
};


/** columns and relationships of "stop_place_newest_version" */
export type StopsDatabaseStopPlaceNewestVersionStopPlaceEquipmentPlacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>;
};


/** columns and relationships of "stop_place_newest_version" */
export type StopsDatabaseStopPlaceNewestVersionStopPlaceEquipmentPlacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>;
};


/** columns and relationships of "stop_place_newest_version" */
export type StopsDatabaseStopPlaceNewestVersionStopPlaceKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceKeyValuesBoolExp>;
};


/** columns and relationships of "stop_place_newest_version" */
export type StopsDatabaseStopPlaceNewestVersionStopPlaceKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceKeyValuesBoolExp>;
};


/** columns and relationships of "stop_place_newest_version" */
export type StopsDatabaseStopPlaceNewestVersionStopPlaceQuaysArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceQuaysSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceQuaysOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceQuaysBoolExp>;
};


/** columns and relationships of "stop_place_newest_version" */
export type StopsDatabaseStopPlaceNewestVersionStopPlaceQuaysAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceQuaysSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceQuaysOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceQuaysBoolExp>;
};


/** columns and relationships of "stop_place_newest_version" */
export type StopsDatabaseStopPlaceNewestVersionStopPlaceTariffZonesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceTariffZonesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceTariffZonesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceTariffZonesBoolExp>;
};


/** columns and relationships of "stop_place_newest_version" */
export type StopsDatabaseStopPlaceNewestVersionStopPlaceTariffZonesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceTariffZonesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceTariffZonesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceTariffZonesBoolExp>;
};

/** aggregated selection of "stop_place_newest_version" */
export type StopsDatabaseStopPlaceNewestVersionAggregate = {
  readonly __typename?: 'stops_database_stop_place_newest_version_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseStopPlaceNewestVersionAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseStopPlaceNewestVersion>;
};

/** aggregate fields of "stop_place_newest_version" */
export type StopsDatabaseStopPlaceNewestVersionAggregateFields = {
  readonly __typename?: 'stops_database_stop_place_newest_version_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseStopPlaceNewestVersionAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseStopPlaceNewestVersionMaxFields>;
  readonly min?: Maybe<StopsDatabaseStopPlaceNewestVersionMinFields>;
  readonly stddev?: Maybe<StopsDatabaseStopPlaceNewestVersionStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseStopPlaceNewestVersionStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseStopPlaceNewestVersionStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseStopPlaceNewestVersionSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseStopPlaceNewestVersionVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseStopPlaceNewestVersionVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseStopPlaceNewestVersionVarianceFields>;
};


/** aggregate fields of "stop_place_newest_version" */
export type StopsDatabaseStopPlaceNewestVersionAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceNewestVersionSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseStopPlaceNewestVersionAvgFields = {
  readonly __typename?: 'stops_database_stop_place_newest_version_avg_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "stop_place_newest_version". All fields are combined with a logical 'AND'. */
export type StopsDatabaseStopPlaceNewestVersionBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceNewestVersionBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseStopPlaceNewestVersionBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceNewestVersionBoolExp>>;
  readonly accessibility_assessment_id?: InputMaybe<BigintComparisonExp>;
  readonly air_submode?: InputMaybe<StringComparisonExp>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<BooleanComparisonExp>;
  readonly border_crossing?: InputMaybe<BooleanComparisonExp>;
  readonly bus_submode?: InputMaybe<StringComparisonExp>;
  readonly centroid?: InputMaybe<GeometryComparisonExp>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly children?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
  readonly children_aggregate?: InputMaybe<StopPlaceChildrenAggregateBoolExp>;
  readonly coach_submode?: InputMaybe<StringComparisonExp>;
  readonly covered?: InputMaybe<IntComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly description_lang?: InputMaybe<StringComparisonExp>;
  readonly description_value?: InputMaybe<StringComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly funicular_submode?: InputMaybe<StringComparisonExp>;
  readonly group_of_stop_places_members?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersBoolExp>;
  readonly group_of_stop_places_members_aggregate?: InputMaybe<GroupOfStopPlacesMembersAggregateBoolExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly is_area?: InputMaybe<BooleanComparisonExp>;
  readonly is_terminal?: InputMaybe<BooleanComparisonExp>;
  readonly metro_submode?: InputMaybe<StringComparisonExp>;
  readonly modification_enumeration?: InputMaybe<StringComparisonExp>;
  readonly name_lang?: InputMaybe<StringComparisonExp>;
  readonly name_value?: InputMaybe<StringComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly parent?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
  readonly parent_site_ref?: InputMaybe<StringComparisonExp>;
  readonly parent_site_ref_version?: InputMaybe<StringComparisonExp>;
  readonly parent_stop_place?: InputMaybe<BooleanComparisonExp>;
  readonly place_equipments_id?: InputMaybe<BigintComparisonExp>;
  readonly polygon_id?: InputMaybe<BigintComparisonExp>;
  readonly priority?: InputMaybe<StringComparisonExp>;
  readonly private_code_type?: InputMaybe<StringComparisonExp>;
  readonly private_code_value?: InputMaybe<StringComparisonExp>;
  readonly public_code?: InputMaybe<StringComparisonExp>;
  readonly rail_submode?: InputMaybe<StringComparisonExp>;
  readonly short_name_lang?: InputMaybe<StringComparisonExp>;
  readonly short_name_value?: InputMaybe<StringComparisonExp>;
  readonly stop_place_access_spaces?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesBoolExp>;
  readonly stop_place_access_spaces_aggregate?: InputMaybe<StopPlaceAccessSpacesAggregateBoolExp>;
  readonly stop_place_alternative_names?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesBoolExp>;
  readonly stop_place_alternative_names_aggregate?: InputMaybe<StopPlaceAlternativeNamesAggregateBoolExp>;
  readonly stop_place_equipment_places?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>;
  readonly stop_place_equipment_places_aggregate?: InputMaybe<StopPlaceEquipmentPlacesAggregateBoolExp>;
  readonly stop_place_key_values?: InputMaybe<StopsDatabaseStopPlaceKeyValuesBoolExp>;
  readonly stop_place_key_values_aggregate?: InputMaybe<StopPlaceKeyValuesAggregateBoolExp>;
  readonly stop_place_quays?: InputMaybe<StopsDatabaseStopPlaceQuaysBoolExp>;
  readonly stop_place_quays_aggregate?: InputMaybe<StopPlaceQuaysAggregateBoolExp>;
  readonly stop_place_tariff_zones?: InputMaybe<StopsDatabaseStopPlaceTariffZonesBoolExp>;
  readonly stop_place_tariff_zones_aggregate?: InputMaybe<StopPlaceTariffZonesAggregateBoolExp>;
  readonly stop_place_type?: InputMaybe<StringComparisonExp>;
  readonly street_address?: InputMaybe<StringComparisonExp>;
  readonly telecabin_submode?: InputMaybe<StringComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly topographic_place_id?: InputMaybe<BigintComparisonExp>;
  readonly tram_submode?: InputMaybe<StringComparisonExp>;
  readonly transport_mode?: InputMaybe<StringComparisonExp>;
  readonly validity_end?: InputMaybe<StringComparisonExp>;
  readonly validity_start?: InputMaybe<StringComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
  readonly water_submode?: InputMaybe<StringComparisonExp>;
  readonly weighting?: InputMaybe<StringComparisonExp>;
};

/** input type for inserting data into table "stop_place_newest_version" */
export type StopsDatabaseStopPlaceNewestVersionInsertInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly air_submode?: InputMaybe<Scalars['String']['input']>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  readonly border_crossing?: InputMaybe<Scalars['Boolean']['input']>;
  readonly bus_submode?: InputMaybe<Scalars['String']['input']>;
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly children?: InputMaybe<StopsDatabaseStopPlaceChildrenArrRelInsertInput>;
  readonly coach_submode?: InputMaybe<Scalars['String']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly funicular_submode?: InputMaybe<Scalars['String']['input']>;
  readonly group_of_stop_places_members?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersArrRelInsertInput>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly is_area?: InputMaybe<Scalars['Boolean']['input']>;
  readonly is_terminal?: InputMaybe<Scalars['Boolean']['input']>;
  readonly metro_submode?: InputMaybe<Scalars['String']['input']>;
  readonly modification_enumeration?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly parent?: InputMaybe<StopsDatabaseStopPlaceChildrenObjRelInsertInput>;
  readonly parent_site_ref?: InputMaybe<Scalars['String']['input']>;
  readonly parent_site_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly parent_stop_place?: InputMaybe<Scalars['Boolean']['input']>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly priority?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly public_code?: InputMaybe<Scalars['String']['input']>;
  readonly rail_submode?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly stop_place_access_spaces?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesArrRelInsertInput>;
  readonly stop_place_alternative_names?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesArrRelInsertInput>;
  readonly stop_place_equipment_places?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesArrRelInsertInput>;
  readonly stop_place_key_values?: InputMaybe<StopsDatabaseStopPlaceKeyValuesArrRelInsertInput>;
  readonly stop_place_quays?: InputMaybe<StopsDatabaseStopPlaceQuaysArrRelInsertInput>;
  readonly stop_place_tariff_zones?: InputMaybe<StopsDatabaseStopPlaceTariffZonesArrRelInsertInput>;
  readonly stop_place_type?: InputMaybe<Scalars['String']['input']>;
  readonly street_address?: InputMaybe<Scalars['String']['input']>;
  readonly telecabin_submode?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly topographic_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly tram_submode?: InputMaybe<Scalars['String']['input']>;
  readonly transport_mode?: InputMaybe<Scalars['String']['input']>;
  readonly validity_end?: InputMaybe<Scalars['String']['input']>;
  readonly validity_start?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
  readonly water_submode?: InputMaybe<Scalars['String']['input']>;
  readonly weighting?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseStopPlaceNewestVersionMaxFields = {
  readonly __typename?: 'stops_database_stop_place_newest_version_max_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly air_submode?: Maybe<Scalars['String']['output']>;
  readonly bus_submode?: Maybe<Scalars['String']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly coach_submode?: Maybe<Scalars['String']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly funicular_submode?: Maybe<Scalars['String']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly metro_submode?: Maybe<Scalars['String']['output']>;
  readonly modification_enumeration?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly parent_site_ref?: Maybe<Scalars['String']['output']>;
  readonly parent_site_ref_version?: Maybe<Scalars['String']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly priority?: Maybe<Scalars['String']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly public_code?: Maybe<Scalars['String']['output']>;
  readonly rail_submode?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly stop_place_type?: Maybe<Scalars['String']['output']>;
  readonly street_address?: Maybe<Scalars['String']['output']>;
  readonly telecabin_submode?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly tram_submode?: Maybe<Scalars['String']['output']>;
  readonly transport_mode?: Maybe<Scalars['String']['output']>;
  readonly validity_end?: Maybe<Scalars['String']['output']>;
  readonly validity_start?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly water_submode?: Maybe<Scalars['String']['output']>;
  readonly weighting?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseStopPlaceNewestVersionMinFields = {
  readonly __typename?: 'stops_database_stop_place_newest_version_min_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly air_submode?: Maybe<Scalars['String']['output']>;
  readonly bus_submode?: Maybe<Scalars['String']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly coach_submode?: Maybe<Scalars['String']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly funicular_submode?: Maybe<Scalars['String']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly metro_submode?: Maybe<Scalars['String']['output']>;
  readonly modification_enumeration?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly parent_site_ref?: Maybe<Scalars['String']['output']>;
  readonly parent_site_ref_version?: Maybe<Scalars['String']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly priority?: Maybe<Scalars['String']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly public_code?: Maybe<Scalars['String']['output']>;
  readonly rail_submode?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly stop_place_type?: Maybe<Scalars['String']['output']>;
  readonly street_address?: Maybe<Scalars['String']['output']>;
  readonly telecabin_submode?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly tram_submode?: Maybe<Scalars['String']['output']>;
  readonly transport_mode?: Maybe<Scalars['String']['output']>;
  readonly validity_end?: Maybe<Scalars['String']['output']>;
  readonly validity_start?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
  readonly water_submode?: Maybe<Scalars['String']['output']>;
  readonly weighting?: Maybe<Scalars['String']['output']>;
};

/** input type for inserting object relation for remote table "stop_place_newest_version" */
export type StopsDatabaseStopPlaceNewestVersionObjRelInsertInput = {
  readonly data: StopsDatabaseStopPlaceNewestVersionInsertInput;
};

/** Ordering options when selecting data from "stop_place_newest_version". */
export type StopsDatabaseStopPlaceNewestVersionOrderBy = {
  readonly accessibility_assessment_id?: InputMaybe<OrderBy>;
  readonly air_submode?: InputMaybe<OrderBy>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<OrderBy>;
  readonly border_crossing?: InputMaybe<OrderBy>;
  readonly bus_submode?: InputMaybe<OrderBy>;
  readonly centroid?: InputMaybe<OrderBy>;
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly children_aggregate?: InputMaybe<StopsDatabaseStopPlaceChildrenAggregateOrderBy>;
  readonly coach_submode?: InputMaybe<OrderBy>;
  readonly covered?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly description_lang?: InputMaybe<OrderBy>;
  readonly description_value?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly funicular_submode?: InputMaybe<OrderBy>;
  readonly group_of_stop_places_members_aggregate?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersAggregateOrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly is_area?: InputMaybe<OrderBy>;
  readonly is_terminal?: InputMaybe<OrderBy>;
  readonly metro_submode?: InputMaybe<OrderBy>;
  readonly modification_enumeration?: InputMaybe<OrderBy>;
  readonly name_lang?: InputMaybe<OrderBy>;
  readonly name_value?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly parent?: InputMaybe<StopsDatabaseStopPlaceChildrenOrderBy>;
  readonly parent_site_ref?: InputMaybe<OrderBy>;
  readonly parent_site_ref_version?: InputMaybe<OrderBy>;
  readonly parent_stop_place?: InputMaybe<OrderBy>;
  readonly place_equipments_id?: InputMaybe<OrderBy>;
  readonly polygon_id?: InputMaybe<OrderBy>;
  readonly priority?: InputMaybe<OrderBy>;
  readonly private_code_type?: InputMaybe<OrderBy>;
  readonly private_code_value?: InputMaybe<OrderBy>;
  readonly public_code?: InputMaybe<OrderBy>;
  readonly rail_submode?: InputMaybe<OrderBy>;
  readonly short_name_lang?: InputMaybe<OrderBy>;
  readonly short_name_value?: InputMaybe<OrderBy>;
  readonly stop_place_access_spaces_aggregate?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesAggregateOrderBy>;
  readonly stop_place_alternative_names_aggregate?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesAggregateOrderBy>;
  readonly stop_place_equipment_places_aggregate?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesAggregateOrderBy>;
  readonly stop_place_key_values_aggregate?: InputMaybe<StopsDatabaseStopPlaceKeyValuesAggregateOrderBy>;
  readonly stop_place_quays_aggregate?: InputMaybe<StopsDatabaseStopPlaceQuaysAggregateOrderBy>;
  readonly stop_place_tariff_zones_aggregate?: InputMaybe<StopsDatabaseStopPlaceTariffZonesAggregateOrderBy>;
  readonly stop_place_type?: InputMaybe<OrderBy>;
  readonly street_address?: InputMaybe<OrderBy>;
  readonly telecabin_submode?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly topographic_place_id?: InputMaybe<OrderBy>;
  readonly tram_submode?: InputMaybe<OrderBy>;
  readonly transport_mode?: InputMaybe<OrderBy>;
  readonly validity_end?: InputMaybe<OrderBy>;
  readonly validity_start?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
  readonly water_submode?: InputMaybe<OrderBy>;
  readonly weighting?: InputMaybe<OrderBy>;
};

/** select columns of table "stop_place_newest_version" */
export enum StopsDatabaseStopPlaceNewestVersionSelectColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AirSubmode = 'air_submode',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  BorderCrossing = 'border_crossing',
  /** column name */
  BusSubmode = 'bus_submode',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  CoachSubmode = 'coach_submode',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  FunicularSubmode = 'funicular_submode',
  /** column name */
  Id = 'id',
  /** column name */
  IsArea = 'is_area',
  /** column name */
  IsTerminal = 'is_terminal',
  /** column name */
  MetroSubmode = 'metro_submode',
  /** column name */
  ModificationEnumeration = 'modification_enumeration',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ParentSiteRef = 'parent_site_ref',
  /** column name */
  ParentSiteRefVersion = 'parent_site_ref_version',
  /** column name */
  ParentStopPlace = 'parent_stop_place',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  Priority = 'priority',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  PublicCode = 'public_code',
  /** column name */
  RailSubmode = 'rail_submode',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  StopPlaceType = 'stop_place_type',
  /** column name */
  StreetAddress = 'street_address',
  /** column name */
  TelecabinSubmode = 'telecabin_submode',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TopographicPlaceId = 'topographic_place_id',
  /** column name */
  TramSubmode = 'tram_submode',
  /** column name */
  TransportMode = 'transport_mode',
  /** column name */
  ValidityEnd = 'validity_end',
  /** column name */
  ValidityStart = 'validity_start',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  WaterSubmode = 'water_submode',
  /** column name */
  Weighting = 'weighting'
}

/** aggregate stddev on columns */
export type StopsDatabaseStopPlaceNewestVersionStddevFields = {
  readonly __typename?: 'stops_database_stop_place_newest_version_stddev_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseStopPlaceNewestVersionStddevPopFields = {
  readonly __typename?: 'stops_database_stop_place_newest_version_stddev_pop_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseStopPlaceNewestVersionStddevSampFields = {
  readonly __typename?: 'stops_database_stop_place_newest_version_stddev_samp_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "stop_place_newest_version" */
export type StopsDatabaseStopPlaceNewestVersionStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseStopPlaceNewestVersionStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseStopPlaceNewestVersionStreamCursorValueInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly air_submode?: InputMaybe<Scalars['String']['input']>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  readonly border_crossing?: InputMaybe<Scalars['Boolean']['input']>;
  readonly bus_submode?: InputMaybe<Scalars['String']['input']>;
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly coach_submode?: InputMaybe<Scalars['String']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly funicular_submode?: InputMaybe<Scalars['String']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly is_area?: InputMaybe<Scalars['Boolean']['input']>;
  readonly is_terminal?: InputMaybe<Scalars['Boolean']['input']>;
  readonly metro_submode?: InputMaybe<Scalars['String']['input']>;
  readonly modification_enumeration?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly parent_site_ref?: InputMaybe<Scalars['String']['input']>;
  readonly parent_site_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly parent_stop_place?: InputMaybe<Scalars['Boolean']['input']>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly priority?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly public_code?: InputMaybe<Scalars['String']['input']>;
  readonly rail_submode?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly stop_place_type?: InputMaybe<Scalars['String']['input']>;
  readonly street_address?: InputMaybe<Scalars['String']['input']>;
  readonly telecabin_submode?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly topographic_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly tram_submode?: InputMaybe<Scalars['String']['input']>;
  readonly transport_mode?: InputMaybe<Scalars['String']['input']>;
  readonly validity_end?: InputMaybe<Scalars['String']['input']>;
  readonly validity_start?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
  readonly water_submode?: InputMaybe<Scalars['String']['input']>;
  readonly weighting?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseStopPlaceNewestVersionSumFields = {
  readonly __typename?: 'stops_database_stop_place_newest_version_sum_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate var_pop on columns */
export type StopsDatabaseStopPlaceNewestVersionVarPopFields = {
  readonly __typename?: 'stops_database_stop_place_newest_version_var_pop_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseStopPlaceNewestVersionVarSampFields = {
  readonly __typename?: 'stops_database_stop_place_newest_version_var_samp_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseStopPlaceNewestVersionVarianceFields = {
  readonly __typename?: 'stops_database_stop_place_newest_version_variance_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** input type for inserting object relation for remote table "stop_place" */
export type StopsDatabaseStopPlaceObjRelInsertInput = {
  readonly data: StopsDatabaseStopPlaceInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseStopPlaceOnConflict>;
};

/** on_conflict condition type for table "stop_place" */
export type StopsDatabaseStopPlaceOnConflict = {
  readonly constraint: StopsDatabaseStopPlaceConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseStopPlaceUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseStopPlaceBoolExp>;
};

/** Ordering options when selecting data from "stop_place". */
export type StopsDatabaseStopPlaceOrderBy = {
  readonly accessibility_assessment?: InputMaybe<StopsDatabaseAccessibilityAssessmentOrderBy>;
  readonly accessibility_assessment_id?: InputMaybe<OrderBy>;
  readonly air_submode?: InputMaybe<OrderBy>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<OrderBy>;
  readonly border_crossing?: InputMaybe<OrderBy>;
  readonly bus_submode?: InputMaybe<OrderBy>;
  readonly centroid?: InputMaybe<OrderBy>;
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly coach_submode?: InputMaybe<OrderBy>;
  readonly covered?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly description_lang?: InputMaybe<OrderBy>;
  readonly description_value?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly funicular_submode?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly installed_equipment_version_structure?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureOrderBy>;
  readonly metro_submode?: InputMaybe<OrderBy>;
  readonly modification_enumeration?: InputMaybe<OrderBy>;
  readonly name_lang?: InputMaybe<OrderBy>;
  readonly name_value?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly parent_site_ref?: InputMaybe<OrderBy>;
  readonly parent_site_ref_version?: InputMaybe<OrderBy>;
  readonly parent_stop_place?: InputMaybe<OrderBy>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonOrderBy>;
  readonly place_equipments_id?: InputMaybe<OrderBy>;
  readonly polygon_id?: InputMaybe<OrderBy>;
  readonly private_code_type?: InputMaybe<OrderBy>;
  readonly private_code_value?: InputMaybe<OrderBy>;
  readonly public_code?: InputMaybe<OrderBy>;
  readonly rail_submode?: InputMaybe<OrderBy>;
  readonly short_name_lang?: InputMaybe<OrderBy>;
  readonly short_name_value?: InputMaybe<OrderBy>;
  readonly stop_place_access_spaces_aggregate?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesAggregateOrderBy>;
  readonly stop_place_alternative_names_aggregate?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesAggregateOrderBy>;
  readonly stop_place_child?: InputMaybe<StopsDatabaseStopPlaceChildrenOrderBy>;
  readonly stop_place_children_aggregate?: InputMaybe<StopsDatabaseStopPlaceChildrenAggregateOrderBy>;
  readonly stop_place_equipment_places_aggregate?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesAggregateOrderBy>;
  readonly stop_place_key_values_aggregate?: InputMaybe<StopsDatabaseStopPlaceKeyValuesAggregateOrderBy>;
  readonly stop_place_quays_aggregate?: InputMaybe<StopsDatabaseStopPlaceQuaysAggregateOrderBy>;
  readonly stop_place_tariff_zones_aggregate?: InputMaybe<StopsDatabaseStopPlaceTariffZonesAggregateOrderBy>;
  readonly stop_place_type?: InputMaybe<OrderBy>;
  readonly telecabin_submode?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly topographic_place?: InputMaybe<StopsDatabaseTopographicPlaceOrderBy>;
  readonly topographic_place_id?: InputMaybe<OrderBy>;
  readonly tram_submode?: InputMaybe<OrderBy>;
  readonly transport_mode?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
  readonly water_submode?: InputMaybe<OrderBy>;
  readonly weighting?: InputMaybe<OrderBy>;
};

/** columns and relationships of "stop_place_organisations" */
export type StopsDatabaseStopPlaceOrganisations = {
  readonly __typename?: 'stops_database_stop_place_organisations';
  readonly organisation_ref: Scalars['String']['output'];
  readonly relationship_type: Scalars['String']['output'];
  readonly stop_place_id: Scalars['bigint']['output'];
};

/** aggregated selection of "stop_place_organisations" */
export type StopsDatabaseStopPlaceOrganisationsAggregate = {
  readonly __typename?: 'stops_database_stop_place_organisations_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseStopPlaceOrganisationsAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseStopPlaceOrganisations>;
};

/** aggregate fields of "stop_place_organisations" */
export type StopsDatabaseStopPlaceOrganisationsAggregateFields = {
  readonly __typename?: 'stops_database_stop_place_organisations_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseStopPlaceOrganisationsAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseStopPlaceOrganisationsMaxFields>;
  readonly min?: Maybe<StopsDatabaseStopPlaceOrganisationsMinFields>;
  readonly stddev?: Maybe<StopsDatabaseStopPlaceOrganisationsStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseStopPlaceOrganisationsStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseStopPlaceOrganisationsStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseStopPlaceOrganisationsSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseStopPlaceOrganisationsVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseStopPlaceOrganisationsVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseStopPlaceOrganisationsVarianceFields>;
};


/** aggregate fields of "stop_place_organisations" */
export type StopsDatabaseStopPlaceOrganisationsAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceOrganisationsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseStopPlaceOrganisationsAvgFields = {
  readonly __typename?: 'stops_database_stop_place_organisations_avg_fields';
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "stop_place_organisations". All fields are combined with a logical 'AND'. */
export type StopsDatabaseStopPlaceOrganisationsBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceOrganisationsBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseStopPlaceOrganisationsBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceOrganisationsBoolExp>>;
  readonly organisation_ref?: InputMaybe<StringComparisonExp>;
  readonly relationship_type?: InputMaybe<StringComparisonExp>;
  readonly stop_place_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "stop_place_organisations" */
export enum StopsDatabaseStopPlaceOrganisationsConstraint {
  /** unique or primary key constraint on columns "relationship_type", "stop_place_id", "organisation_ref" */
  StopPlaceOrganisationsPkey = 'stop_place_organisations_pkey'
}

/** input type for incrementing numeric columns in table "stop_place_organisations" */
export type StopsDatabaseStopPlaceOrganisationsIncInput = {
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "stop_place_organisations" */
export type StopsDatabaseStopPlaceOrganisationsInsertInput = {
  readonly organisation_ref?: InputMaybe<Scalars['String']['input']>;
  readonly relationship_type?: InputMaybe<Scalars['String']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseStopPlaceOrganisationsMaxFields = {
  readonly __typename?: 'stops_database_stop_place_organisations_max_fields';
  readonly organisation_ref?: Maybe<Scalars['String']['output']>;
  readonly relationship_type?: Maybe<Scalars['String']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseStopPlaceOrganisationsMinFields = {
  readonly __typename?: 'stops_database_stop_place_organisations_min_fields';
  readonly organisation_ref?: Maybe<Scalars['String']['output']>;
  readonly relationship_type?: Maybe<Scalars['String']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
};

/** response of any mutation on the table "stop_place_organisations" */
export type StopsDatabaseStopPlaceOrganisationsMutationResponse = {
  readonly __typename?: 'stops_database_stop_place_organisations_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseStopPlaceOrganisations>;
};

/** on_conflict condition type for table "stop_place_organisations" */
export type StopsDatabaseStopPlaceOrganisationsOnConflict = {
  readonly constraint: StopsDatabaseStopPlaceOrganisationsConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseStopPlaceOrganisationsUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseStopPlaceOrganisationsBoolExp>;
};

/** Ordering options when selecting data from "stop_place_organisations". */
export type StopsDatabaseStopPlaceOrganisationsOrderBy = {
  readonly organisation_ref?: InputMaybe<OrderBy>;
  readonly relationship_type?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: stop_place_organisations */
export type StopsDatabaseStopPlaceOrganisationsPkColumnsInput = {
  readonly organisation_ref: Scalars['String']['input'];
  readonly relationship_type: Scalars['String']['input'];
  readonly stop_place_id: Scalars['bigint']['input'];
};

/** select columns of table "stop_place_organisations" */
export enum StopsDatabaseStopPlaceOrganisationsSelectColumn {
  /** column name */
  OrganisationRef = 'organisation_ref',
  /** column name */
  RelationshipType = 'relationship_type',
  /** column name */
  StopPlaceId = 'stop_place_id'
}

/** input type for updating data in table "stop_place_organisations" */
export type StopsDatabaseStopPlaceOrganisationsSetInput = {
  readonly organisation_ref?: InputMaybe<Scalars['String']['input']>;
  readonly relationship_type?: InputMaybe<Scalars['String']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseStopPlaceOrganisationsStddevFields = {
  readonly __typename?: 'stops_database_stop_place_organisations_stddev_fields';
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseStopPlaceOrganisationsStddevPopFields = {
  readonly __typename?: 'stops_database_stop_place_organisations_stddev_pop_fields';
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseStopPlaceOrganisationsStddevSampFields = {
  readonly __typename?: 'stops_database_stop_place_organisations_stddev_samp_fields';
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "stop_place_organisations" */
export type StopsDatabaseStopPlaceOrganisationsStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseStopPlaceOrganisationsStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseStopPlaceOrganisationsStreamCursorValueInput = {
  readonly organisation_ref?: InputMaybe<Scalars['String']['input']>;
  readonly relationship_type?: InputMaybe<Scalars['String']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseStopPlaceOrganisationsSumFields = {
  readonly __typename?: 'stops_database_stop_place_organisations_sum_fields';
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "stop_place_organisations" */
export enum StopsDatabaseStopPlaceOrganisationsUpdateColumn {
  /** column name */
  OrganisationRef = 'organisation_ref',
  /** column name */
  RelationshipType = 'relationship_type',
  /** column name */
  StopPlaceId = 'stop_place_id'
}

export type StopsDatabaseStopPlaceOrganisationsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseStopPlaceOrganisationsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseStopPlaceOrganisationsSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseStopPlaceOrganisationsBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseStopPlaceOrganisationsVarPopFields = {
  readonly __typename?: 'stops_database_stop_place_organisations_var_pop_fields';
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseStopPlaceOrganisationsVarSampFields = {
  readonly __typename?: 'stops_database_stop_place_organisations_var_samp_fields';
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseStopPlaceOrganisationsVarianceFields = {
  readonly __typename?: 'stops_database_stop_place_organisations_variance_fields';
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** primary key columns input for table: stop_place */
export type StopsDatabaseStopPlacePkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** columns and relationships of "stop_place_quays" */
export type StopsDatabaseStopPlaceQuays = {
  readonly __typename?: 'stops_database_stop_place_quays';
  /** An object relationship */
  readonly quay: StopsDatabaseQuay;
  readonly quays_id: Scalars['bigint']['output'];
  readonly stop_place_id: Scalars['bigint']['output'];
};

/** aggregated selection of "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysAggregate = {
  readonly __typename?: 'stops_database_stop_place_quays_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseStopPlaceQuaysAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseStopPlaceQuays>;
};

/** aggregate fields of "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysAggregateFields = {
  readonly __typename?: 'stops_database_stop_place_quays_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseStopPlaceQuaysAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseStopPlaceQuaysMaxFields>;
  readonly min?: Maybe<StopsDatabaseStopPlaceQuaysMinFields>;
  readonly stddev?: Maybe<StopsDatabaseStopPlaceQuaysStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseStopPlaceQuaysStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseStopPlaceQuaysStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseStopPlaceQuaysSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseStopPlaceQuaysVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseStopPlaceQuaysVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseStopPlaceQuaysVarianceFields>;
};


/** aggregate fields of "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceQuaysSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseStopPlaceQuaysAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseStopPlaceQuaysMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseStopPlaceQuaysMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseStopPlaceQuaysStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseStopPlaceQuaysStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseStopPlaceQuaysStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseStopPlaceQuaysSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseStopPlaceQuaysVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseStopPlaceQuaysVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseStopPlaceQuaysVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseStopPlaceQuaysInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseStopPlaceQuaysOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseStopPlaceQuaysAvgFields = {
  readonly __typename?: 'stops_database_stop_place_quays_avg_fields';
  readonly quays_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysAvgOrderBy = {
  readonly quays_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "stop_place_quays". All fields are combined with a logical 'AND'. */
export type StopsDatabaseStopPlaceQuaysBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceQuaysBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseStopPlaceQuaysBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceQuaysBoolExp>>;
  readonly quay?: InputMaybe<StopsDatabaseQuayBoolExp>;
  readonly quays_id?: InputMaybe<BigintComparisonExp>;
  readonly stop_place_id?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "stop_place_quays" */
export enum StopsDatabaseStopPlaceQuaysConstraint {
  /** unique or primary key constraint on columns "quays_id", "stop_place_id" */
  StopPlaceQuaysPkey = 'stop_place_quays_pkey',
  /** unique or primary key constraint on columns "quays_id" */
  UkF684i92mysvn6hqigs0j3m2nr = 'uk_f684i92mysvn6hqigs0j3m2nr'
}

/** input type for incrementing numeric columns in table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysIncInput = {
  readonly quays_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysInsertInput = {
  readonly quay?: InputMaybe<StopsDatabaseQuayObjRelInsertInput>;
  readonly quays_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseStopPlaceQuaysMaxFields = {
  readonly __typename?: 'stops_database_stop_place_quays_max_fields';
  readonly quays_id?: Maybe<Scalars['bigint']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysMaxOrderBy = {
  readonly quays_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseStopPlaceQuaysMinFields = {
  readonly __typename?: 'stops_database_stop_place_quays_min_fields';
  readonly quays_id?: Maybe<Scalars['bigint']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysMinOrderBy = {
  readonly quays_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysMutationResponse = {
  readonly __typename?: 'stops_database_stop_place_quays_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseStopPlaceQuays>;
};

/** on_conflict condition type for table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysOnConflict = {
  readonly constraint: StopsDatabaseStopPlaceQuaysConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseStopPlaceQuaysUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseStopPlaceQuaysBoolExp>;
};

/** Ordering options when selecting data from "stop_place_quays". */
export type StopsDatabaseStopPlaceQuaysOrderBy = {
  readonly quay?: InputMaybe<StopsDatabaseQuayOrderBy>;
  readonly quays_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: stop_place_quays */
export type StopsDatabaseStopPlaceQuaysPkColumnsInput = {
  readonly quays_id: Scalars['bigint']['input'];
  readonly stop_place_id: Scalars['bigint']['input'];
};

/** select columns of table "stop_place_quays" */
export enum StopsDatabaseStopPlaceQuaysSelectColumn {
  /** column name */
  QuaysId = 'quays_id',
  /** column name */
  StopPlaceId = 'stop_place_id'
}

/** input type for updating data in table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysSetInput = {
  readonly quays_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseStopPlaceQuaysStddevFields = {
  readonly __typename?: 'stops_database_stop_place_quays_stddev_fields';
  readonly quays_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysStddevOrderBy = {
  readonly quays_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseStopPlaceQuaysStddevPopFields = {
  readonly __typename?: 'stops_database_stop_place_quays_stddev_pop_fields';
  readonly quays_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysStddevPopOrderBy = {
  readonly quays_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseStopPlaceQuaysStddevSampFields = {
  readonly __typename?: 'stops_database_stop_place_quays_stddev_samp_fields';
  readonly quays_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysStddevSampOrderBy = {
  readonly quays_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseStopPlaceQuaysStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseStopPlaceQuaysStreamCursorValueInput = {
  readonly quays_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseStopPlaceQuaysSumFields = {
  readonly __typename?: 'stops_database_stop_place_quays_sum_fields';
  readonly quays_id?: Maybe<Scalars['bigint']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysSumOrderBy = {
  readonly quays_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** update columns of table "stop_place_quays" */
export enum StopsDatabaseStopPlaceQuaysUpdateColumn {
  /** column name */
  QuaysId = 'quays_id',
  /** column name */
  StopPlaceId = 'stop_place_id'
}

export type StopsDatabaseStopPlaceQuaysUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseStopPlaceQuaysIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseStopPlaceQuaysSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseStopPlaceQuaysBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseStopPlaceQuaysVarPopFields = {
  readonly __typename?: 'stops_database_stop_place_quays_var_pop_fields';
  readonly quays_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysVarPopOrderBy = {
  readonly quays_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseStopPlaceQuaysVarSampFields = {
  readonly __typename?: 'stops_database_stop_place_quays_var_samp_fields';
  readonly quays_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysVarSampOrderBy = {
  readonly quays_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseStopPlaceQuaysVarianceFields = {
  readonly __typename?: 'stops_database_stop_place_quays_variance_fields';
  readonly quays_id?: Maybe<Scalars['Float']['output']>;
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "stop_place_quays" */
export type StopsDatabaseStopPlaceQuaysVarianceOrderBy = {
  readonly quays_id?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** select columns of table "stop_place" */
export enum StopsDatabaseStopPlaceSelectColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AirSubmode = 'air_submode',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  BorderCrossing = 'border_crossing',
  /** column name */
  BusSubmode = 'bus_submode',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  CoachSubmode = 'coach_submode',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  FunicularSubmode = 'funicular_submode',
  /** column name */
  Id = 'id',
  /** column name */
  MetroSubmode = 'metro_submode',
  /** column name */
  ModificationEnumeration = 'modification_enumeration',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ParentSiteRef = 'parent_site_ref',
  /** column name */
  ParentSiteRefVersion = 'parent_site_ref_version',
  /** column name */
  ParentStopPlace = 'parent_stop_place',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  PublicCode = 'public_code',
  /** column name */
  RailSubmode = 'rail_submode',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  StopPlaceType = 'stop_place_type',
  /** column name */
  TelecabinSubmode = 'telecabin_submode',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TopographicPlaceId = 'topographic_place_id',
  /** column name */
  TramSubmode = 'tram_submode',
  /** column name */
  TransportMode = 'transport_mode',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  WaterSubmode = 'water_submode',
  /** column name */
  Weighting = 'weighting'
}

/** input type for updating data in table "stop_place" */
export type StopsDatabaseStopPlaceSetInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly air_submode?: InputMaybe<Scalars['String']['input']>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  readonly border_crossing?: InputMaybe<Scalars['Boolean']['input']>;
  readonly bus_submode?: InputMaybe<Scalars['String']['input']>;
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly coach_submode?: InputMaybe<Scalars['String']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly funicular_submode?: InputMaybe<Scalars['String']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly metro_submode?: InputMaybe<Scalars['String']['input']>;
  readonly modification_enumeration?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly parent_site_ref?: InputMaybe<Scalars['String']['input']>;
  readonly parent_site_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly parent_stop_place?: InputMaybe<Scalars['Boolean']['input']>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly public_code?: InputMaybe<Scalars['String']['input']>;
  readonly rail_submode?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly stop_place_type?: InputMaybe<Scalars['String']['input']>;
  readonly telecabin_submode?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly topographic_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly tram_submode?: InputMaybe<Scalars['String']['input']>;
  readonly transport_mode?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
  readonly water_submode?: InputMaybe<Scalars['String']['input']>;
  readonly weighting?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseStopPlaceStddevFields = {
  readonly __typename?: 'stops_database_stop_place_stddev_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseStopPlaceStddevPopFields = {
  readonly __typename?: 'stops_database_stop_place_stddev_pop_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseStopPlaceStddevSampFields = {
  readonly __typename?: 'stops_database_stop_place_stddev_samp_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "stop_place" */
export type StopsDatabaseStopPlaceStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseStopPlaceStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseStopPlaceStreamCursorValueInput = {
  readonly accessibility_assessment_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly air_submode?: InputMaybe<Scalars['String']['input']>;
  readonly all_areas_wheelchair_accessible?: InputMaybe<Scalars['Boolean']['input']>;
  readonly border_crossing?: InputMaybe<Scalars['Boolean']['input']>;
  readonly bus_submode?: InputMaybe<Scalars['String']['input']>;
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly coach_submode?: InputMaybe<Scalars['String']['input']>;
  readonly covered?: InputMaybe<Scalars['Int']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly funicular_submode?: InputMaybe<Scalars['String']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly metro_submode?: InputMaybe<Scalars['String']['input']>;
  readonly modification_enumeration?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly parent_site_ref?: InputMaybe<Scalars['String']['input']>;
  readonly parent_site_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly parent_stop_place?: InputMaybe<Scalars['Boolean']['input']>;
  readonly place_equipments_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly public_code?: InputMaybe<Scalars['String']['input']>;
  readonly rail_submode?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly stop_place_type?: InputMaybe<Scalars['String']['input']>;
  readonly telecabin_submode?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly topographic_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly tram_submode?: InputMaybe<Scalars['String']['input']>;
  readonly transport_mode?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
  readonly water_submode?: InputMaybe<Scalars['String']['input']>;
  readonly weighting?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseStopPlaceSumFields = {
  readonly __typename?: 'stops_database_stop_place_sum_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['bigint']['output']>;
  readonly covered?: Maybe<Scalars['Int']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** columns and relationships of "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZones = {
  readonly __typename?: 'stops_database_stop_place_tariff_zones';
  readonly ref?: Maybe<Scalars['String']['output']>;
  readonly stop_place_id: Scalars['bigint']['output'];
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesAggregate = {
  readonly __typename?: 'stops_database_stop_place_tariff_zones_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseStopPlaceTariffZonesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseStopPlaceTariffZones>;
};

/** aggregate fields of "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesAggregateFields = {
  readonly __typename?: 'stops_database_stop_place_tariff_zones_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseStopPlaceTariffZonesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseStopPlaceTariffZonesMaxFields>;
  readonly min?: Maybe<StopsDatabaseStopPlaceTariffZonesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseStopPlaceTariffZonesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseStopPlaceTariffZonesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseStopPlaceTariffZonesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseStopPlaceTariffZonesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseStopPlaceTariffZonesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseStopPlaceTariffZonesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseStopPlaceTariffZonesVarianceFields>;
};


/** aggregate fields of "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceTariffZonesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseStopPlaceTariffZonesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseStopPlaceTariffZonesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseStopPlaceTariffZonesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseStopPlaceTariffZonesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseStopPlaceTariffZonesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseStopPlaceTariffZonesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseStopPlaceTariffZonesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseStopPlaceTariffZonesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseStopPlaceTariffZonesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseStopPlaceTariffZonesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseStopPlaceTariffZonesInsertInput>;
};

/** aggregate avg on columns */
export type StopsDatabaseStopPlaceTariffZonesAvgFields = {
  readonly __typename?: 'stops_database_stop_place_tariff_zones_avg_fields';
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesAvgOrderBy = {
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "stop_place_tariff_zones". All fields are combined with a logical 'AND'. */
export type StopsDatabaseStopPlaceTariffZonesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceTariffZonesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseStopPlaceTariffZonesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceTariffZonesBoolExp>>;
  readonly ref?: InputMaybe<StringComparisonExp>;
  readonly stop_place_id?: InputMaybe<BigintComparisonExp>;
  readonly version?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesIncInput = {
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesInsertInput = {
  readonly ref?: InputMaybe<Scalars['String']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseStopPlaceTariffZonesMaxFields = {
  readonly __typename?: 'stops_database_stop_place_tariff_zones_max_fields';
  readonly ref?: Maybe<Scalars['String']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesMaxOrderBy = {
  readonly ref?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseStopPlaceTariffZonesMinFields = {
  readonly __typename?: 'stops_database_stop_place_tariff_zones_min_fields';
  readonly ref?: Maybe<Scalars['String']['output']>;
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesMinOrderBy = {
  readonly ref?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesMutationResponse = {
  readonly __typename?: 'stops_database_stop_place_tariff_zones_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseStopPlaceTariffZones>;
};

/** Ordering options when selecting data from "stop_place_tariff_zones". */
export type StopsDatabaseStopPlaceTariffZonesOrderBy = {
  readonly ref?: InputMaybe<OrderBy>;
  readonly stop_place_id?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
};

/** select columns of table "stop_place_tariff_zones" */
export enum StopsDatabaseStopPlaceTariffZonesSelectColumn {
  /** column name */
  Ref = 'ref',
  /** column name */
  StopPlaceId = 'stop_place_id',
  /** column name */
  Version = 'version'
}

/** input type for updating data in table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesSetInput = {
  readonly ref?: InputMaybe<Scalars['String']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseStopPlaceTariffZonesStddevFields = {
  readonly __typename?: 'stops_database_stop_place_tariff_zones_stddev_fields';
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesStddevOrderBy = {
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseStopPlaceTariffZonesStddevPopFields = {
  readonly __typename?: 'stops_database_stop_place_tariff_zones_stddev_pop_fields';
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesStddevPopOrderBy = {
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseStopPlaceTariffZonesStddevSampFields = {
  readonly __typename?: 'stops_database_stop_place_tariff_zones_stddev_samp_fields';
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesStddevSampOrderBy = {
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseStopPlaceTariffZonesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseStopPlaceTariffZonesStreamCursorValueInput = {
  readonly ref?: InputMaybe<Scalars['String']['input']>;
  readonly stop_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseStopPlaceTariffZonesSumFields = {
  readonly __typename?: 'stops_database_stop_place_tariff_zones_sum_fields';
  readonly stop_place_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesSumOrderBy = {
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

export type StopsDatabaseStopPlaceTariffZonesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseStopPlaceTariffZonesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseStopPlaceTariffZonesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseStopPlaceTariffZonesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseStopPlaceTariffZonesVarPopFields = {
  readonly __typename?: 'stops_database_stop_place_tariff_zones_var_pop_fields';
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesVarPopOrderBy = {
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseStopPlaceTariffZonesVarSampFields = {
  readonly __typename?: 'stops_database_stop_place_tariff_zones_var_samp_fields';
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesVarSampOrderBy = {
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseStopPlaceTariffZonesVarianceFields = {
  readonly __typename?: 'stops_database_stop_place_tariff_zones_variance_fields';
  readonly stop_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "stop_place_tariff_zones" */
export type StopsDatabaseStopPlaceTariffZonesVarianceOrderBy = {
  readonly stop_place_id?: InputMaybe<OrderBy>;
};

/** update columns of table "stop_place" */
export enum StopsDatabaseStopPlaceUpdateColumn {
  /** column name */
  AccessibilityAssessmentId = 'accessibility_assessment_id',
  /** column name */
  AirSubmode = 'air_submode',
  /** column name */
  AllAreasWheelchairAccessible = 'all_areas_wheelchair_accessible',
  /** column name */
  BorderCrossing = 'border_crossing',
  /** column name */
  BusSubmode = 'bus_submode',
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  CoachSubmode = 'coach_submode',
  /** column name */
  Covered = 'covered',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  FunicularSubmode = 'funicular_submode',
  /** column name */
  Id = 'id',
  /** column name */
  MetroSubmode = 'metro_submode',
  /** column name */
  ModificationEnumeration = 'modification_enumeration',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ParentSiteRef = 'parent_site_ref',
  /** column name */
  ParentSiteRefVersion = 'parent_site_ref_version',
  /** column name */
  ParentStopPlace = 'parent_stop_place',
  /** column name */
  PlaceEquipmentsId = 'place_equipments_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  PublicCode = 'public_code',
  /** column name */
  RailSubmode = 'rail_submode',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  StopPlaceType = 'stop_place_type',
  /** column name */
  TelecabinSubmode = 'telecabin_submode',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TopographicPlaceId = 'topographic_place_id',
  /** column name */
  TramSubmode = 'tram_submode',
  /** column name */
  TransportMode = 'transport_mode',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment',
  /** column name */
  WaterSubmode = 'water_submode',
  /** column name */
  Weighting = 'weighting'
}

export type StopsDatabaseStopPlaceUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseStopPlaceIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseStopPlaceSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseStopPlaceBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseStopPlaceVarPopFields = {
  readonly __typename?: 'stops_database_stop_place_var_pop_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseStopPlaceVarSampFields = {
  readonly __typename?: 'stops_database_stop_place_var_samp_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseStopPlaceVarianceFields = {
  readonly __typename?: 'stops_database_stop_place_variance_fields';
  readonly accessibility_assessment_id?: Maybe<Scalars['Float']['output']>;
  readonly covered?: Maybe<Scalars['Float']['output']>;
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly place_equipments_id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

export type StopsDatabaseStopsDatabaseMutationFrontend = {
  readonly __typename?: 'stops_database_stops_database_mutation_frontend';
  /** delete data from the table: "access_space" */
  readonly stops_database_delete_access_space?: Maybe<StopsDatabaseAccessSpaceMutationResponse>;
  /** delete data from the table: "access_space_alternative_names" */
  readonly stops_database_delete_access_space_alternative_names?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesMutationResponse>;
  /** delete single row from the table: "access_space" */
  readonly stops_database_delete_access_space_by_pk?: Maybe<StopsDatabaseAccessSpace>;
  /** delete data from the table: "access_space_check_constraints" */
  readonly stops_database_delete_access_space_check_constraints?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsMutationResponse>;
  /** delete data from the table: "access_space_equipment_places" */
  readonly stops_database_delete_access_space_equipment_places?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesMutationResponse>;
  /** delete data from the table: "access_space_key_values" */
  readonly stops_database_delete_access_space_key_values?: Maybe<StopsDatabaseAccessSpaceKeyValuesMutationResponse>;
  /** delete single row from the table: "access_space_key_values" */
  readonly stops_database_delete_access_space_key_values_by_pk?: Maybe<StopsDatabaseAccessSpaceKeyValues>;
  /** delete data from the table: "accessibility_assessment" */
  readonly stops_database_delete_accessibility_assessment?: Maybe<StopsDatabaseAccessibilityAssessmentMutationResponse>;
  /** delete single row from the table: "accessibility_assessment" */
  readonly stops_database_delete_accessibility_assessment_by_pk?: Maybe<StopsDatabaseAccessibilityAssessment>;
  /** delete data from the table: "accessibility_assessment_limitations" */
  readonly stops_database_delete_accessibility_assessment_limitations?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsMutationResponse>;
  /** delete data from the table: "accessibility_limitation" */
  readonly stops_database_delete_accessibility_limitation?: Maybe<StopsDatabaseAccessibilityLimitationMutationResponse>;
  /** delete single row from the table: "accessibility_limitation" */
  readonly stops_database_delete_accessibility_limitation_by_pk?: Maybe<StopsDatabaseAccessibilityLimitation>;
  /** delete data from the table: "alternative_name" */
  readonly stops_database_delete_alternative_name?: Maybe<StopsDatabaseAlternativeNameMutationResponse>;
  /** delete single row from the table: "alternative_name" */
  readonly stops_database_delete_alternative_name_by_pk?: Maybe<StopsDatabaseAlternativeName>;
  /** delete data from the table: "boarding_position" */
  readonly stops_database_delete_boarding_position?: Maybe<StopsDatabaseBoardingPositionMutationResponse>;
  /** delete data from the table: "boarding_position_alternative_names" */
  readonly stops_database_delete_boarding_position_alternative_names?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesMutationResponse>;
  /** delete single row from the table: "boarding_position" */
  readonly stops_database_delete_boarding_position_by_pk?: Maybe<StopsDatabaseBoardingPosition>;
  /** delete data from the table: "boarding_position_check_constraints" */
  readonly stops_database_delete_boarding_position_check_constraints?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsMutationResponse>;
  /** delete data from the table: "boarding_position_equipment_places" */
  readonly stops_database_delete_boarding_position_equipment_places?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesMutationResponse>;
  /** delete data from the table: "boarding_position_key_values" */
  readonly stops_database_delete_boarding_position_key_values?: Maybe<StopsDatabaseBoardingPositionKeyValuesMutationResponse>;
  /** delete single row from the table: "boarding_position_key_values" */
  readonly stops_database_delete_boarding_position_key_values_by_pk?: Maybe<StopsDatabaseBoardingPositionKeyValues>;
  /** delete data from the table: "check_constraint" */
  readonly stops_database_delete_check_constraint?: Maybe<StopsDatabaseCheckConstraintMutationResponse>;
  /** delete single row from the table: "check_constraint" */
  readonly stops_database_delete_check_constraint_by_pk?: Maybe<StopsDatabaseCheckConstraint>;
  /** delete data from the table: "check_constraint_key_values" */
  readonly stops_database_delete_check_constraint_key_values?: Maybe<StopsDatabaseCheckConstraintKeyValuesMutationResponse>;
  /** delete single row from the table: "check_constraint_key_values" */
  readonly stops_database_delete_check_constraint_key_values_by_pk?: Maybe<StopsDatabaseCheckConstraintKeyValues>;
  /** delete data from the table: "contact" */
  readonly stops_database_delete_contact?: Maybe<StopsDatabaseContactMutationResponse>;
  /** delete single row from the table: "contact" */
  readonly stops_database_delete_contact_by_pk?: Maybe<StopsDatabaseContact>;
  /** delete data from the table: "destination_display_view" */
  readonly stops_database_delete_destination_display_view?: Maybe<StopsDatabaseDestinationDisplayViewMutationResponse>;
  /** delete single row from the table: "destination_display_view" */
  readonly stops_database_delete_destination_display_view_by_pk?: Maybe<StopsDatabaseDestinationDisplayView>;
  /** delete data from the table: "equipment_place" */
  readonly stops_database_delete_equipment_place?: Maybe<StopsDatabaseEquipmentPlaceMutationResponse>;
  /** delete single row from the table: "equipment_place" */
  readonly stops_database_delete_equipment_place_by_pk?: Maybe<StopsDatabaseEquipmentPlace>;
  /** delete data from the table: "equipment_place_equipment_positions" */
  readonly stops_database_delete_equipment_place_equipment_positions?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsMutationResponse>;
  /** delete data from the table: "equipment_place_key_values" */
  readonly stops_database_delete_equipment_place_key_values?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesMutationResponse>;
  /** delete single row from the table: "equipment_place_key_values" */
  readonly stops_database_delete_equipment_place_key_values_by_pk?: Maybe<StopsDatabaseEquipmentPlaceKeyValues>;
  /** delete data from the table: "equipment_position" */
  readonly stops_database_delete_equipment_position?: Maybe<StopsDatabaseEquipmentPositionMutationResponse>;
  /** delete single row from the table: "equipment_position" */
  readonly stops_database_delete_equipment_position_by_pk?: Maybe<StopsDatabaseEquipmentPosition>;
  /** delete data from the table: "equipment_position_key_values" */
  readonly stops_database_delete_equipment_position_key_values?: Maybe<StopsDatabaseEquipmentPositionKeyValuesMutationResponse>;
  /** delete single row from the table: "equipment_position_key_values" */
  readonly stops_database_delete_equipment_position_key_values_by_pk?: Maybe<StopsDatabaseEquipmentPositionKeyValues>;
  /** delete data from the table: "export_job" */
  readonly stops_database_delete_export_job?: Maybe<StopsDatabaseExportJobMutationResponse>;
  /** delete single row from the table: "export_job" */
  readonly stops_database_delete_export_job_by_pk?: Maybe<StopsDatabaseExportJob>;
  /** delete data from the table: "fare_zone" */
  readonly stops_database_delete_fare_zone?: Maybe<StopsDatabaseFareZoneMutationResponse>;
  /** delete single row from the table: "fare_zone" */
  readonly stops_database_delete_fare_zone_by_pk?: Maybe<StopsDatabaseFareZone>;
  /** delete data from the table: "fare_zone_key_values" */
  readonly stops_database_delete_fare_zone_key_values?: Maybe<StopsDatabaseFareZoneKeyValuesMutationResponse>;
  /** delete single row from the table: "fare_zone_key_values" */
  readonly stops_database_delete_fare_zone_key_values_by_pk?: Maybe<StopsDatabaseFareZoneKeyValues>;
  /** delete data from the table: "fare_zone_members" */
  readonly stops_database_delete_fare_zone_members?: Maybe<StopsDatabaseFareZoneMembersMutationResponse>;
  /** delete data from the table: "fare_zone_neighbours" */
  readonly stops_database_delete_fare_zone_neighbours?: Maybe<StopsDatabaseFareZoneNeighboursMutationResponse>;
  /** delete data from the table: "geometry_columns" */
  readonly stops_database_delete_geometry_columns?: Maybe<StopsDatabaseGeometryColumnsMutationResponse>;
  /** delete data from the table: "group_of_stop_places" */
  readonly stops_database_delete_group_of_stop_places?: Maybe<StopsDatabaseGroupOfStopPlacesMutationResponse>;
  /** delete data from the table: "group_of_stop_places_alternative_names" */
  readonly stops_database_delete_group_of_stop_places_alternative_names?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesMutationResponse>;
  /** delete single row from the table: "group_of_stop_places" */
  readonly stops_database_delete_group_of_stop_places_by_pk?: Maybe<StopsDatabaseGroupOfStopPlaces>;
  /** delete data from the table: "group_of_stop_places_key_values" */
  readonly stops_database_delete_group_of_stop_places_key_values?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesMutationResponse>;
  /** delete single row from the table: "group_of_stop_places_key_values" */
  readonly stops_database_delete_group_of_stop_places_key_values_by_pk?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValues>;
  /** delete data from the table: "group_of_stop_places_members" */
  readonly stops_database_delete_group_of_stop_places_members?: Maybe<StopsDatabaseGroupOfStopPlacesMembersMutationResponse>;
  /** delete data from the table: "group_of_tariff_zones" */
  readonly stops_database_delete_group_of_tariff_zones?: Maybe<StopsDatabaseGroupOfTariffZonesMutationResponse>;
  /** delete single row from the table: "group_of_tariff_zones" */
  readonly stops_database_delete_group_of_tariff_zones_by_pk?: Maybe<StopsDatabaseGroupOfTariffZones>;
  /** delete data from the table: "group_of_tariff_zones_key_values" */
  readonly stops_database_delete_group_of_tariff_zones_key_values?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesMutationResponse>;
  /** delete single row from the table: "group_of_tariff_zones_key_values" */
  readonly stops_database_delete_group_of_tariff_zones_key_values_by_pk?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValues>;
  /** delete data from the table: "group_of_tariff_zones_members" */
  readonly stops_database_delete_group_of_tariff_zones_members?: Maybe<StopsDatabaseGroupOfTariffZonesMembersMutationResponse>;
  /** delete single row from the table: "group_of_tariff_zones_members" */
  readonly stops_database_delete_group_of_tariff_zones_members_by_pk?: Maybe<StopsDatabaseGroupOfTariffZonesMembers>;
  /** delete data from the table: "hsl_accessibility_properties" */
  readonly stops_database_delete_hsl_accessibility_properties?: Maybe<StopsDatabaseHslAccessibilityPropertiesMutationResponse>;
  /** delete single row from the table: "hsl_accessibility_properties" */
  readonly stops_database_delete_hsl_accessibility_properties_by_pk?: Maybe<StopsDatabaseHslAccessibilityProperties>;
  /** delete data from the table: "id_generator" */
  readonly stops_database_delete_id_generator?: Maybe<StopsDatabaseIdGeneratorMutationResponse>;
  /** delete data from the table: "info_spot" */
  readonly stops_database_delete_info_spot?: Maybe<StopsDatabaseInfoSpotMutationResponse>;
  /** delete single row from the table: "info_spot" */
  readonly stops_database_delete_info_spot_by_pk?: Maybe<StopsDatabaseInfoSpot>;
  /** delete data from the table: "info_spot_poster" */
  readonly stops_database_delete_info_spot_poster?: Maybe<StopsDatabaseInfoSpotPosterMutationResponse>;
  /** delete single row from the table: "info_spot_poster" */
  readonly stops_database_delete_info_spot_poster_by_pk?: Maybe<StopsDatabaseInfoSpotPoster>;
  /** delete data from the table: "installed_equipment" */
  readonly stops_database_delete_installed_equipment?: Maybe<StopsDatabaseInstalledEquipmentMutationResponse>;
  /** delete data from the table: "installed_equipment_version_structure" */
  readonly stops_database_delete_installed_equipment_version_structure?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureMutationResponse>;
  /** delete single row from the table: "installed_equipment_version_structure" */
  readonly stops_database_delete_installed_equipment_version_structure_by_pk?: Maybe<StopsDatabaseInstalledEquipmentVersionStructure>;
  /** delete data from the table: "installed_equipment_version_structure_installed_equipment" */
  readonly stops_database_delete_installed_equipment_version_structure_installed_equipment?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMutationResponse>;
  /** delete data from the table: "level" */
  readonly stops_database_delete_level?: Maybe<StopsDatabaseLevelMutationResponse>;
  /** delete single row from the table: "level" */
  readonly stops_database_delete_level_by_pk?: Maybe<StopsDatabaseLevel>;
  /** delete data from the table: "level_key_values" */
  readonly stops_database_delete_level_key_values?: Maybe<StopsDatabaseLevelKeyValuesMutationResponse>;
  /** delete single row from the table: "level_key_values" */
  readonly stops_database_delete_level_key_values_by_pk?: Maybe<StopsDatabaseLevelKeyValues>;
  /** delete data from the table: "multilingual_string_entity" */
  readonly stops_database_delete_multilingual_string_entity?: Maybe<StopsDatabaseMultilingualStringEntityMutationResponse>;
  /** delete single row from the table: "multilingual_string_entity" */
  readonly stops_database_delete_multilingual_string_entity_by_pk?: Maybe<StopsDatabaseMultilingualStringEntity>;
  /** delete data from the table: "navigation_path" */
  readonly stops_database_delete_navigation_path?: Maybe<StopsDatabaseNavigationPathMutationResponse>;
  /** delete data from the table: "organisation" */
  readonly stops_database_delete_organisation?: Maybe<StopsDatabaseOrganisationMutationResponse>;
  /** delete single row from the table: "organisation" */
  readonly stops_database_delete_organisation_by_pk?: Maybe<StopsDatabaseOrganisation>;
  /** delete data from the table: "organisation_key_values" */
  readonly stops_database_delete_organisation_key_values?: Maybe<StopsDatabaseOrganisationKeyValuesMutationResponse>;
  /** delete single row from the table: "organisation_key_values" */
  readonly stops_database_delete_organisation_key_values_by_pk?: Maybe<StopsDatabaseOrganisationKeyValues>;
  /** delete data from the table: "parking" */
  readonly stops_database_delete_parking?: Maybe<StopsDatabaseParkingMutationResponse>;
  /** delete data from the table: "parking_adjacent_sites" */
  readonly stops_database_delete_parking_adjacent_sites?: Maybe<StopsDatabaseParkingAdjacentSitesMutationResponse>;
  /** delete data from the table: "parking_alternative_names" */
  readonly stops_database_delete_parking_alternative_names?: Maybe<StopsDatabaseParkingAlternativeNamesMutationResponse>;
  /** delete data from the table: "parking_area" */
  readonly stops_database_delete_parking_area?: Maybe<StopsDatabaseParkingAreaMutationResponse>;
  /** delete data from the table: "parking_area_alternative_names" */
  readonly stops_database_delete_parking_area_alternative_names?: Maybe<StopsDatabaseParkingAreaAlternativeNamesMutationResponse>;
  /** delete single row from the table: "parking_area" */
  readonly stops_database_delete_parking_area_by_pk?: Maybe<StopsDatabaseParkingArea>;
  /** delete data from the table: "parking_area_check_constraints" */
  readonly stops_database_delete_parking_area_check_constraints?: Maybe<StopsDatabaseParkingAreaCheckConstraintsMutationResponse>;
  /** delete data from the table: "parking_area_equipment_places" */
  readonly stops_database_delete_parking_area_equipment_places?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesMutationResponse>;
  /** delete data from the table: "parking_area_key_values" */
  readonly stops_database_delete_parking_area_key_values?: Maybe<StopsDatabaseParkingAreaKeyValuesMutationResponse>;
  /** delete single row from the table: "parking_area_key_values" */
  readonly stops_database_delete_parking_area_key_values_by_pk?: Maybe<StopsDatabaseParkingAreaKeyValues>;
  /** delete single row from the table: "parking" */
  readonly stops_database_delete_parking_by_pk?: Maybe<StopsDatabaseParking>;
  /** delete data from the table: "parking_capacity" */
  readonly stops_database_delete_parking_capacity?: Maybe<StopsDatabaseParkingCapacityMutationResponse>;
  /** delete single row from the table: "parking_capacity" */
  readonly stops_database_delete_parking_capacity_by_pk?: Maybe<StopsDatabaseParkingCapacity>;
  /** delete data from the table: "parking_equipment_places" */
  readonly stops_database_delete_parking_equipment_places?: Maybe<StopsDatabaseParkingEquipmentPlacesMutationResponse>;
  /** delete data from the table: "parking_key_values" */
  readonly stops_database_delete_parking_key_values?: Maybe<StopsDatabaseParkingKeyValuesMutationResponse>;
  /** delete single row from the table: "parking_key_values" */
  readonly stops_database_delete_parking_key_values_by_pk?: Maybe<StopsDatabaseParkingKeyValues>;
  /** delete data from the table: "parking_parking_areas" */
  readonly stops_database_delete_parking_parking_areas?: Maybe<StopsDatabaseParkingParkingAreasMutationResponse>;
  /** delete data from the table: "parking_parking_payment_process" */
  readonly stops_database_delete_parking_parking_payment_process?: Maybe<StopsDatabaseParkingParkingPaymentProcessMutationResponse>;
  /** delete data from the table: "parking_parking_properties" */
  readonly stops_database_delete_parking_parking_properties?: Maybe<StopsDatabaseParkingParkingPropertiesMutationResponse>;
  /** delete data from the table: "parking_parking_vehicle_types" */
  readonly stops_database_delete_parking_parking_vehicle_types?: Maybe<StopsDatabaseParkingParkingVehicleTypesMutationResponse>;
  /** delete data from the table: "parking_properties" */
  readonly stops_database_delete_parking_properties?: Maybe<StopsDatabaseParkingPropertiesMutationResponse>;
  /** delete single row from the table: "parking_properties" */
  readonly stops_database_delete_parking_properties_by_pk?: Maybe<StopsDatabaseParkingProperties>;
  /** delete data from the table: "parking_properties_parking_user_types" */
  readonly stops_database_delete_parking_properties_parking_user_types?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesMutationResponse>;
  /** delete data from the table: "parking_properties_spaces" */
  readonly stops_database_delete_parking_properties_spaces?: Maybe<StopsDatabaseParkingPropertiesSpacesMutationResponse>;
  /** delete data from the table: "path_junction" */
  readonly stops_database_delete_path_junction?: Maybe<StopsDatabasePathJunctionMutationResponse>;
  /** delete single row from the table: "path_junction" */
  readonly stops_database_delete_path_junction_by_pk?: Maybe<StopsDatabasePathJunction>;
  /** delete data from the table: "path_junction_key_values" */
  readonly stops_database_delete_path_junction_key_values?: Maybe<StopsDatabasePathJunctionKeyValuesMutationResponse>;
  /** delete single row from the table: "path_junction_key_values" */
  readonly stops_database_delete_path_junction_key_values_by_pk?: Maybe<StopsDatabasePathJunctionKeyValues>;
  /** delete data from the table: "path_link" */
  readonly stops_database_delete_path_link?: Maybe<StopsDatabasePathLinkMutationResponse>;
  /** delete single row from the table: "path_link" */
  readonly stops_database_delete_path_link_by_pk?: Maybe<StopsDatabasePathLink>;
  /** delete data from the table: "path_link_end" */
  readonly stops_database_delete_path_link_end?: Maybe<StopsDatabasePathLinkEndMutationResponse>;
  /** delete single row from the table: "path_link_end" */
  readonly stops_database_delete_path_link_end_by_pk?: Maybe<StopsDatabasePathLinkEnd>;
  /** delete data from the table: "path_link_key_values" */
  readonly stops_database_delete_path_link_key_values?: Maybe<StopsDatabasePathLinkKeyValuesMutationResponse>;
  /** delete single row from the table: "path_link_key_values" */
  readonly stops_database_delete_path_link_key_values_by_pk?: Maybe<StopsDatabasePathLinkKeyValues>;
  /** delete data from the table: "persistable_polygon" */
  readonly stops_database_delete_persistable_polygon?: Maybe<StopsDatabasePersistablePolygonMutationResponse>;
  /** delete single row from the table: "persistable_polygon" */
  readonly stops_database_delete_persistable_polygon_by_pk?: Maybe<StopsDatabasePersistablePolygon>;
  /** delete data from the table: "purpose_of_grouping" */
  readonly stops_database_delete_purpose_of_grouping?: Maybe<StopsDatabasePurposeOfGroupingMutationResponse>;
  /** delete single row from the table: "purpose_of_grouping" */
  readonly stops_database_delete_purpose_of_grouping_by_pk?: Maybe<StopsDatabasePurposeOfGrouping>;
  /** delete data from the table: "purpose_of_grouping_key_values" */
  readonly stops_database_delete_purpose_of_grouping_key_values?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesMutationResponse>;
  /** delete single row from the table: "purpose_of_grouping_key_values" */
  readonly stops_database_delete_purpose_of_grouping_key_values_by_pk?: Maybe<StopsDatabasePurposeOfGroupingKeyValues>;
  /** delete data from the table: "quay" */
  readonly stops_database_delete_quay?: Maybe<StopsDatabaseQuayMutationResponse>;
  /** delete data from the table: "quay_alternative_names" */
  readonly stops_database_delete_quay_alternative_names?: Maybe<StopsDatabaseQuayAlternativeNamesMutationResponse>;
  /** delete data from the table: "quay_boarding_positions" */
  readonly stops_database_delete_quay_boarding_positions?: Maybe<StopsDatabaseQuayBoardingPositionsMutationResponse>;
  /** delete single row from the table: "quay" */
  readonly stops_database_delete_quay_by_pk?: Maybe<StopsDatabaseQuay>;
  /** delete data from the table: "quay_check_constraints" */
  readonly stops_database_delete_quay_check_constraints?: Maybe<StopsDatabaseQuayCheckConstraintsMutationResponse>;
  /** delete data from the table: "quay_equipment_places" */
  readonly stops_database_delete_quay_equipment_places?: Maybe<StopsDatabaseQuayEquipmentPlacesMutationResponse>;
  /** delete data from the table: "quay_key_values" */
  readonly stops_database_delete_quay_key_values?: Maybe<StopsDatabaseQuayKeyValuesMutationResponse>;
  /** delete single row from the table: "quay_key_values" */
  readonly stops_database_delete_quay_key_values_by_pk?: Maybe<StopsDatabaseQuayKeyValues>;
  /** delete data from the table: "schema_version" */
  readonly stops_database_delete_schema_version?: Maybe<StopsDatabaseSchemaVersionMutationResponse>;
  /** delete single row from the table: "schema_version" */
  readonly stops_database_delete_schema_version_by_pk?: Maybe<StopsDatabaseSchemaVersion>;
  /** delete data from the table: "spatial_ref_sys" */
  readonly stops_database_delete_spatial_ref_sys?: Maybe<StopsDatabaseSpatialRefSysMutationResponse>;
  /** delete single row from the table: "spatial_ref_sys" */
  readonly stops_database_delete_spatial_ref_sys_by_pk?: Maybe<StopsDatabaseSpatialRefSys>;
  /** delete data from the table: "stop_place" */
  readonly stops_database_delete_stop_place?: Maybe<StopsDatabaseStopPlaceMutationResponse>;
  /** delete data from the table: "stop_place_access_spaces" */
  readonly stops_database_delete_stop_place_access_spaces?: Maybe<StopsDatabaseStopPlaceAccessSpacesMutationResponse>;
  /** delete data from the table: "stop_place_adjacent_sites" */
  readonly stops_database_delete_stop_place_adjacent_sites?: Maybe<StopsDatabaseStopPlaceAdjacentSitesMutationResponse>;
  /** delete data from the table: "stop_place_alternative_names" */
  readonly stops_database_delete_stop_place_alternative_names?: Maybe<StopsDatabaseStopPlaceAlternativeNamesMutationResponse>;
  /** delete single row from the table: "stop_place" */
  readonly stops_database_delete_stop_place_by_pk?: Maybe<StopsDatabaseStopPlace>;
  /** delete data from the table: "stop_place_children" */
  readonly stops_database_delete_stop_place_children?: Maybe<StopsDatabaseStopPlaceChildrenMutationResponse>;
  /** delete single row from the table: "stop_place_children" */
  readonly stops_database_delete_stop_place_children_by_pk?: Maybe<StopsDatabaseStopPlaceChildren>;
  /** delete data from the table: "stop_place_equipment_places" */
  readonly stops_database_delete_stop_place_equipment_places?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesMutationResponse>;
  /** delete data from the table: "stop_place_key_values" */
  readonly stops_database_delete_stop_place_key_values?: Maybe<StopsDatabaseStopPlaceKeyValuesMutationResponse>;
  /** delete single row from the table: "stop_place_key_values" */
  readonly stops_database_delete_stop_place_key_values_by_pk?: Maybe<StopsDatabaseStopPlaceKeyValues>;
  /** delete data from the table: "stop_place_organisations" */
  readonly stops_database_delete_stop_place_organisations?: Maybe<StopsDatabaseStopPlaceOrganisationsMutationResponse>;
  /** delete single row from the table: "stop_place_organisations" */
  readonly stops_database_delete_stop_place_organisations_by_pk?: Maybe<StopsDatabaseStopPlaceOrganisations>;
  /** delete data from the table: "stop_place_quays" */
  readonly stops_database_delete_stop_place_quays?: Maybe<StopsDatabaseStopPlaceQuaysMutationResponse>;
  /** delete single row from the table: "stop_place_quays" */
  readonly stops_database_delete_stop_place_quays_by_pk?: Maybe<StopsDatabaseStopPlaceQuays>;
  /** delete data from the table: "stop_place_tariff_zones" */
  readonly stops_database_delete_stop_place_tariff_zones?: Maybe<StopsDatabaseStopPlaceTariffZonesMutationResponse>;
  /** delete data from the table: "tag" */
  readonly stops_database_delete_tag?: Maybe<StopsDatabaseTagMutationResponse>;
  /** delete single row from the table: "tag" */
  readonly stops_database_delete_tag_by_pk?: Maybe<StopsDatabaseTag>;
  /** delete data from the table: "tariff_zone" */
  readonly stops_database_delete_tariff_zone?: Maybe<StopsDatabaseTariffZoneMutationResponse>;
  /** delete single row from the table: "tariff_zone" */
  readonly stops_database_delete_tariff_zone_by_pk?: Maybe<StopsDatabaseTariffZone>;
  /** delete data from the table: "tariff_zone_key_values" */
  readonly stops_database_delete_tariff_zone_key_values?: Maybe<StopsDatabaseTariffZoneKeyValuesMutationResponse>;
  /** delete single row from the table: "tariff_zone_key_values" */
  readonly stops_database_delete_tariff_zone_key_values_by_pk?: Maybe<StopsDatabaseTariffZoneKeyValues>;
  /** delete data from the table: "topographic_place" */
  readonly stops_database_delete_topographic_place?: Maybe<StopsDatabaseTopographicPlaceMutationResponse>;
  /** delete single row from the table: "topographic_place" */
  readonly stops_database_delete_topographic_place_by_pk?: Maybe<StopsDatabaseTopographicPlace>;
  /** delete data from the table: "topographic_place_key_values" */
  readonly stops_database_delete_topographic_place_key_values?: Maybe<StopsDatabaseTopographicPlaceKeyValuesMutationResponse>;
  /** delete single row from the table: "topographic_place_key_values" */
  readonly stops_database_delete_topographic_place_key_values_by_pk?: Maybe<StopsDatabaseTopographicPlaceKeyValues>;
  /** delete data from the table: "value" */
  readonly stops_database_delete_value?: Maybe<StopsDatabaseValueMutationResponse>;
  /** delete single row from the table: "value" */
  readonly stops_database_delete_value_by_pk?: Maybe<StopsDatabaseValue>;
  /** delete data from the table: "value_items" */
  readonly stops_database_delete_value_items?: Maybe<StopsDatabaseValueItemsMutationResponse>;
  /** insert data into the table: "access_space" */
  readonly stops_database_insert_access_space?: Maybe<StopsDatabaseAccessSpaceMutationResponse>;
  /** insert data into the table: "access_space_alternative_names" */
  readonly stops_database_insert_access_space_alternative_names?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesMutationResponse>;
  /** insert a single row into the table: "access_space_alternative_names" */
  readonly stops_database_insert_access_space_alternative_names_one?: Maybe<StopsDatabaseAccessSpaceAlternativeNames>;
  /** insert data into the table: "access_space_check_constraints" */
  readonly stops_database_insert_access_space_check_constraints?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsMutationResponse>;
  /** insert a single row into the table: "access_space_check_constraints" */
  readonly stops_database_insert_access_space_check_constraints_one?: Maybe<StopsDatabaseAccessSpaceCheckConstraints>;
  /** insert data into the table: "access_space_equipment_places" */
  readonly stops_database_insert_access_space_equipment_places?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesMutationResponse>;
  /** insert a single row into the table: "access_space_equipment_places" */
  readonly stops_database_insert_access_space_equipment_places_one?: Maybe<StopsDatabaseAccessSpaceEquipmentPlaces>;
  /** insert data into the table: "access_space_key_values" */
  readonly stops_database_insert_access_space_key_values?: Maybe<StopsDatabaseAccessSpaceKeyValuesMutationResponse>;
  /** insert a single row into the table: "access_space_key_values" */
  readonly stops_database_insert_access_space_key_values_one?: Maybe<StopsDatabaseAccessSpaceKeyValues>;
  /** insert a single row into the table: "access_space" */
  readonly stops_database_insert_access_space_one?: Maybe<StopsDatabaseAccessSpace>;
  /** insert data into the table: "accessibility_assessment" */
  readonly stops_database_insert_accessibility_assessment?: Maybe<StopsDatabaseAccessibilityAssessmentMutationResponse>;
  /** insert data into the table: "accessibility_assessment_limitations" */
  readonly stops_database_insert_accessibility_assessment_limitations?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsMutationResponse>;
  /** insert a single row into the table: "accessibility_assessment_limitations" */
  readonly stops_database_insert_accessibility_assessment_limitations_one?: Maybe<StopsDatabaseAccessibilityAssessmentLimitations>;
  /** insert a single row into the table: "accessibility_assessment" */
  readonly stops_database_insert_accessibility_assessment_one?: Maybe<StopsDatabaseAccessibilityAssessment>;
  /** insert data into the table: "accessibility_limitation" */
  readonly stops_database_insert_accessibility_limitation?: Maybe<StopsDatabaseAccessibilityLimitationMutationResponse>;
  /** insert a single row into the table: "accessibility_limitation" */
  readonly stops_database_insert_accessibility_limitation_one?: Maybe<StopsDatabaseAccessibilityLimitation>;
  /** insert data into the table: "alternative_name" */
  readonly stops_database_insert_alternative_name?: Maybe<StopsDatabaseAlternativeNameMutationResponse>;
  /** insert a single row into the table: "alternative_name" */
  readonly stops_database_insert_alternative_name_one?: Maybe<StopsDatabaseAlternativeName>;
  /** insert data into the table: "boarding_position" */
  readonly stops_database_insert_boarding_position?: Maybe<StopsDatabaseBoardingPositionMutationResponse>;
  /** insert data into the table: "boarding_position_alternative_names" */
  readonly stops_database_insert_boarding_position_alternative_names?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesMutationResponse>;
  /** insert a single row into the table: "boarding_position_alternative_names" */
  readonly stops_database_insert_boarding_position_alternative_names_one?: Maybe<StopsDatabaseBoardingPositionAlternativeNames>;
  /** insert data into the table: "boarding_position_check_constraints" */
  readonly stops_database_insert_boarding_position_check_constraints?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsMutationResponse>;
  /** insert a single row into the table: "boarding_position_check_constraints" */
  readonly stops_database_insert_boarding_position_check_constraints_one?: Maybe<StopsDatabaseBoardingPositionCheckConstraints>;
  /** insert data into the table: "boarding_position_equipment_places" */
  readonly stops_database_insert_boarding_position_equipment_places?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesMutationResponse>;
  /** insert a single row into the table: "boarding_position_equipment_places" */
  readonly stops_database_insert_boarding_position_equipment_places_one?: Maybe<StopsDatabaseBoardingPositionEquipmentPlaces>;
  /** insert data into the table: "boarding_position_key_values" */
  readonly stops_database_insert_boarding_position_key_values?: Maybe<StopsDatabaseBoardingPositionKeyValuesMutationResponse>;
  /** insert a single row into the table: "boarding_position_key_values" */
  readonly stops_database_insert_boarding_position_key_values_one?: Maybe<StopsDatabaseBoardingPositionKeyValues>;
  /** insert a single row into the table: "boarding_position" */
  readonly stops_database_insert_boarding_position_one?: Maybe<StopsDatabaseBoardingPosition>;
  /** insert data into the table: "check_constraint" */
  readonly stops_database_insert_check_constraint?: Maybe<StopsDatabaseCheckConstraintMutationResponse>;
  /** insert data into the table: "check_constraint_key_values" */
  readonly stops_database_insert_check_constraint_key_values?: Maybe<StopsDatabaseCheckConstraintKeyValuesMutationResponse>;
  /** insert a single row into the table: "check_constraint_key_values" */
  readonly stops_database_insert_check_constraint_key_values_one?: Maybe<StopsDatabaseCheckConstraintKeyValues>;
  /** insert a single row into the table: "check_constraint" */
  readonly stops_database_insert_check_constraint_one?: Maybe<StopsDatabaseCheckConstraint>;
  /** insert data into the table: "contact" */
  readonly stops_database_insert_contact?: Maybe<StopsDatabaseContactMutationResponse>;
  /** insert a single row into the table: "contact" */
  readonly stops_database_insert_contact_one?: Maybe<StopsDatabaseContact>;
  /** insert data into the table: "destination_display_view" */
  readonly stops_database_insert_destination_display_view?: Maybe<StopsDatabaseDestinationDisplayViewMutationResponse>;
  /** insert a single row into the table: "destination_display_view" */
  readonly stops_database_insert_destination_display_view_one?: Maybe<StopsDatabaseDestinationDisplayView>;
  /** insert data into the table: "equipment_place" */
  readonly stops_database_insert_equipment_place?: Maybe<StopsDatabaseEquipmentPlaceMutationResponse>;
  /** insert data into the table: "equipment_place_equipment_positions" */
  readonly stops_database_insert_equipment_place_equipment_positions?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsMutationResponse>;
  /** insert a single row into the table: "equipment_place_equipment_positions" */
  readonly stops_database_insert_equipment_place_equipment_positions_one?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositions>;
  /** insert data into the table: "equipment_place_key_values" */
  readonly stops_database_insert_equipment_place_key_values?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesMutationResponse>;
  /** insert a single row into the table: "equipment_place_key_values" */
  readonly stops_database_insert_equipment_place_key_values_one?: Maybe<StopsDatabaseEquipmentPlaceKeyValues>;
  /** insert a single row into the table: "equipment_place" */
  readonly stops_database_insert_equipment_place_one?: Maybe<StopsDatabaseEquipmentPlace>;
  /** insert data into the table: "equipment_position" */
  readonly stops_database_insert_equipment_position?: Maybe<StopsDatabaseEquipmentPositionMutationResponse>;
  /** insert data into the table: "equipment_position_key_values" */
  readonly stops_database_insert_equipment_position_key_values?: Maybe<StopsDatabaseEquipmentPositionKeyValuesMutationResponse>;
  /** insert a single row into the table: "equipment_position_key_values" */
  readonly stops_database_insert_equipment_position_key_values_one?: Maybe<StopsDatabaseEquipmentPositionKeyValues>;
  /** insert a single row into the table: "equipment_position" */
  readonly stops_database_insert_equipment_position_one?: Maybe<StopsDatabaseEquipmentPosition>;
  /** insert data into the table: "export_job" */
  readonly stops_database_insert_export_job?: Maybe<StopsDatabaseExportJobMutationResponse>;
  /** insert a single row into the table: "export_job" */
  readonly stops_database_insert_export_job_one?: Maybe<StopsDatabaseExportJob>;
  /** insert data into the table: "fare_zone" */
  readonly stops_database_insert_fare_zone?: Maybe<StopsDatabaseFareZoneMutationResponse>;
  /** insert data into the table: "fare_zone_key_values" */
  readonly stops_database_insert_fare_zone_key_values?: Maybe<StopsDatabaseFareZoneKeyValuesMutationResponse>;
  /** insert a single row into the table: "fare_zone_key_values" */
  readonly stops_database_insert_fare_zone_key_values_one?: Maybe<StopsDatabaseFareZoneKeyValues>;
  /** insert data into the table: "fare_zone_members" */
  readonly stops_database_insert_fare_zone_members?: Maybe<StopsDatabaseFareZoneMembersMutationResponse>;
  /** insert a single row into the table: "fare_zone_members" */
  readonly stops_database_insert_fare_zone_members_one?: Maybe<StopsDatabaseFareZoneMembers>;
  /** insert data into the table: "fare_zone_neighbours" */
  readonly stops_database_insert_fare_zone_neighbours?: Maybe<StopsDatabaseFareZoneNeighboursMutationResponse>;
  /** insert a single row into the table: "fare_zone_neighbours" */
  readonly stops_database_insert_fare_zone_neighbours_one?: Maybe<StopsDatabaseFareZoneNeighbours>;
  /** insert a single row into the table: "fare_zone" */
  readonly stops_database_insert_fare_zone_one?: Maybe<StopsDatabaseFareZone>;
  /** insert data into the table: "geometry_columns" */
  readonly stops_database_insert_geometry_columns?: Maybe<StopsDatabaseGeometryColumnsMutationResponse>;
  /** insert a single row into the table: "geometry_columns" */
  readonly stops_database_insert_geometry_columns_one?: Maybe<StopsDatabaseGeometryColumns>;
  /** insert data into the table: "group_of_stop_places" */
  readonly stops_database_insert_group_of_stop_places?: Maybe<StopsDatabaseGroupOfStopPlacesMutationResponse>;
  /** insert data into the table: "group_of_stop_places_alternative_names" */
  readonly stops_database_insert_group_of_stop_places_alternative_names?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesMutationResponse>;
  /** insert a single row into the table: "group_of_stop_places_alternative_names" */
  readonly stops_database_insert_group_of_stop_places_alternative_names_one?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNames>;
  /** insert data into the table: "group_of_stop_places_key_values" */
  readonly stops_database_insert_group_of_stop_places_key_values?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesMutationResponse>;
  /** insert a single row into the table: "group_of_stop_places_key_values" */
  readonly stops_database_insert_group_of_stop_places_key_values_one?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValues>;
  /** insert data into the table: "group_of_stop_places_members" */
  readonly stops_database_insert_group_of_stop_places_members?: Maybe<StopsDatabaseGroupOfStopPlacesMembersMutationResponse>;
  /** insert a single row into the table: "group_of_stop_places_members" */
  readonly stops_database_insert_group_of_stop_places_members_one?: Maybe<StopsDatabaseGroupOfStopPlacesMembers>;
  /** insert a single row into the table: "group_of_stop_places" */
  readonly stops_database_insert_group_of_stop_places_one?: Maybe<StopsDatabaseGroupOfStopPlaces>;
  /** insert data into the table: "group_of_tariff_zones" */
  readonly stops_database_insert_group_of_tariff_zones?: Maybe<StopsDatabaseGroupOfTariffZonesMutationResponse>;
  /** insert data into the table: "group_of_tariff_zones_key_values" */
  readonly stops_database_insert_group_of_tariff_zones_key_values?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesMutationResponse>;
  /** insert a single row into the table: "group_of_tariff_zones_key_values" */
  readonly stops_database_insert_group_of_tariff_zones_key_values_one?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValues>;
  /** insert data into the table: "group_of_tariff_zones_members" */
  readonly stops_database_insert_group_of_tariff_zones_members?: Maybe<StopsDatabaseGroupOfTariffZonesMembersMutationResponse>;
  /** insert a single row into the table: "group_of_tariff_zones_members" */
  readonly stops_database_insert_group_of_tariff_zones_members_one?: Maybe<StopsDatabaseGroupOfTariffZonesMembers>;
  /** insert a single row into the table: "group_of_tariff_zones" */
  readonly stops_database_insert_group_of_tariff_zones_one?: Maybe<StopsDatabaseGroupOfTariffZones>;
  /** insert data into the table: "hsl_accessibility_properties" */
  readonly stops_database_insert_hsl_accessibility_properties?: Maybe<StopsDatabaseHslAccessibilityPropertiesMutationResponse>;
  /** insert a single row into the table: "hsl_accessibility_properties" */
  readonly stops_database_insert_hsl_accessibility_properties_one?: Maybe<StopsDatabaseHslAccessibilityProperties>;
  /** insert data into the table: "id_generator" */
  readonly stops_database_insert_id_generator?: Maybe<StopsDatabaseIdGeneratorMutationResponse>;
  /** insert a single row into the table: "id_generator" */
  readonly stops_database_insert_id_generator_one?: Maybe<StopsDatabaseIdGenerator>;
  /** insert data into the table: "info_spot" */
  readonly stops_database_insert_info_spot?: Maybe<StopsDatabaseInfoSpotMutationResponse>;
  /** insert a single row into the table: "info_spot" */
  readonly stops_database_insert_info_spot_one?: Maybe<StopsDatabaseInfoSpot>;
  /** insert data into the table: "info_spot_poster" */
  readonly stops_database_insert_info_spot_poster?: Maybe<StopsDatabaseInfoSpotPosterMutationResponse>;
  /** insert a single row into the table: "info_spot_poster" */
  readonly stops_database_insert_info_spot_poster_one?: Maybe<StopsDatabaseInfoSpotPoster>;
  /** insert data into the table: "installed_equipment" */
  readonly stops_database_insert_installed_equipment?: Maybe<StopsDatabaseInstalledEquipmentMutationResponse>;
  /** insert a single row into the table: "installed_equipment" */
  readonly stops_database_insert_installed_equipment_one?: Maybe<StopsDatabaseInstalledEquipment>;
  /** insert data into the table: "installed_equipment_version_structure" */
  readonly stops_database_insert_installed_equipment_version_structure?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureMutationResponse>;
  /** insert data into the table: "installed_equipment_version_structure_installed_equipment" */
  readonly stops_database_insert_installed_equipment_version_structure_installed_equipment?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMutationResponse>;
  /** insert a single row into the table: "installed_equipment_version_structure_installed_equipment" */
  readonly stops_database_insert_installed_equipment_version_structure_installed_equipment_one?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipment>;
  /** insert a single row into the table: "installed_equipment_version_structure" */
  readonly stops_database_insert_installed_equipment_version_structure_one?: Maybe<StopsDatabaseInstalledEquipmentVersionStructure>;
  /** insert data into the table: "level" */
  readonly stops_database_insert_level?: Maybe<StopsDatabaseLevelMutationResponse>;
  /** insert data into the table: "level_key_values" */
  readonly stops_database_insert_level_key_values?: Maybe<StopsDatabaseLevelKeyValuesMutationResponse>;
  /** insert a single row into the table: "level_key_values" */
  readonly stops_database_insert_level_key_values_one?: Maybe<StopsDatabaseLevelKeyValues>;
  /** insert a single row into the table: "level" */
  readonly stops_database_insert_level_one?: Maybe<StopsDatabaseLevel>;
  /** insert data into the table: "multilingual_string_entity" */
  readonly stops_database_insert_multilingual_string_entity?: Maybe<StopsDatabaseMultilingualStringEntityMutationResponse>;
  /** insert a single row into the table: "multilingual_string_entity" */
  readonly stops_database_insert_multilingual_string_entity_one?: Maybe<StopsDatabaseMultilingualStringEntity>;
  /** insert data into the table: "navigation_path" */
  readonly stops_database_insert_navigation_path?: Maybe<StopsDatabaseNavigationPathMutationResponse>;
  /** insert a single row into the table: "navigation_path" */
  readonly stops_database_insert_navigation_path_one?: Maybe<StopsDatabaseNavigationPath>;
  /** insert data into the table: "organisation" */
  readonly stops_database_insert_organisation?: Maybe<StopsDatabaseOrganisationMutationResponse>;
  /** insert data into the table: "organisation_key_values" */
  readonly stops_database_insert_organisation_key_values?: Maybe<StopsDatabaseOrganisationKeyValuesMutationResponse>;
  /** insert a single row into the table: "organisation_key_values" */
  readonly stops_database_insert_organisation_key_values_one?: Maybe<StopsDatabaseOrganisationKeyValues>;
  /** insert a single row into the table: "organisation" */
  readonly stops_database_insert_organisation_one?: Maybe<StopsDatabaseOrganisation>;
  /** insert data into the table: "parking" */
  readonly stops_database_insert_parking?: Maybe<StopsDatabaseParkingMutationResponse>;
  /** insert data into the table: "parking_adjacent_sites" */
  readonly stops_database_insert_parking_adjacent_sites?: Maybe<StopsDatabaseParkingAdjacentSitesMutationResponse>;
  /** insert a single row into the table: "parking_adjacent_sites" */
  readonly stops_database_insert_parking_adjacent_sites_one?: Maybe<StopsDatabaseParkingAdjacentSites>;
  /** insert data into the table: "parking_alternative_names" */
  readonly stops_database_insert_parking_alternative_names?: Maybe<StopsDatabaseParkingAlternativeNamesMutationResponse>;
  /** insert a single row into the table: "parking_alternative_names" */
  readonly stops_database_insert_parking_alternative_names_one?: Maybe<StopsDatabaseParkingAlternativeNames>;
  /** insert data into the table: "parking_area" */
  readonly stops_database_insert_parking_area?: Maybe<StopsDatabaseParkingAreaMutationResponse>;
  /** insert data into the table: "parking_area_alternative_names" */
  readonly stops_database_insert_parking_area_alternative_names?: Maybe<StopsDatabaseParkingAreaAlternativeNamesMutationResponse>;
  /** insert a single row into the table: "parking_area_alternative_names" */
  readonly stops_database_insert_parking_area_alternative_names_one?: Maybe<StopsDatabaseParkingAreaAlternativeNames>;
  /** insert data into the table: "parking_area_check_constraints" */
  readonly stops_database_insert_parking_area_check_constraints?: Maybe<StopsDatabaseParkingAreaCheckConstraintsMutationResponse>;
  /** insert a single row into the table: "parking_area_check_constraints" */
  readonly stops_database_insert_parking_area_check_constraints_one?: Maybe<StopsDatabaseParkingAreaCheckConstraints>;
  /** insert data into the table: "parking_area_equipment_places" */
  readonly stops_database_insert_parking_area_equipment_places?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesMutationResponse>;
  /** insert a single row into the table: "parking_area_equipment_places" */
  readonly stops_database_insert_parking_area_equipment_places_one?: Maybe<StopsDatabaseParkingAreaEquipmentPlaces>;
  /** insert data into the table: "parking_area_key_values" */
  readonly stops_database_insert_parking_area_key_values?: Maybe<StopsDatabaseParkingAreaKeyValuesMutationResponse>;
  /** insert a single row into the table: "parking_area_key_values" */
  readonly stops_database_insert_parking_area_key_values_one?: Maybe<StopsDatabaseParkingAreaKeyValues>;
  /** insert a single row into the table: "parking_area" */
  readonly stops_database_insert_parking_area_one?: Maybe<StopsDatabaseParkingArea>;
  /** insert data into the table: "parking_capacity" */
  readonly stops_database_insert_parking_capacity?: Maybe<StopsDatabaseParkingCapacityMutationResponse>;
  /** insert a single row into the table: "parking_capacity" */
  readonly stops_database_insert_parking_capacity_one?: Maybe<StopsDatabaseParkingCapacity>;
  /** insert data into the table: "parking_equipment_places" */
  readonly stops_database_insert_parking_equipment_places?: Maybe<StopsDatabaseParkingEquipmentPlacesMutationResponse>;
  /** insert a single row into the table: "parking_equipment_places" */
  readonly stops_database_insert_parking_equipment_places_one?: Maybe<StopsDatabaseParkingEquipmentPlaces>;
  /** insert data into the table: "parking_key_values" */
  readonly stops_database_insert_parking_key_values?: Maybe<StopsDatabaseParkingKeyValuesMutationResponse>;
  /** insert a single row into the table: "parking_key_values" */
  readonly stops_database_insert_parking_key_values_one?: Maybe<StopsDatabaseParkingKeyValues>;
  /** insert a single row into the table: "parking" */
  readonly stops_database_insert_parking_one?: Maybe<StopsDatabaseParking>;
  /** insert data into the table: "parking_parking_areas" */
  readonly stops_database_insert_parking_parking_areas?: Maybe<StopsDatabaseParkingParkingAreasMutationResponse>;
  /** insert a single row into the table: "parking_parking_areas" */
  readonly stops_database_insert_parking_parking_areas_one?: Maybe<StopsDatabaseParkingParkingAreas>;
  /** insert data into the table: "parking_parking_payment_process" */
  readonly stops_database_insert_parking_parking_payment_process?: Maybe<StopsDatabaseParkingParkingPaymentProcessMutationResponse>;
  /** insert a single row into the table: "parking_parking_payment_process" */
  readonly stops_database_insert_parking_parking_payment_process_one?: Maybe<StopsDatabaseParkingParkingPaymentProcess>;
  /** insert data into the table: "parking_parking_properties" */
  readonly stops_database_insert_parking_parking_properties?: Maybe<StopsDatabaseParkingParkingPropertiesMutationResponse>;
  /** insert a single row into the table: "parking_parking_properties" */
  readonly stops_database_insert_parking_parking_properties_one?: Maybe<StopsDatabaseParkingParkingProperties>;
  /** insert data into the table: "parking_parking_vehicle_types" */
  readonly stops_database_insert_parking_parking_vehicle_types?: Maybe<StopsDatabaseParkingParkingVehicleTypesMutationResponse>;
  /** insert a single row into the table: "parking_parking_vehicle_types" */
  readonly stops_database_insert_parking_parking_vehicle_types_one?: Maybe<StopsDatabaseParkingParkingVehicleTypes>;
  /** insert data into the table: "parking_properties" */
  readonly stops_database_insert_parking_properties?: Maybe<StopsDatabaseParkingPropertiesMutationResponse>;
  /** insert a single row into the table: "parking_properties" */
  readonly stops_database_insert_parking_properties_one?: Maybe<StopsDatabaseParkingProperties>;
  /** insert data into the table: "parking_properties_parking_user_types" */
  readonly stops_database_insert_parking_properties_parking_user_types?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesMutationResponse>;
  /** insert a single row into the table: "parking_properties_parking_user_types" */
  readonly stops_database_insert_parking_properties_parking_user_types_one?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypes>;
  /** insert data into the table: "parking_properties_spaces" */
  readonly stops_database_insert_parking_properties_spaces?: Maybe<StopsDatabaseParkingPropertiesSpacesMutationResponse>;
  /** insert a single row into the table: "parking_properties_spaces" */
  readonly stops_database_insert_parking_properties_spaces_one?: Maybe<StopsDatabaseParkingPropertiesSpaces>;
  /** insert data into the table: "path_junction" */
  readonly stops_database_insert_path_junction?: Maybe<StopsDatabasePathJunctionMutationResponse>;
  /** insert data into the table: "path_junction_key_values" */
  readonly stops_database_insert_path_junction_key_values?: Maybe<StopsDatabasePathJunctionKeyValuesMutationResponse>;
  /** insert a single row into the table: "path_junction_key_values" */
  readonly stops_database_insert_path_junction_key_values_one?: Maybe<StopsDatabasePathJunctionKeyValues>;
  /** insert a single row into the table: "path_junction" */
  readonly stops_database_insert_path_junction_one?: Maybe<StopsDatabasePathJunction>;
  /** insert data into the table: "path_link" */
  readonly stops_database_insert_path_link?: Maybe<StopsDatabasePathLinkMutationResponse>;
  /** insert data into the table: "path_link_end" */
  readonly stops_database_insert_path_link_end?: Maybe<StopsDatabasePathLinkEndMutationResponse>;
  /** insert a single row into the table: "path_link_end" */
  readonly stops_database_insert_path_link_end_one?: Maybe<StopsDatabasePathLinkEnd>;
  /** insert data into the table: "path_link_key_values" */
  readonly stops_database_insert_path_link_key_values?: Maybe<StopsDatabasePathLinkKeyValuesMutationResponse>;
  /** insert a single row into the table: "path_link_key_values" */
  readonly stops_database_insert_path_link_key_values_one?: Maybe<StopsDatabasePathLinkKeyValues>;
  /** insert a single row into the table: "path_link" */
  readonly stops_database_insert_path_link_one?: Maybe<StopsDatabasePathLink>;
  /** insert data into the table: "persistable_polygon" */
  readonly stops_database_insert_persistable_polygon?: Maybe<StopsDatabasePersistablePolygonMutationResponse>;
  /** insert a single row into the table: "persistable_polygon" */
  readonly stops_database_insert_persistable_polygon_one?: Maybe<StopsDatabasePersistablePolygon>;
  /** insert data into the table: "purpose_of_grouping" */
  readonly stops_database_insert_purpose_of_grouping?: Maybe<StopsDatabasePurposeOfGroupingMutationResponse>;
  /** insert data into the table: "purpose_of_grouping_key_values" */
  readonly stops_database_insert_purpose_of_grouping_key_values?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesMutationResponse>;
  /** insert a single row into the table: "purpose_of_grouping_key_values" */
  readonly stops_database_insert_purpose_of_grouping_key_values_one?: Maybe<StopsDatabasePurposeOfGroupingKeyValues>;
  /** insert a single row into the table: "purpose_of_grouping" */
  readonly stops_database_insert_purpose_of_grouping_one?: Maybe<StopsDatabasePurposeOfGrouping>;
  /** insert data into the table: "quay" */
  readonly stops_database_insert_quay?: Maybe<StopsDatabaseQuayMutationResponse>;
  /** insert data into the table: "quay_alternative_names" */
  readonly stops_database_insert_quay_alternative_names?: Maybe<StopsDatabaseQuayAlternativeNamesMutationResponse>;
  /** insert a single row into the table: "quay_alternative_names" */
  readonly stops_database_insert_quay_alternative_names_one?: Maybe<StopsDatabaseQuayAlternativeNames>;
  /** insert data into the table: "quay_boarding_positions" */
  readonly stops_database_insert_quay_boarding_positions?: Maybe<StopsDatabaseQuayBoardingPositionsMutationResponse>;
  /** insert a single row into the table: "quay_boarding_positions" */
  readonly stops_database_insert_quay_boarding_positions_one?: Maybe<StopsDatabaseQuayBoardingPositions>;
  /** insert data into the table: "quay_check_constraints" */
  readonly stops_database_insert_quay_check_constraints?: Maybe<StopsDatabaseQuayCheckConstraintsMutationResponse>;
  /** insert a single row into the table: "quay_check_constraints" */
  readonly stops_database_insert_quay_check_constraints_one?: Maybe<StopsDatabaseQuayCheckConstraints>;
  /** insert data into the table: "quay_equipment_places" */
  readonly stops_database_insert_quay_equipment_places?: Maybe<StopsDatabaseQuayEquipmentPlacesMutationResponse>;
  /** insert a single row into the table: "quay_equipment_places" */
  readonly stops_database_insert_quay_equipment_places_one?: Maybe<StopsDatabaseQuayEquipmentPlaces>;
  /** insert data into the table: "quay_key_values" */
  readonly stops_database_insert_quay_key_values?: Maybe<StopsDatabaseQuayKeyValuesMutationResponse>;
  /** insert a single row into the table: "quay_key_values" */
  readonly stops_database_insert_quay_key_values_one?: Maybe<StopsDatabaseQuayKeyValues>;
  /** insert a single row into the table: "quay" */
  readonly stops_database_insert_quay_one?: Maybe<StopsDatabaseQuay>;
  /** insert data into the table: "schema_version" */
  readonly stops_database_insert_schema_version?: Maybe<StopsDatabaseSchemaVersionMutationResponse>;
  /** insert a single row into the table: "schema_version" */
  readonly stops_database_insert_schema_version_one?: Maybe<StopsDatabaseSchemaVersion>;
  /** insert data into the table: "spatial_ref_sys" */
  readonly stops_database_insert_spatial_ref_sys?: Maybe<StopsDatabaseSpatialRefSysMutationResponse>;
  /** insert a single row into the table: "spatial_ref_sys" */
  readonly stops_database_insert_spatial_ref_sys_one?: Maybe<StopsDatabaseSpatialRefSys>;
  /** insert data into the table: "stop_place" */
  readonly stops_database_insert_stop_place?: Maybe<StopsDatabaseStopPlaceMutationResponse>;
  /** insert data into the table: "stop_place_access_spaces" */
  readonly stops_database_insert_stop_place_access_spaces?: Maybe<StopsDatabaseStopPlaceAccessSpacesMutationResponse>;
  /** insert a single row into the table: "stop_place_access_spaces" */
  readonly stops_database_insert_stop_place_access_spaces_one?: Maybe<StopsDatabaseStopPlaceAccessSpaces>;
  /** insert data into the table: "stop_place_adjacent_sites" */
  readonly stops_database_insert_stop_place_adjacent_sites?: Maybe<StopsDatabaseStopPlaceAdjacentSitesMutationResponse>;
  /** insert a single row into the table: "stop_place_adjacent_sites" */
  readonly stops_database_insert_stop_place_adjacent_sites_one?: Maybe<StopsDatabaseStopPlaceAdjacentSites>;
  /** insert data into the table: "stop_place_alternative_names" */
  readonly stops_database_insert_stop_place_alternative_names?: Maybe<StopsDatabaseStopPlaceAlternativeNamesMutationResponse>;
  /** insert a single row into the table: "stop_place_alternative_names" */
  readonly stops_database_insert_stop_place_alternative_names_one?: Maybe<StopsDatabaseStopPlaceAlternativeNames>;
  /** insert data into the table: "stop_place_children" */
  readonly stops_database_insert_stop_place_children?: Maybe<StopsDatabaseStopPlaceChildrenMutationResponse>;
  /** insert a single row into the table: "stop_place_children" */
  readonly stops_database_insert_stop_place_children_one?: Maybe<StopsDatabaseStopPlaceChildren>;
  /** insert data into the table: "stop_place_equipment_places" */
  readonly stops_database_insert_stop_place_equipment_places?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesMutationResponse>;
  /** insert a single row into the table: "stop_place_equipment_places" */
  readonly stops_database_insert_stop_place_equipment_places_one?: Maybe<StopsDatabaseStopPlaceEquipmentPlaces>;
  /** insert data into the table: "stop_place_key_values" */
  readonly stops_database_insert_stop_place_key_values?: Maybe<StopsDatabaseStopPlaceKeyValuesMutationResponse>;
  /** insert a single row into the table: "stop_place_key_values" */
  readonly stops_database_insert_stop_place_key_values_one?: Maybe<StopsDatabaseStopPlaceKeyValues>;
  /** insert a single row into the table: "stop_place" */
  readonly stops_database_insert_stop_place_one?: Maybe<StopsDatabaseStopPlace>;
  /** insert data into the table: "stop_place_organisations" */
  readonly stops_database_insert_stop_place_organisations?: Maybe<StopsDatabaseStopPlaceOrganisationsMutationResponse>;
  /** insert a single row into the table: "stop_place_organisations" */
  readonly stops_database_insert_stop_place_organisations_one?: Maybe<StopsDatabaseStopPlaceOrganisations>;
  /** insert data into the table: "stop_place_quays" */
  readonly stops_database_insert_stop_place_quays?: Maybe<StopsDatabaseStopPlaceQuaysMutationResponse>;
  /** insert a single row into the table: "stop_place_quays" */
  readonly stops_database_insert_stop_place_quays_one?: Maybe<StopsDatabaseStopPlaceQuays>;
  /** insert data into the table: "stop_place_tariff_zones" */
  readonly stops_database_insert_stop_place_tariff_zones?: Maybe<StopsDatabaseStopPlaceTariffZonesMutationResponse>;
  /** insert a single row into the table: "stop_place_tariff_zones" */
  readonly stops_database_insert_stop_place_tariff_zones_one?: Maybe<StopsDatabaseStopPlaceTariffZones>;
  /** insert data into the table: "tag" */
  readonly stops_database_insert_tag?: Maybe<StopsDatabaseTagMutationResponse>;
  /** insert a single row into the table: "tag" */
  readonly stops_database_insert_tag_one?: Maybe<StopsDatabaseTag>;
  /** insert data into the table: "tariff_zone" */
  readonly stops_database_insert_tariff_zone?: Maybe<StopsDatabaseTariffZoneMutationResponse>;
  /** insert data into the table: "tariff_zone_key_values" */
  readonly stops_database_insert_tariff_zone_key_values?: Maybe<StopsDatabaseTariffZoneKeyValuesMutationResponse>;
  /** insert a single row into the table: "tariff_zone_key_values" */
  readonly stops_database_insert_tariff_zone_key_values_one?: Maybe<StopsDatabaseTariffZoneKeyValues>;
  /** insert a single row into the table: "tariff_zone" */
  readonly stops_database_insert_tariff_zone_one?: Maybe<StopsDatabaseTariffZone>;
  /** insert data into the table: "topographic_place" */
  readonly stops_database_insert_topographic_place?: Maybe<StopsDatabaseTopographicPlaceMutationResponse>;
  /** insert data into the table: "topographic_place_key_values" */
  readonly stops_database_insert_topographic_place_key_values?: Maybe<StopsDatabaseTopographicPlaceKeyValuesMutationResponse>;
  /** insert a single row into the table: "topographic_place_key_values" */
  readonly stops_database_insert_topographic_place_key_values_one?: Maybe<StopsDatabaseTopographicPlaceKeyValues>;
  /** insert a single row into the table: "topographic_place" */
  readonly stops_database_insert_topographic_place_one?: Maybe<StopsDatabaseTopographicPlace>;
  /** insert data into the table: "value" */
  readonly stops_database_insert_value?: Maybe<StopsDatabaseValueMutationResponse>;
  /** insert data into the table: "value_items" */
  readonly stops_database_insert_value_items?: Maybe<StopsDatabaseValueItemsMutationResponse>;
  /** insert a single row into the table: "value_items" */
  readonly stops_database_insert_value_items_one?: Maybe<StopsDatabaseValueItems>;
  /** insert a single row into the table: "value" */
  readonly stops_database_insert_value_one?: Maybe<StopsDatabaseValue>;
  /** update data of the table: "access_space" */
  readonly stops_database_update_access_space?: Maybe<StopsDatabaseAccessSpaceMutationResponse>;
  /** update data of the table: "access_space_alternative_names" */
  readonly stops_database_update_access_space_alternative_names?: Maybe<StopsDatabaseAccessSpaceAlternativeNamesMutationResponse>;
  /** update multiples rows of table: "access_space_alternative_names" */
  readonly stops_database_update_access_space_alternative_names_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseAccessSpaceAlternativeNamesMutationResponse>>>;
  /** update single row of the table: "access_space" */
  readonly stops_database_update_access_space_by_pk?: Maybe<StopsDatabaseAccessSpace>;
  /** update data of the table: "access_space_check_constraints" */
  readonly stops_database_update_access_space_check_constraints?: Maybe<StopsDatabaseAccessSpaceCheckConstraintsMutationResponse>;
  /** update multiples rows of table: "access_space_check_constraints" */
  readonly stops_database_update_access_space_check_constraints_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseAccessSpaceCheckConstraintsMutationResponse>>>;
  /** update data of the table: "access_space_equipment_places" */
  readonly stops_database_update_access_space_equipment_places?: Maybe<StopsDatabaseAccessSpaceEquipmentPlacesMutationResponse>;
  /** update multiples rows of table: "access_space_equipment_places" */
  readonly stops_database_update_access_space_equipment_places_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseAccessSpaceEquipmentPlacesMutationResponse>>>;
  /** update data of the table: "access_space_key_values" */
  readonly stops_database_update_access_space_key_values?: Maybe<StopsDatabaseAccessSpaceKeyValuesMutationResponse>;
  /** update single row of the table: "access_space_key_values" */
  readonly stops_database_update_access_space_key_values_by_pk?: Maybe<StopsDatabaseAccessSpaceKeyValues>;
  /** update multiples rows of table: "access_space_key_values" */
  readonly stops_database_update_access_space_key_values_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseAccessSpaceKeyValuesMutationResponse>>>;
  /** update multiples rows of table: "access_space" */
  readonly stops_database_update_access_space_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseAccessSpaceMutationResponse>>>;
  /** update data of the table: "accessibility_assessment" */
  readonly stops_database_update_accessibility_assessment?: Maybe<StopsDatabaseAccessibilityAssessmentMutationResponse>;
  /** update single row of the table: "accessibility_assessment" */
  readonly stops_database_update_accessibility_assessment_by_pk?: Maybe<StopsDatabaseAccessibilityAssessment>;
  /** update data of the table: "accessibility_assessment_limitations" */
  readonly stops_database_update_accessibility_assessment_limitations?: Maybe<StopsDatabaseAccessibilityAssessmentLimitationsMutationResponse>;
  /** update multiples rows of table: "accessibility_assessment_limitations" */
  readonly stops_database_update_accessibility_assessment_limitations_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseAccessibilityAssessmentLimitationsMutationResponse>>>;
  /** update multiples rows of table: "accessibility_assessment" */
  readonly stops_database_update_accessibility_assessment_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseAccessibilityAssessmentMutationResponse>>>;
  /** update data of the table: "accessibility_limitation" */
  readonly stops_database_update_accessibility_limitation?: Maybe<StopsDatabaseAccessibilityLimitationMutationResponse>;
  /** update single row of the table: "accessibility_limitation" */
  readonly stops_database_update_accessibility_limitation_by_pk?: Maybe<StopsDatabaseAccessibilityLimitation>;
  /** update multiples rows of table: "accessibility_limitation" */
  readonly stops_database_update_accessibility_limitation_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseAccessibilityLimitationMutationResponse>>>;
  /** update data of the table: "alternative_name" */
  readonly stops_database_update_alternative_name?: Maybe<StopsDatabaseAlternativeNameMutationResponse>;
  /** update single row of the table: "alternative_name" */
  readonly stops_database_update_alternative_name_by_pk?: Maybe<StopsDatabaseAlternativeName>;
  /** update multiples rows of table: "alternative_name" */
  readonly stops_database_update_alternative_name_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseAlternativeNameMutationResponse>>>;
  /** update data of the table: "boarding_position" */
  readonly stops_database_update_boarding_position?: Maybe<StopsDatabaseBoardingPositionMutationResponse>;
  /** update data of the table: "boarding_position_alternative_names" */
  readonly stops_database_update_boarding_position_alternative_names?: Maybe<StopsDatabaseBoardingPositionAlternativeNamesMutationResponse>;
  /** update multiples rows of table: "boarding_position_alternative_names" */
  readonly stops_database_update_boarding_position_alternative_names_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseBoardingPositionAlternativeNamesMutationResponse>>>;
  /** update single row of the table: "boarding_position" */
  readonly stops_database_update_boarding_position_by_pk?: Maybe<StopsDatabaseBoardingPosition>;
  /** update data of the table: "boarding_position_check_constraints" */
  readonly stops_database_update_boarding_position_check_constraints?: Maybe<StopsDatabaseBoardingPositionCheckConstraintsMutationResponse>;
  /** update multiples rows of table: "boarding_position_check_constraints" */
  readonly stops_database_update_boarding_position_check_constraints_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseBoardingPositionCheckConstraintsMutationResponse>>>;
  /** update data of the table: "boarding_position_equipment_places" */
  readonly stops_database_update_boarding_position_equipment_places?: Maybe<StopsDatabaseBoardingPositionEquipmentPlacesMutationResponse>;
  /** update multiples rows of table: "boarding_position_equipment_places" */
  readonly stops_database_update_boarding_position_equipment_places_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseBoardingPositionEquipmentPlacesMutationResponse>>>;
  /** update data of the table: "boarding_position_key_values" */
  readonly stops_database_update_boarding_position_key_values?: Maybe<StopsDatabaseBoardingPositionKeyValuesMutationResponse>;
  /** update single row of the table: "boarding_position_key_values" */
  readonly stops_database_update_boarding_position_key_values_by_pk?: Maybe<StopsDatabaseBoardingPositionKeyValues>;
  /** update multiples rows of table: "boarding_position_key_values" */
  readonly stops_database_update_boarding_position_key_values_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseBoardingPositionKeyValuesMutationResponse>>>;
  /** update multiples rows of table: "boarding_position" */
  readonly stops_database_update_boarding_position_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseBoardingPositionMutationResponse>>>;
  /** update data of the table: "check_constraint" */
  readonly stops_database_update_check_constraint?: Maybe<StopsDatabaseCheckConstraintMutationResponse>;
  /** update single row of the table: "check_constraint" */
  readonly stops_database_update_check_constraint_by_pk?: Maybe<StopsDatabaseCheckConstraint>;
  /** update data of the table: "check_constraint_key_values" */
  readonly stops_database_update_check_constraint_key_values?: Maybe<StopsDatabaseCheckConstraintKeyValuesMutationResponse>;
  /** update single row of the table: "check_constraint_key_values" */
  readonly stops_database_update_check_constraint_key_values_by_pk?: Maybe<StopsDatabaseCheckConstraintKeyValues>;
  /** update multiples rows of table: "check_constraint_key_values" */
  readonly stops_database_update_check_constraint_key_values_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseCheckConstraintKeyValuesMutationResponse>>>;
  /** update multiples rows of table: "check_constraint" */
  readonly stops_database_update_check_constraint_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseCheckConstraintMutationResponse>>>;
  /** update data of the table: "contact" */
  readonly stops_database_update_contact?: Maybe<StopsDatabaseContactMutationResponse>;
  /** update single row of the table: "contact" */
  readonly stops_database_update_contact_by_pk?: Maybe<StopsDatabaseContact>;
  /** update multiples rows of table: "contact" */
  readonly stops_database_update_contact_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseContactMutationResponse>>>;
  /** update data of the table: "destination_display_view" */
  readonly stops_database_update_destination_display_view?: Maybe<StopsDatabaseDestinationDisplayViewMutationResponse>;
  /** update single row of the table: "destination_display_view" */
  readonly stops_database_update_destination_display_view_by_pk?: Maybe<StopsDatabaseDestinationDisplayView>;
  /** update multiples rows of table: "destination_display_view" */
  readonly stops_database_update_destination_display_view_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseDestinationDisplayViewMutationResponse>>>;
  /** update data of the table: "equipment_place" */
  readonly stops_database_update_equipment_place?: Maybe<StopsDatabaseEquipmentPlaceMutationResponse>;
  /** update single row of the table: "equipment_place" */
  readonly stops_database_update_equipment_place_by_pk?: Maybe<StopsDatabaseEquipmentPlace>;
  /** update data of the table: "equipment_place_equipment_positions" */
  readonly stops_database_update_equipment_place_equipment_positions?: Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsMutationResponse>;
  /** update multiples rows of table: "equipment_place_equipment_positions" */
  readonly stops_database_update_equipment_place_equipment_positions_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseEquipmentPlaceEquipmentPositionsMutationResponse>>>;
  /** update data of the table: "equipment_place_key_values" */
  readonly stops_database_update_equipment_place_key_values?: Maybe<StopsDatabaseEquipmentPlaceKeyValuesMutationResponse>;
  /** update single row of the table: "equipment_place_key_values" */
  readonly stops_database_update_equipment_place_key_values_by_pk?: Maybe<StopsDatabaseEquipmentPlaceKeyValues>;
  /** update multiples rows of table: "equipment_place_key_values" */
  readonly stops_database_update_equipment_place_key_values_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseEquipmentPlaceKeyValuesMutationResponse>>>;
  /** update multiples rows of table: "equipment_place" */
  readonly stops_database_update_equipment_place_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseEquipmentPlaceMutationResponse>>>;
  /** update data of the table: "equipment_position" */
  readonly stops_database_update_equipment_position?: Maybe<StopsDatabaseEquipmentPositionMutationResponse>;
  /** update single row of the table: "equipment_position" */
  readonly stops_database_update_equipment_position_by_pk?: Maybe<StopsDatabaseEquipmentPosition>;
  /** update data of the table: "equipment_position_key_values" */
  readonly stops_database_update_equipment_position_key_values?: Maybe<StopsDatabaseEquipmentPositionKeyValuesMutationResponse>;
  /** update single row of the table: "equipment_position_key_values" */
  readonly stops_database_update_equipment_position_key_values_by_pk?: Maybe<StopsDatabaseEquipmentPositionKeyValues>;
  /** update multiples rows of table: "equipment_position_key_values" */
  readonly stops_database_update_equipment_position_key_values_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseEquipmentPositionKeyValuesMutationResponse>>>;
  /** update multiples rows of table: "equipment_position" */
  readonly stops_database_update_equipment_position_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseEquipmentPositionMutationResponse>>>;
  /** update data of the table: "export_job" */
  readonly stops_database_update_export_job?: Maybe<StopsDatabaseExportJobMutationResponse>;
  /** update single row of the table: "export_job" */
  readonly stops_database_update_export_job_by_pk?: Maybe<StopsDatabaseExportJob>;
  /** update multiples rows of table: "export_job" */
  readonly stops_database_update_export_job_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseExportJobMutationResponse>>>;
  /** update data of the table: "fare_zone" */
  readonly stops_database_update_fare_zone?: Maybe<StopsDatabaseFareZoneMutationResponse>;
  /** update single row of the table: "fare_zone" */
  readonly stops_database_update_fare_zone_by_pk?: Maybe<StopsDatabaseFareZone>;
  /** update data of the table: "fare_zone_key_values" */
  readonly stops_database_update_fare_zone_key_values?: Maybe<StopsDatabaseFareZoneKeyValuesMutationResponse>;
  /** update single row of the table: "fare_zone_key_values" */
  readonly stops_database_update_fare_zone_key_values_by_pk?: Maybe<StopsDatabaseFareZoneKeyValues>;
  /** update multiples rows of table: "fare_zone_key_values" */
  readonly stops_database_update_fare_zone_key_values_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseFareZoneKeyValuesMutationResponse>>>;
  /** update multiples rows of table: "fare_zone" */
  readonly stops_database_update_fare_zone_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseFareZoneMutationResponse>>>;
  /** update data of the table: "fare_zone_members" */
  readonly stops_database_update_fare_zone_members?: Maybe<StopsDatabaseFareZoneMembersMutationResponse>;
  /** update multiples rows of table: "fare_zone_members" */
  readonly stops_database_update_fare_zone_members_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseFareZoneMembersMutationResponse>>>;
  /** update data of the table: "fare_zone_neighbours" */
  readonly stops_database_update_fare_zone_neighbours?: Maybe<StopsDatabaseFareZoneNeighboursMutationResponse>;
  /** update multiples rows of table: "fare_zone_neighbours" */
  readonly stops_database_update_fare_zone_neighbours_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseFareZoneNeighboursMutationResponse>>>;
  /** update data of the table: "geometry_columns" */
  readonly stops_database_update_geometry_columns?: Maybe<StopsDatabaseGeometryColumnsMutationResponse>;
  /** update multiples rows of table: "geometry_columns" */
  readonly stops_database_update_geometry_columns_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseGeometryColumnsMutationResponse>>>;
  /** update data of the table: "group_of_stop_places" */
  readonly stops_database_update_group_of_stop_places?: Maybe<StopsDatabaseGroupOfStopPlacesMutationResponse>;
  /** update data of the table: "group_of_stop_places_alternative_names" */
  readonly stops_database_update_group_of_stop_places_alternative_names?: Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesMutationResponse>;
  /** update multiples rows of table: "group_of_stop_places_alternative_names" */
  readonly stops_database_update_group_of_stop_places_alternative_names_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesMutationResponse>>>;
  /** update single row of the table: "group_of_stop_places" */
  readonly stops_database_update_group_of_stop_places_by_pk?: Maybe<StopsDatabaseGroupOfStopPlaces>;
  /** update data of the table: "group_of_stop_places_key_values" */
  readonly stops_database_update_group_of_stop_places_key_values?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesMutationResponse>;
  /** update single row of the table: "group_of_stop_places_key_values" */
  readonly stops_database_update_group_of_stop_places_key_values_by_pk?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValues>;
  /** update multiples rows of table: "group_of_stop_places_key_values" */
  readonly stops_database_update_group_of_stop_places_key_values_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseGroupOfStopPlacesKeyValuesMutationResponse>>>;
  /** update multiples rows of table: "group_of_stop_places" */
  readonly stops_database_update_group_of_stop_places_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseGroupOfStopPlacesMutationResponse>>>;
  /** update data of the table: "group_of_stop_places_members" */
  readonly stops_database_update_group_of_stop_places_members?: Maybe<StopsDatabaseGroupOfStopPlacesMembersMutationResponse>;
  /** update multiples rows of table: "group_of_stop_places_members" */
  readonly stops_database_update_group_of_stop_places_members_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseGroupOfStopPlacesMembersMutationResponse>>>;
  /** update data of the table: "group_of_tariff_zones" */
  readonly stops_database_update_group_of_tariff_zones?: Maybe<StopsDatabaseGroupOfTariffZonesMutationResponse>;
  /** update single row of the table: "group_of_tariff_zones" */
  readonly stops_database_update_group_of_tariff_zones_by_pk?: Maybe<StopsDatabaseGroupOfTariffZones>;
  /** update data of the table: "group_of_tariff_zones_key_values" */
  readonly stops_database_update_group_of_tariff_zones_key_values?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesMutationResponse>;
  /** update single row of the table: "group_of_tariff_zones_key_values" */
  readonly stops_database_update_group_of_tariff_zones_key_values_by_pk?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValues>;
  /** update multiples rows of table: "group_of_tariff_zones_key_values" */
  readonly stops_database_update_group_of_tariff_zones_key_values_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseGroupOfTariffZonesKeyValuesMutationResponse>>>;
  /** update multiples rows of table: "group_of_tariff_zones" */
  readonly stops_database_update_group_of_tariff_zones_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseGroupOfTariffZonesMutationResponse>>>;
  /** update data of the table: "group_of_tariff_zones_members" */
  readonly stops_database_update_group_of_tariff_zones_members?: Maybe<StopsDatabaseGroupOfTariffZonesMembersMutationResponse>;
  /** update single row of the table: "group_of_tariff_zones_members" */
  readonly stops_database_update_group_of_tariff_zones_members_by_pk?: Maybe<StopsDatabaseGroupOfTariffZonesMembers>;
  /** update multiples rows of table: "group_of_tariff_zones_members" */
  readonly stops_database_update_group_of_tariff_zones_members_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseGroupOfTariffZonesMembersMutationResponse>>>;
  /** update data of the table: "hsl_accessibility_properties" */
  readonly stops_database_update_hsl_accessibility_properties?: Maybe<StopsDatabaseHslAccessibilityPropertiesMutationResponse>;
  /** update single row of the table: "hsl_accessibility_properties" */
  readonly stops_database_update_hsl_accessibility_properties_by_pk?: Maybe<StopsDatabaseHslAccessibilityProperties>;
  /** update multiples rows of table: "hsl_accessibility_properties" */
  readonly stops_database_update_hsl_accessibility_properties_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseHslAccessibilityPropertiesMutationResponse>>>;
  /** update data of the table: "id_generator" */
  readonly stops_database_update_id_generator?: Maybe<StopsDatabaseIdGeneratorMutationResponse>;
  /** update multiples rows of table: "id_generator" */
  readonly stops_database_update_id_generator_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseIdGeneratorMutationResponse>>>;
  /** update data of the table: "info_spot" */
  readonly stops_database_update_info_spot?: Maybe<StopsDatabaseInfoSpotMutationResponse>;
  /** update single row of the table: "info_spot" */
  readonly stops_database_update_info_spot_by_pk?: Maybe<StopsDatabaseInfoSpot>;
  /** update multiples rows of table: "info_spot" */
  readonly stops_database_update_info_spot_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseInfoSpotMutationResponse>>>;
  /** update data of the table: "info_spot_poster" */
  readonly stops_database_update_info_spot_poster?: Maybe<StopsDatabaseInfoSpotPosterMutationResponse>;
  /** update single row of the table: "info_spot_poster" */
  readonly stops_database_update_info_spot_poster_by_pk?: Maybe<StopsDatabaseInfoSpotPoster>;
  /** update multiples rows of table: "info_spot_poster" */
  readonly stops_database_update_info_spot_poster_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseInfoSpotPosterMutationResponse>>>;
  /** update data of the table: "installed_equipment" */
  readonly stops_database_update_installed_equipment?: Maybe<StopsDatabaseInstalledEquipmentMutationResponse>;
  /** update multiples rows of table: "installed_equipment" */
  readonly stops_database_update_installed_equipment_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseInstalledEquipmentMutationResponse>>>;
  /** update data of the table: "installed_equipment_version_structure" */
  readonly stops_database_update_installed_equipment_version_structure?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureMutationResponse>;
  /** update single row of the table: "installed_equipment_version_structure" */
  readonly stops_database_update_installed_equipment_version_structure_by_pk?: Maybe<StopsDatabaseInstalledEquipmentVersionStructure>;
  /** update data of the table: "installed_equipment_version_structure_installed_equipment" */
  readonly stops_database_update_installed_equipment_version_structure_installed_equipment?: Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMutationResponse>;
  /** update multiples rows of table: "installed_equipment_version_structure_installed_equipment" */
  readonly stops_database_update_installed_equipment_version_structure_installed_equipment_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentMutationResponse>>>;
  /** update multiples rows of table: "installed_equipment_version_structure" */
  readonly stops_database_update_installed_equipment_version_structure_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseInstalledEquipmentVersionStructureMutationResponse>>>;
  /** update data of the table: "level" */
  readonly stops_database_update_level?: Maybe<StopsDatabaseLevelMutationResponse>;
  /** update single row of the table: "level" */
  readonly stops_database_update_level_by_pk?: Maybe<StopsDatabaseLevel>;
  /** update data of the table: "level_key_values" */
  readonly stops_database_update_level_key_values?: Maybe<StopsDatabaseLevelKeyValuesMutationResponse>;
  /** update single row of the table: "level_key_values" */
  readonly stops_database_update_level_key_values_by_pk?: Maybe<StopsDatabaseLevelKeyValues>;
  /** update multiples rows of table: "level_key_values" */
  readonly stops_database_update_level_key_values_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseLevelKeyValuesMutationResponse>>>;
  /** update multiples rows of table: "level" */
  readonly stops_database_update_level_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseLevelMutationResponse>>>;
  /** update data of the table: "multilingual_string_entity" */
  readonly stops_database_update_multilingual_string_entity?: Maybe<StopsDatabaseMultilingualStringEntityMutationResponse>;
  /** update single row of the table: "multilingual_string_entity" */
  readonly stops_database_update_multilingual_string_entity_by_pk?: Maybe<StopsDatabaseMultilingualStringEntity>;
  /** update multiples rows of table: "multilingual_string_entity" */
  readonly stops_database_update_multilingual_string_entity_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseMultilingualStringEntityMutationResponse>>>;
  /** update data of the table: "navigation_path" */
  readonly stops_database_update_navigation_path?: Maybe<StopsDatabaseNavigationPathMutationResponse>;
  /** update multiples rows of table: "navigation_path" */
  readonly stops_database_update_navigation_path_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseNavigationPathMutationResponse>>>;
  /** update data of the table: "organisation" */
  readonly stops_database_update_organisation?: Maybe<StopsDatabaseOrganisationMutationResponse>;
  /** update single row of the table: "organisation" */
  readonly stops_database_update_organisation_by_pk?: Maybe<StopsDatabaseOrganisation>;
  /** update data of the table: "organisation_key_values" */
  readonly stops_database_update_organisation_key_values?: Maybe<StopsDatabaseOrganisationKeyValuesMutationResponse>;
  /** update single row of the table: "organisation_key_values" */
  readonly stops_database_update_organisation_key_values_by_pk?: Maybe<StopsDatabaseOrganisationKeyValues>;
  /** update multiples rows of table: "organisation_key_values" */
  readonly stops_database_update_organisation_key_values_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseOrganisationKeyValuesMutationResponse>>>;
  /** update multiples rows of table: "organisation" */
  readonly stops_database_update_organisation_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseOrganisationMutationResponse>>>;
  /** update data of the table: "parking" */
  readonly stops_database_update_parking?: Maybe<StopsDatabaseParkingMutationResponse>;
  /** update data of the table: "parking_adjacent_sites" */
  readonly stops_database_update_parking_adjacent_sites?: Maybe<StopsDatabaseParkingAdjacentSitesMutationResponse>;
  /** update multiples rows of table: "parking_adjacent_sites" */
  readonly stops_database_update_parking_adjacent_sites_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseParkingAdjacentSitesMutationResponse>>>;
  /** update data of the table: "parking_alternative_names" */
  readonly stops_database_update_parking_alternative_names?: Maybe<StopsDatabaseParkingAlternativeNamesMutationResponse>;
  /** update multiples rows of table: "parking_alternative_names" */
  readonly stops_database_update_parking_alternative_names_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseParkingAlternativeNamesMutationResponse>>>;
  /** update data of the table: "parking_area" */
  readonly stops_database_update_parking_area?: Maybe<StopsDatabaseParkingAreaMutationResponse>;
  /** update data of the table: "parking_area_alternative_names" */
  readonly stops_database_update_parking_area_alternative_names?: Maybe<StopsDatabaseParkingAreaAlternativeNamesMutationResponse>;
  /** update multiples rows of table: "parking_area_alternative_names" */
  readonly stops_database_update_parking_area_alternative_names_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseParkingAreaAlternativeNamesMutationResponse>>>;
  /** update single row of the table: "parking_area" */
  readonly stops_database_update_parking_area_by_pk?: Maybe<StopsDatabaseParkingArea>;
  /** update data of the table: "parking_area_check_constraints" */
  readonly stops_database_update_parking_area_check_constraints?: Maybe<StopsDatabaseParkingAreaCheckConstraintsMutationResponse>;
  /** update multiples rows of table: "parking_area_check_constraints" */
  readonly stops_database_update_parking_area_check_constraints_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseParkingAreaCheckConstraintsMutationResponse>>>;
  /** update data of the table: "parking_area_equipment_places" */
  readonly stops_database_update_parking_area_equipment_places?: Maybe<StopsDatabaseParkingAreaEquipmentPlacesMutationResponse>;
  /** update multiples rows of table: "parking_area_equipment_places" */
  readonly stops_database_update_parking_area_equipment_places_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseParkingAreaEquipmentPlacesMutationResponse>>>;
  /** update data of the table: "parking_area_key_values" */
  readonly stops_database_update_parking_area_key_values?: Maybe<StopsDatabaseParkingAreaKeyValuesMutationResponse>;
  /** update single row of the table: "parking_area_key_values" */
  readonly stops_database_update_parking_area_key_values_by_pk?: Maybe<StopsDatabaseParkingAreaKeyValues>;
  /** update multiples rows of table: "parking_area_key_values" */
  readonly stops_database_update_parking_area_key_values_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseParkingAreaKeyValuesMutationResponse>>>;
  /** update multiples rows of table: "parking_area" */
  readonly stops_database_update_parking_area_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseParkingAreaMutationResponse>>>;
  /** update single row of the table: "parking" */
  readonly stops_database_update_parking_by_pk?: Maybe<StopsDatabaseParking>;
  /** update data of the table: "parking_capacity" */
  readonly stops_database_update_parking_capacity?: Maybe<StopsDatabaseParkingCapacityMutationResponse>;
  /** update single row of the table: "parking_capacity" */
  readonly stops_database_update_parking_capacity_by_pk?: Maybe<StopsDatabaseParkingCapacity>;
  /** update multiples rows of table: "parking_capacity" */
  readonly stops_database_update_parking_capacity_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseParkingCapacityMutationResponse>>>;
  /** update data of the table: "parking_equipment_places" */
  readonly stops_database_update_parking_equipment_places?: Maybe<StopsDatabaseParkingEquipmentPlacesMutationResponse>;
  /** update multiples rows of table: "parking_equipment_places" */
  readonly stops_database_update_parking_equipment_places_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseParkingEquipmentPlacesMutationResponse>>>;
  /** update data of the table: "parking_key_values" */
  readonly stops_database_update_parking_key_values?: Maybe<StopsDatabaseParkingKeyValuesMutationResponse>;
  /** update single row of the table: "parking_key_values" */
  readonly stops_database_update_parking_key_values_by_pk?: Maybe<StopsDatabaseParkingKeyValues>;
  /** update multiples rows of table: "parking_key_values" */
  readonly stops_database_update_parking_key_values_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseParkingKeyValuesMutationResponse>>>;
  /** update multiples rows of table: "parking" */
  readonly stops_database_update_parking_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseParkingMutationResponse>>>;
  /** update data of the table: "parking_parking_areas" */
  readonly stops_database_update_parking_parking_areas?: Maybe<StopsDatabaseParkingParkingAreasMutationResponse>;
  /** update multiples rows of table: "parking_parking_areas" */
  readonly stops_database_update_parking_parking_areas_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseParkingParkingAreasMutationResponse>>>;
  /** update data of the table: "parking_parking_payment_process" */
  readonly stops_database_update_parking_parking_payment_process?: Maybe<StopsDatabaseParkingParkingPaymentProcessMutationResponse>;
  /** update multiples rows of table: "parking_parking_payment_process" */
  readonly stops_database_update_parking_parking_payment_process_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseParkingParkingPaymentProcessMutationResponse>>>;
  /** update data of the table: "parking_parking_properties" */
  readonly stops_database_update_parking_parking_properties?: Maybe<StopsDatabaseParkingParkingPropertiesMutationResponse>;
  /** update multiples rows of table: "parking_parking_properties" */
  readonly stops_database_update_parking_parking_properties_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseParkingParkingPropertiesMutationResponse>>>;
  /** update data of the table: "parking_parking_vehicle_types" */
  readonly stops_database_update_parking_parking_vehicle_types?: Maybe<StopsDatabaseParkingParkingVehicleTypesMutationResponse>;
  /** update multiples rows of table: "parking_parking_vehicle_types" */
  readonly stops_database_update_parking_parking_vehicle_types_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseParkingParkingVehicleTypesMutationResponse>>>;
  /** update data of the table: "parking_properties" */
  readonly stops_database_update_parking_properties?: Maybe<StopsDatabaseParkingPropertiesMutationResponse>;
  /** update single row of the table: "parking_properties" */
  readonly stops_database_update_parking_properties_by_pk?: Maybe<StopsDatabaseParkingProperties>;
  /** update multiples rows of table: "parking_properties" */
  readonly stops_database_update_parking_properties_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseParkingPropertiesMutationResponse>>>;
  /** update data of the table: "parking_properties_parking_user_types" */
  readonly stops_database_update_parking_properties_parking_user_types?: Maybe<StopsDatabaseParkingPropertiesParkingUserTypesMutationResponse>;
  /** update multiples rows of table: "parking_properties_parking_user_types" */
  readonly stops_database_update_parking_properties_parking_user_types_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseParkingPropertiesParkingUserTypesMutationResponse>>>;
  /** update data of the table: "parking_properties_spaces" */
  readonly stops_database_update_parking_properties_spaces?: Maybe<StopsDatabaseParkingPropertiesSpacesMutationResponse>;
  /** update multiples rows of table: "parking_properties_spaces" */
  readonly stops_database_update_parking_properties_spaces_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseParkingPropertiesSpacesMutationResponse>>>;
  /** update data of the table: "path_junction" */
  readonly stops_database_update_path_junction?: Maybe<StopsDatabasePathJunctionMutationResponse>;
  /** update single row of the table: "path_junction" */
  readonly stops_database_update_path_junction_by_pk?: Maybe<StopsDatabasePathJunction>;
  /** update data of the table: "path_junction_key_values" */
  readonly stops_database_update_path_junction_key_values?: Maybe<StopsDatabasePathJunctionKeyValuesMutationResponse>;
  /** update single row of the table: "path_junction_key_values" */
  readonly stops_database_update_path_junction_key_values_by_pk?: Maybe<StopsDatabasePathJunctionKeyValues>;
  /** update multiples rows of table: "path_junction_key_values" */
  readonly stops_database_update_path_junction_key_values_many?: Maybe<ReadonlyArray<Maybe<StopsDatabasePathJunctionKeyValuesMutationResponse>>>;
  /** update multiples rows of table: "path_junction" */
  readonly stops_database_update_path_junction_many?: Maybe<ReadonlyArray<Maybe<StopsDatabasePathJunctionMutationResponse>>>;
  /** update data of the table: "path_link" */
  readonly stops_database_update_path_link?: Maybe<StopsDatabasePathLinkMutationResponse>;
  /** update single row of the table: "path_link" */
  readonly stops_database_update_path_link_by_pk?: Maybe<StopsDatabasePathLink>;
  /** update data of the table: "path_link_end" */
  readonly stops_database_update_path_link_end?: Maybe<StopsDatabasePathLinkEndMutationResponse>;
  /** update single row of the table: "path_link_end" */
  readonly stops_database_update_path_link_end_by_pk?: Maybe<StopsDatabasePathLinkEnd>;
  /** update multiples rows of table: "path_link_end" */
  readonly stops_database_update_path_link_end_many?: Maybe<ReadonlyArray<Maybe<StopsDatabasePathLinkEndMutationResponse>>>;
  /** update data of the table: "path_link_key_values" */
  readonly stops_database_update_path_link_key_values?: Maybe<StopsDatabasePathLinkKeyValuesMutationResponse>;
  /** update single row of the table: "path_link_key_values" */
  readonly stops_database_update_path_link_key_values_by_pk?: Maybe<StopsDatabasePathLinkKeyValues>;
  /** update multiples rows of table: "path_link_key_values" */
  readonly stops_database_update_path_link_key_values_many?: Maybe<ReadonlyArray<Maybe<StopsDatabasePathLinkKeyValuesMutationResponse>>>;
  /** update multiples rows of table: "path_link" */
  readonly stops_database_update_path_link_many?: Maybe<ReadonlyArray<Maybe<StopsDatabasePathLinkMutationResponse>>>;
  /** update data of the table: "persistable_polygon" */
  readonly stops_database_update_persistable_polygon?: Maybe<StopsDatabasePersistablePolygonMutationResponse>;
  /** update single row of the table: "persistable_polygon" */
  readonly stops_database_update_persistable_polygon_by_pk?: Maybe<StopsDatabasePersistablePolygon>;
  /** update multiples rows of table: "persistable_polygon" */
  readonly stops_database_update_persistable_polygon_many?: Maybe<ReadonlyArray<Maybe<StopsDatabasePersistablePolygonMutationResponse>>>;
  /** update data of the table: "purpose_of_grouping" */
  readonly stops_database_update_purpose_of_grouping?: Maybe<StopsDatabasePurposeOfGroupingMutationResponse>;
  /** update single row of the table: "purpose_of_grouping" */
  readonly stops_database_update_purpose_of_grouping_by_pk?: Maybe<StopsDatabasePurposeOfGrouping>;
  /** update data of the table: "purpose_of_grouping_key_values" */
  readonly stops_database_update_purpose_of_grouping_key_values?: Maybe<StopsDatabasePurposeOfGroupingKeyValuesMutationResponse>;
  /** update single row of the table: "purpose_of_grouping_key_values" */
  readonly stops_database_update_purpose_of_grouping_key_values_by_pk?: Maybe<StopsDatabasePurposeOfGroupingKeyValues>;
  /** update multiples rows of table: "purpose_of_grouping_key_values" */
  readonly stops_database_update_purpose_of_grouping_key_values_many?: Maybe<ReadonlyArray<Maybe<StopsDatabasePurposeOfGroupingKeyValuesMutationResponse>>>;
  /** update multiples rows of table: "purpose_of_grouping" */
  readonly stops_database_update_purpose_of_grouping_many?: Maybe<ReadonlyArray<Maybe<StopsDatabasePurposeOfGroupingMutationResponse>>>;
  /** update data of the table: "quay" */
  readonly stops_database_update_quay?: Maybe<StopsDatabaseQuayMutationResponse>;
  /** update data of the table: "quay_alternative_names" */
  readonly stops_database_update_quay_alternative_names?: Maybe<StopsDatabaseQuayAlternativeNamesMutationResponse>;
  /** update multiples rows of table: "quay_alternative_names" */
  readonly stops_database_update_quay_alternative_names_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseQuayAlternativeNamesMutationResponse>>>;
  /** update data of the table: "quay_boarding_positions" */
  readonly stops_database_update_quay_boarding_positions?: Maybe<StopsDatabaseQuayBoardingPositionsMutationResponse>;
  /** update multiples rows of table: "quay_boarding_positions" */
  readonly stops_database_update_quay_boarding_positions_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseQuayBoardingPositionsMutationResponse>>>;
  /** update single row of the table: "quay" */
  readonly stops_database_update_quay_by_pk?: Maybe<StopsDatabaseQuay>;
  /** update data of the table: "quay_check_constraints" */
  readonly stops_database_update_quay_check_constraints?: Maybe<StopsDatabaseQuayCheckConstraintsMutationResponse>;
  /** update multiples rows of table: "quay_check_constraints" */
  readonly stops_database_update_quay_check_constraints_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseQuayCheckConstraintsMutationResponse>>>;
  /** update data of the table: "quay_equipment_places" */
  readonly stops_database_update_quay_equipment_places?: Maybe<StopsDatabaseQuayEquipmentPlacesMutationResponse>;
  /** update multiples rows of table: "quay_equipment_places" */
  readonly stops_database_update_quay_equipment_places_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseQuayEquipmentPlacesMutationResponse>>>;
  /** update data of the table: "quay_key_values" */
  readonly stops_database_update_quay_key_values?: Maybe<StopsDatabaseQuayKeyValuesMutationResponse>;
  /** update single row of the table: "quay_key_values" */
  readonly stops_database_update_quay_key_values_by_pk?: Maybe<StopsDatabaseQuayKeyValues>;
  /** update multiples rows of table: "quay_key_values" */
  readonly stops_database_update_quay_key_values_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseQuayKeyValuesMutationResponse>>>;
  /** update multiples rows of table: "quay" */
  readonly stops_database_update_quay_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseQuayMutationResponse>>>;
  /** update data of the table: "schema_version" */
  readonly stops_database_update_schema_version?: Maybe<StopsDatabaseSchemaVersionMutationResponse>;
  /** update single row of the table: "schema_version" */
  readonly stops_database_update_schema_version_by_pk?: Maybe<StopsDatabaseSchemaVersion>;
  /** update multiples rows of table: "schema_version" */
  readonly stops_database_update_schema_version_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseSchemaVersionMutationResponse>>>;
  /** update data of the table: "spatial_ref_sys" */
  readonly stops_database_update_spatial_ref_sys?: Maybe<StopsDatabaseSpatialRefSysMutationResponse>;
  /** update single row of the table: "spatial_ref_sys" */
  readonly stops_database_update_spatial_ref_sys_by_pk?: Maybe<StopsDatabaseSpatialRefSys>;
  /** update multiples rows of table: "spatial_ref_sys" */
  readonly stops_database_update_spatial_ref_sys_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseSpatialRefSysMutationResponse>>>;
  /** update data of the table: "stop_place" */
  readonly stops_database_update_stop_place?: Maybe<StopsDatabaseStopPlaceMutationResponse>;
  /** update data of the table: "stop_place_access_spaces" */
  readonly stops_database_update_stop_place_access_spaces?: Maybe<StopsDatabaseStopPlaceAccessSpacesMutationResponse>;
  /** update multiples rows of table: "stop_place_access_spaces" */
  readonly stops_database_update_stop_place_access_spaces_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseStopPlaceAccessSpacesMutationResponse>>>;
  /** update data of the table: "stop_place_adjacent_sites" */
  readonly stops_database_update_stop_place_adjacent_sites?: Maybe<StopsDatabaseStopPlaceAdjacentSitesMutationResponse>;
  /** update multiples rows of table: "stop_place_adjacent_sites" */
  readonly stops_database_update_stop_place_adjacent_sites_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseStopPlaceAdjacentSitesMutationResponse>>>;
  /** update data of the table: "stop_place_alternative_names" */
  readonly stops_database_update_stop_place_alternative_names?: Maybe<StopsDatabaseStopPlaceAlternativeNamesMutationResponse>;
  /** update multiples rows of table: "stop_place_alternative_names" */
  readonly stops_database_update_stop_place_alternative_names_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseStopPlaceAlternativeNamesMutationResponse>>>;
  /** update single row of the table: "stop_place" */
  readonly stops_database_update_stop_place_by_pk?: Maybe<StopsDatabaseStopPlace>;
  /** update data of the table: "stop_place_children" */
  readonly stops_database_update_stop_place_children?: Maybe<StopsDatabaseStopPlaceChildrenMutationResponse>;
  /** update single row of the table: "stop_place_children" */
  readonly stops_database_update_stop_place_children_by_pk?: Maybe<StopsDatabaseStopPlaceChildren>;
  /** update multiples rows of table: "stop_place_children" */
  readonly stops_database_update_stop_place_children_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseStopPlaceChildrenMutationResponse>>>;
  /** update data of the table: "stop_place_equipment_places" */
  readonly stops_database_update_stop_place_equipment_places?: Maybe<StopsDatabaseStopPlaceEquipmentPlacesMutationResponse>;
  /** update multiples rows of table: "stop_place_equipment_places" */
  readonly stops_database_update_stop_place_equipment_places_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseStopPlaceEquipmentPlacesMutationResponse>>>;
  /** update data of the table: "stop_place_key_values" */
  readonly stops_database_update_stop_place_key_values?: Maybe<StopsDatabaseStopPlaceKeyValuesMutationResponse>;
  /** update single row of the table: "stop_place_key_values" */
  readonly stops_database_update_stop_place_key_values_by_pk?: Maybe<StopsDatabaseStopPlaceKeyValues>;
  /** update multiples rows of table: "stop_place_key_values" */
  readonly stops_database_update_stop_place_key_values_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseStopPlaceKeyValuesMutationResponse>>>;
  /** update multiples rows of table: "stop_place" */
  readonly stops_database_update_stop_place_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseStopPlaceMutationResponse>>>;
  /** update data of the table: "stop_place_organisations" */
  readonly stops_database_update_stop_place_organisations?: Maybe<StopsDatabaseStopPlaceOrganisationsMutationResponse>;
  /** update single row of the table: "stop_place_organisations" */
  readonly stops_database_update_stop_place_organisations_by_pk?: Maybe<StopsDatabaseStopPlaceOrganisations>;
  /** update multiples rows of table: "stop_place_organisations" */
  readonly stops_database_update_stop_place_organisations_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseStopPlaceOrganisationsMutationResponse>>>;
  /** update data of the table: "stop_place_quays" */
  readonly stops_database_update_stop_place_quays?: Maybe<StopsDatabaseStopPlaceQuaysMutationResponse>;
  /** update single row of the table: "stop_place_quays" */
  readonly stops_database_update_stop_place_quays_by_pk?: Maybe<StopsDatabaseStopPlaceQuays>;
  /** update multiples rows of table: "stop_place_quays" */
  readonly stops_database_update_stop_place_quays_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseStopPlaceQuaysMutationResponse>>>;
  /** update data of the table: "stop_place_tariff_zones" */
  readonly stops_database_update_stop_place_tariff_zones?: Maybe<StopsDatabaseStopPlaceTariffZonesMutationResponse>;
  /** update multiples rows of table: "stop_place_tariff_zones" */
  readonly stops_database_update_stop_place_tariff_zones_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseStopPlaceTariffZonesMutationResponse>>>;
  /** update data of the table: "tag" */
  readonly stops_database_update_tag?: Maybe<StopsDatabaseTagMutationResponse>;
  /** update single row of the table: "tag" */
  readonly stops_database_update_tag_by_pk?: Maybe<StopsDatabaseTag>;
  /** update multiples rows of table: "tag" */
  readonly stops_database_update_tag_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseTagMutationResponse>>>;
  /** update data of the table: "tariff_zone" */
  readonly stops_database_update_tariff_zone?: Maybe<StopsDatabaseTariffZoneMutationResponse>;
  /** update single row of the table: "tariff_zone" */
  readonly stops_database_update_tariff_zone_by_pk?: Maybe<StopsDatabaseTariffZone>;
  /** update data of the table: "tariff_zone_key_values" */
  readonly stops_database_update_tariff_zone_key_values?: Maybe<StopsDatabaseTariffZoneKeyValuesMutationResponse>;
  /** update single row of the table: "tariff_zone_key_values" */
  readonly stops_database_update_tariff_zone_key_values_by_pk?: Maybe<StopsDatabaseTariffZoneKeyValues>;
  /** update multiples rows of table: "tariff_zone_key_values" */
  readonly stops_database_update_tariff_zone_key_values_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseTariffZoneKeyValuesMutationResponse>>>;
  /** update multiples rows of table: "tariff_zone" */
  readonly stops_database_update_tariff_zone_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseTariffZoneMutationResponse>>>;
  /** update data of the table: "topographic_place" */
  readonly stops_database_update_topographic_place?: Maybe<StopsDatabaseTopographicPlaceMutationResponse>;
  /** update single row of the table: "topographic_place" */
  readonly stops_database_update_topographic_place_by_pk?: Maybe<StopsDatabaseTopographicPlace>;
  /** update data of the table: "topographic_place_key_values" */
  readonly stops_database_update_topographic_place_key_values?: Maybe<StopsDatabaseTopographicPlaceKeyValuesMutationResponse>;
  /** update single row of the table: "topographic_place_key_values" */
  readonly stops_database_update_topographic_place_key_values_by_pk?: Maybe<StopsDatabaseTopographicPlaceKeyValues>;
  /** update multiples rows of table: "topographic_place_key_values" */
  readonly stops_database_update_topographic_place_key_values_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseTopographicPlaceKeyValuesMutationResponse>>>;
  /** update multiples rows of table: "topographic_place" */
  readonly stops_database_update_topographic_place_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseTopographicPlaceMutationResponse>>>;
  /** update data of the table: "value" */
  readonly stops_database_update_value?: Maybe<StopsDatabaseValueMutationResponse>;
  /** update single row of the table: "value" */
  readonly stops_database_update_value_by_pk?: Maybe<StopsDatabaseValue>;
  /** update data of the table: "value_items" */
  readonly stops_database_update_value_items?: Maybe<StopsDatabaseValueItemsMutationResponse>;
  /** update multiples rows of table: "value_items" */
  readonly stops_database_update_value_items_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseValueItemsMutationResponse>>>;
  /** update multiples rows of table: "value" */
  readonly stops_database_update_value_many?: Maybe<ReadonlyArray<Maybe<StopsDatabaseValueMutationResponse>>>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAccessSpaceArgs = {
  where: StopsDatabaseAccessSpaceBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAccessSpaceAlternativeNamesArgs = {
  where: StopsDatabaseAccessSpaceAlternativeNamesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAccessSpaceByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAccessSpaceCheckConstraintsArgs = {
  where: StopsDatabaseAccessSpaceCheckConstraintsBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAccessSpaceEquipmentPlacesArgs = {
  where: StopsDatabaseAccessSpaceEquipmentPlacesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAccessSpaceKeyValuesArgs = {
  where: StopsDatabaseAccessSpaceKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAccessSpaceKeyValuesByPkArgs = {
  access_space_id: Scalars['bigint']['input'];
  key_values_key: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAccessibilityAssessmentArgs = {
  where: StopsDatabaseAccessibilityAssessmentBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAccessibilityAssessmentByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAccessibilityAssessmentLimitationsArgs = {
  where: StopsDatabaseAccessibilityAssessmentLimitationsBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAccessibilityLimitationArgs = {
  where: StopsDatabaseAccessibilityLimitationBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAccessibilityLimitationByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAlternativeNameArgs = {
  where: StopsDatabaseAlternativeNameBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteAlternativeNameByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteBoardingPositionArgs = {
  where: StopsDatabaseBoardingPositionBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteBoardingPositionAlternativeNamesArgs = {
  where: StopsDatabaseBoardingPositionAlternativeNamesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteBoardingPositionByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteBoardingPositionCheckConstraintsArgs = {
  where: StopsDatabaseBoardingPositionCheckConstraintsBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteBoardingPositionEquipmentPlacesArgs = {
  where: StopsDatabaseBoardingPositionEquipmentPlacesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteBoardingPositionKeyValuesArgs = {
  where: StopsDatabaseBoardingPositionKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteBoardingPositionKeyValuesByPkArgs = {
  boarding_position_id: Scalars['bigint']['input'];
  key_values_key: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteCheckConstraintArgs = {
  where: StopsDatabaseCheckConstraintBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteCheckConstraintByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteCheckConstraintKeyValuesArgs = {
  where: StopsDatabaseCheckConstraintKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteCheckConstraintKeyValuesByPkArgs = {
  check_constraint_id: Scalars['bigint']['input'];
  key_values_key: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteContactArgs = {
  where: StopsDatabaseContactBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteContactByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteDestinationDisplayViewArgs = {
  where: StopsDatabaseDestinationDisplayViewBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteDestinationDisplayViewByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteEquipmentPlaceArgs = {
  where: StopsDatabaseEquipmentPlaceBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteEquipmentPlaceByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteEquipmentPlaceEquipmentPositionsArgs = {
  where: StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteEquipmentPlaceKeyValuesArgs = {
  where: StopsDatabaseEquipmentPlaceKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteEquipmentPlaceKeyValuesByPkArgs = {
  equipment_place_id: Scalars['bigint']['input'];
  key_values_key: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteEquipmentPositionArgs = {
  where: StopsDatabaseEquipmentPositionBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteEquipmentPositionByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteEquipmentPositionKeyValuesArgs = {
  where: StopsDatabaseEquipmentPositionKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteEquipmentPositionKeyValuesByPkArgs = {
  equipment_position_id: Scalars['bigint']['input'];
  key_values_key: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteExportJobArgs = {
  where: StopsDatabaseExportJobBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteExportJobByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteFareZoneArgs = {
  where: StopsDatabaseFareZoneBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteFareZoneByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteFareZoneKeyValuesArgs = {
  where: StopsDatabaseFareZoneKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteFareZoneKeyValuesByPkArgs = {
  fare_zone_id: Scalars['bigint']['input'];
  key_values_key: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteFareZoneMembersArgs = {
  where: StopsDatabaseFareZoneMembersBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteFareZoneNeighboursArgs = {
  where: StopsDatabaseFareZoneNeighboursBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGeometryColumnsArgs = {
  where: StopsDatabaseGeometryColumnsBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGroupOfStopPlacesArgs = {
  where: StopsDatabaseGroupOfStopPlacesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGroupOfStopPlacesAlternativeNamesArgs = {
  where: StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGroupOfStopPlacesByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGroupOfStopPlacesKeyValuesArgs = {
  where: StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGroupOfStopPlacesKeyValuesByPkArgs = {
  group_of_stop_places_id: Scalars['bigint']['input'];
  key_values_key: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGroupOfStopPlacesMembersArgs = {
  where: StopsDatabaseGroupOfStopPlacesMembersBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGroupOfTariffZonesArgs = {
  where: StopsDatabaseGroupOfTariffZonesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGroupOfTariffZonesByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGroupOfTariffZonesKeyValuesArgs = {
  where: StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGroupOfTariffZonesKeyValuesByPkArgs = {
  group_of_tariff_zones_id: Scalars['bigint']['input'];
  key_values_key: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGroupOfTariffZonesMembersArgs = {
  where: StopsDatabaseGroupOfTariffZonesMembersBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteGroupOfTariffZonesMembersByPkArgs = {
  group_of_tariff_zones_id: Scalars['bigint']['input'];
  ref: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteHslAccessibilityPropertiesArgs = {
  where: StopsDatabaseHslAccessibilityPropertiesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteHslAccessibilityPropertiesByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteIdGeneratorArgs = {
  where: StopsDatabaseIdGeneratorBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteInfoSpotArgs = {
  where: StopsDatabaseInfoSpotBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteInfoSpotByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteInfoSpotPosterArgs = {
  where: StopsDatabaseInfoSpotPosterBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteInfoSpotPosterByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteInstalledEquipmentArgs = {
  where: StopsDatabaseInstalledEquipmentBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteInstalledEquipmentVersionStructureArgs = {
  where: StopsDatabaseInstalledEquipmentVersionStructureBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteInstalledEquipmentVersionStructureByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteInstalledEquipmentVersionStructureInstalledEquipmentArgs = {
  where: StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteLevelArgs = {
  where: StopsDatabaseLevelBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteLevelByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteLevelKeyValuesArgs = {
  where: StopsDatabaseLevelKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteLevelKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  level_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteMultilingualStringEntityArgs = {
  where: StopsDatabaseMultilingualStringEntityBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteMultilingualStringEntityByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteNavigationPathArgs = {
  where: StopsDatabaseNavigationPathBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteOrganisationArgs = {
  where: StopsDatabaseOrganisationBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteOrganisationByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteOrganisationKeyValuesArgs = {
  where: StopsDatabaseOrganisationKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteOrganisationKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  organisation_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingArgs = {
  where: StopsDatabaseParkingBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingAdjacentSitesArgs = {
  where: StopsDatabaseParkingAdjacentSitesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingAlternativeNamesArgs = {
  where: StopsDatabaseParkingAlternativeNamesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingAreaArgs = {
  where: StopsDatabaseParkingAreaBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingAreaAlternativeNamesArgs = {
  where: StopsDatabaseParkingAreaAlternativeNamesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingAreaByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingAreaCheckConstraintsArgs = {
  where: StopsDatabaseParkingAreaCheckConstraintsBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingAreaEquipmentPlacesArgs = {
  where: StopsDatabaseParkingAreaEquipmentPlacesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingAreaKeyValuesArgs = {
  where: StopsDatabaseParkingAreaKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingAreaKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  parking_area_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingCapacityArgs = {
  where: StopsDatabaseParkingCapacityBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingCapacityByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingEquipmentPlacesArgs = {
  where: StopsDatabaseParkingEquipmentPlacesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingKeyValuesArgs = {
  where: StopsDatabaseParkingKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  parking_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingParkingAreasArgs = {
  where: StopsDatabaseParkingParkingAreasBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingParkingPaymentProcessArgs = {
  where: StopsDatabaseParkingParkingPaymentProcessBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingParkingPropertiesArgs = {
  where: StopsDatabaseParkingParkingPropertiesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingParkingVehicleTypesArgs = {
  where: StopsDatabaseParkingParkingVehicleTypesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingPropertiesArgs = {
  where: StopsDatabaseParkingPropertiesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingPropertiesByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingPropertiesParkingUserTypesArgs = {
  where: StopsDatabaseParkingPropertiesParkingUserTypesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteParkingPropertiesSpacesArgs = {
  where: StopsDatabaseParkingPropertiesSpacesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePathJunctionArgs = {
  where: StopsDatabasePathJunctionBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePathJunctionByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePathJunctionKeyValuesArgs = {
  where: StopsDatabasePathJunctionKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePathJunctionKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  path_junction_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePathLinkArgs = {
  where: StopsDatabasePathLinkBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePathLinkByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePathLinkEndArgs = {
  where: StopsDatabasePathLinkEndBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePathLinkEndByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePathLinkKeyValuesArgs = {
  where: StopsDatabasePathLinkKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePathLinkKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  path_link_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePersistablePolygonArgs = {
  where: StopsDatabasePersistablePolygonBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePersistablePolygonByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePurposeOfGroupingArgs = {
  where: StopsDatabasePurposeOfGroupingBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePurposeOfGroupingByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePurposeOfGroupingKeyValuesArgs = {
  where: StopsDatabasePurposeOfGroupingKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeletePurposeOfGroupingKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  purpose_of_grouping_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteQuayArgs = {
  where: StopsDatabaseQuayBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteQuayAlternativeNamesArgs = {
  where: StopsDatabaseQuayAlternativeNamesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteQuayBoardingPositionsArgs = {
  where: StopsDatabaseQuayBoardingPositionsBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteQuayByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteQuayCheckConstraintsArgs = {
  where: StopsDatabaseQuayCheckConstraintsBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteQuayEquipmentPlacesArgs = {
  where: StopsDatabaseQuayEquipmentPlacesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteQuayKeyValuesArgs = {
  where: StopsDatabaseQuayKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteQuayKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  quay_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteSchemaVersionArgs = {
  where: StopsDatabaseSchemaVersionBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteSchemaVersionByPkArgs = {
  installed_rank: Scalars['Int']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteSpatialRefSysArgs = {
  where: StopsDatabaseSpatialRefSysBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteSpatialRefSysByPkArgs = {
  srid: Scalars['Int']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceArgs = {
  where: StopsDatabaseStopPlaceBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceAccessSpacesArgs = {
  where: StopsDatabaseStopPlaceAccessSpacesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceAdjacentSitesArgs = {
  where: StopsDatabaseStopPlaceAdjacentSitesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceAlternativeNamesArgs = {
  where: StopsDatabaseStopPlaceAlternativeNamesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceChildrenArgs = {
  where: StopsDatabaseStopPlaceChildrenBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceChildrenByPkArgs = {
  children_id: Scalars['bigint']['input'];
  stop_place_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceEquipmentPlacesArgs = {
  where: StopsDatabaseStopPlaceEquipmentPlacesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceKeyValuesArgs = {
  where: StopsDatabaseStopPlaceKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  stop_place_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceOrganisationsArgs = {
  where: StopsDatabaseStopPlaceOrganisationsBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceOrganisationsByPkArgs = {
  organisation_ref: Scalars['String']['input'];
  relationship_type: Scalars['String']['input'];
  stop_place_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceQuaysArgs = {
  where: StopsDatabaseStopPlaceQuaysBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceQuaysByPkArgs = {
  quays_id: Scalars['bigint']['input'];
  stop_place_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteStopPlaceTariffZonesArgs = {
  where: StopsDatabaseStopPlaceTariffZonesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteTagArgs = {
  where: StopsDatabaseTagBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteTagByPkArgs = {
  name: Scalars['String']['input'];
  netex_reference: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteTariffZoneArgs = {
  where: StopsDatabaseTariffZoneBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteTariffZoneByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteTariffZoneKeyValuesArgs = {
  where: StopsDatabaseTariffZoneKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteTariffZoneKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  tariff_zone_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteTopographicPlaceArgs = {
  where: StopsDatabaseTopographicPlaceBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteTopographicPlaceByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteTopographicPlaceKeyValuesArgs = {
  where: StopsDatabaseTopographicPlaceKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteTopographicPlaceKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  topographic_place_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteValueArgs = {
  where: StopsDatabaseValueBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteValueByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseDeleteValueItemsArgs = {
  where: StopsDatabaseValueItemsBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessSpaceArgs = {
  objects: ReadonlyArray<StopsDatabaseAccessSpaceInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseAccessSpaceOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessSpaceAlternativeNamesArgs = {
  objects: ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNamesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessSpaceAlternativeNamesOneArgs = {
  object: StopsDatabaseAccessSpaceAlternativeNamesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessSpaceCheckConstraintsArgs = {
  objects: ReadonlyArray<StopsDatabaseAccessSpaceCheckConstraintsInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessSpaceCheckConstraintsOneArgs = {
  object: StopsDatabaseAccessSpaceCheckConstraintsInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessSpaceEquipmentPlacesArgs = {
  objects: ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlacesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessSpaceEquipmentPlacesOneArgs = {
  object: StopsDatabaseAccessSpaceEquipmentPlacesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessSpaceKeyValuesArgs = {
  objects: ReadonlyArray<StopsDatabaseAccessSpaceKeyValuesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessSpaceKeyValuesOneArgs = {
  object: StopsDatabaseAccessSpaceKeyValuesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessSpaceOneArgs = {
  object: StopsDatabaseAccessSpaceInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseAccessSpaceOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessibilityAssessmentArgs = {
  objects: ReadonlyArray<StopsDatabaseAccessibilityAssessmentInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseAccessibilityAssessmentOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessibilityAssessmentLimitationsArgs = {
  objects: ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitationsInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessibilityAssessmentLimitationsOneArgs = {
  object: StopsDatabaseAccessibilityAssessmentLimitationsInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessibilityAssessmentOneArgs = {
  object: StopsDatabaseAccessibilityAssessmentInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseAccessibilityAssessmentOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessibilityLimitationArgs = {
  objects: ReadonlyArray<StopsDatabaseAccessibilityLimitationInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseAccessibilityLimitationOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAccessibilityLimitationOneArgs = {
  object: StopsDatabaseAccessibilityLimitationInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseAccessibilityLimitationOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAlternativeNameArgs = {
  objects: ReadonlyArray<StopsDatabaseAlternativeNameInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseAlternativeNameOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertAlternativeNameOneArgs = {
  object: StopsDatabaseAlternativeNameInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseAlternativeNameOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertBoardingPositionArgs = {
  objects: ReadonlyArray<StopsDatabaseBoardingPositionInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseBoardingPositionOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertBoardingPositionAlternativeNamesArgs = {
  objects: ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNamesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertBoardingPositionAlternativeNamesOneArgs = {
  object: StopsDatabaseBoardingPositionAlternativeNamesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertBoardingPositionCheckConstraintsArgs = {
  objects: ReadonlyArray<StopsDatabaseBoardingPositionCheckConstraintsInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertBoardingPositionCheckConstraintsOneArgs = {
  object: StopsDatabaseBoardingPositionCheckConstraintsInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertBoardingPositionEquipmentPlacesArgs = {
  objects: ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlacesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertBoardingPositionEquipmentPlacesOneArgs = {
  object: StopsDatabaseBoardingPositionEquipmentPlacesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertBoardingPositionKeyValuesArgs = {
  objects: ReadonlyArray<StopsDatabaseBoardingPositionKeyValuesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertBoardingPositionKeyValuesOneArgs = {
  object: StopsDatabaseBoardingPositionKeyValuesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertBoardingPositionOneArgs = {
  object: StopsDatabaseBoardingPositionInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseBoardingPositionOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertCheckConstraintArgs = {
  objects: ReadonlyArray<StopsDatabaseCheckConstraintInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseCheckConstraintOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertCheckConstraintKeyValuesArgs = {
  objects: ReadonlyArray<StopsDatabaseCheckConstraintKeyValuesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertCheckConstraintKeyValuesOneArgs = {
  object: StopsDatabaseCheckConstraintKeyValuesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertCheckConstraintOneArgs = {
  object: StopsDatabaseCheckConstraintInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseCheckConstraintOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertContactArgs = {
  objects: ReadonlyArray<StopsDatabaseContactInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseContactOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertContactOneArgs = {
  object: StopsDatabaseContactInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseContactOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertDestinationDisplayViewArgs = {
  objects: ReadonlyArray<StopsDatabaseDestinationDisplayViewInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseDestinationDisplayViewOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertDestinationDisplayViewOneArgs = {
  object: StopsDatabaseDestinationDisplayViewInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseDestinationDisplayViewOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertEquipmentPlaceArgs = {
  objects: ReadonlyArray<StopsDatabaseEquipmentPlaceInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseEquipmentPlaceOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertEquipmentPlaceEquipmentPositionsArgs = {
  objects: ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositionsInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertEquipmentPlaceEquipmentPositionsOneArgs = {
  object: StopsDatabaseEquipmentPlaceEquipmentPositionsInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertEquipmentPlaceKeyValuesArgs = {
  objects: ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValuesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertEquipmentPlaceKeyValuesOneArgs = {
  object: StopsDatabaseEquipmentPlaceKeyValuesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertEquipmentPlaceOneArgs = {
  object: StopsDatabaseEquipmentPlaceInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseEquipmentPlaceOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertEquipmentPositionArgs = {
  objects: ReadonlyArray<StopsDatabaseEquipmentPositionInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseEquipmentPositionOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertEquipmentPositionKeyValuesArgs = {
  objects: ReadonlyArray<StopsDatabaseEquipmentPositionKeyValuesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertEquipmentPositionKeyValuesOneArgs = {
  object: StopsDatabaseEquipmentPositionKeyValuesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertEquipmentPositionOneArgs = {
  object: StopsDatabaseEquipmentPositionInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseEquipmentPositionOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertExportJobArgs = {
  objects: ReadonlyArray<StopsDatabaseExportJobInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseExportJobOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertExportJobOneArgs = {
  object: StopsDatabaseExportJobInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseExportJobOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertFareZoneArgs = {
  objects: ReadonlyArray<StopsDatabaseFareZoneInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseFareZoneOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertFareZoneKeyValuesArgs = {
  objects: ReadonlyArray<StopsDatabaseFareZoneKeyValuesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseFareZoneKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertFareZoneKeyValuesOneArgs = {
  object: StopsDatabaseFareZoneKeyValuesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseFareZoneKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertFareZoneMembersArgs = {
  objects: ReadonlyArray<StopsDatabaseFareZoneMembersInsertInput>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertFareZoneMembersOneArgs = {
  object: StopsDatabaseFareZoneMembersInsertInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertFareZoneNeighboursArgs = {
  objects: ReadonlyArray<StopsDatabaseFareZoneNeighboursInsertInput>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertFareZoneNeighboursOneArgs = {
  object: StopsDatabaseFareZoneNeighboursInsertInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertFareZoneOneArgs = {
  object: StopsDatabaseFareZoneInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseFareZoneOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGeometryColumnsArgs = {
  objects: ReadonlyArray<StopsDatabaseGeometryColumnsInsertInput>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGeometryColumnsOneArgs = {
  object: StopsDatabaseGeometryColumnsInsertInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfStopPlacesArgs = {
  objects: ReadonlyArray<StopsDatabaseGroupOfStopPlacesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseGroupOfStopPlacesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfStopPlacesAlternativeNamesArgs = {
  objects: ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNamesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfStopPlacesAlternativeNamesOneArgs = {
  object: StopsDatabaseGroupOfStopPlacesAlternativeNamesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfStopPlacesKeyValuesArgs = {
  objects: ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValuesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfStopPlacesKeyValuesOneArgs = {
  object: StopsDatabaseGroupOfStopPlacesKeyValuesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfStopPlacesMembersArgs = {
  objects: ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembersInsertInput>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfStopPlacesMembersOneArgs = {
  object: StopsDatabaseGroupOfStopPlacesMembersInsertInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfStopPlacesOneArgs = {
  object: StopsDatabaseGroupOfStopPlacesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseGroupOfStopPlacesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfTariffZonesArgs = {
  objects: ReadonlyArray<StopsDatabaseGroupOfTariffZonesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseGroupOfTariffZonesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfTariffZonesKeyValuesArgs = {
  objects: ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValuesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfTariffZonesKeyValuesOneArgs = {
  object: StopsDatabaseGroupOfTariffZonesKeyValuesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfTariffZonesMembersArgs = {
  objects: ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembersInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfTariffZonesMembersOneArgs = {
  object: StopsDatabaseGroupOfTariffZonesMembersInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertGroupOfTariffZonesOneArgs = {
  object: StopsDatabaseGroupOfTariffZonesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseGroupOfTariffZonesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertHslAccessibilityPropertiesArgs = {
  objects: ReadonlyArray<StopsDatabaseHslAccessibilityPropertiesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseHslAccessibilityPropertiesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertHslAccessibilityPropertiesOneArgs = {
  object: StopsDatabaseHslAccessibilityPropertiesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseHslAccessibilityPropertiesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertIdGeneratorArgs = {
  objects: ReadonlyArray<StopsDatabaseIdGeneratorInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseIdGeneratorOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertIdGeneratorOneArgs = {
  object: StopsDatabaseIdGeneratorInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseIdGeneratorOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertInfoSpotArgs = {
  objects: ReadonlyArray<StopsDatabaseInfoSpotInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseInfoSpotOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertInfoSpotOneArgs = {
  object: StopsDatabaseInfoSpotInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseInfoSpotOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertInfoSpotPosterArgs = {
  objects: ReadonlyArray<StopsDatabaseInfoSpotPosterInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseInfoSpotPosterOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertInfoSpotPosterOneArgs = {
  object: StopsDatabaseInfoSpotPosterInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseInfoSpotPosterOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertInstalledEquipmentArgs = {
  objects: ReadonlyArray<StopsDatabaseInstalledEquipmentInsertInput>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertInstalledEquipmentOneArgs = {
  object: StopsDatabaseInstalledEquipmentInsertInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertInstalledEquipmentVersionStructureArgs = {
  objects: ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertInstalledEquipmentVersionStructureInstalledEquipmentArgs = {
  objects: ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertInstalledEquipmentVersionStructureInstalledEquipmentOneArgs = {
  object: StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertInstalledEquipmentVersionStructureOneArgs = {
  object: StopsDatabaseInstalledEquipmentVersionStructureInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertLevelArgs = {
  objects: ReadonlyArray<StopsDatabaseLevelInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseLevelOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertLevelKeyValuesArgs = {
  objects: ReadonlyArray<StopsDatabaseLevelKeyValuesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseLevelKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertLevelKeyValuesOneArgs = {
  object: StopsDatabaseLevelKeyValuesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseLevelKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertLevelOneArgs = {
  object: StopsDatabaseLevelInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseLevelOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertMultilingualStringEntityArgs = {
  objects: ReadonlyArray<StopsDatabaseMultilingualStringEntityInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseMultilingualStringEntityOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertMultilingualStringEntityOneArgs = {
  object: StopsDatabaseMultilingualStringEntityInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseMultilingualStringEntityOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertNavigationPathArgs = {
  objects: ReadonlyArray<StopsDatabaseNavigationPathInsertInput>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertNavigationPathOneArgs = {
  object: StopsDatabaseNavigationPathInsertInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertOrganisationArgs = {
  objects: ReadonlyArray<StopsDatabaseOrganisationInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseOrganisationOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertOrganisationKeyValuesArgs = {
  objects: ReadonlyArray<StopsDatabaseOrganisationKeyValuesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseOrganisationKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertOrganisationKeyValuesOneArgs = {
  object: StopsDatabaseOrganisationKeyValuesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseOrganisationKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertOrganisationOneArgs = {
  object: StopsDatabaseOrganisationInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseOrganisationOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingArgs = {
  objects: ReadonlyArray<StopsDatabaseParkingInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseParkingOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAdjacentSitesArgs = {
  objects: ReadonlyArray<StopsDatabaseParkingAdjacentSitesInsertInput>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAdjacentSitesOneArgs = {
  object: StopsDatabaseParkingAdjacentSitesInsertInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAlternativeNamesArgs = {
  objects: ReadonlyArray<StopsDatabaseParkingAlternativeNamesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseParkingAlternativeNamesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAlternativeNamesOneArgs = {
  object: StopsDatabaseParkingAlternativeNamesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseParkingAlternativeNamesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAreaArgs = {
  objects: ReadonlyArray<StopsDatabaseParkingAreaInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseParkingAreaOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAreaAlternativeNamesArgs = {
  objects: ReadonlyArray<StopsDatabaseParkingAreaAlternativeNamesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAreaAlternativeNamesOneArgs = {
  object: StopsDatabaseParkingAreaAlternativeNamesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAreaCheckConstraintsArgs = {
  objects: ReadonlyArray<StopsDatabaseParkingAreaCheckConstraintsInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAreaCheckConstraintsOneArgs = {
  object: StopsDatabaseParkingAreaCheckConstraintsInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAreaEquipmentPlacesArgs = {
  objects: ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlacesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAreaEquipmentPlacesOneArgs = {
  object: StopsDatabaseParkingAreaEquipmentPlacesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAreaKeyValuesArgs = {
  objects: ReadonlyArray<StopsDatabaseParkingAreaKeyValuesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseParkingAreaKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAreaKeyValuesOneArgs = {
  object: StopsDatabaseParkingAreaKeyValuesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseParkingAreaKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingAreaOneArgs = {
  object: StopsDatabaseParkingAreaInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseParkingAreaOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingCapacityArgs = {
  objects: ReadonlyArray<StopsDatabaseParkingCapacityInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseParkingCapacityOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingCapacityOneArgs = {
  object: StopsDatabaseParkingCapacityInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseParkingCapacityOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingEquipmentPlacesArgs = {
  objects: ReadonlyArray<StopsDatabaseParkingEquipmentPlacesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseParkingEquipmentPlacesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingEquipmentPlacesOneArgs = {
  object: StopsDatabaseParkingEquipmentPlacesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseParkingEquipmentPlacesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingKeyValuesArgs = {
  objects: ReadonlyArray<StopsDatabaseParkingKeyValuesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseParkingKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingKeyValuesOneArgs = {
  object: StopsDatabaseParkingKeyValuesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseParkingKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingOneArgs = {
  object: StopsDatabaseParkingInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseParkingOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingParkingAreasArgs = {
  objects: ReadonlyArray<StopsDatabaseParkingParkingAreasInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseParkingParkingAreasOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingParkingAreasOneArgs = {
  object: StopsDatabaseParkingParkingAreasInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseParkingParkingAreasOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingParkingPaymentProcessArgs = {
  objects: ReadonlyArray<StopsDatabaseParkingParkingPaymentProcessInsertInput>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingParkingPaymentProcessOneArgs = {
  object: StopsDatabaseParkingParkingPaymentProcessInsertInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingParkingPropertiesArgs = {
  objects: ReadonlyArray<StopsDatabaseParkingParkingPropertiesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseParkingParkingPropertiesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingParkingPropertiesOneArgs = {
  object: StopsDatabaseParkingParkingPropertiesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseParkingParkingPropertiesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingParkingVehicleTypesArgs = {
  objects: ReadonlyArray<StopsDatabaseParkingParkingVehicleTypesInsertInput>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingParkingVehicleTypesOneArgs = {
  object: StopsDatabaseParkingParkingVehicleTypesInsertInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingPropertiesArgs = {
  objects: ReadonlyArray<StopsDatabaseParkingPropertiesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseParkingPropertiesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingPropertiesOneArgs = {
  object: StopsDatabaseParkingPropertiesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseParkingPropertiesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingPropertiesParkingUserTypesArgs = {
  objects: ReadonlyArray<StopsDatabaseParkingPropertiesParkingUserTypesInsertInput>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingPropertiesParkingUserTypesOneArgs = {
  object: StopsDatabaseParkingPropertiesParkingUserTypesInsertInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingPropertiesSpacesArgs = {
  objects: ReadonlyArray<StopsDatabaseParkingPropertiesSpacesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseParkingPropertiesSpacesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertParkingPropertiesSpacesOneArgs = {
  object: StopsDatabaseParkingPropertiesSpacesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseParkingPropertiesSpacesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPathJunctionArgs = {
  objects: ReadonlyArray<StopsDatabasePathJunctionInsertInput>;
  on_conflict?: InputMaybe<StopsDatabasePathJunctionOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPathJunctionKeyValuesArgs = {
  objects: ReadonlyArray<StopsDatabasePathJunctionKeyValuesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabasePathJunctionKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPathJunctionKeyValuesOneArgs = {
  object: StopsDatabasePathJunctionKeyValuesInsertInput;
  on_conflict?: InputMaybe<StopsDatabasePathJunctionKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPathJunctionOneArgs = {
  object: StopsDatabasePathJunctionInsertInput;
  on_conflict?: InputMaybe<StopsDatabasePathJunctionOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPathLinkArgs = {
  objects: ReadonlyArray<StopsDatabasePathLinkInsertInput>;
  on_conflict?: InputMaybe<StopsDatabasePathLinkOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPathLinkEndArgs = {
  objects: ReadonlyArray<StopsDatabasePathLinkEndInsertInput>;
  on_conflict?: InputMaybe<StopsDatabasePathLinkEndOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPathLinkEndOneArgs = {
  object: StopsDatabasePathLinkEndInsertInput;
  on_conflict?: InputMaybe<StopsDatabasePathLinkEndOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPathLinkKeyValuesArgs = {
  objects: ReadonlyArray<StopsDatabasePathLinkKeyValuesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabasePathLinkKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPathLinkKeyValuesOneArgs = {
  object: StopsDatabasePathLinkKeyValuesInsertInput;
  on_conflict?: InputMaybe<StopsDatabasePathLinkKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPathLinkOneArgs = {
  object: StopsDatabasePathLinkInsertInput;
  on_conflict?: InputMaybe<StopsDatabasePathLinkOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPersistablePolygonArgs = {
  objects: ReadonlyArray<StopsDatabasePersistablePolygonInsertInput>;
  on_conflict?: InputMaybe<StopsDatabasePersistablePolygonOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPersistablePolygonOneArgs = {
  object: StopsDatabasePersistablePolygonInsertInput;
  on_conflict?: InputMaybe<StopsDatabasePersistablePolygonOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPurposeOfGroupingArgs = {
  objects: ReadonlyArray<StopsDatabasePurposeOfGroupingInsertInput>;
  on_conflict?: InputMaybe<StopsDatabasePurposeOfGroupingOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPurposeOfGroupingKeyValuesArgs = {
  objects: ReadonlyArray<StopsDatabasePurposeOfGroupingKeyValuesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPurposeOfGroupingKeyValuesOneArgs = {
  object: StopsDatabasePurposeOfGroupingKeyValuesInsertInput;
  on_conflict?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertPurposeOfGroupingOneArgs = {
  object: StopsDatabasePurposeOfGroupingInsertInput;
  on_conflict?: InputMaybe<StopsDatabasePurposeOfGroupingOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertQuayArgs = {
  objects: ReadonlyArray<StopsDatabaseQuayInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseQuayOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertQuayAlternativeNamesArgs = {
  objects: ReadonlyArray<StopsDatabaseQuayAlternativeNamesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseQuayAlternativeNamesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertQuayAlternativeNamesOneArgs = {
  object: StopsDatabaseQuayAlternativeNamesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseQuayAlternativeNamesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertQuayBoardingPositionsArgs = {
  objects: ReadonlyArray<StopsDatabaseQuayBoardingPositionsInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseQuayBoardingPositionsOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertQuayBoardingPositionsOneArgs = {
  object: StopsDatabaseQuayBoardingPositionsInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseQuayBoardingPositionsOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertQuayCheckConstraintsArgs = {
  objects: ReadonlyArray<StopsDatabaseQuayCheckConstraintsInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseQuayCheckConstraintsOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertQuayCheckConstraintsOneArgs = {
  object: StopsDatabaseQuayCheckConstraintsInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseQuayCheckConstraintsOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertQuayEquipmentPlacesArgs = {
  objects: ReadonlyArray<StopsDatabaseQuayEquipmentPlacesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseQuayEquipmentPlacesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertQuayEquipmentPlacesOneArgs = {
  object: StopsDatabaseQuayEquipmentPlacesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseQuayEquipmentPlacesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertQuayKeyValuesArgs = {
  objects: ReadonlyArray<StopsDatabaseQuayKeyValuesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseQuayKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertQuayKeyValuesOneArgs = {
  object: StopsDatabaseQuayKeyValuesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseQuayKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertQuayOneArgs = {
  object: StopsDatabaseQuayInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseQuayOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertSchemaVersionArgs = {
  objects: ReadonlyArray<StopsDatabaseSchemaVersionInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseSchemaVersionOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertSchemaVersionOneArgs = {
  object: StopsDatabaseSchemaVersionInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseSchemaVersionOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertSpatialRefSysArgs = {
  objects: ReadonlyArray<StopsDatabaseSpatialRefSysInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseSpatialRefSysOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertSpatialRefSysOneArgs = {
  object: StopsDatabaseSpatialRefSysInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseSpatialRefSysOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceArgs = {
  objects: ReadonlyArray<StopsDatabaseStopPlaceInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseStopPlaceOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceAccessSpacesArgs = {
  objects: ReadonlyArray<StopsDatabaseStopPlaceAccessSpacesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceAccessSpacesOneArgs = {
  object: StopsDatabaseStopPlaceAccessSpacesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceAdjacentSitesArgs = {
  objects: ReadonlyArray<StopsDatabaseStopPlaceAdjacentSitesInsertInput>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceAdjacentSitesOneArgs = {
  object: StopsDatabaseStopPlaceAdjacentSitesInsertInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceAlternativeNamesArgs = {
  objects: ReadonlyArray<StopsDatabaseStopPlaceAlternativeNamesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceAlternativeNamesOneArgs = {
  object: StopsDatabaseStopPlaceAlternativeNamesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceChildrenArgs = {
  objects: ReadonlyArray<StopsDatabaseStopPlaceChildrenInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseStopPlaceChildrenOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceChildrenOneArgs = {
  object: StopsDatabaseStopPlaceChildrenInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseStopPlaceChildrenOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceEquipmentPlacesArgs = {
  objects: ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlacesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceEquipmentPlacesOneArgs = {
  object: StopsDatabaseStopPlaceEquipmentPlacesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceKeyValuesArgs = {
  objects: ReadonlyArray<StopsDatabaseStopPlaceKeyValuesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseStopPlaceKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceKeyValuesOneArgs = {
  object: StopsDatabaseStopPlaceKeyValuesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseStopPlaceKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceOneArgs = {
  object: StopsDatabaseStopPlaceInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseStopPlaceOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceOrganisationsArgs = {
  objects: ReadonlyArray<StopsDatabaseStopPlaceOrganisationsInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseStopPlaceOrganisationsOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceOrganisationsOneArgs = {
  object: StopsDatabaseStopPlaceOrganisationsInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseStopPlaceOrganisationsOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceQuaysArgs = {
  objects: ReadonlyArray<StopsDatabaseStopPlaceQuaysInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseStopPlaceQuaysOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceQuaysOneArgs = {
  object: StopsDatabaseStopPlaceQuaysInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseStopPlaceQuaysOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceTariffZonesArgs = {
  objects: ReadonlyArray<StopsDatabaseStopPlaceTariffZonesInsertInput>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertStopPlaceTariffZonesOneArgs = {
  object: StopsDatabaseStopPlaceTariffZonesInsertInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertTagArgs = {
  objects: ReadonlyArray<StopsDatabaseTagInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseTagOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertTagOneArgs = {
  object: StopsDatabaseTagInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseTagOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertTariffZoneArgs = {
  objects: ReadonlyArray<StopsDatabaseTariffZoneInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseTariffZoneOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertTariffZoneKeyValuesArgs = {
  objects: ReadonlyArray<StopsDatabaseTariffZoneKeyValuesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseTariffZoneKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertTariffZoneKeyValuesOneArgs = {
  object: StopsDatabaseTariffZoneKeyValuesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseTariffZoneKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertTariffZoneOneArgs = {
  object: StopsDatabaseTariffZoneInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseTariffZoneOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertTopographicPlaceArgs = {
  objects: ReadonlyArray<StopsDatabaseTopographicPlaceInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseTopographicPlaceOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertTopographicPlaceKeyValuesArgs = {
  objects: ReadonlyArray<StopsDatabaseTopographicPlaceKeyValuesInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertTopographicPlaceKeyValuesOneArgs = {
  object: StopsDatabaseTopographicPlaceKeyValuesInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertTopographicPlaceOneArgs = {
  object: StopsDatabaseTopographicPlaceInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseTopographicPlaceOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertValueArgs = {
  objects: ReadonlyArray<StopsDatabaseValueInsertInput>;
  on_conflict?: InputMaybe<StopsDatabaseValueOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertValueItemsArgs = {
  objects: ReadonlyArray<StopsDatabaseValueItemsInsertInput>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertValueItemsOneArgs = {
  object: StopsDatabaseValueItemsInsertInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseInsertValueOneArgs = {
  object: StopsDatabaseValueInsertInput;
  on_conflict?: InputMaybe<StopsDatabaseValueOnConflict>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessSpaceArgs = {
  _inc?: InputMaybe<StopsDatabaseAccessSpaceIncInput>;
  _set?: InputMaybe<StopsDatabaseAccessSpaceSetInput>;
  where: StopsDatabaseAccessSpaceBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessSpaceAlternativeNamesArgs = {
  _inc?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesIncInput>;
  _set?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesSetInput>;
  where: StopsDatabaseAccessSpaceAlternativeNamesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessSpaceAlternativeNamesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNamesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessSpaceByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseAccessSpaceIncInput>;
  _set?: InputMaybe<StopsDatabaseAccessSpaceSetInput>;
  pk_columns: StopsDatabaseAccessSpacePkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessSpaceCheckConstraintsArgs = {
  _inc?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsIncInput>;
  _set?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsSetInput>;
  where: StopsDatabaseAccessSpaceCheckConstraintsBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessSpaceCheckConstraintsManyArgs = {
  updates: ReadonlyArray<StopsDatabaseAccessSpaceCheckConstraintsUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessSpaceEquipmentPlacesArgs = {
  _inc?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesIncInput>;
  _set?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesSetInput>;
  where: StopsDatabaseAccessSpaceEquipmentPlacesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessSpaceEquipmentPlacesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlacesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessSpaceKeyValuesArgs = {
  _inc?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesSetInput>;
  where: StopsDatabaseAccessSpaceKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessSpaceKeyValuesByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesSetInput>;
  pk_columns: StopsDatabaseAccessSpaceKeyValuesPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessSpaceKeyValuesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseAccessSpaceKeyValuesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessSpaceManyArgs = {
  updates: ReadonlyArray<StopsDatabaseAccessSpaceUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessibilityAssessmentArgs = {
  _inc?: InputMaybe<StopsDatabaseAccessibilityAssessmentIncInput>;
  _set?: InputMaybe<StopsDatabaseAccessibilityAssessmentSetInput>;
  where: StopsDatabaseAccessibilityAssessmentBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessibilityAssessmentByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseAccessibilityAssessmentIncInput>;
  _set?: InputMaybe<StopsDatabaseAccessibilityAssessmentSetInput>;
  pk_columns: StopsDatabaseAccessibilityAssessmentPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessibilityAssessmentLimitationsArgs = {
  _inc?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsIncInput>;
  _set?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsSetInput>;
  where: StopsDatabaseAccessibilityAssessmentLimitationsBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessibilityAssessmentLimitationsManyArgs = {
  updates: ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitationsUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessibilityAssessmentManyArgs = {
  updates: ReadonlyArray<StopsDatabaseAccessibilityAssessmentUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessibilityLimitationArgs = {
  _inc?: InputMaybe<StopsDatabaseAccessibilityLimitationIncInput>;
  _set?: InputMaybe<StopsDatabaseAccessibilityLimitationSetInput>;
  where: StopsDatabaseAccessibilityLimitationBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessibilityLimitationByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseAccessibilityLimitationIncInput>;
  _set?: InputMaybe<StopsDatabaseAccessibilityLimitationSetInput>;
  pk_columns: StopsDatabaseAccessibilityLimitationPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAccessibilityLimitationManyArgs = {
  updates: ReadonlyArray<StopsDatabaseAccessibilityLimitationUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAlternativeNameArgs = {
  _inc?: InputMaybe<StopsDatabaseAlternativeNameIncInput>;
  _set?: InputMaybe<StopsDatabaseAlternativeNameSetInput>;
  where: StopsDatabaseAlternativeNameBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAlternativeNameByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseAlternativeNameIncInput>;
  _set?: InputMaybe<StopsDatabaseAlternativeNameSetInput>;
  pk_columns: StopsDatabaseAlternativeNamePkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateAlternativeNameManyArgs = {
  updates: ReadonlyArray<StopsDatabaseAlternativeNameUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateBoardingPositionArgs = {
  _inc?: InputMaybe<StopsDatabaseBoardingPositionIncInput>;
  _set?: InputMaybe<StopsDatabaseBoardingPositionSetInput>;
  where: StopsDatabaseBoardingPositionBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateBoardingPositionAlternativeNamesArgs = {
  _inc?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesIncInput>;
  _set?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesSetInput>;
  where: StopsDatabaseBoardingPositionAlternativeNamesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateBoardingPositionAlternativeNamesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNamesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateBoardingPositionByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseBoardingPositionIncInput>;
  _set?: InputMaybe<StopsDatabaseBoardingPositionSetInput>;
  pk_columns: StopsDatabaseBoardingPositionPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateBoardingPositionCheckConstraintsArgs = {
  _inc?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsIncInput>;
  _set?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsSetInput>;
  where: StopsDatabaseBoardingPositionCheckConstraintsBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateBoardingPositionCheckConstraintsManyArgs = {
  updates: ReadonlyArray<StopsDatabaseBoardingPositionCheckConstraintsUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateBoardingPositionEquipmentPlacesArgs = {
  _inc?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesIncInput>;
  _set?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesSetInput>;
  where: StopsDatabaseBoardingPositionEquipmentPlacesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateBoardingPositionEquipmentPlacesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlacesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateBoardingPositionKeyValuesArgs = {
  _inc?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesSetInput>;
  where: StopsDatabaseBoardingPositionKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateBoardingPositionKeyValuesByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesSetInput>;
  pk_columns: StopsDatabaseBoardingPositionKeyValuesPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateBoardingPositionKeyValuesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseBoardingPositionKeyValuesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateBoardingPositionManyArgs = {
  updates: ReadonlyArray<StopsDatabaseBoardingPositionUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateCheckConstraintArgs = {
  _inc?: InputMaybe<StopsDatabaseCheckConstraintIncInput>;
  _set?: InputMaybe<StopsDatabaseCheckConstraintSetInput>;
  where: StopsDatabaseCheckConstraintBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateCheckConstraintByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseCheckConstraintIncInput>;
  _set?: InputMaybe<StopsDatabaseCheckConstraintSetInput>;
  pk_columns: StopsDatabaseCheckConstraintPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateCheckConstraintKeyValuesArgs = {
  _inc?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesSetInput>;
  where: StopsDatabaseCheckConstraintKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateCheckConstraintKeyValuesByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesSetInput>;
  pk_columns: StopsDatabaseCheckConstraintKeyValuesPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateCheckConstraintKeyValuesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseCheckConstraintKeyValuesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateCheckConstraintManyArgs = {
  updates: ReadonlyArray<StopsDatabaseCheckConstraintUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateContactArgs = {
  _inc?: InputMaybe<StopsDatabaseContactIncInput>;
  _set?: InputMaybe<StopsDatabaseContactSetInput>;
  where: StopsDatabaseContactBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateContactByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseContactIncInput>;
  _set?: InputMaybe<StopsDatabaseContactSetInput>;
  pk_columns: StopsDatabaseContactPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateContactManyArgs = {
  updates: ReadonlyArray<StopsDatabaseContactUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateDestinationDisplayViewArgs = {
  _inc?: InputMaybe<StopsDatabaseDestinationDisplayViewIncInput>;
  _set?: InputMaybe<StopsDatabaseDestinationDisplayViewSetInput>;
  where: StopsDatabaseDestinationDisplayViewBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateDestinationDisplayViewByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseDestinationDisplayViewIncInput>;
  _set?: InputMaybe<StopsDatabaseDestinationDisplayViewSetInput>;
  pk_columns: StopsDatabaseDestinationDisplayViewPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateDestinationDisplayViewManyArgs = {
  updates: ReadonlyArray<StopsDatabaseDestinationDisplayViewUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPlaceArgs = {
  _inc?: InputMaybe<StopsDatabaseEquipmentPlaceIncInput>;
  _set?: InputMaybe<StopsDatabaseEquipmentPlaceSetInput>;
  where: StopsDatabaseEquipmentPlaceBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPlaceByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseEquipmentPlaceIncInput>;
  _set?: InputMaybe<StopsDatabaseEquipmentPlaceSetInput>;
  pk_columns: StopsDatabaseEquipmentPlacePkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPlaceEquipmentPositionsArgs = {
  _inc?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsIncInput>;
  _set?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsSetInput>;
  where: StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPlaceEquipmentPositionsManyArgs = {
  updates: ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositionsUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPlaceKeyValuesArgs = {
  _inc?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesSetInput>;
  where: StopsDatabaseEquipmentPlaceKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPlaceKeyValuesByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesSetInput>;
  pk_columns: StopsDatabaseEquipmentPlaceKeyValuesPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPlaceKeyValuesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValuesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPlaceManyArgs = {
  updates: ReadonlyArray<StopsDatabaseEquipmentPlaceUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPositionArgs = {
  _inc?: InputMaybe<StopsDatabaseEquipmentPositionIncInput>;
  _set?: InputMaybe<StopsDatabaseEquipmentPositionSetInput>;
  where: StopsDatabaseEquipmentPositionBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPositionByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseEquipmentPositionIncInput>;
  _set?: InputMaybe<StopsDatabaseEquipmentPositionSetInput>;
  pk_columns: StopsDatabaseEquipmentPositionPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPositionKeyValuesArgs = {
  _inc?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesSetInput>;
  where: StopsDatabaseEquipmentPositionKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPositionKeyValuesByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesSetInput>;
  pk_columns: StopsDatabaseEquipmentPositionKeyValuesPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPositionKeyValuesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseEquipmentPositionKeyValuesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateEquipmentPositionManyArgs = {
  updates: ReadonlyArray<StopsDatabaseEquipmentPositionUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateExportJobArgs = {
  _inc?: InputMaybe<StopsDatabaseExportJobIncInput>;
  _set?: InputMaybe<StopsDatabaseExportJobSetInput>;
  where: StopsDatabaseExportJobBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateExportJobByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseExportJobIncInput>;
  _set?: InputMaybe<StopsDatabaseExportJobSetInput>;
  pk_columns: StopsDatabaseExportJobPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateExportJobManyArgs = {
  updates: ReadonlyArray<StopsDatabaseExportJobUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateFareZoneArgs = {
  _inc?: InputMaybe<StopsDatabaseFareZoneIncInput>;
  _set?: InputMaybe<StopsDatabaseFareZoneSetInput>;
  where: StopsDatabaseFareZoneBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateFareZoneByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseFareZoneIncInput>;
  _set?: InputMaybe<StopsDatabaseFareZoneSetInput>;
  pk_columns: StopsDatabaseFareZonePkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateFareZoneKeyValuesArgs = {
  _inc?: InputMaybe<StopsDatabaseFareZoneKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseFareZoneKeyValuesSetInput>;
  where: StopsDatabaseFareZoneKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateFareZoneKeyValuesByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseFareZoneKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseFareZoneKeyValuesSetInput>;
  pk_columns: StopsDatabaseFareZoneKeyValuesPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateFareZoneKeyValuesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseFareZoneKeyValuesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateFareZoneManyArgs = {
  updates: ReadonlyArray<StopsDatabaseFareZoneUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateFareZoneMembersArgs = {
  _inc?: InputMaybe<StopsDatabaseFareZoneMembersIncInput>;
  _set?: InputMaybe<StopsDatabaseFareZoneMembersSetInput>;
  where: StopsDatabaseFareZoneMembersBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateFareZoneMembersManyArgs = {
  updates: ReadonlyArray<StopsDatabaseFareZoneMembersUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateFareZoneNeighboursArgs = {
  _inc?: InputMaybe<StopsDatabaseFareZoneNeighboursIncInput>;
  _set?: InputMaybe<StopsDatabaseFareZoneNeighboursSetInput>;
  where: StopsDatabaseFareZoneNeighboursBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateFareZoneNeighboursManyArgs = {
  updates: ReadonlyArray<StopsDatabaseFareZoneNeighboursUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGeometryColumnsArgs = {
  _inc?: InputMaybe<StopsDatabaseGeometryColumnsIncInput>;
  _set?: InputMaybe<StopsDatabaseGeometryColumnsSetInput>;
  where: StopsDatabaseGeometryColumnsBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGeometryColumnsManyArgs = {
  updates: ReadonlyArray<StopsDatabaseGeometryColumnsUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfStopPlacesArgs = {
  _inc?: InputMaybe<StopsDatabaseGroupOfStopPlacesIncInput>;
  _set?: InputMaybe<StopsDatabaseGroupOfStopPlacesSetInput>;
  where: StopsDatabaseGroupOfStopPlacesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfStopPlacesAlternativeNamesArgs = {
  _inc?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesIncInput>;
  _set?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesSetInput>;
  where: StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfStopPlacesAlternativeNamesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNamesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfStopPlacesByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseGroupOfStopPlacesIncInput>;
  _set?: InputMaybe<StopsDatabaseGroupOfStopPlacesSetInput>;
  pk_columns: StopsDatabaseGroupOfStopPlacesPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfStopPlacesKeyValuesArgs = {
  _inc?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesSetInput>;
  where: StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfStopPlacesKeyValuesByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesSetInput>;
  pk_columns: StopsDatabaseGroupOfStopPlacesKeyValuesPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfStopPlacesKeyValuesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValuesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfStopPlacesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseGroupOfStopPlacesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfStopPlacesMembersArgs = {
  _inc?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersIncInput>;
  _set?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersSetInput>;
  where: StopsDatabaseGroupOfStopPlacesMembersBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfStopPlacesMembersManyArgs = {
  updates: ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembersUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfTariffZonesArgs = {
  _inc?: InputMaybe<StopsDatabaseGroupOfTariffZonesIncInput>;
  _set?: InputMaybe<StopsDatabaseGroupOfTariffZonesSetInput>;
  where: StopsDatabaseGroupOfTariffZonesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfTariffZonesByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseGroupOfTariffZonesIncInput>;
  _set?: InputMaybe<StopsDatabaseGroupOfTariffZonesSetInput>;
  pk_columns: StopsDatabaseGroupOfTariffZonesPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfTariffZonesKeyValuesArgs = {
  _inc?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesSetInput>;
  where: StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfTariffZonesKeyValuesByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesSetInput>;
  pk_columns: StopsDatabaseGroupOfTariffZonesKeyValuesPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfTariffZonesKeyValuesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValuesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfTariffZonesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseGroupOfTariffZonesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfTariffZonesMembersArgs = {
  _inc?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersIncInput>;
  _set?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersSetInput>;
  where: StopsDatabaseGroupOfTariffZonesMembersBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfTariffZonesMembersByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersIncInput>;
  _set?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersSetInput>;
  pk_columns: StopsDatabaseGroupOfTariffZonesMembersPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateGroupOfTariffZonesMembersManyArgs = {
  updates: ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembersUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateHslAccessibilityPropertiesArgs = {
  _inc?: InputMaybe<StopsDatabaseHslAccessibilityPropertiesIncInput>;
  _set?: InputMaybe<StopsDatabaseHslAccessibilityPropertiesSetInput>;
  where: StopsDatabaseHslAccessibilityPropertiesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateHslAccessibilityPropertiesByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseHslAccessibilityPropertiesIncInput>;
  _set?: InputMaybe<StopsDatabaseHslAccessibilityPropertiesSetInput>;
  pk_columns: StopsDatabaseHslAccessibilityPropertiesPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateHslAccessibilityPropertiesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseHslAccessibilityPropertiesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateIdGeneratorArgs = {
  _inc?: InputMaybe<StopsDatabaseIdGeneratorIncInput>;
  _set?: InputMaybe<StopsDatabaseIdGeneratorSetInput>;
  where: StopsDatabaseIdGeneratorBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateIdGeneratorManyArgs = {
  updates: ReadonlyArray<StopsDatabaseIdGeneratorUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateInfoSpotArgs = {
  _inc?: InputMaybe<StopsDatabaseInfoSpotIncInput>;
  _set?: InputMaybe<StopsDatabaseInfoSpotSetInput>;
  where: StopsDatabaseInfoSpotBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateInfoSpotByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseInfoSpotIncInput>;
  _set?: InputMaybe<StopsDatabaseInfoSpotSetInput>;
  pk_columns: StopsDatabaseInfoSpotPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateInfoSpotManyArgs = {
  updates: ReadonlyArray<StopsDatabaseInfoSpotUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateInfoSpotPosterArgs = {
  _inc?: InputMaybe<StopsDatabaseInfoSpotPosterIncInput>;
  _set?: InputMaybe<StopsDatabaseInfoSpotPosterSetInput>;
  where: StopsDatabaseInfoSpotPosterBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateInfoSpotPosterByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseInfoSpotPosterIncInput>;
  _set?: InputMaybe<StopsDatabaseInfoSpotPosterSetInput>;
  pk_columns: StopsDatabaseInfoSpotPosterPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateInfoSpotPosterManyArgs = {
  updates: ReadonlyArray<StopsDatabaseInfoSpotPosterUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateInstalledEquipmentArgs = {
  _inc?: InputMaybe<StopsDatabaseInstalledEquipmentIncInput>;
  _set?: InputMaybe<StopsDatabaseInstalledEquipmentSetInput>;
  where: StopsDatabaseInstalledEquipmentBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateInstalledEquipmentManyArgs = {
  updates: ReadonlyArray<StopsDatabaseInstalledEquipmentUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateInstalledEquipmentVersionStructureArgs = {
  _inc?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureIncInput>;
  _set?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureSetInput>;
  where: StopsDatabaseInstalledEquipmentVersionStructureBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateInstalledEquipmentVersionStructureByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureIncInput>;
  _set?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureSetInput>;
  pk_columns: StopsDatabaseInstalledEquipmentVersionStructurePkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateInstalledEquipmentVersionStructureInstalledEquipmentArgs = {
  _inc?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentIncInput>;
  _set?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSetInput>;
  where: StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateInstalledEquipmentVersionStructureInstalledEquipmentManyArgs = {
  updates: ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateInstalledEquipmentVersionStructureManyArgs = {
  updates: ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateLevelArgs = {
  _inc?: InputMaybe<StopsDatabaseLevelIncInput>;
  _set?: InputMaybe<StopsDatabaseLevelSetInput>;
  where: StopsDatabaseLevelBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateLevelByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseLevelIncInput>;
  _set?: InputMaybe<StopsDatabaseLevelSetInput>;
  pk_columns: StopsDatabaseLevelPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateLevelKeyValuesArgs = {
  _inc?: InputMaybe<StopsDatabaseLevelKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseLevelKeyValuesSetInput>;
  where: StopsDatabaseLevelKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateLevelKeyValuesByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseLevelKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseLevelKeyValuesSetInput>;
  pk_columns: StopsDatabaseLevelKeyValuesPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateLevelKeyValuesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseLevelKeyValuesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateLevelManyArgs = {
  updates: ReadonlyArray<StopsDatabaseLevelUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateMultilingualStringEntityArgs = {
  _inc?: InputMaybe<StopsDatabaseMultilingualStringEntityIncInput>;
  _set?: InputMaybe<StopsDatabaseMultilingualStringEntitySetInput>;
  where: StopsDatabaseMultilingualStringEntityBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateMultilingualStringEntityByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseMultilingualStringEntityIncInput>;
  _set?: InputMaybe<StopsDatabaseMultilingualStringEntitySetInput>;
  pk_columns: StopsDatabaseMultilingualStringEntityPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateMultilingualStringEntityManyArgs = {
  updates: ReadonlyArray<StopsDatabaseMultilingualStringEntityUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateNavigationPathArgs = {
  _inc?: InputMaybe<StopsDatabaseNavigationPathIncInput>;
  _set?: InputMaybe<StopsDatabaseNavigationPathSetInput>;
  where: StopsDatabaseNavigationPathBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateNavigationPathManyArgs = {
  updates: ReadonlyArray<StopsDatabaseNavigationPathUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateOrganisationArgs = {
  _inc?: InputMaybe<StopsDatabaseOrganisationIncInput>;
  _set?: InputMaybe<StopsDatabaseOrganisationSetInput>;
  where: StopsDatabaseOrganisationBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateOrganisationByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseOrganisationIncInput>;
  _set?: InputMaybe<StopsDatabaseOrganisationSetInput>;
  pk_columns: StopsDatabaseOrganisationPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateOrganisationKeyValuesArgs = {
  _inc?: InputMaybe<StopsDatabaseOrganisationKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseOrganisationKeyValuesSetInput>;
  where: StopsDatabaseOrganisationKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateOrganisationKeyValuesByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseOrganisationKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseOrganisationKeyValuesSetInput>;
  pk_columns: StopsDatabaseOrganisationKeyValuesPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateOrganisationKeyValuesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseOrganisationKeyValuesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateOrganisationManyArgs = {
  updates: ReadonlyArray<StopsDatabaseOrganisationUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingArgs = {
  _inc?: InputMaybe<StopsDatabaseParkingIncInput>;
  _set?: InputMaybe<StopsDatabaseParkingSetInput>;
  where: StopsDatabaseParkingBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAdjacentSitesArgs = {
  _inc?: InputMaybe<StopsDatabaseParkingAdjacentSitesIncInput>;
  _set?: InputMaybe<StopsDatabaseParkingAdjacentSitesSetInput>;
  where: StopsDatabaseParkingAdjacentSitesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAdjacentSitesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseParkingAdjacentSitesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAlternativeNamesArgs = {
  _inc?: InputMaybe<StopsDatabaseParkingAlternativeNamesIncInput>;
  _set?: InputMaybe<StopsDatabaseParkingAlternativeNamesSetInput>;
  where: StopsDatabaseParkingAlternativeNamesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAlternativeNamesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseParkingAlternativeNamesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAreaArgs = {
  _inc?: InputMaybe<StopsDatabaseParkingAreaIncInput>;
  _set?: InputMaybe<StopsDatabaseParkingAreaSetInput>;
  where: StopsDatabaseParkingAreaBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAreaAlternativeNamesArgs = {
  _inc?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesIncInput>;
  _set?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesSetInput>;
  where: StopsDatabaseParkingAreaAlternativeNamesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAreaAlternativeNamesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseParkingAreaAlternativeNamesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAreaByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseParkingAreaIncInput>;
  _set?: InputMaybe<StopsDatabaseParkingAreaSetInput>;
  pk_columns: StopsDatabaseParkingAreaPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAreaCheckConstraintsArgs = {
  _inc?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsIncInput>;
  _set?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsSetInput>;
  where: StopsDatabaseParkingAreaCheckConstraintsBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAreaCheckConstraintsManyArgs = {
  updates: ReadonlyArray<StopsDatabaseParkingAreaCheckConstraintsUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAreaEquipmentPlacesArgs = {
  _inc?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesIncInput>;
  _set?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesSetInput>;
  where: StopsDatabaseParkingAreaEquipmentPlacesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAreaEquipmentPlacesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlacesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAreaKeyValuesArgs = {
  _inc?: InputMaybe<StopsDatabaseParkingAreaKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseParkingAreaKeyValuesSetInput>;
  where: StopsDatabaseParkingAreaKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAreaKeyValuesByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseParkingAreaKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseParkingAreaKeyValuesSetInput>;
  pk_columns: StopsDatabaseParkingAreaKeyValuesPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAreaKeyValuesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseParkingAreaKeyValuesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingAreaManyArgs = {
  updates: ReadonlyArray<StopsDatabaseParkingAreaUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseParkingIncInput>;
  _set?: InputMaybe<StopsDatabaseParkingSetInput>;
  pk_columns: StopsDatabaseParkingPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingCapacityArgs = {
  _inc?: InputMaybe<StopsDatabaseParkingCapacityIncInput>;
  _set?: InputMaybe<StopsDatabaseParkingCapacitySetInput>;
  where: StopsDatabaseParkingCapacityBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingCapacityByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseParkingCapacityIncInput>;
  _set?: InputMaybe<StopsDatabaseParkingCapacitySetInput>;
  pk_columns: StopsDatabaseParkingCapacityPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingCapacityManyArgs = {
  updates: ReadonlyArray<StopsDatabaseParkingCapacityUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingEquipmentPlacesArgs = {
  _inc?: InputMaybe<StopsDatabaseParkingEquipmentPlacesIncInput>;
  _set?: InputMaybe<StopsDatabaseParkingEquipmentPlacesSetInput>;
  where: StopsDatabaseParkingEquipmentPlacesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingEquipmentPlacesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseParkingEquipmentPlacesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingKeyValuesArgs = {
  _inc?: InputMaybe<StopsDatabaseParkingKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseParkingKeyValuesSetInput>;
  where: StopsDatabaseParkingKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingKeyValuesByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseParkingKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseParkingKeyValuesSetInput>;
  pk_columns: StopsDatabaseParkingKeyValuesPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingKeyValuesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseParkingKeyValuesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingManyArgs = {
  updates: ReadonlyArray<StopsDatabaseParkingUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingParkingAreasArgs = {
  _inc?: InputMaybe<StopsDatabaseParkingParkingAreasIncInput>;
  _set?: InputMaybe<StopsDatabaseParkingParkingAreasSetInput>;
  where: StopsDatabaseParkingParkingAreasBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingParkingAreasManyArgs = {
  updates: ReadonlyArray<StopsDatabaseParkingParkingAreasUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingParkingPaymentProcessArgs = {
  _inc?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessIncInput>;
  _set?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessSetInput>;
  where: StopsDatabaseParkingParkingPaymentProcessBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingParkingPaymentProcessManyArgs = {
  updates: ReadonlyArray<StopsDatabaseParkingParkingPaymentProcessUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingParkingPropertiesArgs = {
  _inc?: InputMaybe<StopsDatabaseParkingParkingPropertiesIncInput>;
  _set?: InputMaybe<StopsDatabaseParkingParkingPropertiesSetInput>;
  where: StopsDatabaseParkingParkingPropertiesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingParkingPropertiesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseParkingParkingPropertiesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingParkingVehicleTypesArgs = {
  _inc?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesIncInput>;
  _set?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesSetInput>;
  where: StopsDatabaseParkingParkingVehicleTypesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingParkingVehicleTypesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseParkingParkingVehicleTypesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingPropertiesArgs = {
  _inc?: InputMaybe<StopsDatabaseParkingPropertiesIncInput>;
  _set?: InputMaybe<StopsDatabaseParkingPropertiesSetInput>;
  where: StopsDatabaseParkingPropertiesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingPropertiesByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseParkingPropertiesIncInput>;
  _set?: InputMaybe<StopsDatabaseParkingPropertiesSetInput>;
  pk_columns: StopsDatabaseParkingPropertiesPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingPropertiesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseParkingPropertiesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingPropertiesParkingUserTypesArgs = {
  _inc?: InputMaybe<StopsDatabaseParkingPropertiesParkingUserTypesIncInput>;
  _set?: InputMaybe<StopsDatabaseParkingPropertiesParkingUserTypesSetInput>;
  where: StopsDatabaseParkingPropertiesParkingUserTypesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingPropertiesParkingUserTypesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseParkingPropertiesParkingUserTypesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingPropertiesSpacesArgs = {
  _inc?: InputMaybe<StopsDatabaseParkingPropertiesSpacesIncInput>;
  _set?: InputMaybe<StopsDatabaseParkingPropertiesSpacesSetInput>;
  where: StopsDatabaseParkingPropertiesSpacesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateParkingPropertiesSpacesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseParkingPropertiesSpacesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathJunctionArgs = {
  _inc?: InputMaybe<StopsDatabasePathJunctionIncInput>;
  _set?: InputMaybe<StopsDatabasePathJunctionSetInput>;
  where: StopsDatabasePathJunctionBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathJunctionByPkArgs = {
  _inc?: InputMaybe<StopsDatabasePathJunctionIncInput>;
  _set?: InputMaybe<StopsDatabasePathJunctionSetInput>;
  pk_columns: StopsDatabasePathJunctionPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathJunctionKeyValuesArgs = {
  _inc?: InputMaybe<StopsDatabasePathJunctionKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabasePathJunctionKeyValuesSetInput>;
  where: StopsDatabasePathJunctionKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathJunctionKeyValuesByPkArgs = {
  _inc?: InputMaybe<StopsDatabasePathJunctionKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabasePathJunctionKeyValuesSetInput>;
  pk_columns: StopsDatabasePathJunctionKeyValuesPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathJunctionKeyValuesManyArgs = {
  updates: ReadonlyArray<StopsDatabasePathJunctionKeyValuesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathJunctionManyArgs = {
  updates: ReadonlyArray<StopsDatabasePathJunctionUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathLinkArgs = {
  _inc?: InputMaybe<StopsDatabasePathLinkIncInput>;
  _set?: InputMaybe<StopsDatabasePathLinkSetInput>;
  where: StopsDatabasePathLinkBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathLinkByPkArgs = {
  _inc?: InputMaybe<StopsDatabasePathLinkIncInput>;
  _set?: InputMaybe<StopsDatabasePathLinkSetInput>;
  pk_columns: StopsDatabasePathLinkPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathLinkEndArgs = {
  _inc?: InputMaybe<StopsDatabasePathLinkEndIncInput>;
  _set?: InputMaybe<StopsDatabasePathLinkEndSetInput>;
  where: StopsDatabasePathLinkEndBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathLinkEndByPkArgs = {
  _inc?: InputMaybe<StopsDatabasePathLinkEndIncInput>;
  _set?: InputMaybe<StopsDatabasePathLinkEndSetInput>;
  pk_columns: StopsDatabasePathLinkEndPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathLinkEndManyArgs = {
  updates: ReadonlyArray<StopsDatabasePathLinkEndUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathLinkKeyValuesArgs = {
  _inc?: InputMaybe<StopsDatabasePathLinkKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabasePathLinkKeyValuesSetInput>;
  where: StopsDatabasePathLinkKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathLinkKeyValuesByPkArgs = {
  _inc?: InputMaybe<StopsDatabasePathLinkKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabasePathLinkKeyValuesSetInput>;
  pk_columns: StopsDatabasePathLinkKeyValuesPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathLinkKeyValuesManyArgs = {
  updates: ReadonlyArray<StopsDatabasePathLinkKeyValuesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePathLinkManyArgs = {
  updates: ReadonlyArray<StopsDatabasePathLinkUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePersistablePolygonArgs = {
  _inc?: InputMaybe<StopsDatabasePersistablePolygonIncInput>;
  _set?: InputMaybe<StopsDatabasePersistablePolygonSetInput>;
  where: StopsDatabasePersistablePolygonBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePersistablePolygonByPkArgs = {
  _inc?: InputMaybe<StopsDatabasePersistablePolygonIncInput>;
  _set?: InputMaybe<StopsDatabasePersistablePolygonSetInput>;
  pk_columns: StopsDatabasePersistablePolygonPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePersistablePolygonManyArgs = {
  updates: ReadonlyArray<StopsDatabasePersistablePolygonUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePurposeOfGroupingArgs = {
  _inc?: InputMaybe<StopsDatabasePurposeOfGroupingIncInput>;
  _set?: InputMaybe<StopsDatabasePurposeOfGroupingSetInput>;
  where: StopsDatabasePurposeOfGroupingBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePurposeOfGroupingByPkArgs = {
  _inc?: InputMaybe<StopsDatabasePurposeOfGroupingIncInput>;
  _set?: InputMaybe<StopsDatabasePurposeOfGroupingSetInput>;
  pk_columns: StopsDatabasePurposeOfGroupingPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePurposeOfGroupingKeyValuesArgs = {
  _inc?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesSetInput>;
  where: StopsDatabasePurposeOfGroupingKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePurposeOfGroupingKeyValuesByPkArgs = {
  _inc?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesSetInput>;
  pk_columns: StopsDatabasePurposeOfGroupingKeyValuesPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePurposeOfGroupingKeyValuesManyArgs = {
  updates: ReadonlyArray<StopsDatabasePurposeOfGroupingKeyValuesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdatePurposeOfGroupingManyArgs = {
  updates: ReadonlyArray<StopsDatabasePurposeOfGroupingUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayArgs = {
  _inc?: InputMaybe<StopsDatabaseQuayIncInput>;
  _set?: InputMaybe<StopsDatabaseQuaySetInput>;
  where: StopsDatabaseQuayBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayAlternativeNamesArgs = {
  _inc?: InputMaybe<StopsDatabaseQuayAlternativeNamesIncInput>;
  _set?: InputMaybe<StopsDatabaseQuayAlternativeNamesSetInput>;
  where: StopsDatabaseQuayAlternativeNamesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayAlternativeNamesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseQuayAlternativeNamesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayBoardingPositionsArgs = {
  _inc?: InputMaybe<StopsDatabaseQuayBoardingPositionsIncInput>;
  _set?: InputMaybe<StopsDatabaseQuayBoardingPositionsSetInput>;
  where: StopsDatabaseQuayBoardingPositionsBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayBoardingPositionsManyArgs = {
  updates: ReadonlyArray<StopsDatabaseQuayBoardingPositionsUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseQuayIncInput>;
  _set?: InputMaybe<StopsDatabaseQuaySetInput>;
  pk_columns: StopsDatabaseQuayPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayCheckConstraintsArgs = {
  _inc?: InputMaybe<StopsDatabaseQuayCheckConstraintsIncInput>;
  _set?: InputMaybe<StopsDatabaseQuayCheckConstraintsSetInput>;
  where: StopsDatabaseQuayCheckConstraintsBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayCheckConstraintsManyArgs = {
  updates: ReadonlyArray<StopsDatabaseQuayCheckConstraintsUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayEquipmentPlacesArgs = {
  _inc?: InputMaybe<StopsDatabaseQuayEquipmentPlacesIncInput>;
  _set?: InputMaybe<StopsDatabaseQuayEquipmentPlacesSetInput>;
  where: StopsDatabaseQuayEquipmentPlacesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayEquipmentPlacesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseQuayEquipmentPlacesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayKeyValuesArgs = {
  _inc?: InputMaybe<StopsDatabaseQuayKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseQuayKeyValuesSetInput>;
  where: StopsDatabaseQuayKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayKeyValuesByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseQuayKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseQuayKeyValuesSetInput>;
  pk_columns: StopsDatabaseQuayKeyValuesPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayKeyValuesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseQuayKeyValuesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateQuayManyArgs = {
  updates: ReadonlyArray<StopsDatabaseQuayUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateSchemaVersionArgs = {
  _inc?: InputMaybe<StopsDatabaseSchemaVersionIncInput>;
  _set?: InputMaybe<StopsDatabaseSchemaVersionSetInput>;
  where: StopsDatabaseSchemaVersionBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateSchemaVersionByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseSchemaVersionIncInput>;
  _set?: InputMaybe<StopsDatabaseSchemaVersionSetInput>;
  pk_columns: StopsDatabaseSchemaVersionPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateSchemaVersionManyArgs = {
  updates: ReadonlyArray<StopsDatabaseSchemaVersionUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateSpatialRefSysArgs = {
  _inc?: InputMaybe<StopsDatabaseSpatialRefSysIncInput>;
  _set?: InputMaybe<StopsDatabaseSpatialRefSysSetInput>;
  where: StopsDatabaseSpatialRefSysBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateSpatialRefSysByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseSpatialRefSysIncInput>;
  _set?: InputMaybe<StopsDatabaseSpatialRefSysSetInput>;
  pk_columns: StopsDatabaseSpatialRefSysPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateSpatialRefSysManyArgs = {
  updates: ReadonlyArray<StopsDatabaseSpatialRefSysUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceArgs = {
  _inc?: InputMaybe<StopsDatabaseStopPlaceIncInput>;
  _set?: InputMaybe<StopsDatabaseStopPlaceSetInput>;
  where: StopsDatabaseStopPlaceBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceAccessSpacesArgs = {
  _inc?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesIncInput>;
  _set?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesSetInput>;
  where: StopsDatabaseStopPlaceAccessSpacesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceAccessSpacesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseStopPlaceAccessSpacesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceAdjacentSitesArgs = {
  _inc?: InputMaybe<StopsDatabaseStopPlaceAdjacentSitesIncInput>;
  _set?: InputMaybe<StopsDatabaseStopPlaceAdjacentSitesSetInput>;
  where: StopsDatabaseStopPlaceAdjacentSitesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceAdjacentSitesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseStopPlaceAdjacentSitesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceAlternativeNamesArgs = {
  _inc?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesIncInput>;
  _set?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesSetInput>;
  where: StopsDatabaseStopPlaceAlternativeNamesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceAlternativeNamesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseStopPlaceAlternativeNamesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseStopPlaceIncInput>;
  _set?: InputMaybe<StopsDatabaseStopPlaceSetInput>;
  pk_columns: StopsDatabaseStopPlacePkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceChildrenArgs = {
  _inc?: InputMaybe<StopsDatabaseStopPlaceChildrenIncInput>;
  _set?: InputMaybe<StopsDatabaseStopPlaceChildrenSetInput>;
  where: StopsDatabaseStopPlaceChildrenBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceChildrenByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseStopPlaceChildrenIncInput>;
  _set?: InputMaybe<StopsDatabaseStopPlaceChildrenSetInput>;
  pk_columns: StopsDatabaseStopPlaceChildrenPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceChildrenManyArgs = {
  updates: ReadonlyArray<StopsDatabaseStopPlaceChildrenUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceEquipmentPlacesArgs = {
  _inc?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesIncInput>;
  _set?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesSetInput>;
  where: StopsDatabaseStopPlaceEquipmentPlacesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceEquipmentPlacesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlacesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceKeyValuesArgs = {
  _inc?: InputMaybe<StopsDatabaseStopPlaceKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseStopPlaceKeyValuesSetInput>;
  where: StopsDatabaseStopPlaceKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceKeyValuesByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseStopPlaceKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseStopPlaceKeyValuesSetInput>;
  pk_columns: StopsDatabaseStopPlaceKeyValuesPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceKeyValuesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseStopPlaceKeyValuesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceManyArgs = {
  updates: ReadonlyArray<StopsDatabaseStopPlaceUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceOrganisationsArgs = {
  _inc?: InputMaybe<StopsDatabaseStopPlaceOrganisationsIncInput>;
  _set?: InputMaybe<StopsDatabaseStopPlaceOrganisationsSetInput>;
  where: StopsDatabaseStopPlaceOrganisationsBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceOrganisationsByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseStopPlaceOrganisationsIncInput>;
  _set?: InputMaybe<StopsDatabaseStopPlaceOrganisationsSetInput>;
  pk_columns: StopsDatabaseStopPlaceOrganisationsPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceOrganisationsManyArgs = {
  updates: ReadonlyArray<StopsDatabaseStopPlaceOrganisationsUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceQuaysArgs = {
  _inc?: InputMaybe<StopsDatabaseStopPlaceQuaysIncInput>;
  _set?: InputMaybe<StopsDatabaseStopPlaceQuaysSetInput>;
  where: StopsDatabaseStopPlaceQuaysBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceQuaysByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseStopPlaceQuaysIncInput>;
  _set?: InputMaybe<StopsDatabaseStopPlaceQuaysSetInput>;
  pk_columns: StopsDatabaseStopPlaceQuaysPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceQuaysManyArgs = {
  updates: ReadonlyArray<StopsDatabaseStopPlaceQuaysUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceTariffZonesArgs = {
  _inc?: InputMaybe<StopsDatabaseStopPlaceTariffZonesIncInput>;
  _set?: InputMaybe<StopsDatabaseStopPlaceTariffZonesSetInput>;
  where: StopsDatabaseStopPlaceTariffZonesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateStopPlaceTariffZonesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseStopPlaceTariffZonesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTagArgs = {
  _set?: InputMaybe<StopsDatabaseTagSetInput>;
  where: StopsDatabaseTagBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTagByPkArgs = {
  _set?: InputMaybe<StopsDatabaseTagSetInput>;
  pk_columns: StopsDatabaseTagPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTagManyArgs = {
  updates: ReadonlyArray<StopsDatabaseTagUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTariffZoneArgs = {
  _inc?: InputMaybe<StopsDatabaseTariffZoneIncInput>;
  _set?: InputMaybe<StopsDatabaseTariffZoneSetInput>;
  where: StopsDatabaseTariffZoneBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTariffZoneByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseTariffZoneIncInput>;
  _set?: InputMaybe<StopsDatabaseTariffZoneSetInput>;
  pk_columns: StopsDatabaseTariffZonePkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTariffZoneKeyValuesArgs = {
  _inc?: InputMaybe<StopsDatabaseTariffZoneKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseTariffZoneKeyValuesSetInput>;
  where: StopsDatabaseTariffZoneKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTariffZoneKeyValuesByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseTariffZoneKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseTariffZoneKeyValuesSetInput>;
  pk_columns: StopsDatabaseTariffZoneKeyValuesPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTariffZoneKeyValuesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseTariffZoneKeyValuesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTariffZoneManyArgs = {
  updates: ReadonlyArray<StopsDatabaseTariffZoneUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTopographicPlaceArgs = {
  _inc?: InputMaybe<StopsDatabaseTopographicPlaceIncInput>;
  _set?: InputMaybe<StopsDatabaseTopographicPlaceSetInput>;
  where: StopsDatabaseTopographicPlaceBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTopographicPlaceByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseTopographicPlaceIncInput>;
  _set?: InputMaybe<StopsDatabaseTopographicPlaceSetInput>;
  pk_columns: StopsDatabaseTopographicPlacePkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTopographicPlaceKeyValuesArgs = {
  _inc?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesSetInput>;
  where: StopsDatabaseTopographicPlaceKeyValuesBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTopographicPlaceKeyValuesByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesIncInput>;
  _set?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesSetInput>;
  pk_columns: StopsDatabaseTopographicPlaceKeyValuesPkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTopographicPlaceKeyValuesManyArgs = {
  updates: ReadonlyArray<StopsDatabaseTopographicPlaceKeyValuesUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateTopographicPlaceManyArgs = {
  updates: ReadonlyArray<StopsDatabaseTopographicPlaceUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateValueArgs = {
  _inc?: InputMaybe<StopsDatabaseValueIncInput>;
  _set?: InputMaybe<StopsDatabaseValueSetInput>;
  where: StopsDatabaseValueBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateValueByPkArgs = {
  _inc?: InputMaybe<StopsDatabaseValueIncInput>;
  _set?: InputMaybe<StopsDatabaseValueSetInput>;
  pk_columns: StopsDatabaseValuePkColumnsInput;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateValueItemsArgs = {
  _inc?: InputMaybe<StopsDatabaseValueItemsIncInput>;
  _set?: InputMaybe<StopsDatabaseValueItemsSetInput>;
  where: StopsDatabaseValueItemsBoolExp;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateValueItemsManyArgs = {
  updates: ReadonlyArray<StopsDatabaseValueItemsUpdates>;
};


export type StopsDatabaseStopsDatabaseMutationFrontendStopsDatabaseUpdateValueManyArgs = {
  updates: ReadonlyArray<StopsDatabaseValueUpdates>;
};

export type StopsDatabaseStopsDatabaseQuery = {
  readonly __typename?: 'stops_database_stops_database_query';
  readonly findStopsForTerminal: ReadonlyArray<TerminalStopSearchResult>;
  /** fetch data from the table: "access_space" */
  readonly stops_database_access_space: ReadonlyArray<StopsDatabaseAccessSpace>;
  /** fetch aggregated fields from the table: "access_space" */
  readonly stops_database_access_space_aggregate: StopsDatabaseAccessSpaceAggregate;
  /** fetch data from the table: "access_space_alternative_names" */
  readonly stops_database_access_space_alternative_names: ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNames>;
  /** fetch aggregated fields from the table: "access_space_alternative_names" */
  readonly stops_database_access_space_alternative_names_aggregate: StopsDatabaseAccessSpaceAlternativeNamesAggregate;
  /** fetch data from the table: "access_space" using primary key columns */
  readonly stops_database_access_space_by_pk?: Maybe<StopsDatabaseAccessSpace>;
  /** fetch data from the table: "access_space_check_constraints" */
  readonly stops_database_access_space_check_constraints: ReadonlyArray<StopsDatabaseAccessSpaceCheckConstraints>;
  /** fetch aggregated fields from the table: "access_space_check_constraints" */
  readonly stops_database_access_space_check_constraints_aggregate: StopsDatabaseAccessSpaceCheckConstraintsAggregate;
  /** fetch data from the table: "access_space_equipment_places" */
  readonly stops_database_access_space_equipment_places: ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlaces>;
  /** fetch aggregated fields from the table: "access_space_equipment_places" */
  readonly stops_database_access_space_equipment_places_aggregate: StopsDatabaseAccessSpaceEquipmentPlacesAggregate;
  /** fetch data from the table: "access_space_key_values" */
  readonly stops_database_access_space_key_values: ReadonlyArray<StopsDatabaseAccessSpaceKeyValues>;
  /** fetch aggregated fields from the table: "access_space_key_values" */
  readonly stops_database_access_space_key_values_aggregate: StopsDatabaseAccessSpaceKeyValuesAggregate;
  /** fetch data from the table: "access_space_key_values" using primary key columns */
  readonly stops_database_access_space_key_values_by_pk?: Maybe<StopsDatabaseAccessSpaceKeyValues>;
  /** fetch data from the table: "accessibility_assessment" */
  readonly stops_database_accessibility_assessment: ReadonlyArray<StopsDatabaseAccessibilityAssessment>;
  /** fetch aggregated fields from the table: "accessibility_assessment" */
  readonly stops_database_accessibility_assessment_aggregate: StopsDatabaseAccessibilityAssessmentAggregate;
  /** fetch data from the table: "accessibility_assessment" using primary key columns */
  readonly stops_database_accessibility_assessment_by_pk?: Maybe<StopsDatabaseAccessibilityAssessment>;
  /** fetch data from the table: "accessibility_assessment_limitations" */
  readonly stops_database_accessibility_assessment_limitations: ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitations>;
  /** fetch aggregated fields from the table: "accessibility_assessment_limitations" */
  readonly stops_database_accessibility_assessment_limitations_aggregate: StopsDatabaseAccessibilityAssessmentLimitationsAggregate;
  /** fetch data from the table: "accessibility_limitation" */
  readonly stops_database_accessibility_limitation: ReadonlyArray<StopsDatabaseAccessibilityLimitation>;
  /** fetch aggregated fields from the table: "accessibility_limitation" */
  readonly stops_database_accessibility_limitation_aggregate: StopsDatabaseAccessibilityLimitationAggregate;
  /** fetch data from the table: "accessibility_limitation" using primary key columns */
  readonly stops_database_accessibility_limitation_by_pk?: Maybe<StopsDatabaseAccessibilityLimitation>;
  /** fetch data from the table: "alternative_name" */
  readonly stops_database_alternative_name: ReadonlyArray<StopsDatabaseAlternativeName>;
  /** fetch aggregated fields from the table: "alternative_name" */
  readonly stops_database_alternative_name_aggregate: StopsDatabaseAlternativeNameAggregate;
  /** fetch data from the table: "alternative_name" using primary key columns */
  readonly stops_database_alternative_name_by_pk?: Maybe<StopsDatabaseAlternativeName>;
  /** fetch data from the table: "boarding_position" */
  readonly stops_database_boarding_position: ReadonlyArray<StopsDatabaseBoardingPosition>;
  /** fetch aggregated fields from the table: "boarding_position" */
  readonly stops_database_boarding_position_aggregate: StopsDatabaseBoardingPositionAggregate;
  /** fetch data from the table: "boarding_position_alternative_names" */
  readonly stops_database_boarding_position_alternative_names: ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNames>;
  /** fetch aggregated fields from the table: "boarding_position_alternative_names" */
  readonly stops_database_boarding_position_alternative_names_aggregate: StopsDatabaseBoardingPositionAlternativeNamesAggregate;
  /** fetch data from the table: "boarding_position" using primary key columns */
  readonly stops_database_boarding_position_by_pk?: Maybe<StopsDatabaseBoardingPosition>;
  /** fetch data from the table: "boarding_position_check_constraints" */
  readonly stops_database_boarding_position_check_constraints: ReadonlyArray<StopsDatabaseBoardingPositionCheckConstraints>;
  /** fetch aggregated fields from the table: "boarding_position_check_constraints" */
  readonly stops_database_boarding_position_check_constraints_aggregate: StopsDatabaseBoardingPositionCheckConstraintsAggregate;
  /** fetch data from the table: "boarding_position_equipment_places" */
  readonly stops_database_boarding_position_equipment_places: ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlaces>;
  /** fetch aggregated fields from the table: "boarding_position_equipment_places" */
  readonly stops_database_boarding_position_equipment_places_aggregate: StopsDatabaseBoardingPositionEquipmentPlacesAggregate;
  /** fetch data from the table: "boarding_position_key_values" */
  readonly stops_database_boarding_position_key_values: ReadonlyArray<StopsDatabaseBoardingPositionKeyValues>;
  /** fetch aggregated fields from the table: "boarding_position_key_values" */
  readonly stops_database_boarding_position_key_values_aggregate: StopsDatabaseBoardingPositionKeyValuesAggregate;
  /** fetch data from the table: "boarding_position_key_values" using primary key columns */
  readonly stops_database_boarding_position_key_values_by_pk?: Maybe<StopsDatabaseBoardingPositionKeyValues>;
  /** fetch data from the table: "check_constraint" */
  readonly stops_database_check_constraint: ReadonlyArray<StopsDatabaseCheckConstraint>;
  /** fetch aggregated fields from the table: "check_constraint" */
  readonly stops_database_check_constraint_aggregate: StopsDatabaseCheckConstraintAggregate;
  /** fetch data from the table: "check_constraint" using primary key columns */
  readonly stops_database_check_constraint_by_pk?: Maybe<StopsDatabaseCheckConstraint>;
  /** fetch data from the table: "check_constraint_key_values" */
  readonly stops_database_check_constraint_key_values: ReadonlyArray<StopsDatabaseCheckConstraintKeyValues>;
  /** fetch aggregated fields from the table: "check_constraint_key_values" */
  readonly stops_database_check_constraint_key_values_aggregate: StopsDatabaseCheckConstraintKeyValuesAggregate;
  /** fetch data from the table: "check_constraint_key_values" using primary key columns */
  readonly stops_database_check_constraint_key_values_by_pk?: Maybe<StopsDatabaseCheckConstraintKeyValues>;
  /** fetch data from the table: "contact" */
  readonly stops_database_contact: ReadonlyArray<StopsDatabaseContact>;
  /** fetch aggregated fields from the table: "contact" */
  readonly stops_database_contact_aggregate: StopsDatabaseContactAggregate;
  /** fetch data from the table: "contact" using primary key columns */
  readonly stops_database_contact_by_pk?: Maybe<StopsDatabaseContact>;
  /** fetch data from the table: "destination_display_view" */
  readonly stops_database_destination_display_view: ReadonlyArray<StopsDatabaseDestinationDisplayView>;
  /** fetch aggregated fields from the table: "destination_display_view" */
  readonly stops_database_destination_display_view_aggregate: StopsDatabaseDestinationDisplayViewAggregate;
  /** fetch data from the table: "destination_display_view" using primary key columns */
  readonly stops_database_destination_display_view_by_pk?: Maybe<StopsDatabaseDestinationDisplayView>;
  /** fetch data from the table: "equipment_place" */
  readonly stops_database_equipment_place: ReadonlyArray<StopsDatabaseEquipmentPlace>;
  /** fetch aggregated fields from the table: "equipment_place" */
  readonly stops_database_equipment_place_aggregate: StopsDatabaseEquipmentPlaceAggregate;
  /** fetch data from the table: "equipment_place" using primary key columns */
  readonly stops_database_equipment_place_by_pk?: Maybe<StopsDatabaseEquipmentPlace>;
  /** fetch data from the table: "equipment_place_equipment_positions" */
  readonly stops_database_equipment_place_equipment_positions: ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositions>;
  /** fetch aggregated fields from the table: "equipment_place_equipment_positions" */
  readonly stops_database_equipment_place_equipment_positions_aggregate: StopsDatabaseEquipmentPlaceEquipmentPositionsAggregate;
  /** fetch data from the table: "equipment_place_key_values" */
  readonly stops_database_equipment_place_key_values: ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValues>;
  /** fetch aggregated fields from the table: "equipment_place_key_values" */
  readonly stops_database_equipment_place_key_values_aggregate: StopsDatabaseEquipmentPlaceKeyValuesAggregate;
  /** fetch data from the table: "equipment_place_key_values" using primary key columns */
  readonly stops_database_equipment_place_key_values_by_pk?: Maybe<StopsDatabaseEquipmentPlaceKeyValues>;
  /** fetch data from the table: "equipment_position" */
  readonly stops_database_equipment_position: ReadonlyArray<StopsDatabaseEquipmentPosition>;
  /** fetch aggregated fields from the table: "equipment_position" */
  readonly stops_database_equipment_position_aggregate: StopsDatabaseEquipmentPositionAggregate;
  /** fetch data from the table: "equipment_position" using primary key columns */
  readonly stops_database_equipment_position_by_pk?: Maybe<StopsDatabaseEquipmentPosition>;
  /** fetch data from the table: "equipment_position_key_values" */
  readonly stops_database_equipment_position_key_values: ReadonlyArray<StopsDatabaseEquipmentPositionKeyValues>;
  /** fetch aggregated fields from the table: "equipment_position_key_values" */
  readonly stops_database_equipment_position_key_values_aggregate: StopsDatabaseEquipmentPositionKeyValuesAggregate;
  /** fetch data from the table: "equipment_position_key_values" using primary key columns */
  readonly stops_database_equipment_position_key_values_by_pk?: Maybe<StopsDatabaseEquipmentPositionKeyValues>;
  /** fetch data from the table: "export_job" */
  readonly stops_database_export_job: ReadonlyArray<StopsDatabaseExportJob>;
  /** fetch aggregated fields from the table: "export_job" */
  readonly stops_database_export_job_aggregate: StopsDatabaseExportJobAggregate;
  /** fetch data from the table: "export_job" using primary key columns */
  readonly stops_database_export_job_by_pk?: Maybe<StopsDatabaseExportJob>;
  /** fetch data from the table: "fare_zone" */
  readonly stops_database_fare_zone: ReadonlyArray<StopsDatabaseFareZone>;
  /** fetch aggregated fields from the table: "fare_zone" */
  readonly stops_database_fare_zone_aggregate: StopsDatabaseFareZoneAggregate;
  /** fetch data from the table: "fare_zone" using primary key columns */
  readonly stops_database_fare_zone_by_pk?: Maybe<StopsDatabaseFareZone>;
  /** fetch data from the table: "fare_zone_key_values" */
  readonly stops_database_fare_zone_key_values: ReadonlyArray<StopsDatabaseFareZoneKeyValues>;
  /** fetch aggregated fields from the table: "fare_zone_key_values" */
  readonly stops_database_fare_zone_key_values_aggregate: StopsDatabaseFareZoneKeyValuesAggregate;
  /** fetch data from the table: "fare_zone_key_values" using primary key columns */
  readonly stops_database_fare_zone_key_values_by_pk?: Maybe<StopsDatabaseFareZoneKeyValues>;
  /** fetch data from the table: "fare_zone_members" */
  readonly stops_database_fare_zone_members: ReadonlyArray<StopsDatabaseFareZoneMembers>;
  /** fetch aggregated fields from the table: "fare_zone_members" */
  readonly stops_database_fare_zone_members_aggregate: StopsDatabaseFareZoneMembersAggregate;
  /** fetch data from the table: "fare_zone_neighbours" */
  readonly stops_database_fare_zone_neighbours: ReadonlyArray<StopsDatabaseFareZoneNeighbours>;
  /** fetch aggregated fields from the table: "fare_zone_neighbours" */
  readonly stops_database_fare_zone_neighbours_aggregate: StopsDatabaseFareZoneNeighboursAggregate;
  /** fetch data from the table: "geography_columns" */
  readonly stops_database_geography_columns: ReadonlyArray<StopsDatabaseGeographyColumns>;
  /** fetch aggregated fields from the table: "geography_columns" */
  readonly stops_database_geography_columns_aggregate: StopsDatabaseGeographyColumnsAggregate;
  /** fetch data from the table: "geometry_columns" */
  readonly stops_database_geometry_columns: ReadonlyArray<StopsDatabaseGeometryColumns>;
  /** fetch aggregated fields from the table: "geometry_columns" */
  readonly stops_database_geometry_columns_aggregate: StopsDatabaseGeometryColumnsAggregate;
  /** fetch data from the table: "group_of_stop_places" */
  readonly stops_database_group_of_stop_places: ReadonlyArray<StopsDatabaseGroupOfStopPlaces>;
  /** fetch aggregated fields from the table: "group_of_stop_places" */
  readonly stops_database_group_of_stop_places_aggregate: StopsDatabaseGroupOfStopPlacesAggregate;
  /** fetch data from the table: "group_of_stop_places_alternative_names" */
  readonly stops_database_group_of_stop_places_alternative_names: ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNames>;
  /** fetch aggregated fields from the table: "group_of_stop_places_alternative_names" */
  readonly stops_database_group_of_stop_places_alternative_names_aggregate: StopsDatabaseGroupOfStopPlacesAlternativeNamesAggregate;
  /** fetch data from the table: "group_of_stop_places" using primary key columns */
  readonly stops_database_group_of_stop_places_by_pk?: Maybe<StopsDatabaseGroupOfStopPlaces>;
  /** fetch data from the table: "group_of_stop_places_key_values" */
  readonly stops_database_group_of_stop_places_key_values: ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValues>;
  /** fetch aggregated fields from the table: "group_of_stop_places_key_values" */
  readonly stops_database_group_of_stop_places_key_values_aggregate: StopsDatabaseGroupOfStopPlacesKeyValuesAggregate;
  /** fetch data from the table: "group_of_stop_places_key_values" using primary key columns */
  readonly stops_database_group_of_stop_places_key_values_by_pk?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValues>;
  /** fetch data from the table: "group_of_stop_places_members" */
  readonly stops_database_group_of_stop_places_members: ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembers>;
  /** fetch aggregated fields from the table: "group_of_stop_places_members" */
  readonly stops_database_group_of_stop_places_members_aggregate: StopsDatabaseGroupOfStopPlacesMembersAggregate;
  /** fetch data from the table: "group_of_tariff_zones" */
  readonly stops_database_group_of_tariff_zones: ReadonlyArray<StopsDatabaseGroupOfTariffZones>;
  /** fetch aggregated fields from the table: "group_of_tariff_zones" */
  readonly stops_database_group_of_tariff_zones_aggregate: StopsDatabaseGroupOfTariffZonesAggregate;
  /** fetch data from the table: "group_of_tariff_zones" using primary key columns */
  readonly stops_database_group_of_tariff_zones_by_pk?: Maybe<StopsDatabaseGroupOfTariffZones>;
  /** fetch data from the table: "group_of_tariff_zones_key_values" */
  readonly stops_database_group_of_tariff_zones_key_values: ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValues>;
  /** fetch aggregated fields from the table: "group_of_tariff_zones_key_values" */
  readonly stops_database_group_of_tariff_zones_key_values_aggregate: StopsDatabaseGroupOfTariffZonesKeyValuesAggregate;
  /** fetch data from the table: "group_of_tariff_zones_key_values" using primary key columns */
  readonly stops_database_group_of_tariff_zones_key_values_by_pk?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValues>;
  /** fetch data from the table: "group_of_tariff_zones_members" */
  readonly stops_database_group_of_tariff_zones_members: ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembers>;
  /** fetch aggregated fields from the table: "group_of_tariff_zones_members" */
  readonly stops_database_group_of_tariff_zones_members_aggregate: StopsDatabaseGroupOfTariffZonesMembersAggregate;
  /** fetch data from the table: "group_of_tariff_zones_members" using primary key columns */
  readonly stops_database_group_of_tariff_zones_members_by_pk?: Maybe<StopsDatabaseGroupOfTariffZonesMembers>;
  /** fetch data from the table: "hsl_accessibility_properties" */
  readonly stops_database_hsl_accessibility_properties: ReadonlyArray<StopsDatabaseHslAccessibilityProperties>;
  /** fetch aggregated fields from the table: "hsl_accessibility_properties" */
  readonly stops_database_hsl_accessibility_properties_aggregate: StopsDatabaseHslAccessibilityPropertiesAggregate;
  /** fetch data from the table: "hsl_accessibility_properties" using primary key columns */
  readonly stops_database_hsl_accessibility_properties_by_pk?: Maybe<StopsDatabaseHslAccessibilityProperties>;
  /** fetch data from the table: "id_generator" */
  readonly stops_database_id_generator: ReadonlyArray<StopsDatabaseIdGenerator>;
  /** fetch aggregated fields from the table: "id_generator" */
  readonly stops_database_id_generator_aggregate: StopsDatabaseIdGeneratorAggregate;
  /** fetch data from the table: "info_spot" */
  readonly stops_database_info_spot: ReadonlyArray<StopsDatabaseInfoSpot>;
  /** fetch aggregated fields from the table: "info_spot" */
  readonly stops_database_info_spot_aggregate: StopsDatabaseInfoSpotAggregate;
  /** fetch data from the table: "info_spot" using primary key columns */
  readonly stops_database_info_spot_by_pk?: Maybe<StopsDatabaseInfoSpot>;
  /** fetch data from the table: "info_spot_poster" */
  readonly stops_database_info_spot_poster: ReadonlyArray<StopsDatabaseInfoSpotPoster>;
  /** fetch aggregated fields from the table: "info_spot_poster" */
  readonly stops_database_info_spot_poster_aggregate: StopsDatabaseInfoSpotPosterAggregate;
  /** fetch data from the table: "info_spot_poster" using primary key columns */
  readonly stops_database_info_spot_poster_by_pk?: Maybe<StopsDatabaseInfoSpotPoster>;
  /** fetch data from the table: "installed_equipment" */
  readonly stops_database_installed_equipment: ReadonlyArray<StopsDatabaseInstalledEquipment>;
  /** fetch aggregated fields from the table: "installed_equipment" */
  readonly stops_database_installed_equipment_aggregate: StopsDatabaseInstalledEquipmentAggregate;
  /** fetch data from the table: "installed_equipment_version_structure" */
  readonly stops_database_installed_equipment_version_structure: ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructure>;
  /** fetch aggregated fields from the table: "installed_equipment_version_structure" */
  readonly stops_database_installed_equipment_version_structure_aggregate: StopsDatabaseInstalledEquipmentVersionStructureAggregate;
  /** fetch data from the table: "installed_equipment_version_structure" using primary key columns */
  readonly stops_database_installed_equipment_version_structure_by_pk?: Maybe<StopsDatabaseInstalledEquipmentVersionStructure>;
  /** fetch data from the table: "installed_equipment_version_structure_installed_equipment" */
  readonly stops_database_installed_equipment_version_structure_installed_equipment: ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipment>;
  /** fetch aggregated fields from the table: "installed_equipment_version_structure_installed_equipment" */
  readonly stops_database_installed_equipment_version_structure_installed_equipment_aggregate: StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAggregate;
  /** fetch data from the table: "level" */
  readonly stops_database_level: ReadonlyArray<StopsDatabaseLevel>;
  /** fetch aggregated fields from the table: "level" */
  readonly stops_database_level_aggregate: StopsDatabaseLevelAggregate;
  /** fetch data from the table: "level" using primary key columns */
  readonly stops_database_level_by_pk?: Maybe<StopsDatabaseLevel>;
  /** fetch data from the table: "level_key_values" */
  readonly stops_database_level_key_values: ReadonlyArray<StopsDatabaseLevelKeyValues>;
  /** fetch aggregated fields from the table: "level_key_values" */
  readonly stops_database_level_key_values_aggregate: StopsDatabaseLevelKeyValuesAggregate;
  /** fetch data from the table: "level_key_values" using primary key columns */
  readonly stops_database_level_key_values_by_pk?: Maybe<StopsDatabaseLevelKeyValues>;
  /** fetch data from the table: "multilingual_string_entity" */
  readonly stops_database_multilingual_string_entity: ReadonlyArray<StopsDatabaseMultilingualStringEntity>;
  /** fetch aggregated fields from the table: "multilingual_string_entity" */
  readonly stops_database_multilingual_string_entity_aggregate: StopsDatabaseMultilingualStringEntityAggregate;
  /** fetch data from the table: "multilingual_string_entity" using primary key columns */
  readonly stops_database_multilingual_string_entity_by_pk?: Maybe<StopsDatabaseMultilingualStringEntity>;
  /** fetch data from the table: "navigation_path" */
  readonly stops_database_navigation_path: ReadonlyArray<StopsDatabaseNavigationPath>;
  /** fetch aggregated fields from the table: "navigation_path" */
  readonly stops_database_navigation_path_aggregate: StopsDatabaseNavigationPathAggregate;
  /** fetch data from the table: "organisation" */
  readonly stops_database_organisation: ReadonlyArray<StopsDatabaseOrganisation>;
  /** fetch aggregated fields from the table: "organisation" */
  readonly stops_database_organisation_aggregate: StopsDatabaseOrganisationAggregate;
  /** fetch data from the table: "organisation" using primary key columns */
  readonly stops_database_organisation_by_pk?: Maybe<StopsDatabaseOrganisation>;
  /** fetch data from the table: "organisation_key_values" */
  readonly stops_database_organisation_key_values: ReadonlyArray<StopsDatabaseOrganisationKeyValues>;
  /** fetch aggregated fields from the table: "organisation_key_values" */
  readonly stops_database_organisation_key_values_aggregate: StopsDatabaseOrganisationKeyValuesAggregate;
  /** fetch data from the table: "organisation_key_values" using primary key columns */
  readonly stops_database_organisation_key_values_by_pk?: Maybe<StopsDatabaseOrganisationKeyValues>;
  /** fetch data from the table: "parking" */
  readonly stops_database_parking: ReadonlyArray<StopsDatabaseParking>;
  /** fetch data from the table: "parking_adjacent_sites" */
  readonly stops_database_parking_adjacent_sites: ReadonlyArray<StopsDatabaseParkingAdjacentSites>;
  /** fetch aggregated fields from the table: "parking_adjacent_sites" */
  readonly stops_database_parking_adjacent_sites_aggregate: StopsDatabaseParkingAdjacentSitesAggregate;
  /** fetch aggregated fields from the table: "parking" */
  readonly stops_database_parking_aggregate: StopsDatabaseParkingAggregate;
  /** fetch data from the table: "parking_alternative_names" */
  readonly stops_database_parking_alternative_names: ReadonlyArray<StopsDatabaseParkingAlternativeNames>;
  /** fetch aggregated fields from the table: "parking_alternative_names" */
  readonly stops_database_parking_alternative_names_aggregate: StopsDatabaseParkingAlternativeNamesAggregate;
  /** fetch data from the table: "parking_area" */
  readonly stops_database_parking_area: ReadonlyArray<StopsDatabaseParkingArea>;
  /** fetch aggregated fields from the table: "parking_area" */
  readonly stops_database_parking_area_aggregate: StopsDatabaseParkingAreaAggregate;
  /** fetch data from the table: "parking_area_alternative_names" */
  readonly stops_database_parking_area_alternative_names: ReadonlyArray<StopsDatabaseParkingAreaAlternativeNames>;
  /** fetch aggregated fields from the table: "parking_area_alternative_names" */
  readonly stops_database_parking_area_alternative_names_aggregate: StopsDatabaseParkingAreaAlternativeNamesAggregate;
  /** fetch data from the table: "parking_area" using primary key columns */
  readonly stops_database_parking_area_by_pk?: Maybe<StopsDatabaseParkingArea>;
  /** fetch data from the table: "parking_area_check_constraints" */
  readonly stops_database_parking_area_check_constraints: ReadonlyArray<StopsDatabaseParkingAreaCheckConstraints>;
  /** fetch aggregated fields from the table: "parking_area_check_constraints" */
  readonly stops_database_parking_area_check_constraints_aggregate: StopsDatabaseParkingAreaCheckConstraintsAggregate;
  /** fetch data from the table: "parking_area_equipment_places" */
  readonly stops_database_parking_area_equipment_places: ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlaces>;
  /** fetch aggregated fields from the table: "parking_area_equipment_places" */
  readonly stops_database_parking_area_equipment_places_aggregate: StopsDatabaseParkingAreaEquipmentPlacesAggregate;
  /** fetch data from the table: "parking_area_key_values" */
  readonly stops_database_parking_area_key_values: ReadonlyArray<StopsDatabaseParkingAreaKeyValues>;
  /** fetch aggregated fields from the table: "parking_area_key_values" */
  readonly stops_database_parking_area_key_values_aggregate: StopsDatabaseParkingAreaKeyValuesAggregate;
  /** fetch data from the table: "parking_area_key_values" using primary key columns */
  readonly stops_database_parking_area_key_values_by_pk?: Maybe<StopsDatabaseParkingAreaKeyValues>;
  /** fetch data from the table: "parking" using primary key columns */
  readonly stops_database_parking_by_pk?: Maybe<StopsDatabaseParking>;
  /** fetch data from the table: "parking_capacity" */
  readonly stops_database_parking_capacity: ReadonlyArray<StopsDatabaseParkingCapacity>;
  /** fetch aggregated fields from the table: "parking_capacity" */
  readonly stops_database_parking_capacity_aggregate: StopsDatabaseParkingCapacityAggregate;
  /** fetch data from the table: "parking_capacity" using primary key columns */
  readonly stops_database_parking_capacity_by_pk?: Maybe<StopsDatabaseParkingCapacity>;
  /** fetch data from the table: "parking_equipment_places" */
  readonly stops_database_parking_equipment_places: ReadonlyArray<StopsDatabaseParkingEquipmentPlaces>;
  /** fetch aggregated fields from the table: "parking_equipment_places" */
  readonly stops_database_parking_equipment_places_aggregate: StopsDatabaseParkingEquipmentPlacesAggregate;
  /** fetch data from the table: "parking_key_values" */
  readonly stops_database_parking_key_values: ReadonlyArray<StopsDatabaseParkingKeyValues>;
  /** fetch aggregated fields from the table: "parking_key_values" */
  readonly stops_database_parking_key_values_aggregate: StopsDatabaseParkingKeyValuesAggregate;
  /** fetch data from the table: "parking_key_values" using primary key columns */
  readonly stops_database_parking_key_values_by_pk?: Maybe<StopsDatabaseParkingKeyValues>;
  /** fetch data from the table: "parking_parking_areas" */
  readonly stops_database_parking_parking_areas: ReadonlyArray<StopsDatabaseParkingParkingAreas>;
  /** fetch aggregated fields from the table: "parking_parking_areas" */
  readonly stops_database_parking_parking_areas_aggregate: StopsDatabaseParkingParkingAreasAggregate;
  /** fetch data from the table: "parking_parking_payment_process" */
  readonly stops_database_parking_parking_payment_process: ReadonlyArray<StopsDatabaseParkingParkingPaymentProcess>;
  /** fetch aggregated fields from the table: "parking_parking_payment_process" */
  readonly stops_database_parking_parking_payment_process_aggregate: StopsDatabaseParkingParkingPaymentProcessAggregate;
  /** fetch data from the table: "parking_parking_properties" */
  readonly stops_database_parking_parking_properties: ReadonlyArray<StopsDatabaseParkingParkingProperties>;
  /** fetch aggregated fields from the table: "parking_parking_properties" */
  readonly stops_database_parking_parking_properties_aggregate: StopsDatabaseParkingParkingPropertiesAggregate;
  /** fetch data from the table: "parking_parking_vehicle_types" */
  readonly stops_database_parking_parking_vehicle_types: ReadonlyArray<StopsDatabaseParkingParkingVehicleTypes>;
  /** fetch aggregated fields from the table: "parking_parking_vehicle_types" */
  readonly stops_database_parking_parking_vehicle_types_aggregate: StopsDatabaseParkingParkingVehicleTypesAggregate;
  /** fetch data from the table: "parking_properties" */
  readonly stops_database_parking_properties: ReadonlyArray<StopsDatabaseParkingProperties>;
  /** fetch aggregated fields from the table: "parking_properties" */
  readonly stops_database_parking_properties_aggregate: StopsDatabaseParkingPropertiesAggregate;
  /** fetch data from the table: "parking_properties" using primary key columns */
  readonly stops_database_parking_properties_by_pk?: Maybe<StopsDatabaseParkingProperties>;
  /** fetch data from the table: "parking_properties_parking_user_types" */
  readonly stops_database_parking_properties_parking_user_types: ReadonlyArray<StopsDatabaseParkingPropertiesParkingUserTypes>;
  /** fetch aggregated fields from the table: "parking_properties_parking_user_types" */
  readonly stops_database_parking_properties_parking_user_types_aggregate: StopsDatabaseParkingPropertiesParkingUserTypesAggregate;
  /** fetch data from the table: "parking_properties_spaces" */
  readonly stops_database_parking_properties_spaces: ReadonlyArray<StopsDatabaseParkingPropertiesSpaces>;
  /** fetch aggregated fields from the table: "parking_properties_spaces" */
  readonly stops_database_parking_properties_spaces_aggregate: StopsDatabaseParkingPropertiesSpacesAggregate;
  /** fetch data from the table: "path_junction" */
  readonly stops_database_path_junction: ReadonlyArray<StopsDatabasePathJunction>;
  /** fetch aggregated fields from the table: "path_junction" */
  readonly stops_database_path_junction_aggregate: StopsDatabasePathJunctionAggregate;
  /** fetch data from the table: "path_junction" using primary key columns */
  readonly stops_database_path_junction_by_pk?: Maybe<StopsDatabasePathJunction>;
  /** fetch data from the table: "path_junction_key_values" */
  readonly stops_database_path_junction_key_values: ReadonlyArray<StopsDatabasePathJunctionKeyValues>;
  /** fetch aggregated fields from the table: "path_junction_key_values" */
  readonly stops_database_path_junction_key_values_aggregate: StopsDatabasePathJunctionKeyValuesAggregate;
  /** fetch data from the table: "path_junction_key_values" using primary key columns */
  readonly stops_database_path_junction_key_values_by_pk?: Maybe<StopsDatabasePathJunctionKeyValues>;
  /** fetch data from the table: "path_link" */
  readonly stops_database_path_link: ReadonlyArray<StopsDatabasePathLink>;
  /** fetch aggregated fields from the table: "path_link" */
  readonly stops_database_path_link_aggregate: StopsDatabasePathLinkAggregate;
  /** fetch data from the table: "path_link" using primary key columns */
  readonly stops_database_path_link_by_pk?: Maybe<StopsDatabasePathLink>;
  /** fetch data from the table: "path_link_end" */
  readonly stops_database_path_link_end: ReadonlyArray<StopsDatabasePathLinkEnd>;
  /** fetch aggregated fields from the table: "path_link_end" */
  readonly stops_database_path_link_end_aggregate: StopsDatabasePathLinkEndAggregate;
  /** fetch data from the table: "path_link_end" using primary key columns */
  readonly stops_database_path_link_end_by_pk?: Maybe<StopsDatabasePathLinkEnd>;
  /** fetch data from the table: "path_link_key_values" */
  readonly stops_database_path_link_key_values: ReadonlyArray<StopsDatabasePathLinkKeyValues>;
  /** fetch aggregated fields from the table: "path_link_key_values" */
  readonly stops_database_path_link_key_values_aggregate: StopsDatabasePathLinkKeyValuesAggregate;
  /** fetch data from the table: "path_link_key_values" using primary key columns */
  readonly stops_database_path_link_key_values_by_pk?: Maybe<StopsDatabasePathLinkKeyValues>;
  /** fetch data from the table: "persistable_polygon" */
  readonly stops_database_persistable_polygon: ReadonlyArray<StopsDatabasePersistablePolygon>;
  /** fetch aggregated fields from the table: "persistable_polygon" */
  readonly stops_database_persistable_polygon_aggregate: StopsDatabasePersistablePolygonAggregate;
  /** fetch data from the table: "persistable_polygon" using primary key columns */
  readonly stops_database_persistable_polygon_by_pk?: Maybe<StopsDatabasePersistablePolygon>;
  /** fetch data from the table: "place_equipment" */
  readonly stops_database_place_equipment: ReadonlyArray<StopsDatabasePlaceEquipment>;
  /** fetch aggregated fields from the table: "place_equipment" */
  readonly stops_database_place_equipment_aggregate: StopsDatabasePlaceEquipmentAggregate;
  /** fetch data from the table: "purpose_of_grouping" */
  readonly stops_database_purpose_of_grouping: ReadonlyArray<StopsDatabasePurposeOfGrouping>;
  /** fetch aggregated fields from the table: "purpose_of_grouping" */
  readonly stops_database_purpose_of_grouping_aggregate: StopsDatabasePurposeOfGroupingAggregate;
  /** fetch data from the table: "purpose_of_grouping" using primary key columns */
  readonly stops_database_purpose_of_grouping_by_pk?: Maybe<StopsDatabasePurposeOfGrouping>;
  /** fetch data from the table: "purpose_of_grouping_key_values" */
  readonly stops_database_purpose_of_grouping_key_values: ReadonlyArray<StopsDatabasePurposeOfGroupingKeyValues>;
  /** fetch aggregated fields from the table: "purpose_of_grouping_key_values" */
  readonly stops_database_purpose_of_grouping_key_values_aggregate: StopsDatabasePurposeOfGroupingKeyValuesAggregate;
  /** fetch data from the table: "purpose_of_grouping_key_values" using primary key columns */
  readonly stops_database_purpose_of_grouping_key_values_by_pk?: Maybe<StopsDatabasePurposeOfGroupingKeyValues>;
  /** fetch data from the table: "quay" */
  readonly stops_database_quay: ReadonlyArray<StopsDatabaseQuay>;
  /** fetch aggregated fields from the table: "quay" */
  readonly stops_database_quay_aggregate: StopsDatabaseQuayAggregate;
  /** fetch data from the table: "quay_alternative_names" */
  readonly stops_database_quay_alternative_names: ReadonlyArray<StopsDatabaseQuayAlternativeNames>;
  /** fetch aggregated fields from the table: "quay_alternative_names" */
  readonly stops_database_quay_alternative_names_aggregate: StopsDatabaseQuayAlternativeNamesAggregate;
  /** fetch data from the table: "quay_boarding_positions" */
  readonly stops_database_quay_boarding_positions: ReadonlyArray<StopsDatabaseQuayBoardingPositions>;
  /** fetch aggregated fields from the table: "quay_boarding_positions" */
  readonly stops_database_quay_boarding_positions_aggregate: StopsDatabaseQuayBoardingPositionsAggregate;
  /** fetch data from the table: "quay" using primary key columns */
  readonly stops_database_quay_by_pk?: Maybe<StopsDatabaseQuay>;
  /** fetch data from the table: "quay_check_constraints" */
  readonly stops_database_quay_check_constraints: ReadonlyArray<StopsDatabaseQuayCheckConstraints>;
  /** fetch aggregated fields from the table: "quay_check_constraints" */
  readonly stops_database_quay_check_constraints_aggregate: StopsDatabaseQuayCheckConstraintsAggregate;
  /** fetch data from the table: "quay_equipment_places" */
  readonly stops_database_quay_equipment_places: ReadonlyArray<StopsDatabaseQuayEquipmentPlaces>;
  /** fetch aggregated fields from the table: "quay_equipment_places" */
  readonly stops_database_quay_equipment_places_aggregate: StopsDatabaseQuayEquipmentPlacesAggregate;
  /** fetch data from the table: "quay_key_values" */
  readonly stops_database_quay_key_values: ReadonlyArray<StopsDatabaseQuayKeyValues>;
  /** fetch aggregated fields from the table: "quay_key_values" */
  readonly stops_database_quay_key_values_aggregate: StopsDatabaseQuayKeyValuesAggregate;
  /** fetch data from the table: "quay_key_values" using primary key columns */
  readonly stops_database_quay_key_values_by_pk?: Maybe<StopsDatabaseQuayKeyValues>;
  /** fetch data from the table: "quay_newest_version" */
  readonly stops_database_quay_newest_version: ReadonlyArray<StopsDatabaseQuayNewestVersion>;
  /** fetch aggregated fields from the table: "quay_newest_version" */
  readonly stops_database_quay_newest_version_aggregate: StopsDatabaseQuayNewestVersionAggregate;
  /** fetch data from the table: "schema_version" */
  readonly stops_database_schema_version: ReadonlyArray<StopsDatabaseSchemaVersion>;
  /** fetch aggregated fields from the table: "schema_version" */
  readonly stops_database_schema_version_aggregate: StopsDatabaseSchemaVersionAggregate;
  /** fetch data from the table: "schema_version" using primary key columns */
  readonly stops_database_schema_version_by_pk?: Maybe<StopsDatabaseSchemaVersion>;
  /** fetch data from the table: "spatial_ref_sys" */
  readonly stops_database_spatial_ref_sys: ReadonlyArray<StopsDatabaseSpatialRefSys>;
  /** fetch aggregated fields from the table: "spatial_ref_sys" */
  readonly stops_database_spatial_ref_sys_aggregate: StopsDatabaseSpatialRefSysAggregate;
  /** fetch data from the table: "spatial_ref_sys" using primary key columns */
  readonly stops_database_spatial_ref_sys_by_pk?: Maybe<StopsDatabaseSpatialRefSys>;
  /** fetch data from the table: "stop_place" */
  readonly stops_database_stop_place: ReadonlyArray<StopsDatabaseStopPlace>;
  /** fetch data from the table: "stop_place_access_spaces" */
  readonly stops_database_stop_place_access_spaces: ReadonlyArray<StopsDatabaseStopPlaceAccessSpaces>;
  /** fetch aggregated fields from the table: "stop_place_access_spaces" */
  readonly stops_database_stop_place_access_spaces_aggregate: StopsDatabaseStopPlaceAccessSpacesAggregate;
  /** fetch data from the table: "stop_place_adjacent_sites" */
  readonly stops_database_stop_place_adjacent_sites: ReadonlyArray<StopsDatabaseStopPlaceAdjacentSites>;
  /** fetch aggregated fields from the table: "stop_place_adjacent_sites" */
  readonly stops_database_stop_place_adjacent_sites_aggregate: StopsDatabaseStopPlaceAdjacentSitesAggregate;
  /** fetch aggregated fields from the table: "stop_place" */
  readonly stops_database_stop_place_aggregate: StopsDatabaseStopPlaceAggregate;
  /** fetch data from the table: "stop_place_alternative_names" */
  readonly stops_database_stop_place_alternative_names: ReadonlyArray<StopsDatabaseStopPlaceAlternativeNames>;
  /** fetch aggregated fields from the table: "stop_place_alternative_names" */
  readonly stops_database_stop_place_alternative_names_aggregate: StopsDatabaseStopPlaceAlternativeNamesAggregate;
  /** fetch data from the table: "stop_place" using primary key columns */
  readonly stops_database_stop_place_by_pk?: Maybe<StopsDatabaseStopPlace>;
  /** fetch data from the table: "stop_place_children" */
  readonly stops_database_stop_place_children: ReadonlyArray<StopsDatabaseStopPlaceChildren>;
  /** fetch aggregated fields from the table: "stop_place_children" */
  readonly stops_database_stop_place_children_aggregate: StopsDatabaseStopPlaceChildrenAggregate;
  /** fetch data from the table: "stop_place_children" using primary key columns */
  readonly stops_database_stop_place_children_by_pk?: Maybe<StopsDatabaseStopPlaceChildren>;
  /** fetch data from the table: "stop_place_equipment_places" */
  readonly stops_database_stop_place_equipment_places: ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlaces>;
  /** fetch aggregated fields from the table: "stop_place_equipment_places" */
  readonly stops_database_stop_place_equipment_places_aggregate: StopsDatabaseStopPlaceEquipmentPlacesAggregate;
  /** fetch data from the table: "stop_place_key_values" */
  readonly stops_database_stop_place_key_values: ReadonlyArray<StopsDatabaseStopPlaceKeyValues>;
  /** fetch aggregated fields from the table: "stop_place_key_values" */
  readonly stops_database_stop_place_key_values_aggregate: StopsDatabaseStopPlaceKeyValuesAggregate;
  /** fetch data from the table: "stop_place_key_values" using primary key columns */
  readonly stops_database_stop_place_key_values_by_pk?: Maybe<StopsDatabaseStopPlaceKeyValues>;
  /** fetch data from the table: "stop_place_newest_version" */
  readonly stops_database_stop_place_newest_version: ReadonlyArray<StopsDatabaseStopPlaceNewestVersion>;
  /** fetch aggregated fields from the table: "stop_place_newest_version" */
  readonly stops_database_stop_place_newest_version_aggregate: StopsDatabaseStopPlaceNewestVersionAggregate;
  /** fetch data from the table: "stop_place_organisations" */
  readonly stops_database_stop_place_organisations: ReadonlyArray<StopsDatabaseStopPlaceOrganisations>;
  /** fetch aggregated fields from the table: "stop_place_organisations" */
  readonly stops_database_stop_place_organisations_aggregate: StopsDatabaseStopPlaceOrganisationsAggregate;
  /** fetch data from the table: "stop_place_organisations" using primary key columns */
  readonly stops_database_stop_place_organisations_by_pk?: Maybe<StopsDatabaseStopPlaceOrganisations>;
  /** fetch data from the table: "stop_place_quays" */
  readonly stops_database_stop_place_quays: ReadonlyArray<StopsDatabaseStopPlaceQuays>;
  /** fetch aggregated fields from the table: "stop_place_quays" */
  readonly stops_database_stop_place_quays_aggregate: StopsDatabaseStopPlaceQuaysAggregate;
  /** fetch data from the table: "stop_place_quays" using primary key columns */
  readonly stops_database_stop_place_quays_by_pk?: Maybe<StopsDatabaseStopPlaceQuays>;
  /** fetch data from the table: "stop_place_tariff_zones" */
  readonly stops_database_stop_place_tariff_zones: ReadonlyArray<StopsDatabaseStopPlaceTariffZones>;
  /** fetch aggregated fields from the table: "stop_place_tariff_zones" */
  readonly stops_database_stop_place_tariff_zones_aggregate: StopsDatabaseStopPlaceTariffZonesAggregate;
  /** fetch data from the table: "tag" */
  readonly stops_database_tag: ReadonlyArray<StopsDatabaseTag>;
  /** fetch aggregated fields from the table: "tag" */
  readonly stops_database_tag_aggregate: StopsDatabaseTagAggregate;
  /** fetch data from the table: "tag" using primary key columns */
  readonly stops_database_tag_by_pk?: Maybe<StopsDatabaseTag>;
  /** fetch data from the table: "tariff_zone" */
  readonly stops_database_tariff_zone: ReadonlyArray<StopsDatabaseTariffZone>;
  /** fetch aggregated fields from the table: "tariff_zone" */
  readonly stops_database_tariff_zone_aggregate: StopsDatabaseTariffZoneAggregate;
  /** fetch data from the table: "tariff_zone" using primary key columns */
  readonly stops_database_tariff_zone_by_pk?: Maybe<StopsDatabaseTariffZone>;
  /** fetch data from the table: "tariff_zone_key_values" */
  readonly stops_database_tariff_zone_key_values: ReadonlyArray<StopsDatabaseTariffZoneKeyValues>;
  /** fetch aggregated fields from the table: "tariff_zone_key_values" */
  readonly stops_database_tariff_zone_key_values_aggregate: StopsDatabaseTariffZoneKeyValuesAggregate;
  /** fetch data from the table: "tariff_zone_key_values" using primary key columns */
  readonly stops_database_tariff_zone_key_values_by_pk?: Maybe<StopsDatabaseTariffZoneKeyValues>;
  /** fetch data from the table: "topographic_place" */
  readonly stops_database_topographic_place: ReadonlyArray<StopsDatabaseTopographicPlace>;
  /** fetch aggregated fields from the table: "topographic_place" */
  readonly stops_database_topographic_place_aggregate: StopsDatabaseTopographicPlaceAggregate;
  /** fetch data from the table: "topographic_place" using primary key columns */
  readonly stops_database_topographic_place_by_pk?: Maybe<StopsDatabaseTopographicPlace>;
  /** fetch data from the table: "topographic_place_key_values" */
  readonly stops_database_topographic_place_key_values: ReadonlyArray<StopsDatabaseTopographicPlaceKeyValues>;
  /** fetch aggregated fields from the table: "topographic_place_key_values" */
  readonly stops_database_topographic_place_key_values_aggregate: StopsDatabaseTopographicPlaceKeyValuesAggregate;
  /** fetch data from the table: "topographic_place_key_values" using primary key columns */
  readonly stops_database_topographic_place_key_values_by_pk?: Maybe<StopsDatabaseTopographicPlaceKeyValues>;
  /** fetch data from the table: "value" */
  readonly stops_database_value: ReadonlyArray<StopsDatabaseValue>;
  /** fetch aggregated fields from the table: "value" */
  readonly stops_database_value_aggregate: StopsDatabaseValueAggregate;
  /** fetch data from the table: "value" using primary key columns */
  readonly stops_database_value_by_pk?: Maybe<StopsDatabaseValue>;
  /** fetch data from the table: "value_items" */
  readonly stops_database_value_items: ReadonlyArray<StopsDatabaseValueItems>;
  /** fetch aggregated fields from the table: "value_items" */
  readonly stops_database_value_items_aggregate: StopsDatabaseValueItemsAggregate;
};


export type StopsDatabaseStopsDatabaseQueryFindStopsForTerminalArgs = {
  args: FindStopsForTerminalArguments;
  distinct_on?: InputMaybe<ReadonlyArray<TerminalStopSearchResultEnumName>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTerminalStopSearchResultOrderBy>>;
  where?: InputMaybe<StopsDatabaseTerminalStopSearchResultBoolExpBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessSpaceArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessSpaceAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessSpaceAlternativeNamesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessSpaceAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessSpaceByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessSpaceCheckConstraintsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceCheckConstraintsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceCheckConstraintsOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessSpaceCheckConstraintsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceCheckConstraintsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceCheckConstraintsOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessSpaceEquipmentPlacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessSpaceEquipmentPlacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessSpaceKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessSpaceKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessSpaceKeyValuesByPkArgs = {
  access_space_id: Scalars['bigint']['input'];
  key_values_key: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessibilityAssessmentArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessibilityAssessmentBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessibilityAssessmentAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessibilityAssessmentBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessibilityAssessmentByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessibilityAssessmentLimitationsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitationsOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessibilityAssessmentLimitationsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitationsOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessibilityLimitationArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityLimitationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityLimitationOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessibilityLimitationBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessibilityLimitationAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityLimitationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityLimitationOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessibilityLimitationBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAccessibilityLimitationByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAlternativeNameArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAlternativeNameSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAlternativeNameOrderBy>>;
  where?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAlternativeNameAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAlternativeNameSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAlternativeNameOrderBy>>;
  where?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseAlternativeNameByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseBoardingPositionArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseBoardingPositionAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseBoardingPositionAlternativeNamesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseBoardingPositionAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseBoardingPositionByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseBoardingPositionCheckConstraintsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionCheckConstraintsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionCheckConstraintsOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseBoardingPositionCheckConstraintsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionCheckConstraintsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionCheckConstraintsOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseBoardingPositionEquipmentPlacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseBoardingPositionEquipmentPlacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseBoardingPositionKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseBoardingPositionKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseBoardingPositionKeyValuesByPkArgs = {
  boarding_position_id: Scalars['bigint']['input'];
  key_values_key: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseCheckConstraintArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseCheckConstraintSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseCheckConstraintOrderBy>>;
  where?: InputMaybe<StopsDatabaseCheckConstraintBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseCheckConstraintAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseCheckConstraintSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseCheckConstraintOrderBy>>;
  where?: InputMaybe<StopsDatabaseCheckConstraintBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseCheckConstraintByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseCheckConstraintKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseCheckConstraintKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseCheckConstraintKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseCheckConstraintKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseCheckConstraintKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseCheckConstraintKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseCheckConstraintKeyValuesByPkArgs = {
  check_constraint_id: Scalars['bigint']['input'];
  key_values_key: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseContactArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseContactSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseContactOrderBy>>;
  where?: InputMaybe<StopsDatabaseContactBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseContactAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseContactSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseContactOrderBy>>;
  where?: InputMaybe<StopsDatabaseContactBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseContactByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseDestinationDisplayViewArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseDestinationDisplayViewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseDestinationDisplayViewOrderBy>>;
  where?: InputMaybe<StopsDatabaseDestinationDisplayViewBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseDestinationDisplayViewAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseDestinationDisplayViewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseDestinationDisplayViewOrderBy>>;
  where?: InputMaybe<StopsDatabaseDestinationDisplayViewBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseDestinationDisplayViewByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPlaceArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPlaceAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPlaceByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPlaceEquipmentPositionsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositionsOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPlaceEquipmentPositionsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositionsOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPlaceKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPlaceKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPlaceKeyValuesByPkArgs = {
  equipment_place_id: Scalars['bigint']['input'];
  key_values_key: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPositionArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPositionBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPositionAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPositionBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPositionByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPositionKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPositionKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseEquipmentPositionKeyValuesByPkArgs = {
  equipment_position_id: Scalars['bigint']['input'];
  key_values_key: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseExportJobArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseExportJobSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseExportJobOrderBy>>;
  where?: InputMaybe<StopsDatabaseExportJobBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseExportJobAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseExportJobSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseExportJobOrderBy>>;
  where?: InputMaybe<StopsDatabaseExportJobBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseExportJobByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseFareZoneArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseFareZoneAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseFareZoneByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseFareZoneKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseFareZoneKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseFareZoneKeyValuesByPkArgs = {
  fare_zone_id: Scalars['bigint']['input'];
  key_values_key: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseFareZoneMembersArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneMembersOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneMembersBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseFareZoneMembersAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneMembersOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneMembersBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseFareZoneNeighboursArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneNeighboursSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneNeighboursOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneNeighboursBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseFareZoneNeighboursAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneNeighboursSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneNeighboursOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneNeighboursBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGeographyColumnsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGeographyColumnsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGeographyColumnsOrderBy>>;
  where?: InputMaybe<StopsDatabaseGeographyColumnsBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGeographyColumnsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGeographyColumnsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGeographyColumnsOrderBy>>;
  where?: InputMaybe<StopsDatabaseGeographyColumnsBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGeometryColumnsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGeometryColumnsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGeometryColumnsOrderBy>>;
  where?: InputMaybe<StopsDatabaseGeometryColumnsBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGeometryColumnsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGeometryColumnsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGeometryColumnsOrderBy>>;
  where?: InputMaybe<StopsDatabaseGeometryColumnsBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfStopPlacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfStopPlacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfStopPlacesAlternativeNamesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfStopPlacesAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfStopPlacesByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfStopPlacesKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfStopPlacesKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfStopPlacesKeyValuesByPkArgs = {
  group_of_stop_places_id: Scalars['bigint']['input'];
  key_values_key: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfStopPlacesMembersArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembersOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfStopPlacesMembersAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembersOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfTariffZonesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfTariffZonesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfTariffZonesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfTariffZonesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfTariffZonesByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfTariffZonesKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfTariffZonesKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfTariffZonesKeyValuesByPkArgs = {
  group_of_tariff_zones_id: Scalars['bigint']['input'];
  key_values_key: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfTariffZonesMembersArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembersOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfTariffZonesMembersAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembersOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseGroupOfTariffZonesMembersByPkArgs = {
  group_of_tariff_zones_id: Scalars['bigint']['input'];
  ref: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseHslAccessibilityPropertiesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseHslAccessibilityPropertiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseHslAccessibilityPropertiesOrderBy>>;
  where?: InputMaybe<StopsDatabaseHslAccessibilityPropertiesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseHslAccessibilityPropertiesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseHslAccessibilityPropertiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseHslAccessibilityPropertiesOrderBy>>;
  where?: InputMaybe<StopsDatabaseHslAccessibilityPropertiesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseHslAccessibilityPropertiesByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseIdGeneratorArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseIdGeneratorSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseIdGeneratorOrderBy>>;
  where?: InputMaybe<StopsDatabaseIdGeneratorBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseIdGeneratorAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseIdGeneratorSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseIdGeneratorOrderBy>>;
  where?: InputMaybe<StopsDatabaseIdGeneratorBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseInfoSpotArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseInfoSpotSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseInfoSpotOrderBy>>;
  where?: InputMaybe<StopsDatabaseInfoSpotBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseInfoSpotAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseInfoSpotSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseInfoSpotOrderBy>>;
  where?: InputMaybe<StopsDatabaseInfoSpotBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseInfoSpotByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseInfoSpotPosterArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseInfoSpotPosterSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseInfoSpotPosterOrderBy>>;
  where?: InputMaybe<StopsDatabaseInfoSpotPosterBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseInfoSpotPosterAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseInfoSpotPosterSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseInfoSpotPosterOrderBy>>;
  where?: InputMaybe<StopsDatabaseInfoSpotPosterBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseInfoSpotPosterByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseInstalledEquipmentArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentOrderBy>>;
  where?: InputMaybe<StopsDatabaseInstalledEquipmentBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseInstalledEquipmentAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentOrderBy>>;
  where?: InputMaybe<StopsDatabaseInstalledEquipmentBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseInstalledEquipmentVersionStructureArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureOrderBy>>;
  where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseInstalledEquipmentVersionStructureAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureOrderBy>>;
  where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseInstalledEquipmentVersionStructureByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentOrderBy>>;
  where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentOrderBy>>;
  where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseLevelArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseLevelSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseLevelOrderBy>>;
  where?: InputMaybe<StopsDatabaseLevelBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseLevelAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseLevelSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseLevelOrderBy>>;
  where?: InputMaybe<StopsDatabaseLevelBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseLevelByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseLevelKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseLevelKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseLevelKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseLevelKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseLevelKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseLevelKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseLevelKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseLevelKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseLevelKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  level_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseMultilingualStringEntityArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseMultilingualStringEntitySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseMultilingualStringEntityOrderBy>>;
  where?: InputMaybe<StopsDatabaseMultilingualStringEntityBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseMultilingualStringEntityAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseMultilingualStringEntitySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseMultilingualStringEntityOrderBy>>;
  where?: InputMaybe<StopsDatabaseMultilingualStringEntityBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseMultilingualStringEntityByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseNavigationPathArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseNavigationPathSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseNavigationPathOrderBy>>;
  where?: InputMaybe<StopsDatabaseNavigationPathBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseNavigationPathAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseNavigationPathSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseNavigationPathOrderBy>>;
  where?: InputMaybe<StopsDatabaseNavigationPathBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseOrganisationArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseOrganisationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseOrganisationOrderBy>>;
  where?: InputMaybe<StopsDatabaseOrganisationBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseOrganisationAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseOrganisationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseOrganisationOrderBy>>;
  where?: InputMaybe<StopsDatabaseOrganisationBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseOrganisationByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseOrganisationKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseOrganisationKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseOrganisationKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseOrganisationKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseOrganisationKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseOrganisationKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseOrganisationKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseOrganisationKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseOrganisationKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  organisation_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAdjacentSitesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAdjacentSitesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAdjacentSitesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAdjacentSitesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAdjacentSitesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAdjacentSitesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAdjacentSitesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAdjacentSitesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAlternativeNamesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAreaArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAreaAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAreaAlternativeNamesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAreaAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAreaByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAreaCheckConstraintsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaCheckConstraintsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaCheckConstraintsOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAreaCheckConstraintsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaCheckConstraintsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaCheckConstraintsOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAreaEquipmentPlacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAreaEquipmentPlacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAreaKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAreaKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingAreaKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  parking_area_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingCapacityArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingCapacitySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingCapacityOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingCapacityBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingCapacityAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingCapacitySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingCapacityOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingCapacityBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingCapacityByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingEquipmentPlacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingEquipmentPlacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  parking_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingParkingAreasArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingAreasSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingAreasOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingAreasBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingParkingAreasAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingAreasSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingAreasOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingAreasBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingParkingPaymentProcessArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPaymentProcessSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPaymentProcessOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingParkingPaymentProcessAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPaymentProcessSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPaymentProcessOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingParkingPropertiesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPropertiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPropertiesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingPropertiesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingParkingPropertiesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPropertiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPropertiesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingPropertiesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingParkingVehicleTypesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingVehicleTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingVehicleTypesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingParkingVehicleTypesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingVehicleTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingVehicleTypesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingPropertiesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingPropertiesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingPropertiesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingPropertiesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingPropertiesByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingPropertiesParkingUserTypesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesParkingUserTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesParkingUserTypesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingPropertiesParkingUserTypesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingPropertiesParkingUserTypesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesParkingUserTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesParkingUserTypesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingPropertiesParkingUserTypesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingPropertiesSpacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesSpacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesSpacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingPropertiesSpacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseParkingPropertiesSpacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesSpacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesSpacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingPropertiesSpacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathJunctionArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePathJunctionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePathJunctionOrderBy>>;
  where?: InputMaybe<StopsDatabasePathJunctionBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathJunctionAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePathJunctionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePathJunctionOrderBy>>;
  where?: InputMaybe<StopsDatabasePathJunctionBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathJunctionByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathJunctionKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePathJunctionKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePathJunctionKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabasePathJunctionKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathJunctionKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePathJunctionKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePathJunctionKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabasePathJunctionKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathJunctionKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  path_junction_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathLinkArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkOrderBy>>;
  where?: InputMaybe<StopsDatabasePathLinkBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathLinkAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkOrderBy>>;
  where?: InputMaybe<StopsDatabasePathLinkBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathLinkByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathLinkEndArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkEndSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkEndOrderBy>>;
  where?: InputMaybe<StopsDatabasePathLinkEndBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathLinkEndAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkEndSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkEndOrderBy>>;
  where?: InputMaybe<StopsDatabasePathLinkEndBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathLinkEndByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathLinkKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabasePathLinkKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathLinkKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabasePathLinkKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePathLinkKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  path_link_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePersistablePolygonArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePersistablePolygonSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePersistablePolygonOrderBy>>;
  where?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePersistablePolygonAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePersistablePolygonSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePersistablePolygonOrderBy>>;
  where?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePersistablePolygonByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePlaceEquipmentArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePlaceEquipmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePlaceEquipmentOrderBy>>;
  where?: InputMaybe<StopsDatabasePlaceEquipmentBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePlaceEquipmentAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePlaceEquipmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePlaceEquipmentOrderBy>>;
  where?: InputMaybe<StopsDatabasePlaceEquipmentBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePurposeOfGroupingArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePurposeOfGroupingSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePurposeOfGroupingOrderBy>>;
  where?: InputMaybe<StopsDatabasePurposeOfGroupingBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePurposeOfGroupingAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePurposeOfGroupingSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePurposeOfGroupingOrderBy>>;
  where?: InputMaybe<StopsDatabasePurposeOfGroupingBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePurposeOfGroupingByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePurposeOfGroupingKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePurposeOfGroupingKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePurposeOfGroupingKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePurposeOfGroupingKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePurposeOfGroupingKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePurposeOfGroupingKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabasePurposeOfGroupingKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  purpose_of_grouping_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuaySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuaySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayAlternativeNamesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayBoardingPositionsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayBoardingPositionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayBoardingPositionsOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayBoardingPositionsBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayBoardingPositionsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayBoardingPositionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayBoardingPositionsOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayBoardingPositionsBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayCheckConstraintsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayCheckConstraintsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayCheckConstraintsOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayCheckConstraintsBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayCheckConstraintsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayCheckConstraintsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayCheckConstraintsOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayCheckConstraintsBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayEquipmentPlacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayEquipmentPlacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  quay_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayNewestVersionArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayNewestVersionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayNewestVersionOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayNewestVersionBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseQuayNewestVersionAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayNewestVersionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayNewestVersionOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayNewestVersionBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseSchemaVersionArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseSchemaVersionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseSchemaVersionOrderBy>>;
  where?: InputMaybe<StopsDatabaseSchemaVersionBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseSchemaVersionAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseSchemaVersionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseSchemaVersionOrderBy>>;
  where?: InputMaybe<StopsDatabaseSchemaVersionBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseSchemaVersionByPkArgs = {
  installed_rank: Scalars['Int']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseSpatialRefSysArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseSpatialRefSysSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseSpatialRefSysOrderBy>>;
  where?: InputMaybe<StopsDatabaseSpatialRefSysBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseSpatialRefSysAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseSpatialRefSysSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseSpatialRefSysOrderBy>>;
  where?: InputMaybe<StopsDatabaseSpatialRefSysBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseSpatialRefSysByPkArgs = {
  srid: Scalars['Int']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceAccessSpacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAccessSpacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAccessSpacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceAccessSpacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAccessSpacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAccessSpacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceAdjacentSitesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAdjacentSitesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAdjacentSitesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAdjacentSitesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceAdjacentSitesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAdjacentSitesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAdjacentSitesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAdjacentSitesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceAlternativeNamesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceChildrenArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceChildrenSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceChildrenOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceChildrenAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceChildrenSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceChildrenOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceChildrenByPkArgs = {
  children_id: Scalars['bigint']['input'];
  stop_place_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceEquipmentPlacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceEquipmentPlacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  stop_place_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceNewestVersionArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceNewestVersionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceNewestVersionOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceNewestVersionBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceNewestVersionAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceNewestVersionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceNewestVersionOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceNewestVersionBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceOrganisationsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceOrganisationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceOrganisationsOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceOrganisationsBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceOrganisationsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceOrganisationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceOrganisationsOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceOrganisationsBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceOrganisationsByPkArgs = {
  organisation_ref: Scalars['String']['input'];
  relationship_type: Scalars['String']['input'];
  stop_place_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceQuaysArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceQuaysSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceQuaysOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceQuaysBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceQuaysAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceQuaysSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceQuaysOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceQuaysBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceQuaysByPkArgs = {
  quays_id: Scalars['bigint']['input'];
  stop_place_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceTariffZonesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceTariffZonesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceTariffZonesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceTariffZonesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseStopPlaceTariffZonesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceTariffZonesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceTariffZonesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceTariffZonesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTagArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseTagSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTagOrderBy>>;
  where?: InputMaybe<StopsDatabaseTagBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTagAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseTagSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTagOrderBy>>;
  where?: InputMaybe<StopsDatabaseTagBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTagByPkArgs = {
  name: Scalars['String']['input'];
  netex_reference: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTariffZoneArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneOrderBy>>;
  where?: InputMaybe<StopsDatabaseTariffZoneBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTariffZoneAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneOrderBy>>;
  where?: InputMaybe<StopsDatabaseTariffZoneBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTariffZoneByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTariffZoneKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseTariffZoneKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTariffZoneKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseTariffZoneKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTariffZoneKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  tariff_zone_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTopographicPlaceArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceOrderBy>>;
  where?: InputMaybe<StopsDatabaseTopographicPlaceBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTopographicPlaceAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceOrderBy>>;
  where?: InputMaybe<StopsDatabaseTopographicPlaceBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTopographicPlaceByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTopographicPlaceKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTopographicPlaceKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseTopographicPlaceKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  topographic_place_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseValueArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseValueSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseValueOrderBy>>;
  where?: InputMaybe<StopsDatabaseValueBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseValueAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseValueSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseValueOrderBy>>;
  where?: InputMaybe<StopsDatabaseValueBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseValueByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseValueItemsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseValueItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseValueItemsOrderBy>>;
  where?: InputMaybe<StopsDatabaseValueItemsBoolExp>;
};


export type StopsDatabaseStopsDatabaseQueryStopsDatabaseValueItemsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseValueItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseValueItemsOrderBy>>;
  where?: InputMaybe<StopsDatabaseValueItemsBoolExp>;
};

export type StopsDatabaseStopsDatabaseSubscription = {
  readonly __typename?: 'stops_database_stops_database_subscription';
  readonly findStopsForTerminal: ReadonlyArray<TerminalStopSearchResult>;
  /** fetch data from the table: "access_space" */
  readonly stops_database_access_space: ReadonlyArray<StopsDatabaseAccessSpace>;
  /** fetch aggregated fields from the table: "access_space" */
  readonly stops_database_access_space_aggregate: StopsDatabaseAccessSpaceAggregate;
  /** fetch data from the table: "access_space_alternative_names" */
  readonly stops_database_access_space_alternative_names: ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNames>;
  /** fetch aggregated fields from the table: "access_space_alternative_names" */
  readonly stops_database_access_space_alternative_names_aggregate: StopsDatabaseAccessSpaceAlternativeNamesAggregate;
  /** fetch data from the table in a streaming manner: "access_space_alternative_names" */
  readonly stops_database_access_space_alternative_names_stream: ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNames>;
  /** fetch data from the table: "access_space" using primary key columns */
  readonly stops_database_access_space_by_pk?: Maybe<StopsDatabaseAccessSpace>;
  /** fetch data from the table: "access_space_check_constraints" */
  readonly stops_database_access_space_check_constraints: ReadonlyArray<StopsDatabaseAccessSpaceCheckConstraints>;
  /** fetch aggregated fields from the table: "access_space_check_constraints" */
  readonly stops_database_access_space_check_constraints_aggregate: StopsDatabaseAccessSpaceCheckConstraintsAggregate;
  /** fetch data from the table in a streaming manner: "access_space_check_constraints" */
  readonly stops_database_access_space_check_constraints_stream: ReadonlyArray<StopsDatabaseAccessSpaceCheckConstraints>;
  /** fetch data from the table: "access_space_equipment_places" */
  readonly stops_database_access_space_equipment_places: ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlaces>;
  /** fetch aggregated fields from the table: "access_space_equipment_places" */
  readonly stops_database_access_space_equipment_places_aggregate: StopsDatabaseAccessSpaceEquipmentPlacesAggregate;
  /** fetch data from the table in a streaming manner: "access_space_equipment_places" */
  readonly stops_database_access_space_equipment_places_stream: ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlaces>;
  /** fetch data from the table: "access_space_key_values" */
  readonly stops_database_access_space_key_values: ReadonlyArray<StopsDatabaseAccessSpaceKeyValues>;
  /** fetch aggregated fields from the table: "access_space_key_values" */
  readonly stops_database_access_space_key_values_aggregate: StopsDatabaseAccessSpaceKeyValuesAggregate;
  /** fetch data from the table: "access_space_key_values" using primary key columns */
  readonly stops_database_access_space_key_values_by_pk?: Maybe<StopsDatabaseAccessSpaceKeyValues>;
  /** fetch data from the table in a streaming manner: "access_space_key_values" */
  readonly stops_database_access_space_key_values_stream: ReadonlyArray<StopsDatabaseAccessSpaceKeyValues>;
  /** fetch data from the table in a streaming manner: "access_space" */
  readonly stops_database_access_space_stream: ReadonlyArray<StopsDatabaseAccessSpace>;
  /** fetch data from the table: "accessibility_assessment" */
  readonly stops_database_accessibility_assessment: ReadonlyArray<StopsDatabaseAccessibilityAssessment>;
  /** fetch aggregated fields from the table: "accessibility_assessment" */
  readonly stops_database_accessibility_assessment_aggregate: StopsDatabaseAccessibilityAssessmentAggregate;
  /** fetch data from the table: "accessibility_assessment" using primary key columns */
  readonly stops_database_accessibility_assessment_by_pk?: Maybe<StopsDatabaseAccessibilityAssessment>;
  /** fetch data from the table: "accessibility_assessment_limitations" */
  readonly stops_database_accessibility_assessment_limitations: ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitations>;
  /** fetch aggregated fields from the table: "accessibility_assessment_limitations" */
  readonly stops_database_accessibility_assessment_limitations_aggregate: StopsDatabaseAccessibilityAssessmentLimitationsAggregate;
  /** fetch data from the table in a streaming manner: "accessibility_assessment_limitations" */
  readonly stops_database_accessibility_assessment_limitations_stream: ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitations>;
  /** fetch data from the table in a streaming manner: "accessibility_assessment" */
  readonly stops_database_accessibility_assessment_stream: ReadonlyArray<StopsDatabaseAccessibilityAssessment>;
  /** fetch data from the table: "accessibility_limitation" */
  readonly stops_database_accessibility_limitation: ReadonlyArray<StopsDatabaseAccessibilityLimitation>;
  /** fetch aggregated fields from the table: "accessibility_limitation" */
  readonly stops_database_accessibility_limitation_aggregate: StopsDatabaseAccessibilityLimitationAggregate;
  /** fetch data from the table: "accessibility_limitation" using primary key columns */
  readonly stops_database_accessibility_limitation_by_pk?: Maybe<StopsDatabaseAccessibilityLimitation>;
  /** fetch data from the table in a streaming manner: "accessibility_limitation" */
  readonly stops_database_accessibility_limitation_stream: ReadonlyArray<StopsDatabaseAccessibilityLimitation>;
  /** fetch data from the table: "alternative_name" */
  readonly stops_database_alternative_name: ReadonlyArray<StopsDatabaseAlternativeName>;
  /** fetch aggregated fields from the table: "alternative_name" */
  readonly stops_database_alternative_name_aggregate: StopsDatabaseAlternativeNameAggregate;
  /** fetch data from the table: "alternative_name" using primary key columns */
  readonly stops_database_alternative_name_by_pk?: Maybe<StopsDatabaseAlternativeName>;
  /** fetch data from the table in a streaming manner: "alternative_name" */
  readonly stops_database_alternative_name_stream: ReadonlyArray<StopsDatabaseAlternativeName>;
  /** fetch data from the table: "boarding_position" */
  readonly stops_database_boarding_position: ReadonlyArray<StopsDatabaseBoardingPosition>;
  /** fetch aggregated fields from the table: "boarding_position" */
  readonly stops_database_boarding_position_aggregate: StopsDatabaseBoardingPositionAggregate;
  /** fetch data from the table: "boarding_position_alternative_names" */
  readonly stops_database_boarding_position_alternative_names: ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNames>;
  /** fetch aggregated fields from the table: "boarding_position_alternative_names" */
  readonly stops_database_boarding_position_alternative_names_aggregate: StopsDatabaseBoardingPositionAlternativeNamesAggregate;
  /** fetch data from the table in a streaming manner: "boarding_position_alternative_names" */
  readonly stops_database_boarding_position_alternative_names_stream: ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNames>;
  /** fetch data from the table: "boarding_position" using primary key columns */
  readonly stops_database_boarding_position_by_pk?: Maybe<StopsDatabaseBoardingPosition>;
  /** fetch data from the table: "boarding_position_check_constraints" */
  readonly stops_database_boarding_position_check_constraints: ReadonlyArray<StopsDatabaseBoardingPositionCheckConstraints>;
  /** fetch aggregated fields from the table: "boarding_position_check_constraints" */
  readonly stops_database_boarding_position_check_constraints_aggregate: StopsDatabaseBoardingPositionCheckConstraintsAggregate;
  /** fetch data from the table in a streaming manner: "boarding_position_check_constraints" */
  readonly stops_database_boarding_position_check_constraints_stream: ReadonlyArray<StopsDatabaseBoardingPositionCheckConstraints>;
  /** fetch data from the table: "boarding_position_equipment_places" */
  readonly stops_database_boarding_position_equipment_places: ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlaces>;
  /** fetch aggregated fields from the table: "boarding_position_equipment_places" */
  readonly stops_database_boarding_position_equipment_places_aggregate: StopsDatabaseBoardingPositionEquipmentPlacesAggregate;
  /** fetch data from the table in a streaming manner: "boarding_position_equipment_places" */
  readonly stops_database_boarding_position_equipment_places_stream: ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlaces>;
  /** fetch data from the table: "boarding_position_key_values" */
  readonly stops_database_boarding_position_key_values: ReadonlyArray<StopsDatabaseBoardingPositionKeyValues>;
  /** fetch aggregated fields from the table: "boarding_position_key_values" */
  readonly stops_database_boarding_position_key_values_aggregate: StopsDatabaseBoardingPositionKeyValuesAggregate;
  /** fetch data from the table: "boarding_position_key_values" using primary key columns */
  readonly stops_database_boarding_position_key_values_by_pk?: Maybe<StopsDatabaseBoardingPositionKeyValues>;
  /** fetch data from the table in a streaming manner: "boarding_position_key_values" */
  readonly stops_database_boarding_position_key_values_stream: ReadonlyArray<StopsDatabaseBoardingPositionKeyValues>;
  /** fetch data from the table in a streaming manner: "boarding_position" */
  readonly stops_database_boarding_position_stream: ReadonlyArray<StopsDatabaseBoardingPosition>;
  /** fetch data from the table: "check_constraint" */
  readonly stops_database_check_constraint: ReadonlyArray<StopsDatabaseCheckConstraint>;
  /** fetch aggregated fields from the table: "check_constraint" */
  readonly stops_database_check_constraint_aggregate: StopsDatabaseCheckConstraintAggregate;
  /** fetch data from the table: "check_constraint" using primary key columns */
  readonly stops_database_check_constraint_by_pk?: Maybe<StopsDatabaseCheckConstraint>;
  /** fetch data from the table: "check_constraint_key_values" */
  readonly stops_database_check_constraint_key_values: ReadonlyArray<StopsDatabaseCheckConstraintKeyValues>;
  /** fetch aggregated fields from the table: "check_constraint_key_values" */
  readonly stops_database_check_constraint_key_values_aggregate: StopsDatabaseCheckConstraintKeyValuesAggregate;
  /** fetch data from the table: "check_constraint_key_values" using primary key columns */
  readonly stops_database_check_constraint_key_values_by_pk?: Maybe<StopsDatabaseCheckConstraintKeyValues>;
  /** fetch data from the table in a streaming manner: "check_constraint_key_values" */
  readonly stops_database_check_constraint_key_values_stream: ReadonlyArray<StopsDatabaseCheckConstraintKeyValues>;
  /** fetch data from the table in a streaming manner: "check_constraint" */
  readonly stops_database_check_constraint_stream: ReadonlyArray<StopsDatabaseCheckConstraint>;
  /** fetch data from the table: "contact" */
  readonly stops_database_contact: ReadonlyArray<StopsDatabaseContact>;
  /** fetch aggregated fields from the table: "contact" */
  readonly stops_database_contact_aggregate: StopsDatabaseContactAggregate;
  /** fetch data from the table: "contact" using primary key columns */
  readonly stops_database_contact_by_pk?: Maybe<StopsDatabaseContact>;
  /** fetch data from the table in a streaming manner: "contact" */
  readonly stops_database_contact_stream: ReadonlyArray<StopsDatabaseContact>;
  /** fetch data from the table: "destination_display_view" */
  readonly stops_database_destination_display_view: ReadonlyArray<StopsDatabaseDestinationDisplayView>;
  /** fetch aggregated fields from the table: "destination_display_view" */
  readonly stops_database_destination_display_view_aggregate: StopsDatabaseDestinationDisplayViewAggregate;
  /** fetch data from the table: "destination_display_view" using primary key columns */
  readonly stops_database_destination_display_view_by_pk?: Maybe<StopsDatabaseDestinationDisplayView>;
  /** fetch data from the table in a streaming manner: "destination_display_view" */
  readonly stops_database_destination_display_view_stream: ReadonlyArray<StopsDatabaseDestinationDisplayView>;
  /** fetch data from the table: "equipment_place" */
  readonly stops_database_equipment_place: ReadonlyArray<StopsDatabaseEquipmentPlace>;
  /** fetch aggregated fields from the table: "equipment_place" */
  readonly stops_database_equipment_place_aggregate: StopsDatabaseEquipmentPlaceAggregate;
  /** fetch data from the table: "equipment_place" using primary key columns */
  readonly stops_database_equipment_place_by_pk?: Maybe<StopsDatabaseEquipmentPlace>;
  /** fetch data from the table: "equipment_place_equipment_positions" */
  readonly stops_database_equipment_place_equipment_positions: ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositions>;
  /** fetch aggregated fields from the table: "equipment_place_equipment_positions" */
  readonly stops_database_equipment_place_equipment_positions_aggregate: StopsDatabaseEquipmentPlaceEquipmentPositionsAggregate;
  /** fetch data from the table in a streaming manner: "equipment_place_equipment_positions" */
  readonly stops_database_equipment_place_equipment_positions_stream: ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositions>;
  /** fetch data from the table: "equipment_place_key_values" */
  readonly stops_database_equipment_place_key_values: ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValues>;
  /** fetch aggregated fields from the table: "equipment_place_key_values" */
  readonly stops_database_equipment_place_key_values_aggregate: StopsDatabaseEquipmentPlaceKeyValuesAggregate;
  /** fetch data from the table: "equipment_place_key_values" using primary key columns */
  readonly stops_database_equipment_place_key_values_by_pk?: Maybe<StopsDatabaseEquipmentPlaceKeyValues>;
  /** fetch data from the table in a streaming manner: "equipment_place_key_values" */
  readonly stops_database_equipment_place_key_values_stream: ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValues>;
  /** fetch data from the table in a streaming manner: "equipment_place" */
  readonly stops_database_equipment_place_stream: ReadonlyArray<StopsDatabaseEquipmentPlace>;
  /** fetch data from the table: "equipment_position" */
  readonly stops_database_equipment_position: ReadonlyArray<StopsDatabaseEquipmentPosition>;
  /** fetch aggregated fields from the table: "equipment_position" */
  readonly stops_database_equipment_position_aggregate: StopsDatabaseEquipmentPositionAggregate;
  /** fetch data from the table: "equipment_position" using primary key columns */
  readonly stops_database_equipment_position_by_pk?: Maybe<StopsDatabaseEquipmentPosition>;
  /** fetch data from the table: "equipment_position_key_values" */
  readonly stops_database_equipment_position_key_values: ReadonlyArray<StopsDatabaseEquipmentPositionKeyValues>;
  /** fetch aggregated fields from the table: "equipment_position_key_values" */
  readonly stops_database_equipment_position_key_values_aggregate: StopsDatabaseEquipmentPositionKeyValuesAggregate;
  /** fetch data from the table: "equipment_position_key_values" using primary key columns */
  readonly stops_database_equipment_position_key_values_by_pk?: Maybe<StopsDatabaseEquipmentPositionKeyValues>;
  /** fetch data from the table in a streaming manner: "equipment_position_key_values" */
  readonly stops_database_equipment_position_key_values_stream: ReadonlyArray<StopsDatabaseEquipmentPositionKeyValues>;
  /** fetch data from the table in a streaming manner: "equipment_position" */
  readonly stops_database_equipment_position_stream: ReadonlyArray<StopsDatabaseEquipmentPosition>;
  /** fetch data from the table: "export_job" */
  readonly stops_database_export_job: ReadonlyArray<StopsDatabaseExportJob>;
  /** fetch aggregated fields from the table: "export_job" */
  readonly stops_database_export_job_aggregate: StopsDatabaseExportJobAggregate;
  /** fetch data from the table: "export_job" using primary key columns */
  readonly stops_database_export_job_by_pk?: Maybe<StopsDatabaseExportJob>;
  /** fetch data from the table in a streaming manner: "export_job" */
  readonly stops_database_export_job_stream: ReadonlyArray<StopsDatabaseExportJob>;
  /** fetch data from the table: "fare_zone" */
  readonly stops_database_fare_zone: ReadonlyArray<StopsDatabaseFareZone>;
  /** fetch aggregated fields from the table: "fare_zone" */
  readonly stops_database_fare_zone_aggregate: StopsDatabaseFareZoneAggregate;
  /** fetch data from the table: "fare_zone" using primary key columns */
  readonly stops_database_fare_zone_by_pk?: Maybe<StopsDatabaseFareZone>;
  /** fetch data from the table: "fare_zone_key_values" */
  readonly stops_database_fare_zone_key_values: ReadonlyArray<StopsDatabaseFareZoneKeyValues>;
  /** fetch aggregated fields from the table: "fare_zone_key_values" */
  readonly stops_database_fare_zone_key_values_aggregate: StopsDatabaseFareZoneKeyValuesAggregate;
  /** fetch data from the table: "fare_zone_key_values" using primary key columns */
  readonly stops_database_fare_zone_key_values_by_pk?: Maybe<StopsDatabaseFareZoneKeyValues>;
  /** fetch data from the table in a streaming manner: "fare_zone_key_values" */
  readonly stops_database_fare_zone_key_values_stream: ReadonlyArray<StopsDatabaseFareZoneKeyValues>;
  /** fetch data from the table: "fare_zone_members" */
  readonly stops_database_fare_zone_members: ReadonlyArray<StopsDatabaseFareZoneMembers>;
  /** fetch aggregated fields from the table: "fare_zone_members" */
  readonly stops_database_fare_zone_members_aggregate: StopsDatabaseFareZoneMembersAggregate;
  /** fetch data from the table in a streaming manner: "fare_zone_members" */
  readonly stops_database_fare_zone_members_stream: ReadonlyArray<StopsDatabaseFareZoneMembers>;
  /** fetch data from the table: "fare_zone_neighbours" */
  readonly stops_database_fare_zone_neighbours: ReadonlyArray<StopsDatabaseFareZoneNeighbours>;
  /** fetch aggregated fields from the table: "fare_zone_neighbours" */
  readonly stops_database_fare_zone_neighbours_aggregate: StopsDatabaseFareZoneNeighboursAggregate;
  /** fetch data from the table in a streaming manner: "fare_zone_neighbours" */
  readonly stops_database_fare_zone_neighbours_stream: ReadonlyArray<StopsDatabaseFareZoneNeighbours>;
  /** fetch data from the table in a streaming manner: "fare_zone" */
  readonly stops_database_fare_zone_stream: ReadonlyArray<StopsDatabaseFareZone>;
  /** fetch data from the table: "geography_columns" */
  readonly stops_database_geography_columns: ReadonlyArray<StopsDatabaseGeographyColumns>;
  /** fetch aggregated fields from the table: "geography_columns" */
  readonly stops_database_geography_columns_aggregate: StopsDatabaseGeographyColumnsAggregate;
  /** fetch data from the table in a streaming manner: "geography_columns" */
  readonly stops_database_geography_columns_stream: ReadonlyArray<StopsDatabaseGeographyColumns>;
  /** fetch data from the table: "geometry_columns" */
  readonly stops_database_geometry_columns: ReadonlyArray<StopsDatabaseGeometryColumns>;
  /** fetch aggregated fields from the table: "geometry_columns" */
  readonly stops_database_geometry_columns_aggregate: StopsDatabaseGeometryColumnsAggregate;
  /** fetch data from the table in a streaming manner: "geometry_columns" */
  readonly stops_database_geometry_columns_stream: ReadonlyArray<StopsDatabaseGeometryColumns>;
  /** fetch data from the table: "group_of_stop_places" */
  readonly stops_database_group_of_stop_places: ReadonlyArray<StopsDatabaseGroupOfStopPlaces>;
  /** fetch aggregated fields from the table: "group_of_stop_places" */
  readonly stops_database_group_of_stop_places_aggregate: StopsDatabaseGroupOfStopPlacesAggregate;
  /** fetch data from the table: "group_of_stop_places_alternative_names" */
  readonly stops_database_group_of_stop_places_alternative_names: ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNames>;
  /** fetch aggregated fields from the table: "group_of_stop_places_alternative_names" */
  readonly stops_database_group_of_stop_places_alternative_names_aggregate: StopsDatabaseGroupOfStopPlacesAlternativeNamesAggregate;
  /** fetch data from the table in a streaming manner: "group_of_stop_places_alternative_names" */
  readonly stops_database_group_of_stop_places_alternative_names_stream: ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNames>;
  /** fetch data from the table: "group_of_stop_places" using primary key columns */
  readonly stops_database_group_of_stop_places_by_pk?: Maybe<StopsDatabaseGroupOfStopPlaces>;
  /** fetch data from the table: "group_of_stop_places_key_values" */
  readonly stops_database_group_of_stop_places_key_values: ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValues>;
  /** fetch aggregated fields from the table: "group_of_stop_places_key_values" */
  readonly stops_database_group_of_stop_places_key_values_aggregate: StopsDatabaseGroupOfStopPlacesKeyValuesAggregate;
  /** fetch data from the table: "group_of_stop_places_key_values" using primary key columns */
  readonly stops_database_group_of_stop_places_key_values_by_pk?: Maybe<StopsDatabaseGroupOfStopPlacesKeyValues>;
  /** fetch data from the table in a streaming manner: "group_of_stop_places_key_values" */
  readonly stops_database_group_of_stop_places_key_values_stream: ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValues>;
  /** fetch data from the table: "group_of_stop_places_members" */
  readonly stops_database_group_of_stop_places_members: ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembers>;
  /** fetch aggregated fields from the table: "group_of_stop_places_members" */
  readonly stops_database_group_of_stop_places_members_aggregate: StopsDatabaseGroupOfStopPlacesMembersAggregate;
  /** fetch data from the table in a streaming manner: "group_of_stop_places_members" */
  readonly stops_database_group_of_stop_places_members_stream: ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembers>;
  /** fetch data from the table in a streaming manner: "group_of_stop_places" */
  readonly stops_database_group_of_stop_places_stream: ReadonlyArray<StopsDatabaseGroupOfStopPlaces>;
  /** fetch data from the table: "group_of_tariff_zones" */
  readonly stops_database_group_of_tariff_zones: ReadonlyArray<StopsDatabaseGroupOfTariffZones>;
  /** fetch aggregated fields from the table: "group_of_tariff_zones" */
  readonly stops_database_group_of_tariff_zones_aggregate: StopsDatabaseGroupOfTariffZonesAggregate;
  /** fetch data from the table: "group_of_tariff_zones" using primary key columns */
  readonly stops_database_group_of_tariff_zones_by_pk?: Maybe<StopsDatabaseGroupOfTariffZones>;
  /** fetch data from the table: "group_of_tariff_zones_key_values" */
  readonly stops_database_group_of_tariff_zones_key_values: ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValues>;
  /** fetch aggregated fields from the table: "group_of_tariff_zones_key_values" */
  readonly stops_database_group_of_tariff_zones_key_values_aggregate: StopsDatabaseGroupOfTariffZonesKeyValuesAggregate;
  /** fetch data from the table: "group_of_tariff_zones_key_values" using primary key columns */
  readonly stops_database_group_of_tariff_zones_key_values_by_pk?: Maybe<StopsDatabaseGroupOfTariffZonesKeyValues>;
  /** fetch data from the table in a streaming manner: "group_of_tariff_zones_key_values" */
  readonly stops_database_group_of_tariff_zones_key_values_stream: ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValues>;
  /** fetch data from the table: "group_of_tariff_zones_members" */
  readonly stops_database_group_of_tariff_zones_members: ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembers>;
  /** fetch aggregated fields from the table: "group_of_tariff_zones_members" */
  readonly stops_database_group_of_tariff_zones_members_aggregate: StopsDatabaseGroupOfTariffZonesMembersAggregate;
  /** fetch data from the table: "group_of_tariff_zones_members" using primary key columns */
  readonly stops_database_group_of_tariff_zones_members_by_pk?: Maybe<StopsDatabaseGroupOfTariffZonesMembers>;
  /** fetch data from the table in a streaming manner: "group_of_tariff_zones_members" */
  readonly stops_database_group_of_tariff_zones_members_stream: ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembers>;
  /** fetch data from the table in a streaming manner: "group_of_tariff_zones" */
  readonly stops_database_group_of_tariff_zones_stream: ReadonlyArray<StopsDatabaseGroupOfTariffZones>;
  /** fetch data from the table: "hsl_accessibility_properties" */
  readonly stops_database_hsl_accessibility_properties: ReadonlyArray<StopsDatabaseHslAccessibilityProperties>;
  /** fetch aggregated fields from the table: "hsl_accessibility_properties" */
  readonly stops_database_hsl_accessibility_properties_aggregate: StopsDatabaseHslAccessibilityPropertiesAggregate;
  /** fetch data from the table: "hsl_accessibility_properties" using primary key columns */
  readonly stops_database_hsl_accessibility_properties_by_pk?: Maybe<StopsDatabaseHslAccessibilityProperties>;
  /** fetch data from the table in a streaming manner: "hsl_accessibility_properties" */
  readonly stops_database_hsl_accessibility_properties_stream: ReadonlyArray<StopsDatabaseHslAccessibilityProperties>;
  /** fetch data from the table: "id_generator" */
  readonly stops_database_id_generator: ReadonlyArray<StopsDatabaseIdGenerator>;
  /** fetch aggregated fields from the table: "id_generator" */
  readonly stops_database_id_generator_aggregate: StopsDatabaseIdGeneratorAggregate;
  /** fetch data from the table in a streaming manner: "id_generator" */
  readonly stops_database_id_generator_stream: ReadonlyArray<StopsDatabaseIdGenerator>;
  /** fetch data from the table: "info_spot" */
  readonly stops_database_info_spot: ReadonlyArray<StopsDatabaseInfoSpot>;
  /** fetch aggregated fields from the table: "info_spot" */
  readonly stops_database_info_spot_aggregate: StopsDatabaseInfoSpotAggregate;
  /** fetch data from the table: "info_spot" using primary key columns */
  readonly stops_database_info_spot_by_pk?: Maybe<StopsDatabaseInfoSpot>;
  /** fetch data from the table: "info_spot_poster" */
  readonly stops_database_info_spot_poster: ReadonlyArray<StopsDatabaseInfoSpotPoster>;
  /** fetch aggregated fields from the table: "info_spot_poster" */
  readonly stops_database_info_spot_poster_aggregate: StopsDatabaseInfoSpotPosterAggregate;
  /** fetch data from the table: "info_spot_poster" using primary key columns */
  readonly stops_database_info_spot_poster_by_pk?: Maybe<StopsDatabaseInfoSpotPoster>;
  /** fetch data from the table in a streaming manner: "info_spot_poster" */
  readonly stops_database_info_spot_poster_stream: ReadonlyArray<StopsDatabaseInfoSpotPoster>;
  /** fetch data from the table in a streaming manner: "info_spot" */
  readonly stops_database_info_spot_stream: ReadonlyArray<StopsDatabaseInfoSpot>;
  /** fetch data from the table: "installed_equipment" */
  readonly stops_database_installed_equipment: ReadonlyArray<StopsDatabaseInstalledEquipment>;
  /** fetch aggregated fields from the table: "installed_equipment" */
  readonly stops_database_installed_equipment_aggregate: StopsDatabaseInstalledEquipmentAggregate;
  /** fetch data from the table in a streaming manner: "installed_equipment" */
  readonly stops_database_installed_equipment_stream: ReadonlyArray<StopsDatabaseInstalledEquipment>;
  /** fetch data from the table: "installed_equipment_version_structure" */
  readonly stops_database_installed_equipment_version_structure: ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructure>;
  /** fetch aggregated fields from the table: "installed_equipment_version_structure" */
  readonly stops_database_installed_equipment_version_structure_aggregate: StopsDatabaseInstalledEquipmentVersionStructureAggregate;
  /** fetch data from the table: "installed_equipment_version_structure" using primary key columns */
  readonly stops_database_installed_equipment_version_structure_by_pk?: Maybe<StopsDatabaseInstalledEquipmentVersionStructure>;
  /** fetch data from the table: "installed_equipment_version_structure_installed_equipment" */
  readonly stops_database_installed_equipment_version_structure_installed_equipment: ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipment>;
  /** fetch aggregated fields from the table: "installed_equipment_version_structure_installed_equipment" */
  readonly stops_database_installed_equipment_version_structure_installed_equipment_aggregate: StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAggregate;
  /** fetch data from the table in a streaming manner: "installed_equipment_version_structure_installed_equipment" */
  readonly stops_database_installed_equipment_version_structure_installed_equipment_stream: ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipment>;
  /** fetch data from the table in a streaming manner: "installed_equipment_version_structure" */
  readonly stops_database_installed_equipment_version_structure_stream: ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructure>;
  /** fetch data from the table: "level" */
  readonly stops_database_level: ReadonlyArray<StopsDatabaseLevel>;
  /** fetch aggregated fields from the table: "level" */
  readonly stops_database_level_aggregate: StopsDatabaseLevelAggregate;
  /** fetch data from the table: "level" using primary key columns */
  readonly stops_database_level_by_pk?: Maybe<StopsDatabaseLevel>;
  /** fetch data from the table: "level_key_values" */
  readonly stops_database_level_key_values: ReadonlyArray<StopsDatabaseLevelKeyValues>;
  /** fetch aggregated fields from the table: "level_key_values" */
  readonly stops_database_level_key_values_aggregate: StopsDatabaseLevelKeyValuesAggregate;
  /** fetch data from the table: "level_key_values" using primary key columns */
  readonly stops_database_level_key_values_by_pk?: Maybe<StopsDatabaseLevelKeyValues>;
  /** fetch data from the table in a streaming manner: "level_key_values" */
  readonly stops_database_level_key_values_stream: ReadonlyArray<StopsDatabaseLevelKeyValues>;
  /** fetch data from the table in a streaming manner: "level" */
  readonly stops_database_level_stream: ReadonlyArray<StopsDatabaseLevel>;
  /** fetch data from the table: "multilingual_string_entity" */
  readonly stops_database_multilingual_string_entity: ReadonlyArray<StopsDatabaseMultilingualStringEntity>;
  /** fetch aggregated fields from the table: "multilingual_string_entity" */
  readonly stops_database_multilingual_string_entity_aggregate: StopsDatabaseMultilingualStringEntityAggregate;
  /** fetch data from the table: "multilingual_string_entity" using primary key columns */
  readonly stops_database_multilingual_string_entity_by_pk?: Maybe<StopsDatabaseMultilingualStringEntity>;
  /** fetch data from the table in a streaming manner: "multilingual_string_entity" */
  readonly stops_database_multilingual_string_entity_stream: ReadonlyArray<StopsDatabaseMultilingualStringEntity>;
  /** fetch data from the table: "navigation_path" */
  readonly stops_database_navigation_path: ReadonlyArray<StopsDatabaseNavigationPath>;
  /** fetch aggregated fields from the table: "navigation_path" */
  readonly stops_database_navigation_path_aggregate: StopsDatabaseNavigationPathAggregate;
  /** fetch data from the table in a streaming manner: "navigation_path" */
  readonly stops_database_navigation_path_stream: ReadonlyArray<StopsDatabaseNavigationPath>;
  /** fetch data from the table: "organisation" */
  readonly stops_database_organisation: ReadonlyArray<StopsDatabaseOrganisation>;
  /** fetch aggregated fields from the table: "organisation" */
  readonly stops_database_organisation_aggregate: StopsDatabaseOrganisationAggregate;
  /** fetch data from the table: "organisation" using primary key columns */
  readonly stops_database_organisation_by_pk?: Maybe<StopsDatabaseOrganisation>;
  /** fetch data from the table: "organisation_key_values" */
  readonly stops_database_organisation_key_values: ReadonlyArray<StopsDatabaseOrganisationKeyValues>;
  /** fetch aggregated fields from the table: "organisation_key_values" */
  readonly stops_database_organisation_key_values_aggregate: StopsDatabaseOrganisationKeyValuesAggregate;
  /** fetch data from the table: "organisation_key_values" using primary key columns */
  readonly stops_database_organisation_key_values_by_pk?: Maybe<StopsDatabaseOrganisationKeyValues>;
  /** fetch data from the table in a streaming manner: "organisation_key_values" */
  readonly stops_database_organisation_key_values_stream: ReadonlyArray<StopsDatabaseOrganisationKeyValues>;
  /** fetch data from the table in a streaming manner: "organisation" */
  readonly stops_database_organisation_stream: ReadonlyArray<StopsDatabaseOrganisation>;
  /** fetch data from the table: "parking" */
  readonly stops_database_parking: ReadonlyArray<StopsDatabaseParking>;
  /** fetch data from the table: "parking_adjacent_sites" */
  readonly stops_database_parking_adjacent_sites: ReadonlyArray<StopsDatabaseParkingAdjacentSites>;
  /** fetch aggregated fields from the table: "parking_adjacent_sites" */
  readonly stops_database_parking_adjacent_sites_aggregate: StopsDatabaseParkingAdjacentSitesAggregate;
  /** fetch data from the table in a streaming manner: "parking_adjacent_sites" */
  readonly stops_database_parking_adjacent_sites_stream: ReadonlyArray<StopsDatabaseParkingAdjacentSites>;
  /** fetch aggregated fields from the table: "parking" */
  readonly stops_database_parking_aggregate: StopsDatabaseParkingAggregate;
  /** fetch data from the table: "parking_alternative_names" */
  readonly stops_database_parking_alternative_names: ReadonlyArray<StopsDatabaseParkingAlternativeNames>;
  /** fetch aggregated fields from the table: "parking_alternative_names" */
  readonly stops_database_parking_alternative_names_aggregate: StopsDatabaseParkingAlternativeNamesAggregate;
  /** fetch data from the table in a streaming manner: "parking_alternative_names" */
  readonly stops_database_parking_alternative_names_stream: ReadonlyArray<StopsDatabaseParkingAlternativeNames>;
  /** fetch data from the table: "parking_area" */
  readonly stops_database_parking_area: ReadonlyArray<StopsDatabaseParkingArea>;
  /** fetch aggregated fields from the table: "parking_area" */
  readonly stops_database_parking_area_aggregate: StopsDatabaseParkingAreaAggregate;
  /** fetch data from the table: "parking_area_alternative_names" */
  readonly stops_database_parking_area_alternative_names: ReadonlyArray<StopsDatabaseParkingAreaAlternativeNames>;
  /** fetch aggregated fields from the table: "parking_area_alternative_names" */
  readonly stops_database_parking_area_alternative_names_aggregate: StopsDatabaseParkingAreaAlternativeNamesAggregate;
  /** fetch data from the table in a streaming manner: "parking_area_alternative_names" */
  readonly stops_database_parking_area_alternative_names_stream: ReadonlyArray<StopsDatabaseParkingAreaAlternativeNames>;
  /** fetch data from the table: "parking_area" using primary key columns */
  readonly stops_database_parking_area_by_pk?: Maybe<StopsDatabaseParkingArea>;
  /** fetch data from the table: "parking_area_check_constraints" */
  readonly stops_database_parking_area_check_constraints: ReadonlyArray<StopsDatabaseParkingAreaCheckConstraints>;
  /** fetch aggregated fields from the table: "parking_area_check_constraints" */
  readonly stops_database_parking_area_check_constraints_aggregate: StopsDatabaseParkingAreaCheckConstraintsAggregate;
  /** fetch data from the table in a streaming manner: "parking_area_check_constraints" */
  readonly stops_database_parking_area_check_constraints_stream: ReadonlyArray<StopsDatabaseParkingAreaCheckConstraints>;
  /** fetch data from the table: "parking_area_equipment_places" */
  readonly stops_database_parking_area_equipment_places: ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlaces>;
  /** fetch aggregated fields from the table: "parking_area_equipment_places" */
  readonly stops_database_parking_area_equipment_places_aggregate: StopsDatabaseParkingAreaEquipmentPlacesAggregate;
  /** fetch data from the table in a streaming manner: "parking_area_equipment_places" */
  readonly stops_database_parking_area_equipment_places_stream: ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlaces>;
  /** fetch data from the table: "parking_area_key_values" */
  readonly stops_database_parking_area_key_values: ReadonlyArray<StopsDatabaseParkingAreaKeyValues>;
  /** fetch aggregated fields from the table: "parking_area_key_values" */
  readonly stops_database_parking_area_key_values_aggregate: StopsDatabaseParkingAreaKeyValuesAggregate;
  /** fetch data from the table: "parking_area_key_values" using primary key columns */
  readonly stops_database_parking_area_key_values_by_pk?: Maybe<StopsDatabaseParkingAreaKeyValues>;
  /** fetch data from the table in a streaming manner: "parking_area_key_values" */
  readonly stops_database_parking_area_key_values_stream: ReadonlyArray<StopsDatabaseParkingAreaKeyValues>;
  /** fetch data from the table in a streaming manner: "parking_area" */
  readonly stops_database_parking_area_stream: ReadonlyArray<StopsDatabaseParkingArea>;
  /** fetch data from the table: "parking" using primary key columns */
  readonly stops_database_parking_by_pk?: Maybe<StopsDatabaseParking>;
  /** fetch data from the table: "parking_capacity" */
  readonly stops_database_parking_capacity: ReadonlyArray<StopsDatabaseParkingCapacity>;
  /** fetch aggregated fields from the table: "parking_capacity" */
  readonly stops_database_parking_capacity_aggregate: StopsDatabaseParkingCapacityAggregate;
  /** fetch data from the table: "parking_capacity" using primary key columns */
  readonly stops_database_parking_capacity_by_pk?: Maybe<StopsDatabaseParkingCapacity>;
  /** fetch data from the table in a streaming manner: "parking_capacity" */
  readonly stops_database_parking_capacity_stream: ReadonlyArray<StopsDatabaseParkingCapacity>;
  /** fetch data from the table: "parking_equipment_places" */
  readonly stops_database_parking_equipment_places: ReadonlyArray<StopsDatabaseParkingEquipmentPlaces>;
  /** fetch aggregated fields from the table: "parking_equipment_places" */
  readonly stops_database_parking_equipment_places_aggregate: StopsDatabaseParkingEquipmentPlacesAggregate;
  /** fetch data from the table in a streaming manner: "parking_equipment_places" */
  readonly stops_database_parking_equipment_places_stream: ReadonlyArray<StopsDatabaseParkingEquipmentPlaces>;
  /** fetch data from the table: "parking_key_values" */
  readonly stops_database_parking_key_values: ReadonlyArray<StopsDatabaseParkingKeyValues>;
  /** fetch aggregated fields from the table: "parking_key_values" */
  readonly stops_database_parking_key_values_aggregate: StopsDatabaseParkingKeyValuesAggregate;
  /** fetch data from the table: "parking_key_values" using primary key columns */
  readonly stops_database_parking_key_values_by_pk?: Maybe<StopsDatabaseParkingKeyValues>;
  /** fetch data from the table in a streaming manner: "parking_key_values" */
  readonly stops_database_parking_key_values_stream: ReadonlyArray<StopsDatabaseParkingKeyValues>;
  /** fetch data from the table: "parking_parking_areas" */
  readonly stops_database_parking_parking_areas: ReadonlyArray<StopsDatabaseParkingParkingAreas>;
  /** fetch aggregated fields from the table: "parking_parking_areas" */
  readonly stops_database_parking_parking_areas_aggregate: StopsDatabaseParkingParkingAreasAggregate;
  /** fetch data from the table in a streaming manner: "parking_parking_areas" */
  readonly stops_database_parking_parking_areas_stream: ReadonlyArray<StopsDatabaseParkingParkingAreas>;
  /** fetch data from the table: "parking_parking_payment_process" */
  readonly stops_database_parking_parking_payment_process: ReadonlyArray<StopsDatabaseParkingParkingPaymentProcess>;
  /** fetch aggregated fields from the table: "parking_parking_payment_process" */
  readonly stops_database_parking_parking_payment_process_aggregate: StopsDatabaseParkingParkingPaymentProcessAggregate;
  /** fetch data from the table in a streaming manner: "parking_parking_payment_process" */
  readonly stops_database_parking_parking_payment_process_stream: ReadonlyArray<StopsDatabaseParkingParkingPaymentProcess>;
  /** fetch data from the table: "parking_parking_properties" */
  readonly stops_database_parking_parking_properties: ReadonlyArray<StopsDatabaseParkingParkingProperties>;
  /** fetch aggregated fields from the table: "parking_parking_properties" */
  readonly stops_database_parking_parking_properties_aggregate: StopsDatabaseParkingParkingPropertiesAggregate;
  /** fetch data from the table in a streaming manner: "parking_parking_properties" */
  readonly stops_database_parking_parking_properties_stream: ReadonlyArray<StopsDatabaseParkingParkingProperties>;
  /** fetch data from the table: "parking_parking_vehicle_types" */
  readonly stops_database_parking_parking_vehicle_types: ReadonlyArray<StopsDatabaseParkingParkingVehicleTypes>;
  /** fetch aggregated fields from the table: "parking_parking_vehicle_types" */
  readonly stops_database_parking_parking_vehicle_types_aggregate: StopsDatabaseParkingParkingVehicleTypesAggregate;
  /** fetch data from the table in a streaming manner: "parking_parking_vehicle_types" */
  readonly stops_database_parking_parking_vehicle_types_stream: ReadonlyArray<StopsDatabaseParkingParkingVehicleTypes>;
  /** fetch data from the table: "parking_properties" */
  readonly stops_database_parking_properties: ReadonlyArray<StopsDatabaseParkingProperties>;
  /** fetch aggregated fields from the table: "parking_properties" */
  readonly stops_database_parking_properties_aggregate: StopsDatabaseParkingPropertiesAggregate;
  /** fetch data from the table: "parking_properties" using primary key columns */
  readonly stops_database_parking_properties_by_pk?: Maybe<StopsDatabaseParkingProperties>;
  /** fetch data from the table: "parking_properties_parking_user_types" */
  readonly stops_database_parking_properties_parking_user_types: ReadonlyArray<StopsDatabaseParkingPropertiesParkingUserTypes>;
  /** fetch aggregated fields from the table: "parking_properties_parking_user_types" */
  readonly stops_database_parking_properties_parking_user_types_aggregate: StopsDatabaseParkingPropertiesParkingUserTypesAggregate;
  /** fetch data from the table in a streaming manner: "parking_properties_parking_user_types" */
  readonly stops_database_parking_properties_parking_user_types_stream: ReadonlyArray<StopsDatabaseParkingPropertiesParkingUserTypes>;
  /** fetch data from the table: "parking_properties_spaces" */
  readonly stops_database_parking_properties_spaces: ReadonlyArray<StopsDatabaseParkingPropertiesSpaces>;
  /** fetch aggregated fields from the table: "parking_properties_spaces" */
  readonly stops_database_parking_properties_spaces_aggregate: StopsDatabaseParkingPropertiesSpacesAggregate;
  /** fetch data from the table in a streaming manner: "parking_properties_spaces" */
  readonly stops_database_parking_properties_spaces_stream: ReadonlyArray<StopsDatabaseParkingPropertiesSpaces>;
  /** fetch data from the table in a streaming manner: "parking_properties" */
  readonly stops_database_parking_properties_stream: ReadonlyArray<StopsDatabaseParkingProperties>;
  /** fetch data from the table in a streaming manner: "parking" */
  readonly stops_database_parking_stream: ReadonlyArray<StopsDatabaseParking>;
  /** fetch data from the table: "path_junction" */
  readonly stops_database_path_junction: ReadonlyArray<StopsDatabasePathJunction>;
  /** fetch aggregated fields from the table: "path_junction" */
  readonly stops_database_path_junction_aggregate: StopsDatabasePathJunctionAggregate;
  /** fetch data from the table: "path_junction" using primary key columns */
  readonly stops_database_path_junction_by_pk?: Maybe<StopsDatabasePathJunction>;
  /** fetch data from the table: "path_junction_key_values" */
  readonly stops_database_path_junction_key_values: ReadonlyArray<StopsDatabasePathJunctionKeyValues>;
  /** fetch aggregated fields from the table: "path_junction_key_values" */
  readonly stops_database_path_junction_key_values_aggregate: StopsDatabasePathJunctionKeyValuesAggregate;
  /** fetch data from the table: "path_junction_key_values" using primary key columns */
  readonly stops_database_path_junction_key_values_by_pk?: Maybe<StopsDatabasePathJunctionKeyValues>;
  /** fetch data from the table in a streaming manner: "path_junction_key_values" */
  readonly stops_database_path_junction_key_values_stream: ReadonlyArray<StopsDatabasePathJunctionKeyValues>;
  /** fetch data from the table in a streaming manner: "path_junction" */
  readonly stops_database_path_junction_stream: ReadonlyArray<StopsDatabasePathJunction>;
  /** fetch data from the table: "path_link" */
  readonly stops_database_path_link: ReadonlyArray<StopsDatabasePathLink>;
  /** fetch aggregated fields from the table: "path_link" */
  readonly stops_database_path_link_aggregate: StopsDatabasePathLinkAggregate;
  /** fetch data from the table: "path_link" using primary key columns */
  readonly stops_database_path_link_by_pk?: Maybe<StopsDatabasePathLink>;
  /** fetch data from the table: "path_link_end" */
  readonly stops_database_path_link_end: ReadonlyArray<StopsDatabasePathLinkEnd>;
  /** fetch aggregated fields from the table: "path_link_end" */
  readonly stops_database_path_link_end_aggregate: StopsDatabasePathLinkEndAggregate;
  /** fetch data from the table: "path_link_end" using primary key columns */
  readonly stops_database_path_link_end_by_pk?: Maybe<StopsDatabasePathLinkEnd>;
  /** fetch data from the table in a streaming manner: "path_link_end" */
  readonly stops_database_path_link_end_stream: ReadonlyArray<StopsDatabasePathLinkEnd>;
  /** fetch data from the table: "path_link_key_values" */
  readonly stops_database_path_link_key_values: ReadonlyArray<StopsDatabasePathLinkKeyValues>;
  /** fetch aggregated fields from the table: "path_link_key_values" */
  readonly stops_database_path_link_key_values_aggregate: StopsDatabasePathLinkKeyValuesAggregate;
  /** fetch data from the table: "path_link_key_values" using primary key columns */
  readonly stops_database_path_link_key_values_by_pk?: Maybe<StopsDatabasePathLinkKeyValues>;
  /** fetch data from the table in a streaming manner: "path_link_key_values" */
  readonly stops_database_path_link_key_values_stream: ReadonlyArray<StopsDatabasePathLinkKeyValues>;
  /** fetch data from the table in a streaming manner: "path_link" */
  readonly stops_database_path_link_stream: ReadonlyArray<StopsDatabasePathLink>;
  /** fetch data from the table: "persistable_polygon" */
  readonly stops_database_persistable_polygon: ReadonlyArray<StopsDatabasePersistablePolygon>;
  /** fetch aggregated fields from the table: "persistable_polygon" */
  readonly stops_database_persistable_polygon_aggregate: StopsDatabasePersistablePolygonAggregate;
  /** fetch data from the table: "persistable_polygon" using primary key columns */
  readonly stops_database_persistable_polygon_by_pk?: Maybe<StopsDatabasePersistablePolygon>;
  /** fetch data from the table in a streaming manner: "persistable_polygon" */
  readonly stops_database_persistable_polygon_stream: ReadonlyArray<StopsDatabasePersistablePolygon>;
  /** fetch data from the table: "place_equipment" */
  readonly stops_database_place_equipment: ReadonlyArray<StopsDatabasePlaceEquipment>;
  /** fetch aggregated fields from the table: "place_equipment" */
  readonly stops_database_place_equipment_aggregate: StopsDatabasePlaceEquipmentAggregate;
  /** fetch data from the table in a streaming manner: "place_equipment" */
  readonly stops_database_place_equipment_stream: ReadonlyArray<StopsDatabasePlaceEquipment>;
  /** fetch data from the table: "purpose_of_grouping" */
  readonly stops_database_purpose_of_grouping: ReadonlyArray<StopsDatabasePurposeOfGrouping>;
  /** fetch aggregated fields from the table: "purpose_of_grouping" */
  readonly stops_database_purpose_of_grouping_aggregate: StopsDatabasePurposeOfGroupingAggregate;
  /** fetch data from the table: "purpose_of_grouping" using primary key columns */
  readonly stops_database_purpose_of_grouping_by_pk?: Maybe<StopsDatabasePurposeOfGrouping>;
  /** fetch data from the table: "purpose_of_grouping_key_values" */
  readonly stops_database_purpose_of_grouping_key_values: ReadonlyArray<StopsDatabasePurposeOfGroupingKeyValues>;
  /** fetch aggregated fields from the table: "purpose_of_grouping_key_values" */
  readonly stops_database_purpose_of_grouping_key_values_aggregate: StopsDatabasePurposeOfGroupingKeyValuesAggregate;
  /** fetch data from the table: "purpose_of_grouping_key_values" using primary key columns */
  readonly stops_database_purpose_of_grouping_key_values_by_pk?: Maybe<StopsDatabasePurposeOfGroupingKeyValues>;
  /** fetch data from the table in a streaming manner: "purpose_of_grouping_key_values" */
  readonly stops_database_purpose_of_grouping_key_values_stream: ReadonlyArray<StopsDatabasePurposeOfGroupingKeyValues>;
  /** fetch data from the table in a streaming manner: "purpose_of_grouping" */
  readonly stops_database_purpose_of_grouping_stream: ReadonlyArray<StopsDatabasePurposeOfGrouping>;
  /** fetch data from the table: "quay" */
  readonly stops_database_quay: ReadonlyArray<StopsDatabaseQuay>;
  /** fetch aggregated fields from the table: "quay" */
  readonly stops_database_quay_aggregate: StopsDatabaseQuayAggregate;
  /** fetch data from the table: "quay_alternative_names" */
  readonly stops_database_quay_alternative_names: ReadonlyArray<StopsDatabaseQuayAlternativeNames>;
  /** fetch aggregated fields from the table: "quay_alternative_names" */
  readonly stops_database_quay_alternative_names_aggregate: StopsDatabaseQuayAlternativeNamesAggregate;
  /** fetch data from the table in a streaming manner: "quay_alternative_names" */
  readonly stops_database_quay_alternative_names_stream: ReadonlyArray<StopsDatabaseQuayAlternativeNames>;
  /** fetch data from the table: "quay_boarding_positions" */
  readonly stops_database_quay_boarding_positions: ReadonlyArray<StopsDatabaseQuayBoardingPositions>;
  /** fetch aggregated fields from the table: "quay_boarding_positions" */
  readonly stops_database_quay_boarding_positions_aggregate: StopsDatabaseQuayBoardingPositionsAggregate;
  /** fetch data from the table in a streaming manner: "quay_boarding_positions" */
  readonly stops_database_quay_boarding_positions_stream: ReadonlyArray<StopsDatabaseQuayBoardingPositions>;
  /** fetch data from the table: "quay" using primary key columns */
  readonly stops_database_quay_by_pk?: Maybe<StopsDatabaseQuay>;
  /** fetch data from the table: "quay_check_constraints" */
  readonly stops_database_quay_check_constraints: ReadonlyArray<StopsDatabaseQuayCheckConstraints>;
  /** fetch aggregated fields from the table: "quay_check_constraints" */
  readonly stops_database_quay_check_constraints_aggregate: StopsDatabaseQuayCheckConstraintsAggregate;
  /** fetch data from the table in a streaming manner: "quay_check_constraints" */
  readonly stops_database_quay_check_constraints_stream: ReadonlyArray<StopsDatabaseQuayCheckConstraints>;
  /** fetch data from the table: "quay_equipment_places" */
  readonly stops_database_quay_equipment_places: ReadonlyArray<StopsDatabaseQuayEquipmentPlaces>;
  /** fetch aggregated fields from the table: "quay_equipment_places" */
  readonly stops_database_quay_equipment_places_aggregate: StopsDatabaseQuayEquipmentPlacesAggregate;
  /** fetch data from the table in a streaming manner: "quay_equipment_places" */
  readonly stops_database_quay_equipment_places_stream: ReadonlyArray<StopsDatabaseQuayEquipmentPlaces>;
  /** fetch data from the table: "quay_key_values" */
  readonly stops_database_quay_key_values: ReadonlyArray<StopsDatabaseQuayKeyValues>;
  /** fetch aggregated fields from the table: "quay_key_values" */
  readonly stops_database_quay_key_values_aggregate: StopsDatabaseQuayKeyValuesAggregate;
  /** fetch data from the table: "quay_key_values" using primary key columns */
  readonly stops_database_quay_key_values_by_pk?: Maybe<StopsDatabaseQuayKeyValues>;
  /** fetch data from the table in a streaming manner: "quay_key_values" */
  readonly stops_database_quay_key_values_stream: ReadonlyArray<StopsDatabaseQuayKeyValues>;
  /** fetch data from the table: "quay_newest_version" */
  readonly stops_database_quay_newest_version: ReadonlyArray<StopsDatabaseQuayNewestVersion>;
  /** fetch aggregated fields from the table: "quay_newest_version" */
  readonly stops_database_quay_newest_version_aggregate: StopsDatabaseQuayNewestVersionAggregate;
  /** fetch data from the table in a streaming manner: "quay_newest_version" */
  readonly stops_database_quay_newest_version_stream: ReadonlyArray<StopsDatabaseQuayNewestVersion>;
  /** fetch data from the table in a streaming manner: "quay" */
  readonly stops_database_quay_stream: ReadonlyArray<StopsDatabaseQuay>;
  /** fetch data from the table: "schema_version" */
  readonly stops_database_schema_version: ReadonlyArray<StopsDatabaseSchemaVersion>;
  /** fetch aggregated fields from the table: "schema_version" */
  readonly stops_database_schema_version_aggregate: StopsDatabaseSchemaVersionAggregate;
  /** fetch data from the table: "schema_version" using primary key columns */
  readonly stops_database_schema_version_by_pk?: Maybe<StopsDatabaseSchemaVersion>;
  /** fetch data from the table in a streaming manner: "schema_version" */
  readonly stops_database_schema_version_stream: ReadonlyArray<StopsDatabaseSchemaVersion>;
  /** fetch data from the table: "spatial_ref_sys" */
  readonly stops_database_spatial_ref_sys: ReadonlyArray<StopsDatabaseSpatialRefSys>;
  /** fetch aggregated fields from the table: "spatial_ref_sys" */
  readonly stops_database_spatial_ref_sys_aggregate: StopsDatabaseSpatialRefSysAggregate;
  /** fetch data from the table: "spatial_ref_sys" using primary key columns */
  readonly stops_database_spatial_ref_sys_by_pk?: Maybe<StopsDatabaseSpatialRefSys>;
  /** fetch data from the table in a streaming manner: "spatial_ref_sys" */
  readonly stops_database_spatial_ref_sys_stream: ReadonlyArray<StopsDatabaseSpatialRefSys>;
  /** fetch data from the table: "stop_place" */
  readonly stops_database_stop_place: ReadonlyArray<StopsDatabaseStopPlace>;
  /** fetch data from the table: "stop_place_access_spaces" */
  readonly stops_database_stop_place_access_spaces: ReadonlyArray<StopsDatabaseStopPlaceAccessSpaces>;
  /** fetch aggregated fields from the table: "stop_place_access_spaces" */
  readonly stops_database_stop_place_access_spaces_aggregate: StopsDatabaseStopPlaceAccessSpacesAggregate;
  /** fetch data from the table in a streaming manner: "stop_place_access_spaces" */
  readonly stops_database_stop_place_access_spaces_stream: ReadonlyArray<StopsDatabaseStopPlaceAccessSpaces>;
  /** fetch data from the table: "stop_place_adjacent_sites" */
  readonly stops_database_stop_place_adjacent_sites: ReadonlyArray<StopsDatabaseStopPlaceAdjacentSites>;
  /** fetch aggregated fields from the table: "stop_place_adjacent_sites" */
  readonly stops_database_stop_place_adjacent_sites_aggregate: StopsDatabaseStopPlaceAdjacentSitesAggregate;
  /** fetch data from the table in a streaming manner: "stop_place_adjacent_sites" */
  readonly stops_database_stop_place_adjacent_sites_stream: ReadonlyArray<StopsDatabaseStopPlaceAdjacentSites>;
  /** fetch aggregated fields from the table: "stop_place" */
  readonly stops_database_stop_place_aggregate: StopsDatabaseStopPlaceAggregate;
  /** fetch data from the table: "stop_place_alternative_names" */
  readonly stops_database_stop_place_alternative_names: ReadonlyArray<StopsDatabaseStopPlaceAlternativeNames>;
  /** fetch aggregated fields from the table: "stop_place_alternative_names" */
  readonly stops_database_stop_place_alternative_names_aggregate: StopsDatabaseStopPlaceAlternativeNamesAggregate;
  /** fetch data from the table in a streaming manner: "stop_place_alternative_names" */
  readonly stops_database_stop_place_alternative_names_stream: ReadonlyArray<StopsDatabaseStopPlaceAlternativeNames>;
  /** fetch data from the table: "stop_place" using primary key columns */
  readonly stops_database_stop_place_by_pk?: Maybe<StopsDatabaseStopPlace>;
  /** fetch data from the table: "stop_place_children" */
  readonly stops_database_stop_place_children: ReadonlyArray<StopsDatabaseStopPlaceChildren>;
  /** fetch aggregated fields from the table: "stop_place_children" */
  readonly stops_database_stop_place_children_aggregate: StopsDatabaseStopPlaceChildrenAggregate;
  /** fetch data from the table: "stop_place_children" using primary key columns */
  readonly stops_database_stop_place_children_by_pk?: Maybe<StopsDatabaseStopPlaceChildren>;
  /** fetch data from the table in a streaming manner: "stop_place_children" */
  readonly stops_database_stop_place_children_stream: ReadonlyArray<StopsDatabaseStopPlaceChildren>;
  /** fetch data from the table: "stop_place_equipment_places" */
  readonly stops_database_stop_place_equipment_places: ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlaces>;
  /** fetch aggregated fields from the table: "stop_place_equipment_places" */
  readonly stops_database_stop_place_equipment_places_aggregate: StopsDatabaseStopPlaceEquipmentPlacesAggregate;
  /** fetch data from the table in a streaming manner: "stop_place_equipment_places" */
  readonly stops_database_stop_place_equipment_places_stream: ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlaces>;
  /** fetch data from the table: "stop_place_key_values" */
  readonly stops_database_stop_place_key_values: ReadonlyArray<StopsDatabaseStopPlaceKeyValues>;
  /** fetch aggregated fields from the table: "stop_place_key_values" */
  readonly stops_database_stop_place_key_values_aggregate: StopsDatabaseStopPlaceKeyValuesAggregate;
  /** fetch data from the table: "stop_place_key_values" using primary key columns */
  readonly stops_database_stop_place_key_values_by_pk?: Maybe<StopsDatabaseStopPlaceKeyValues>;
  /** fetch data from the table in a streaming manner: "stop_place_key_values" */
  readonly stops_database_stop_place_key_values_stream: ReadonlyArray<StopsDatabaseStopPlaceKeyValues>;
  /** fetch data from the table: "stop_place_newest_version" */
  readonly stops_database_stop_place_newest_version: ReadonlyArray<StopsDatabaseStopPlaceNewestVersion>;
  /** fetch aggregated fields from the table: "stop_place_newest_version" */
  readonly stops_database_stop_place_newest_version_aggregate: StopsDatabaseStopPlaceNewestVersionAggregate;
  /** fetch data from the table in a streaming manner: "stop_place_newest_version" */
  readonly stops_database_stop_place_newest_version_stream: ReadonlyArray<StopsDatabaseStopPlaceNewestVersion>;
  /** fetch data from the table: "stop_place_organisations" */
  readonly stops_database_stop_place_organisations: ReadonlyArray<StopsDatabaseStopPlaceOrganisations>;
  /** fetch aggregated fields from the table: "stop_place_organisations" */
  readonly stops_database_stop_place_organisations_aggregate: StopsDatabaseStopPlaceOrganisationsAggregate;
  /** fetch data from the table: "stop_place_organisations" using primary key columns */
  readonly stops_database_stop_place_organisations_by_pk?: Maybe<StopsDatabaseStopPlaceOrganisations>;
  /** fetch data from the table in a streaming manner: "stop_place_organisations" */
  readonly stops_database_stop_place_organisations_stream: ReadonlyArray<StopsDatabaseStopPlaceOrganisations>;
  /** fetch data from the table: "stop_place_quays" */
  readonly stops_database_stop_place_quays: ReadonlyArray<StopsDatabaseStopPlaceQuays>;
  /** fetch aggregated fields from the table: "stop_place_quays" */
  readonly stops_database_stop_place_quays_aggregate: StopsDatabaseStopPlaceQuaysAggregate;
  /** fetch data from the table: "stop_place_quays" using primary key columns */
  readonly stops_database_stop_place_quays_by_pk?: Maybe<StopsDatabaseStopPlaceQuays>;
  /** fetch data from the table in a streaming manner: "stop_place_quays" */
  readonly stops_database_stop_place_quays_stream: ReadonlyArray<StopsDatabaseStopPlaceQuays>;
  /** fetch data from the table in a streaming manner: "stop_place" */
  readonly stops_database_stop_place_stream: ReadonlyArray<StopsDatabaseStopPlace>;
  /** fetch data from the table: "stop_place_tariff_zones" */
  readonly stops_database_stop_place_tariff_zones: ReadonlyArray<StopsDatabaseStopPlaceTariffZones>;
  /** fetch aggregated fields from the table: "stop_place_tariff_zones" */
  readonly stops_database_stop_place_tariff_zones_aggregate: StopsDatabaseStopPlaceTariffZonesAggregate;
  /** fetch data from the table in a streaming manner: "stop_place_tariff_zones" */
  readonly stops_database_stop_place_tariff_zones_stream: ReadonlyArray<StopsDatabaseStopPlaceTariffZones>;
  /** fetch data from the table: "tag" */
  readonly stops_database_tag: ReadonlyArray<StopsDatabaseTag>;
  /** fetch aggregated fields from the table: "tag" */
  readonly stops_database_tag_aggregate: StopsDatabaseTagAggregate;
  /** fetch data from the table: "tag" using primary key columns */
  readonly stops_database_tag_by_pk?: Maybe<StopsDatabaseTag>;
  /** fetch data from the table in a streaming manner: "tag" */
  readonly stops_database_tag_stream: ReadonlyArray<StopsDatabaseTag>;
  /** fetch data from the table: "tariff_zone" */
  readonly stops_database_tariff_zone: ReadonlyArray<StopsDatabaseTariffZone>;
  /** fetch aggregated fields from the table: "tariff_zone" */
  readonly stops_database_tariff_zone_aggregate: StopsDatabaseTariffZoneAggregate;
  /** fetch data from the table: "tariff_zone" using primary key columns */
  readonly stops_database_tariff_zone_by_pk?: Maybe<StopsDatabaseTariffZone>;
  /** fetch data from the table: "tariff_zone_key_values" */
  readonly stops_database_tariff_zone_key_values: ReadonlyArray<StopsDatabaseTariffZoneKeyValues>;
  /** fetch aggregated fields from the table: "tariff_zone_key_values" */
  readonly stops_database_tariff_zone_key_values_aggregate: StopsDatabaseTariffZoneKeyValuesAggregate;
  /** fetch data from the table: "tariff_zone_key_values" using primary key columns */
  readonly stops_database_tariff_zone_key_values_by_pk?: Maybe<StopsDatabaseTariffZoneKeyValues>;
  /** fetch data from the table in a streaming manner: "tariff_zone_key_values" */
  readonly stops_database_tariff_zone_key_values_stream: ReadonlyArray<StopsDatabaseTariffZoneKeyValues>;
  /** fetch data from the table in a streaming manner: "tariff_zone" */
  readonly stops_database_tariff_zone_stream: ReadonlyArray<StopsDatabaseTariffZone>;
  /** fetch data from the table: "topographic_place" */
  readonly stops_database_topographic_place: ReadonlyArray<StopsDatabaseTopographicPlace>;
  /** fetch aggregated fields from the table: "topographic_place" */
  readonly stops_database_topographic_place_aggregate: StopsDatabaseTopographicPlaceAggregate;
  /** fetch data from the table: "topographic_place" using primary key columns */
  readonly stops_database_topographic_place_by_pk?: Maybe<StopsDatabaseTopographicPlace>;
  /** fetch data from the table: "topographic_place_key_values" */
  readonly stops_database_topographic_place_key_values: ReadonlyArray<StopsDatabaseTopographicPlaceKeyValues>;
  /** fetch aggregated fields from the table: "topographic_place_key_values" */
  readonly stops_database_topographic_place_key_values_aggregate: StopsDatabaseTopographicPlaceKeyValuesAggregate;
  /** fetch data from the table: "topographic_place_key_values" using primary key columns */
  readonly stops_database_topographic_place_key_values_by_pk?: Maybe<StopsDatabaseTopographicPlaceKeyValues>;
  /** fetch data from the table in a streaming manner: "topographic_place_key_values" */
  readonly stops_database_topographic_place_key_values_stream: ReadonlyArray<StopsDatabaseTopographicPlaceKeyValues>;
  /** fetch data from the table in a streaming manner: "topographic_place" */
  readonly stops_database_topographic_place_stream: ReadonlyArray<StopsDatabaseTopographicPlace>;
  /** fetch data from the table: "value" */
  readonly stops_database_value: ReadonlyArray<StopsDatabaseValue>;
  /** fetch aggregated fields from the table: "value" */
  readonly stops_database_value_aggregate: StopsDatabaseValueAggregate;
  /** fetch data from the table: "value" using primary key columns */
  readonly stops_database_value_by_pk?: Maybe<StopsDatabaseValue>;
  /** fetch data from the table: "value_items" */
  readonly stops_database_value_items: ReadonlyArray<StopsDatabaseValueItems>;
  /** fetch aggregated fields from the table: "value_items" */
  readonly stops_database_value_items_aggregate: StopsDatabaseValueItemsAggregate;
  /** fetch data from the table in a streaming manner: "value_items" */
  readonly stops_database_value_items_stream: ReadonlyArray<StopsDatabaseValueItems>;
  /** fetch data from the table in a streaming manner: "value" */
  readonly stops_database_value_stream: ReadonlyArray<StopsDatabaseValue>;
};


export type StopsDatabaseStopsDatabaseSubscriptionFindStopsForTerminalArgs = {
  args: FindStopsForTerminalArguments;
  distinct_on?: InputMaybe<ReadonlyArray<TerminalStopSearchResultEnumName>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTerminalStopSearchResultOrderBy>>;
  where?: InputMaybe<StopsDatabaseTerminalStopSearchResultBoolExpBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceAlternativeNamesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceAlternativeNamesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceCheckConstraintsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceCheckConstraintsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceCheckConstraintsOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceCheckConstraintsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceCheckConstraintsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceCheckConstraintsOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceCheckConstraintsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceCheckConstraintsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceEquipmentPlacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceEquipmentPlacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceEquipmentPlacesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessSpaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceKeyValuesByPkArgs = {
  access_space_id: Scalars['bigint']['input'];
  key_values_key: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceKeyValuesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseAccessSpaceKeyValuesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessSpaceStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseAccessSpaceStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseAccessSpaceBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessibilityAssessmentArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessibilityAssessmentBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessibilityAssessmentAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessibilityAssessmentBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessibilityAssessmentByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessibilityAssessmentLimitationsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitationsOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessibilityAssessmentLimitationsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityAssessmentLimitationsOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessibilityAssessmentLimitationsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseAccessibilityAssessmentLimitationsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessibilityAssessmentStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseAccessibilityAssessmentStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseAccessibilityAssessmentBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessibilityLimitationArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityLimitationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityLimitationOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessibilityLimitationBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessibilityLimitationAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityLimitationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAccessibilityLimitationOrderBy>>;
  where?: InputMaybe<StopsDatabaseAccessibilityLimitationBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessibilityLimitationByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAccessibilityLimitationStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseAccessibilityLimitationStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseAccessibilityLimitationBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAlternativeNameArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAlternativeNameSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAlternativeNameOrderBy>>;
  where?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAlternativeNameAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseAlternativeNameSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseAlternativeNameOrderBy>>;
  where?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAlternativeNameByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseAlternativeNameStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseAlternativeNameStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseAlternativeNameBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionAlternativeNamesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionAlternativeNamesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionCheckConstraintsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionCheckConstraintsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionCheckConstraintsOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionCheckConstraintsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionCheckConstraintsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionCheckConstraintsOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionCheckConstraintsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionCheckConstraintsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionEquipmentPlacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionEquipmentPlacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionEquipmentPlacesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseBoardingPositionKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionKeyValuesByPkArgs = {
  boarding_position_id: Scalars['bigint']['input'];
  key_values_key: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionKeyValuesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseBoardingPositionKeyValuesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseBoardingPositionStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseBoardingPositionStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseBoardingPositionBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseCheckConstraintArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseCheckConstraintSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseCheckConstraintOrderBy>>;
  where?: InputMaybe<StopsDatabaseCheckConstraintBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseCheckConstraintAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseCheckConstraintSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseCheckConstraintOrderBy>>;
  where?: InputMaybe<StopsDatabaseCheckConstraintBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseCheckConstraintByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseCheckConstraintKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseCheckConstraintKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseCheckConstraintKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseCheckConstraintKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseCheckConstraintKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseCheckConstraintKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseCheckConstraintKeyValuesByPkArgs = {
  check_constraint_id: Scalars['bigint']['input'];
  key_values_key: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseCheckConstraintKeyValuesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseCheckConstraintKeyValuesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseCheckConstraintKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseCheckConstraintStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseCheckConstraintStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseCheckConstraintBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseContactArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseContactSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseContactOrderBy>>;
  where?: InputMaybe<StopsDatabaseContactBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseContactAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseContactSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseContactOrderBy>>;
  where?: InputMaybe<StopsDatabaseContactBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseContactByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseContactStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseContactStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseContactBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseDestinationDisplayViewArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseDestinationDisplayViewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseDestinationDisplayViewOrderBy>>;
  where?: InputMaybe<StopsDatabaseDestinationDisplayViewBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseDestinationDisplayViewAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseDestinationDisplayViewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseDestinationDisplayViewOrderBy>>;
  where?: InputMaybe<StopsDatabaseDestinationDisplayViewBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseDestinationDisplayViewByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseDestinationDisplayViewStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseDestinationDisplayViewStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseDestinationDisplayViewBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPlaceArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPlaceAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPlaceByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPlaceEquipmentPositionsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositionsOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPlaceEquipmentPositionsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceEquipmentPositionsOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPlaceEquipmentPositionsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceEquipmentPositionsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPlaceKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPlaceKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPlaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPlaceKeyValuesByPkArgs = {
  equipment_place_id: Scalars['bigint']['input'];
  key_values_key: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPlaceKeyValuesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPlaceStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseEquipmentPlaceStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseEquipmentPlaceBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPositionArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPositionBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPositionAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPositionBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPositionByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPositionKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPositionKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseEquipmentPositionKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPositionKeyValuesByPkArgs = {
  equipment_position_id: Scalars['bigint']['input'];
  key_values_key: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPositionKeyValuesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseEquipmentPositionKeyValuesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseEquipmentPositionKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseEquipmentPositionStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseEquipmentPositionStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseEquipmentPositionBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseExportJobArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseExportJobSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseExportJobOrderBy>>;
  where?: InputMaybe<StopsDatabaseExportJobBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseExportJobAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseExportJobSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseExportJobOrderBy>>;
  where?: InputMaybe<StopsDatabaseExportJobBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseExportJobByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseExportJobStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseExportJobStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseExportJobBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneKeyValuesByPkArgs = {
  fare_zone_id: Scalars['bigint']['input'];
  key_values_key: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneKeyValuesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseFareZoneKeyValuesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseFareZoneKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneMembersArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneMembersOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneMembersBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneMembersAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneMembersOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneMembersBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneMembersStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseFareZoneMembersStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseFareZoneMembersBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneNeighboursArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneNeighboursSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneNeighboursOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneNeighboursBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneNeighboursAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneNeighboursSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseFareZoneNeighboursOrderBy>>;
  where?: InputMaybe<StopsDatabaseFareZoneNeighboursBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneNeighboursStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseFareZoneNeighboursStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseFareZoneNeighboursBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseFareZoneStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseFareZoneStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseFareZoneBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGeographyColumnsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGeographyColumnsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGeographyColumnsOrderBy>>;
  where?: InputMaybe<StopsDatabaseGeographyColumnsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGeographyColumnsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGeographyColumnsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGeographyColumnsOrderBy>>;
  where?: InputMaybe<StopsDatabaseGeographyColumnsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGeographyColumnsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseGeographyColumnsStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseGeographyColumnsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGeometryColumnsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGeometryColumnsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGeometryColumnsOrderBy>>;
  where?: InputMaybe<StopsDatabaseGeometryColumnsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGeometryColumnsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGeometryColumnsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGeometryColumnsOrderBy>>;
  where?: InputMaybe<StopsDatabaseGeometryColumnsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGeometryColumnsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseGeometryColumnsStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseGeometryColumnsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesAlternativeNamesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesAlternativeNamesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesKeyValuesByPkArgs = {
  group_of_stop_places_id: Scalars['bigint']['input'];
  key_values_key: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesKeyValuesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesMembersArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembersOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesMembersAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfStopPlacesMembersOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesMembersStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseGroupOfStopPlacesMembersStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesMembersBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfStopPlacesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseGroupOfStopPlacesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseGroupOfStopPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfTariffZonesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfTariffZonesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfTariffZonesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfTariffZonesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfTariffZonesByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfTariffZonesKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfTariffZonesKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfTariffZonesKeyValuesByPkArgs = {
  group_of_tariff_zones_id: Scalars['bigint']['input'];
  key_values_key: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfTariffZonesKeyValuesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseGroupOfTariffZonesKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfTariffZonesMembersArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembersOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfTariffZonesMembersAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseGroupOfTariffZonesMembersOrderBy>>;
  where?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfTariffZonesMembersByPkArgs = {
  group_of_tariff_zones_id: Scalars['bigint']['input'];
  ref: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfTariffZonesMembersStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseGroupOfTariffZonesMembersStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseGroupOfTariffZonesMembersBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseGroupOfTariffZonesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseGroupOfTariffZonesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseGroupOfTariffZonesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseHslAccessibilityPropertiesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseHslAccessibilityPropertiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseHslAccessibilityPropertiesOrderBy>>;
  where?: InputMaybe<StopsDatabaseHslAccessibilityPropertiesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseHslAccessibilityPropertiesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseHslAccessibilityPropertiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseHslAccessibilityPropertiesOrderBy>>;
  where?: InputMaybe<StopsDatabaseHslAccessibilityPropertiesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseHslAccessibilityPropertiesByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseHslAccessibilityPropertiesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseHslAccessibilityPropertiesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseHslAccessibilityPropertiesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseIdGeneratorArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseIdGeneratorSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseIdGeneratorOrderBy>>;
  where?: InputMaybe<StopsDatabaseIdGeneratorBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseIdGeneratorAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseIdGeneratorSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseIdGeneratorOrderBy>>;
  where?: InputMaybe<StopsDatabaseIdGeneratorBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseIdGeneratorStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseIdGeneratorStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseIdGeneratorBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInfoSpotArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseInfoSpotSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseInfoSpotOrderBy>>;
  where?: InputMaybe<StopsDatabaseInfoSpotBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInfoSpotAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseInfoSpotSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseInfoSpotOrderBy>>;
  where?: InputMaybe<StopsDatabaseInfoSpotBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInfoSpotByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInfoSpotPosterArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseInfoSpotPosterSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseInfoSpotPosterOrderBy>>;
  where?: InputMaybe<StopsDatabaseInfoSpotPosterBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInfoSpotPosterAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseInfoSpotPosterSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseInfoSpotPosterOrderBy>>;
  where?: InputMaybe<StopsDatabaseInfoSpotPosterBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInfoSpotPosterByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInfoSpotPosterStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseInfoSpotPosterStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseInfoSpotPosterBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInfoSpotStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseInfoSpotStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseInfoSpotBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInstalledEquipmentArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentOrderBy>>;
  where?: InputMaybe<StopsDatabaseInstalledEquipmentBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInstalledEquipmentAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentOrderBy>>;
  where?: InputMaybe<StopsDatabaseInstalledEquipmentBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInstalledEquipmentStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseInstalledEquipmentStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseInstalledEquipmentBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInstalledEquipmentVersionStructureArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureOrderBy>>;
  where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInstalledEquipmentVersionStructureAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureOrderBy>>;
  where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInstalledEquipmentVersionStructureByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentOrderBy>>;
  where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentOrderBy>>;
  where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureInstalledEquipmentBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseInstalledEquipmentVersionStructureStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseInstalledEquipmentVersionStructureBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseLevelArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseLevelSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseLevelOrderBy>>;
  where?: InputMaybe<StopsDatabaseLevelBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseLevelAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseLevelSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseLevelOrderBy>>;
  where?: InputMaybe<StopsDatabaseLevelBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseLevelByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseLevelKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseLevelKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseLevelKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseLevelKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseLevelKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseLevelKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseLevelKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseLevelKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseLevelKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  level_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseLevelKeyValuesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseLevelKeyValuesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseLevelKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseLevelStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseLevelStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseLevelBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseMultilingualStringEntityArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseMultilingualStringEntitySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseMultilingualStringEntityOrderBy>>;
  where?: InputMaybe<StopsDatabaseMultilingualStringEntityBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseMultilingualStringEntityAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseMultilingualStringEntitySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseMultilingualStringEntityOrderBy>>;
  where?: InputMaybe<StopsDatabaseMultilingualStringEntityBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseMultilingualStringEntityByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseMultilingualStringEntityStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseMultilingualStringEntityStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseMultilingualStringEntityBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseNavigationPathArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseNavigationPathSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseNavigationPathOrderBy>>;
  where?: InputMaybe<StopsDatabaseNavigationPathBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseNavigationPathAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseNavigationPathSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseNavigationPathOrderBy>>;
  where?: InputMaybe<StopsDatabaseNavigationPathBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseNavigationPathStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseNavigationPathStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseNavigationPathBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseOrganisationArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseOrganisationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseOrganisationOrderBy>>;
  where?: InputMaybe<StopsDatabaseOrganisationBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseOrganisationAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseOrganisationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseOrganisationOrderBy>>;
  where?: InputMaybe<StopsDatabaseOrganisationBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseOrganisationByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseOrganisationKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseOrganisationKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseOrganisationKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseOrganisationKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseOrganisationKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseOrganisationKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseOrganisationKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseOrganisationKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseOrganisationKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  organisation_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseOrganisationKeyValuesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseOrganisationKeyValuesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseOrganisationKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseOrganisationStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseOrganisationStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseOrganisationBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAdjacentSitesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAdjacentSitesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAdjacentSitesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAdjacentSitesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAdjacentSitesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAdjacentSitesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAdjacentSitesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAdjacentSitesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAdjacentSitesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseParkingAdjacentSitesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseParkingAdjacentSitesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAlternativeNamesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAlternativeNamesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseParkingAlternativeNamesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseParkingAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaAlternativeNamesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaAlternativeNamesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseParkingAreaAlternativeNamesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseParkingAreaAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaCheckConstraintsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaCheckConstraintsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaCheckConstraintsOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaCheckConstraintsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaCheckConstraintsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaCheckConstraintsOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaCheckConstraintsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseParkingAreaCheckConstraintsStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseParkingAreaCheckConstraintsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaEquipmentPlacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaEquipmentPlacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaEquipmentPlacesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseParkingAreaEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingAreaKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingAreaKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  parking_area_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaKeyValuesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseParkingAreaKeyValuesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseParkingAreaKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingAreaStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseParkingAreaStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseParkingAreaBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingCapacityArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingCapacitySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingCapacityOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingCapacityBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingCapacityAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingCapacitySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingCapacityOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingCapacityBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingCapacityByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingCapacityStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseParkingCapacityStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseParkingCapacityBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingEquipmentPlacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingEquipmentPlacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingEquipmentPlacesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseParkingEquipmentPlacesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseParkingEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  parking_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingKeyValuesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseParkingKeyValuesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseParkingKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingParkingAreasArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingAreasSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingAreasOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingAreasBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingParkingAreasAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingAreasSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingAreasOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingAreasBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingParkingAreasStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseParkingParkingAreasStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseParkingParkingAreasBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingParkingPaymentProcessArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPaymentProcessSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPaymentProcessOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingParkingPaymentProcessAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPaymentProcessSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPaymentProcessOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingParkingPaymentProcessStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseParkingParkingPaymentProcessStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseParkingParkingPaymentProcessBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingParkingPropertiesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPropertiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPropertiesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingPropertiesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingParkingPropertiesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPropertiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingPropertiesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingPropertiesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingParkingPropertiesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseParkingParkingPropertiesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseParkingParkingPropertiesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingParkingVehicleTypesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingVehicleTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingVehicleTypesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingParkingVehicleTypesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingVehicleTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingParkingVehicleTypesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingParkingVehicleTypesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseParkingParkingVehicleTypesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseParkingParkingVehicleTypesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingPropertiesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingPropertiesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingPropertiesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingPropertiesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingPropertiesByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingPropertiesParkingUserTypesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesParkingUserTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesParkingUserTypesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingPropertiesParkingUserTypesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingPropertiesParkingUserTypesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesParkingUserTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesParkingUserTypesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingPropertiesParkingUserTypesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingPropertiesParkingUserTypesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseParkingPropertiesParkingUserTypesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseParkingPropertiesParkingUserTypesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingPropertiesSpacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesSpacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesSpacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingPropertiesSpacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingPropertiesSpacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesSpacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseParkingPropertiesSpacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseParkingPropertiesSpacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingPropertiesSpacesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseParkingPropertiesSpacesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseParkingPropertiesSpacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingPropertiesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseParkingPropertiesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseParkingPropertiesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseParkingStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseParkingStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseParkingBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathJunctionArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePathJunctionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePathJunctionOrderBy>>;
  where?: InputMaybe<StopsDatabasePathJunctionBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathJunctionAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePathJunctionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePathJunctionOrderBy>>;
  where?: InputMaybe<StopsDatabasePathJunctionBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathJunctionByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathJunctionKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePathJunctionKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePathJunctionKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabasePathJunctionKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathJunctionKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePathJunctionKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePathJunctionKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabasePathJunctionKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathJunctionKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  path_junction_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathJunctionKeyValuesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabasePathJunctionKeyValuesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabasePathJunctionKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathJunctionStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabasePathJunctionStreamCursorInput>>;
  where?: InputMaybe<StopsDatabasePathJunctionBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathLinkArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkOrderBy>>;
  where?: InputMaybe<StopsDatabasePathLinkBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathLinkAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkOrderBy>>;
  where?: InputMaybe<StopsDatabasePathLinkBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathLinkByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathLinkEndArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkEndSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkEndOrderBy>>;
  where?: InputMaybe<StopsDatabasePathLinkEndBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathLinkEndAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkEndSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkEndOrderBy>>;
  where?: InputMaybe<StopsDatabasePathLinkEndBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathLinkEndByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathLinkEndStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabasePathLinkEndStreamCursorInput>>;
  where?: InputMaybe<StopsDatabasePathLinkEndBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathLinkKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabasePathLinkKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathLinkKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePathLinkKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabasePathLinkKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathLinkKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  path_link_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathLinkKeyValuesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabasePathLinkKeyValuesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabasePathLinkKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePathLinkStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabasePathLinkStreamCursorInput>>;
  where?: InputMaybe<StopsDatabasePathLinkBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePersistablePolygonArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePersistablePolygonSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePersistablePolygonOrderBy>>;
  where?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePersistablePolygonAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePersistablePolygonSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePersistablePolygonOrderBy>>;
  where?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePersistablePolygonByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePersistablePolygonStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabasePersistablePolygonStreamCursorInput>>;
  where?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePlaceEquipmentArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePlaceEquipmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePlaceEquipmentOrderBy>>;
  where?: InputMaybe<StopsDatabasePlaceEquipmentBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePlaceEquipmentAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePlaceEquipmentSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePlaceEquipmentOrderBy>>;
  where?: InputMaybe<StopsDatabasePlaceEquipmentBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePlaceEquipmentStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabasePlaceEquipmentStreamCursorInput>>;
  where?: InputMaybe<StopsDatabasePlaceEquipmentBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePurposeOfGroupingArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePurposeOfGroupingSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePurposeOfGroupingOrderBy>>;
  where?: InputMaybe<StopsDatabasePurposeOfGroupingBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePurposeOfGroupingAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePurposeOfGroupingSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePurposeOfGroupingOrderBy>>;
  where?: InputMaybe<StopsDatabasePurposeOfGroupingBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePurposeOfGroupingByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePurposeOfGroupingKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePurposeOfGroupingKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePurposeOfGroupingKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePurposeOfGroupingKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabasePurposeOfGroupingKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabasePurposeOfGroupingKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePurposeOfGroupingKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  purpose_of_grouping_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePurposeOfGroupingKeyValuesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabasePurposeOfGroupingKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabasePurposeOfGroupingStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabasePurposeOfGroupingStreamCursorInput>>;
  where?: InputMaybe<StopsDatabasePurposeOfGroupingBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuaySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuaySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayAlternativeNamesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayAlternativeNamesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseQuayAlternativeNamesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseQuayAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayBoardingPositionsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayBoardingPositionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayBoardingPositionsOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayBoardingPositionsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayBoardingPositionsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayBoardingPositionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayBoardingPositionsOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayBoardingPositionsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayBoardingPositionsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseQuayBoardingPositionsStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseQuayBoardingPositionsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayCheckConstraintsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayCheckConstraintsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayCheckConstraintsOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayCheckConstraintsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayCheckConstraintsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayCheckConstraintsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayCheckConstraintsOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayCheckConstraintsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayCheckConstraintsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseQuayCheckConstraintsStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseQuayCheckConstraintsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayEquipmentPlacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayEquipmentPlacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayEquipmentPlacesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseQuayEquipmentPlacesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseQuayEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  quay_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayKeyValuesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseQuayKeyValuesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseQuayKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayNewestVersionArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayNewestVersionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayNewestVersionOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayNewestVersionBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayNewestVersionAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseQuayNewestVersionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseQuayNewestVersionOrderBy>>;
  where?: InputMaybe<StopsDatabaseQuayNewestVersionBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayNewestVersionStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseQuayNewestVersionStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseQuayNewestVersionBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseQuayStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseQuayStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseQuayBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseSchemaVersionArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseSchemaVersionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseSchemaVersionOrderBy>>;
  where?: InputMaybe<StopsDatabaseSchemaVersionBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseSchemaVersionAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseSchemaVersionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseSchemaVersionOrderBy>>;
  where?: InputMaybe<StopsDatabaseSchemaVersionBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseSchemaVersionByPkArgs = {
  installed_rank: Scalars['Int']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseSchemaVersionStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseSchemaVersionStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseSchemaVersionBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseSpatialRefSysArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseSpatialRefSysSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseSpatialRefSysOrderBy>>;
  where?: InputMaybe<StopsDatabaseSpatialRefSysBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseSpatialRefSysAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseSpatialRefSysSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseSpatialRefSysOrderBy>>;
  where?: InputMaybe<StopsDatabaseSpatialRefSysBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseSpatialRefSysByPkArgs = {
  srid: Scalars['Int']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseSpatialRefSysStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseSpatialRefSysStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseSpatialRefSysBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceAccessSpacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAccessSpacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAccessSpacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceAccessSpacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAccessSpacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAccessSpacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceAccessSpacesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseStopPlaceAccessSpacesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAccessSpacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceAdjacentSitesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAdjacentSitesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAdjacentSitesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAdjacentSitesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceAdjacentSitesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAdjacentSitesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAdjacentSitesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAdjacentSitesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceAdjacentSitesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseStopPlaceAdjacentSitesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAdjacentSitesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceAlternativeNamesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceAlternativeNamesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAlternativeNamesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceAlternativeNamesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceAlternativeNamesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseStopPlaceAlternativeNamesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseStopPlaceAlternativeNamesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceChildrenArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceChildrenSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceChildrenOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceChildrenAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceChildrenSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceChildrenOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceChildrenByPkArgs = {
  children_id: Scalars['bigint']['input'];
  stop_place_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceChildrenStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseStopPlaceChildrenStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseStopPlaceChildrenBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceEquipmentPlacesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceEquipmentPlacesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlacesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceEquipmentPlacesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceEquipmentPlacesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseStopPlaceEquipmentPlacesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  stop_place_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceKeyValuesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseStopPlaceKeyValuesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseStopPlaceKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceNewestVersionArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceNewestVersionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceNewestVersionOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceNewestVersionBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceNewestVersionAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceNewestVersionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceNewestVersionOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceNewestVersionBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceNewestVersionStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseStopPlaceNewestVersionStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseStopPlaceNewestVersionBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceOrganisationsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceOrganisationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceOrganisationsOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceOrganisationsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceOrganisationsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceOrganisationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceOrganisationsOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceOrganisationsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceOrganisationsByPkArgs = {
  organisation_ref: Scalars['String']['input'];
  relationship_type: Scalars['String']['input'];
  stop_place_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceOrganisationsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseStopPlaceOrganisationsStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseStopPlaceOrganisationsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceQuaysArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceQuaysSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceQuaysOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceQuaysBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceQuaysAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceQuaysSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceQuaysOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceQuaysBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceQuaysByPkArgs = {
  quays_id: Scalars['bigint']['input'];
  stop_place_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceQuaysStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseStopPlaceQuaysStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseStopPlaceQuaysBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseStopPlaceStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseStopPlaceBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceTariffZonesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceTariffZonesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceTariffZonesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceTariffZonesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceTariffZonesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceTariffZonesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseStopPlaceTariffZonesOrderBy>>;
  where?: InputMaybe<StopsDatabaseStopPlaceTariffZonesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseStopPlaceTariffZonesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseStopPlaceTariffZonesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseStopPlaceTariffZonesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTagArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseTagSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTagOrderBy>>;
  where?: InputMaybe<StopsDatabaseTagBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTagAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseTagSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTagOrderBy>>;
  where?: InputMaybe<StopsDatabaseTagBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTagByPkArgs = {
  name: Scalars['String']['input'];
  netex_reference: Scalars['String']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTagStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseTagStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseTagBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTariffZoneArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneOrderBy>>;
  where?: InputMaybe<StopsDatabaseTariffZoneBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTariffZoneAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneOrderBy>>;
  where?: InputMaybe<StopsDatabaseTariffZoneBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTariffZoneByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTariffZoneKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseTariffZoneKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTariffZoneKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseTariffZoneKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTariffZoneKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  tariff_zone_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTariffZoneKeyValuesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseTariffZoneKeyValuesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseTariffZoneKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTariffZoneStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseTariffZoneStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseTariffZoneBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTopographicPlaceArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceOrderBy>>;
  where?: InputMaybe<StopsDatabaseTopographicPlaceBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTopographicPlaceAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceOrderBy>>;
  where?: InputMaybe<StopsDatabaseTopographicPlaceBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTopographicPlaceByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTopographicPlaceKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTopographicPlaceKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTopographicPlaceKeyValuesByPkArgs = {
  key_values_key: Scalars['String']['input'];
  topographic_place_id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTopographicPlaceKeyValuesStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseTopographicPlaceKeyValuesStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseTopographicPlaceStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseTopographicPlaceStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseTopographicPlaceBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseValueArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseValueSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseValueOrderBy>>;
  where?: InputMaybe<StopsDatabaseValueBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseValueAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseValueSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseValueOrderBy>>;
  where?: InputMaybe<StopsDatabaseValueBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseValueByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseValueItemsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseValueItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseValueItemsOrderBy>>;
  where?: InputMaybe<StopsDatabaseValueItemsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseValueItemsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseValueItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseValueItemsOrderBy>>;
  where?: InputMaybe<StopsDatabaseValueItemsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseValueItemsStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseValueItemsStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseValueItemsBoolExp>;
};


export type StopsDatabaseStopsDatabaseSubscriptionStopsDatabaseValueStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<StopsDatabaseValueStreamCursorInput>>;
  where?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** columns and relationships of "tag" */
export type StopsDatabaseTag = {
  readonly __typename?: 'stops_database_tag';
  readonly comment?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly created_by?: Maybe<Scalars['String']['output']>;
  readonly name: Scalars['String']['output'];
  readonly netex_reference: Scalars['String']['output'];
  readonly removed?: Maybe<Scalars['timestamp']['output']>;
  readonly removed_by?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "tag" */
export type StopsDatabaseTagAggregate = {
  readonly __typename?: 'stops_database_tag_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseTagAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseTag>;
};

/** aggregate fields of "tag" */
export type StopsDatabaseTagAggregateFields = {
  readonly __typename?: 'stops_database_tag_aggregate_fields';
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseTagMaxFields>;
  readonly min?: Maybe<StopsDatabaseTagMinFields>;
};


/** aggregate fields of "tag" */
export type StopsDatabaseTagAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseTagSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "tag". All fields are combined with a logical 'AND'. */
export type StopsDatabaseTagBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseTagBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseTagBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseTagBoolExp>>;
  readonly comment?: InputMaybe<StringComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly created_by?: InputMaybe<StringComparisonExp>;
  readonly name?: InputMaybe<StringComparisonExp>;
  readonly netex_reference?: InputMaybe<StringComparisonExp>;
  readonly removed?: InputMaybe<TimestampComparisonExp>;
  readonly removed_by?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "tag" */
export enum StopsDatabaseTagConstraint {
  /** unique or primary key constraint on columns "netex_reference", "name" */
  TagPkey = 'tag_pkey'
}

/** input type for inserting data into table "tag" */
export type StopsDatabaseTagInsertInput = {
  readonly comment?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly created_by?: InputMaybe<Scalars['String']['input']>;
  readonly name?: InputMaybe<Scalars['String']['input']>;
  readonly netex_reference?: InputMaybe<Scalars['String']['input']>;
  readonly removed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly removed_by?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseTagMaxFields = {
  readonly __typename?: 'stops_database_tag_max_fields';
  readonly comment?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly created_by?: Maybe<Scalars['String']['output']>;
  readonly name?: Maybe<Scalars['String']['output']>;
  readonly netex_reference?: Maybe<Scalars['String']['output']>;
  readonly removed?: Maybe<Scalars['timestamp']['output']>;
  readonly removed_by?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseTagMinFields = {
  readonly __typename?: 'stops_database_tag_min_fields';
  readonly comment?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly created_by?: Maybe<Scalars['String']['output']>;
  readonly name?: Maybe<Scalars['String']['output']>;
  readonly netex_reference?: Maybe<Scalars['String']['output']>;
  readonly removed?: Maybe<Scalars['timestamp']['output']>;
  readonly removed_by?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "tag" */
export type StopsDatabaseTagMutationResponse = {
  readonly __typename?: 'stops_database_tag_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseTag>;
};

/** on_conflict condition type for table "tag" */
export type StopsDatabaseTagOnConflict = {
  readonly constraint: StopsDatabaseTagConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseTagUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseTagBoolExp>;
};

/** Ordering options when selecting data from "tag". */
export type StopsDatabaseTagOrderBy = {
  readonly comment?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly created_by?: InputMaybe<OrderBy>;
  readonly name?: InputMaybe<OrderBy>;
  readonly netex_reference?: InputMaybe<OrderBy>;
  readonly removed?: InputMaybe<OrderBy>;
  readonly removed_by?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: tag */
export type StopsDatabaseTagPkColumnsInput = {
  readonly name: Scalars['String']['input'];
  readonly netex_reference: Scalars['String']['input'];
};

/** select columns of table "tag" */
export enum StopsDatabaseTagSelectColumn {
  /** column name */
  Comment = 'comment',
  /** column name */
  Created = 'created',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Name = 'name',
  /** column name */
  NetexReference = 'netex_reference',
  /** column name */
  Removed = 'removed',
  /** column name */
  RemovedBy = 'removed_by'
}

/** input type for updating data in table "tag" */
export type StopsDatabaseTagSetInput = {
  readonly comment?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly created_by?: InputMaybe<Scalars['String']['input']>;
  readonly name?: InputMaybe<Scalars['String']['input']>;
  readonly netex_reference?: InputMaybe<Scalars['String']['input']>;
  readonly removed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly removed_by?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "tag" */
export type StopsDatabaseTagStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseTagStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseTagStreamCursorValueInput = {
  readonly comment?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly created_by?: InputMaybe<Scalars['String']['input']>;
  readonly name?: InputMaybe<Scalars['String']['input']>;
  readonly netex_reference?: InputMaybe<Scalars['String']['input']>;
  readonly removed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly removed_by?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "tag" */
export enum StopsDatabaseTagUpdateColumn {
  /** column name */
  Comment = 'comment',
  /** column name */
  Created = 'created',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Name = 'name',
  /** column name */
  NetexReference = 'netex_reference',
  /** column name */
  Removed = 'removed',
  /** column name */
  RemovedBy = 'removed_by'
}

export type StopsDatabaseTagUpdates = {
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseTagSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseTagBoolExp;
};

/** columns and relationships of "tariff_zone" */
export type StopsDatabaseTariffZone = {
  readonly __typename?: 'stops_database_tariff_zone';
  readonly centroid?: Maybe<Scalars['geometry']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id: Scalars['bigint']['output'];
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  readonly persistable_polygon?: Maybe<StopsDatabasePersistablePolygon>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  readonly tariff_zone_key_values: ReadonlyArray<StopsDatabaseTariffZoneKeyValues>;
  /** An aggregate relationship */
  readonly tariff_zone_key_values_aggregate: StopsDatabaseTariffZoneKeyValuesAggregate;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "tariff_zone" */
export type StopsDatabaseTariffZoneTariffZoneKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseTariffZoneKeyValuesBoolExp>;
};


/** columns and relationships of "tariff_zone" */
export type StopsDatabaseTariffZoneTariffZoneKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseTariffZoneKeyValuesBoolExp>;
};

/** aggregated selection of "tariff_zone" */
export type StopsDatabaseTariffZoneAggregate = {
  readonly __typename?: 'stops_database_tariff_zone_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseTariffZoneAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseTariffZone>;
};

/** aggregate fields of "tariff_zone" */
export type StopsDatabaseTariffZoneAggregateFields = {
  readonly __typename?: 'stops_database_tariff_zone_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseTariffZoneAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseTariffZoneMaxFields>;
  readonly min?: Maybe<StopsDatabaseTariffZoneMinFields>;
  readonly stddev?: Maybe<StopsDatabaseTariffZoneStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseTariffZoneStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseTariffZoneStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseTariffZoneSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseTariffZoneVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseTariffZoneVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseTariffZoneVarianceFields>;
};


/** aggregate fields of "tariff_zone" */
export type StopsDatabaseTariffZoneAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseTariffZoneAvgFields = {
  readonly __typename?: 'stops_database_tariff_zone_avg_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "tariff_zone". All fields are combined with a logical 'AND'. */
export type StopsDatabaseTariffZoneBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseTariffZoneBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneBoolExp>>;
  readonly centroid?: InputMaybe<GeometryComparisonExp>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly description_lang?: InputMaybe<StringComparisonExp>;
  readonly description_value?: InputMaybe<StringComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly name_lang?: InputMaybe<StringComparisonExp>;
  readonly name_value?: InputMaybe<StringComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  readonly polygon_id?: InputMaybe<BigintComparisonExp>;
  readonly private_code_type?: InputMaybe<StringComparisonExp>;
  readonly private_code_value?: InputMaybe<StringComparisonExp>;
  readonly short_name_lang?: InputMaybe<StringComparisonExp>;
  readonly short_name_value?: InputMaybe<StringComparisonExp>;
  readonly tariff_zone_key_values?: InputMaybe<StopsDatabaseTariffZoneKeyValuesBoolExp>;
  readonly tariff_zone_key_values_aggregate?: InputMaybe<TariffZoneKeyValuesAggregateBoolExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "tariff_zone" */
export enum StopsDatabaseTariffZoneConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  TariffZoneNetexIdVersionConstraint = 'tariff_zone_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  TariffZonePkey = 'tariff_zone_pkey'
}

/** input type for incrementing numeric columns in table "tariff_zone" */
export type StopsDatabaseTariffZoneIncInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "tariff_zone" */
export type StopsDatabaseTariffZoneInsertInput = {
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonObjRelInsertInput>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly tariff_zone_key_values?: InputMaybe<StopsDatabaseTariffZoneKeyValuesArrRelInsertInput>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValues = {
  readonly __typename?: 'stops_database_tariff_zone_key_values';
  readonly key_values_id: Scalars['bigint']['output'];
  readonly key_values_key: Scalars['String']['output'];
  readonly tariff_zone_id: Scalars['bigint']['output'];
  /** An object relationship */
  readonly value: StopsDatabaseValue;
};

/** aggregated selection of "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesAggregate = {
  readonly __typename?: 'stops_database_tariff_zone_key_values_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseTariffZoneKeyValuesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseTariffZoneKeyValues>;
};

/** aggregate fields of "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesAggregateFields = {
  readonly __typename?: 'stops_database_tariff_zone_key_values_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseTariffZoneKeyValuesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseTariffZoneKeyValuesMaxFields>;
  readonly min?: Maybe<StopsDatabaseTariffZoneKeyValuesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseTariffZoneKeyValuesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseTariffZoneKeyValuesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseTariffZoneKeyValuesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseTariffZoneKeyValuesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseTariffZoneKeyValuesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseTariffZoneKeyValuesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseTariffZoneKeyValuesVarianceFields>;
};


/** aggregate fields of "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseTariffZoneKeyValuesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseTariffZoneKeyValuesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseTariffZoneKeyValuesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseTariffZoneKeyValuesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseTariffZoneKeyValuesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseTariffZoneKeyValuesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseTariffZoneKeyValuesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseTariffZoneKeyValuesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseTariffZoneKeyValuesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseTariffZoneKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseTariffZoneKeyValuesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseTariffZoneKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseTariffZoneKeyValuesAvgFields = {
  readonly __typename?: 'stops_database_tariff_zone_key_values_avg_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly tariff_zone_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesAvgOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly tariff_zone_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "tariff_zone_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseTariffZoneKeyValuesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneKeyValuesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseTariffZoneKeyValuesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneKeyValuesBoolExp>>;
  readonly key_values_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_key?: InputMaybe<StringComparisonExp>;
  readonly tariff_zone_id?: InputMaybe<BigintComparisonExp>;
  readonly value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "tariff_zone_key_values" */
export enum StopsDatabaseTariffZoneKeyValuesConstraint {
  /** unique or primary key constraint on columns "key_values_key", "tariff_zone_id" */
  TariffZoneKeyValuesPkey = 'tariff_zone_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkN3n61qrmgry87uoc7sho0nphm = 'uk_n3n61qrmgry87uoc7sho0nphm'
}

/** input type for incrementing numeric columns in table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesIncInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly tariff_zone_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesInsertInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly tariff_zone_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseTariffZoneKeyValuesMaxFields = {
  readonly __typename?: 'stops_database_tariff_zone_key_values_max_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
  readonly tariff_zone_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesMaxOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly tariff_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseTariffZoneKeyValuesMinFields = {
  readonly __typename?: 'stops_database_tariff_zone_key_values_min_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
  readonly tariff_zone_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesMinOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly tariff_zone_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesMutationResponse = {
  readonly __typename?: 'stops_database_tariff_zone_key_values_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseTariffZoneKeyValues>;
};

/** on_conflict condition type for table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesOnConflict = {
  readonly constraint: StopsDatabaseTariffZoneKeyValuesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseTariffZoneKeyValuesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseTariffZoneKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "tariff_zone_key_values". */
export type StopsDatabaseTariffZoneKeyValuesOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly tariff_zone_id?: InputMaybe<OrderBy>;
  readonly value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: tariff_zone_key_values */
export type StopsDatabaseTariffZoneKeyValuesPkColumnsInput = {
  readonly key_values_key: Scalars['String']['input'];
  readonly tariff_zone_id: Scalars['bigint']['input'];
};

/** select columns of table "tariff_zone_key_values" */
export enum StopsDatabaseTariffZoneKeyValuesSelectColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  TariffZoneId = 'tariff_zone_id'
}

/** input type for updating data in table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesSetInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly tariff_zone_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseTariffZoneKeyValuesStddevFields = {
  readonly __typename?: 'stops_database_tariff_zone_key_values_stddev_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly tariff_zone_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesStddevOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly tariff_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseTariffZoneKeyValuesStddevPopFields = {
  readonly __typename?: 'stops_database_tariff_zone_key_values_stddev_pop_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly tariff_zone_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesStddevPopOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly tariff_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseTariffZoneKeyValuesStddevSampFields = {
  readonly __typename?: 'stops_database_tariff_zone_key_values_stddev_samp_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly tariff_zone_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesStddevSampOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly tariff_zone_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseTariffZoneKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseTariffZoneKeyValuesStreamCursorValueInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly tariff_zone_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseTariffZoneKeyValuesSumFields = {
  readonly __typename?: 'stops_database_tariff_zone_key_values_sum_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly tariff_zone_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesSumOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly tariff_zone_id?: InputMaybe<OrderBy>;
};

/** update columns of table "tariff_zone_key_values" */
export enum StopsDatabaseTariffZoneKeyValuesUpdateColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  TariffZoneId = 'tariff_zone_id'
}

export type StopsDatabaseTariffZoneKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseTariffZoneKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseTariffZoneKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseTariffZoneKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseTariffZoneKeyValuesVarPopFields = {
  readonly __typename?: 'stops_database_tariff_zone_key_values_var_pop_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly tariff_zone_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesVarPopOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly tariff_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseTariffZoneKeyValuesVarSampFields = {
  readonly __typename?: 'stops_database_tariff_zone_key_values_var_samp_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly tariff_zone_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesVarSampOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly tariff_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseTariffZoneKeyValuesVarianceFields = {
  readonly __typename?: 'stops_database_tariff_zone_key_values_variance_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly tariff_zone_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "tariff_zone_key_values" */
export type StopsDatabaseTariffZoneKeyValuesVarianceOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly tariff_zone_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseTariffZoneMaxFields = {
  readonly __typename?: 'stops_database_tariff_zone_max_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseTariffZoneMinFields = {
  readonly __typename?: 'stops_database_tariff_zone_min_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "tariff_zone" */
export type StopsDatabaseTariffZoneMutationResponse = {
  readonly __typename?: 'stops_database_tariff_zone_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseTariffZone>;
};

/** on_conflict condition type for table "tariff_zone" */
export type StopsDatabaseTariffZoneOnConflict = {
  readonly constraint: StopsDatabaseTariffZoneConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseTariffZoneUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseTariffZoneBoolExp>;
};

/** Ordering options when selecting data from "tariff_zone". */
export type StopsDatabaseTariffZoneOrderBy = {
  readonly centroid?: InputMaybe<OrderBy>;
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly description_lang?: InputMaybe<OrderBy>;
  readonly description_value?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly name_lang?: InputMaybe<OrderBy>;
  readonly name_value?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonOrderBy>;
  readonly polygon_id?: InputMaybe<OrderBy>;
  readonly private_code_type?: InputMaybe<OrderBy>;
  readonly private_code_value?: InputMaybe<OrderBy>;
  readonly short_name_lang?: InputMaybe<OrderBy>;
  readonly short_name_value?: InputMaybe<OrderBy>;
  readonly tariff_zone_key_values_aggregate?: InputMaybe<StopsDatabaseTariffZoneKeyValuesAggregateOrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: tariff_zone */
export type StopsDatabaseTariffZonePkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "tariff_zone" */
export enum StopsDatabaseTariffZoneSelectColumn {
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

/** input type for updating data in table "tariff_zone" */
export type StopsDatabaseTariffZoneSetInput = {
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseTariffZoneStddevFields = {
  readonly __typename?: 'stops_database_tariff_zone_stddev_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseTariffZoneStddevPopFields = {
  readonly __typename?: 'stops_database_tariff_zone_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseTariffZoneStddevSampFields = {
  readonly __typename?: 'stops_database_tariff_zone_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "tariff_zone" */
export type StopsDatabaseTariffZoneStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseTariffZoneStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseTariffZoneStreamCursorValueInput = {
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseTariffZoneSumFields = {
  readonly __typename?: 'stops_database_tariff_zone_sum_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "tariff_zone" */
export enum StopsDatabaseTariffZoneUpdateColumn {
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

export type StopsDatabaseTariffZoneUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseTariffZoneIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseTariffZoneSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseTariffZoneBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseTariffZoneVarPopFields = {
  readonly __typename?: 'stops_database_tariff_zone_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseTariffZoneVarSampFields = {
  readonly __typename?: 'stops_database_tariff_zone_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseTariffZoneVarianceFields = {
  readonly __typename?: 'stops_database_tariff_zone_variance_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "topographic_place" */
export type StopsDatabaseTopographicPlace = {
  readonly __typename?: 'stops_database_topographic_place';
  readonly centroid?: Maybe<Scalars['geometry']['output']>;
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly country_ref?: Maybe<Scalars['String']['output']>;
  readonly country_ref_value?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id: Scalars['bigint']['output'];
  readonly iso_code?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly parent_ref?: Maybe<Scalars['String']['output']>;
  readonly parent_ref_version?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  readonly persistable_polygon?: Maybe<StopsDatabasePersistablePolygon>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  /** An array relationship */
  readonly topographic_place_key_values: ReadonlyArray<StopsDatabaseTopographicPlaceKeyValues>;
  /** An aggregate relationship */
  readonly topographic_place_key_values_aggregate: StopsDatabaseTopographicPlaceKeyValuesAggregate;
  readonly topographic_place_type?: Maybe<Scalars['String']['output']>;
  readonly version: Scalars['bigint']['output'];
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "topographic_place" */
export type StopsDatabaseTopographicPlaceTopographicPlaceKeyValuesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesBoolExp>;
};


/** columns and relationships of "topographic_place" */
export type StopsDatabaseTopographicPlaceTopographicPlaceKeyValuesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceKeyValuesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceKeyValuesOrderBy>>;
  where?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesBoolExp>;
};

/** aggregated selection of "topographic_place" */
export type StopsDatabaseTopographicPlaceAggregate = {
  readonly __typename?: 'stops_database_topographic_place_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseTopographicPlaceAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseTopographicPlace>;
};

/** aggregate fields of "topographic_place" */
export type StopsDatabaseTopographicPlaceAggregateFields = {
  readonly __typename?: 'stops_database_topographic_place_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseTopographicPlaceAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseTopographicPlaceMaxFields>;
  readonly min?: Maybe<StopsDatabaseTopographicPlaceMinFields>;
  readonly stddev?: Maybe<StopsDatabaseTopographicPlaceStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseTopographicPlaceStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseTopographicPlaceStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseTopographicPlaceSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseTopographicPlaceVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseTopographicPlaceVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseTopographicPlaceVarianceFields>;
};


/** aggregate fields of "topographic_place" */
export type StopsDatabaseTopographicPlaceAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseTopographicPlaceAvgFields = {
  readonly __typename?: 'stops_database_topographic_place_avg_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "topographic_place". All fields are combined with a logical 'AND'. */
export type StopsDatabaseTopographicPlaceBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseTopographicPlaceBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceBoolExp>>;
  readonly centroid?: InputMaybe<GeometryComparisonExp>;
  readonly changed?: InputMaybe<TimestampComparisonExp>;
  readonly changed_by?: InputMaybe<StringComparisonExp>;
  readonly country_ref?: InputMaybe<StringComparisonExp>;
  readonly country_ref_value?: InputMaybe<StringComparisonExp>;
  readonly created?: InputMaybe<TimestampComparisonExp>;
  readonly description_lang?: InputMaybe<StringComparisonExp>;
  readonly description_value?: InputMaybe<StringComparisonExp>;
  readonly from_date?: InputMaybe<TimestampComparisonExp>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly iso_code?: InputMaybe<StringComparisonExp>;
  readonly name_lang?: InputMaybe<StringComparisonExp>;
  readonly name_value?: InputMaybe<StringComparisonExp>;
  readonly netex_id?: InputMaybe<StringComparisonExp>;
  readonly parent_ref?: InputMaybe<StringComparisonExp>;
  readonly parent_ref_version?: InputMaybe<StringComparisonExp>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonBoolExp>;
  readonly polygon_id?: InputMaybe<BigintComparisonExp>;
  readonly private_code_type?: InputMaybe<StringComparisonExp>;
  readonly private_code_value?: InputMaybe<StringComparisonExp>;
  readonly short_name_lang?: InputMaybe<StringComparisonExp>;
  readonly short_name_value?: InputMaybe<StringComparisonExp>;
  readonly to_date?: InputMaybe<TimestampComparisonExp>;
  readonly topographic_place_key_values?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesBoolExp>;
  readonly topographic_place_key_values_aggregate?: InputMaybe<TopographicPlaceKeyValuesAggregateBoolExp>;
  readonly topographic_place_type?: InputMaybe<StringComparisonExp>;
  readonly version?: InputMaybe<BigintComparisonExp>;
  readonly version_comment?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "topographic_place" */
export enum StopsDatabaseTopographicPlaceConstraint {
  /** unique or primary key constraint on columns "netex_id", "version" */
  TopographicPlaceNetexIdVersionConstraint = 'topographic_place_netex_id_version_constraint',
  /** unique or primary key constraint on columns "id" */
  TopographicPlacePkey = 'topographic_place_pkey'
}

/** input type for incrementing numeric columns in table "topographic_place" */
export type StopsDatabaseTopographicPlaceIncInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "topographic_place" */
export type StopsDatabaseTopographicPlaceInsertInput = {
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly country_ref?: InputMaybe<Scalars['String']['input']>;
  readonly country_ref_value?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly iso_code?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly parent_ref?: InputMaybe<Scalars['String']['input']>;
  readonly parent_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonObjRelInsertInput>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly topographic_place_key_values?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesArrRelInsertInput>;
  readonly topographic_place_type?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValues = {
  readonly __typename?: 'stops_database_topographic_place_key_values';
  readonly key_values_id: Scalars['bigint']['output'];
  readonly key_values_key: Scalars['String']['output'];
  readonly topographic_place_id: Scalars['bigint']['output'];
  /** An object relationship */
  readonly value: StopsDatabaseValue;
};

/** aggregated selection of "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesAggregate = {
  readonly __typename?: 'stops_database_topographic_place_key_values_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseTopographicPlaceKeyValuesAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseTopographicPlaceKeyValues>;
};

/** aggregate fields of "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesAggregateFields = {
  readonly __typename?: 'stops_database_topographic_place_key_values_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseTopographicPlaceKeyValuesAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseTopographicPlaceKeyValuesMaxFields>;
  readonly min?: Maybe<StopsDatabaseTopographicPlaceKeyValuesMinFields>;
  readonly stddev?: Maybe<StopsDatabaseTopographicPlaceKeyValuesStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseTopographicPlaceKeyValuesStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseTopographicPlaceKeyValuesStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseTopographicPlaceKeyValuesSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseTopographicPlaceKeyValuesVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseTopographicPlaceKeyValuesVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseTopographicPlaceKeyValuesVarianceFields>;
};


/** aggregate fields of "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceKeyValuesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseTopographicPlaceKeyValuesInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesOnConflict>;
};

/** aggregate avg on columns */
export type StopsDatabaseTopographicPlaceKeyValuesAvgFields = {
  readonly __typename?: 'stops_database_topographic_place_key_values_avg_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesAvgOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly topographic_place_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "topographic_place_key_values". All fields are combined with a logical 'AND'. */
export type StopsDatabaseTopographicPlaceKeyValuesBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceKeyValuesBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceKeyValuesBoolExp>>;
  readonly key_values_id?: InputMaybe<BigintComparisonExp>;
  readonly key_values_key?: InputMaybe<StringComparisonExp>;
  readonly topographic_place_id?: InputMaybe<BigintComparisonExp>;
  readonly value?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** unique or primary key constraints on table "topographic_place_key_values" */
export enum StopsDatabaseTopographicPlaceKeyValuesConstraint {
  /** unique or primary key constraint on columns "key_values_key", "topographic_place_id" */
  TopographicPlaceKeyValuesPkey = 'topographic_place_key_values_pkey',
  /** unique or primary key constraint on columns "key_values_id" */
  UkTq5dgj811w1k4w86m4x66iwso = 'uk_tq5dgj811w1k4w86m4x66iwso'
}

/** input type for incrementing numeric columns in table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesIncInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly topographic_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesInsertInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly topographic_place_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
};

/** aggregate max on columns */
export type StopsDatabaseTopographicPlaceKeyValuesMaxFields = {
  readonly __typename?: 'stops_database_topographic_place_key_values_max_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesMaxOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly topographic_place_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseTopographicPlaceKeyValuesMinFields = {
  readonly __typename?: 'stops_database_topographic_place_key_values_min_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly key_values_key?: Maybe<Scalars['String']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesMinOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly topographic_place_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesMutationResponse = {
  readonly __typename?: 'stops_database_topographic_place_key_values_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseTopographicPlaceKeyValues>;
};

/** on_conflict condition type for table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesOnConflict = {
  readonly constraint: StopsDatabaseTopographicPlaceKeyValuesConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseTopographicPlaceKeyValuesUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesBoolExp>;
};

/** Ordering options when selecting data from "topographic_place_key_values". */
export type StopsDatabaseTopographicPlaceKeyValuesOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly key_values_key?: InputMaybe<OrderBy>;
  readonly topographic_place_id?: InputMaybe<OrderBy>;
  readonly value?: InputMaybe<StopsDatabaseValueOrderBy>;
};

/** primary key columns input for table: topographic_place_key_values */
export type StopsDatabaseTopographicPlaceKeyValuesPkColumnsInput = {
  readonly key_values_key: Scalars['String']['input'];
  readonly topographic_place_id: Scalars['bigint']['input'];
};

/** select columns of table "topographic_place_key_values" */
export enum StopsDatabaseTopographicPlaceKeyValuesSelectColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  TopographicPlaceId = 'topographic_place_id'
}

/** input type for updating data in table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesSetInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly topographic_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseTopographicPlaceKeyValuesStddevFields = {
  readonly __typename?: 'stops_database_topographic_place_key_values_stddev_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesStddevOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly topographic_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseTopographicPlaceKeyValuesStddevPopFields = {
  readonly __typename?: 'stops_database_topographic_place_key_values_stddev_pop_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesStddevPopOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly topographic_place_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseTopographicPlaceKeyValuesStddevSampFields = {
  readonly __typename?: 'stops_database_topographic_place_key_values_stddev_samp_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesStddevSampOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly topographic_place_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseTopographicPlaceKeyValuesStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseTopographicPlaceKeyValuesStreamCursorValueInput = {
  readonly key_values_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly key_values_key?: InputMaybe<Scalars['String']['input']>;
  readonly topographic_place_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseTopographicPlaceKeyValuesSumFields = {
  readonly __typename?: 'stops_database_topographic_place_key_values_sum_fields';
  readonly key_values_id?: Maybe<Scalars['bigint']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesSumOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly topographic_place_id?: InputMaybe<OrderBy>;
};

/** update columns of table "topographic_place_key_values" */
export enum StopsDatabaseTopographicPlaceKeyValuesUpdateColumn {
  /** column name */
  KeyValuesId = 'key_values_id',
  /** column name */
  KeyValuesKey = 'key_values_key',
  /** column name */
  TopographicPlaceId = 'topographic_place_id'
}

export type StopsDatabaseTopographicPlaceKeyValuesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseTopographicPlaceKeyValuesBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseTopographicPlaceKeyValuesVarPopFields = {
  readonly __typename?: 'stops_database_topographic_place_key_values_var_pop_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesVarPopOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly topographic_place_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseTopographicPlaceKeyValuesVarSampFields = {
  readonly __typename?: 'stops_database_topographic_place_key_values_var_samp_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesVarSampOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly topographic_place_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseTopographicPlaceKeyValuesVarianceFields = {
  readonly __typename?: 'stops_database_topographic_place_key_values_variance_fields';
  readonly key_values_id?: Maybe<Scalars['Float']['output']>;
  readonly topographic_place_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "topographic_place_key_values" */
export type StopsDatabaseTopographicPlaceKeyValuesVarianceOrderBy = {
  readonly key_values_id?: InputMaybe<OrderBy>;
  readonly topographic_place_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseTopographicPlaceMaxFields = {
  readonly __typename?: 'stops_database_topographic_place_max_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly country_ref?: Maybe<Scalars['String']['output']>;
  readonly country_ref_value?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly iso_code?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly parent_ref?: Maybe<Scalars['String']['output']>;
  readonly parent_ref_version?: Maybe<Scalars['String']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly topographic_place_type?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseTopographicPlaceMinFields = {
  readonly __typename?: 'stops_database_topographic_place_min_fields';
  readonly changed?: Maybe<Scalars['timestamp']['output']>;
  readonly changed_by?: Maybe<Scalars['String']['output']>;
  readonly country_ref?: Maybe<Scalars['String']['output']>;
  readonly country_ref_value?: Maybe<Scalars['String']['output']>;
  readonly created?: Maybe<Scalars['timestamp']['output']>;
  readonly description_lang?: Maybe<Scalars['String']['output']>;
  readonly description_value?: Maybe<Scalars['String']['output']>;
  readonly from_date?: Maybe<Scalars['timestamp']['output']>;
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly iso_code?: Maybe<Scalars['String']['output']>;
  readonly name_lang?: Maybe<Scalars['String']['output']>;
  readonly name_value?: Maybe<Scalars['String']['output']>;
  readonly netex_id?: Maybe<Scalars['String']['output']>;
  readonly parent_ref?: Maybe<Scalars['String']['output']>;
  readonly parent_ref_version?: Maybe<Scalars['String']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly private_code_type?: Maybe<Scalars['String']['output']>;
  readonly private_code_value?: Maybe<Scalars['String']['output']>;
  readonly short_name_lang?: Maybe<Scalars['String']['output']>;
  readonly short_name_value?: Maybe<Scalars['String']['output']>;
  readonly to_date?: Maybe<Scalars['timestamp']['output']>;
  readonly topographic_place_type?: Maybe<Scalars['String']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
  readonly version_comment?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "topographic_place" */
export type StopsDatabaseTopographicPlaceMutationResponse = {
  readonly __typename?: 'stops_database_topographic_place_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseTopographicPlace>;
};

/** input type for inserting object relation for remote table "topographic_place" */
export type StopsDatabaseTopographicPlaceObjRelInsertInput = {
  readonly data: StopsDatabaseTopographicPlaceInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseTopographicPlaceOnConflict>;
};

/** on_conflict condition type for table "topographic_place" */
export type StopsDatabaseTopographicPlaceOnConflict = {
  readonly constraint: StopsDatabaseTopographicPlaceConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseTopographicPlaceUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseTopographicPlaceBoolExp>;
};

/** Ordering options when selecting data from "topographic_place". */
export type StopsDatabaseTopographicPlaceOrderBy = {
  readonly centroid?: InputMaybe<OrderBy>;
  readonly changed?: InputMaybe<OrderBy>;
  readonly changed_by?: InputMaybe<OrderBy>;
  readonly country_ref?: InputMaybe<OrderBy>;
  readonly country_ref_value?: InputMaybe<OrderBy>;
  readonly created?: InputMaybe<OrderBy>;
  readonly description_lang?: InputMaybe<OrderBy>;
  readonly description_value?: InputMaybe<OrderBy>;
  readonly from_date?: InputMaybe<OrderBy>;
  readonly id?: InputMaybe<OrderBy>;
  readonly iso_code?: InputMaybe<OrderBy>;
  readonly name_lang?: InputMaybe<OrderBy>;
  readonly name_value?: InputMaybe<OrderBy>;
  readonly netex_id?: InputMaybe<OrderBy>;
  readonly parent_ref?: InputMaybe<OrderBy>;
  readonly parent_ref_version?: InputMaybe<OrderBy>;
  readonly persistable_polygon?: InputMaybe<StopsDatabasePersistablePolygonOrderBy>;
  readonly polygon_id?: InputMaybe<OrderBy>;
  readonly private_code_type?: InputMaybe<OrderBy>;
  readonly private_code_value?: InputMaybe<OrderBy>;
  readonly short_name_lang?: InputMaybe<OrderBy>;
  readonly short_name_value?: InputMaybe<OrderBy>;
  readonly to_date?: InputMaybe<OrderBy>;
  readonly topographic_place_key_values_aggregate?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesAggregateOrderBy>;
  readonly topographic_place_type?: InputMaybe<OrderBy>;
  readonly version?: InputMaybe<OrderBy>;
  readonly version_comment?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: topographic_place */
export type StopsDatabaseTopographicPlacePkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "topographic_place" */
export enum StopsDatabaseTopographicPlaceSelectColumn {
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  CountryRef = 'country_ref',
  /** column name */
  CountryRefValue = 'country_ref_value',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  IsoCode = 'iso_code',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ParentRef = 'parent_ref',
  /** column name */
  ParentRefVersion = 'parent_ref_version',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TopographicPlaceType = 'topographic_place_type',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

/** input type for updating data in table "topographic_place" */
export type StopsDatabaseTopographicPlaceSetInput = {
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly country_ref?: InputMaybe<Scalars['String']['input']>;
  readonly country_ref_value?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly iso_code?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly parent_ref?: InputMaybe<Scalars['String']['input']>;
  readonly parent_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly topographic_place_type?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseTopographicPlaceStddevFields = {
  readonly __typename?: 'stops_database_topographic_place_stddev_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseTopographicPlaceStddevPopFields = {
  readonly __typename?: 'stops_database_topographic_place_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseTopographicPlaceStddevSampFields = {
  readonly __typename?: 'stops_database_topographic_place_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "topographic_place" */
export type StopsDatabaseTopographicPlaceStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseTopographicPlaceStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseTopographicPlaceStreamCursorValueInput = {
  readonly centroid?: InputMaybe<Scalars['geometry']['input']>;
  readonly changed?: InputMaybe<Scalars['timestamp']['input']>;
  readonly changed_by?: InputMaybe<Scalars['String']['input']>;
  readonly country_ref?: InputMaybe<Scalars['String']['input']>;
  readonly country_ref_value?: InputMaybe<Scalars['String']['input']>;
  readonly created?: InputMaybe<Scalars['timestamp']['input']>;
  readonly description_lang?: InputMaybe<Scalars['String']['input']>;
  readonly description_value?: InputMaybe<Scalars['String']['input']>;
  readonly from_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly iso_code?: InputMaybe<Scalars['String']['input']>;
  readonly name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly name_value?: InputMaybe<Scalars['String']['input']>;
  readonly netex_id?: InputMaybe<Scalars['String']['input']>;
  readonly parent_ref?: InputMaybe<Scalars['String']['input']>;
  readonly parent_ref_version?: InputMaybe<Scalars['String']['input']>;
  readonly polygon_id?: InputMaybe<Scalars['bigint']['input']>;
  readonly private_code_type?: InputMaybe<Scalars['String']['input']>;
  readonly private_code_value?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_lang?: InputMaybe<Scalars['String']['input']>;
  readonly short_name_value?: InputMaybe<Scalars['String']['input']>;
  readonly to_date?: InputMaybe<Scalars['timestamp']['input']>;
  readonly topographic_place_type?: InputMaybe<Scalars['String']['input']>;
  readonly version?: InputMaybe<Scalars['bigint']['input']>;
  readonly version_comment?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseTopographicPlaceSumFields = {
  readonly __typename?: 'stops_database_topographic_place_sum_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
  readonly polygon_id?: Maybe<Scalars['bigint']['output']>;
  readonly version?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "topographic_place" */
export enum StopsDatabaseTopographicPlaceUpdateColumn {
  /** column name */
  Centroid = 'centroid',
  /** column name */
  Changed = 'changed',
  /** column name */
  ChangedBy = 'changed_by',
  /** column name */
  CountryRef = 'country_ref',
  /** column name */
  CountryRefValue = 'country_ref_value',
  /** column name */
  Created = 'created',
  /** column name */
  DescriptionLang = 'description_lang',
  /** column name */
  DescriptionValue = 'description_value',
  /** column name */
  FromDate = 'from_date',
  /** column name */
  Id = 'id',
  /** column name */
  IsoCode = 'iso_code',
  /** column name */
  NameLang = 'name_lang',
  /** column name */
  NameValue = 'name_value',
  /** column name */
  NetexId = 'netex_id',
  /** column name */
  ParentRef = 'parent_ref',
  /** column name */
  ParentRefVersion = 'parent_ref_version',
  /** column name */
  PolygonId = 'polygon_id',
  /** column name */
  PrivateCodeType = 'private_code_type',
  /** column name */
  PrivateCodeValue = 'private_code_value',
  /** column name */
  ShortNameLang = 'short_name_lang',
  /** column name */
  ShortNameValue = 'short_name_value',
  /** column name */
  ToDate = 'to_date',
  /** column name */
  TopographicPlaceType = 'topographic_place_type',
  /** column name */
  Version = 'version',
  /** column name */
  VersionComment = 'version_comment'
}

export type StopsDatabaseTopographicPlaceUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseTopographicPlaceIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseTopographicPlaceSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseTopographicPlaceBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseTopographicPlaceVarPopFields = {
  readonly __typename?: 'stops_database_topographic_place_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseTopographicPlaceVarSampFields = {
  readonly __typename?: 'stops_database_topographic_place_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseTopographicPlaceVarianceFields = {
  readonly __typename?: 'stops_database_topographic_place_variance_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
  readonly polygon_id?: Maybe<Scalars['Float']['output']>;
  readonly version?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "value" */
export type StopsDatabaseValue = {
  readonly __typename?: 'stops_database_value';
  readonly id: Scalars['bigint']['output'];
  /** An array relationship */
  readonly value_items: ReadonlyArray<StopsDatabaseValueItems>;
  /** An aggregate relationship */
  readonly value_items_aggregate: StopsDatabaseValueItemsAggregate;
};


/** columns and relationships of "value" */
export type StopsDatabaseValueValueItemsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseValueItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseValueItemsOrderBy>>;
  where?: InputMaybe<StopsDatabaseValueItemsBoolExp>;
};


/** columns and relationships of "value" */
export type StopsDatabaseValueValueItemsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<StopsDatabaseValueItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<StopsDatabaseValueItemsOrderBy>>;
  where?: InputMaybe<StopsDatabaseValueItemsBoolExp>;
};

/** aggregated selection of "value" */
export type StopsDatabaseValueAggregate = {
  readonly __typename?: 'stops_database_value_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseValueAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseValue>;
};

/** aggregate fields of "value" */
export type StopsDatabaseValueAggregateFields = {
  readonly __typename?: 'stops_database_value_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseValueAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseValueMaxFields>;
  readonly min?: Maybe<StopsDatabaseValueMinFields>;
  readonly stddev?: Maybe<StopsDatabaseValueStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseValueStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseValueStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseValueSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseValueVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseValueVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseValueVarianceFields>;
};


/** aggregate fields of "value" */
export type StopsDatabaseValueAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseValueSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StopsDatabaseValueAvgFields = {
  readonly __typename?: 'stops_database_value_avg_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "value". All fields are combined with a logical 'AND'. */
export type StopsDatabaseValueBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseValueBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseValueBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseValueBoolExp>>;
  readonly id?: InputMaybe<BigintComparisonExp>;
  readonly value_items?: InputMaybe<StopsDatabaseValueItemsBoolExp>;
  readonly value_items_aggregate?: InputMaybe<ValueItemsAggregateBoolExp>;
};

/** unique or primary key constraints on table "value" */
export enum StopsDatabaseValueConstraint {
  /** unique or primary key constraint on columns "id" */
  ValuePkey = 'value_pkey'
}

/** input type for incrementing numeric columns in table "value" */
export type StopsDatabaseValueIncInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "value" */
export type StopsDatabaseValueInsertInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
  readonly value_items?: InputMaybe<StopsDatabaseValueItemsArrRelInsertInput>;
};

/** columns and relationships of "value_items" */
export type StopsDatabaseValueItems = {
  readonly __typename?: 'stops_database_value_items';
  readonly items?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  readonly value: StopsDatabaseValue;
  readonly value_id: Scalars['bigint']['output'];
};

/** aggregated selection of "value_items" */
export type StopsDatabaseValueItemsAggregate = {
  readonly __typename?: 'stops_database_value_items_aggregate';
  readonly aggregate?: Maybe<StopsDatabaseValueItemsAggregateFields>;
  readonly nodes: ReadonlyArray<StopsDatabaseValueItems>;
};

/** aggregate fields of "value_items" */
export type StopsDatabaseValueItemsAggregateFields = {
  readonly __typename?: 'stops_database_value_items_aggregate_fields';
  readonly avg?: Maybe<StopsDatabaseValueItemsAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<StopsDatabaseValueItemsMaxFields>;
  readonly min?: Maybe<StopsDatabaseValueItemsMinFields>;
  readonly stddev?: Maybe<StopsDatabaseValueItemsStddevFields>;
  readonly stddev_pop?: Maybe<StopsDatabaseValueItemsStddevPopFields>;
  readonly stddev_samp?: Maybe<StopsDatabaseValueItemsStddevSampFields>;
  readonly sum?: Maybe<StopsDatabaseValueItemsSumFields>;
  readonly var_pop?: Maybe<StopsDatabaseValueItemsVarPopFields>;
  readonly var_samp?: Maybe<StopsDatabaseValueItemsVarSampFields>;
  readonly variance?: Maybe<StopsDatabaseValueItemsVarianceFields>;
};


/** aggregate fields of "value_items" */
export type StopsDatabaseValueItemsAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<StopsDatabaseValueItemsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "value_items" */
export type StopsDatabaseValueItemsAggregateOrderBy = {
  readonly avg?: InputMaybe<StopsDatabaseValueItemsAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<StopsDatabaseValueItemsMaxOrderBy>;
  readonly min?: InputMaybe<StopsDatabaseValueItemsMinOrderBy>;
  readonly stddev?: InputMaybe<StopsDatabaseValueItemsStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<StopsDatabaseValueItemsStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<StopsDatabaseValueItemsStddevSampOrderBy>;
  readonly sum?: InputMaybe<StopsDatabaseValueItemsSumOrderBy>;
  readonly var_pop?: InputMaybe<StopsDatabaseValueItemsVarPopOrderBy>;
  readonly var_samp?: InputMaybe<StopsDatabaseValueItemsVarSampOrderBy>;
  readonly variance?: InputMaybe<StopsDatabaseValueItemsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "value_items" */
export type StopsDatabaseValueItemsArrRelInsertInput = {
  readonly data: ReadonlyArray<StopsDatabaseValueItemsInsertInput>;
};

/** aggregate avg on columns */
export type StopsDatabaseValueItemsAvgFields = {
  readonly __typename?: 'stops_database_value_items_avg_fields';
  readonly value_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "value_items" */
export type StopsDatabaseValueItemsAvgOrderBy = {
  readonly value_id?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "value_items". All fields are combined with a logical 'AND'. */
export type StopsDatabaseValueItemsBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<StopsDatabaseValueItemsBoolExp>>;
  readonly _not?: InputMaybe<StopsDatabaseValueItemsBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<StopsDatabaseValueItemsBoolExp>>;
  readonly items?: InputMaybe<StringComparisonExp>;
  readonly value?: InputMaybe<StopsDatabaseValueBoolExp>;
  readonly value_id?: InputMaybe<BigintComparisonExp>;
};

/** input type for incrementing numeric columns in table "value_items" */
export type StopsDatabaseValueItemsIncInput = {
  readonly value_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "value_items" */
export type StopsDatabaseValueItemsInsertInput = {
  readonly items?: InputMaybe<Scalars['String']['input']>;
  readonly value?: InputMaybe<StopsDatabaseValueObjRelInsertInput>;
  readonly value_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate max on columns */
export type StopsDatabaseValueItemsMaxFields = {
  readonly __typename?: 'stops_database_value_items_max_fields';
  readonly items?: Maybe<Scalars['String']['output']>;
  readonly value_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by max() on columns of table "value_items" */
export type StopsDatabaseValueItemsMaxOrderBy = {
  readonly items?: InputMaybe<OrderBy>;
  readonly value_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type StopsDatabaseValueItemsMinFields = {
  readonly __typename?: 'stops_database_value_items_min_fields';
  readonly items?: Maybe<Scalars['String']['output']>;
  readonly value_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by min() on columns of table "value_items" */
export type StopsDatabaseValueItemsMinOrderBy = {
  readonly items?: InputMaybe<OrderBy>;
  readonly value_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "value_items" */
export type StopsDatabaseValueItemsMutationResponse = {
  readonly __typename?: 'stops_database_value_items_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseValueItems>;
};

/** Ordering options when selecting data from "value_items". */
export type StopsDatabaseValueItemsOrderBy = {
  readonly items?: InputMaybe<OrderBy>;
  readonly value?: InputMaybe<StopsDatabaseValueOrderBy>;
  readonly value_id?: InputMaybe<OrderBy>;
};

/** select columns of table "value_items" */
export enum StopsDatabaseValueItemsSelectColumn {
  /** column name */
  Items = 'items',
  /** column name */
  ValueId = 'value_id'
}

/** input type for updating data in table "value_items" */
export type StopsDatabaseValueItemsSetInput = {
  readonly items?: InputMaybe<Scalars['String']['input']>;
  readonly value_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseValueItemsStddevFields = {
  readonly __typename?: 'stops_database_value_items_stddev_fields';
  readonly value_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "value_items" */
export type StopsDatabaseValueItemsStddevOrderBy = {
  readonly value_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseValueItemsStddevPopFields = {
  readonly __typename?: 'stops_database_value_items_stddev_pop_fields';
  readonly value_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "value_items" */
export type StopsDatabaseValueItemsStddevPopOrderBy = {
  readonly value_id?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseValueItemsStddevSampFields = {
  readonly __typename?: 'stops_database_value_items_stddev_samp_fields';
  readonly value_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "value_items" */
export type StopsDatabaseValueItemsStddevSampOrderBy = {
  readonly value_id?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "value_items" */
export type StopsDatabaseValueItemsStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseValueItemsStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseValueItemsStreamCursorValueInput = {
  readonly items?: InputMaybe<Scalars['String']['input']>;
  readonly value_id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseValueItemsSumFields = {
  readonly __typename?: 'stops_database_value_items_sum_fields';
  readonly value_id?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "value_items" */
export type StopsDatabaseValueItemsSumOrderBy = {
  readonly value_id?: InputMaybe<OrderBy>;
};

export type StopsDatabaseValueItemsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseValueItemsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseValueItemsSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseValueItemsBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseValueItemsVarPopFields = {
  readonly __typename?: 'stops_database_value_items_var_pop_fields';
  readonly value_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "value_items" */
export type StopsDatabaseValueItemsVarPopOrderBy = {
  readonly value_id?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseValueItemsVarSampFields = {
  readonly __typename?: 'stops_database_value_items_var_samp_fields';
  readonly value_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "value_items" */
export type StopsDatabaseValueItemsVarSampOrderBy = {
  readonly value_id?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type StopsDatabaseValueItemsVarianceFields = {
  readonly __typename?: 'stops_database_value_items_variance_fields';
  readonly value_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "value_items" */
export type StopsDatabaseValueItemsVarianceOrderBy = {
  readonly value_id?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type StopsDatabaseValueMaxFields = {
  readonly __typename?: 'stops_database_value_max_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type StopsDatabaseValueMinFields = {
  readonly __typename?: 'stops_database_value_min_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
};

/** response of any mutation on the table "value" */
export type StopsDatabaseValueMutationResponse = {
  readonly __typename?: 'stops_database_value_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<StopsDatabaseValue>;
};

/** input type for inserting object relation for remote table "value" */
export type StopsDatabaseValueObjRelInsertInput = {
  readonly data: StopsDatabaseValueInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<StopsDatabaseValueOnConflict>;
};

/** on_conflict condition type for table "value" */
export type StopsDatabaseValueOnConflict = {
  readonly constraint: StopsDatabaseValueConstraint;
  readonly update_columns?: ReadonlyArray<StopsDatabaseValueUpdateColumn>;
  readonly where?: InputMaybe<StopsDatabaseValueBoolExp>;
};

/** Ordering options when selecting data from "value". */
export type StopsDatabaseValueOrderBy = {
  readonly id?: InputMaybe<OrderBy>;
  readonly value_items_aggregate?: InputMaybe<StopsDatabaseValueItemsAggregateOrderBy>;
};

/** primary key columns input for table: value */
export type StopsDatabaseValuePkColumnsInput = {
  readonly id: Scalars['bigint']['input'];
};

/** select columns of table "value" */
export enum StopsDatabaseValueSelectColumn {
  /** column name */
  Id = 'id'
}

/** input type for updating data in table "value" */
export type StopsDatabaseValueSetInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate stddev on columns */
export type StopsDatabaseValueStddevFields = {
  readonly __typename?: 'stops_database_value_stddev_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type StopsDatabaseValueStddevPopFields = {
  readonly __typename?: 'stops_database_value_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type StopsDatabaseValueStddevSampFields = {
  readonly __typename?: 'stops_database_value_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "value" */
export type StopsDatabaseValueStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: StopsDatabaseValueStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<StopsDatabaseCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StopsDatabaseValueStreamCursorValueInput = {
  readonly id?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StopsDatabaseValueSumFields = {
  readonly __typename?: 'stops_database_value_sum_fields';
  readonly id?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "value" */
export enum StopsDatabaseValueUpdateColumn {
  /** column name */
  Id = 'id'
}

export type StopsDatabaseValueUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<StopsDatabaseValueIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<StopsDatabaseValueSetInput>;
  /** filter the rows which have to be updated */
  readonly where: StopsDatabaseValueBoolExp;
};

/** aggregate var_pop on columns */
export type StopsDatabaseValueVarPopFields = {
  readonly __typename?: 'stops_database_value_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type StopsDatabaseValueVarSampFields = {
  readonly __typename?: 'stops_database_value_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StopsDatabaseValueVarianceFields = {
  readonly __typename?: 'stops_database_value_variance_fields';
  readonly id?: Maybe<Scalars['Float']['output']>;
};

export type SubscriptionRoot = {
  readonly __typename?: 'subscription_root';
  /** fetch data from the table: "hsl_route.legacy_hsl_municipality_code" */
  readonly hsl_route_legacy_hsl_municipality_code: ReadonlyArray<HslRouteLegacyHslMunicipalityCode>;
  /** fetch aggregated fields from the table: "hsl_route.legacy_hsl_municipality_code" */
  readonly hsl_route_legacy_hsl_municipality_code_aggregate: HslRouteLegacyHslMunicipalityCodeAggregate;
  /** fetch data from the table: "hsl_route.legacy_hsl_municipality_code" using primary key columns */
  readonly hsl_route_legacy_hsl_municipality_code_by_pk?: Maybe<HslRouteLegacyHslMunicipalityCode>;
  /** fetch data from the table in a streaming manner: "hsl_route.legacy_hsl_municipality_code" */
  readonly hsl_route_legacy_hsl_municipality_code_stream: ReadonlyArray<HslRouteLegacyHslMunicipalityCode>;
  /** fetch data from the table: "hsl_route.transport_target" */
  readonly hsl_route_transport_target: ReadonlyArray<HslRouteTransportTarget>;
  /** fetch aggregated fields from the table: "hsl_route.transport_target" */
  readonly hsl_route_transport_target_aggregate: HslRouteTransportTargetAggregate;
  /** fetch data from the table: "hsl_route.transport_target" using primary key columns */
  readonly hsl_route_transport_target_by_pk?: Maybe<HslRouteTransportTarget>;
  /** fetch data from the table in a streaming manner: "hsl_route.transport_target" */
  readonly hsl_route_transport_target_stream: ReadonlyArray<HslRouteTransportTarget>;
  /** fetch data from the table: "infrastructure_network.direction" */
  readonly infrastructure_network_direction: ReadonlyArray<InfrastructureNetworkDirection>;
  /** fetch aggregated fields from the table: "infrastructure_network.direction" */
  readonly infrastructure_network_direction_aggregate: InfrastructureNetworkDirectionAggregate;
  /** fetch data from the table: "infrastructure_network.direction" using primary key columns */
  readonly infrastructure_network_direction_by_pk?: Maybe<InfrastructureNetworkDirection>;
  /** fetch data from the table in a streaming manner: "infrastructure_network.direction" */
  readonly infrastructure_network_direction_stream: ReadonlyArray<InfrastructureNetworkDirection>;
  /** fetch data from the table: "infrastructure_network.external_source" */
  readonly infrastructure_network_external_source: ReadonlyArray<InfrastructureNetworkExternalSource>;
  /** fetch aggregated fields from the table: "infrastructure_network.external_source" */
  readonly infrastructure_network_external_source_aggregate: InfrastructureNetworkExternalSourceAggregate;
  /** fetch data from the table: "infrastructure_network.external_source" using primary key columns */
  readonly infrastructure_network_external_source_by_pk?: Maybe<InfrastructureNetworkExternalSource>;
  /** fetch data from the table in a streaming manner: "infrastructure_network.external_source" */
  readonly infrastructure_network_external_source_stream: ReadonlyArray<InfrastructureNetworkExternalSource>;
  /** execute function "infrastructure_network.find_point_direction_on_link" which returns "infrastructure_network.direction" */
  readonly infrastructure_network_find_point_direction_on_link: ReadonlyArray<InfrastructureNetworkDirection>;
  /** execute function "infrastructure_network.find_point_direction_on_link" and query aggregates on result of table type "infrastructure_network.direction" */
  readonly infrastructure_network_find_point_direction_on_link_aggregate: InfrastructureNetworkDirectionAggregate;
  /** fetch data from the table: "infrastructure_network.infrastructure_link" */
  readonly infrastructure_network_infrastructure_link: ReadonlyArray<InfrastructureNetworkInfrastructureLink>;
  /** fetch aggregated fields from the table: "infrastructure_network.infrastructure_link" */
  readonly infrastructure_network_infrastructure_link_aggregate: InfrastructureNetworkInfrastructureLinkAggregate;
  /** fetch data from the table: "infrastructure_network.infrastructure_link" using primary key columns */
  readonly infrastructure_network_infrastructure_link_by_pk?: Maybe<InfrastructureNetworkInfrastructureLink>;
  /** fetch data from the table in a streaming manner: "infrastructure_network.infrastructure_link" */
  readonly infrastructure_network_infrastructure_link_stream: ReadonlyArray<InfrastructureNetworkInfrastructureLink>;
  /** execute function "infrastructure_network.resolve_point_to_closest_link" which returns "infrastructure_network.infrastructure_link" */
  readonly infrastructure_network_resolve_point_to_closest_link: ReadonlyArray<InfrastructureNetworkInfrastructureLink>;
  /** execute function "infrastructure_network.resolve_point_to_closest_link" and query aggregates on result of table type "infrastructure_network.infrastructure_link" */
  readonly infrastructure_network_resolve_point_to_closest_link_aggregate: InfrastructureNetworkInfrastructureLinkAggregate;
  /** fetch data from the table: "infrastructure_network.vehicle_submode_on_infrastructure_link" */
  readonly infrastructure_network_vehicle_submode_on_infrastructure_link: ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
  /** fetch aggregated fields from the table: "infrastructure_network.vehicle_submode_on_infrastructure_link" */
  readonly infrastructure_network_vehicle_submode_on_infrastructure_link_aggregate: InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregate;
  /** fetch data from the table: "infrastructure_network.vehicle_submode_on_infrastructure_link" using primary key columns */
  readonly infrastructure_network_vehicle_submode_on_infrastructure_link_by_pk?: Maybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
  /** fetch data from the table in a streaming manner: "infrastructure_network.vehicle_submode_on_infrastructure_link" */
  readonly infrastructure_network_vehicle_submode_on_infrastructure_link_stream: ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLink>;
  /** execute function "journey_pattern.check_infra_link_stop_refs_with_new_scheduled_stop_point" which returns "journey_pattern.journey_pattern" */
  readonly journey_pattern_check_infra_link_stop_refs_with_new_scheduled_stop_point: ReadonlyArray<JourneyPatternJourneyPattern>;
  /** execute function "journey_pattern.check_infra_link_stop_refs_with_new_scheduled_stop_point" and query aggregates on result of table type "journey_pattern.journey_pattern" */
  readonly journey_pattern_check_infra_link_stop_refs_with_new_scheduled_stop_point_aggregate: JourneyPatternJourneyPatternAggregate;
  /** fetch data from the table: "journey_pattern.journey_pattern" */
  readonly journey_pattern_journey_pattern: ReadonlyArray<JourneyPatternJourneyPattern>;
  /** fetch aggregated fields from the table: "journey_pattern.journey_pattern" */
  readonly journey_pattern_journey_pattern_aggregate: JourneyPatternJourneyPatternAggregate;
  /** fetch data from the table: "journey_pattern.journey_pattern" using primary key columns */
  readonly journey_pattern_journey_pattern_by_pk?: Maybe<JourneyPatternJourneyPattern>;
  /** fetch data from the table in a streaming manner: "journey_pattern.journey_pattern" */
  readonly journey_pattern_journey_pattern_stream: ReadonlyArray<JourneyPatternJourneyPattern>;
  /** fetch data from the table: "journey_pattern.scheduled_stop_point_in_journey_pattern" */
  readonly journey_pattern_scheduled_stop_point_in_journey_pattern: ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPattern>;
  /** fetch aggregated fields from the table: "journey_pattern.scheduled_stop_point_in_journey_pattern" */
  readonly journey_pattern_scheduled_stop_point_in_journey_pattern_aggregate: JourneyPatternScheduledStopPointInJourneyPatternAggregate;
  /** fetch data from the table: "journey_pattern.scheduled_stop_point_in_journey_pattern" using primary key columns */
  readonly journey_pattern_scheduled_stop_point_in_journey_pattern_by_pk?: Maybe<JourneyPatternScheduledStopPointInJourneyPattern>;
  /** fetch data from the table in a streaming manner: "journey_pattern.scheduled_stop_point_in_journey_pattern" */
  readonly journey_pattern_scheduled_stop_point_in_journey_pattern_stream: ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPattern>;
  /** fetch data from the table: "reusable_components.vehicle_mode" */
  readonly reusable_components_vehicle_mode: ReadonlyArray<ReusableComponentsVehicleMode>;
  /** fetch aggregated fields from the table: "reusable_components.vehicle_mode" */
  readonly reusable_components_vehicle_mode_aggregate: ReusableComponentsVehicleModeAggregate;
  /** fetch data from the table: "reusable_components.vehicle_mode" using primary key columns */
  readonly reusable_components_vehicle_mode_by_pk?: Maybe<ReusableComponentsVehicleMode>;
  /** fetch data from the table in a streaming manner: "reusable_components.vehicle_mode" */
  readonly reusable_components_vehicle_mode_stream: ReadonlyArray<ReusableComponentsVehicleMode>;
  /** fetch data from the table: "reusable_components.vehicle_submode" */
  readonly reusable_components_vehicle_submode: ReadonlyArray<ReusableComponentsVehicleSubmode>;
  /** fetch aggregated fields from the table: "reusable_components.vehicle_submode" */
  readonly reusable_components_vehicle_submode_aggregate: ReusableComponentsVehicleSubmodeAggregate;
  /** fetch data from the table: "reusable_components.vehicle_submode" using primary key columns */
  readonly reusable_components_vehicle_submode_by_pk?: Maybe<ReusableComponentsVehicleSubmode>;
  /** fetch data from the table in a streaming manner: "reusable_components.vehicle_submode" */
  readonly reusable_components_vehicle_submode_stream: ReadonlyArray<ReusableComponentsVehicleSubmode>;
  /** fetch data from the table: "route.direction" */
  readonly route_direction: ReadonlyArray<RouteDirection>;
  /** fetch aggregated fields from the table: "route.direction" */
  readonly route_direction_aggregate: RouteDirectionAggregate;
  /** fetch data from the table: "route.direction" using primary key columns */
  readonly route_direction_by_pk?: Maybe<RouteDirection>;
  /** fetch data from the table in a streaming manner: "route.direction" */
  readonly route_direction_stream: ReadonlyArray<RouteDirection>;
  /** fetch data from the table: "route.infrastructure_link_along_route" */
  readonly route_infrastructure_link_along_route: ReadonlyArray<RouteInfrastructureLinkAlongRoute>;
  /** fetch aggregated fields from the table: "route.infrastructure_link_along_route" */
  readonly route_infrastructure_link_along_route_aggregate: RouteInfrastructureLinkAlongRouteAggregate;
  /** fetch data from the table: "route.infrastructure_link_along_route" using primary key columns */
  readonly route_infrastructure_link_along_route_by_pk?: Maybe<RouteInfrastructureLinkAlongRoute>;
  /** fetch data from the table in a streaming manner: "route.infrastructure_link_along_route" */
  readonly route_infrastructure_link_along_route_stream: ReadonlyArray<RouteInfrastructureLinkAlongRoute>;
  /** fetch data from the table: "route.line" */
  readonly route_line: ReadonlyArray<RouteLine>;
  /** fetch aggregated fields from the table: "route.line" */
  readonly route_line_aggregate: RouteLineAggregate;
  /** fetch data from the table: "route.line" using primary key columns */
  readonly route_line_by_pk?: Maybe<RouteLine>;
  /** fetch data from the table in a streaming manner: "route.line" */
  readonly route_line_stream: ReadonlyArray<RouteLine>;
  /** fetch data from the table: "route.route" */
  readonly route_route: ReadonlyArray<RouteRoute>;
  /** fetch aggregated fields from the table: "route.route" */
  readonly route_route_aggregate: RouteRouteAggregate;
  /** fetch data from the table: "route.route" using primary key columns */
  readonly route_route_by_pk?: Maybe<RouteRoute>;
  /** fetch data from the table in a streaming manner: "route.route" */
  readonly route_route_stream: ReadonlyArray<RouteRoute>;
  /** fetch data from the table: "route.type_of_line" */
  readonly route_type_of_line: ReadonlyArray<RouteTypeOfLine>;
  /** fetch aggregated fields from the table: "route.type_of_line" */
  readonly route_type_of_line_aggregate: RouteTypeOfLineAggregate;
  /** fetch data from the table: "route.type_of_line" using primary key columns */
  readonly route_type_of_line_by_pk?: Maybe<RouteTypeOfLine>;
  /** fetch data from the table in a streaming manner: "route.type_of_line" */
  readonly route_type_of_line_stream: ReadonlyArray<RouteTypeOfLine>;
  /** fetch data from the table: "service_pattern.distance_between_stops_calculation" */
  readonly service_pattern_distance_between_stops_calculation: ReadonlyArray<ServicePatternDistanceBetweenStopsCalculation>;
  /** fetch aggregated fields from the table: "service_pattern.distance_between_stops_calculation" */
  readonly service_pattern_distance_between_stops_calculation_aggregate: ServicePatternDistanceBetweenStopsCalculationAggregate;
  /** fetch data from the table: "service_pattern.distance_between_stops_calculation" using primary key columns */
  readonly service_pattern_distance_between_stops_calculation_by_pk?: Maybe<ServicePatternDistanceBetweenStopsCalculation>;
  /** fetch data from the table in a streaming manner: "service_pattern.distance_between_stops_calculation" */
  readonly service_pattern_distance_between_stops_calculation_stream: ReadonlyArray<ServicePatternDistanceBetweenStopsCalculation>;
  /** execute function "service_pattern.get_distances_between_stop_points_by_routes" which returns "service_pattern.distance_between_stops_calculation" */
  readonly service_pattern_get_distances_between_stop_points_by_routes: ReadonlyArray<ServicePatternDistanceBetweenStopsCalculation>;
  /** execute function "service_pattern.get_distances_between_stop_points_by_routes" and query aggregates on result of table type "service_pattern.distance_between_stops_calculation" */
  readonly service_pattern_get_distances_between_stop_points_by_routes_aggregate: ServicePatternDistanceBetweenStopsCalculationAggregate;
  /** execute function "service_pattern.get_distances_between_stop_points_in_journey_patterns" which returns "service_pattern.distance_between_stops_calculation" */
  readonly service_pattern_get_distances_between_stop_points_in_journey_patterns: ReadonlyArray<ServicePatternDistanceBetweenStopsCalculation>;
  /** execute function "service_pattern.get_distances_between_stop_points_in_journey_patterns" and query aggregates on result of table type "service_pattern.distance_between_stops_calculation" */
  readonly service_pattern_get_distances_between_stop_points_in_journey_patterns_aggregate: ServicePatternDistanceBetweenStopsCalculationAggregate;
  /** fetch data from the table: "service_pattern.scheduled_stop_point" */
  readonly service_pattern_scheduled_stop_point: ReadonlyArray<ServicePatternScheduledStopPoint>;
  /** fetch aggregated fields from the table: "service_pattern.scheduled_stop_point" */
  readonly service_pattern_scheduled_stop_point_aggregate: ServicePatternScheduledStopPointAggregate;
  /** fetch data from the table: "service_pattern.scheduled_stop_point" using primary key columns */
  readonly service_pattern_scheduled_stop_point_by_pk?: Maybe<ServicePatternScheduledStopPoint>;
  /** fetch data from the table in a streaming manner: "service_pattern.scheduled_stop_point" */
  readonly service_pattern_scheduled_stop_point_stream: ReadonlyArray<ServicePatternScheduledStopPoint>;
  /** fetch data from the table: "service_pattern.vehicle_mode_on_scheduled_stop_point" */
  readonly service_pattern_vehicle_mode_on_scheduled_stop_point: ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPoint>;
  /** fetch aggregated fields from the table: "service_pattern.vehicle_mode_on_scheduled_stop_point" */
  readonly service_pattern_vehicle_mode_on_scheduled_stop_point_aggregate: ServicePatternVehicleModeOnScheduledStopPointAggregate;
  /** fetch data from the table: "service_pattern.vehicle_mode_on_scheduled_stop_point" using primary key columns */
  readonly service_pattern_vehicle_mode_on_scheduled_stop_point_by_pk?: Maybe<ServicePatternVehicleModeOnScheduledStopPoint>;
  /** fetch data from the table in a streaming manner: "service_pattern.vehicle_mode_on_scheduled_stop_point" */
  readonly service_pattern_vehicle_mode_on_scheduled_stop_point_stream: ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPoint>;
  readonly stops_database?: Maybe<StopsDatabaseStopsDatabaseSubscription>;
  readonly timetables?: Maybe<TimetablesTimetablesSubscription>;
  /** fetch data from the table: "timing_pattern.timing_place" */
  readonly timing_pattern_timing_place: ReadonlyArray<TimingPatternTimingPlace>;
  /** fetch aggregated fields from the table: "timing_pattern.timing_place" */
  readonly timing_pattern_timing_place_aggregate: TimingPatternTimingPlaceAggregate;
  /** fetch data from the table: "timing_pattern.timing_place" using primary key columns */
  readonly timing_pattern_timing_place_by_pk?: Maybe<TimingPatternTimingPlace>;
  /** fetch data from the table in a streaming manner: "timing_pattern.timing_place" */
  readonly timing_pattern_timing_place_stream: ReadonlyArray<TimingPatternTimingPlace>;
};


export type SubscriptionRootHslRouteLegacyHslMunicipalityCodeArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<HslRouteLegacyHslMunicipalityCodeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<HslRouteLegacyHslMunicipalityCodeOrderBy>>;
  where?: InputMaybe<HslRouteLegacyHslMunicipalityCodeBoolExp>;
};


export type SubscriptionRootHslRouteLegacyHslMunicipalityCodeAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<HslRouteLegacyHslMunicipalityCodeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<HslRouteLegacyHslMunicipalityCodeOrderBy>>;
  where?: InputMaybe<HslRouteLegacyHslMunicipalityCodeBoolExp>;
};


export type SubscriptionRootHslRouteLegacyHslMunicipalityCodeByPkArgs = {
  hsl_municipality: Scalars['String']['input'];
};


export type SubscriptionRootHslRouteLegacyHslMunicipalityCodeStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<HslRouteLegacyHslMunicipalityCodeStreamCursorInput>>;
  where?: InputMaybe<HslRouteLegacyHslMunicipalityCodeBoolExp>;
};


export type SubscriptionRootHslRouteTransportTargetArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<HslRouteTransportTargetSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<HslRouteTransportTargetOrderBy>>;
  where?: InputMaybe<HslRouteTransportTargetBoolExp>;
};


export type SubscriptionRootHslRouteTransportTargetAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<HslRouteTransportTargetSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<HslRouteTransportTargetOrderBy>>;
  where?: InputMaybe<HslRouteTransportTargetBoolExp>;
};


export type SubscriptionRootHslRouteTransportTargetByPkArgs = {
  transport_target: Scalars['String']['input'];
};


export type SubscriptionRootHslRouteTransportTargetStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<HslRouteTransportTargetStreamCursorInput>>;
  where?: InputMaybe<HslRouteTransportTargetBoolExp>;
};


export type SubscriptionRootInfrastructureNetworkDirectionArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkDirectionOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkDirectionBoolExp>;
};


export type SubscriptionRootInfrastructureNetworkDirectionAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkDirectionOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkDirectionBoolExp>;
};


export type SubscriptionRootInfrastructureNetworkDirectionByPkArgs = {
  value: Scalars['String']['input'];
};


export type SubscriptionRootInfrastructureNetworkDirectionStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<InfrastructureNetworkDirectionStreamCursorInput>>;
  where?: InputMaybe<InfrastructureNetworkDirectionBoolExp>;
};


export type SubscriptionRootInfrastructureNetworkExternalSourceArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkExternalSourceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkExternalSourceOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkExternalSourceBoolExp>;
};


export type SubscriptionRootInfrastructureNetworkExternalSourceAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkExternalSourceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkExternalSourceOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkExternalSourceBoolExp>;
};


export type SubscriptionRootInfrastructureNetworkExternalSourceByPkArgs = {
  value: Scalars['String']['input'];
};


export type SubscriptionRootInfrastructureNetworkExternalSourceStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<InfrastructureNetworkExternalSourceStreamCursorInput>>;
  where?: InputMaybe<InfrastructureNetworkExternalSourceBoolExp>;
};


export type SubscriptionRootInfrastructureNetworkFindPointDirectionOnLinkArgs = {
  args: InfrastructureNetworkFindPointDirectionOnLinkArgs;
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkDirectionOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkDirectionBoolExp>;
};


export type SubscriptionRootInfrastructureNetworkFindPointDirectionOnLinkAggregateArgs = {
  args: InfrastructureNetworkFindPointDirectionOnLinkArgs;
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkDirectionOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkDirectionBoolExp>;
};


export type SubscriptionRootInfrastructureNetworkInfrastructureLinkArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
};


export type SubscriptionRootInfrastructureNetworkInfrastructureLinkAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
};


export type SubscriptionRootInfrastructureNetworkInfrastructureLinkByPkArgs = {
  infrastructure_link_id: Scalars['uuid']['input'];
};


export type SubscriptionRootInfrastructureNetworkInfrastructureLinkStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<InfrastructureNetworkInfrastructureLinkStreamCursorInput>>;
  where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
};


export type SubscriptionRootInfrastructureNetworkResolvePointToClosestLinkArgs = {
  args: InfrastructureNetworkResolvePointToClosestLinkArgs;
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
};


export type SubscriptionRootInfrastructureNetworkResolvePointToClosestLinkAggregateArgs = {
  args: InfrastructureNetworkResolvePointToClosestLinkArgs;
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkInfrastructureLinkBoolExp>;
};


export type SubscriptionRootInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
};


export type SubscriptionRootInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkOrderBy>>;
  where?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
};


export type SubscriptionRootInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkByPkArgs = {
  infrastructure_link_id: Scalars['uuid']['input'];
  vehicle_submode: ReusableComponentsVehicleSubmodeEnum;
};


export type SubscriptionRootInfrastructureNetworkVehicleSubmodeOnInfrastructureLinkStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkStreamCursorInput>>;
  where?: InputMaybe<InfrastructureNetworkVehicleSubmodeOnInfrastructureLinkBoolExp>;
};


export type SubscriptionRootJourneyPatternCheckInfraLinkStopRefsWithNewScheduledStopPointArgs = {
  args: JourneyPatternCheckInfraLinkStopRefsWithNewScheduledStopPointArgs;
  distinct_on?: InputMaybe<ReadonlyArray<JourneyPatternJourneyPatternSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<JourneyPatternJourneyPatternOrderBy>>;
  where?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
};


export type SubscriptionRootJourneyPatternCheckInfraLinkStopRefsWithNewScheduledStopPointAggregateArgs = {
  args: JourneyPatternCheckInfraLinkStopRefsWithNewScheduledStopPointArgs;
  distinct_on?: InputMaybe<ReadonlyArray<JourneyPatternJourneyPatternSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<JourneyPatternJourneyPatternOrderBy>>;
  where?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
};


export type SubscriptionRootJourneyPatternJourneyPatternArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<JourneyPatternJourneyPatternSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<JourneyPatternJourneyPatternOrderBy>>;
  where?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
};


export type SubscriptionRootJourneyPatternJourneyPatternAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<JourneyPatternJourneyPatternSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<JourneyPatternJourneyPatternOrderBy>>;
  where?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
};


export type SubscriptionRootJourneyPatternJourneyPatternByPkArgs = {
  journey_pattern_id: Scalars['uuid']['input'];
};


export type SubscriptionRootJourneyPatternJourneyPatternStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<JourneyPatternJourneyPatternStreamCursorInput>>;
  where?: InputMaybe<JourneyPatternJourneyPatternBoolExp>;
};


export type SubscriptionRootJourneyPatternScheduledStopPointInJourneyPatternArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternOrderBy>>;
  where?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
};


export type SubscriptionRootJourneyPatternScheduledStopPointInJourneyPatternAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternOrderBy>>;
  where?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
};


export type SubscriptionRootJourneyPatternScheduledStopPointInJourneyPatternByPkArgs = {
  journey_pattern_id: Scalars['uuid']['input'];
  scheduled_stop_point_sequence: Scalars['Int']['input'];
};


export type SubscriptionRootJourneyPatternScheduledStopPointInJourneyPatternStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternStreamCursorInput>>;
  where?: InputMaybe<JourneyPatternScheduledStopPointInJourneyPatternBoolExp>;
};


export type SubscriptionRootReusableComponentsVehicleModeArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleModeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleModeOrderBy>>;
  where?: InputMaybe<ReusableComponentsVehicleModeBoolExp>;
};


export type SubscriptionRootReusableComponentsVehicleModeAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleModeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleModeOrderBy>>;
  where?: InputMaybe<ReusableComponentsVehicleModeBoolExp>;
};


export type SubscriptionRootReusableComponentsVehicleModeByPkArgs = {
  vehicle_mode: Scalars['String']['input'];
};


export type SubscriptionRootReusableComponentsVehicleModeStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<ReusableComponentsVehicleModeStreamCursorInput>>;
  where?: InputMaybe<ReusableComponentsVehicleModeBoolExp>;
};


export type SubscriptionRootReusableComponentsVehicleSubmodeArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleSubmodeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleSubmodeOrderBy>>;
  where?: InputMaybe<ReusableComponentsVehicleSubmodeBoolExp>;
};


export type SubscriptionRootReusableComponentsVehicleSubmodeAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleSubmodeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ReusableComponentsVehicleSubmodeOrderBy>>;
  where?: InputMaybe<ReusableComponentsVehicleSubmodeBoolExp>;
};


export type SubscriptionRootReusableComponentsVehicleSubmodeByPkArgs = {
  vehicle_submode: Scalars['String']['input'];
};


export type SubscriptionRootReusableComponentsVehicleSubmodeStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<ReusableComponentsVehicleSubmodeStreamCursorInput>>;
  where?: InputMaybe<ReusableComponentsVehicleSubmodeBoolExp>;
};


export type SubscriptionRootRouteDirectionArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteDirectionOrderBy>>;
  where?: InputMaybe<RouteDirectionBoolExp>;
};


export type SubscriptionRootRouteDirectionAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteDirectionOrderBy>>;
  where?: InputMaybe<RouteDirectionBoolExp>;
};


export type SubscriptionRootRouteDirectionByPkArgs = {
  direction: Scalars['String']['input'];
};


export type SubscriptionRootRouteDirectionStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<RouteDirectionStreamCursorInput>>;
  where?: InputMaybe<RouteDirectionBoolExp>;
};


export type SubscriptionRootRouteInfrastructureLinkAlongRouteArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteInfrastructureLinkAlongRouteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteInfrastructureLinkAlongRouteOrderBy>>;
  where?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
};


export type SubscriptionRootRouteInfrastructureLinkAlongRouteAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteInfrastructureLinkAlongRouteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteInfrastructureLinkAlongRouteOrderBy>>;
  where?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
};


export type SubscriptionRootRouteInfrastructureLinkAlongRouteByPkArgs = {
  infrastructure_link_sequence: Scalars['Int']['input'];
  route_id: Scalars['uuid']['input'];
};


export type SubscriptionRootRouteInfrastructureLinkAlongRouteStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<RouteInfrastructureLinkAlongRouteStreamCursorInput>>;
  where?: InputMaybe<RouteInfrastructureLinkAlongRouteBoolExp>;
};


export type SubscriptionRootRouteLineArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteLineOrderBy>>;
  where?: InputMaybe<RouteLineBoolExp>;
};


export type SubscriptionRootRouteLineAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteLineOrderBy>>;
  where?: InputMaybe<RouteLineBoolExp>;
};


export type SubscriptionRootRouteLineByPkArgs = {
  line_id: Scalars['uuid']['input'];
};


export type SubscriptionRootRouteLineStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<RouteLineStreamCursorInput>>;
  where?: InputMaybe<RouteLineBoolExp>;
};


export type SubscriptionRootRouteRouteArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteRouteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteRouteOrderBy>>;
  where?: InputMaybe<RouteRouteBoolExp>;
};


export type SubscriptionRootRouteRouteAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteRouteSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteRouteOrderBy>>;
  where?: InputMaybe<RouteRouteBoolExp>;
};


export type SubscriptionRootRouteRouteByPkArgs = {
  route_id: Scalars['uuid']['input'];
};


export type SubscriptionRootRouteRouteStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<RouteRouteStreamCursorInput>>;
  where?: InputMaybe<RouteRouteBoolExp>;
};


export type SubscriptionRootRouteTypeOfLineArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteTypeOfLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteTypeOfLineOrderBy>>;
  where?: InputMaybe<RouteTypeOfLineBoolExp>;
};


export type SubscriptionRootRouteTypeOfLineAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<RouteTypeOfLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<RouteTypeOfLineOrderBy>>;
  where?: InputMaybe<RouteTypeOfLineBoolExp>;
};


export type SubscriptionRootRouteTypeOfLineByPkArgs = {
  type_of_line: Scalars['String']['input'];
};


export type SubscriptionRootRouteTypeOfLineStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<RouteTypeOfLineStreamCursorInput>>;
  where?: InputMaybe<RouteTypeOfLineBoolExp>;
};


export type SubscriptionRootServicePatternDistanceBetweenStopsCalculationArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationOrderBy>>;
  where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
};


export type SubscriptionRootServicePatternDistanceBetweenStopsCalculationAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationOrderBy>>;
  where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
};


export type SubscriptionRootServicePatternDistanceBetweenStopsCalculationByPkArgs = {
  journey_pattern_id: Scalars['uuid']['input'];
  observation_date: Scalars['date']['input'];
  route_priority: Scalars['Int']['input'];
  stop_interval_sequence: Scalars['Int']['input'];
};


export type SubscriptionRootServicePatternDistanceBetweenStopsCalculationStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<ServicePatternDistanceBetweenStopsCalculationStreamCursorInput>>;
  where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
};


export type SubscriptionRootServicePatternGetDistancesBetweenStopPointsByRoutesArgs = {
  args: ServicePatternGetDistancesBetweenStopPointsByRoutesArgs;
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationOrderBy>>;
  where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
};


export type SubscriptionRootServicePatternGetDistancesBetweenStopPointsByRoutesAggregateArgs = {
  args: ServicePatternGetDistancesBetweenStopPointsByRoutesArgs;
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationOrderBy>>;
  where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
};


export type SubscriptionRootServicePatternGetDistancesBetweenStopPointsInJourneyPatternsArgs = {
  args: ServicePatternGetDistancesBetweenStopPointsInJourneyPatternsArgs;
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationOrderBy>>;
  where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
};


export type SubscriptionRootServicePatternGetDistancesBetweenStopPointsInJourneyPatternsAggregateArgs = {
  args: ServicePatternGetDistancesBetweenStopPointsInJourneyPatternsArgs;
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternDistanceBetweenStopsCalculationOrderBy>>;
  where?: InputMaybe<ServicePatternDistanceBetweenStopsCalculationBoolExp>;
};


export type SubscriptionRootServicePatternScheduledStopPointArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};


export type SubscriptionRootServicePatternScheduledStopPointAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};


export type SubscriptionRootServicePatternScheduledStopPointByPkArgs = {
  scheduled_stop_point_id: Scalars['uuid']['input'];
};


export type SubscriptionRootServicePatternScheduledStopPointStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<ServicePatternScheduledStopPointStreamCursorInput>>;
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};


export type SubscriptionRootServicePatternVehicleModeOnScheduledStopPointArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointBoolExp>;
};


export type SubscriptionRootServicePatternVehicleModeOnScheduledStopPointAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternVehicleModeOnScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointBoolExp>;
};


export type SubscriptionRootServicePatternVehicleModeOnScheduledStopPointByPkArgs = {
  scheduled_stop_point_id: Scalars['uuid']['input'];
  vehicle_mode: ReusableComponentsVehicleModeEnum;
};


export type SubscriptionRootServicePatternVehicleModeOnScheduledStopPointStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<ServicePatternVehicleModeOnScheduledStopPointStreamCursorInput>>;
  where?: InputMaybe<ServicePatternVehicleModeOnScheduledStopPointBoolExp>;
};


export type SubscriptionRootTimingPatternTimingPlaceArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimingPatternTimingPlaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimingPatternTimingPlaceOrderBy>>;
  where?: InputMaybe<TimingPatternTimingPlaceBoolExp>;
};


export type SubscriptionRootTimingPatternTimingPlaceAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimingPatternTimingPlaceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimingPatternTimingPlaceOrderBy>>;
  where?: InputMaybe<TimingPatternTimingPlaceBoolExp>;
};


export type SubscriptionRootTimingPatternTimingPlaceByPkArgs = {
  timing_place_id: Scalars['uuid']['input'];
};


export type SubscriptionRootTimingPatternTimingPlaceStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<TimingPatternTimingPlaceStreamCursorInput>>;
  where?: InputMaybe<TimingPatternTimingPlaceBoolExp>;
};

export type TariffZoneKeyValuesAggregateBoolExp = {
  readonly count?: InputMaybe<TariffZoneKeyValuesAggregateBoolExpCount>;
};

export type TariffZoneKeyValuesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseTariffZoneKeyValuesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseTariffZoneKeyValuesBoolExp>;
  readonly predicate: IntComparisonExp;
};

/** Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'. */
export type TimestampComparisonExp = {
  readonly _eq?: InputMaybe<Scalars['timestamp']['input']>;
  readonly _gt?: InputMaybe<Scalars['timestamp']['input']>;
  readonly _gte?: InputMaybe<Scalars['timestamp']['input']>;
  readonly _in?: InputMaybe<ReadonlyArray<Scalars['timestamp']['input']>>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _lt?: InputMaybe<Scalars['timestamp']['input']>;
  readonly _lte?: InputMaybe<Scalars['timestamp']['input']>;
  readonly _neq?: InputMaybe<Scalars['timestamp']['input']>;
  readonly _nin?: InputMaybe<ReadonlyArray<Scalars['timestamp']['input']>>;
};

/** Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'. */
export type TimestamptzComparisonExp = {
  readonly _eq?: InputMaybe<Scalars['timestamptz']['input']>;
  readonly _gt?: InputMaybe<Scalars['timestamptz']['input']>;
  readonly _gte?: InputMaybe<Scalars['timestamptz']['input']>;
  readonly _in?: InputMaybe<ReadonlyArray<Scalars['timestamptz']['input']>>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _lt?: InputMaybe<Scalars['timestamptz']['input']>;
  readonly _lte?: InputMaybe<Scalars['timestamptz']['input']>;
  readonly _neq?: InputMaybe<Scalars['timestamptz']['input']>;
  readonly _nin?: InputMaybe<ReadonlyArray<Scalars['timestamptz']['input']>>;
};

/** ordering argument of a cursor */
export enum TimetablesCursorOrdering {
  /** ascending ordering of the cursor */
  Asc = 'ASC',
  /** descending ordering of the cursor */
  Desc = 'DESC'
}

/** Reference to a given snapshot of a JOURNEY PATTERN for a given operating day. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:729  */
export type TimetablesJourneyPatternJourneyPatternRef = {
  readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref';
  /** The ID of the referenced JOURNEY PATTERN */
  readonly journey_pattern_id: Scalars['uuid']['output'];
  readonly journey_pattern_instance?: Maybe<JourneyPatternJourneyPattern>;
  readonly journey_pattern_ref_id: Scalars['uuid']['output'];
  /** The user-given point of time used to pick one journey pattern (with route and scheduled stop points) among possibly many variants. The selected, unambiguous journey pattern variant is used as a basis for schedule planning. */
  readonly observation_timestamp: Scalars['timestamptz']['output'];
  /** The direction of the route associated with the referenced journey pattern */
  readonly route_direction: TimetablesRouteDirectionEnum;
  /** The label of the route associated with the referenced journey pattern */
  readonly route_label: Scalars['String']['output'];
  /** The end date of the validity period of the route associated with the referenced journey pattern. If NULL, then the end of the validity period is unbounded (infinity). */
  readonly route_validity_end?: Maybe<Scalars['date']['output']>;
  /** The start date of the validity period of the route associated with the referenced journey pattern. If NULL, then the start of the validity period is unbounded (-infinity). */
  readonly route_validity_start?: Maybe<Scalars['date']['output']>;
  /** An array relationship */
  readonly scheduled_stop_point_in_journey_pattern_refs: ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRef>;
  /** An aggregate relationship */
  readonly scheduled_stop_point_in_journey_pattern_refs_aggregate: TimetablesServicePatternScheduledStopPointInJourneyPatternRefAggregate;
  /** The timestamp when the snapshot was taken */
  readonly snapshot_timestamp: Scalars['timestamptz']['output'];
  /** The type of line (GTFS route type): https://developers.google.com/transit/gtfs/reference/extended-route-types */
  readonly type_of_line: Scalars['String']['output'];
  /** An array relationship */
  readonly vehicle_journeys: ReadonlyArray<TimetablesVehicleJourneyVehicleJourney>;
  /** An aggregate relationship */
  readonly vehicle_journeys_aggregate: TimetablesVehicleJourneyVehicleJourneyAggregate;
};


/** Reference to a given snapshot of a JOURNEY PATTERN for a given operating day. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:729  */
export type TimetablesJourneyPatternJourneyPatternRefScheduledStopPointInJourneyPatternRefsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRefOrderBy>>;
  where?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>;
};


/** Reference to a given snapshot of a JOURNEY PATTERN for a given operating day. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:729  */
export type TimetablesJourneyPatternJourneyPatternRefScheduledStopPointInJourneyPatternRefsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRefOrderBy>>;
  where?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>;
};


/** Reference to a given snapshot of a JOURNEY PATTERN for a given operating day. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:729  */
export type TimetablesJourneyPatternJourneyPatternRefVehicleJourneysArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleJourneyVehicleJourneySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleJourneyVehicleJourneyOrderBy>>;
  where?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
};


/** Reference to a given snapshot of a JOURNEY PATTERN for a given operating day. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:729  */
export type TimetablesJourneyPatternJourneyPatternRefVehicleJourneysAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleJourneyVehicleJourneySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleJourneyVehicleJourneyOrderBy>>;
  where?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
};

/** aggregated selection of "journey_pattern.journey_pattern_ref" */
export type TimetablesJourneyPatternJourneyPatternRefAggregate = {
  readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref_aggregate';
  readonly aggregate?: Maybe<TimetablesJourneyPatternJourneyPatternRefAggregateFields>;
  readonly nodes: ReadonlyArray<TimetablesJourneyPatternJourneyPatternRef>;
};

/** aggregate fields of "journey_pattern.journey_pattern_ref" */
export type TimetablesJourneyPatternJourneyPatternRefAggregateFields = {
  readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref_aggregate_fields';
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<TimetablesJourneyPatternJourneyPatternRefMaxFields>;
  readonly min?: Maybe<TimetablesJourneyPatternJourneyPatternRefMinFields>;
};


/** aggregate fields of "journey_pattern.journey_pattern_ref" */
export type TimetablesJourneyPatternJourneyPatternRefAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<TimetablesJourneyPatternJourneyPatternRefSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "journey_pattern.journey_pattern_ref". All fields are combined with a logical 'AND'. */
export type TimetablesJourneyPatternJourneyPatternRefBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<TimetablesJourneyPatternJourneyPatternRefBoolExp>>;
  readonly _not?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<TimetablesJourneyPatternJourneyPatternRefBoolExp>>;
  readonly journey_pattern_id?: InputMaybe<UuidComparisonExp>;
  readonly journey_pattern_ref_id?: InputMaybe<UuidComparisonExp>;
  readonly observation_timestamp?: InputMaybe<TimestamptzComparisonExp>;
  readonly route_direction?: InputMaybe<TimetablesRouteDirectionEnumComparisonExp>;
  readonly route_label?: InputMaybe<StringComparisonExp>;
  readonly route_validity_end?: InputMaybe<DateComparisonExp>;
  readonly route_validity_start?: InputMaybe<DateComparisonExp>;
  readonly scheduled_stop_point_in_journey_pattern_refs?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>;
  readonly scheduled_stop_point_in_journey_pattern_refs_aggregate?: InputMaybe<ServicePatternScheduledStopPointInJourneyPatternRefAggregateBoolExp>;
  readonly snapshot_timestamp?: InputMaybe<TimestamptzComparisonExp>;
  readonly type_of_line?: InputMaybe<StringComparisonExp>;
  readonly vehicle_journeys?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
  readonly vehicle_journeys_aggregate?: InputMaybe<VehicleJourneyVehicleJourneyAggregateBoolExp>;
};

/** unique or primary key constraints on table "journey_pattern.journey_pattern_ref" */
export enum TimetablesJourneyPatternJourneyPatternRefConstraint {
  /** unique or primary key constraint on columns "journey_pattern_ref_id" */
  JourneyPatternRefPkey = 'journey_pattern_ref_pkey'
}

/** input type for inserting data into table "journey_pattern.journey_pattern_ref" */
export type TimetablesJourneyPatternJourneyPatternRefInsertInput = {
  /** The ID of the referenced JOURNEY PATTERN */
  readonly journey_pattern_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly journey_pattern_ref_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The user-given point of time used to pick one journey pattern (with route and scheduled stop points) among possibly many variants. The selected, unambiguous journey pattern variant is used as a basis for schedule planning. */
  readonly observation_timestamp?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The direction of the route associated with the referenced journey pattern */
  readonly route_direction?: InputMaybe<TimetablesRouteDirectionEnum>;
  /** The label of the route associated with the referenced journey pattern */
  readonly route_label?: InputMaybe<Scalars['String']['input']>;
  /** The end date of the validity period of the route associated with the referenced journey pattern. If NULL, then the end of the validity period is unbounded (infinity). */
  readonly route_validity_end?: InputMaybe<Scalars['date']['input']>;
  /** The start date of the validity period of the route associated with the referenced journey pattern. If NULL, then the start of the validity period is unbounded (-infinity). */
  readonly route_validity_start?: InputMaybe<Scalars['date']['input']>;
  readonly scheduled_stop_point_in_journey_pattern_refs?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefArrRelInsertInput>;
  /** The timestamp when the snapshot was taken */
  readonly snapshot_timestamp?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The type of line (GTFS route type): https://developers.google.com/transit/gtfs/reference/extended-route-types */
  readonly type_of_line?: InputMaybe<Scalars['String']['input']>;
  readonly vehicle_journeys?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyArrRelInsertInput>;
};

/** aggregate max on columns */
export type TimetablesJourneyPatternJourneyPatternRefMaxFields = {
  readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref_max_fields';
  /** The ID of the referenced JOURNEY PATTERN */
  readonly journey_pattern_id?: Maybe<Scalars['uuid']['output']>;
  readonly journey_pattern_ref_id?: Maybe<Scalars['uuid']['output']>;
  /** The user-given point of time used to pick one journey pattern (with route and scheduled stop points) among possibly many variants. The selected, unambiguous journey pattern variant is used as a basis for schedule planning. */
  readonly observation_timestamp?: Maybe<Scalars['timestamptz']['output']>;
  /** The label of the route associated with the referenced journey pattern */
  readonly route_label?: Maybe<Scalars['String']['output']>;
  /** The end date of the validity period of the route associated with the referenced journey pattern. If NULL, then the end of the validity period is unbounded (infinity). */
  readonly route_validity_end?: Maybe<Scalars['date']['output']>;
  /** The start date of the validity period of the route associated with the referenced journey pattern. If NULL, then the start of the validity period is unbounded (-infinity). */
  readonly route_validity_start?: Maybe<Scalars['date']['output']>;
  /** The timestamp when the snapshot was taken */
  readonly snapshot_timestamp?: Maybe<Scalars['timestamptz']['output']>;
  /** The type of line (GTFS route type): https://developers.google.com/transit/gtfs/reference/extended-route-types */
  readonly type_of_line?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type TimetablesJourneyPatternJourneyPatternRefMinFields = {
  readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref_min_fields';
  /** The ID of the referenced JOURNEY PATTERN */
  readonly journey_pattern_id?: Maybe<Scalars['uuid']['output']>;
  readonly journey_pattern_ref_id?: Maybe<Scalars['uuid']['output']>;
  /** The user-given point of time used to pick one journey pattern (with route and scheduled stop points) among possibly many variants. The selected, unambiguous journey pattern variant is used as a basis for schedule planning. */
  readonly observation_timestamp?: Maybe<Scalars['timestamptz']['output']>;
  /** The label of the route associated with the referenced journey pattern */
  readonly route_label?: Maybe<Scalars['String']['output']>;
  /** The end date of the validity period of the route associated with the referenced journey pattern. If NULL, then the end of the validity period is unbounded (infinity). */
  readonly route_validity_end?: Maybe<Scalars['date']['output']>;
  /** The start date of the validity period of the route associated with the referenced journey pattern. If NULL, then the start of the validity period is unbounded (-infinity). */
  readonly route_validity_start?: Maybe<Scalars['date']['output']>;
  /** The timestamp when the snapshot was taken */
  readonly snapshot_timestamp?: Maybe<Scalars['timestamptz']['output']>;
  /** The type of line (GTFS route type): https://developers.google.com/transit/gtfs/reference/extended-route-types */
  readonly type_of_line?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "journey_pattern.journey_pattern_ref" */
export type TimetablesJourneyPatternJourneyPatternRefMutationResponse = {
  readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<TimetablesJourneyPatternJourneyPatternRef>;
};

/** input type for inserting object relation for remote table "journey_pattern.journey_pattern_ref" */
export type TimetablesJourneyPatternJourneyPatternRefObjRelInsertInput = {
  readonly data: TimetablesJourneyPatternJourneyPatternRefInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefOnConflict>;
};

/** on_conflict condition type for table "journey_pattern.journey_pattern_ref" */
export type TimetablesJourneyPatternJourneyPatternRefOnConflict = {
  readonly constraint: TimetablesJourneyPatternJourneyPatternRefConstraint;
  readonly update_columns?: ReadonlyArray<TimetablesJourneyPatternJourneyPatternRefUpdateColumn>;
  readonly where?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefBoolExp>;
};

/** Ordering options when selecting data from "journey_pattern.journey_pattern_ref". */
export type TimetablesJourneyPatternJourneyPatternRefOrderBy = {
  readonly journey_pattern_id?: InputMaybe<OrderBy>;
  readonly journey_pattern_ref_id?: InputMaybe<OrderBy>;
  readonly observation_timestamp?: InputMaybe<OrderBy>;
  readonly route_direction?: InputMaybe<OrderBy>;
  readonly route_label?: InputMaybe<OrderBy>;
  readonly route_validity_end?: InputMaybe<OrderBy>;
  readonly route_validity_start?: InputMaybe<OrderBy>;
  readonly scheduled_stop_point_in_journey_pattern_refs_aggregate?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefAggregateOrderBy>;
  readonly snapshot_timestamp?: InputMaybe<OrderBy>;
  readonly type_of_line?: InputMaybe<OrderBy>;
  readonly vehicle_journeys_aggregate?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyAggregateOrderBy>;
};

/** primary key columns input for table: journey_pattern.journey_pattern_ref */
export type TimetablesJourneyPatternJourneyPatternRefPkColumnsInput = {
  readonly journey_pattern_ref_id: Scalars['uuid']['input'];
};

/** select columns of table "journey_pattern.journey_pattern_ref" */
export enum TimetablesJourneyPatternJourneyPatternRefSelectColumn {
  /** column name */
  JourneyPatternId = 'journey_pattern_id',
  /** column name */
  JourneyPatternRefId = 'journey_pattern_ref_id',
  /** column name */
  ObservationTimestamp = 'observation_timestamp',
  /** column name */
  RouteDirection = 'route_direction',
  /** column name */
  RouteLabel = 'route_label',
  /** column name */
  RouteValidityEnd = 'route_validity_end',
  /** column name */
  RouteValidityStart = 'route_validity_start',
  /** column name */
  SnapshotTimestamp = 'snapshot_timestamp',
  /** column name */
  TypeOfLine = 'type_of_line'
}

/** input type for updating data in table "journey_pattern.journey_pattern_ref" */
export type TimetablesJourneyPatternJourneyPatternRefSetInput = {
  /** The ID of the referenced JOURNEY PATTERN */
  readonly journey_pattern_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly journey_pattern_ref_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The user-given point of time used to pick one journey pattern (with route and scheduled stop points) among possibly many variants. The selected, unambiguous journey pattern variant is used as a basis for schedule planning. */
  readonly observation_timestamp?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The direction of the route associated with the referenced journey pattern */
  readonly route_direction?: InputMaybe<TimetablesRouteDirectionEnum>;
  /** The label of the route associated with the referenced journey pattern */
  readonly route_label?: InputMaybe<Scalars['String']['input']>;
  /** The end date of the validity period of the route associated with the referenced journey pattern. If NULL, then the end of the validity period is unbounded (infinity). */
  readonly route_validity_end?: InputMaybe<Scalars['date']['input']>;
  /** The start date of the validity period of the route associated with the referenced journey pattern. If NULL, then the start of the validity period is unbounded (-infinity). */
  readonly route_validity_start?: InputMaybe<Scalars['date']['input']>;
  /** The timestamp when the snapshot was taken */
  readonly snapshot_timestamp?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The type of line (GTFS route type): https://developers.google.com/transit/gtfs/reference/extended-route-types */
  readonly type_of_line?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "journey_pattern_journey_pattern_ref" */
export type TimetablesJourneyPatternJourneyPatternRefStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: TimetablesJourneyPatternJourneyPatternRefStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesJourneyPatternJourneyPatternRefStreamCursorValueInput = {
  /** The ID of the referenced JOURNEY PATTERN */
  readonly journey_pattern_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly journey_pattern_ref_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The user-given point of time used to pick one journey pattern (with route and scheduled stop points) among possibly many variants. The selected, unambiguous journey pattern variant is used as a basis for schedule planning. */
  readonly observation_timestamp?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The direction of the route associated with the referenced journey pattern */
  readonly route_direction?: InputMaybe<TimetablesRouteDirectionEnum>;
  /** The label of the route associated with the referenced journey pattern */
  readonly route_label?: InputMaybe<Scalars['String']['input']>;
  /** The end date of the validity period of the route associated with the referenced journey pattern. If NULL, then the end of the validity period is unbounded (infinity). */
  readonly route_validity_end?: InputMaybe<Scalars['date']['input']>;
  /** The start date of the validity period of the route associated with the referenced journey pattern. If NULL, then the start of the validity period is unbounded (-infinity). */
  readonly route_validity_start?: InputMaybe<Scalars['date']['input']>;
  /** The timestamp when the snapshot was taken */
  readonly snapshot_timestamp?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The type of line (GTFS route type): https://developers.google.com/transit/gtfs/reference/extended-route-types */
  readonly type_of_line?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "journey_pattern.journey_pattern_ref" */
export enum TimetablesJourneyPatternJourneyPatternRefUpdateColumn {
  /** column name */
  JourneyPatternId = 'journey_pattern_id',
  /** column name */
  JourneyPatternRefId = 'journey_pattern_ref_id',
  /** column name */
  ObservationTimestamp = 'observation_timestamp',
  /** column name */
  RouteDirection = 'route_direction',
  /** column name */
  RouteLabel = 'route_label',
  /** column name */
  RouteValidityEnd = 'route_validity_end',
  /** column name */
  RouteValidityStart = 'route_validity_start',
  /** column name */
  SnapshotTimestamp = 'snapshot_timestamp',
  /** column name */
  TypeOfLine = 'type_of_line'
}

export type TimetablesJourneyPatternJourneyPatternRefUpdates = {
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefSetInput>;
  /** filter the rows which have to be updated */
  readonly where: TimetablesJourneyPatternJourneyPatternRefBoolExp;
};

/** Long-term planned time data concerning public transport vehicles passing a particular POINT IN JOURNEY PATTERN on a specified VEHICLE JOURNEY for a certain DAY TYPE. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:4:946  */
export type TimetablesPassingTimesTimetabledPassingTime = {
  readonly __typename?: 'timetables_passing_times_timetabled_passing_time';
  /** The time when the vehicle arrives to the SCHEDULED STOP POINT. Measured as interval counted from the midnight of the OPERATING DAY. When NULL, only the departure time is defined for the passing time. E.g. in case this is the first SCHEDULED STOP POINT of the journey. */
  readonly arrival_time?: Maybe<Scalars['interval']['output']>;
  /** The time when the vehicle departs from the SCHEDULED STOP POINT. Measured as interval counted from the midnight of the OPERATING DAY. When NULL, only the arrival time is defined for the passing time. E.g. in case this is the last SCHEDULED STOP POINT of the journey. */
  readonly departure_time?: Maybe<Scalars['interval']['output']>;
  /** The time when the vehicle can be considered as passing a SCHEDULED STOP POINT. Computed field to ease development; it can never be NULL. */
  readonly passing_time: Scalars['interval']['output'];
  /** An object relationship */
  readonly scheduled_stop_point_in_journey_pattern_ref: TimetablesServicePatternScheduledStopPointInJourneyPatternRef;
  /** The SCHEDULED STOP POINT of the JOURNEY PATTERN where the vehicle passes */
  readonly scheduled_stop_point_in_journey_pattern_ref_id: Scalars['uuid']['output'];
  readonly timetabled_passing_time_id: Scalars['uuid']['output'];
  /** An object relationship */
  readonly vehicle_journey: TimetablesVehicleJourneyVehicleJourney;
  /** The VEHICLE JOURNEY to which this TIMETABLED PASSING TIME belongs */
  readonly vehicle_journey_id: Scalars['uuid']['output'];
};

/** aggregated selection of "passing_times.timetabled_passing_time" */
export type TimetablesPassingTimesTimetabledPassingTimeAggregate = {
  readonly __typename?: 'timetables_passing_times_timetabled_passing_time_aggregate';
  readonly aggregate?: Maybe<TimetablesPassingTimesTimetabledPassingTimeAggregateFields>;
  readonly nodes: ReadonlyArray<TimetablesPassingTimesTimetabledPassingTime>;
};

/** aggregate fields of "passing_times.timetabled_passing_time" */
export type TimetablesPassingTimesTimetabledPassingTimeAggregateFields = {
  readonly __typename?: 'timetables_passing_times_timetabled_passing_time_aggregate_fields';
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<TimetablesPassingTimesTimetabledPassingTimeMaxFields>;
  readonly min?: Maybe<TimetablesPassingTimesTimetabledPassingTimeMinFields>;
};


/** aggregate fields of "passing_times.timetabled_passing_time" */
export type TimetablesPassingTimesTimetabledPassingTimeAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<TimetablesPassingTimesTimetabledPassingTimeSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "passing_times.timetabled_passing_time" */
export type TimetablesPassingTimesTimetabledPassingTimeAggregateOrderBy = {
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeMaxOrderBy>;
  readonly min?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeMinOrderBy>;
};

/** input type for inserting array relation for remote table "passing_times.timetabled_passing_time" */
export type TimetablesPassingTimesTimetabledPassingTimeArrRelInsertInput = {
  readonly data: ReadonlyArray<TimetablesPassingTimesTimetabledPassingTimeInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeOnConflict>;
};

/** Boolean expression to filter rows from the table "passing_times.timetabled_passing_time". All fields are combined with a logical 'AND'. */
export type TimetablesPassingTimesTimetabledPassingTimeBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<TimetablesPassingTimesTimetabledPassingTimeBoolExp>>;
  readonly _not?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<TimetablesPassingTimesTimetabledPassingTimeBoolExp>>;
  readonly arrival_time?: InputMaybe<IntervalComparisonExp>;
  readonly departure_time?: InputMaybe<IntervalComparisonExp>;
  readonly passing_time?: InputMaybe<IntervalComparisonExp>;
  readonly scheduled_stop_point_in_journey_pattern_ref?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>;
  readonly scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<UuidComparisonExp>;
  readonly timetabled_passing_time_id?: InputMaybe<UuidComparisonExp>;
  readonly vehicle_journey?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
  readonly vehicle_journey_id?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "passing_times.timetabled_passing_time" */
export enum TimetablesPassingTimesTimetabledPassingTimeConstraint {
  /** unique or primary key constraint on columns "timetabled_passing_time_id" */
  TimetabledPassingTimePkey = 'timetabled_passing_time_pkey',
  /** unique or primary key constraint on columns "scheduled_stop_point_in_journey_pattern_ref_id", "vehicle_journey_id" */
  TimetabledPassingTimeStopPointUniqueIdx = 'timetabled_passing_time_stop_point_unique_idx'
}

/** input type for inserting data into table "passing_times.timetabled_passing_time" */
export type TimetablesPassingTimesTimetabledPassingTimeInsertInput = {
  /** The time when the vehicle arrives to the SCHEDULED STOP POINT. Measured as interval counted from the midnight of the OPERATING DAY. When NULL, only the departure time is defined for the passing time. E.g. in case this is the first SCHEDULED STOP POINT of the journey. */
  readonly arrival_time?: InputMaybe<Scalars['interval']['input']>;
  /** The time when the vehicle departs from the SCHEDULED STOP POINT. Measured as interval counted from the midnight of the OPERATING DAY. When NULL, only the arrival time is defined for the passing time. E.g. in case this is the last SCHEDULED STOP POINT of the journey. */
  readonly departure_time?: InputMaybe<Scalars['interval']['input']>;
  readonly scheduled_stop_point_in_journey_pattern_ref?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefObjRelInsertInput>;
  /** The SCHEDULED STOP POINT of the JOURNEY PATTERN where the vehicle passes */
  readonly scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly timetabled_passing_time_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly vehicle_journey?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyObjRelInsertInput>;
  /** The VEHICLE JOURNEY to which this TIMETABLED PASSING TIME belongs */
  readonly vehicle_journey_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type TimetablesPassingTimesTimetabledPassingTimeMaxFields = {
  readonly __typename?: 'timetables_passing_times_timetabled_passing_time_max_fields';
  /** The SCHEDULED STOP POINT of the JOURNEY PATTERN where the vehicle passes */
  readonly scheduled_stop_point_in_journey_pattern_ref_id?: Maybe<Scalars['uuid']['output']>;
  readonly timetabled_passing_time_id?: Maybe<Scalars['uuid']['output']>;
  /** The VEHICLE JOURNEY to which this TIMETABLED PASSING TIME belongs */
  readonly vehicle_journey_id?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "passing_times.timetabled_passing_time" */
export type TimetablesPassingTimesTimetabledPassingTimeMaxOrderBy = {
  /** The SCHEDULED STOP POINT of the JOURNEY PATTERN where the vehicle passes */
  readonly scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<OrderBy>;
  readonly timetabled_passing_time_id?: InputMaybe<OrderBy>;
  /** The VEHICLE JOURNEY to which this TIMETABLED PASSING TIME belongs */
  readonly vehicle_journey_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type TimetablesPassingTimesTimetabledPassingTimeMinFields = {
  readonly __typename?: 'timetables_passing_times_timetabled_passing_time_min_fields';
  /** The SCHEDULED STOP POINT of the JOURNEY PATTERN where the vehicle passes */
  readonly scheduled_stop_point_in_journey_pattern_ref_id?: Maybe<Scalars['uuid']['output']>;
  readonly timetabled_passing_time_id?: Maybe<Scalars['uuid']['output']>;
  /** The VEHICLE JOURNEY to which this TIMETABLED PASSING TIME belongs */
  readonly vehicle_journey_id?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "passing_times.timetabled_passing_time" */
export type TimetablesPassingTimesTimetabledPassingTimeMinOrderBy = {
  /** The SCHEDULED STOP POINT of the JOURNEY PATTERN where the vehicle passes */
  readonly scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<OrderBy>;
  readonly timetabled_passing_time_id?: InputMaybe<OrderBy>;
  /** The VEHICLE JOURNEY to which this TIMETABLED PASSING TIME belongs */
  readonly vehicle_journey_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "passing_times.timetabled_passing_time" */
export type TimetablesPassingTimesTimetabledPassingTimeMutationResponse = {
  readonly __typename?: 'timetables_passing_times_timetabled_passing_time_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<TimetablesPassingTimesTimetabledPassingTime>;
};

/** on_conflict condition type for table "passing_times.timetabled_passing_time" */
export type TimetablesPassingTimesTimetabledPassingTimeOnConflict = {
  readonly constraint: TimetablesPassingTimesTimetabledPassingTimeConstraint;
  readonly update_columns?: ReadonlyArray<TimetablesPassingTimesTimetabledPassingTimeUpdateColumn>;
  readonly where?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
};

/** Ordering options when selecting data from "passing_times.timetabled_passing_time". */
export type TimetablesPassingTimesTimetabledPassingTimeOrderBy = {
  readonly arrival_time?: InputMaybe<OrderBy>;
  readonly departure_time?: InputMaybe<OrderBy>;
  readonly passing_time?: InputMaybe<OrderBy>;
  readonly scheduled_stop_point_in_journey_pattern_ref?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefOrderBy>;
  readonly scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<OrderBy>;
  readonly timetabled_passing_time_id?: InputMaybe<OrderBy>;
  readonly vehicle_journey?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyOrderBy>;
  readonly vehicle_journey_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: passing_times.timetabled_passing_time */
export type TimetablesPassingTimesTimetabledPassingTimePkColumnsInput = {
  readonly timetabled_passing_time_id: Scalars['uuid']['input'];
};

/** select columns of table "passing_times.timetabled_passing_time" */
export enum TimetablesPassingTimesTimetabledPassingTimeSelectColumn {
  /** column name */
  ArrivalTime = 'arrival_time',
  /** column name */
  DepartureTime = 'departure_time',
  /** column name */
  PassingTime = 'passing_time',
  /** column name */
  ScheduledStopPointInJourneyPatternRefId = 'scheduled_stop_point_in_journey_pattern_ref_id',
  /** column name */
  TimetabledPassingTimeId = 'timetabled_passing_time_id',
  /** column name */
  VehicleJourneyId = 'vehicle_journey_id'
}

/** input type for updating data in table "passing_times.timetabled_passing_time" */
export type TimetablesPassingTimesTimetabledPassingTimeSetInput = {
  /** The time when the vehicle arrives to the SCHEDULED STOP POINT. Measured as interval counted from the midnight of the OPERATING DAY. When NULL, only the departure time is defined for the passing time. E.g. in case this is the first SCHEDULED STOP POINT of the journey. */
  readonly arrival_time?: InputMaybe<Scalars['interval']['input']>;
  /** The time when the vehicle departs from the SCHEDULED STOP POINT. Measured as interval counted from the midnight of the OPERATING DAY. When NULL, only the arrival time is defined for the passing time. E.g. in case this is the last SCHEDULED STOP POINT of the journey. */
  readonly departure_time?: InputMaybe<Scalars['interval']['input']>;
  /** The SCHEDULED STOP POINT of the JOURNEY PATTERN where the vehicle passes */
  readonly scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly timetabled_passing_time_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The VEHICLE JOURNEY to which this TIMETABLED PASSING TIME belongs */
  readonly vehicle_journey_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "passing_times_timetabled_passing_time" */
export type TimetablesPassingTimesTimetabledPassingTimeStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: TimetablesPassingTimesTimetabledPassingTimeStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesPassingTimesTimetabledPassingTimeStreamCursorValueInput = {
  /** The time when the vehicle arrives to the SCHEDULED STOP POINT. Measured as interval counted from the midnight of the OPERATING DAY. When NULL, only the departure time is defined for the passing time. E.g. in case this is the first SCHEDULED STOP POINT of the journey. */
  readonly arrival_time?: InputMaybe<Scalars['interval']['input']>;
  /** The time when the vehicle departs from the SCHEDULED STOP POINT. Measured as interval counted from the midnight of the OPERATING DAY. When NULL, only the arrival time is defined for the passing time. E.g. in case this is the last SCHEDULED STOP POINT of the journey. */
  readonly departure_time?: InputMaybe<Scalars['interval']['input']>;
  /** The time when the vehicle can be considered as passing a SCHEDULED STOP POINT. Computed field to ease development; it can never be NULL. */
  readonly passing_time?: InputMaybe<Scalars['interval']['input']>;
  /** The SCHEDULED STOP POINT of the JOURNEY PATTERN where the vehicle passes */
  readonly scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly timetabled_passing_time_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The VEHICLE JOURNEY to which this TIMETABLED PASSING TIME belongs */
  readonly vehicle_journey_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "passing_times.timetabled_passing_time" */
export enum TimetablesPassingTimesTimetabledPassingTimeUpdateColumn {
  /** column name */
  ArrivalTime = 'arrival_time',
  /** column name */
  DepartureTime = 'departure_time',
  /** column name */
  ScheduledStopPointInJourneyPatternRefId = 'scheduled_stop_point_in_journey_pattern_ref_id',
  /** column name */
  TimetabledPassingTimeId = 'timetabled_passing_time_id',
  /** column name */
  VehicleJourneyId = 'vehicle_journey_id'
}

export type TimetablesPassingTimesTimetabledPassingTimeUpdates = {
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeSetInput>;
  /** filter the rows which have to be updated */
  readonly where: TimetablesPassingTimesTimetabledPassingTimeBoolExp;
};

/**
 * This return value is used for functions that determine what timetable versions are in effect. In effect will be true for all the timetable version rows that
 * are valid on given observation day and are the highest priority of that day type. As an example if we have:
 * Saturday Standard priority valid for 1.1.2023 - 30.6.2023
 * Saturday Temporary priority valid for 1.5.2023 - 31.5.2023
 * Saturday Special priority valid for 20.5.2023 - 20.5.2023
 *
 * If we check the timetable versions for the date 1.2.2023, for Saturday we only get the Standard priority, beacuse it is the only one valid on that time. So that
 * row would have in_effect = true.
 * If we check the timetable versions for the date 1.5.2023, for Saturday we would get the Standard and the Temporary priority for this date, as they are both valid.
 * But only the higher priority is in effect on this date. So the Saturday Temporary priority would have in_effect = true, and the Saturday Standard priority would
 * have in_effect = false.
 * If we check the timetable versions for the date 20.5.2023, for Saturday we have all three valid, but only one can be in_effect, and that would be the Special
 * priority in this case.
 *
 */
export type TimetablesReturnValueTimetableVersion = {
  readonly __typename?: 'timetables_return_value_timetable_version';
  /** An object relationship */
  readonly day_type?: Maybe<TimetablesServiceCalendarDayType>;
  readonly day_type_id: Scalars['uuid']['output'];
  readonly in_effect: Scalars['Boolean']['output'];
  readonly priority: Scalars['Int']['output'];
  /** An object relationship */
  readonly substitute_operating_day_by_line_type?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineType>;
  readonly substitute_operating_day_by_line_type_id?: Maybe<Scalars['uuid']['output']>;
  readonly validity_end: Scalars['date']['output'];
  readonly validity_start: Scalars['date']['output'];
  /** An object relationship */
  readonly vehicle_schedule_frame?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrame>;
  readonly vehicle_schedule_frame_id?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "return_value.timetable_version" */
export type TimetablesReturnValueTimetableVersionAggregate = {
  readonly __typename?: 'timetables_return_value_timetable_version_aggregate';
  readonly aggregate?: Maybe<TimetablesReturnValueTimetableVersionAggregateFields>;
  readonly nodes: ReadonlyArray<TimetablesReturnValueTimetableVersion>;
};

/** aggregate fields of "return_value.timetable_version" */
export type TimetablesReturnValueTimetableVersionAggregateFields = {
  readonly __typename?: 'timetables_return_value_timetable_version_aggregate_fields';
  readonly avg?: Maybe<TimetablesReturnValueTimetableVersionAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<TimetablesReturnValueTimetableVersionMaxFields>;
  readonly min?: Maybe<TimetablesReturnValueTimetableVersionMinFields>;
  readonly stddev?: Maybe<TimetablesReturnValueTimetableVersionStddevFields>;
  readonly stddev_pop?: Maybe<TimetablesReturnValueTimetableVersionStddevPopFields>;
  readonly stddev_samp?: Maybe<TimetablesReturnValueTimetableVersionStddevSampFields>;
  readonly sum?: Maybe<TimetablesReturnValueTimetableVersionSumFields>;
  readonly var_pop?: Maybe<TimetablesReturnValueTimetableVersionVarPopFields>;
  readonly var_samp?: Maybe<TimetablesReturnValueTimetableVersionVarSampFields>;
  readonly variance?: Maybe<TimetablesReturnValueTimetableVersionVarianceFields>;
};


/** aggregate fields of "return_value.timetable_version" */
export type TimetablesReturnValueTimetableVersionAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type TimetablesReturnValueTimetableVersionAvgFields = {
  readonly __typename?: 'timetables_return_value_timetable_version_avg_fields';
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "return_value.timetable_version". All fields are combined with a logical 'AND'. */
export type TimetablesReturnValueTimetableVersionBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionBoolExp>>;
  readonly _not?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionBoolExp>>;
  readonly day_type?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
  readonly day_type_id?: InputMaybe<UuidComparisonExp>;
  readonly in_effect?: InputMaybe<BooleanComparisonExp>;
  readonly priority?: InputMaybe<IntComparisonExp>;
  readonly substitute_operating_day_by_line_type?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>;
  readonly substitute_operating_day_by_line_type_id?: InputMaybe<UuidComparisonExp>;
  readonly validity_end?: InputMaybe<DateComparisonExp>;
  readonly validity_start?: InputMaybe<DateComparisonExp>;
  readonly vehicle_schedule_frame?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameBoolExp>;
  readonly vehicle_schedule_frame_id?: InputMaybe<UuidComparisonExp>;
};

/** input type for incrementing numeric columns in table "return_value.timetable_version" */
export type TimetablesReturnValueTimetableVersionIncInput = {
  readonly priority?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "return_value.timetable_version" */
export type TimetablesReturnValueTimetableVersionInsertInput = {
  readonly day_type?: InputMaybe<TimetablesServiceCalendarDayTypeObjRelInsertInput>;
  readonly day_type_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly in_effect?: InputMaybe<Scalars['Boolean']['input']>;
  readonly priority?: InputMaybe<Scalars['Int']['input']>;
  readonly substitute_operating_day_by_line_type?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeObjRelInsertInput>;
  readonly substitute_operating_day_by_line_type_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly validity_end?: InputMaybe<Scalars['date']['input']>;
  readonly validity_start?: InputMaybe<Scalars['date']['input']>;
  readonly vehicle_schedule_frame?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameObjRelInsertInput>;
  readonly vehicle_schedule_frame_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type TimetablesReturnValueTimetableVersionMaxFields = {
  readonly __typename?: 'timetables_return_value_timetable_version_max_fields';
  readonly day_type_id?: Maybe<Scalars['uuid']['output']>;
  readonly priority?: Maybe<Scalars['Int']['output']>;
  readonly substitute_operating_day_by_line_type_id?: Maybe<Scalars['uuid']['output']>;
  readonly validity_end?: Maybe<Scalars['date']['output']>;
  readonly validity_start?: Maybe<Scalars['date']['output']>;
  readonly vehicle_schedule_frame_id?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type TimetablesReturnValueTimetableVersionMinFields = {
  readonly __typename?: 'timetables_return_value_timetable_version_min_fields';
  readonly day_type_id?: Maybe<Scalars['uuid']['output']>;
  readonly priority?: Maybe<Scalars['Int']['output']>;
  readonly substitute_operating_day_by_line_type_id?: Maybe<Scalars['uuid']['output']>;
  readonly validity_end?: Maybe<Scalars['date']['output']>;
  readonly validity_start?: Maybe<Scalars['date']['output']>;
  readonly vehicle_schedule_frame_id?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "return_value.timetable_version" */
export type TimetablesReturnValueTimetableVersionMutationResponse = {
  readonly __typename?: 'timetables_return_value_timetable_version_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<TimetablesReturnValueTimetableVersion>;
};

/** Ordering options when selecting data from "return_value.timetable_version". */
export type TimetablesReturnValueTimetableVersionOrderBy = {
  readonly day_type?: InputMaybe<TimetablesServiceCalendarDayTypeOrderBy>;
  readonly day_type_id?: InputMaybe<OrderBy>;
  readonly in_effect?: InputMaybe<OrderBy>;
  readonly priority?: InputMaybe<OrderBy>;
  readonly substitute_operating_day_by_line_type?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOrderBy>;
  readonly substitute_operating_day_by_line_type_id?: InputMaybe<OrderBy>;
  readonly validity_end?: InputMaybe<OrderBy>;
  readonly validity_start?: InputMaybe<OrderBy>;
  readonly vehicle_schedule_frame?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameOrderBy>;
  readonly vehicle_schedule_frame_id?: InputMaybe<OrderBy>;
};

/** select columns of table "return_value.timetable_version" */
export enum TimetablesReturnValueTimetableVersionSelectColumn {
  /** column name */
  DayTypeId = 'day_type_id',
  /** column name */
  InEffect = 'in_effect',
  /** column name */
  Priority = 'priority',
  /** column name */
  SubstituteOperatingDayByLineTypeId = 'substitute_operating_day_by_line_type_id',
  /** column name */
  ValidityEnd = 'validity_end',
  /** column name */
  ValidityStart = 'validity_start',
  /** column name */
  VehicleScheduleFrameId = 'vehicle_schedule_frame_id'
}

/** input type for updating data in table "return_value.timetable_version" */
export type TimetablesReturnValueTimetableVersionSetInput = {
  readonly day_type_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly in_effect?: InputMaybe<Scalars['Boolean']['input']>;
  readonly priority?: InputMaybe<Scalars['Int']['input']>;
  readonly substitute_operating_day_by_line_type_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly validity_end?: InputMaybe<Scalars['date']['input']>;
  readonly validity_start?: InputMaybe<Scalars['date']['input']>;
  readonly vehicle_schedule_frame_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type TimetablesReturnValueTimetableVersionStddevFields = {
  readonly __typename?: 'timetables_return_value_timetable_version_stddev_fields';
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type TimetablesReturnValueTimetableVersionStddevPopFields = {
  readonly __typename?: 'timetables_return_value_timetable_version_stddev_pop_fields';
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type TimetablesReturnValueTimetableVersionStddevSampFields = {
  readonly __typename?: 'timetables_return_value_timetable_version_stddev_samp_fields';
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "return_value_timetable_version" */
export type TimetablesReturnValueTimetableVersionStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: TimetablesReturnValueTimetableVersionStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesReturnValueTimetableVersionStreamCursorValueInput = {
  readonly day_type_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly in_effect?: InputMaybe<Scalars['Boolean']['input']>;
  readonly priority?: InputMaybe<Scalars['Int']['input']>;
  readonly substitute_operating_day_by_line_type_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly validity_end?: InputMaybe<Scalars['date']['input']>;
  readonly validity_start?: InputMaybe<Scalars['date']['input']>;
  readonly vehicle_schedule_frame_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type TimetablesReturnValueTimetableVersionSumFields = {
  readonly __typename?: 'timetables_return_value_timetable_version_sum_fields';
  readonly priority?: Maybe<Scalars['Int']['output']>;
};

export type TimetablesReturnValueTimetableVersionUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<TimetablesReturnValueTimetableVersionIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<TimetablesReturnValueTimetableVersionSetInput>;
  /** filter the rows which have to be updated */
  readonly where: TimetablesReturnValueTimetableVersionBoolExp;
};

/** aggregate var_pop on columns */
export type TimetablesReturnValueTimetableVersionVarPopFields = {
  readonly __typename?: 'timetables_return_value_timetable_version_var_pop_fields';
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type TimetablesReturnValueTimetableVersionVarSampFields = {
  readonly __typename?: 'timetables_return_value_timetable_version_var_samp_fields';
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type TimetablesReturnValueTimetableVersionVarianceFields = {
  readonly __typename?: 'timetables_return_value_timetable_version_variance_fields';
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/**
 * This return value table is used in function vehicle_journey.get_vehicle_schedules_on_date. It consists of vehicle_journey_id, vehicle_schedule_frame_id or
 * substitute_operating_day_by_line_type_id and also enriched with data, which are used in the UI side.
 */
export type TimetablesReturnValueVehicleSchedule = {
  readonly __typename?: 'timetables_return_value_vehicle_schedule';
  readonly created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  readonly day_type?: Maybe<TimetablesServiceCalendarDayType>;
  readonly day_type_id: Scalars['uuid']['output'];
  readonly priority: Scalars['Int']['output'];
  readonly substitute_operating_day_by_line_type_id?: Maybe<Scalars['uuid']['output']>;
  readonly validity_end: Scalars['date']['output'];
  readonly validity_start: Scalars['date']['output'];
  /** An object relationship */
  readonly vehicle_journey?: Maybe<TimetablesVehicleJourneyVehicleJourney>;
  readonly vehicle_journey_id?: Maybe<Scalars['uuid']['output']>;
  readonly vehicle_schedule_frame_id?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "return_value.vehicle_schedule" */
export type TimetablesReturnValueVehicleScheduleAggregate = {
  readonly __typename?: 'timetables_return_value_vehicle_schedule_aggregate';
  readonly aggregate?: Maybe<TimetablesReturnValueVehicleScheduleAggregateFields>;
  readonly nodes: ReadonlyArray<TimetablesReturnValueVehicleSchedule>;
};

/** aggregate fields of "return_value.vehicle_schedule" */
export type TimetablesReturnValueVehicleScheduleAggregateFields = {
  readonly __typename?: 'timetables_return_value_vehicle_schedule_aggregate_fields';
  readonly avg?: Maybe<TimetablesReturnValueVehicleScheduleAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<TimetablesReturnValueVehicleScheduleMaxFields>;
  readonly min?: Maybe<TimetablesReturnValueVehicleScheduleMinFields>;
  readonly stddev?: Maybe<TimetablesReturnValueVehicleScheduleStddevFields>;
  readonly stddev_pop?: Maybe<TimetablesReturnValueVehicleScheduleStddevPopFields>;
  readonly stddev_samp?: Maybe<TimetablesReturnValueVehicleScheduleStddevSampFields>;
  readonly sum?: Maybe<TimetablesReturnValueVehicleScheduleSumFields>;
  readonly var_pop?: Maybe<TimetablesReturnValueVehicleScheduleVarPopFields>;
  readonly var_samp?: Maybe<TimetablesReturnValueVehicleScheduleVarSampFields>;
  readonly variance?: Maybe<TimetablesReturnValueVehicleScheduleVarianceFields>;
};


/** aggregate fields of "return_value.vehicle_schedule" */
export type TimetablesReturnValueVehicleScheduleAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<TimetablesReturnValueVehicleScheduleSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type TimetablesReturnValueVehicleScheduleAvgFields = {
  readonly __typename?: 'timetables_return_value_vehicle_schedule_avg_fields';
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "return_value.vehicle_schedule". All fields are combined with a logical 'AND'. */
export type TimetablesReturnValueVehicleScheduleBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<TimetablesReturnValueVehicleScheduleBoolExp>>;
  readonly _not?: InputMaybe<TimetablesReturnValueVehicleScheduleBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<TimetablesReturnValueVehicleScheduleBoolExp>>;
  readonly created_at?: InputMaybe<TimestamptzComparisonExp>;
  readonly day_type?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
  readonly day_type_id?: InputMaybe<UuidComparisonExp>;
  readonly priority?: InputMaybe<IntComparisonExp>;
  readonly substitute_operating_day_by_line_type_id?: InputMaybe<UuidComparisonExp>;
  readonly validity_end?: InputMaybe<DateComparisonExp>;
  readonly validity_start?: InputMaybe<DateComparisonExp>;
  readonly vehicle_journey?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
  readonly vehicle_journey_id?: InputMaybe<UuidComparisonExp>;
  readonly vehicle_schedule_frame_id?: InputMaybe<UuidComparisonExp>;
};

/** input type for incrementing numeric columns in table "return_value.vehicle_schedule" */
export type TimetablesReturnValueVehicleScheduleIncInput = {
  readonly priority?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "return_value.vehicle_schedule" */
export type TimetablesReturnValueVehicleScheduleInsertInput = {
  readonly created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  readonly day_type?: InputMaybe<TimetablesServiceCalendarDayTypeObjRelInsertInput>;
  readonly day_type_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly priority?: InputMaybe<Scalars['Int']['input']>;
  readonly substitute_operating_day_by_line_type_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly validity_end?: InputMaybe<Scalars['date']['input']>;
  readonly validity_start?: InputMaybe<Scalars['date']['input']>;
  readonly vehicle_journey?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyObjRelInsertInput>;
  readonly vehicle_journey_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly vehicle_schedule_frame_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type TimetablesReturnValueVehicleScheduleMaxFields = {
  readonly __typename?: 'timetables_return_value_vehicle_schedule_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']['output']>;
  readonly day_type_id?: Maybe<Scalars['uuid']['output']>;
  readonly priority?: Maybe<Scalars['Int']['output']>;
  readonly substitute_operating_day_by_line_type_id?: Maybe<Scalars['uuid']['output']>;
  readonly validity_end?: Maybe<Scalars['date']['output']>;
  readonly validity_start?: Maybe<Scalars['date']['output']>;
  readonly vehicle_journey_id?: Maybe<Scalars['uuid']['output']>;
  readonly vehicle_schedule_frame_id?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type TimetablesReturnValueVehicleScheduleMinFields = {
  readonly __typename?: 'timetables_return_value_vehicle_schedule_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']['output']>;
  readonly day_type_id?: Maybe<Scalars['uuid']['output']>;
  readonly priority?: Maybe<Scalars['Int']['output']>;
  readonly substitute_operating_day_by_line_type_id?: Maybe<Scalars['uuid']['output']>;
  readonly validity_end?: Maybe<Scalars['date']['output']>;
  readonly validity_start?: Maybe<Scalars['date']['output']>;
  readonly vehicle_journey_id?: Maybe<Scalars['uuid']['output']>;
  readonly vehicle_schedule_frame_id?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "return_value.vehicle_schedule" */
export type TimetablesReturnValueVehicleScheduleMutationResponse = {
  readonly __typename?: 'timetables_return_value_vehicle_schedule_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<TimetablesReturnValueVehicleSchedule>;
};

/** Ordering options when selecting data from "return_value.vehicle_schedule". */
export type TimetablesReturnValueVehicleScheduleOrderBy = {
  readonly created_at?: InputMaybe<OrderBy>;
  readonly day_type?: InputMaybe<TimetablesServiceCalendarDayTypeOrderBy>;
  readonly day_type_id?: InputMaybe<OrderBy>;
  readonly priority?: InputMaybe<OrderBy>;
  readonly substitute_operating_day_by_line_type_id?: InputMaybe<OrderBy>;
  readonly validity_end?: InputMaybe<OrderBy>;
  readonly validity_start?: InputMaybe<OrderBy>;
  readonly vehicle_journey?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyOrderBy>;
  readonly vehicle_journey_id?: InputMaybe<OrderBy>;
  readonly vehicle_schedule_frame_id?: InputMaybe<OrderBy>;
};

/** select columns of table "return_value.vehicle_schedule" */
export enum TimetablesReturnValueVehicleScheduleSelectColumn {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DayTypeId = 'day_type_id',
  /** column name */
  Priority = 'priority',
  /** column name */
  SubstituteOperatingDayByLineTypeId = 'substitute_operating_day_by_line_type_id',
  /** column name */
  ValidityEnd = 'validity_end',
  /** column name */
  ValidityStart = 'validity_start',
  /** column name */
  VehicleJourneyId = 'vehicle_journey_id',
  /** column name */
  VehicleScheduleFrameId = 'vehicle_schedule_frame_id'
}

/** input type for updating data in table "return_value.vehicle_schedule" */
export type TimetablesReturnValueVehicleScheduleSetInput = {
  readonly created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  readonly day_type_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly priority?: InputMaybe<Scalars['Int']['input']>;
  readonly substitute_operating_day_by_line_type_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly validity_end?: InputMaybe<Scalars['date']['input']>;
  readonly validity_start?: InputMaybe<Scalars['date']['input']>;
  readonly vehicle_journey_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly vehicle_schedule_frame_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type TimetablesReturnValueVehicleScheduleStddevFields = {
  readonly __typename?: 'timetables_return_value_vehicle_schedule_stddev_fields';
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type TimetablesReturnValueVehicleScheduleStddevPopFields = {
  readonly __typename?: 'timetables_return_value_vehicle_schedule_stddev_pop_fields';
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type TimetablesReturnValueVehicleScheduleStddevSampFields = {
  readonly __typename?: 'timetables_return_value_vehicle_schedule_stddev_samp_fields';
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "return_value_vehicle_schedule" */
export type TimetablesReturnValueVehicleScheduleStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: TimetablesReturnValueVehicleScheduleStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesReturnValueVehicleScheduleStreamCursorValueInput = {
  readonly created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  readonly day_type_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly priority?: InputMaybe<Scalars['Int']['input']>;
  readonly substitute_operating_day_by_line_type_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly validity_end?: InputMaybe<Scalars['date']['input']>;
  readonly validity_start?: InputMaybe<Scalars['date']['input']>;
  readonly vehicle_journey_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly vehicle_schedule_frame_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type TimetablesReturnValueVehicleScheduleSumFields = {
  readonly __typename?: 'timetables_return_value_vehicle_schedule_sum_fields';
  readonly priority?: Maybe<Scalars['Int']['output']>;
};

export type TimetablesReturnValueVehicleScheduleUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<TimetablesReturnValueVehicleScheduleIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<TimetablesReturnValueVehicleScheduleSetInput>;
  /** filter the rows which have to be updated */
  readonly where: TimetablesReturnValueVehicleScheduleBoolExp;
};

/** aggregate var_pop on columns */
export type TimetablesReturnValueVehicleScheduleVarPopFields = {
  readonly __typename?: 'timetables_return_value_vehicle_schedule_var_pop_fields';
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type TimetablesReturnValueVehicleScheduleVarSampFields = {
  readonly __typename?: 'timetables_return_value_vehicle_schedule_var_samp_fields';
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type TimetablesReturnValueVehicleScheduleVarianceFields = {
  readonly __typename?: 'timetables_return_value_vehicle_schedule_variance_fields';
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** The route directions from Transmodel */
export type TimetablesRouteDirection = {
  readonly __typename?: 'timetables_route_direction';
  /** The name of the route direction */
  readonly direction: Scalars['String']['output'];
  /** The opposite direction */
  readonly the_opposite_of_direction?: Maybe<TimetablesRouteDirectionEnum>;
};

/** aggregated selection of "route.direction" */
export type TimetablesRouteDirectionAggregate = {
  readonly __typename?: 'timetables_route_direction_aggregate';
  readonly aggregate?: Maybe<TimetablesRouteDirectionAggregateFields>;
  readonly nodes: ReadonlyArray<TimetablesRouteDirection>;
};

/** aggregate fields of "route.direction" */
export type TimetablesRouteDirectionAggregateFields = {
  readonly __typename?: 'timetables_route_direction_aggregate_fields';
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<TimetablesRouteDirectionMaxFields>;
  readonly min?: Maybe<TimetablesRouteDirectionMinFields>;
};


/** aggregate fields of "route.direction" */
export type TimetablesRouteDirectionAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<TimetablesRouteDirectionSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "route.direction". All fields are combined with a logical 'AND'. */
export type TimetablesRouteDirectionBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<TimetablesRouteDirectionBoolExp>>;
  readonly _not?: InputMaybe<TimetablesRouteDirectionBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<TimetablesRouteDirectionBoolExp>>;
  readonly direction?: InputMaybe<StringComparisonExp>;
  readonly the_opposite_of_direction?: InputMaybe<TimetablesRouteDirectionEnumComparisonExp>;
};

/** unique or primary key constraints on table "route.direction" */
export enum TimetablesRouteDirectionConstraint {
  /** unique or primary key constraint on columns "direction" */
  DirectionPkey = 'direction_pkey'
}

export enum TimetablesRouteDirectionEnum {
  /** clockwise */
  Anticlockwise = 'anticlockwise',
  /** anticlockwise */
  Clockwise = 'clockwise',
  /** westbound */
  Eastbound = 'eastbound',
  /** outbound */
  Inbound = 'inbound',
  /** southbound */
  Northbound = 'northbound',
  /** inbound */
  Outbound = 'outbound',
  /** northbound */
  Southbound = 'southbound',
  /** eastbound */
  Westbound = 'westbound'
}

/** Boolean expression to compare columns of type "timetables_route_direction_enum". All fields are combined with logical 'AND'. */
export type TimetablesRouteDirectionEnumComparisonExp = {
  readonly _eq?: InputMaybe<TimetablesRouteDirectionEnum>;
  readonly _in?: InputMaybe<ReadonlyArray<TimetablesRouteDirectionEnum>>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _neq?: InputMaybe<TimetablesRouteDirectionEnum>;
  readonly _nin?: InputMaybe<ReadonlyArray<TimetablesRouteDirectionEnum>>;
};

/** input type for inserting data into table "route.direction" */
export type TimetablesRouteDirectionInsertInput = {
  /** The name of the route direction */
  readonly direction?: InputMaybe<Scalars['String']['input']>;
  /** The opposite direction */
  readonly the_opposite_of_direction?: InputMaybe<TimetablesRouteDirectionEnum>;
};

/** aggregate max on columns */
export type TimetablesRouteDirectionMaxFields = {
  readonly __typename?: 'timetables_route_direction_max_fields';
  /** The name of the route direction */
  readonly direction?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type TimetablesRouteDirectionMinFields = {
  readonly __typename?: 'timetables_route_direction_min_fields';
  /** The name of the route direction */
  readonly direction?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "route.direction" */
export type TimetablesRouteDirectionMutationResponse = {
  readonly __typename?: 'timetables_route_direction_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<TimetablesRouteDirection>;
};

/** on_conflict condition type for table "route.direction" */
export type TimetablesRouteDirectionOnConflict = {
  readonly constraint: TimetablesRouteDirectionConstraint;
  readonly update_columns?: ReadonlyArray<TimetablesRouteDirectionUpdateColumn>;
  readonly where?: InputMaybe<TimetablesRouteDirectionBoolExp>;
};

/** Ordering options when selecting data from "route.direction". */
export type TimetablesRouteDirectionOrderBy = {
  readonly direction?: InputMaybe<OrderBy>;
  readonly the_opposite_of_direction?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: route.direction */
export type TimetablesRouteDirectionPkColumnsInput = {
  /** The name of the route direction */
  readonly direction: Scalars['String']['input'];
};

/** select columns of table "route.direction" */
export enum TimetablesRouteDirectionSelectColumn {
  /** column name */
  Direction = 'direction',
  /** column name */
  TheOppositeOfDirection = 'the_opposite_of_direction'
}

/** input type for updating data in table "route.direction" */
export type TimetablesRouteDirectionSetInput = {
  /** The name of the route direction */
  readonly direction?: InputMaybe<Scalars['String']['input']>;
  /** The opposite direction */
  readonly the_opposite_of_direction?: InputMaybe<TimetablesRouteDirectionEnum>;
};

/** Streaming cursor of the table "route_direction" */
export type TimetablesRouteDirectionStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: TimetablesRouteDirectionStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesRouteDirectionStreamCursorValueInput = {
  /** The name of the route direction */
  readonly direction?: InputMaybe<Scalars['String']['input']>;
  /** The opposite direction */
  readonly the_opposite_of_direction?: InputMaybe<TimetablesRouteDirectionEnum>;
};

/** update columns of table "route.direction" */
export enum TimetablesRouteDirectionUpdateColumn {
  /** column name */
  Direction = 'direction',
  /** column name */
  TheOppositeOfDirection = 'the_opposite_of_direction'
}

export type TimetablesRouteDirectionUpdates = {
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<TimetablesRouteDirectionSetInput>;
  /** filter the rows which have to be updated */
  readonly where: TimetablesRouteDirectionBoolExp;
};

/** Type of line. https://www.transmodel-cen.eu/model/index.htm?goto=2:1:3:424 */
export type TimetablesRouteTypeOfLine = {
  readonly __typename?: 'timetables_route_type_of_line';
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  readonly type_of_line: Scalars['String']['output'];
};

/** aggregated selection of "route.type_of_line" */
export type TimetablesRouteTypeOfLineAggregate = {
  readonly __typename?: 'timetables_route_type_of_line_aggregate';
  readonly aggregate?: Maybe<TimetablesRouteTypeOfLineAggregateFields>;
  readonly nodes: ReadonlyArray<TimetablesRouteTypeOfLine>;
};

/** aggregate fields of "route.type_of_line" */
export type TimetablesRouteTypeOfLineAggregateFields = {
  readonly __typename?: 'timetables_route_type_of_line_aggregate_fields';
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<TimetablesRouteTypeOfLineMaxFields>;
  readonly min?: Maybe<TimetablesRouteTypeOfLineMinFields>;
};


/** aggregate fields of "route.type_of_line" */
export type TimetablesRouteTypeOfLineAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<TimetablesRouteTypeOfLineSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "route.type_of_line". All fields are combined with a logical 'AND'. */
export type TimetablesRouteTypeOfLineBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<TimetablesRouteTypeOfLineBoolExp>>;
  readonly _not?: InputMaybe<TimetablesRouteTypeOfLineBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<TimetablesRouteTypeOfLineBoolExp>>;
  readonly type_of_line?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "route.type_of_line" */
export enum TimetablesRouteTypeOfLineConstraint {
  /** unique or primary key constraint on columns "type_of_line" */
  TypeOfLinePkey = 'type_of_line_pkey'
}

/** input type for inserting data into table "route.type_of_line" */
export type TimetablesRouteTypeOfLineInsertInput = {
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  readonly type_of_line?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type TimetablesRouteTypeOfLineMaxFields = {
  readonly __typename?: 'timetables_route_type_of_line_max_fields';
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  readonly type_of_line?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type TimetablesRouteTypeOfLineMinFields = {
  readonly __typename?: 'timetables_route_type_of_line_min_fields';
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  readonly type_of_line?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "route.type_of_line" */
export type TimetablesRouteTypeOfLineMutationResponse = {
  readonly __typename?: 'timetables_route_type_of_line_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<TimetablesRouteTypeOfLine>;
};

/** on_conflict condition type for table "route.type_of_line" */
export type TimetablesRouteTypeOfLineOnConflict = {
  readonly constraint: TimetablesRouteTypeOfLineConstraint;
  readonly update_columns?: ReadonlyArray<TimetablesRouteTypeOfLineUpdateColumn>;
  readonly where?: InputMaybe<TimetablesRouteTypeOfLineBoolExp>;
};

/** Ordering options when selecting data from "route.type_of_line". */
export type TimetablesRouteTypeOfLineOrderBy = {
  readonly type_of_line?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: route.type_of_line */
export type TimetablesRouteTypeOfLinePkColumnsInput = {
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  readonly type_of_line: Scalars['String']['input'];
};

/** select columns of table "route.type_of_line" */
export enum TimetablesRouteTypeOfLineSelectColumn {
  /** column name */
  TypeOfLine = 'type_of_line'
}

/** input type for updating data in table "route.type_of_line" */
export type TimetablesRouteTypeOfLineSetInput = {
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  readonly type_of_line?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "route_type_of_line" */
export type TimetablesRouteTypeOfLineStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: TimetablesRouteTypeOfLineStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesRouteTypeOfLineStreamCursorValueInput = {
  /** GTFS route type: https://developers.google.com/transit/gtfs/reference/extended-route-types */
  readonly type_of_line?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "route.type_of_line" */
export enum TimetablesRouteTypeOfLineUpdateColumn {
  /** column name */
  TypeOfLine = 'type_of_line'
}

export type TimetablesRouteTypeOfLineUpdates = {
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<TimetablesRouteTypeOfLineSetInput>;
  /** filter the rows which have to be updated */
  readonly where: TimetablesRouteTypeOfLineBoolExp;
};

/** A type of day characterised by one or more properties which affect public transport operation. For example: weekday in school holidays. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:3:299  */
export type TimetablesServiceCalendarDayType = {
  readonly __typename?: 'timetables_service_calendar_day_type';
  /** An array relationship */
  readonly active_on_days_of_week: ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeek>;
  /** An aggregate relationship */
  readonly active_on_days_of_week_aggregate: TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAggregate;
  readonly day_type_id: Scalars['uuid']['output'];
  /** The label for the DAY TYPE. Used for identifying the DAY TYPE when importing data from Hastus. Includes both basic (e.g. "Monday-Thursday") and special ("Easter Sunday") day types */
  readonly label: Scalars['String']['output'];
  /** Human-readable name for the DAY TYPE */
  readonly name_i18n: Scalars['jsonb']['output'];
  /** An array relationship */
  readonly vehicle_services: ReadonlyArray<TimetablesVehicleServiceVehicleService>;
  /** An aggregate relationship */
  readonly vehicle_services_aggregate: TimetablesVehicleServiceVehicleServiceAggregate;
};


/** A type of day characterised by one or more properties which affect public transport operation. For example: weekday in school holidays. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:3:299  */
export type TimetablesServiceCalendarDayTypeActiveOnDaysOfWeekArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekOrderBy>>;
  where?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>;
};


/** A type of day characterised by one or more properties which affect public transport operation. For example: weekday in school holidays. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:3:299  */
export type TimetablesServiceCalendarDayTypeActiveOnDaysOfWeekAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekOrderBy>>;
  where?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>;
};


/** A type of day characterised by one or more properties which affect public transport operation. For example: weekday in school holidays. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:3:299  */
export type TimetablesServiceCalendarDayTypeNameI18nArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** A type of day characterised by one or more properties which affect public transport operation. For example: weekday in school holidays. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:3:299  */
export type TimetablesServiceCalendarDayTypeVehicleServicesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceVehicleServiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceVehicleServiceOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
};


/** A type of day characterised by one or more properties which affect public transport operation. For example: weekday in school holidays. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=1:6:3:299  */
export type TimetablesServiceCalendarDayTypeVehicleServicesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceVehicleServiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceVehicleServiceOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
};

/** Tells on which days of week a particular DAY TYPE is active */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeek = {
  readonly __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week';
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week: Scalars['Int']['output'];
  /** An object relationship */
  readonly day_type: TimetablesServiceCalendarDayType;
  /** The DAY TYPE for which we define the activeness */
  readonly day_type_id: Scalars['uuid']['output'];
};

/** aggregated selection of "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAggregate = {
  readonly __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_aggregate';
  readonly aggregate?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAggregateFields>;
  readonly nodes: ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeek>;
};

/** aggregate fields of "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAggregateFields = {
  readonly __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_aggregate_fields';
  readonly avg?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMaxFields>;
  readonly min?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMinFields>;
  readonly stddev?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStddevFields>;
  readonly stddev_pop?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStddevPopFields>;
  readonly stddev_samp?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStddevSampFields>;
  readonly sum?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSumFields>;
  readonly var_pop?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekVarPopFields>;
  readonly var_samp?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekVarSampFields>;
  readonly variance?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekVarianceFields>;
};


/** aggregate fields of "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAggregateOrderBy = {
  readonly avg?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMaxOrderBy>;
  readonly min?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMinOrderBy>;
  readonly stddev?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStddevSampOrderBy>;
  readonly sum?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSumOrderBy>;
  readonly var_pop?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekVarPopOrderBy>;
  readonly var_samp?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekVarSampOrderBy>;
  readonly variance?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekArrRelInsertInput = {
  readonly data: ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekOnConflict>;
};

/** aggregate avg on columns */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAvgFields = {
  readonly __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_avg_fields';
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAvgOrderBy = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "service_calendar.day_type_active_on_day_of_week". All fields are combined with a logical 'AND'. */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>>;
  readonly _not?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>>;
  readonly day_of_week?: InputMaybe<IntComparisonExp>;
  readonly day_type?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
  readonly day_type_id?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "service_calendar.day_type_active_on_day_of_week" */
export enum TimetablesServiceCalendarDayTypeActiveOnDayOfWeekConstraint {
  /** unique or primary key constraint on columns "day_of_week", "day_type_id" */
  DayTypeActiveOnDayOfWeekPkey = 'day_type_active_on_day_of_week_pkey'
}

/** input type for incrementing numeric columns in table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekIncInput = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekInsertInput = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week?: InputMaybe<Scalars['Int']['input']>;
  readonly day_type?: InputMaybe<TimetablesServiceCalendarDayTypeObjRelInsertInput>;
  /** The DAY TYPE for which we define the activeness */
  readonly day_type_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMaxFields = {
  readonly __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_max_fields';
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week?: Maybe<Scalars['Int']['output']>;
  /** The DAY TYPE for which we define the activeness */
  readonly day_type_id?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMaxOrderBy = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week?: InputMaybe<OrderBy>;
  /** The DAY TYPE for which we define the activeness */
  readonly day_type_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMinFields = {
  readonly __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_min_fields';
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week?: Maybe<Scalars['Int']['output']>;
  /** The DAY TYPE for which we define the activeness */
  readonly day_type_id?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMinOrderBy = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week?: InputMaybe<OrderBy>;
  /** The DAY TYPE for which we define the activeness */
  readonly day_type_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMutationResponse = {
  readonly __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeek>;
};

/** on_conflict condition type for table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekOnConflict = {
  readonly constraint: TimetablesServiceCalendarDayTypeActiveOnDayOfWeekConstraint;
  readonly update_columns?: ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekUpdateColumn>;
  readonly where?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>;
};

/** Ordering options when selecting data from "service_calendar.day_type_active_on_day_of_week". */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekOrderBy = {
  readonly day_of_week?: InputMaybe<OrderBy>;
  readonly day_type?: InputMaybe<TimetablesServiceCalendarDayTypeOrderBy>;
  readonly day_type_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: service_calendar.day_type_active_on_day_of_week */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekPkColumnsInput = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week: Scalars['Int']['input'];
  /** The DAY TYPE for which we define the activeness */
  readonly day_type_id: Scalars['uuid']['input'];
};

/** select columns of table "service_calendar.day_type_active_on_day_of_week" */
export enum TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSelectColumn {
  /** column name */
  DayOfWeek = 'day_of_week',
  /** column name */
  DayTypeId = 'day_type_id'
}

/** input type for updating data in table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSetInput = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week?: InputMaybe<Scalars['Int']['input']>;
  /** The DAY TYPE for which we define the activeness */
  readonly day_type_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStddevFields = {
  readonly __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_stddev_fields';
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStddevOrderBy = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStddevPopFields = {
  readonly __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_stddev_pop_fields';
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStddevPopOrderBy = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStddevSampFields = {
  readonly __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_stddev_samp_fields';
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStddevSampOrderBy = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "service_calendar_day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStreamCursorValueInput = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week?: InputMaybe<Scalars['Int']['input']>;
  /** The DAY TYPE for which we define the activeness */
  readonly day_type_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSumFields = {
  readonly __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_sum_fields';
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSumOrderBy = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week?: InputMaybe<OrderBy>;
};

/** update columns of table "service_calendar.day_type_active_on_day_of_week" */
export enum TimetablesServiceCalendarDayTypeActiveOnDayOfWeekUpdateColumn {
  /** column name */
  DayOfWeek = 'day_of_week',
  /** column name */
  DayTypeId = 'day_type_id'
}

export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSetInput>;
  /** filter the rows which have to be updated */
  readonly where: TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp;
};

/** aggregate var_pop on columns */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekVarPopFields = {
  readonly __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_var_pop_fields';
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekVarPopOrderBy = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekVarSampFields = {
  readonly __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_var_samp_fields';
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekVarSampOrderBy = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekVarianceFields = {
  readonly __typename?: 'timetables_service_calendar_day_type_active_on_day_of_week_variance_fields';
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "service_calendar.day_type_active_on_day_of_week" */
export type TimetablesServiceCalendarDayTypeActiveOnDayOfWeekVarianceOrderBy = {
  /** ISO week day definition (1 = Monday, 7 = Sunday) */
  readonly day_of_week?: InputMaybe<OrderBy>;
};

/** aggregated selection of "service_calendar.day_type" */
export type TimetablesServiceCalendarDayTypeAggregate = {
  readonly __typename?: 'timetables_service_calendar_day_type_aggregate';
  readonly aggregate?: Maybe<TimetablesServiceCalendarDayTypeAggregateFields>;
  readonly nodes: ReadonlyArray<TimetablesServiceCalendarDayType>;
};

/** aggregate fields of "service_calendar.day_type" */
export type TimetablesServiceCalendarDayTypeAggregateFields = {
  readonly __typename?: 'timetables_service_calendar_day_type_aggregate_fields';
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<TimetablesServiceCalendarDayTypeMaxFields>;
  readonly min?: Maybe<TimetablesServiceCalendarDayTypeMinFields>;
};


/** aggregate fields of "service_calendar.day_type" */
export type TimetablesServiceCalendarDayTypeAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type TimetablesServiceCalendarDayTypeAppendInput = {
  /** Human-readable name for the DAY TYPE */
  readonly name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
};

/** Boolean expression to filter rows from the table "service_calendar.day_type". All fields are combined with a logical 'AND'. */
export type TimetablesServiceCalendarDayTypeBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeBoolExp>>;
  readonly _not?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeBoolExp>>;
  readonly active_on_days_of_week?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>;
  readonly active_on_days_of_week_aggregate?: InputMaybe<ServiceCalendarDayTypeActiveOnDayOfWeekAggregateBoolExp>;
  readonly day_type_id?: InputMaybe<UuidComparisonExp>;
  readonly label?: InputMaybe<StringComparisonExp>;
  readonly name_i18n?: InputMaybe<JsonbComparisonExp>;
  readonly vehicle_services?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
  readonly vehicle_services_aggregate?: InputMaybe<VehicleServiceVehicleServiceAggregateBoolExp>;
};

/** unique or primary key constraints on table "service_calendar.day_type" */
export enum TimetablesServiceCalendarDayTypeConstraint {
  /** unique or primary key constraint on columns "day_type_id" */
  DayTypePkey = 'day_type_pkey',
  /** unique or primary key constraint on columns "label" */
  ServiceCalendarDayTypeLabelIdx = 'service_calendar_day_type_label_idx'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type TimetablesServiceCalendarDayTypeDeleteAtPathInput = {
  /** Human-readable name for the DAY TYPE */
  readonly name_i18n?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type TimetablesServiceCalendarDayTypeDeleteElemInput = {
  /** Human-readable name for the DAY TYPE */
  readonly name_i18n?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type TimetablesServiceCalendarDayTypeDeleteKeyInput = {
  /** Human-readable name for the DAY TYPE */
  readonly name_i18n?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "service_calendar.day_type" */
export type TimetablesServiceCalendarDayTypeInsertInput = {
  readonly active_on_days_of_week?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekArrRelInsertInput>;
  readonly day_type_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The label for the DAY TYPE. Used for identifying the DAY TYPE when importing data from Hastus. Includes both basic (e.g. "Monday-Thursday") and special ("Easter Sunday") day types */
  readonly label?: InputMaybe<Scalars['String']['input']>;
  /** Human-readable name for the DAY TYPE */
  readonly name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  readonly vehicle_services?: InputMaybe<TimetablesVehicleServiceVehicleServiceArrRelInsertInput>;
};

/** aggregate max on columns */
export type TimetablesServiceCalendarDayTypeMaxFields = {
  readonly __typename?: 'timetables_service_calendar_day_type_max_fields';
  readonly day_type_id?: Maybe<Scalars['uuid']['output']>;
  /** The label for the DAY TYPE. Used for identifying the DAY TYPE when importing data from Hastus. Includes both basic (e.g. "Monday-Thursday") and special ("Easter Sunday") day types */
  readonly label?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type TimetablesServiceCalendarDayTypeMinFields = {
  readonly __typename?: 'timetables_service_calendar_day_type_min_fields';
  readonly day_type_id?: Maybe<Scalars['uuid']['output']>;
  /** The label for the DAY TYPE. Used for identifying the DAY TYPE when importing data from Hastus. Includes both basic (e.g. "Monday-Thursday") and special ("Easter Sunday") day types */
  readonly label?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "service_calendar.day_type" */
export type TimetablesServiceCalendarDayTypeMutationResponse = {
  readonly __typename?: 'timetables_service_calendar_day_type_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<TimetablesServiceCalendarDayType>;
};

/** input type for inserting object relation for remote table "service_calendar.day_type" */
export type TimetablesServiceCalendarDayTypeObjRelInsertInput = {
  readonly data: TimetablesServiceCalendarDayTypeInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<TimetablesServiceCalendarDayTypeOnConflict>;
};

/** on_conflict condition type for table "service_calendar.day_type" */
export type TimetablesServiceCalendarDayTypeOnConflict = {
  readonly constraint: TimetablesServiceCalendarDayTypeConstraint;
  readonly update_columns?: ReadonlyArray<TimetablesServiceCalendarDayTypeUpdateColumn>;
  readonly where?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
};

/** Ordering options when selecting data from "service_calendar.day_type". */
export type TimetablesServiceCalendarDayTypeOrderBy = {
  readonly active_on_days_of_week_aggregate?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAggregateOrderBy>;
  readonly day_type_id?: InputMaybe<OrderBy>;
  readonly label?: InputMaybe<OrderBy>;
  readonly name_i18n?: InputMaybe<OrderBy>;
  readonly vehicle_services_aggregate?: InputMaybe<TimetablesVehicleServiceVehicleServiceAggregateOrderBy>;
};

/** primary key columns input for table: service_calendar.day_type */
export type TimetablesServiceCalendarDayTypePkColumnsInput = {
  readonly day_type_id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type TimetablesServiceCalendarDayTypePrependInput = {
  /** Human-readable name for the DAY TYPE */
  readonly name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "service_calendar.day_type" */
export enum TimetablesServiceCalendarDayTypeSelectColumn {
  /** column name */
  DayTypeId = 'day_type_id',
  /** column name */
  Label = 'label',
  /** column name */
  NameI18n = 'name_i18n'
}

/** input type for updating data in table "service_calendar.day_type" */
export type TimetablesServiceCalendarDayTypeSetInput = {
  readonly day_type_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The label for the DAY TYPE. Used for identifying the DAY TYPE when importing data from Hastus. Includes both basic (e.g. "Monday-Thursday") and special ("Easter Sunday") day types */
  readonly label?: InputMaybe<Scalars['String']['input']>;
  /** Human-readable name for the DAY TYPE */
  readonly name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
};

/** Streaming cursor of the table "service_calendar_day_type" */
export type TimetablesServiceCalendarDayTypeStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: TimetablesServiceCalendarDayTypeStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesServiceCalendarDayTypeStreamCursorValueInput = {
  readonly day_type_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The label for the DAY TYPE. Used for identifying the DAY TYPE when importing data from Hastus. Includes both basic (e.g. "Monday-Thursday") and special ("Easter Sunday") day types */
  readonly label?: InputMaybe<Scalars['String']['input']>;
  /** Human-readable name for the DAY TYPE */
  readonly name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
};

/** update columns of table "service_calendar.day_type" */
export enum TimetablesServiceCalendarDayTypeUpdateColumn {
  /** column name */
  DayTypeId = 'day_type_id',
  /** column name */
  Label = 'label',
  /** column name */
  NameI18n = 'name_i18n'
}

export type TimetablesServiceCalendarDayTypeUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  readonly _append?: InputMaybe<TimetablesServiceCalendarDayTypeAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  readonly _delete_at_path?: InputMaybe<TimetablesServiceCalendarDayTypeDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  readonly _delete_elem?: InputMaybe<TimetablesServiceCalendarDayTypeDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  readonly _delete_key?: InputMaybe<TimetablesServiceCalendarDayTypeDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  readonly _prepend?: InputMaybe<TimetablesServiceCalendarDayTypePrependInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<TimetablesServiceCalendarDayTypeSetInput>;
  /** filter the rows which have to be updated */
  readonly where: TimetablesServiceCalendarDayTypeBoolExp;
};

export type TimetablesServiceCalendarGetActiveDayTypesForDateArgs = {
  readonly observation_date?: InputMaybe<Scalars['date']['input']>;
};

/** Models substitute public transit as (1) a reference day or (2) indicating that public transit does not occur on certain date. Substitute operating days are always bound to a type of line. */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineType = {
  readonly __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type';
  /** Calculated timestamp for the instant from which the substituting public transit comes into effect. */
  readonly begin_datetime: Scalars['timestamptz']['output'];
  /** The time from which the substituting public transit comes into effect. If NULL, the substitution is in effect from the start of the operating day. When substitute_day_of_week is not NULL (reference day case), vehicle journeys prior to this time are not operated. When substitute_day_of_week is NULL (no traffic case), the vehicle journeys before this time are operated as usual. */
  readonly begin_time?: Maybe<Scalars['interval']['output']>;
  readonly created_at: Scalars['timestamptz']['output'];
  /** Calculated timestamp for the instant (exclusive) until which the substituting public transit is in effect. */
  readonly end_datetime: Scalars['timestamptz']['output'];
  /** The time (exclusive) until which the substituting public transit is valid. If NULL, the substitution is in effect until the end of the operating day. When substitute_day_of_week is not NULL (reference day case), vehicle journeys starting from this time are not operated. When substitute_day_of_week is NULL (no traffic case), the vehicle journeys starting from this time are operated as usual. */
  readonly end_time?: Maybe<Scalars['interval']['output']>;
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  readonly substitute_day_of_week?: Maybe<Scalars['Int']['output']>;
  readonly substitute_operating_day_by_line_type_id: Scalars['uuid']['output'];
  /** The id of the substitute operating period */
  readonly substitute_operating_period_id: Scalars['uuid']['output'];
  /** The date of operating day being superseded. */
  readonly superseded_date: Scalars['date']['output'];
  readonly timezone: Scalars['String']['output'];
  /** The type of line this substitute operating day is bound to. */
  readonly type_of_line: Scalars['String']['output'];
};

/** aggregated selection of "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAggregate = {
  readonly __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_aggregate';
  readonly aggregate?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAggregateFields>;
  readonly nodes: ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineType>;
};

/** aggregate fields of "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAggregateFields = {
  readonly __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_aggregate_fields';
  readonly avg?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMaxFields>;
  readonly min?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMinFields>;
  readonly stddev?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStddevFields>;
  readonly stddev_pop?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStddevPopFields>;
  readonly stddev_samp?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStddevSampFields>;
  readonly sum?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSumFields>;
  readonly var_pop?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeVarPopFields>;
  readonly var_samp?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeVarSampFields>;
  readonly variance?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeVarianceFields>;
};


/** aggregate fields of "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAggregateOrderBy = {
  readonly avg?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMaxOrderBy>;
  readonly min?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMinOrderBy>;
  readonly stddev?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStddevSampOrderBy>;
  readonly sum?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSumOrderBy>;
  readonly var_pop?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeVarPopOrderBy>;
  readonly var_samp?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeVarSampOrderBy>;
  readonly variance?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeArrRelInsertInput = {
  readonly data: ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOnConflict>;
};

/** aggregate avg on columns */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAvgFields = {
  readonly __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_avg_fields';
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  readonly substitute_day_of_week?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAvgOrderBy = {
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  readonly substitute_day_of_week?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "service_calendar.substitute_operating_day_by_line_type". All fields are combined with a logical 'AND'. */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>>;
  readonly _not?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>>;
  readonly begin_datetime?: InputMaybe<TimestamptzComparisonExp>;
  readonly begin_time?: InputMaybe<IntervalComparisonExp>;
  readonly created_at?: InputMaybe<TimestamptzComparisonExp>;
  readonly end_datetime?: InputMaybe<TimestamptzComparisonExp>;
  readonly end_time?: InputMaybe<IntervalComparisonExp>;
  readonly substitute_day_of_week?: InputMaybe<IntComparisonExp>;
  readonly substitute_operating_day_by_line_type_id?: InputMaybe<UuidComparisonExp>;
  readonly substitute_operating_period_id?: InputMaybe<UuidComparisonExp>;
  readonly superseded_date?: InputMaybe<DateComparisonExp>;
  readonly timezone?: InputMaybe<StringComparisonExp>;
  readonly type_of_line?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "service_calendar.substitute_operating_day_by_line_type" */
export enum TimetablesServiceCalendarSubstituteOperatingDayByLineTypeConstraint {
  /** unique or primary key constraint on columns "substitute_operating_day_by_line_type_id" */
  SubstituteOperatingDayByLineTypePkey = 'substitute_operating_day_by_line_type_pkey'
}

/** input type for incrementing numeric columns in table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeIncInput = {
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  readonly substitute_day_of_week?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeInsertInput = {
  /** The time from which the substituting public transit comes into effect. If NULL, the substitution is in effect from the start of the operating day. When substitute_day_of_week is not NULL (reference day case), vehicle journeys prior to this time are not operated. When substitute_day_of_week is NULL (no traffic case), the vehicle journeys before this time are operated as usual. */
  readonly begin_time?: InputMaybe<Scalars['interval']['input']>;
  readonly created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The time (exclusive) until which the substituting public transit is valid. If NULL, the substitution is in effect until the end of the operating day. When substitute_day_of_week is not NULL (reference day case), vehicle journeys starting from this time are not operated. When substitute_day_of_week is NULL (no traffic case), the vehicle journeys starting from this time are operated as usual. */
  readonly end_time?: InputMaybe<Scalars['interval']['input']>;
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  readonly substitute_day_of_week?: InputMaybe<Scalars['Int']['input']>;
  readonly substitute_operating_day_by_line_type_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The id of the substitute operating period */
  readonly substitute_operating_period_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The date of operating day being superseded. */
  readonly superseded_date?: InputMaybe<Scalars['date']['input']>;
  readonly timezone?: InputMaybe<Scalars['String']['input']>;
  /** The type of line this substitute operating day is bound to. */
  readonly type_of_line?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMaxFields = {
  readonly __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_max_fields';
  /** Calculated timestamp for the instant from which the substituting public transit comes into effect. */
  readonly begin_datetime?: Maybe<Scalars['timestamptz']['output']>;
  readonly created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Calculated timestamp for the instant (exclusive) until which the substituting public transit is in effect. */
  readonly end_datetime?: Maybe<Scalars['timestamptz']['output']>;
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  readonly substitute_day_of_week?: Maybe<Scalars['Int']['output']>;
  readonly substitute_operating_day_by_line_type_id?: Maybe<Scalars['uuid']['output']>;
  /** The id of the substitute operating period */
  readonly substitute_operating_period_id?: Maybe<Scalars['uuid']['output']>;
  /** The date of operating day being superseded. */
  readonly superseded_date?: Maybe<Scalars['date']['output']>;
  readonly timezone?: Maybe<Scalars['String']['output']>;
  /** The type of line this substitute operating day is bound to. */
  readonly type_of_line?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMaxOrderBy = {
  /** Calculated timestamp for the instant from which the substituting public transit comes into effect. */
  readonly begin_datetime?: InputMaybe<OrderBy>;
  readonly created_at?: InputMaybe<OrderBy>;
  /** Calculated timestamp for the instant (exclusive) until which the substituting public transit is in effect. */
  readonly end_datetime?: InputMaybe<OrderBy>;
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  readonly substitute_day_of_week?: InputMaybe<OrderBy>;
  readonly substitute_operating_day_by_line_type_id?: InputMaybe<OrderBy>;
  /** The id of the substitute operating period */
  readonly substitute_operating_period_id?: InputMaybe<OrderBy>;
  /** The date of operating day being superseded. */
  readonly superseded_date?: InputMaybe<OrderBy>;
  readonly timezone?: InputMaybe<OrderBy>;
  /** The type of line this substitute operating day is bound to. */
  readonly type_of_line?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMinFields = {
  readonly __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_min_fields';
  /** Calculated timestamp for the instant from which the substituting public transit comes into effect. */
  readonly begin_datetime?: Maybe<Scalars['timestamptz']['output']>;
  readonly created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Calculated timestamp for the instant (exclusive) until which the substituting public transit is in effect. */
  readonly end_datetime?: Maybe<Scalars['timestamptz']['output']>;
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  readonly substitute_day_of_week?: Maybe<Scalars['Int']['output']>;
  readonly substitute_operating_day_by_line_type_id?: Maybe<Scalars['uuid']['output']>;
  /** The id of the substitute operating period */
  readonly substitute_operating_period_id?: Maybe<Scalars['uuid']['output']>;
  /** The date of operating day being superseded. */
  readonly superseded_date?: Maybe<Scalars['date']['output']>;
  readonly timezone?: Maybe<Scalars['String']['output']>;
  /** The type of line this substitute operating day is bound to. */
  readonly type_of_line?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMinOrderBy = {
  /** Calculated timestamp for the instant from which the substituting public transit comes into effect. */
  readonly begin_datetime?: InputMaybe<OrderBy>;
  readonly created_at?: InputMaybe<OrderBy>;
  /** Calculated timestamp for the instant (exclusive) until which the substituting public transit is in effect. */
  readonly end_datetime?: InputMaybe<OrderBy>;
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  readonly substitute_day_of_week?: InputMaybe<OrderBy>;
  readonly substitute_operating_day_by_line_type_id?: InputMaybe<OrderBy>;
  /** The id of the substitute operating period */
  readonly substitute_operating_period_id?: InputMaybe<OrderBy>;
  /** The date of operating day being superseded. */
  readonly superseded_date?: InputMaybe<OrderBy>;
  readonly timezone?: InputMaybe<OrderBy>;
  /** The type of line this substitute operating day is bound to. */
  readonly type_of_line?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMutationResponse = {
  readonly __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineType>;
};

/** input type for inserting object relation for remote table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeObjRelInsertInput = {
  readonly data: TimetablesServiceCalendarSubstituteOperatingDayByLineTypeInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOnConflict>;
};

/** on_conflict condition type for table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOnConflict = {
  readonly constraint: TimetablesServiceCalendarSubstituteOperatingDayByLineTypeConstraint;
  readonly update_columns?: ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeUpdateColumn>;
  readonly where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>;
};

/** Ordering options when selecting data from "service_calendar.substitute_operating_day_by_line_type". */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOrderBy = {
  readonly begin_datetime?: InputMaybe<OrderBy>;
  readonly begin_time?: InputMaybe<OrderBy>;
  readonly created_at?: InputMaybe<OrderBy>;
  readonly end_datetime?: InputMaybe<OrderBy>;
  readonly end_time?: InputMaybe<OrderBy>;
  readonly substitute_day_of_week?: InputMaybe<OrderBy>;
  readonly substitute_operating_day_by_line_type_id?: InputMaybe<OrderBy>;
  readonly substitute_operating_period_id?: InputMaybe<OrderBy>;
  readonly superseded_date?: InputMaybe<OrderBy>;
  readonly timezone?: InputMaybe<OrderBy>;
  readonly type_of_line?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: service_calendar.substitute_operating_day_by_line_type */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypePkColumnsInput = {
  readonly substitute_operating_day_by_line_type_id: Scalars['uuid']['input'];
};

/** select columns of table "service_calendar.substitute_operating_day_by_line_type" */
export enum TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSelectColumn {
  /** column name */
  BeginDatetime = 'begin_datetime',
  /** column name */
  BeginTime = 'begin_time',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndDatetime = 'end_datetime',
  /** column name */
  EndTime = 'end_time',
  /** column name */
  SubstituteDayOfWeek = 'substitute_day_of_week',
  /** column name */
  SubstituteOperatingDayByLineTypeId = 'substitute_operating_day_by_line_type_id',
  /** column name */
  SubstituteOperatingPeriodId = 'substitute_operating_period_id',
  /** column name */
  SupersededDate = 'superseded_date',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  TypeOfLine = 'type_of_line'
}

/** input type for updating data in table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSetInput = {
  /** The time from which the substituting public transit comes into effect. If NULL, the substitution is in effect from the start of the operating day. When substitute_day_of_week is not NULL (reference day case), vehicle journeys prior to this time are not operated. When substitute_day_of_week is NULL (no traffic case), the vehicle journeys before this time are operated as usual. */
  readonly begin_time?: InputMaybe<Scalars['interval']['input']>;
  readonly created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The time (exclusive) until which the substituting public transit is valid. If NULL, the substitution is in effect until the end of the operating day. When substitute_day_of_week is not NULL (reference day case), vehicle journeys starting from this time are not operated. When substitute_day_of_week is NULL (no traffic case), the vehicle journeys starting from this time are operated as usual. */
  readonly end_time?: InputMaybe<Scalars['interval']['input']>;
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  readonly substitute_day_of_week?: InputMaybe<Scalars['Int']['input']>;
  readonly substitute_operating_day_by_line_type_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The id of the substitute operating period */
  readonly substitute_operating_period_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The date of operating day being superseded. */
  readonly superseded_date?: InputMaybe<Scalars['date']['input']>;
  readonly timezone?: InputMaybe<Scalars['String']['input']>;
  /** The type of line this substitute operating day is bound to. */
  readonly type_of_line?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStddevFields = {
  readonly __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_stddev_fields';
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  readonly substitute_day_of_week?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStddevOrderBy = {
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  readonly substitute_day_of_week?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStddevPopFields = {
  readonly __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_stddev_pop_fields';
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  readonly substitute_day_of_week?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStddevPopOrderBy = {
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  readonly substitute_day_of_week?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStddevSampFields = {
  readonly __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_stddev_samp_fields';
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  readonly substitute_day_of_week?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStddevSampOrderBy = {
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  readonly substitute_day_of_week?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "service_calendar_substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStreamCursorValueInput = {
  /** Calculated timestamp for the instant from which the substituting public transit comes into effect. */
  readonly begin_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The time from which the substituting public transit comes into effect. If NULL, the substitution is in effect from the start of the operating day. When substitute_day_of_week is not NULL (reference day case), vehicle journeys prior to this time are not operated. When substitute_day_of_week is NULL (no traffic case), the vehicle journeys before this time are operated as usual. */
  readonly begin_time?: InputMaybe<Scalars['interval']['input']>;
  readonly created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Calculated timestamp for the instant (exclusive) until which the substituting public transit is in effect. */
  readonly end_datetime?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The time (exclusive) until which the substituting public transit is valid. If NULL, the substitution is in effect until the end of the operating day. When substitute_day_of_week is not NULL (reference day case), vehicle journeys starting from this time are not operated. When substitute_day_of_week is NULL (no traffic case), the vehicle journeys starting from this time are operated as usual. */
  readonly end_time?: InputMaybe<Scalars['interval']['input']>;
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  readonly substitute_day_of_week?: InputMaybe<Scalars['Int']['input']>;
  readonly substitute_operating_day_by_line_type_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The id of the substitute operating period */
  readonly substitute_operating_period_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The date of operating day being superseded. */
  readonly superseded_date?: InputMaybe<Scalars['date']['input']>;
  readonly timezone?: InputMaybe<Scalars['String']['input']>;
  /** The type of line this substitute operating day is bound to. */
  readonly type_of_line?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSumFields = {
  readonly __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_sum_fields';
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  readonly substitute_day_of_week?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSumOrderBy = {
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  readonly substitute_day_of_week?: InputMaybe<OrderBy>;
};

/** update columns of table "service_calendar.substitute_operating_day_by_line_type" */
export enum TimetablesServiceCalendarSubstituteOperatingDayByLineTypeUpdateColumn {
  /** column name */
  BeginTime = 'begin_time',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndTime = 'end_time',
  /** column name */
  SubstituteDayOfWeek = 'substitute_day_of_week',
  /** column name */
  SubstituteOperatingDayByLineTypeId = 'substitute_operating_day_by_line_type_id',
  /** column name */
  SubstituteOperatingPeriodId = 'substitute_operating_period_id',
  /** column name */
  SupersededDate = 'superseded_date',
  /** column name */
  Timezone = 'timezone',
  /** column name */
  TypeOfLine = 'type_of_line'
}

export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSetInput>;
  /** filter the rows which have to be updated */
  readonly where: TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp;
};

/** aggregate var_pop on columns */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeVarPopFields = {
  readonly __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_var_pop_fields';
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  readonly substitute_day_of_week?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeVarPopOrderBy = {
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  readonly substitute_day_of_week?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeVarSampFields = {
  readonly __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_var_samp_fields';
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  readonly substitute_day_of_week?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeVarSampOrderBy = {
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  readonly substitute_day_of_week?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeVarianceFields = {
  readonly __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_variance_fields';
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  readonly substitute_day_of_week?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "service_calendar.substitute_operating_day_by_line_type" */
export type TimetablesServiceCalendarSubstituteOperatingDayByLineTypeVarianceOrderBy = {
  /** The ISO day of week (1=Monday, ... , 7=Sunday) of the day type used as the basis for operating day substitution. A NULL value indicates that there is no public transit at all, i.e. no vehicle journeys are operated within the given time period. */
  readonly substitute_day_of_week?: InputMaybe<OrderBy>;
};

/** Models substitute operating period that consists of substitute operating days by line types. */
export type TimetablesServiceCalendarSubstituteOperatingPeriod = {
  readonly __typename?: 'timetables_service_calendar_substitute_operating_period';
  /** Flag indicating whether operating period is preset or not. Preset operating periods have restrictions on the UI */
  readonly is_preset: Scalars['Boolean']['output'];
  /** Substitute operating period's name */
  readonly period_name: Scalars['String']['output'];
  /** An array relationship */
  readonly substitute_operating_day_by_line_types: ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineType>;
  /** An aggregate relationship */
  readonly substitute_operating_day_by_line_types_aggregate: TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAggregate;
  readonly substitute_operating_period_id: Scalars['uuid']['output'];
};


/** Models substitute operating period that consists of substitute operating days by line types. */
export type TimetablesServiceCalendarSubstituteOperatingPeriodSubstituteOperatingDayByLineTypesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOrderBy>>;
  where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>;
};


/** Models substitute operating period that consists of substitute operating days by line types. */
export type TimetablesServiceCalendarSubstituteOperatingPeriodSubstituteOperatingDayByLineTypesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOrderBy>>;
  where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>;
};

/** aggregated selection of "service_calendar.substitute_operating_period" */
export type TimetablesServiceCalendarSubstituteOperatingPeriodAggregate = {
  readonly __typename?: 'timetables_service_calendar_substitute_operating_period_aggregate';
  readonly aggregate?: Maybe<TimetablesServiceCalendarSubstituteOperatingPeriodAggregateFields>;
  readonly nodes: ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingPeriod>;
};

/** aggregate fields of "service_calendar.substitute_operating_period" */
export type TimetablesServiceCalendarSubstituteOperatingPeriodAggregateFields = {
  readonly __typename?: 'timetables_service_calendar_substitute_operating_period_aggregate_fields';
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<TimetablesServiceCalendarSubstituteOperatingPeriodMaxFields>;
  readonly min?: Maybe<TimetablesServiceCalendarSubstituteOperatingPeriodMinFields>;
};


/** aggregate fields of "service_calendar.substitute_operating_period" */
export type TimetablesServiceCalendarSubstituteOperatingPeriodAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingPeriodSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "service_calendar.substitute_operating_period". All fields are combined with a logical 'AND'. */
export type TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp>>;
  readonly _not?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp>>;
  readonly is_preset?: InputMaybe<BooleanComparisonExp>;
  readonly period_name?: InputMaybe<StringComparisonExp>;
  readonly substitute_operating_day_by_line_types?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>;
  readonly substitute_operating_day_by_line_types_aggregate?: InputMaybe<ServiceCalendarSubstituteOperatingDayByLineTypeAggregateBoolExp>;
  readonly substitute_operating_period_id?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "service_calendar.substitute_operating_period" */
export enum TimetablesServiceCalendarSubstituteOperatingPeriodConstraint {
  /** unique or primary key constraint on columns "period_name" */
  SubstituteOperatingPeriodPeriodNameKey = 'substitute_operating_period_period_name_key',
  /** unique or primary key constraint on columns "substitute_operating_period_id" */
  SubstituteOperatingPeriodPkey = 'substitute_operating_period_pkey'
}

/** input type for inserting data into table "service_calendar.substitute_operating_period" */
export type TimetablesServiceCalendarSubstituteOperatingPeriodInsertInput = {
  /** Flag indicating whether operating period is preset or not. Preset operating periods have restrictions on the UI */
  readonly is_preset?: InputMaybe<Scalars['Boolean']['input']>;
  /** Substitute operating period's name */
  readonly period_name?: InputMaybe<Scalars['String']['input']>;
  readonly substitute_operating_day_by_line_types?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeArrRelInsertInput>;
  readonly substitute_operating_period_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type TimetablesServiceCalendarSubstituteOperatingPeriodMaxFields = {
  readonly __typename?: 'timetables_service_calendar_substitute_operating_period_max_fields';
  /** Substitute operating period's name */
  readonly period_name?: Maybe<Scalars['String']['output']>;
  readonly substitute_operating_period_id?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type TimetablesServiceCalendarSubstituteOperatingPeriodMinFields = {
  readonly __typename?: 'timetables_service_calendar_substitute_operating_period_min_fields';
  /** Substitute operating period's name */
  readonly period_name?: Maybe<Scalars['String']['output']>;
  readonly substitute_operating_period_id?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "service_calendar.substitute_operating_period" */
export type TimetablesServiceCalendarSubstituteOperatingPeriodMutationResponse = {
  readonly __typename?: 'timetables_service_calendar_substitute_operating_period_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingPeriod>;
};

/** on_conflict condition type for table "service_calendar.substitute_operating_period" */
export type TimetablesServiceCalendarSubstituteOperatingPeriodOnConflict = {
  readonly constraint: TimetablesServiceCalendarSubstituteOperatingPeriodConstraint;
  readonly update_columns?: ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingPeriodUpdateColumn>;
  readonly where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp>;
};

/** Ordering options when selecting data from "service_calendar.substitute_operating_period". */
export type TimetablesServiceCalendarSubstituteOperatingPeriodOrderBy = {
  readonly is_preset?: InputMaybe<OrderBy>;
  readonly period_name?: InputMaybe<OrderBy>;
  readonly substitute_operating_day_by_line_types_aggregate?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAggregateOrderBy>;
  readonly substitute_operating_period_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: service_calendar.substitute_operating_period */
export type TimetablesServiceCalendarSubstituteOperatingPeriodPkColumnsInput = {
  readonly substitute_operating_period_id: Scalars['uuid']['input'];
};

/** select columns of table "service_calendar.substitute_operating_period" */
export enum TimetablesServiceCalendarSubstituteOperatingPeriodSelectColumn {
  /** column name */
  IsPreset = 'is_preset',
  /** column name */
  PeriodName = 'period_name',
  /** column name */
  SubstituteOperatingPeriodId = 'substitute_operating_period_id'
}

/** input type for updating data in table "service_calendar.substitute_operating_period" */
export type TimetablesServiceCalendarSubstituteOperatingPeriodSetInput = {
  /** Flag indicating whether operating period is preset or not. Preset operating periods have restrictions on the UI */
  readonly is_preset?: InputMaybe<Scalars['Boolean']['input']>;
  /** Substitute operating period's name */
  readonly period_name?: InputMaybe<Scalars['String']['input']>;
  readonly substitute_operating_period_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "service_calendar_substitute_operating_period" */
export type TimetablesServiceCalendarSubstituteOperatingPeriodStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: TimetablesServiceCalendarSubstituteOperatingPeriodStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesServiceCalendarSubstituteOperatingPeriodStreamCursorValueInput = {
  /** Flag indicating whether operating period is preset or not. Preset operating periods have restrictions on the UI */
  readonly is_preset?: InputMaybe<Scalars['Boolean']['input']>;
  /** Substitute operating period's name */
  readonly period_name?: InputMaybe<Scalars['String']['input']>;
  readonly substitute_operating_period_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "service_calendar.substitute_operating_period" */
export enum TimetablesServiceCalendarSubstituteOperatingPeriodUpdateColumn {
  /** column name */
  IsPreset = 'is_preset',
  /** column name */
  PeriodName = 'period_name',
  /** column name */
  SubstituteOperatingPeriodId = 'substitute_operating_period_id'
}

export type TimetablesServiceCalendarSubstituteOperatingPeriodUpdates = {
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodSetInput>;
  /** filter the rows which have to be updated */
  readonly where: TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp;
};

/** Reference the a SCHEDULED STOP POINT within a JOURNEY PATTERN. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:729  */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRef = {
  readonly __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref';
  /** An object relationship */
  readonly journey_pattern_ref: TimetablesJourneyPatternJourneyPatternRef;
  /** JOURNEY PATTERN to which the SCHEDULED STOP POINT belongs */
  readonly journey_pattern_ref_id: Scalars['uuid']['output'];
  readonly scheduled_stop_point_in_journey_pattern_ref_id: Scalars['uuid']['output'];
  readonly scheduled_stop_point_instances: ReadonlyArray<ServicePatternScheduledStopPoint>;
  readonly scheduled_stop_point_instances_aggregate: ServicePatternScheduledStopPointAggregate;
  /** The label of the SCHEDULED STOP POINT */
  readonly scheduled_stop_point_label: Scalars['String']['output'];
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  readonly scheduled_stop_point_sequence: Scalars['Int']['output'];
  /** An array relationship */
  readonly timetabled_passing_times: ReadonlyArray<TimetablesPassingTimesTimetabledPassingTime>;
  /** An aggregate relationship */
  readonly timetabled_passing_times_aggregate: TimetablesPassingTimesTimetabledPassingTimeAggregate;
  /** The label of the timing place associated with the referenced scheduled stop point in journey pattern */
  readonly timing_place_label?: Maybe<Scalars['String']['output']>;
};


/** Reference the a SCHEDULED STOP POINT within a JOURNEY PATTERN. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:729  */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefScheduledStopPointInstancesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};


/** Reference the a SCHEDULED STOP POINT within a JOURNEY PATTERN. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:729  */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefScheduledStopPointInstancesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};


/** Reference the a SCHEDULED STOP POINT within a JOURNEY PATTERN. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:729  */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefTimetabledPassingTimesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesPassingTimesTimetabledPassingTimeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesPassingTimesTimetabledPassingTimeOrderBy>>;
  where?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
};


/** Reference the a SCHEDULED STOP POINT within a JOURNEY PATTERN. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:4:729  */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefTimetabledPassingTimesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesPassingTimesTimetabledPassingTimeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesPassingTimesTimetabledPassingTimeOrderBy>>;
  where?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
};

/** aggregated selection of "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefAggregate = {
  readonly __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_aggregate';
  readonly aggregate?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefAggregateFields>;
  readonly nodes: ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRef>;
};

/** aggregate fields of "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefAggregateFields = {
  readonly __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_aggregate_fields';
  readonly avg?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefMaxFields>;
  readonly min?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefMinFields>;
  readonly stddev?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefStddevFields>;
  readonly stddev_pop?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefStddevPopFields>;
  readonly stddev_samp?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefStddevSampFields>;
  readonly sum?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSumFields>;
  readonly var_pop?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefVarPopFields>;
  readonly var_samp?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefVarSampFields>;
  readonly variance?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefVarianceFields>;
};


/** aggregate fields of "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefAggregateOrderBy = {
  readonly avg?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefMaxOrderBy>;
  readonly min?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefMinOrderBy>;
  readonly stddev?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefStddevSampOrderBy>;
  readonly sum?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSumOrderBy>;
  readonly var_pop?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefVarPopOrderBy>;
  readonly var_samp?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefVarSampOrderBy>;
  readonly variance?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefArrRelInsertInput = {
  readonly data: ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRefInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefOnConflict>;
};

/** aggregate avg on columns */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefAvgFields = {
  readonly __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_avg_fields';
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  readonly scheduled_stop_point_sequence?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefAvgOrderBy = {
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  readonly scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "service_pattern.scheduled_stop_point_in_journey_pattern_ref". All fields are combined with a logical 'AND'. */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>>;
  readonly _not?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>>;
  readonly journey_pattern_ref?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefBoolExp>;
  readonly journey_pattern_ref_id?: InputMaybe<UuidComparisonExp>;
  readonly scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<UuidComparisonExp>;
  readonly scheduled_stop_point_label?: InputMaybe<StringComparisonExp>;
  readonly scheduled_stop_point_sequence?: InputMaybe<IntComparisonExp>;
  readonly timetabled_passing_times?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
  readonly timetabled_passing_times_aggregate?: InputMaybe<PassingTimesTimetabledPassingTimeAggregateBoolExp>;
  readonly timing_place_label?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export enum TimetablesServicePatternScheduledStopPointInJourneyPatternRefConstraint {
  /** unique or primary key constraint on columns "scheduled_stop_point_in_journey_pattern_ref_id" */
  ScheduledStopPointInJourneyPatternRefPkey = 'scheduled_stop_point_in_journey_pattern_ref_pkey',
  /** unique or primary key constraint on columns "journey_pattern_ref_id", "scheduled_stop_point_sequence" */
  ServicePatternScheduledStopPointInJourneyPatternRefIdx = 'service_pattern_scheduled_stop_point_in_journey_pattern_ref_idx'
}

/** input type for incrementing numeric columns in table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefIncInput = {
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  readonly scheduled_stop_point_sequence?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefInsertInput = {
  readonly journey_pattern_ref?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefObjRelInsertInput>;
  /** JOURNEY PATTERN to which the SCHEDULED STOP POINT belongs */
  readonly journey_pattern_ref_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The label of the SCHEDULED STOP POINT */
  readonly scheduled_stop_point_label?: InputMaybe<Scalars['String']['input']>;
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  readonly scheduled_stop_point_sequence?: InputMaybe<Scalars['Int']['input']>;
  readonly timetabled_passing_times?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeArrRelInsertInput>;
  /** The label of the timing place associated with the referenced scheduled stop point in journey pattern */
  readonly timing_place_label?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefMaxFields = {
  readonly __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_max_fields';
  /** JOURNEY PATTERN to which the SCHEDULED STOP POINT belongs */
  readonly journey_pattern_ref_id?: Maybe<Scalars['uuid']['output']>;
  readonly scheduled_stop_point_in_journey_pattern_ref_id?: Maybe<Scalars['uuid']['output']>;
  /** The label of the SCHEDULED STOP POINT */
  readonly scheduled_stop_point_label?: Maybe<Scalars['String']['output']>;
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  readonly scheduled_stop_point_sequence?: Maybe<Scalars['Int']['output']>;
  /** The label of the timing place associated with the referenced scheduled stop point in journey pattern */
  readonly timing_place_label?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefMaxOrderBy = {
  /** JOURNEY PATTERN to which the SCHEDULED STOP POINT belongs */
  readonly journey_pattern_ref_id?: InputMaybe<OrderBy>;
  readonly scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<OrderBy>;
  /** The label of the SCHEDULED STOP POINT */
  readonly scheduled_stop_point_label?: InputMaybe<OrderBy>;
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  readonly scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
  /** The label of the timing place associated with the referenced scheduled stop point in journey pattern */
  readonly timing_place_label?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefMinFields = {
  readonly __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_min_fields';
  /** JOURNEY PATTERN to which the SCHEDULED STOP POINT belongs */
  readonly journey_pattern_ref_id?: Maybe<Scalars['uuid']['output']>;
  readonly scheduled_stop_point_in_journey_pattern_ref_id?: Maybe<Scalars['uuid']['output']>;
  /** The label of the SCHEDULED STOP POINT */
  readonly scheduled_stop_point_label?: Maybe<Scalars['String']['output']>;
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  readonly scheduled_stop_point_sequence?: Maybe<Scalars['Int']['output']>;
  /** The label of the timing place associated with the referenced scheduled stop point in journey pattern */
  readonly timing_place_label?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefMinOrderBy = {
  /** JOURNEY PATTERN to which the SCHEDULED STOP POINT belongs */
  readonly journey_pattern_ref_id?: InputMaybe<OrderBy>;
  readonly scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<OrderBy>;
  /** The label of the SCHEDULED STOP POINT */
  readonly scheduled_stop_point_label?: InputMaybe<OrderBy>;
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  readonly scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
  /** The label of the timing place associated with the referenced scheduled stop point in journey pattern */
  readonly timing_place_label?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefMutationResponse = {
  readonly __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRef>;
};

/** input type for inserting object relation for remote table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefObjRelInsertInput = {
  readonly data: TimetablesServicePatternScheduledStopPointInJourneyPatternRefInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefOnConflict>;
};

/** on_conflict condition type for table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefOnConflict = {
  readonly constraint: TimetablesServicePatternScheduledStopPointInJourneyPatternRefConstraint;
  readonly update_columns?: ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRefUpdateColumn>;
  readonly where?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>;
};

/** Ordering options when selecting data from "service_pattern.scheduled_stop_point_in_journey_pattern_ref". */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefOrderBy = {
  readonly journey_pattern_ref?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefOrderBy>;
  readonly journey_pattern_ref_id?: InputMaybe<OrderBy>;
  readonly scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<OrderBy>;
  readonly scheduled_stop_point_label?: InputMaybe<OrderBy>;
  readonly scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
  readonly timetabled_passing_times_aggregate?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeAggregateOrderBy>;
  readonly timing_place_label?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: service_pattern.scheduled_stop_point_in_journey_pattern_ref */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefPkColumnsInput = {
  readonly scheduled_stop_point_in_journey_pattern_ref_id: Scalars['uuid']['input'];
};

/** select columns of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export enum TimetablesServicePatternScheduledStopPointInJourneyPatternRefSelectColumn {
  /** column name */
  JourneyPatternRefId = 'journey_pattern_ref_id',
  /** column name */
  ScheduledStopPointInJourneyPatternRefId = 'scheduled_stop_point_in_journey_pattern_ref_id',
  /** column name */
  ScheduledStopPointLabel = 'scheduled_stop_point_label',
  /** column name */
  ScheduledStopPointSequence = 'scheduled_stop_point_sequence',
  /** column name */
  TimingPlaceLabel = 'timing_place_label'
}

/** input type for updating data in table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefSetInput = {
  /** JOURNEY PATTERN to which the SCHEDULED STOP POINT belongs */
  readonly journey_pattern_ref_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The label of the SCHEDULED STOP POINT */
  readonly scheduled_stop_point_label?: InputMaybe<Scalars['String']['input']>;
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  readonly scheduled_stop_point_sequence?: InputMaybe<Scalars['Int']['input']>;
  /** The label of the timing place associated with the referenced scheduled stop point in journey pattern */
  readonly timing_place_label?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefStddevFields = {
  readonly __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_stddev_fields';
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  readonly scheduled_stop_point_sequence?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefStddevOrderBy = {
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  readonly scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefStddevPopFields = {
  readonly __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_stddev_pop_fields';
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  readonly scheduled_stop_point_sequence?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefStddevPopOrderBy = {
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  readonly scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefStddevSampFields = {
  readonly __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_stddev_samp_fields';
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  readonly scheduled_stop_point_sequence?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefStddevSampOrderBy = {
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  readonly scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "service_pattern_scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: TimetablesServicePatternScheduledStopPointInJourneyPatternRefStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefStreamCursorValueInput = {
  /** JOURNEY PATTERN to which the SCHEDULED STOP POINT belongs */
  readonly journey_pattern_ref_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly scheduled_stop_point_in_journey_pattern_ref_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The label of the SCHEDULED STOP POINT */
  readonly scheduled_stop_point_label?: InputMaybe<Scalars['String']['input']>;
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  readonly scheduled_stop_point_sequence?: InputMaybe<Scalars['Int']['input']>;
  /** The label of the timing place associated with the referenced scheduled stop point in journey pattern */
  readonly timing_place_label?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefSumFields = {
  readonly __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_sum_fields';
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  readonly scheduled_stop_point_sequence?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefSumOrderBy = {
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  readonly scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

/** update columns of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export enum TimetablesServicePatternScheduledStopPointInJourneyPatternRefUpdateColumn {
  /** column name */
  JourneyPatternRefId = 'journey_pattern_ref_id',
  /** column name */
  ScheduledStopPointInJourneyPatternRefId = 'scheduled_stop_point_in_journey_pattern_ref_id',
  /** column name */
  ScheduledStopPointLabel = 'scheduled_stop_point_label',
  /** column name */
  ScheduledStopPointSequence = 'scheduled_stop_point_sequence',
  /** column name */
  TimingPlaceLabel = 'timing_place_label'
}

export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSetInput>;
  /** filter the rows which have to be updated */
  readonly where: TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp;
};

/** aggregate var_pop on columns */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefVarPopFields = {
  readonly __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_var_pop_fields';
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  readonly scheduled_stop_point_sequence?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefVarPopOrderBy = {
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  readonly scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefVarSampFields = {
  readonly __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_var_samp_fields';
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  readonly scheduled_stop_point_sequence?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefVarSampOrderBy = {
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  readonly scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefVarianceFields = {
  readonly __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_variance_fields';
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  readonly scheduled_stop_point_sequence?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
export type TimetablesServicePatternScheduledStopPointInJourneyPatternRefVarianceOrderBy = {
  /** The order of the SCHEDULED STOP POINT within the JOURNEY PATTERN. */
  readonly scheduled_stop_point_sequence?: InputMaybe<OrderBy>;
};

export type TimetablesTimetablesMutationFrontend = {
  readonly __typename?: 'timetables_timetables_mutation_frontend';
  /** delete data from the table: "journey_pattern.journey_pattern_ref" */
  readonly timetables_delete_journey_pattern_journey_pattern_ref?: Maybe<TimetablesJourneyPatternJourneyPatternRefMutationResponse>;
  /** delete single row from the table: "journey_pattern.journey_pattern_ref" */
  readonly timetables_delete_journey_pattern_journey_pattern_ref_by_pk?: Maybe<TimetablesJourneyPatternJourneyPatternRef>;
  /** delete data from the table: "passing_times.timetabled_passing_time" */
  readonly timetables_delete_passing_times_timetabled_passing_time?: Maybe<TimetablesPassingTimesTimetabledPassingTimeMutationResponse>;
  /** delete single row from the table: "passing_times.timetabled_passing_time" */
  readonly timetables_delete_passing_times_timetabled_passing_time_by_pk?: Maybe<TimetablesPassingTimesTimetabledPassingTime>;
  /** delete data from the table: "return_value.timetable_version" */
  readonly timetables_delete_return_value_timetable_version?: Maybe<TimetablesReturnValueTimetableVersionMutationResponse>;
  /** delete data from the table: "return_value.vehicle_schedule" */
  readonly timetables_delete_return_value_vehicle_schedule?: Maybe<TimetablesReturnValueVehicleScheduleMutationResponse>;
  /** delete data from the table: "route.direction" */
  readonly timetables_delete_route_direction?: Maybe<TimetablesRouteDirectionMutationResponse>;
  /** delete single row from the table: "route.direction" */
  readonly timetables_delete_route_direction_by_pk?: Maybe<TimetablesRouteDirection>;
  /** delete data from the table: "route.type_of_line" */
  readonly timetables_delete_route_type_of_line?: Maybe<TimetablesRouteTypeOfLineMutationResponse>;
  /** delete single row from the table: "route.type_of_line" */
  readonly timetables_delete_route_type_of_line_by_pk?: Maybe<TimetablesRouteTypeOfLine>;
  /** delete data from the table: "service_calendar.day_type" */
  readonly timetables_delete_service_calendar_day_type?: Maybe<TimetablesServiceCalendarDayTypeMutationResponse>;
  /** delete data from the table: "service_calendar.day_type_active_on_day_of_week" */
  readonly timetables_delete_service_calendar_day_type_active_on_day_of_week?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMutationResponse>;
  /** delete single row from the table: "service_calendar.day_type_active_on_day_of_week" */
  readonly timetables_delete_service_calendar_day_type_active_on_day_of_week_by_pk?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeek>;
  /** delete single row from the table: "service_calendar.day_type" */
  readonly timetables_delete_service_calendar_day_type_by_pk?: Maybe<TimetablesServiceCalendarDayType>;
  /** delete data from the table: "service_calendar.substitute_operating_day_by_line_type" */
  readonly timetables_delete_service_calendar_substitute_operating_day_by_line_type?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMutationResponse>;
  /** delete single row from the table: "service_calendar.substitute_operating_day_by_line_type" */
  readonly timetables_delete_service_calendar_substitute_operating_day_by_line_type_by_pk?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineType>;
  /** delete data from the table: "service_calendar.substitute_operating_period" */
  readonly timetables_delete_service_calendar_substitute_operating_period?: Maybe<TimetablesServiceCalendarSubstituteOperatingPeriodMutationResponse>;
  /** delete single row from the table: "service_calendar.substitute_operating_period" */
  readonly timetables_delete_service_calendar_substitute_operating_period_by_pk?: Maybe<TimetablesServiceCalendarSubstituteOperatingPeriod>;
  /** delete data from the table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
  readonly timetables_delete_service_pattern_scheduled_stop_point_in_journey_pattern_ref?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefMutationResponse>;
  /** delete single row from the table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
  readonly timetables_delete_service_pattern_scheduled_stop_point_in_journey_pattern_ref_by_pk?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRef>;
  /** delete data from the table: "vehicle_journey.vehicle_journey" */
  readonly timetables_delete_vehicle_journey_vehicle_journey?: Maybe<TimetablesVehicleJourneyVehicleJourneyMutationResponse>;
  /** delete single row from the table: "vehicle_journey.vehicle_journey" */
  readonly timetables_delete_vehicle_journey_vehicle_journey_by_pk?: Maybe<TimetablesVehicleJourneyVehicleJourney>;
  /** delete data from the table: "vehicle_schedule.vehicle_schedule_frame" */
  readonly timetables_delete_vehicle_schedule_vehicle_schedule_frame?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameMutationResponse>;
  /** delete single row from the table: "vehicle_schedule.vehicle_schedule_frame" */
  readonly timetables_delete_vehicle_schedule_vehicle_schedule_frame_by_pk?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrame>;
  /** delete data from the table: "vehicle_service.block" */
  readonly timetables_delete_vehicle_service_block?: Maybe<TimetablesVehicleServiceBlockMutationResponse>;
  /** delete single row from the table: "vehicle_service.block" */
  readonly timetables_delete_vehicle_service_block_by_pk?: Maybe<TimetablesVehicleServiceBlock>;
  /** delete data from the table: "vehicle_service.journey_patterns_in_vehicle_service" */
  readonly timetables_delete_vehicle_service_journey_patterns_in_vehicle_service?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceMutationResponse>;
  /** delete single row from the table: "vehicle_service.journey_patterns_in_vehicle_service" */
  readonly timetables_delete_vehicle_service_journey_patterns_in_vehicle_service_by_pk?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleService>;
  /** delete data from the table: "vehicle_service.vehicle_service" */
  readonly timetables_delete_vehicle_service_vehicle_service?: Maybe<TimetablesVehicleServiceVehicleServiceMutationResponse>;
  /** delete single row from the table: "vehicle_service.vehicle_service" */
  readonly timetables_delete_vehicle_service_vehicle_service_by_pk?: Maybe<TimetablesVehicleServiceVehicleService>;
  /** delete data from the table: "vehicle_type.vehicle_type" */
  readonly timetables_delete_vehicle_type_vehicle_type?: Maybe<TimetablesVehicleTypeVehicleTypeMutationResponse>;
  /** delete single row from the table: "vehicle_type.vehicle_type" */
  readonly timetables_delete_vehicle_type_vehicle_type_by_pk?: Maybe<TimetablesVehicleTypeVehicleType>;
  /** insert data into the table: "journey_pattern.journey_pattern_ref" */
  readonly timetables_insert_journey_pattern_journey_pattern_ref?: Maybe<TimetablesJourneyPatternJourneyPatternRefMutationResponse>;
  /** insert a single row into the table: "journey_pattern.journey_pattern_ref" */
  readonly timetables_insert_journey_pattern_journey_pattern_ref_one?: Maybe<TimetablesJourneyPatternJourneyPatternRef>;
  /** insert data into the table: "passing_times.timetabled_passing_time" */
  readonly timetables_insert_passing_times_timetabled_passing_time?: Maybe<TimetablesPassingTimesTimetabledPassingTimeMutationResponse>;
  /** insert a single row into the table: "passing_times.timetabled_passing_time" */
  readonly timetables_insert_passing_times_timetabled_passing_time_one?: Maybe<TimetablesPassingTimesTimetabledPassingTime>;
  /** insert data into the table: "return_value.timetable_version" */
  readonly timetables_insert_return_value_timetable_version?: Maybe<TimetablesReturnValueTimetableVersionMutationResponse>;
  /** insert a single row into the table: "return_value.timetable_version" */
  readonly timetables_insert_return_value_timetable_version_one?: Maybe<TimetablesReturnValueTimetableVersion>;
  /** insert data into the table: "return_value.vehicle_schedule" */
  readonly timetables_insert_return_value_vehicle_schedule?: Maybe<TimetablesReturnValueVehicleScheduleMutationResponse>;
  /** insert a single row into the table: "return_value.vehicle_schedule" */
  readonly timetables_insert_return_value_vehicle_schedule_one?: Maybe<TimetablesReturnValueVehicleSchedule>;
  /** insert data into the table: "route.direction" */
  readonly timetables_insert_route_direction?: Maybe<TimetablesRouteDirectionMutationResponse>;
  /** insert a single row into the table: "route.direction" */
  readonly timetables_insert_route_direction_one?: Maybe<TimetablesRouteDirection>;
  /** insert data into the table: "route.type_of_line" */
  readonly timetables_insert_route_type_of_line?: Maybe<TimetablesRouteTypeOfLineMutationResponse>;
  /** insert a single row into the table: "route.type_of_line" */
  readonly timetables_insert_route_type_of_line_one?: Maybe<TimetablesRouteTypeOfLine>;
  /** insert data into the table: "service_calendar.day_type" */
  readonly timetables_insert_service_calendar_day_type?: Maybe<TimetablesServiceCalendarDayTypeMutationResponse>;
  /** insert data into the table: "service_calendar.day_type_active_on_day_of_week" */
  readonly timetables_insert_service_calendar_day_type_active_on_day_of_week?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMutationResponse>;
  /** insert a single row into the table: "service_calendar.day_type_active_on_day_of_week" */
  readonly timetables_insert_service_calendar_day_type_active_on_day_of_week_one?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeek>;
  /** insert a single row into the table: "service_calendar.day_type" */
  readonly timetables_insert_service_calendar_day_type_one?: Maybe<TimetablesServiceCalendarDayType>;
  /** insert data into the table: "service_calendar.substitute_operating_day_by_line_type" */
  readonly timetables_insert_service_calendar_substitute_operating_day_by_line_type?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMutationResponse>;
  /** insert a single row into the table: "service_calendar.substitute_operating_day_by_line_type" */
  readonly timetables_insert_service_calendar_substitute_operating_day_by_line_type_one?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineType>;
  /** insert data into the table: "service_calendar.substitute_operating_period" */
  readonly timetables_insert_service_calendar_substitute_operating_period?: Maybe<TimetablesServiceCalendarSubstituteOperatingPeriodMutationResponse>;
  /** insert a single row into the table: "service_calendar.substitute_operating_period" */
  readonly timetables_insert_service_calendar_substitute_operating_period_one?: Maybe<TimetablesServiceCalendarSubstituteOperatingPeriod>;
  /** insert data into the table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
  readonly timetables_insert_service_pattern_scheduled_stop_point_in_journey_pattern_ref?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefMutationResponse>;
  /** insert a single row into the table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
  readonly timetables_insert_service_pattern_scheduled_stop_point_in_journey_pattern_ref_one?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRef>;
  /** insert data into the table: "vehicle_journey.vehicle_journey" */
  readonly timetables_insert_vehicle_journey_vehicle_journey?: Maybe<TimetablesVehicleJourneyVehicleJourneyMutationResponse>;
  /** insert a single row into the table: "vehicle_journey.vehicle_journey" */
  readonly timetables_insert_vehicle_journey_vehicle_journey_one?: Maybe<TimetablesVehicleJourneyVehicleJourney>;
  /** insert data into the table: "vehicle_schedule.vehicle_schedule_frame" */
  readonly timetables_insert_vehicle_schedule_vehicle_schedule_frame?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameMutationResponse>;
  /** insert a single row into the table: "vehicle_schedule.vehicle_schedule_frame" */
  readonly timetables_insert_vehicle_schedule_vehicle_schedule_frame_one?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrame>;
  /** insert data into the table: "vehicle_service.block" */
  readonly timetables_insert_vehicle_service_block?: Maybe<TimetablesVehicleServiceBlockMutationResponse>;
  /** insert a single row into the table: "vehicle_service.block" */
  readonly timetables_insert_vehicle_service_block_one?: Maybe<TimetablesVehicleServiceBlock>;
  /** insert data into the table: "vehicle_service.journey_patterns_in_vehicle_service" */
  readonly timetables_insert_vehicle_service_journey_patterns_in_vehicle_service?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceMutationResponse>;
  /** insert a single row into the table: "vehicle_service.journey_patterns_in_vehicle_service" */
  readonly timetables_insert_vehicle_service_journey_patterns_in_vehicle_service_one?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleService>;
  /** insert data into the table: "vehicle_service.vehicle_service" */
  readonly timetables_insert_vehicle_service_vehicle_service?: Maybe<TimetablesVehicleServiceVehicleServiceMutationResponse>;
  /** insert a single row into the table: "vehicle_service.vehicle_service" */
  readonly timetables_insert_vehicle_service_vehicle_service_one?: Maybe<TimetablesVehicleServiceVehicleService>;
  /** insert data into the table: "vehicle_type.vehicle_type" */
  readonly timetables_insert_vehicle_type_vehicle_type?: Maybe<TimetablesVehicleTypeVehicleTypeMutationResponse>;
  /** insert a single row into the table: "vehicle_type.vehicle_type" */
  readonly timetables_insert_vehicle_type_vehicle_type_one?: Maybe<TimetablesVehicleTypeVehicleType>;
  /** update data of the table: "journey_pattern.journey_pattern_ref" */
  readonly timetables_update_journey_pattern_journey_pattern_ref?: Maybe<TimetablesJourneyPatternJourneyPatternRefMutationResponse>;
  /** update single row of the table: "journey_pattern.journey_pattern_ref" */
  readonly timetables_update_journey_pattern_journey_pattern_ref_by_pk?: Maybe<TimetablesJourneyPatternJourneyPatternRef>;
  /** update multiples rows of table: "journey_pattern.journey_pattern_ref" */
  readonly timetables_update_journey_pattern_journey_pattern_ref_many?: Maybe<ReadonlyArray<Maybe<TimetablesJourneyPatternJourneyPatternRefMutationResponse>>>;
  /** update data of the table: "passing_times.timetabled_passing_time" */
  readonly timetables_update_passing_times_timetabled_passing_time?: Maybe<TimetablesPassingTimesTimetabledPassingTimeMutationResponse>;
  /** update single row of the table: "passing_times.timetabled_passing_time" */
  readonly timetables_update_passing_times_timetabled_passing_time_by_pk?: Maybe<TimetablesPassingTimesTimetabledPassingTime>;
  /** update multiples rows of table: "passing_times.timetabled_passing_time" */
  readonly timetables_update_passing_times_timetabled_passing_time_many?: Maybe<ReadonlyArray<Maybe<TimetablesPassingTimesTimetabledPassingTimeMutationResponse>>>;
  /** update data of the table: "return_value.timetable_version" */
  readonly timetables_update_return_value_timetable_version?: Maybe<TimetablesReturnValueTimetableVersionMutationResponse>;
  /** update multiples rows of table: "return_value.timetable_version" */
  readonly timetables_update_return_value_timetable_version_many?: Maybe<ReadonlyArray<Maybe<TimetablesReturnValueTimetableVersionMutationResponse>>>;
  /** update data of the table: "return_value.vehicle_schedule" */
  readonly timetables_update_return_value_vehicle_schedule?: Maybe<TimetablesReturnValueVehicleScheduleMutationResponse>;
  /** update multiples rows of table: "return_value.vehicle_schedule" */
  readonly timetables_update_return_value_vehicle_schedule_many?: Maybe<ReadonlyArray<Maybe<TimetablesReturnValueVehicleScheduleMutationResponse>>>;
  /** update data of the table: "route.direction" */
  readonly timetables_update_route_direction?: Maybe<TimetablesRouteDirectionMutationResponse>;
  /** update single row of the table: "route.direction" */
  readonly timetables_update_route_direction_by_pk?: Maybe<TimetablesRouteDirection>;
  /** update multiples rows of table: "route.direction" */
  readonly timetables_update_route_direction_many?: Maybe<ReadonlyArray<Maybe<TimetablesRouteDirectionMutationResponse>>>;
  /** update data of the table: "route.type_of_line" */
  readonly timetables_update_route_type_of_line?: Maybe<TimetablesRouteTypeOfLineMutationResponse>;
  /** update single row of the table: "route.type_of_line" */
  readonly timetables_update_route_type_of_line_by_pk?: Maybe<TimetablesRouteTypeOfLine>;
  /** update multiples rows of table: "route.type_of_line" */
  readonly timetables_update_route_type_of_line_many?: Maybe<ReadonlyArray<Maybe<TimetablesRouteTypeOfLineMutationResponse>>>;
  /** update data of the table: "service_calendar.day_type" */
  readonly timetables_update_service_calendar_day_type?: Maybe<TimetablesServiceCalendarDayTypeMutationResponse>;
  /** update data of the table: "service_calendar.day_type_active_on_day_of_week" */
  readonly timetables_update_service_calendar_day_type_active_on_day_of_week?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMutationResponse>;
  /** update single row of the table: "service_calendar.day_type_active_on_day_of_week" */
  readonly timetables_update_service_calendar_day_type_active_on_day_of_week_by_pk?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeek>;
  /** update multiples rows of table: "service_calendar.day_type_active_on_day_of_week" */
  readonly timetables_update_service_calendar_day_type_active_on_day_of_week_many?: Maybe<ReadonlyArray<Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekMutationResponse>>>;
  /** update single row of the table: "service_calendar.day_type" */
  readonly timetables_update_service_calendar_day_type_by_pk?: Maybe<TimetablesServiceCalendarDayType>;
  /** update multiples rows of table: "service_calendar.day_type" */
  readonly timetables_update_service_calendar_day_type_many?: Maybe<ReadonlyArray<Maybe<TimetablesServiceCalendarDayTypeMutationResponse>>>;
  /** update data of the table: "service_calendar.substitute_operating_day_by_line_type" */
  readonly timetables_update_service_calendar_substitute_operating_day_by_line_type?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMutationResponse>;
  /** update single row of the table: "service_calendar.substitute_operating_day_by_line_type" */
  readonly timetables_update_service_calendar_substitute_operating_day_by_line_type_by_pk?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineType>;
  /** update multiples rows of table: "service_calendar.substitute_operating_day_by_line_type" */
  readonly timetables_update_service_calendar_substitute_operating_day_by_line_type_many?: Maybe<ReadonlyArray<Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeMutationResponse>>>;
  /** update data of the table: "service_calendar.substitute_operating_period" */
  readonly timetables_update_service_calendar_substitute_operating_period?: Maybe<TimetablesServiceCalendarSubstituteOperatingPeriodMutationResponse>;
  /** update single row of the table: "service_calendar.substitute_operating_period" */
  readonly timetables_update_service_calendar_substitute_operating_period_by_pk?: Maybe<TimetablesServiceCalendarSubstituteOperatingPeriod>;
  /** update multiples rows of table: "service_calendar.substitute_operating_period" */
  readonly timetables_update_service_calendar_substitute_operating_period_many?: Maybe<ReadonlyArray<Maybe<TimetablesServiceCalendarSubstituteOperatingPeriodMutationResponse>>>;
  /** update data of the table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
  readonly timetables_update_service_pattern_scheduled_stop_point_in_journey_pattern_ref?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefMutationResponse>;
  /** update single row of the table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
  readonly timetables_update_service_pattern_scheduled_stop_point_in_journey_pattern_ref_by_pk?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRef>;
  /** update multiples rows of table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
  readonly timetables_update_service_pattern_scheduled_stop_point_in_journey_pattern_ref_many?: Maybe<ReadonlyArray<Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefMutationResponse>>>;
  /** update data of the table: "vehicle_journey.vehicle_journey" */
  readonly timetables_update_vehicle_journey_vehicle_journey?: Maybe<TimetablesVehicleJourneyVehicleJourneyMutationResponse>;
  /** update single row of the table: "vehicle_journey.vehicle_journey" */
  readonly timetables_update_vehicle_journey_vehicle_journey_by_pk?: Maybe<TimetablesVehicleJourneyVehicleJourney>;
  /** update multiples rows of table: "vehicle_journey.vehicle_journey" */
  readonly timetables_update_vehicle_journey_vehicle_journey_many?: Maybe<ReadonlyArray<Maybe<TimetablesVehicleJourneyVehicleJourneyMutationResponse>>>;
  /** update data of the table: "vehicle_schedule.vehicle_schedule_frame" */
  readonly timetables_update_vehicle_schedule_vehicle_schedule_frame?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameMutationResponse>;
  /** update single row of the table: "vehicle_schedule.vehicle_schedule_frame" */
  readonly timetables_update_vehicle_schedule_vehicle_schedule_frame_by_pk?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrame>;
  /** update multiples rows of table: "vehicle_schedule.vehicle_schedule_frame" */
  readonly timetables_update_vehicle_schedule_vehicle_schedule_frame_many?: Maybe<ReadonlyArray<Maybe<TimetablesVehicleScheduleVehicleScheduleFrameMutationResponse>>>;
  /** update data of the table: "vehicle_service.block" */
  readonly timetables_update_vehicle_service_block?: Maybe<TimetablesVehicleServiceBlockMutationResponse>;
  /** update single row of the table: "vehicle_service.block" */
  readonly timetables_update_vehicle_service_block_by_pk?: Maybe<TimetablesVehicleServiceBlock>;
  /** update multiples rows of table: "vehicle_service.block" */
  readonly timetables_update_vehicle_service_block_many?: Maybe<ReadonlyArray<Maybe<TimetablesVehicleServiceBlockMutationResponse>>>;
  /** update data of the table: "vehicle_service.journey_patterns_in_vehicle_service" */
  readonly timetables_update_vehicle_service_journey_patterns_in_vehicle_service?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceMutationResponse>;
  /** update single row of the table: "vehicle_service.journey_patterns_in_vehicle_service" */
  readonly timetables_update_vehicle_service_journey_patterns_in_vehicle_service_by_pk?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleService>;
  /** update multiples rows of table: "vehicle_service.journey_patterns_in_vehicle_service" */
  readonly timetables_update_vehicle_service_journey_patterns_in_vehicle_service_many?: Maybe<ReadonlyArray<Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceMutationResponse>>>;
  /** update data of the table: "vehicle_service.vehicle_service" */
  readonly timetables_update_vehicle_service_vehicle_service?: Maybe<TimetablesVehicleServiceVehicleServiceMutationResponse>;
  /** update single row of the table: "vehicle_service.vehicle_service" */
  readonly timetables_update_vehicle_service_vehicle_service_by_pk?: Maybe<TimetablesVehicleServiceVehicleService>;
  /** update multiples rows of table: "vehicle_service.vehicle_service" */
  readonly timetables_update_vehicle_service_vehicle_service_many?: Maybe<ReadonlyArray<Maybe<TimetablesVehicleServiceVehicleServiceMutationResponse>>>;
  /** update data of the table: "vehicle_type.vehicle_type" */
  readonly timetables_update_vehicle_type_vehicle_type?: Maybe<TimetablesVehicleTypeVehicleTypeMutationResponse>;
  /** update single row of the table: "vehicle_type.vehicle_type" */
  readonly timetables_update_vehicle_type_vehicle_type_by_pk?: Maybe<TimetablesVehicleTypeVehicleType>;
  /** update multiples rows of table: "vehicle_type.vehicle_type" */
  readonly timetables_update_vehicle_type_vehicle_type_many?: Maybe<ReadonlyArray<Maybe<TimetablesVehicleTypeVehicleTypeMutationResponse>>>;
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteJourneyPatternJourneyPatternRefArgs = {
  where: TimetablesJourneyPatternJourneyPatternRefBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteJourneyPatternJourneyPatternRefByPkArgs = {
  journey_pattern_ref_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesMutationFrontendTimetablesDeletePassingTimesTimetabledPassingTimeArgs = {
  where: TimetablesPassingTimesTimetabledPassingTimeBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesDeletePassingTimesTimetabledPassingTimeByPkArgs = {
  timetabled_passing_time_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteReturnValueTimetableVersionArgs = {
  where: TimetablesReturnValueTimetableVersionBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteReturnValueVehicleScheduleArgs = {
  where: TimetablesReturnValueVehicleScheduleBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteRouteDirectionArgs = {
  where: TimetablesRouteDirectionBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteRouteDirectionByPkArgs = {
  direction: Scalars['String']['input'];
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteRouteTypeOfLineArgs = {
  where: TimetablesRouteTypeOfLineBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteRouteTypeOfLineByPkArgs = {
  type_of_line: Scalars['String']['input'];
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteServiceCalendarDayTypeArgs = {
  where: TimetablesServiceCalendarDayTypeBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteServiceCalendarDayTypeActiveOnDayOfWeekArgs = {
  where: TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteServiceCalendarDayTypeActiveOnDayOfWeekByPkArgs = {
  day_of_week: Scalars['Int']['input'];
  day_type_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteServiceCalendarDayTypeByPkArgs = {
  day_type_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteServiceCalendarSubstituteOperatingDayByLineTypeArgs = {
  where: TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteServiceCalendarSubstituteOperatingDayByLineTypeByPkArgs = {
  substitute_operating_day_by_line_type_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteServiceCalendarSubstituteOperatingPeriodArgs = {
  where: TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteServiceCalendarSubstituteOperatingPeriodByPkArgs = {
  substitute_operating_period_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteServicePatternScheduledStopPointInJourneyPatternRefArgs = {
  where: TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteServicePatternScheduledStopPointInJourneyPatternRefByPkArgs = {
  scheduled_stop_point_in_journey_pattern_ref_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteVehicleJourneyVehicleJourneyArgs = {
  where: TimetablesVehicleJourneyVehicleJourneyBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteVehicleJourneyVehicleJourneyByPkArgs = {
  vehicle_journey_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteVehicleScheduleVehicleScheduleFrameArgs = {
  where: TimetablesVehicleScheduleVehicleScheduleFrameBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteVehicleScheduleVehicleScheduleFrameByPkArgs = {
  vehicle_schedule_frame_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteVehicleServiceBlockArgs = {
  where: TimetablesVehicleServiceBlockBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteVehicleServiceBlockByPkArgs = {
  block_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteVehicleServiceJourneyPatternsInVehicleServiceArgs = {
  where: TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteVehicleServiceJourneyPatternsInVehicleServiceByPkArgs = {
  journey_pattern_id: Scalars['uuid']['input'];
  vehicle_service_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteVehicleServiceVehicleServiceArgs = {
  where: TimetablesVehicleServiceVehicleServiceBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteVehicleServiceVehicleServiceByPkArgs = {
  vehicle_service_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteVehicleTypeVehicleTypeArgs = {
  where: TimetablesVehicleTypeVehicleTypeBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesDeleteVehicleTypeVehicleTypeByPkArgs = {
  vehicle_type_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertJourneyPatternJourneyPatternRefArgs = {
  objects: ReadonlyArray<TimetablesJourneyPatternJourneyPatternRefInsertInput>;
  on_conflict?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertJourneyPatternJourneyPatternRefOneArgs = {
  object: TimetablesJourneyPatternJourneyPatternRefInsertInput;
  on_conflict?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertPassingTimesTimetabledPassingTimeArgs = {
  objects: ReadonlyArray<TimetablesPassingTimesTimetabledPassingTimeInsertInput>;
  on_conflict?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertPassingTimesTimetabledPassingTimeOneArgs = {
  object: TimetablesPassingTimesTimetabledPassingTimeInsertInput;
  on_conflict?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertReturnValueTimetableVersionArgs = {
  objects: ReadonlyArray<TimetablesReturnValueTimetableVersionInsertInput>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertReturnValueTimetableVersionOneArgs = {
  object: TimetablesReturnValueTimetableVersionInsertInput;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertReturnValueVehicleScheduleArgs = {
  objects: ReadonlyArray<TimetablesReturnValueVehicleScheduleInsertInput>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertReturnValueVehicleScheduleOneArgs = {
  object: TimetablesReturnValueVehicleScheduleInsertInput;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertRouteDirectionArgs = {
  objects: ReadonlyArray<TimetablesRouteDirectionInsertInput>;
  on_conflict?: InputMaybe<TimetablesRouteDirectionOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertRouteDirectionOneArgs = {
  object: TimetablesRouteDirectionInsertInput;
  on_conflict?: InputMaybe<TimetablesRouteDirectionOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertRouteTypeOfLineArgs = {
  objects: ReadonlyArray<TimetablesRouteTypeOfLineInsertInput>;
  on_conflict?: InputMaybe<TimetablesRouteTypeOfLineOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertRouteTypeOfLineOneArgs = {
  object: TimetablesRouteTypeOfLineInsertInput;
  on_conflict?: InputMaybe<TimetablesRouteTypeOfLineOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertServiceCalendarDayTypeArgs = {
  objects: ReadonlyArray<TimetablesServiceCalendarDayTypeInsertInput>;
  on_conflict?: InputMaybe<TimetablesServiceCalendarDayTypeOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertServiceCalendarDayTypeActiveOnDayOfWeekArgs = {
  objects: ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekInsertInput>;
  on_conflict?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertServiceCalendarDayTypeActiveOnDayOfWeekOneArgs = {
  object: TimetablesServiceCalendarDayTypeActiveOnDayOfWeekInsertInput;
  on_conflict?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertServiceCalendarDayTypeOneArgs = {
  object: TimetablesServiceCalendarDayTypeInsertInput;
  on_conflict?: InputMaybe<TimetablesServiceCalendarDayTypeOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertServiceCalendarSubstituteOperatingDayByLineTypeArgs = {
  objects: ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeInsertInput>;
  on_conflict?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertServiceCalendarSubstituteOperatingDayByLineTypeOneArgs = {
  object: TimetablesServiceCalendarSubstituteOperatingDayByLineTypeInsertInput;
  on_conflict?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertServiceCalendarSubstituteOperatingPeriodArgs = {
  objects: ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingPeriodInsertInput>;
  on_conflict?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertServiceCalendarSubstituteOperatingPeriodOneArgs = {
  object: TimetablesServiceCalendarSubstituteOperatingPeriodInsertInput;
  on_conflict?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertServicePatternScheduledStopPointInJourneyPatternRefArgs = {
  objects: ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRefInsertInput>;
  on_conflict?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertServicePatternScheduledStopPointInJourneyPatternRefOneArgs = {
  object: TimetablesServicePatternScheduledStopPointInJourneyPatternRefInsertInput;
  on_conflict?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertVehicleJourneyVehicleJourneyArgs = {
  objects: ReadonlyArray<TimetablesVehicleJourneyVehicleJourneyInsertInput>;
  on_conflict?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertVehicleJourneyVehicleJourneyOneArgs = {
  object: TimetablesVehicleJourneyVehicleJourneyInsertInput;
  on_conflict?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertVehicleScheduleVehicleScheduleFrameArgs = {
  objects: ReadonlyArray<TimetablesVehicleScheduleVehicleScheduleFrameInsertInput>;
  on_conflict?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertVehicleScheduleVehicleScheduleFrameOneArgs = {
  object: TimetablesVehicleScheduleVehicleScheduleFrameInsertInput;
  on_conflict?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertVehicleServiceBlockArgs = {
  objects: ReadonlyArray<TimetablesVehicleServiceBlockInsertInput>;
  on_conflict?: InputMaybe<TimetablesVehicleServiceBlockOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertVehicleServiceBlockOneArgs = {
  object: TimetablesVehicleServiceBlockInsertInput;
  on_conflict?: InputMaybe<TimetablesVehicleServiceBlockOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertVehicleServiceJourneyPatternsInVehicleServiceArgs = {
  objects: ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleServiceInsertInput>;
  on_conflict?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertVehicleServiceJourneyPatternsInVehicleServiceOneArgs = {
  object: TimetablesVehicleServiceJourneyPatternsInVehicleServiceInsertInput;
  on_conflict?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertVehicleServiceVehicleServiceArgs = {
  objects: ReadonlyArray<TimetablesVehicleServiceVehicleServiceInsertInput>;
  on_conflict?: InputMaybe<TimetablesVehicleServiceVehicleServiceOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertVehicleServiceVehicleServiceOneArgs = {
  object: TimetablesVehicleServiceVehicleServiceInsertInput;
  on_conflict?: InputMaybe<TimetablesVehicleServiceVehicleServiceOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertVehicleTypeVehicleTypeArgs = {
  objects: ReadonlyArray<TimetablesVehicleTypeVehicleTypeInsertInput>;
  on_conflict?: InputMaybe<TimetablesVehicleTypeVehicleTypeOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesInsertVehicleTypeVehicleTypeOneArgs = {
  object: TimetablesVehicleTypeVehicleTypeInsertInput;
  on_conflict?: InputMaybe<TimetablesVehicleTypeVehicleTypeOnConflict>;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateJourneyPatternJourneyPatternRefArgs = {
  _set?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefSetInput>;
  where: TimetablesJourneyPatternJourneyPatternRefBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateJourneyPatternJourneyPatternRefByPkArgs = {
  _set?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefSetInput>;
  pk_columns: TimetablesJourneyPatternJourneyPatternRefPkColumnsInput;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateJourneyPatternJourneyPatternRefManyArgs = {
  updates: ReadonlyArray<TimetablesJourneyPatternJourneyPatternRefUpdates>;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdatePassingTimesTimetabledPassingTimeArgs = {
  _set?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeSetInput>;
  where: TimetablesPassingTimesTimetabledPassingTimeBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdatePassingTimesTimetabledPassingTimeByPkArgs = {
  _set?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeSetInput>;
  pk_columns: TimetablesPassingTimesTimetabledPassingTimePkColumnsInput;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdatePassingTimesTimetabledPassingTimeManyArgs = {
  updates: ReadonlyArray<TimetablesPassingTimesTimetabledPassingTimeUpdates>;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateReturnValueTimetableVersionArgs = {
  _inc?: InputMaybe<TimetablesReturnValueTimetableVersionIncInput>;
  _set?: InputMaybe<TimetablesReturnValueTimetableVersionSetInput>;
  where: TimetablesReturnValueTimetableVersionBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateReturnValueTimetableVersionManyArgs = {
  updates: ReadonlyArray<TimetablesReturnValueTimetableVersionUpdates>;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateReturnValueVehicleScheduleArgs = {
  _inc?: InputMaybe<TimetablesReturnValueVehicleScheduleIncInput>;
  _set?: InputMaybe<TimetablesReturnValueVehicleScheduleSetInput>;
  where: TimetablesReturnValueVehicleScheduleBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateReturnValueVehicleScheduleManyArgs = {
  updates: ReadonlyArray<TimetablesReturnValueVehicleScheduleUpdates>;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateRouteDirectionArgs = {
  _set?: InputMaybe<TimetablesRouteDirectionSetInput>;
  where: TimetablesRouteDirectionBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateRouteDirectionByPkArgs = {
  _set?: InputMaybe<TimetablesRouteDirectionSetInput>;
  pk_columns: TimetablesRouteDirectionPkColumnsInput;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateRouteDirectionManyArgs = {
  updates: ReadonlyArray<TimetablesRouteDirectionUpdates>;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateRouteTypeOfLineArgs = {
  _set?: InputMaybe<TimetablesRouteTypeOfLineSetInput>;
  where: TimetablesRouteTypeOfLineBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateRouteTypeOfLineByPkArgs = {
  _set?: InputMaybe<TimetablesRouteTypeOfLineSetInput>;
  pk_columns: TimetablesRouteTypeOfLinePkColumnsInput;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateRouteTypeOfLineManyArgs = {
  updates: ReadonlyArray<TimetablesRouteTypeOfLineUpdates>;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateServiceCalendarDayTypeArgs = {
  _append?: InputMaybe<TimetablesServiceCalendarDayTypeAppendInput>;
  _delete_at_path?: InputMaybe<TimetablesServiceCalendarDayTypeDeleteAtPathInput>;
  _delete_elem?: InputMaybe<TimetablesServiceCalendarDayTypeDeleteElemInput>;
  _delete_key?: InputMaybe<TimetablesServiceCalendarDayTypeDeleteKeyInput>;
  _prepend?: InputMaybe<TimetablesServiceCalendarDayTypePrependInput>;
  _set?: InputMaybe<TimetablesServiceCalendarDayTypeSetInput>;
  where: TimetablesServiceCalendarDayTypeBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateServiceCalendarDayTypeActiveOnDayOfWeekArgs = {
  _inc?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekIncInput>;
  _set?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSetInput>;
  where: TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateServiceCalendarDayTypeActiveOnDayOfWeekByPkArgs = {
  _inc?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekIncInput>;
  _set?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSetInput>;
  pk_columns: TimetablesServiceCalendarDayTypeActiveOnDayOfWeekPkColumnsInput;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateServiceCalendarDayTypeActiveOnDayOfWeekManyArgs = {
  updates: ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekUpdates>;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateServiceCalendarDayTypeByPkArgs = {
  _append?: InputMaybe<TimetablesServiceCalendarDayTypeAppendInput>;
  _delete_at_path?: InputMaybe<TimetablesServiceCalendarDayTypeDeleteAtPathInput>;
  _delete_elem?: InputMaybe<TimetablesServiceCalendarDayTypeDeleteElemInput>;
  _delete_key?: InputMaybe<TimetablesServiceCalendarDayTypeDeleteKeyInput>;
  _prepend?: InputMaybe<TimetablesServiceCalendarDayTypePrependInput>;
  _set?: InputMaybe<TimetablesServiceCalendarDayTypeSetInput>;
  pk_columns: TimetablesServiceCalendarDayTypePkColumnsInput;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateServiceCalendarDayTypeManyArgs = {
  updates: ReadonlyArray<TimetablesServiceCalendarDayTypeUpdates>;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateServiceCalendarSubstituteOperatingDayByLineTypeArgs = {
  _inc?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeIncInput>;
  _set?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSetInput>;
  where: TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateServiceCalendarSubstituteOperatingDayByLineTypeByPkArgs = {
  _inc?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeIncInput>;
  _set?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSetInput>;
  pk_columns: TimetablesServiceCalendarSubstituteOperatingDayByLineTypePkColumnsInput;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateServiceCalendarSubstituteOperatingDayByLineTypeManyArgs = {
  updates: ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeUpdates>;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateServiceCalendarSubstituteOperatingPeriodArgs = {
  _set?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodSetInput>;
  where: TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateServiceCalendarSubstituteOperatingPeriodByPkArgs = {
  _set?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodSetInput>;
  pk_columns: TimetablesServiceCalendarSubstituteOperatingPeriodPkColumnsInput;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateServiceCalendarSubstituteOperatingPeriodManyArgs = {
  updates: ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingPeriodUpdates>;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateServicePatternScheduledStopPointInJourneyPatternRefArgs = {
  _inc?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefIncInput>;
  _set?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSetInput>;
  where: TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateServicePatternScheduledStopPointInJourneyPatternRefByPkArgs = {
  _inc?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefIncInput>;
  _set?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSetInput>;
  pk_columns: TimetablesServicePatternScheduledStopPointInJourneyPatternRefPkColumnsInput;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateServicePatternScheduledStopPointInJourneyPatternRefManyArgs = {
  updates: ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRefUpdates>;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleJourneyVehicleJourneyArgs = {
  _append?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyAppendInput>;
  _delete_at_path?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyDeleteAtPathInput>;
  _delete_elem?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyDeleteElemInput>;
  _delete_key?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyDeleteKeyInput>;
  _prepend?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyPrependInput>;
  _set?: InputMaybe<TimetablesVehicleJourneyVehicleJourneySetInput>;
  where: TimetablesVehicleJourneyVehicleJourneyBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleJourneyVehicleJourneyByPkArgs = {
  _append?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyAppendInput>;
  _delete_at_path?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyDeleteAtPathInput>;
  _delete_elem?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyDeleteElemInput>;
  _delete_key?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyDeleteKeyInput>;
  _prepend?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyPrependInput>;
  _set?: InputMaybe<TimetablesVehicleJourneyVehicleJourneySetInput>;
  pk_columns: TimetablesVehicleJourneyVehicleJourneyPkColumnsInput;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleJourneyVehicleJourneyManyArgs = {
  updates: ReadonlyArray<TimetablesVehicleJourneyVehicleJourneyUpdates>;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleScheduleVehicleScheduleFrameArgs = {
  _append?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameAppendInput>;
  _delete_at_path?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameDeleteAtPathInput>;
  _delete_elem?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameDeleteElemInput>;
  _delete_key?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameDeleteKeyInput>;
  _inc?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameIncInput>;
  _prepend?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFramePrependInput>;
  _set?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameSetInput>;
  where: TimetablesVehicleScheduleVehicleScheduleFrameBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleScheduleVehicleScheduleFrameByPkArgs = {
  _append?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameAppendInput>;
  _delete_at_path?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameDeleteAtPathInput>;
  _delete_elem?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameDeleteElemInput>;
  _delete_key?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameDeleteKeyInput>;
  _inc?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameIncInput>;
  _prepend?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFramePrependInput>;
  _set?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameSetInput>;
  pk_columns: TimetablesVehicleScheduleVehicleScheduleFramePkColumnsInput;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleScheduleVehicleScheduleFrameManyArgs = {
  updates: ReadonlyArray<TimetablesVehicleScheduleVehicleScheduleFrameUpdates>;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleServiceBlockArgs = {
  _set?: InputMaybe<TimetablesVehicleServiceBlockSetInput>;
  where: TimetablesVehicleServiceBlockBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleServiceBlockByPkArgs = {
  _set?: InputMaybe<TimetablesVehicleServiceBlockSetInput>;
  pk_columns: TimetablesVehicleServiceBlockPkColumnsInput;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleServiceBlockManyArgs = {
  updates: ReadonlyArray<TimetablesVehicleServiceBlockUpdates>;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleServiceJourneyPatternsInVehicleServiceArgs = {
  _inc?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceIncInput>;
  _set?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSetInput>;
  where: TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleServiceJourneyPatternsInVehicleServiceByPkArgs = {
  _inc?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceIncInput>;
  _set?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSetInput>;
  pk_columns: TimetablesVehicleServiceJourneyPatternsInVehicleServicePkColumnsInput;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleServiceJourneyPatternsInVehicleServiceManyArgs = {
  updates: ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleServiceUpdates>;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleServiceVehicleServiceArgs = {
  _append?: InputMaybe<TimetablesVehicleServiceVehicleServiceAppendInput>;
  _delete_at_path?: InputMaybe<TimetablesVehicleServiceVehicleServiceDeleteAtPathInput>;
  _delete_elem?: InputMaybe<TimetablesVehicleServiceVehicleServiceDeleteElemInput>;
  _delete_key?: InputMaybe<TimetablesVehicleServiceVehicleServiceDeleteKeyInput>;
  _prepend?: InputMaybe<TimetablesVehicleServiceVehicleServicePrependInput>;
  _set?: InputMaybe<TimetablesVehicleServiceVehicleServiceSetInput>;
  where: TimetablesVehicleServiceVehicleServiceBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleServiceVehicleServiceByPkArgs = {
  _append?: InputMaybe<TimetablesVehicleServiceVehicleServiceAppendInput>;
  _delete_at_path?: InputMaybe<TimetablesVehicleServiceVehicleServiceDeleteAtPathInput>;
  _delete_elem?: InputMaybe<TimetablesVehicleServiceVehicleServiceDeleteElemInput>;
  _delete_key?: InputMaybe<TimetablesVehicleServiceVehicleServiceDeleteKeyInput>;
  _prepend?: InputMaybe<TimetablesVehicleServiceVehicleServicePrependInput>;
  _set?: InputMaybe<TimetablesVehicleServiceVehicleServiceSetInput>;
  pk_columns: TimetablesVehicleServiceVehicleServicePkColumnsInput;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleServiceVehicleServiceManyArgs = {
  updates: ReadonlyArray<TimetablesVehicleServiceVehicleServiceUpdates>;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleTypeVehicleTypeArgs = {
  _append?: InputMaybe<TimetablesVehicleTypeVehicleTypeAppendInput>;
  _delete_at_path?: InputMaybe<TimetablesVehicleTypeVehicleTypeDeleteAtPathInput>;
  _delete_elem?: InputMaybe<TimetablesVehicleTypeVehicleTypeDeleteElemInput>;
  _delete_key?: InputMaybe<TimetablesVehicleTypeVehicleTypeDeleteKeyInput>;
  _inc?: InputMaybe<TimetablesVehicleTypeVehicleTypeIncInput>;
  _prepend?: InputMaybe<TimetablesVehicleTypeVehicleTypePrependInput>;
  _set?: InputMaybe<TimetablesVehicleTypeVehicleTypeSetInput>;
  where: TimetablesVehicleTypeVehicleTypeBoolExp;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleTypeVehicleTypeByPkArgs = {
  _append?: InputMaybe<TimetablesVehicleTypeVehicleTypeAppendInput>;
  _delete_at_path?: InputMaybe<TimetablesVehicleTypeVehicleTypeDeleteAtPathInput>;
  _delete_elem?: InputMaybe<TimetablesVehicleTypeVehicleTypeDeleteElemInput>;
  _delete_key?: InputMaybe<TimetablesVehicleTypeVehicleTypeDeleteKeyInput>;
  _inc?: InputMaybe<TimetablesVehicleTypeVehicleTypeIncInput>;
  _prepend?: InputMaybe<TimetablesVehicleTypeVehicleTypePrependInput>;
  _set?: InputMaybe<TimetablesVehicleTypeVehicleTypeSetInput>;
  pk_columns: TimetablesVehicleTypeVehicleTypePkColumnsInput;
};


export type TimetablesTimetablesMutationFrontendTimetablesUpdateVehicleTypeVehicleTypeManyArgs = {
  updates: ReadonlyArray<TimetablesVehicleTypeVehicleTypeUpdates>;
};

export type TimetablesTimetablesQuery = {
  readonly __typename?: 'timetables_timetables_query';
  /** fetch data from the table: "journey_pattern.journey_pattern_ref" */
  readonly timetables_journey_pattern_journey_pattern_ref: ReadonlyArray<TimetablesJourneyPatternJourneyPatternRef>;
  /** fetch aggregated fields from the table: "journey_pattern.journey_pattern_ref" */
  readonly timetables_journey_pattern_journey_pattern_ref_aggregate: TimetablesJourneyPatternJourneyPatternRefAggregate;
  /** fetch data from the table: "journey_pattern.journey_pattern_ref" using primary key columns */
  readonly timetables_journey_pattern_journey_pattern_ref_by_pk?: Maybe<TimetablesJourneyPatternJourneyPatternRef>;
  /** fetch data from the table: "passing_times.timetabled_passing_time" */
  readonly timetables_passing_times_timetabled_passing_time: ReadonlyArray<TimetablesPassingTimesTimetabledPassingTime>;
  /** fetch aggregated fields from the table: "passing_times.timetabled_passing_time" */
  readonly timetables_passing_times_timetabled_passing_time_aggregate: TimetablesPassingTimesTimetabledPassingTimeAggregate;
  /** fetch data from the table: "passing_times.timetabled_passing_time" using primary key columns */
  readonly timetables_passing_times_timetabled_passing_time_by_pk?: Maybe<TimetablesPassingTimesTimetabledPassingTime>;
  /** fetch data from the table: "return_value.timetable_version" */
  readonly timetables_return_value_timetable_version: ReadonlyArray<TimetablesReturnValueTimetableVersion>;
  /** fetch aggregated fields from the table: "return_value.timetable_version" */
  readonly timetables_return_value_timetable_version_aggregate: TimetablesReturnValueTimetableVersionAggregate;
  /** fetch data from the table: "return_value.vehicle_schedule" */
  readonly timetables_return_value_vehicle_schedule: ReadonlyArray<TimetablesReturnValueVehicleSchedule>;
  /** fetch aggregated fields from the table: "return_value.vehicle_schedule" */
  readonly timetables_return_value_vehicle_schedule_aggregate: TimetablesReturnValueVehicleScheduleAggregate;
  /** fetch data from the table: "route.direction" */
  readonly timetables_route_direction: ReadonlyArray<TimetablesRouteDirection>;
  /** fetch aggregated fields from the table: "route.direction" */
  readonly timetables_route_direction_aggregate: TimetablesRouteDirectionAggregate;
  /** fetch data from the table: "route.direction" using primary key columns */
  readonly timetables_route_direction_by_pk?: Maybe<TimetablesRouteDirection>;
  /** fetch data from the table: "route.type_of_line" */
  readonly timetables_route_type_of_line: ReadonlyArray<TimetablesRouteTypeOfLine>;
  /** fetch aggregated fields from the table: "route.type_of_line" */
  readonly timetables_route_type_of_line_aggregate: TimetablesRouteTypeOfLineAggregate;
  /** fetch data from the table: "route.type_of_line" using primary key columns */
  readonly timetables_route_type_of_line_by_pk?: Maybe<TimetablesRouteTypeOfLine>;
  /** fetch data from the table: "service_calendar.day_type" */
  readonly timetables_service_calendar_day_type: ReadonlyArray<TimetablesServiceCalendarDayType>;
  /** fetch data from the table: "service_calendar.day_type_active_on_day_of_week" */
  readonly timetables_service_calendar_day_type_active_on_day_of_week: ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeek>;
  /** fetch aggregated fields from the table: "service_calendar.day_type_active_on_day_of_week" */
  readonly timetables_service_calendar_day_type_active_on_day_of_week_aggregate: TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAggregate;
  /** fetch data from the table: "service_calendar.day_type_active_on_day_of_week" using primary key columns */
  readonly timetables_service_calendar_day_type_active_on_day_of_week_by_pk?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeek>;
  /** fetch aggregated fields from the table: "service_calendar.day_type" */
  readonly timetables_service_calendar_day_type_aggregate: TimetablesServiceCalendarDayTypeAggregate;
  /** fetch data from the table: "service_calendar.day_type" using primary key columns */
  readonly timetables_service_calendar_day_type_by_pk?: Maybe<TimetablesServiceCalendarDayType>;
  /** execute function "service_calendar.get_active_day_types_for_date" which returns "service_calendar.day_type" */
  readonly timetables_service_calendar_get_active_day_types_for_date: ReadonlyArray<TimetablesServiceCalendarDayType>;
  /** execute function "service_calendar.get_active_day_types_for_date" and query aggregates on result of table type "service_calendar.day_type" */
  readonly timetables_service_calendar_get_active_day_types_for_date_aggregate: TimetablesServiceCalendarDayTypeAggregate;
  /** fetch data from the table: "service_calendar.substitute_operating_day_by_line_type" */
  readonly timetables_service_calendar_substitute_operating_day_by_line_type: ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineType>;
  /** fetch aggregated fields from the table: "service_calendar.substitute_operating_day_by_line_type" */
  readonly timetables_service_calendar_substitute_operating_day_by_line_type_aggregate: TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAggregate;
  /** fetch data from the table: "service_calendar.substitute_operating_day_by_line_type" using primary key columns */
  readonly timetables_service_calendar_substitute_operating_day_by_line_type_by_pk?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineType>;
  /** fetch data from the table: "service_calendar.substitute_operating_period" */
  readonly timetables_service_calendar_substitute_operating_period: ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingPeriod>;
  /** fetch aggregated fields from the table: "service_calendar.substitute_operating_period" */
  readonly timetables_service_calendar_substitute_operating_period_aggregate: TimetablesServiceCalendarSubstituteOperatingPeriodAggregate;
  /** fetch data from the table: "service_calendar.substitute_operating_period" using primary key columns */
  readonly timetables_service_calendar_substitute_operating_period_by_pk?: Maybe<TimetablesServiceCalendarSubstituteOperatingPeriod>;
  /** fetch data from the table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
  readonly timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref: ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRef>;
  /** fetch aggregated fields from the table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
  readonly timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_aggregate: TimetablesServicePatternScheduledStopPointInJourneyPatternRefAggregate;
  /** fetch data from the table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" using primary key columns */
  readonly timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_by_pk?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRef>;
  /** execute function "vehicle_journey.get_vehicle_schedules_on_date" which returns "return_value.vehicle_schedule" */
  readonly timetables_vehicle_journey_get_vehicle_schedules_on_date: ReadonlyArray<TimetablesReturnValueVehicleSchedule>;
  /** execute function "vehicle_journey.get_vehicle_schedules_on_date" and query aggregates on result of table type "return_value.vehicle_schedule" */
  readonly timetables_vehicle_journey_get_vehicle_schedules_on_date_aggregate: TimetablesReturnValueVehicleScheduleAggregate;
  /** fetch data from the table: "vehicle_journey.vehicle_journey" */
  readonly timetables_vehicle_journey_vehicle_journey: ReadonlyArray<TimetablesVehicleJourneyVehicleJourney>;
  /** fetch aggregated fields from the table: "vehicle_journey.vehicle_journey" */
  readonly timetables_vehicle_journey_vehicle_journey_aggregate: TimetablesVehicleJourneyVehicleJourneyAggregate;
  /** fetch data from the table: "vehicle_journey.vehicle_journey" using primary key columns */
  readonly timetables_vehicle_journey_vehicle_journey_by_pk?: Maybe<TimetablesVehicleJourneyVehicleJourney>;
  /** fetch data from the table: "vehicle_schedule.vehicle_schedule_frame" */
  readonly timetables_vehicle_schedule_vehicle_schedule_frame: ReadonlyArray<TimetablesVehicleScheduleVehicleScheduleFrame>;
  /** fetch aggregated fields from the table: "vehicle_schedule.vehicle_schedule_frame" */
  readonly timetables_vehicle_schedule_vehicle_schedule_frame_aggregate: TimetablesVehicleScheduleVehicleScheduleFrameAggregate;
  /** fetch data from the table: "vehicle_schedule.vehicle_schedule_frame" using primary key columns */
  readonly timetables_vehicle_schedule_vehicle_schedule_frame_by_pk?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrame>;
  /** fetch data from the table: "vehicle_service.block" */
  readonly timetables_vehicle_service_block: ReadonlyArray<TimetablesVehicleServiceBlock>;
  /** fetch aggregated fields from the table: "vehicle_service.block" */
  readonly timetables_vehicle_service_block_aggregate: TimetablesVehicleServiceBlockAggregate;
  /** fetch data from the table: "vehicle_service.block" using primary key columns */
  readonly timetables_vehicle_service_block_by_pk?: Maybe<TimetablesVehicleServiceBlock>;
  /** execute function "vehicle_service.get_timetable_versions_by_journey_pattern_ids" which returns "return_value.timetable_version" */
  readonly timetables_vehicle_service_get_timetable_versions_by_journey_pattern_ids: ReadonlyArray<TimetablesReturnValueTimetableVersion>;
  /** execute function "vehicle_service.get_timetable_versions_by_journey_pattern_ids" and query aggregates on result of table type "return_value.timetable_version" */
  readonly timetables_vehicle_service_get_timetable_versions_by_journey_pattern_ids_aggregate: TimetablesReturnValueTimetableVersionAggregate;
  /** execute function "vehicle_service.get_timetables_and_substitute_operating_days" which returns "return_value.timetable_version" */
  readonly timetables_vehicle_service_get_timetables_and_substitute_operating_days: ReadonlyArray<TimetablesReturnValueTimetableVersion>;
  /** execute function "vehicle_service.get_timetables_and_substitute_operating_days" and query aggregates on result of table type "return_value.timetable_version" */
  readonly timetables_vehicle_service_get_timetables_and_substitute_operating_days_aggregate: TimetablesReturnValueTimetableVersionAggregate;
  /** fetch data from the table: "vehicle_service.journey_patterns_in_vehicle_service" */
  readonly timetables_vehicle_service_journey_patterns_in_vehicle_service: ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleService>;
  /** fetch aggregated fields from the table: "vehicle_service.journey_patterns_in_vehicle_service" */
  readonly timetables_vehicle_service_journey_patterns_in_vehicle_service_aggregate: TimetablesVehicleServiceJourneyPatternsInVehicleServiceAggregate;
  /** fetch data from the table: "vehicle_service.journey_patterns_in_vehicle_service" using primary key columns */
  readonly timetables_vehicle_service_journey_patterns_in_vehicle_service_by_pk?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleService>;
  /** fetch data from the table: "vehicle_service.vehicle_service" */
  readonly timetables_vehicle_service_vehicle_service: ReadonlyArray<TimetablesVehicleServiceVehicleService>;
  /** fetch aggregated fields from the table: "vehicle_service.vehicle_service" */
  readonly timetables_vehicle_service_vehicle_service_aggregate: TimetablesVehicleServiceVehicleServiceAggregate;
  /** fetch data from the table: "vehicle_service.vehicle_service" using primary key columns */
  readonly timetables_vehicle_service_vehicle_service_by_pk?: Maybe<TimetablesVehicleServiceVehicleService>;
  /** fetch data from the table: "vehicle_type.vehicle_type" */
  readonly timetables_vehicle_type_vehicle_type: ReadonlyArray<TimetablesVehicleTypeVehicleType>;
  /** fetch aggregated fields from the table: "vehicle_type.vehicle_type" */
  readonly timetables_vehicle_type_vehicle_type_aggregate: TimetablesVehicleTypeVehicleTypeAggregate;
  /** fetch data from the table: "vehicle_type.vehicle_type" using primary key columns */
  readonly timetables_vehicle_type_vehicle_type_by_pk?: Maybe<TimetablesVehicleTypeVehicleType>;
};


export type TimetablesTimetablesQueryTimetablesJourneyPatternJourneyPatternRefArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesJourneyPatternJourneyPatternRefSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesJourneyPatternJourneyPatternRefOrderBy>>;
  where?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesJourneyPatternJourneyPatternRefAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesJourneyPatternJourneyPatternRefSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesJourneyPatternJourneyPatternRefOrderBy>>;
  where?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesJourneyPatternJourneyPatternRefByPkArgs = {
  journey_pattern_ref_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesQueryTimetablesPassingTimesTimetabledPassingTimeArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesPassingTimesTimetabledPassingTimeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesPassingTimesTimetabledPassingTimeOrderBy>>;
  where?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesPassingTimesTimetabledPassingTimeAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesPassingTimesTimetabledPassingTimeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesPassingTimesTimetabledPassingTimeOrderBy>>;
  where?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesPassingTimesTimetabledPassingTimeByPkArgs = {
  timetabled_passing_time_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesQueryTimetablesReturnValueTimetableVersionArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionOrderBy>>;
  where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesReturnValueTimetableVersionAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionOrderBy>>;
  where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesReturnValueVehicleScheduleArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesReturnValueVehicleScheduleSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesReturnValueVehicleScheduleOrderBy>>;
  where?: InputMaybe<TimetablesReturnValueVehicleScheduleBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesReturnValueVehicleScheduleAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesReturnValueVehicleScheduleSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesReturnValueVehicleScheduleOrderBy>>;
  where?: InputMaybe<TimetablesReturnValueVehicleScheduleBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesRouteDirectionArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesRouteDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesRouteDirectionOrderBy>>;
  where?: InputMaybe<TimetablesRouteDirectionBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesRouteDirectionAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesRouteDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesRouteDirectionOrderBy>>;
  where?: InputMaybe<TimetablesRouteDirectionBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesRouteDirectionByPkArgs = {
  direction: Scalars['String']['input'];
};


export type TimetablesTimetablesQueryTimetablesRouteTypeOfLineArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesRouteTypeOfLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesRouteTypeOfLineOrderBy>>;
  where?: InputMaybe<TimetablesRouteTypeOfLineBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesRouteTypeOfLineAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesRouteTypeOfLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesRouteTypeOfLineOrderBy>>;
  where?: InputMaybe<TimetablesRouteTypeOfLineBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesRouteTypeOfLineByPkArgs = {
  type_of_line: Scalars['String']['input'];
};


export type TimetablesTimetablesQueryTimetablesServiceCalendarDayTypeArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeOrderBy>>;
  where?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesServiceCalendarDayTypeActiveOnDayOfWeekArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekOrderBy>>;
  where?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesServiceCalendarDayTypeActiveOnDayOfWeekAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekOrderBy>>;
  where?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesServiceCalendarDayTypeActiveOnDayOfWeekByPkArgs = {
  day_of_week: Scalars['Int']['input'];
  day_type_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesQueryTimetablesServiceCalendarDayTypeAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeOrderBy>>;
  where?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesServiceCalendarDayTypeByPkArgs = {
  day_type_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesQueryTimetablesServiceCalendarGetActiveDayTypesForDateArgs = {
  args: TimetablesServiceCalendarGetActiveDayTypesForDateArgs;
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeOrderBy>>;
  where?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesServiceCalendarGetActiveDayTypesForDateAggregateArgs = {
  args: TimetablesServiceCalendarGetActiveDayTypesForDateArgs;
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeOrderBy>>;
  where?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesServiceCalendarSubstituteOperatingDayByLineTypeArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOrderBy>>;
  where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesServiceCalendarSubstituteOperatingDayByLineTypeAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOrderBy>>;
  where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesServiceCalendarSubstituteOperatingDayByLineTypeByPkArgs = {
  substitute_operating_day_by_line_type_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesQueryTimetablesServiceCalendarSubstituteOperatingPeriodArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingPeriodSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingPeriodOrderBy>>;
  where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesServiceCalendarSubstituteOperatingPeriodAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingPeriodSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingPeriodOrderBy>>;
  where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesServiceCalendarSubstituteOperatingPeriodByPkArgs = {
  substitute_operating_period_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesQueryTimetablesServicePatternScheduledStopPointInJourneyPatternRefArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRefOrderBy>>;
  where?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesServicePatternScheduledStopPointInJourneyPatternRefAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRefOrderBy>>;
  where?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesServicePatternScheduledStopPointInJourneyPatternRefByPkArgs = {
  scheduled_stop_point_in_journey_pattern_ref_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesQueryTimetablesVehicleJourneyGetVehicleSchedulesOnDateArgs = {
  args: TimetablesVehicleJourneyGetVehicleSchedulesOnDateArgs;
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesReturnValueVehicleScheduleSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesReturnValueVehicleScheduleOrderBy>>;
  where?: InputMaybe<TimetablesReturnValueVehicleScheduleBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesVehicleJourneyGetVehicleSchedulesOnDateAggregateArgs = {
  args: TimetablesVehicleJourneyGetVehicleSchedulesOnDateArgs;
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesReturnValueVehicleScheduleSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesReturnValueVehicleScheduleOrderBy>>;
  where?: InputMaybe<TimetablesReturnValueVehicleScheduleBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesVehicleJourneyVehicleJourneyArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleJourneyVehicleJourneySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleJourneyVehicleJourneyOrderBy>>;
  where?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesVehicleJourneyVehicleJourneyAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleJourneyVehicleJourneySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleJourneyVehicleJourneyOrderBy>>;
  where?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesVehicleJourneyVehicleJourneyByPkArgs = {
  vehicle_journey_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesQueryTimetablesVehicleScheduleVehicleScheduleFrameArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleScheduleVehicleScheduleFrameSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleScheduleVehicleScheduleFrameOrderBy>>;
  where?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesVehicleScheduleVehicleScheduleFrameAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleScheduleVehicleScheduleFrameSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleScheduleVehicleScheduleFrameOrderBy>>;
  where?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesVehicleScheduleVehicleScheduleFrameByPkArgs = {
  vehicle_schedule_frame_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesQueryTimetablesVehicleServiceBlockArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceBlockSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceBlockOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceBlockBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesVehicleServiceBlockAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceBlockSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceBlockOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceBlockBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesVehicleServiceBlockByPkArgs = {
  block_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesQueryTimetablesVehicleServiceGetTimetableVersionsByJourneyPatternIdsArgs = {
  args: TimetablesVehicleServiceGetTimetableVersionsByJourneyPatternIdsArgs;
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionOrderBy>>;
  where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesVehicleServiceGetTimetableVersionsByJourneyPatternIdsAggregateArgs = {
  args: TimetablesVehicleServiceGetTimetableVersionsByJourneyPatternIdsArgs;
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionOrderBy>>;
  where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesVehicleServiceGetTimetablesAndSubstituteOperatingDaysArgs = {
  args: TimetablesVehicleServiceGetTimetablesAndSubstituteOperatingDaysArgs;
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionOrderBy>>;
  where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesVehicleServiceGetTimetablesAndSubstituteOperatingDaysAggregateArgs = {
  args: TimetablesVehicleServiceGetTimetablesAndSubstituteOperatingDaysArgs;
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionOrderBy>>;
  where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesVehicleServiceJourneyPatternsInVehicleServiceArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleServiceOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesVehicleServiceJourneyPatternsInVehicleServiceAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleServiceOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesVehicleServiceJourneyPatternsInVehicleServiceByPkArgs = {
  journey_pattern_id: Scalars['uuid']['input'];
  vehicle_service_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesQueryTimetablesVehicleServiceVehicleServiceArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceVehicleServiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceVehicleServiceOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesVehicleServiceVehicleServiceAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceVehicleServiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceVehicleServiceOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesVehicleServiceVehicleServiceByPkArgs = {
  vehicle_service_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesQueryTimetablesVehicleTypeVehicleTypeArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleTypeVehicleTypeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleTypeVehicleTypeOrderBy>>;
  where?: InputMaybe<TimetablesVehicleTypeVehicleTypeBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesVehicleTypeVehicleTypeAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleTypeVehicleTypeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleTypeVehicleTypeOrderBy>>;
  where?: InputMaybe<TimetablesVehicleTypeVehicleTypeBoolExp>;
};


export type TimetablesTimetablesQueryTimetablesVehicleTypeVehicleTypeByPkArgs = {
  vehicle_type_id: Scalars['uuid']['input'];
};

export type TimetablesTimetablesSubscription = {
  readonly __typename?: 'timetables_timetables_subscription';
  /** fetch data from the table: "journey_pattern.journey_pattern_ref" */
  readonly timetables_journey_pattern_journey_pattern_ref: ReadonlyArray<TimetablesJourneyPatternJourneyPatternRef>;
  /** fetch aggregated fields from the table: "journey_pattern.journey_pattern_ref" */
  readonly timetables_journey_pattern_journey_pattern_ref_aggregate: TimetablesJourneyPatternJourneyPatternRefAggregate;
  /** fetch data from the table: "journey_pattern.journey_pattern_ref" using primary key columns */
  readonly timetables_journey_pattern_journey_pattern_ref_by_pk?: Maybe<TimetablesJourneyPatternJourneyPatternRef>;
  /** fetch data from the table in a streaming manner: "journey_pattern.journey_pattern_ref" */
  readonly timetables_journey_pattern_journey_pattern_ref_stream: ReadonlyArray<TimetablesJourneyPatternJourneyPatternRef>;
  /** fetch data from the table: "passing_times.timetabled_passing_time" */
  readonly timetables_passing_times_timetabled_passing_time: ReadonlyArray<TimetablesPassingTimesTimetabledPassingTime>;
  /** fetch aggregated fields from the table: "passing_times.timetabled_passing_time" */
  readonly timetables_passing_times_timetabled_passing_time_aggregate: TimetablesPassingTimesTimetabledPassingTimeAggregate;
  /** fetch data from the table: "passing_times.timetabled_passing_time" using primary key columns */
  readonly timetables_passing_times_timetabled_passing_time_by_pk?: Maybe<TimetablesPassingTimesTimetabledPassingTime>;
  /** fetch data from the table in a streaming manner: "passing_times.timetabled_passing_time" */
  readonly timetables_passing_times_timetabled_passing_time_stream: ReadonlyArray<TimetablesPassingTimesTimetabledPassingTime>;
  /** fetch data from the table: "return_value.timetable_version" */
  readonly timetables_return_value_timetable_version: ReadonlyArray<TimetablesReturnValueTimetableVersion>;
  /** fetch aggregated fields from the table: "return_value.timetable_version" */
  readonly timetables_return_value_timetable_version_aggregate: TimetablesReturnValueTimetableVersionAggregate;
  /** fetch data from the table in a streaming manner: "return_value.timetable_version" */
  readonly timetables_return_value_timetable_version_stream: ReadonlyArray<TimetablesReturnValueTimetableVersion>;
  /** fetch data from the table: "return_value.vehicle_schedule" */
  readonly timetables_return_value_vehicle_schedule: ReadonlyArray<TimetablesReturnValueVehicleSchedule>;
  /** fetch aggregated fields from the table: "return_value.vehicle_schedule" */
  readonly timetables_return_value_vehicle_schedule_aggregate: TimetablesReturnValueVehicleScheduleAggregate;
  /** fetch data from the table in a streaming manner: "return_value.vehicle_schedule" */
  readonly timetables_return_value_vehicle_schedule_stream: ReadonlyArray<TimetablesReturnValueVehicleSchedule>;
  /** fetch data from the table: "route.direction" */
  readonly timetables_route_direction: ReadonlyArray<TimetablesRouteDirection>;
  /** fetch aggregated fields from the table: "route.direction" */
  readonly timetables_route_direction_aggregate: TimetablesRouteDirectionAggregate;
  /** fetch data from the table: "route.direction" using primary key columns */
  readonly timetables_route_direction_by_pk?: Maybe<TimetablesRouteDirection>;
  /** fetch data from the table in a streaming manner: "route.direction" */
  readonly timetables_route_direction_stream: ReadonlyArray<TimetablesRouteDirection>;
  /** fetch data from the table: "route.type_of_line" */
  readonly timetables_route_type_of_line: ReadonlyArray<TimetablesRouteTypeOfLine>;
  /** fetch aggregated fields from the table: "route.type_of_line" */
  readonly timetables_route_type_of_line_aggregate: TimetablesRouteTypeOfLineAggregate;
  /** fetch data from the table: "route.type_of_line" using primary key columns */
  readonly timetables_route_type_of_line_by_pk?: Maybe<TimetablesRouteTypeOfLine>;
  /** fetch data from the table in a streaming manner: "route.type_of_line" */
  readonly timetables_route_type_of_line_stream: ReadonlyArray<TimetablesRouteTypeOfLine>;
  /** fetch data from the table: "service_calendar.day_type" */
  readonly timetables_service_calendar_day_type: ReadonlyArray<TimetablesServiceCalendarDayType>;
  /** fetch data from the table: "service_calendar.day_type_active_on_day_of_week" */
  readonly timetables_service_calendar_day_type_active_on_day_of_week: ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeek>;
  /** fetch aggregated fields from the table: "service_calendar.day_type_active_on_day_of_week" */
  readonly timetables_service_calendar_day_type_active_on_day_of_week_aggregate: TimetablesServiceCalendarDayTypeActiveOnDayOfWeekAggregate;
  /** fetch data from the table: "service_calendar.day_type_active_on_day_of_week" using primary key columns */
  readonly timetables_service_calendar_day_type_active_on_day_of_week_by_pk?: Maybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeek>;
  /** fetch data from the table in a streaming manner: "service_calendar.day_type_active_on_day_of_week" */
  readonly timetables_service_calendar_day_type_active_on_day_of_week_stream: ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeek>;
  /** fetch aggregated fields from the table: "service_calendar.day_type" */
  readonly timetables_service_calendar_day_type_aggregate: TimetablesServiceCalendarDayTypeAggregate;
  /** fetch data from the table: "service_calendar.day_type" using primary key columns */
  readonly timetables_service_calendar_day_type_by_pk?: Maybe<TimetablesServiceCalendarDayType>;
  /** fetch data from the table in a streaming manner: "service_calendar.day_type" */
  readonly timetables_service_calendar_day_type_stream: ReadonlyArray<TimetablesServiceCalendarDayType>;
  /** execute function "service_calendar.get_active_day_types_for_date" which returns "service_calendar.day_type" */
  readonly timetables_service_calendar_get_active_day_types_for_date: ReadonlyArray<TimetablesServiceCalendarDayType>;
  /** execute function "service_calendar.get_active_day_types_for_date" and query aggregates on result of table type "service_calendar.day_type" */
  readonly timetables_service_calendar_get_active_day_types_for_date_aggregate: TimetablesServiceCalendarDayTypeAggregate;
  /** fetch data from the table: "service_calendar.substitute_operating_day_by_line_type" */
  readonly timetables_service_calendar_substitute_operating_day_by_line_type: ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineType>;
  /** fetch aggregated fields from the table: "service_calendar.substitute_operating_day_by_line_type" */
  readonly timetables_service_calendar_substitute_operating_day_by_line_type_aggregate: TimetablesServiceCalendarSubstituteOperatingDayByLineTypeAggregate;
  /** fetch data from the table: "service_calendar.substitute_operating_day_by_line_type" using primary key columns */
  readonly timetables_service_calendar_substitute_operating_day_by_line_type_by_pk?: Maybe<TimetablesServiceCalendarSubstituteOperatingDayByLineType>;
  /** fetch data from the table in a streaming manner: "service_calendar.substitute_operating_day_by_line_type" */
  readonly timetables_service_calendar_substitute_operating_day_by_line_type_stream: ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineType>;
  /** fetch data from the table: "service_calendar.substitute_operating_period" */
  readonly timetables_service_calendar_substitute_operating_period: ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingPeriod>;
  /** fetch aggregated fields from the table: "service_calendar.substitute_operating_period" */
  readonly timetables_service_calendar_substitute_operating_period_aggregate: TimetablesServiceCalendarSubstituteOperatingPeriodAggregate;
  /** fetch data from the table: "service_calendar.substitute_operating_period" using primary key columns */
  readonly timetables_service_calendar_substitute_operating_period_by_pk?: Maybe<TimetablesServiceCalendarSubstituteOperatingPeriod>;
  /** fetch data from the table in a streaming manner: "service_calendar.substitute_operating_period" */
  readonly timetables_service_calendar_substitute_operating_period_stream: ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingPeriod>;
  /** fetch data from the table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
  readonly timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref: ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRef>;
  /** fetch aggregated fields from the table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
  readonly timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_aggregate: TimetablesServicePatternScheduledStopPointInJourneyPatternRefAggregate;
  /** fetch data from the table: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" using primary key columns */
  readonly timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_by_pk?: Maybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRef>;
  /** fetch data from the table in a streaming manner: "service_pattern.scheduled_stop_point_in_journey_pattern_ref" */
  readonly timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref_stream: ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRef>;
  /** execute function "vehicle_journey.get_vehicle_schedules_on_date" which returns "return_value.vehicle_schedule" */
  readonly timetables_vehicle_journey_get_vehicle_schedules_on_date: ReadonlyArray<TimetablesReturnValueVehicleSchedule>;
  /** execute function "vehicle_journey.get_vehicle_schedules_on_date" and query aggregates on result of table type "return_value.vehicle_schedule" */
  readonly timetables_vehicle_journey_get_vehicle_schedules_on_date_aggregate: TimetablesReturnValueVehicleScheduleAggregate;
  /** fetch data from the table: "vehicle_journey.vehicle_journey" */
  readonly timetables_vehicle_journey_vehicle_journey: ReadonlyArray<TimetablesVehicleJourneyVehicleJourney>;
  /** fetch aggregated fields from the table: "vehicle_journey.vehicle_journey" */
  readonly timetables_vehicle_journey_vehicle_journey_aggregate: TimetablesVehicleJourneyVehicleJourneyAggregate;
  /** fetch data from the table: "vehicle_journey.vehicle_journey" using primary key columns */
  readonly timetables_vehicle_journey_vehicle_journey_by_pk?: Maybe<TimetablesVehicleJourneyVehicleJourney>;
  /** fetch data from the table in a streaming manner: "vehicle_journey.vehicle_journey" */
  readonly timetables_vehicle_journey_vehicle_journey_stream: ReadonlyArray<TimetablesVehicleJourneyVehicleJourney>;
  /** fetch data from the table: "vehicle_schedule.vehicle_schedule_frame" */
  readonly timetables_vehicle_schedule_vehicle_schedule_frame: ReadonlyArray<TimetablesVehicleScheduleVehicleScheduleFrame>;
  /** fetch aggregated fields from the table: "vehicle_schedule.vehicle_schedule_frame" */
  readonly timetables_vehicle_schedule_vehicle_schedule_frame_aggregate: TimetablesVehicleScheduleVehicleScheduleFrameAggregate;
  /** fetch data from the table: "vehicle_schedule.vehicle_schedule_frame" using primary key columns */
  readonly timetables_vehicle_schedule_vehicle_schedule_frame_by_pk?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrame>;
  /** fetch data from the table in a streaming manner: "vehicle_schedule.vehicle_schedule_frame" */
  readonly timetables_vehicle_schedule_vehicle_schedule_frame_stream: ReadonlyArray<TimetablesVehicleScheduleVehicleScheduleFrame>;
  /** fetch data from the table: "vehicle_service.block" */
  readonly timetables_vehicle_service_block: ReadonlyArray<TimetablesVehicleServiceBlock>;
  /** fetch aggregated fields from the table: "vehicle_service.block" */
  readonly timetables_vehicle_service_block_aggregate: TimetablesVehicleServiceBlockAggregate;
  /** fetch data from the table: "vehicle_service.block" using primary key columns */
  readonly timetables_vehicle_service_block_by_pk?: Maybe<TimetablesVehicleServiceBlock>;
  /** fetch data from the table in a streaming manner: "vehicle_service.block" */
  readonly timetables_vehicle_service_block_stream: ReadonlyArray<TimetablesVehicleServiceBlock>;
  /** execute function "vehicle_service.get_timetable_versions_by_journey_pattern_ids" which returns "return_value.timetable_version" */
  readonly timetables_vehicle_service_get_timetable_versions_by_journey_pattern_ids: ReadonlyArray<TimetablesReturnValueTimetableVersion>;
  /** execute function "vehicle_service.get_timetable_versions_by_journey_pattern_ids" and query aggregates on result of table type "return_value.timetable_version" */
  readonly timetables_vehicle_service_get_timetable_versions_by_journey_pattern_ids_aggregate: TimetablesReturnValueTimetableVersionAggregate;
  /** execute function "vehicle_service.get_timetables_and_substitute_operating_days" which returns "return_value.timetable_version" */
  readonly timetables_vehicle_service_get_timetables_and_substitute_operating_days: ReadonlyArray<TimetablesReturnValueTimetableVersion>;
  /** execute function "vehicle_service.get_timetables_and_substitute_operating_days" and query aggregates on result of table type "return_value.timetable_version" */
  readonly timetables_vehicle_service_get_timetables_and_substitute_operating_days_aggregate: TimetablesReturnValueTimetableVersionAggregate;
  /** fetch data from the table: "vehicle_service.journey_patterns_in_vehicle_service" */
  readonly timetables_vehicle_service_journey_patterns_in_vehicle_service: ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleService>;
  /** fetch aggregated fields from the table: "vehicle_service.journey_patterns_in_vehicle_service" */
  readonly timetables_vehicle_service_journey_patterns_in_vehicle_service_aggregate: TimetablesVehicleServiceJourneyPatternsInVehicleServiceAggregate;
  /** fetch data from the table: "vehicle_service.journey_patterns_in_vehicle_service" using primary key columns */
  readonly timetables_vehicle_service_journey_patterns_in_vehicle_service_by_pk?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleService>;
  /** fetch data from the table in a streaming manner: "vehicle_service.journey_patterns_in_vehicle_service" */
  readonly timetables_vehicle_service_journey_patterns_in_vehicle_service_stream: ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleService>;
  /** fetch data from the table: "vehicle_service.vehicle_service" */
  readonly timetables_vehicle_service_vehicle_service: ReadonlyArray<TimetablesVehicleServiceVehicleService>;
  /** fetch aggregated fields from the table: "vehicle_service.vehicle_service" */
  readonly timetables_vehicle_service_vehicle_service_aggregate: TimetablesVehicleServiceVehicleServiceAggregate;
  /** fetch data from the table: "vehicle_service.vehicle_service" using primary key columns */
  readonly timetables_vehicle_service_vehicle_service_by_pk?: Maybe<TimetablesVehicleServiceVehicleService>;
  /** fetch data from the table in a streaming manner: "vehicle_service.vehicle_service" */
  readonly timetables_vehicle_service_vehicle_service_stream: ReadonlyArray<TimetablesVehicleServiceVehicleService>;
  /** fetch data from the table: "vehicle_type.vehicle_type" */
  readonly timetables_vehicle_type_vehicle_type: ReadonlyArray<TimetablesVehicleTypeVehicleType>;
  /** fetch aggregated fields from the table: "vehicle_type.vehicle_type" */
  readonly timetables_vehicle_type_vehicle_type_aggregate: TimetablesVehicleTypeVehicleTypeAggregate;
  /** fetch data from the table: "vehicle_type.vehicle_type" using primary key columns */
  readonly timetables_vehicle_type_vehicle_type_by_pk?: Maybe<TimetablesVehicleTypeVehicleType>;
  /** fetch data from the table in a streaming manner: "vehicle_type.vehicle_type" */
  readonly timetables_vehicle_type_vehicle_type_stream: ReadonlyArray<TimetablesVehicleTypeVehicleType>;
};


export type TimetablesTimetablesSubscriptionTimetablesJourneyPatternJourneyPatternRefArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesJourneyPatternJourneyPatternRefSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesJourneyPatternJourneyPatternRefOrderBy>>;
  where?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesJourneyPatternJourneyPatternRefAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesJourneyPatternJourneyPatternRefSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesJourneyPatternJourneyPatternRefOrderBy>>;
  where?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesJourneyPatternJourneyPatternRefByPkArgs = {
  journey_pattern_ref_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesSubscriptionTimetablesJourneyPatternJourneyPatternRefStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<TimetablesJourneyPatternJourneyPatternRefStreamCursorInput>>;
  where?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesPassingTimesTimetabledPassingTimeArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesPassingTimesTimetabledPassingTimeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesPassingTimesTimetabledPassingTimeOrderBy>>;
  where?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesPassingTimesTimetabledPassingTimeAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesPassingTimesTimetabledPassingTimeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesPassingTimesTimetabledPassingTimeOrderBy>>;
  where?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesPassingTimesTimetabledPassingTimeByPkArgs = {
  timetabled_passing_time_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesSubscriptionTimetablesPassingTimesTimetabledPassingTimeStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<TimetablesPassingTimesTimetabledPassingTimeStreamCursorInput>>;
  where?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesReturnValueTimetableVersionArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionOrderBy>>;
  where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesReturnValueTimetableVersionAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionOrderBy>>;
  where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesReturnValueTimetableVersionStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<TimetablesReturnValueTimetableVersionStreamCursorInput>>;
  where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesReturnValueVehicleScheduleArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesReturnValueVehicleScheduleSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesReturnValueVehicleScheduleOrderBy>>;
  where?: InputMaybe<TimetablesReturnValueVehicleScheduleBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesReturnValueVehicleScheduleAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesReturnValueVehicleScheduleSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesReturnValueVehicleScheduleOrderBy>>;
  where?: InputMaybe<TimetablesReturnValueVehicleScheduleBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesReturnValueVehicleScheduleStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<TimetablesReturnValueVehicleScheduleStreamCursorInput>>;
  where?: InputMaybe<TimetablesReturnValueVehicleScheduleBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesRouteDirectionArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesRouteDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesRouteDirectionOrderBy>>;
  where?: InputMaybe<TimetablesRouteDirectionBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesRouteDirectionAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesRouteDirectionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesRouteDirectionOrderBy>>;
  where?: InputMaybe<TimetablesRouteDirectionBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesRouteDirectionByPkArgs = {
  direction: Scalars['String']['input'];
};


export type TimetablesTimetablesSubscriptionTimetablesRouteDirectionStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<TimetablesRouteDirectionStreamCursorInput>>;
  where?: InputMaybe<TimetablesRouteDirectionBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesRouteTypeOfLineArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesRouteTypeOfLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesRouteTypeOfLineOrderBy>>;
  where?: InputMaybe<TimetablesRouteTypeOfLineBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesRouteTypeOfLineAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesRouteTypeOfLineSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesRouteTypeOfLineOrderBy>>;
  where?: InputMaybe<TimetablesRouteTypeOfLineBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesRouteTypeOfLineByPkArgs = {
  type_of_line: Scalars['String']['input'];
};


export type TimetablesTimetablesSubscriptionTimetablesRouteTypeOfLineStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<TimetablesRouteTypeOfLineStreamCursorInput>>;
  where?: InputMaybe<TimetablesRouteTypeOfLineBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarDayTypeArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeOrderBy>>;
  where?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarDayTypeActiveOnDayOfWeekArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekOrderBy>>;
  where?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarDayTypeActiveOnDayOfWeekAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekOrderBy>>;
  where?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarDayTypeActiveOnDayOfWeekByPkArgs = {
  day_of_week: Scalars['Int']['input'];
  day_type_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarDayTypeActiveOnDayOfWeekStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekStreamCursorInput>>;
  where?: InputMaybe<TimetablesServiceCalendarDayTypeActiveOnDayOfWeekBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarDayTypeAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeOrderBy>>;
  where?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarDayTypeByPkArgs = {
  day_type_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarDayTypeStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<TimetablesServiceCalendarDayTypeStreamCursorInput>>;
  where?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarGetActiveDayTypesForDateArgs = {
  args: TimetablesServiceCalendarGetActiveDayTypesForDateArgs;
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeOrderBy>>;
  where?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarGetActiveDayTypesForDateAggregateArgs = {
  args: TimetablesServiceCalendarGetActiveDayTypesForDateArgs;
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarDayTypeOrderBy>>;
  where?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarSubstituteOperatingDayByLineTypeArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOrderBy>>;
  where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarSubstituteOperatingDayByLineTypeAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeOrderBy>>;
  where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarSubstituteOperatingDayByLineTypeByPkArgs = {
  substitute_operating_day_by_line_type_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarSubstituteOperatingDayByLineTypeStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeStreamCursorInput>>;
  where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarSubstituteOperatingPeriodArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingPeriodSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingPeriodOrderBy>>;
  where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarSubstituteOperatingPeriodAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingPeriodSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingPeriodOrderBy>>;
  where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarSubstituteOperatingPeriodByPkArgs = {
  substitute_operating_period_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesSubscriptionTimetablesServiceCalendarSubstituteOperatingPeriodStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodStreamCursorInput>>;
  where?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesServicePatternScheduledStopPointInJourneyPatternRefArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRefOrderBy>>;
  where?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesServicePatternScheduledStopPointInJourneyPatternRefAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRefSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesServicePatternScheduledStopPointInJourneyPatternRefOrderBy>>;
  where?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesServicePatternScheduledStopPointInJourneyPatternRefByPkArgs = {
  scheduled_stop_point_in_journey_pattern_ref_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesSubscriptionTimetablesServicePatternScheduledStopPointInJourneyPatternRefStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefStreamCursorInput>>;
  where?: InputMaybe<TimetablesServicePatternScheduledStopPointInJourneyPatternRefBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleJourneyGetVehicleSchedulesOnDateArgs = {
  args: TimetablesVehicleJourneyGetVehicleSchedulesOnDateArgs;
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesReturnValueVehicleScheduleSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesReturnValueVehicleScheduleOrderBy>>;
  where?: InputMaybe<TimetablesReturnValueVehicleScheduleBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleJourneyGetVehicleSchedulesOnDateAggregateArgs = {
  args: TimetablesVehicleJourneyGetVehicleSchedulesOnDateArgs;
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesReturnValueVehicleScheduleSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesReturnValueVehicleScheduleOrderBy>>;
  where?: InputMaybe<TimetablesReturnValueVehicleScheduleBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleJourneyVehicleJourneyArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleJourneyVehicleJourneySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleJourneyVehicleJourneyOrderBy>>;
  where?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleJourneyVehicleJourneyAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleJourneyVehicleJourneySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleJourneyVehicleJourneyOrderBy>>;
  where?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleJourneyVehicleJourneyByPkArgs = {
  vehicle_journey_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleJourneyVehicleJourneyStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<TimetablesVehicleJourneyVehicleJourneyStreamCursorInput>>;
  where?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleScheduleVehicleScheduleFrameArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleScheduleVehicleScheduleFrameSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleScheduleVehicleScheduleFrameOrderBy>>;
  where?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleScheduleVehicleScheduleFrameAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleScheduleVehicleScheduleFrameSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleScheduleVehicleScheduleFrameOrderBy>>;
  where?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleScheduleVehicleScheduleFrameByPkArgs = {
  vehicle_schedule_frame_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleScheduleVehicleScheduleFrameStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameStreamCursorInput>>;
  where?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceBlockArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceBlockSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceBlockOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceBlockBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceBlockAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceBlockSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceBlockOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceBlockBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceBlockByPkArgs = {
  block_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceBlockStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<TimetablesVehicleServiceBlockStreamCursorInput>>;
  where?: InputMaybe<TimetablesVehicleServiceBlockBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceGetTimetableVersionsByJourneyPatternIdsArgs = {
  args: TimetablesVehicleServiceGetTimetableVersionsByJourneyPatternIdsArgs;
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionOrderBy>>;
  where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceGetTimetableVersionsByJourneyPatternIdsAggregateArgs = {
  args: TimetablesVehicleServiceGetTimetableVersionsByJourneyPatternIdsArgs;
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionOrderBy>>;
  where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceGetTimetablesAndSubstituteOperatingDaysArgs = {
  args: TimetablesVehicleServiceGetTimetablesAndSubstituteOperatingDaysArgs;
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionOrderBy>>;
  where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceGetTimetablesAndSubstituteOperatingDaysAggregateArgs = {
  args: TimetablesVehicleServiceGetTimetablesAndSubstituteOperatingDaysArgs;
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesReturnValueTimetableVersionOrderBy>>;
  where?: InputMaybe<TimetablesReturnValueTimetableVersionBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceJourneyPatternsInVehicleServiceArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleServiceOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceJourneyPatternsInVehicleServiceAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleServiceOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceJourneyPatternsInVehicleServiceByPkArgs = {
  journey_pattern_id: Scalars['uuid']['input'];
  vehicle_service_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceJourneyPatternsInVehicleServiceStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceStreamCursorInput>>;
  where?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceVehicleServiceArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceVehicleServiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceVehicleServiceOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceVehicleServiceAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceVehicleServiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceVehicleServiceOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceVehicleServiceByPkArgs = {
  vehicle_service_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleServiceVehicleServiceStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<TimetablesVehicleServiceVehicleServiceStreamCursorInput>>;
  where?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleTypeVehicleTypeArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleTypeVehicleTypeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleTypeVehicleTypeOrderBy>>;
  where?: InputMaybe<TimetablesVehicleTypeVehicleTypeBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleTypeVehicleTypeAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleTypeVehicleTypeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleTypeVehicleTypeOrderBy>>;
  where?: InputMaybe<TimetablesVehicleTypeVehicleTypeBoolExp>;
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleTypeVehicleTypeByPkArgs = {
  vehicle_type_id: Scalars['uuid']['input'];
};


export type TimetablesTimetablesSubscriptionTimetablesVehicleTypeVehicleTypeStreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: ReadonlyArray<InputMaybe<TimetablesVehicleTypeVehicleTypeStreamCursorInput>>;
  where?: InputMaybe<TimetablesVehicleTypeVehicleTypeBoolExp>;
};

export type TimetablesVehicleJourneyGetVehicleSchedulesOnDateArgs = {
  readonly journey_pattern_uuid?: InputMaybe<Scalars['uuid']['input']>;
  readonly observation_date?: InputMaybe<Scalars['date']['input']>;
};

/** The planned movement of a public transport vehicle on a DAY TYPE from the start point to the end point of a JOURNEY PATTERN on a specified ROUTE. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:1:1:831  */
export type TimetablesVehicleJourneyVehicleJourney = {
  readonly __typename?: 'timetables_vehicle_journey_vehicle_journey';
  /** An object relationship */
  readonly block: TimetablesVehicleServiceBlock;
  /** The BLOCK to which this VEHICLE JOURNEY belongs */
  readonly block_id: Scalars['uuid']['output'];
  /** The contract number for this vehicle journey. */
  readonly contract_number: Scalars['String']['output'];
  /** Displayed name of the journey. */
  readonly displayed_name?: Maybe<Scalars['String']['output']>;
  /** A computed field, executes function "vehicle_journey.vehicle_journey_end_time" */
  readonly end_time: Scalars['interval']['output'];
  /** Is the journey a backup journey. */
  readonly is_backup_journey: Scalars['Boolean']['output'];
  /** Is the journey an extra journey. */
  readonly is_extra_journey: Scalars['Boolean']['output'];
  /** It is required to use the same vehicle type as required in vehicle service. */
  readonly is_vehicle_type_mandatory: Scalars['Boolean']['output'];
  /** Name that user can give to the vehicle journey. */
  readonly journey_name_i18n?: Maybe<Scalars['jsonb']['output']>;
  /** An object relationship */
  readonly journey_pattern_ref: TimetablesJourneyPatternJourneyPatternRef;
  /** The JOURNEY PATTERN on which the VEHICLE JOURNEY travels */
  readonly journey_pattern_ref_id: Scalars['uuid']['output'];
  /** STANDARD | DRY_RUN | SERVICE_JOURNEY */
  readonly journey_type: Scalars['String']['output'];
  /** LAYOVER TIMEs describe a certain time allowance that may be given at the end of each VEHICLE JOURNEY, before starting the next one, to compensate delays or for other purposes (e.g. rest time for the driver). This “layover time” can be regarded as a buffer time, which may or may not be actually consumed in real time operation. */
  readonly layover_time?: Maybe<Scalars['interval']['output']>;
  /** A computed field, executes function "vehicle_journey.vehicle_journey_start_time" */
  readonly start_time: Scalars['interval']['output'];
  /** An array relationship */
  readonly timetabled_passing_times: ReadonlyArray<TimetablesPassingTimesTimetabledPassingTime>;
  /** An aggregate relationship */
  readonly timetabled_passing_times_aggregate: TimetablesPassingTimesTimetabledPassingTimeAggregate;
  /** Turnaround time is the time taken by a vehicle to proceed from the end of a ROUTE to the start of another. */
  readonly turnaround_time?: Maybe<Scalars['interval']['output']>;
  readonly vehicle_journey_id: Scalars['uuid']['output'];
};


/** The planned movement of a public transport vehicle on a DAY TYPE from the start point to the end point of a JOURNEY PATTERN on a specified ROUTE. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:1:1:831  */
export type TimetablesVehicleJourneyVehicleJourneyJourneyNameI18nArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** The planned movement of a public transport vehicle on a DAY TYPE from the start point to the end point of a JOURNEY PATTERN on a specified ROUTE. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:1:1:831  */
export type TimetablesVehicleJourneyVehicleJourneyTimetabledPassingTimesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesPassingTimesTimetabledPassingTimeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesPassingTimesTimetabledPassingTimeOrderBy>>;
  where?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
};


/** The planned movement of a public transport vehicle on a DAY TYPE from the start point to the end point of a JOURNEY PATTERN on a specified ROUTE. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:1:1:831  */
export type TimetablesVehicleJourneyVehicleJourneyTimetabledPassingTimesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesPassingTimesTimetabledPassingTimeSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesPassingTimesTimetabledPassingTimeOrderBy>>;
  where?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
};

/** aggregated selection of "vehicle_journey.vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneyAggregate = {
  readonly __typename?: 'timetables_vehicle_journey_vehicle_journey_aggregate';
  readonly aggregate?: Maybe<TimetablesVehicleJourneyVehicleJourneyAggregateFields>;
  readonly nodes: ReadonlyArray<TimetablesVehicleJourneyVehicleJourney>;
};

/** aggregate fields of "vehicle_journey.vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneyAggregateFields = {
  readonly __typename?: 'timetables_vehicle_journey_vehicle_journey_aggregate_fields';
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<TimetablesVehicleJourneyVehicleJourneyMaxFields>;
  readonly min?: Maybe<TimetablesVehicleJourneyVehicleJourneyMinFields>;
};


/** aggregate fields of "vehicle_journey.vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneyAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<TimetablesVehicleJourneyVehicleJourneySelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "vehicle_journey.vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneyAggregateOrderBy = {
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyMaxOrderBy>;
  readonly min?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyMinOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type TimetablesVehicleJourneyVehicleJourneyAppendInput = {
  /** Name that user can give to the vehicle journey. */
  readonly journey_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "vehicle_journey.vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneyArrRelInsertInput = {
  readonly data: ReadonlyArray<TimetablesVehicleJourneyVehicleJourneyInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyOnConflict>;
};

/** Boolean expression to filter rows from the table "vehicle_journey.vehicle_journey". All fields are combined with a logical 'AND'. */
export type TimetablesVehicleJourneyVehicleJourneyBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<TimetablesVehicleJourneyVehicleJourneyBoolExp>>;
  readonly _not?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<TimetablesVehicleJourneyVehicleJourneyBoolExp>>;
  readonly block?: InputMaybe<TimetablesVehicleServiceBlockBoolExp>;
  readonly block_id?: InputMaybe<UuidComparisonExp>;
  readonly contract_number?: InputMaybe<StringComparisonExp>;
  readonly displayed_name?: InputMaybe<StringComparisonExp>;
  readonly end_time?: InputMaybe<StringComparisonExp>;
  readonly is_backup_journey?: InputMaybe<BooleanComparisonExp>;
  readonly is_extra_journey?: InputMaybe<BooleanComparisonExp>;
  readonly is_vehicle_type_mandatory?: InputMaybe<BooleanComparisonExp>;
  readonly journey_name_i18n?: InputMaybe<JsonbComparisonExp>;
  readonly journey_pattern_ref?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefBoolExp>;
  readonly journey_pattern_ref_id?: InputMaybe<UuidComparisonExp>;
  readonly journey_type?: InputMaybe<StringComparisonExp>;
  readonly layover_time?: InputMaybe<IntervalComparisonExp>;
  readonly start_time?: InputMaybe<StringComparisonExp>;
  readonly timetabled_passing_times?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeBoolExp>;
  readonly timetabled_passing_times_aggregate?: InputMaybe<PassingTimesTimetabledPassingTimeAggregateBoolExp>;
  readonly turnaround_time?: InputMaybe<IntervalComparisonExp>;
  readonly vehicle_journey_id?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "vehicle_journey.vehicle_journey" */
export enum TimetablesVehicleJourneyVehicleJourneyConstraint {
  /** unique or primary key constraint on columns "vehicle_journey_id" */
  VehicleJourneyPkey = 'vehicle_journey_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type TimetablesVehicleJourneyVehicleJourneyDeleteAtPathInput = {
  /** Name that user can give to the vehicle journey. */
  readonly journey_name_i18n?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type TimetablesVehicleJourneyVehicleJourneyDeleteElemInput = {
  /** Name that user can give to the vehicle journey. */
  readonly journey_name_i18n?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type TimetablesVehicleJourneyVehicleJourneyDeleteKeyInput = {
  /** Name that user can give to the vehicle journey. */
  readonly journey_name_i18n?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "vehicle_journey.vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneyInsertInput = {
  readonly block?: InputMaybe<TimetablesVehicleServiceBlockObjRelInsertInput>;
  /** The BLOCK to which this VEHICLE JOURNEY belongs */
  readonly block_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The contract number for this vehicle journey. */
  readonly contract_number?: InputMaybe<Scalars['String']['input']>;
  /** Displayed name of the journey. */
  readonly displayed_name?: InputMaybe<Scalars['String']['input']>;
  /** Is the journey a backup journey. */
  readonly is_backup_journey?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is the journey an extra journey. */
  readonly is_extra_journey?: InputMaybe<Scalars['Boolean']['input']>;
  /** It is required to use the same vehicle type as required in vehicle service. */
  readonly is_vehicle_type_mandatory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Name that user can give to the vehicle journey. */
  readonly journey_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  readonly journey_pattern_ref?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefObjRelInsertInput>;
  /** The JOURNEY PATTERN on which the VEHICLE JOURNEY travels */
  readonly journey_pattern_ref_id?: InputMaybe<Scalars['uuid']['input']>;
  /** STANDARD | DRY_RUN | SERVICE_JOURNEY */
  readonly journey_type?: InputMaybe<Scalars['String']['input']>;
  /** LAYOVER TIMEs describe a certain time allowance that may be given at the end of each VEHICLE JOURNEY, before starting the next one, to compensate delays or for other purposes (e.g. rest time for the driver). This “layover time” can be regarded as a buffer time, which may or may not be actually consumed in real time operation. */
  readonly layover_time?: InputMaybe<Scalars['interval']['input']>;
  readonly timetabled_passing_times?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeArrRelInsertInput>;
  /** Turnaround time is the time taken by a vehicle to proceed from the end of a ROUTE to the start of another. */
  readonly turnaround_time?: InputMaybe<Scalars['interval']['input']>;
  readonly vehicle_journey_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type TimetablesVehicleJourneyVehicleJourneyMaxFields = {
  readonly __typename?: 'timetables_vehicle_journey_vehicle_journey_max_fields';
  /** The BLOCK to which this VEHICLE JOURNEY belongs */
  readonly block_id?: Maybe<Scalars['uuid']['output']>;
  /** The contract number for this vehicle journey. */
  readonly contract_number?: Maybe<Scalars['String']['output']>;
  /** Displayed name of the journey. */
  readonly displayed_name?: Maybe<Scalars['String']['output']>;
  /** A computed field, executes function "vehicle_journey.vehicle_journey_end_time" */
  readonly end_time?: Maybe<Scalars['String']['output']>;
  /** The JOURNEY PATTERN on which the VEHICLE JOURNEY travels */
  readonly journey_pattern_ref_id?: Maybe<Scalars['uuid']['output']>;
  /** STANDARD | DRY_RUN | SERVICE_JOURNEY */
  readonly journey_type?: Maybe<Scalars['String']['output']>;
  /** A computed field, executes function "vehicle_journey.vehicle_journey_start_time" */
  readonly start_time?: Maybe<Scalars['String']['output']>;
  readonly vehicle_journey_id?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "vehicle_journey.vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneyMaxOrderBy = {
  /** The BLOCK to which this VEHICLE JOURNEY belongs */
  readonly block_id?: InputMaybe<OrderBy>;
  /** The contract number for this vehicle journey. */
  readonly contract_number?: InputMaybe<OrderBy>;
  /** Displayed name of the journey. */
  readonly displayed_name?: InputMaybe<OrderBy>;
  /** The JOURNEY PATTERN on which the VEHICLE JOURNEY travels */
  readonly journey_pattern_ref_id?: InputMaybe<OrderBy>;
  /** STANDARD | DRY_RUN | SERVICE_JOURNEY */
  readonly journey_type?: InputMaybe<OrderBy>;
  readonly vehicle_journey_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type TimetablesVehicleJourneyVehicleJourneyMinFields = {
  readonly __typename?: 'timetables_vehicle_journey_vehicle_journey_min_fields';
  /** The BLOCK to which this VEHICLE JOURNEY belongs */
  readonly block_id?: Maybe<Scalars['uuid']['output']>;
  /** The contract number for this vehicle journey. */
  readonly contract_number?: Maybe<Scalars['String']['output']>;
  /** Displayed name of the journey. */
  readonly displayed_name?: Maybe<Scalars['String']['output']>;
  /** A computed field, executes function "vehicle_journey.vehicle_journey_end_time" */
  readonly end_time?: Maybe<Scalars['String']['output']>;
  /** The JOURNEY PATTERN on which the VEHICLE JOURNEY travels */
  readonly journey_pattern_ref_id?: Maybe<Scalars['uuid']['output']>;
  /** STANDARD | DRY_RUN | SERVICE_JOURNEY */
  readonly journey_type?: Maybe<Scalars['String']['output']>;
  /** A computed field, executes function "vehicle_journey.vehicle_journey_start_time" */
  readonly start_time?: Maybe<Scalars['String']['output']>;
  readonly vehicle_journey_id?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "vehicle_journey.vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneyMinOrderBy = {
  /** The BLOCK to which this VEHICLE JOURNEY belongs */
  readonly block_id?: InputMaybe<OrderBy>;
  /** The contract number for this vehicle journey. */
  readonly contract_number?: InputMaybe<OrderBy>;
  /** Displayed name of the journey. */
  readonly displayed_name?: InputMaybe<OrderBy>;
  /** The JOURNEY PATTERN on which the VEHICLE JOURNEY travels */
  readonly journey_pattern_ref_id?: InputMaybe<OrderBy>;
  /** STANDARD | DRY_RUN | SERVICE_JOURNEY */
  readonly journey_type?: InputMaybe<OrderBy>;
  readonly vehicle_journey_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "vehicle_journey.vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneyMutationResponse = {
  readonly __typename?: 'timetables_vehicle_journey_vehicle_journey_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<TimetablesVehicleJourneyVehicleJourney>;
};

/** input type for inserting object relation for remote table "vehicle_journey.vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneyObjRelInsertInput = {
  readonly data: TimetablesVehicleJourneyVehicleJourneyInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyOnConflict>;
};

/** on_conflict condition type for table "vehicle_journey.vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneyOnConflict = {
  readonly constraint: TimetablesVehicleJourneyVehicleJourneyConstraint;
  readonly update_columns?: ReadonlyArray<TimetablesVehicleJourneyVehicleJourneyUpdateColumn>;
  readonly where?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
};

/** Ordering options when selecting data from "vehicle_journey.vehicle_journey". */
export type TimetablesVehicleJourneyVehicleJourneyOrderBy = {
  readonly block?: InputMaybe<TimetablesVehicleServiceBlockOrderBy>;
  readonly block_id?: InputMaybe<OrderBy>;
  readonly contract_number?: InputMaybe<OrderBy>;
  readonly displayed_name?: InputMaybe<OrderBy>;
  readonly end_time?: InputMaybe<OrderBy>;
  readonly is_backup_journey?: InputMaybe<OrderBy>;
  readonly is_extra_journey?: InputMaybe<OrderBy>;
  readonly is_vehicle_type_mandatory?: InputMaybe<OrderBy>;
  readonly journey_name_i18n?: InputMaybe<OrderBy>;
  readonly journey_pattern_ref?: InputMaybe<TimetablesJourneyPatternJourneyPatternRefOrderBy>;
  readonly journey_pattern_ref_id?: InputMaybe<OrderBy>;
  readonly journey_type?: InputMaybe<OrderBy>;
  readonly layover_time?: InputMaybe<OrderBy>;
  readonly start_time?: InputMaybe<OrderBy>;
  readonly timetabled_passing_times_aggregate?: InputMaybe<TimetablesPassingTimesTimetabledPassingTimeAggregateOrderBy>;
  readonly turnaround_time?: InputMaybe<OrderBy>;
  readonly vehicle_journey_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: vehicle_journey.vehicle_journey */
export type TimetablesVehicleJourneyVehicleJourneyPkColumnsInput = {
  readonly vehicle_journey_id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type TimetablesVehicleJourneyVehicleJourneyPrependInput = {
  /** Name that user can give to the vehicle journey. */
  readonly journey_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "vehicle_journey.vehicle_journey" */
export enum TimetablesVehicleJourneyVehicleJourneySelectColumn {
  /** column name */
  BlockId = 'block_id',
  /** column name */
  ContractNumber = 'contract_number',
  /** column name */
  DisplayedName = 'displayed_name',
  /** column name */
  IsBackupJourney = 'is_backup_journey',
  /** column name */
  IsExtraJourney = 'is_extra_journey',
  /** column name */
  IsVehicleTypeMandatory = 'is_vehicle_type_mandatory',
  /** column name */
  JourneyNameI18n = 'journey_name_i18n',
  /** column name */
  JourneyPatternRefId = 'journey_pattern_ref_id',
  /** column name */
  JourneyType = 'journey_type',
  /** column name */
  LayoverTime = 'layover_time',
  /** column name */
  TurnaroundTime = 'turnaround_time',
  /** column name */
  VehicleJourneyId = 'vehicle_journey_id'
}

/** select "vehicle_journey_vehicle_journey_aggregate_bool_exp_bool_and_arguments_columns" columns of table "vehicle_journey.vehicle_journey" */
export enum TimetablesVehicleJourneyVehicleJourneySelectColumnVehicleJourneyVehicleJourneyAggregateBoolExpBoolAndArgumentsColumns {
  /** column name */
  IsBackupJourney = 'is_backup_journey',
  /** column name */
  IsExtraJourney = 'is_extra_journey',
  /** column name */
  IsVehicleTypeMandatory = 'is_vehicle_type_mandatory'
}

/** select "vehicle_journey_vehicle_journey_aggregate_bool_exp_bool_or_arguments_columns" columns of table "vehicle_journey.vehicle_journey" */
export enum TimetablesVehicleJourneyVehicleJourneySelectColumnVehicleJourneyVehicleJourneyAggregateBoolExpBoolOrArgumentsColumns {
  /** column name */
  IsBackupJourney = 'is_backup_journey',
  /** column name */
  IsExtraJourney = 'is_extra_journey',
  /** column name */
  IsVehicleTypeMandatory = 'is_vehicle_type_mandatory'
}

/** input type for updating data in table "vehicle_journey.vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneySetInput = {
  /** The BLOCK to which this VEHICLE JOURNEY belongs */
  readonly block_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The contract number for this vehicle journey. */
  readonly contract_number?: InputMaybe<Scalars['String']['input']>;
  /** Displayed name of the journey. */
  readonly displayed_name?: InputMaybe<Scalars['String']['input']>;
  /** Is the journey a backup journey. */
  readonly is_backup_journey?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is the journey an extra journey. */
  readonly is_extra_journey?: InputMaybe<Scalars['Boolean']['input']>;
  /** It is required to use the same vehicle type as required in vehicle service. */
  readonly is_vehicle_type_mandatory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Name that user can give to the vehicle journey. */
  readonly journey_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  /** The JOURNEY PATTERN on which the VEHICLE JOURNEY travels */
  readonly journey_pattern_ref_id?: InputMaybe<Scalars['uuid']['input']>;
  /** STANDARD | DRY_RUN | SERVICE_JOURNEY */
  readonly journey_type?: InputMaybe<Scalars['String']['input']>;
  /** LAYOVER TIMEs describe a certain time allowance that may be given at the end of each VEHICLE JOURNEY, before starting the next one, to compensate delays or for other purposes (e.g. rest time for the driver). This “layover time” can be regarded as a buffer time, which may or may not be actually consumed in real time operation. */
  readonly layover_time?: InputMaybe<Scalars['interval']['input']>;
  /** Turnaround time is the time taken by a vehicle to proceed from the end of a ROUTE to the start of another. */
  readonly turnaround_time?: InputMaybe<Scalars['interval']['input']>;
  readonly vehicle_journey_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "vehicle_journey_vehicle_journey" */
export type TimetablesVehicleJourneyVehicleJourneyStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: TimetablesVehicleJourneyVehicleJourneyStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesVehicleJourneyVehicleJourneyStreamCursorValueInput = {
  /** The BLOCK to which this VEHICLE JOURNEY belongs */
  readonly block_id?: InputMaybe<Scalars['uuid']['input']>;
  /** The contract number for this vehicle journey. */
  readonly contract_number?: InputMaybe<Scalars['String']['input']>;
  /** Displayed name of the journey. */
  readonly displayed_name?: InputMaybe<Scalars['String']['input']>;
  /** Is the journey a backup journey. */
  readonly is_backup_journey?: InputMaybe<Scalars['Boolean']['input']>;
  /** Is the journey an extra journey. */
  readonly is_extra_journey?: InputMaybe<Scalars['Boolean']['input']>;
  /** It is required to use the same vehicle type as required in vehicle service. */
  readonly is_vehicle_type_mandatory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Name that user can give to the vehicle journey. */
  readonly journey_name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  /** The JOURNEY PATTERN on which the VEHICLE JOURNEY travels */
  readonly journey_pattern_ref_id?: InputMaybe<Scalars['uuid']['input']>;
  /** STANDARD | DRY_RUN | SERVICE_JOURNEY */
  readonly journey_type?: InputMaybe<Scalars['String']['input']>;
  /** LAYOVER TIMEs describe a certain time allowance that may be given at the end of each VEHICLE JOURNEY, before starting the next one, to compensate delays or for other purposes (e.g. rest time for the driver). This “layover time” can be regarded as a buffer time, which may or may not be actually consumed in real time operation. */
  readonly layover_time?: InputMaybe<Scalars['interval']['input']>;
  /** Turnaround time is the time taken by a vehicle to proceed from the end of a ROUTE to the start of another. */
  readonly turnaround_time?: InputMaybe<Scalars['interval']['input']>;
  readonly vehicle_journey_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "vehicle_journey.vehicle_journey" */
export enum TimetablesVehicleJourneyVehicleJourneyUpdateColumn {
  /** column name */
  BlockId = 'block_id',
  /** column name */
  ContractNumber = 'contract_number',
  /** column name */
  DisplayedName = 'displayed_name',
  /** column name */
  IsBackupJourney = 'is_backup_journey',
  /** column name */
  IsExtraJourney = 'is_extra_journey',
  /** column name */
  IsVehicleTypeMandatory = 'is_vehicle_type_mandatory',
  /** column name */
  JourneyNameI18n = 'journey_name_i18n',
  /** column name */
  JourneyPatternRefId = 'journey_pattern_ref_id',
  /** column name */
  JourneyType = 'journey_type',
  /** column name */
  LayoverTime = 'layover_time',
  /** column name */
  TurnaroundTime = 'turnaround_time',
  /** column name */
  VehicleJourneyId = 'vehicle_journey_id'
}

export type TimetablesVehicleJourneyVehicleJourneyUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  readonly _append?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  readonly _delete_at_path?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  readonly _delete_elem?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  readonly _delete_key?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  readonly _prepend?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<TimetablesVehicleJourneyVehicleJourneySetInput>;
  /** filter the rows which have to be updated */
  readonly where: TimetablesVehicleJourneyVehicleJourneyBoolExp;
};

/** A coherent set of BLOCKS, COMPOUND BLOCKs, COURSEs of JOURNEY and VEHICLE SCHEDULEs to which the same set of VALIDITY CONDITIONs have been assigned. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:7:2:993  */
export type TimetablesVehicleScheduleVehicleScheduleFrame = {
  readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame';
  /** Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus. */
  readonly booking_description_i18n?: Maybe<Scalars['jsonb']['output']>;
  /** Booking label for the vehicle schedule frame. Comes from BookingRecord vsc_booking field from Hastus. */
  readonly booking_label: Scalars['String']['output'];
  readonly created_at: Scalars['timestamptz']['output'];
  /** Label for the vehicle schedule frame. Comes from BookingRecord vsc_name field from Hastus. */
  readonly label: Scalars['String']['output'];
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  readonly name_i18n?: Maybe<Scalars['jsonb']['output']>;
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  readonly priority: Scalars['Int']['output'];
  /** OPERATING DAY when the VEHICLE SCHEDULE FRAME validity ends (inclusive). Null if always will be valid. */
  readonly validity_end: Scalars['date']['output'];
  /**
   *
   * A denormalized column for actual daterange when vehicle schedule frame is valid,
   * that is, a closed date range [validity_start, validity_end].
   * Added to make working with PostgreSQL functions easier:
   * they typically expect ranges to be half closed.
   */
  readonly validity_range: Scalars['daterange']['output'];
  /** OPERATING DAY when the VEHICLE SCHEDULE FRAME validity starts (inclusive). Null if always has been valid. */
  readonly validity_start: Scalars['date']['output'];
  readonly vehicle_schedule_frame_id: Scalars['uuid']['output'];
  /** An array relationship */
  readonly vehicle_services: ReadonlyArray<TimetablesVehicleServiceVehicleService>;
  /** An aggregate relationship */
  readonly vehicle_services_aggregate: TimetablesVehicleServiceVehicleServiceAggregate;
};


/** A coherent set of BLOCKS, COMPOUND BLOCKs, COURSEs of JOURNEY and VEHICLE SCHEDULEs to which the same set of VALIDITY CONDITIONs have been assigned. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:7:2:993  */
export type TimetablesVehicleScheduleVehicleScheduleFrameBookingDescriptionI18nArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** A coherent set of BLOCKS, COMPOUND BLOCKs, COURSEs of JOURNEY and VEHICLE SCHEDULEs to which the same set of VALIDITY CONDITIONs have been assigned. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:7:2:993  */
export type TimetablesVehicleScheduleVehicleScheduleFrameNameI18nArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** A coherent set of BLOCKS, COMPOUND BLOCKs, COURSEs of JOURNEY and VEHICLE SCHEDULEs to which the same set of VALIDITY CONDITIONs have been assigned. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:7:2:993  */
export type TimetablesVehicleScheduleVehicleScheduleFrameVehicleServicesArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceVehicleServiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceVehicleServiceOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
};


/** A coherent set of BLOCKS, COMPOUND BLOCKs, COURSEs of JOURNEY and VEHICLE SCHEDULEs to which the same set of VALIDITY CONDITIONs have been assigned. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:7:2:993  */
export type TimetablesVehicleScheduleVehicleScheduleFrameVehicleServicesAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceVehicleServiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceVehicleServiceOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
};

/** aggregated selection of "vehicle_schedule.vehicle_schedule_frame" */
export type TimetablesVehicleScheduleVehicleScheduleFrameAggregate = {
  readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_aggregate';
  readonly aggregate?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameAggregateFields>;
  readonly nodes: ReadonlyArray<TimetablesVehicleScheduleVehicleScheduleFrame>;
};

/** aggregate fields of "vehicle_schedule.vehicle_schedule_frame" */
export type TimetablesVehicleScheduleVehicleScheduleFrameAggregateFields = {
  readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_aggregate_fields';
  readonly avg?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameMaxFields>;
  readonly min?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameMinFields>;
  readonly stddev?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameStddevFields>;
  readonly stddev_pop?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameStddevPopFields>;
  readonly stddev_samp?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameStddevSampFields>;
  readonly sum?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameSumFields>;
  readonly var_pop?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameVarPopFields>;
  readonly var_samp?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameVarSampFields>;
  readonly variance?: Maybe<TimetablesVehicleScheduleVehicleScheduleFrameVarianceFields>;
};


/** aggregate fields of "vehicle_schedule.vehicle_schedule_frame" */
export type TimetablesVehicleScheduleVehicleScheduleFrameAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<TimetablesVehicleScheduleVehicleScheduleFrameSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type TimetablesVehicleScheduleVehicleScheduleFrameAppendInput = {
  /** Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus. */
  readonly booking_description_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  readonly name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type TimetablesVehicleScheduleVehicleScheduleFrameAvgFields = {
  readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_avg_fields';
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "vehicle_schedule.vehicle_schedule_frame". All fields are combined with a logical 'AND'. */
export type TimetablesVehicleScheduleVehicleScheduleFrameBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<TimetablesVehicleScheduleVehicleScheduleFrameBoolExp>>;
  readonly _not?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<TimetablesVehicleScheduleVehicleScheduleFrameBoolExp>>;
  readonly booking_description_i18n?: InputMaybe<JsonbComparisonExp>;
  readonly booking_label?: InputMaybe<StringComparisonExp>;
  readonly created_at?: InputMaybe<TimestamptzComparisonExp>;
  readonly label?: InputMaybe<StringComparisonExp>;
  readonly name_i18n?: InputMaybe<JsonbComparisonExp>;
  readonly priority?: InputMaybe<IntComparisonExp>;
  readonly validity_end?: InputMaybe<DateComparisonExp>;
  readonly validity_range?: InputMaybe<DaterangeComparisonExp>;
  readonly validity_start?: InputMaybe<DateComparisonExp>;
  readonly vehicle_schedule_frame_id?: InputMaybe<UuidComparisonExp>;
  readonly vehicle_services?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
  readonly vehicle_services_aggregate?: InputMaybe<VehicleServiceVehicleServiceAggregateBoolExp>;
};

/** unique or primary key constraints on table "vehicle_schedule.vehicle_schedule_frame" */
export enum TimetablesVehicleScheduleVehicleScheduleFrameConstraint {
  /** unique or primary key constraint on columns "vehicle_schedule_frame_id" */
  VehicleScheduleFramePkey = 'vehicle_schedule_frame_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type TimetablesVehicleScheduleVehicleScheduleFrameDeleteAtPathInput = {
  /** Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus. */
  readonly booking_description_i18n?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  readonly name_i18n?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type TimetablesVehicleScheduleVehicleScheduleFrameDeleteElemInput = {
  /** Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus. */
  readonly booking_description_i18n?: InputMaybe<Scalars['Int']['input']>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  readonly name_i18n?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type TimetablesVehicleScheduleVehicleScheduleFrameDeleteKeyInput = {
  /** Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus. */
  readonly booking_description_i18n?: InputMaybe<Scalars['String']['input']>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  readonly name_i18n?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "vehicle_schedule.vehicle_schedule_frame" */
export type TimetablesVehicleScheduleVehicleScheduleFrameIncInput = {
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "vehicle_schedule.vehicle_schedule_frame" */
export type TimetablesVehicleScheduleVehicleScheduleFrameInsertInput = {
  /** Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus. */
  readonly booking_description_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  /** Booking label for the vehicle schedule frame. Comes from BookingRecord vsc_booking field from Hastus. */
  readonly booking_label?: InputMaybe<Scalars['String']['input']>;
  readonly created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Label for the vehicle schedule frame. Comes from BookingRecord vsc_name field from Hastus. */
  readonly label?: InputMaybe<Scalars['String']['input']>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  readonly name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<Scalars['Int']['input']>;
  /** OPERATING DAY when the VEHICLE SCHEDULE FRAME validity ends (inclusive). Null if always will be valid. */
  readonly validity_end?: InputMaybe<Scalars['date']['input']>;
  /** OPERATING DAY when the VEHICLE SCHEDULE FRAME validity starts (inclusive). Null if always has been valid. */
  readonly validity_start?: InputMaybe<Scalars['date']['input']>;
  readonly vehicle_schedule_frame_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly vehicle_services?: InputMaybe<TimetablesVehicleServiceVehicleServiceArrRelInsertInput>;
};

/** aggregate max on columns */
export type TimetablesVehicleScheduleVehicleScheduleFrameMaxFields = {
  readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_max_fields';
  /** Booking label for the vehicle schedule frame. Comes from BookingRecord vsc_booking field from Hastus. */
  readonly booking_label?: Maybe<Scalars['String']['output']>;
  readonly created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Label for the vehicle schedule frame. Comes from BookingRecord vsc_name field from Hastus. */
  readonly label?: Maybe<Scalars['String']['output']>;
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Int']['output']>;
  /** OPERATING DAY when the VEHICLE SCHEDULE FRAME validity ends (inclusive). Null if always will be valid. */
  readonly validity_end?: Maybe<Scalars['date']['output']>;
  /** OPERATING DAY when the VEHICLE SCHEDULE FRAME validity starts (inclusive). Null if always has been valid. */
  readonly validity_start?: Maybe<Scalars['date']['output']>;
  readonly vehicle_schedule_frame_id?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type TimetablesVehicleScheduleVehicleScheduleFrameMinFields = {
  readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_min_fields';
  /** Booking label for the vehicle schedule frame. Comes from BookingRecord vsc_booking field from Hastus. */
  readonly booking_label?: Maybe<Scalars['String']['output']>;
  readonly created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** Label for the vehicle schedule frame. Comes from BookingRecord vsc_name field from Hastus. */
  readonly label?: Maybe<Scalars['String']['output']>;
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Int']['output']>;
  /** OPERATING DAY when the VEHICLE SCHEDULE FRAME validity ends (inclusive). Null if always will be valid. */
  readonly validity_end?: Maybe<Scalars['date']['output']>;
  /** OPERATING DAY when the VEHICLE SCHEDULE FRAME validity starts (inclusive). Null if always has been valid. */
  readonly validity_start?: Maybe<Scalars['date']['output']>;
  readonly vehicle_schedule_frame_id?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "vehicle_schedule.vehicle_schedule_frame" */
export type TimetablesVehicleScheduleVehicleScheduleFrameMutationResponse = {
  readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<TimetablesVehicleScheduleVehicleScheduleFrame>;
};

/** input type for inserting object relation for remote table "vehicle_schedule.vehicle_schedule_frame" */
export type TimetablesVehicleScheduleVehicleScheduleFrameObjRelInsertInput = {
  readonly data: TimetablesVehicleScheduleVehicleScheduleFrameInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameOnConflict>;
};

/** on_conflict condition type for table "vehicle_schedule.vehicle_schedule_frame" */
export type TimetablesVehicleScheduleVehicleScheduleFrameOnConflict = {
  readonly constraint: TimetablesVehicleScheduleVehicleScheduleFrameConstraint;
  readonly update_columns?: ReadonlyArray<TimetablesVehicleScheduleVehicleScheduleFrameUpdateColumn>;
  readonly where?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameBoolExp>;
};

/** Ordering options when selecting data from "vehicle_schedule.vehicle_schedule_frame". */
export type TimetablesVehicleScheduleVehicleScheduleFrameOrderBy = {
  readonly booking_description_i18n?: InputMaybe<OrderBy>;
  readonly booking_label?: InputMaybe<OrderBy>;
  readonly created_at?: InputMaybe<OrderBy>;
  readonly label?: InputMaybe<OrderBy>;
  readonly name_i18n?: InputMaybe<OrderBy>;
  readonly priority?: InputMaybe<OrderBy>;
  readonly validity_end?: InputMaybe<OrderBy>;
  readonly validity_range?: InputMaybe<OrderBy>;
  readonly validity_start?: InputMaybe<OrderBy>;
  readonly vehicle_schedule_frame_id?: InputMaybe<OrderBy>;
  readonly vehicle_services_aggregate?: InputMaybe<TimetablesVehicleServiceVehicleServiceAggregateOrderBy>;
};

/** primary key columns input for table: vehicle_schedule.vehicle_schedule_frame */
export type TimetablesVehicleScheduleVehicleScheduleFramePkColumnsInput = {
  readonly vehicle_schedule_frame_id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type TimetablesVehicleScheduleVehicleScheduleFramePrependInput = {
  /** Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus. */
  readonly booking_description_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  readonly name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "vehicle_schedule.vehicle_schedule_frame" */
export enum TimetablesVehicleScheduleVehicleScheduleFrameSelectColumn {
  /** column name */
  BookingDescriptionI18n = 'booking_description_i18n',
  /** column name */
  BookingLabel = 'booking_label',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Label = 'label',
  /** column name */
  NameI18n = 'name_i18n',
  /** column name */
  Priority = 'priority',
  /** column name */
  ValidityEnd = 'validity_end',
  /** column name */
  ValidityRange = 'validity_range',
  /** column name */
  ValidityStart = 'validity_start',
  /** column name */
  VehicleScheduleFrameId = 'vehicle_schedule_frame_id'
}

/** input type for updating data in table "vehicle_schedule.vehicle_schedule_frame" */
export type TimetablesVehicleScheduleVehicleScheduleFrameSetInput = {
  /** Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus. */
  readonly booking_description_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  /** Booking label for the vehicle schedule frame. Comes from BookingRecord vsc_booking field from Hastus. */
  readonly booking_label?: InputMaybe<Scalars['String']['input']>;
  readonly created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Label for the vehicle schedule frame. Comes from BookingRecord vsc_name field from Hastus. */
  readonly label?: InputMaybe<Scalars['String']['input']>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  readonly name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<Scalars['Int']['input']>;
  /** OPERATING DAY when the VEHICLE SCHEDULE FRAME validity ends (inclusive). Null if always will be valid. */
  readonly validity_end?: InputMaybe<Scalars['date']['input']>;
  /** OPERATING DAY when the VEHICLE SCHEDULE FRAME validity starts (inclusive). Null if always has been valid. */
  readonly validity_start?: InputMaybe<Scalars['date']['input']>;
  readonly vehicle_schedule_frame_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type TimetablesVehicleScheduleVehicleScheduleFrameStddevFields = {
  readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_stddev_fields';
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type TimetablesVehicleScheduleVehicleScheduleFrameStddevPopFields = {
  readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_stddev_pop_fields';
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type TimetablesVehicleScheduleVehicleScheduleFrameStddevSampFields = {
  readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_stddev_samp_fields';
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "vehicle_schedule_vehicle_schedule_frame" */
export type TimetablesVehicleScheduleVehicleScheduleFrameStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: TimetablesVehicleScheduleVehicleScheduleFrameStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesVehicleScheduleVehicleScheduleFrameStreamCursorValueInput = {
  /** Booking description for the vehicle schedule frame. Comes from BookingRecord vsc_booking_desc field from Hastus. */
  readonly booking_description_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  /** Booking label for the vehicle schedule frame. Comes from BookingRecord vsc_booking field from Hastus. */
  readonly booking_label?: InputMaybe<Scalars['String']['input']>;
  readonly created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Label for the vehicle schedule frame. Comes from BookingRecord vsc_name field from Hastus. */
  readonly label?: InputMaybe<Scalars['String']['input']>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  readonly name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: InputMaybe<Scalars['Int']['input']>;
  /** OPERATING DAY when the VEHICLE SCHEDULE FRAME validity ends (inclusive). Null if always will be valid. */
  readonly validity_end?: InputMaybe<Scalars['date']['input']>;
  /**
   *
   * A denormalized column for actual daterange when vehicle schedule frame is valid,
   * that is, a closed date range [validity_start, validity_end].
   * Added to make working with PostgreSQL functions easier:
   * they typically expect ranges to be half closed.
   */
  readonly validity_range?: InputMaybe<Scalars['daterange']['input']>;
  /** OPERATING DAY when the VEHICLE SCHEDULE FRAME validity starts (inclusive). Null if always has been valid. */
  readonly validity_start?: InputMaybe<Scalars['date']['input']>;
  readonly vehicle_schedule_frame_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type TimetablesVehicleScheduleVehicleScheduleFrameSumFields = {
  readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_sum_fields';
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "vehicle_schedule.vehicle_schedule_frame" */
export enum TimetablesVehicleScheduleVehicleScheduleFrameUpdateColumn {
  /** column name */
  BookingDescriptionI18n = 'booking_description_i18n',
  /** column name */
  BookingLabel = 'booking_label',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Label = 'label',
  /** column name */
  NameI18n = 'name_i18n',
  /** column name */
  Priority = 'priority',
  /** column name */
  ValidityEnd = 'validity_end',
  /** column name */
  ValidityStart = 'validity_start',
  /** column name */
  VehicleScheduleFrameId = 'vehicle_schedule_frame_id'
}

export type TimetablesVehicleScheduleVehicleScheduleFrameUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  readonly _append?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  readonly _delete_at_path?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  readonly _delete_elem?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  readonly _delete_key?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  readonly _prepend?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFramePrependInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameSetInput>;
  /** filter the rows which have to be updated */
  readonly where: TimetablesVehicleScheduleVehicleScheduleFrameBoolExp;
};

/** aggregate var_pop on columns */
export type TimetablesVehicleScheduleVehicleScheduleFrameVarPopFields = {
  readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_var_pop_fields';
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type TimetablesVehicleScheduleVehicleScheduleFrameVarSampFields = {
  readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_var_samp_fields';
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type TimetablesVehicleScheduleVehicleScheduleFrameVarianceFields = {
  readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_variance_fields';
  /** The priority of the timetable definition. The definition may be overridden by higher priority definitions. */
  readonly priority?: Maybe<Scalars['Float']['output']>;
};

/** The work of a vehicle from the time it leaves a PARKING POINT after parking until its next return to park at a PARKING POINT. Any subsequent departure from a PARKING POINT after parking marks the start of a new BLOCK. The period of a BLOCK has to be covered by DUTies. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:5:958  */
export type TimetablesVehicleServiceBlock = {
  readonly __typename?: 'timetables_vehicle_service_block';
  readonly block_id: Scalars['uuid']['output'];
  /** Finishing time after end of vehicle service block. */
  readonly finishing_time?: Maybe<Scalars['interval']['output']>;
  /** Preparation time before start of vehicle service block. */
  readonly preparing_time?: Maybe<Scalars['interval']['output']>;
  /** An array relationship */
  readonly vehicle_journeys: ReadonlyArray<TimetablesVehicleJourneyVehicleJourney>;
  /** An aggregate relationship */
  readonly vehicle_journeys_aggregate: TimetablesVehicleJourneyVehicleJourneyAggregate;
  /** An object relationship */
  readonly vehicle_service: TimetablesVehicleServiceVehicleService;
  /** The VEHICLE SERVICE to which this BLOCK belongs. */
  readonly vehicle_service_id: Scalars['uuid']['output'];
  /** An object relationship */
  readonly vehicle_type?: Maybe<TimetablesVehicleTypeVehicleType>;
  /** Reference to vehicle_type.vehicle_type. */
  readonly vehicle_type_id?: Maybe<Scalars['uuid']['output']>;
};


/** The work of a vehicle from the time it leaves a PARKING POINT after parking until its next return to park at a PARKING POINT. Any subsequent departure from a PARKING POINT after parking marks the start of a new BLOCK. The period of a BLOCK has to be covered by DUTies. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:5:958  */
export type TimetablesVehicleServiceBlockVehicleJourneysArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleJourneyVehicleJourneySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleJourneyVehicleJourneyOrderBy>>;
  where?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
};


/** The work of a vehicle from the time it leaves a PARKING POINT after parking until its next return to park at a PARKING POINT. Any subsequent departure from a PARKING POINT after parking marks the start of a new BLOCK. The period of a BLOCK has to be covered by DUTies. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:5:958  */
export type TimetablesVehicleServiceBlockVehicleJourneysAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleJourneyVehicleJourneySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleJourneyVehicleJourneyOrderBy>>;
  where?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
};

/** aggregated selection of "vehicle_service.block" */
export type TimetablesVehicleServiceBlockAggregate = {
  readonly __typename?: 'timetables_vehicle_service_block_aggregate';
  readonly aggregate?: Maybe<TimetablesVehicleServiceBlockAggregateFields>;
  readonly nodes: ReadonlyArray<TimetablesVehicleServiceBlock>;
};

/** aggregate fields of "vehicle_service.block" */
export type TimetablesVehicleServiceBlockAggregateFields = {
  readonly __typename?: 'timetables_vehicle_service_block_aggregate_fields';
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<TimetablesVehicleServiceBlockMaxFields>;
  readonly min?: Maybe<TimetablesVehicleServiceBlockMinFields>;
};


/** aggregate fields of "vehicle_service.block" */
export type TimetablesVehicleServiceBlockAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceBlockSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "vehicle_service.block" */
export type TimetablesVehicleServiceBlockAggregateOrderBy = {
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<TimetablesVehicleServiceBlockMaxOrderBy>;
  readonly min?: InputMaybe<TimetablesVehicleServiceBlockMinOrderBy>;
};

/** input type for inserting array relation for remote table "vehicle_service.block" */
export type TimetablesVehicleServiceBlockArrRelInsertInput = {
  readonly data: ReadonlyArray<TimetablesVehicleServiceBlockInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<TimetablesVehicleServiceBlockOnConflict>;
};

/** Boolean expression to filter rows from the table "vehicle_service.block". All fields are combined with a logical 'AND'. */
export type TimetablesVehicleServiceBlockBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceBlockBoolExp>>;
  readonly _not?: InputMaybe<TimetablesVehicleServiceBlockBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceBlockBoolExp>>;
  readonly block_id?: InputMaybe<UuidComparisonExp>;
  readonly finishing_time?: InputMaybe<IntervalComparisonExp>;
  readonly preparing_time?: InputMaybe<IntervalComparisonExp>;
  readonly vehicle_journeys?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
  readonly vehicle_journeys_aggregate?: InputMaybe<VehicleJourneyVehicleJourneyAggregateBoolExp>;
  readonly vehicle_service?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
  readonly vehicle_service_id?: InputMaybe<UuidComparisonExp>;
  readonly vehicle_type?: InputMaybe<TimetablesVehicleTypeVehicleTypeBoolExp>;
  readonly vehicle_type_id?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "vehicle_service.block" */
export enum TimetablesVehicleServiceBlockConstraint {
  /** unique or primary key constraint on columns "block_id" */
  BlockPkey = 'block_pkey'
}

/** input type for inserting data into table "vehicle_service.block" */
export type TimetablesVehicleServiceBlockInsertInput = {
  readonly block_id?: InputMaybe<Scalars['uuid']['input']>;
  /** Finishing time after end of vehicle service block. */
  readonly finishing_time?: InputMaybe<Scalars['interval']['input']>;
  /** Preparation time before start of vehicle service block. */
  readonly preparing_time?: InputMaybe<Scalars['interval']['input']>;
  readonly vehicle_journeys?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyArrRelInsertInput>;
  readonly vehicle_service?: InputMaybe<TimetablesVehicleServiceVehicleServiceObjRelInsertInput>;
  /** The VEHICLE SERVICE to which this BLOCK belongs. */
  readonly vehicle_service_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly vehicle_type?: InputMaybe<TimetablesVehicleTypeVehicleTypeObjRelInsertInput>;
  /** Reference to vehicle_type.vehicle_type. */
  readonly vehicle_type_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type TimetablesVehicleServiceBlockMaxFields = {
  readonly __typename?: 'timetables_vehicle_service_block_max_fields';
  readonly block_id?: Maybe<Scalars['uuid']['output']>;
  /** The VEHICLE SERVICE to which this BLOCK belongs. */
  readonly vehicle_service_id?: Maybe<Scalars['uuid']['output']>;
  /** Reference to vehicle_type.vehicle_type. */
  readonly vehicle_type_id?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "vehicle_service.block" */
export type TimetablesVehicleServiceBlockMaxOrderBy = {
  readonly block_id?: InputMaybe<OrderBy>;
  /** The VEHICLE SERVICE to which this BLOCK belongs. */
  readonly vehicle_service_id?: InputMaybe<OrderBy>;
  /** Reference to vehicle_type.vehicle_type. */
  readonly vehicle_type_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type TimetablesVehicleServiceBlockMinFields = {
  readonly __typename?: 'timetables_vehicle_service_block_min_fields';
  readonly block_id?: Maybe<Scalars['uuid']['output']>;
  /** The VEHICLE SERVICE to which this BLOCK belongs. */
  readonly vehicle_service_id?: Maybe<Scalars['uuid']['output']>;
  /** Reference to vehicle_type.vehicle_type. */
  readonly vehicle_type_id?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "vehicle_service.block" */
export type TimetablesVehicleServiceBlockMinOrderBy = {
  readonly block_id?: InputMaybe<OrderBy>;
  /** The VEHICLE SERVICE to which this BLOCK belongs. */
  readonly vehicle_service_id?: InputMaybe<OrderBy>;
  /** Reference to vehicle_type.vehicle_type. */
  readonly vehicle_type_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "vehicle_service.block" */
export type TimetablesVehicleServiceBlockMutationResponse = {
  readonly __typename?: 'timetables_vehicle_service_block_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<TimetablesVehicleServiceBlock>;
};

/** input type for inserting object relation for remote table "vehicle_service.block" */
export type TimetablesVehicleServiceBlockObjRelInsertInput = {
  readonly data: TimetablesVehicleServiceBlockInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<TimetablesVehicleServiceBlockOnConflict>;
};

/** on_conflict condition type for table "vehicle_service.block" */
export type TimetablesVehicleServiceBlockOnConflict = {
  readonly constraint: TimetablesVehicleServiceBlockConstraint;
  readonly update_columns?: ReadonlyArray<TimetablesVehicleServiceBlockUpdateColumn>;
  readonly where?: InputMaybe<TimetablesVehicleServiceBlockBoolExp>;
};

/** Ordering options when selecting data from "vehicle_service.block". */
export type TimetablesVehicleServiceBlockOrderBy = {
  readonly block_id?: InputMaybe<OrderBy>;
  readonly finishing_time?: InputMaybe<OrderBy>;
  readonly preparing_time?: InputMaybe<OrderBy>;
  readonly vehicle_journeys_aggregate?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyAggregateOrderBy>;
  readonly vehicle_service?: InputMaybe<TimetablesVehicleServiceVehicleServiceOrderBy>;
  readonly vehicle_service_id?: InputMaybe<OrderBy>;
  readonly vehicle_type?: InputMaybe<TimetablesVehicleTypeVehicleTypeOrderBy>;
  readonly vehicle_type_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: vehicle_service.block */
export type TimetablesVehicleServiceBlockPkColumnsInput = {
  readonly block_id: Scalars['uuid']['input'];
};

/** select columns of table "vehicle_service.block" */
export enum TimetablesVehicleServiceBlockSelectColumn {
  /** column name */
  BlockId = 'block_id',
  /** column name */
  FinishingTime = 'finishing_time',
  /** column name */
  PreparingTime = 'preparing_time',
  /** column name */
  VehicleServiceId = 'vehicle_service_id',
  /** column name */
  VehicleTypeId = 'vehicle_type_id'
}

/** input type for updating data in table "vehicle_service.block" */
export type TimetablesVehicleServiceBlockSetInput = {
  readonly block_id?: InputMaybe<Scalars['uuid']['input']>;
  /** Finishing time after end of vehicle service block. */
  readonly finishing_time?: InputMaybe<Scalars['interval']['input']>;
  /** Preparation time before start of vehicle service block. */
  readonly preparing_time?: InputMaybe<Scalars['interval']['input']>;
  /** The VEHICLE SERVICE to which this BLOCK belongs. */
  readonly vehicle_service_id?: InputMaybe<Scalars['uuid']['input']>;
  /** Reference to vehicle_type.vehicle_type. */
  readonly vehicle_type_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "vehicle_service_block" */
export type TimetablesVehicleServiceBlockStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: TimetablesVehicleServiceBlockStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesVehicleServiceBlockStreamCursorValueInput = {
  readonly block_id?: InputMaybe<Scalars['uuid']['input']>;
  /** Finishing time after end of vehicle service block. */
  readonly finishing_time?: InputMaybe<Scalars['interval']['input']>;
  /** Preparation time before start of vehicle service block. */
  readonly preparing_time?: InputMaybe<Scalars['interval']['input']>;
  /** The VEHICLE SERVICE to which this BLOCK belongs. */
  readonly vehicle_service_id?: InputMaybe<Scalars['uuid']['input']>;
  /** Reference to vehicle_type.vehicle_type. */
  readonly vehicle_type_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "vehicle_service.block" */
export enum TimetablesVehicleServiceBlockUpdateColumn {
  /** column name */
  BlockId = 'block_id',
  /** column name */
  FinishingTime = 'finishing_time',
  /** column name */
  PreparingTime = 'preparing_time',
  /** column name */
  VehicleServiceId = 'vehicle_service_id',
  /** column name */
  VehicleTypeId = 'vehicle_type_id'
}

export type TimetablesVehicleServiceBlockUpdates = {
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<TimetablesVehicleServiceBlockSetInput>;
  /** filter the rows which have to be updated */
  readonly where: TimetablesVehicleServiceBlockBoolExp;
};

export type TimetablesVehicleServiceGetTimetableVersionsByJourneyPatternIdsArgs = {
  readonly end_date?: InputMaybe<Scalars['date']['input']>;
  readonly journey_pattern_ids?: InputMaybe<Scalars['_uuid']['input']>;
  readonly observation_date?: InputMaybe<Scalars['date']['input']>;
  readonly start_date?: InputMaybe<Scalars['date']['input']>;
};

export type TimetablesVehicleServiceGetTimetablesAndSubstituteOperatingDaysArgs = {
  readonly end_date?: InputMaybe<Scalars['date']['input']>;
  readonly journey_pattern_ids?: InputMaybe<Scalars['_uuid']['input']>;
  readonly start_date?: InputMaybe<Scalars['date']['input']>;
};

/**
 * A denormalized table containing relationships between vehicle_services and journey_patterns (via journey_pattern_ref.journey_pattern_id).
 *  Without this table this relationship could be found via vehicle_service -> block -> vehicle_journey -> journey_pattern_ref.
 *  Kept up to date with triggers, should not be updated manually.
 */
export type TimetablesVehicleServiceJourneyPatternsInVehicleService = {
  readonly __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service';
  /**
   * The journey_pattern_id from journey_pattern.journey_pattern_ref.
   *  No foreign key reference is set because the target column is not unique.
   */
  readonly journey_pattern_id: Scalars['uuid']['output'];
  readonly journey_pattern_instance?: Maybe<JourneyPatternJourneyPattern>;
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  readonly reference_count: Scalars['Int']['output'];
  /** An object relationship */
  readonly vehicle_service: TimetablesVehicleServiceVehicleService;
  readonly vehicle_service_id: Scalars['uuid']['output'];
};

/** aggregated selection of "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceAggregate = {
  readonly __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_aggregate';
  readonly aggregate?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceAggregateFields>;
  readonly nodes: ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleService>;
};

/** aggregate fields of "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceAggregateFields = {
  readonly __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_aggregate_fields';
  readonly avg?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceMaxFields>;
  readonly min?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceMinFields>;
  readonly stddev?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceStddevFields>;
  readonly stddev_pop?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceStddevPopFields>;
  readonly stddev_samp?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceStddevSampFields>;
  readonly sum?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSumFields>;
  readonly var_pop?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceVarPopFields>;
  readonly var_samp?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceVarSampFields>;
  readonly variance?: Maybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceVarianceFields>;
};


/** aggregate fields of "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceAggregateOrderBy = {
  readonly avg?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceAvgOrderBy>;
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceMaxOrderBy>;
  readonly min?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceMinOrderBy>;
  readonly stddev?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceStddevOrderBy>;
  readonly stddev_pop?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceStddevPopOrderBy>;
  readonly stddev_samp?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceStddevSampOrderBy>;
  readonly sum?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSumOrderBy>;
  readonly var_pop?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceVarPopOrderBy>;
  readonly var_samp?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceVarSampOrderBy>;
  readonly variance?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceArrRelInsertInput = {
  readonly data: ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleServiceInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceOnConflict>;
};

/** aggregate avg on columns */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceAvgFields = {
  readonly __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_avg_fields';
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  readonly reference_count?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceAvgOrderBy = {
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  readonly reference_count?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "vehicle_service.journey_patterns_in_vehicle_service". All fields are combined with a logical 'AND'. */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>>;
  readonly _not?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>>;
  readonly journey_pattern_id?: InputMaybe<UuidComparisonExp>;
  readonly reference_count?: InputMaybe<IntComparisonExp>;
  readonly vehicle_service?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
  readonly vehicle_service_id?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "vehicle_service.journey_patterns_in_vehicle_service" */
export enum TimetablesVehicleServiceJourneyPatternsInVehicleServiceConstraint {
  /** unique or primary key constraint on columns "vehicle_service_id", "journey_pattern_id" */
  JourneyPatternsInVehicleServicePkey = 'journey_patterns_in_vehicle_service_pkey'
}

/** input type for incrementing numeric columns in table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceIncInput = {
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  readonly reference_count?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceInsertInput = {
  /**
   * The journey_pattern_id from journey_pattern.journey_pattern_ref.
   *  No foreign key reference is set because the target column is not unique.
   */
  readonly journey_pattern_id?: InputMaybe<Scalars['uuid']['input']>;
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  readonly reference_count?: InputMaybe<Scalars['Int']['input']>;
  readonly vehicle_service?: InputMaybe<TimetablesVehicleServiceVehicleServiceObjRelInsertInput>;
  readonly vehicle_service_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceMaxFields = {
  readonly __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_max_fields';
  /**
   * The journey_pattern_id from journey_pattern.journey_pattern_ref.
   *  No foreign key reference is set because the target column is not unique.
   */
  readonly journey_pattern_id?: Maybe<Scalars['uuid']['output']>;
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  readonly reference_count?: Maybe<Scalars['Int']['output']>;
  readonly vehicle_service_id?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceMaxOrderBy = {
  /**
   * The journey_pattern_id from journey_pattern.journey_pattern_ref.
   *  No foreign key reference is set because the target column is not unique.
   */
  readonly journey_pattern_id?: InputMaybe<OrderBy>;
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  readonly reference_count?: InputMaybe<OrderBy>;
  readonly vehicle_service_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceMinFields = {
  readonly __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_min_fields';
  /**
   * The journey_pattern_id from journey_pattern.journey_pattern_ref.
   *  No foreign key reference is set because the target column is not unique.
   */
  readonly journey_pattern_id?: Maybe<Scalars['uuid']['output']>;
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  readonly reference_count?: Maybe<Scalars['Int']['output']>;
  readonly vehicle_service_id?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceMinOrderBy = {
  /**
   * The journey_pattern_id from journey_pattern.journey_pattern_ref.
   *  No foreign key reference is set because the target column is not unique.
   */
  readonly journey_pattern_id?: InputMaybe<OrderBy>;
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  readonly reference_count?: InputMaybe<OrderBy>;
  readonly vehicle_service_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceMutationResponse = {
  readonly __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleService>;
};

/** on_conflict condition type for table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceOnConflict = {
  readonly constraint: TimetablesVehicleServiceJourneyPatternsInVehicleServiceConstraint;
  readonly update_columns?: ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleServiceUpdateColumn>;
  readonly where?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
};

/** Ordering options when selecting data from "vehicle_service.journey_patterns_in_vehicle_service". */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceOrderBy = {
  readonly journey_pattern_id?: InputMaybe<OrderBy>;
  readonly reference_count?: InputMaybe<OrderBy>;
  readonly vehicle_service?: InputMaybe<TimetablesVehicleServiceVehicleServiceOrderBy>;
  readonly vehicle_service_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: vehicle_service.journey_patterns_in_vehicle_service */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServicePkColumnsInput = {
  /**
   * The journey_pattern_id from journey_pattern.journey_pattern_ref.
   *  No foreign key reference is set because the target column is not unique.
   */
  readonly journey_pattern_id: Scalars['uuid']['input'];
  readonly vehicle_service_id: Scalars['uuid']['input'];
};

/** select columns of table "vehicle_service.journey_patterns_in_vehicle_service" */
export enum TimetablesVehicleServiceJourneyPatternsInVehicleServiceSelectColumn {
  /** column name */
  JourneyPatternId = 'journey_pattern_id',
  /** column name */
  ReferenceCount = 'reference_count',
  /** column name */
  VehicleServiceId = 'vehicle_service_id'
}

/** input type for updating data in table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceSetInput = {
  /**
   * The journey_pattern_id from journey_pattern.journey_pattern_ref.
   *  No foreign key reference is set because the target column is not unique.
   */
  readonly journey_pattern_id?: InputMaybe<Scalars['uuid']['input']>;
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  readonly reference_count?: InputMaybe<Scalars['Int']['input']>;
  readonly vehicle_service_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceStddevFields = {
  readonly __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_stddev_fields';
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  readonly reference_count?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceStddevOrderBy = {
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  readonly reference_count?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceStddevPopFields = {
  readonly __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_stddev_pop_fields';
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  readonly reference_count?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceStddevPopOrderBy = {
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  readonly reference_count?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceStddevSampFields = {
  readonly __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_stddev_samp_fields';
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  readonly reference_count?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceStddevSampOrderBy = {
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  readonly reference_count?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "vehicle_service_journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: TimetablesVehicleServiceJourneyPatternsInVehicleServiceStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceStreamCursorValueInput = {
  /**
   * The journey_pattern_id from journey_pattern.journey_pattern_ref.
   *  No foreign key reference is set because the target column is not unique.
   */
  readonly journey_pattern_id?: InputMaybe<Scalars['uuid']['input']>;
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  readonly reference_count?: InputMaybe<Scalars['Int']['input']>;
  readonly vehicle_service_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceSumFields = {
  readonly __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_sum_fields';
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  readonly reference_count?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceSumOrderBy = {
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  readonly reference_count?: InputMaybe<OrderBy>;
};

/** update columns of table "vehicle_service.journey_patterns_in_vehicle_service" */
export enum TimetablesVehicleServiceJourneyPatternsInVehicleServiceUpdateColumn {
  /** column name */
  JourneyPatternId = 'journey_pattern_id',
  /** column name */
  ReferenceCount = 'reference_count',
  /** column name */
  VehicleServiceId = 'vehicle_service_id'
}

export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceIncInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSetInput>;
  /** filter the rows which have to be updated */
  readonly where: TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp;
};

/** aggregate var_pop on columns */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceVarPopFields = {
  readonly __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_var_pop_fields';
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  readonly reference_count?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceVarPopOrderBy = {
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  readonly reference_count?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceVarSampFields = {
  readonly __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_var_samp_fields';
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  readonly reference_count?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceVarSampOrderBy = {
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  readonly reference_count?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceVarianceFields = {
  readonly __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service_variance_fields';
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  readonly reference_count?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "vehicle_service.journey_patterns_in_vehicle_service" */
export type TimetablesVehicleServiceJourneyPatternsInVehicleServiceVarianceOrderBy = {
  /**
   * The amount of unique references between the journey_pattern and vehicle_service.
   *   When this reaches 0 the row will be deleted.
   */
  readonly reference_count?: InputMaybe<OrderBy>;
};

/** A work plan for a single vehicle for a whole day, planned for a specific DAY TYPE. A VEHICLE SERVICE includes one or several BLOCKs. If there is no service on a given day, it does not include any BLOCKs. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:5:965  */
export type TimetablesVehicleServiceVehicleService = {
  readonly __typename?: 'timetables_vehicle_service_vehicle_service';
  /** An array relationship */
  readonly blocks: ReadonlyArray<TimetablesVehicleServiceBlock>;
  /** An aggregate relationship */
  readonly blocks_aggregate: TimetablesVehicleServiceBlockAggregate;
  /** An object relationship */
  readonly day_type: TimetablesServiceCalendarDayType;
  /** The DAY TYPE for the VEHICLE SERVICE. */
  readonly day_type_id: Scalars['uuid']['output'];
  /** An array relationship */
  readonly journey_patterns_in_vehicle_service: ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleService>;
  /** An aggregate relationship */
  readonly journey_patterns_in_vehicle_service_aggregate: TimetablesVehicleServiceJourneyPatternsInVehicleServiceAggregate;
  /** Name for vehicle service. */
  readonly name_i18n?: Maybe<Scalars['jsonb']['output']>;
  /** An object relationship */
  readonly vehicle_schedule_frame: TimetablesVehicleScheduleVehicleScheduleFrame;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  readonly vehicle_schedule_frame_id: Scalars['uuid']['output'];
  readonly vehicle_service_id: Scalars['uuid']['output'];
};


/** A work plan for a single vehicle for a whole day, planned for a specific DAY TYPE. A VEHICLE SERVICE includes one or several BLOCKs. If there is no service on a given day, it does not include any BLOCKs. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:5:965  */
export type TimetablesVehicleServiceVehicleServiceBlocksArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceBlockSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceBlockOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceBlockBoolExp>;
};


/** A work plan for a single vehicle for a whole day, planned for a specific DAY TYPE. A VEHICLE SERVICE includes one or several BLOCKs. If there is no service on a given day, it does not include any BLOCKs. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:5:965  */
export type TimetablesVehicleServiceVehicleServiceBlocksAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceBlockSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceBlockOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceBlockBoolExp>;
};


/** A work plan for a single vehicle for a whole day, planned for a specific DAY TYPE. A VEHICLE SERVICE includes one or several BLOCKs. If there is no service on a given day, it does not include any BLOCKs. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:5:965  */
export type TimetablesVehicleServiceVehicleServiceJourneyPatternsInVehicleServiceArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleServiceOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
};


/** A work plan for a single vehicle for a whole day, planned for a specific DAY TYPE. A VEHICLE SERVICE includes one or several BLOCKs. If there is no service on a given day, it does not include any BLOCKs. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:5:965  */
export type TimetablesVehicleServiceVehicleServiceJourneyPatternsInVehicleServiceAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleServiceOrderBy>>;
  where?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
};


/** A work plan for a single vehicle for a whole day, planned for a specific DAY TYPE. A VEHICLE SERVICE includes one or several BLOCKs. If there is no service on a given day, it does not include any BLOCKs. Transmodel: https://www.transmodel-cen.eu/model/index.htm?goto=3:5:965  */
export type TimetablesVehicleServiceVehicleServiceNameI18nArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "vehicle_service.vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceAggregate = {
  readonly __typename?: 'timetables_vehicle_service_vehicle_service_aggregate';
  readonly aggregate?: Maybe<TimetablesVehicleServiceVehicleServiceAggregateFields>;
  readonly nodes: ReadonlyArray<TimetablesVehicleServiceVehicleService>;
};

/** aggregate fields of "vehicle_service.vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceAggregateFields = {
  readonly __typename?: 'timetables_vehicle_service_vehicle_service_aggregate_fields';
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<TimetablesVehicleServiceVehicleServiceMaxFields>;
  readonly min?: Maybe<TimetablesVehicleServiceVehicleServiceMinFields>;
};


/** aggregate fields of "vehicle_service.vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceVehicleServiceSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "vehicle_service.vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceAggregateOrderBy = {
  readonly count?: InputMaybe<OrderBy>;
  readonly max?: InputMaybe<TimetablesVehicleServiceVehicleServiceMaxOrderBy>;
  readonly min?: InputMaybe<TimetablesVehicleServiceVehicleServiceMinOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type TimetablesVehicleServiceVehicleServiceAppendInput = {
  /** Name for vehicle service. */
  readonly name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "vehicle_service.vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceArrRelInsertInput = {
  readonly data: ReadonlyArray<TimetablesVehicleServiceVehicleServiceInsertInput>;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<TimetablesVehicleServiceVehicleServiceOnConflict>;
};

/** Boolean expression to filter rows from the table "vehicle_service.vehicle_service". All fields are combined with a logical 'AND'. */
export type TimetablesVehicleServiceVehicleServiceBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceVehicleServiceBoolExp>>;
  readonly _not?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceVehicleServiceBoolExp>>;
  readonly blocks?: InputMaybe<TimetablesVehicleServiceBlockBoolExp>;
  readonly blocks_aggregate?: InputMaybe<VehicleServiceBlockAggregateBoolExp>;
  readonly day_type?: InputMaybe<TimetablesServiceCalendarDayTypeBoolExp>;
  readonly day_type_id?: InputMaybe<UuidComparisonExp>;
  readonly journey_patterns_in_vehicle_service?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
  readonly journey_patterns_in_vehicle_service_aggregate?: InputMaybe<VehicleServiceJourneyPatternsInVehicleServiceAggregateBoolExp>;
  readonly name_i18n?: InputMaybe<JsonbComparisonExp>;
  readonly vehicle_schedule_frame?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameBoolExp>;
  readonly vehicle_schedule_frame_id?: InputMaybe<UuidComparisonExp>;
  readonly vehicle_service_id?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "vehicle_service.vehicle_service" */
export enum TimetablesVehicleServiceVehicleServiceConstraint {
  /** unique or primary key constraint on columns "vehicle_service_id" */
  VehicleServicePkey = 'vehicle_service_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type TimetablesVehicleServiceVehicleServiceDeleteAtPathInput = {
  /** Name for vehicle service. */
  readonly name_i18n?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type TimetablesVehicleServiceVehicleServiceDeleteElemInput = {
  /** Name for vehicle service. */
  readonly name_i18n?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type TimetablesVehicleServiceVehicleServiceDeleteKeyInput = {
  /** Name for vehicle service. */
  readonly name_i18n?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "vehicle_service.vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceInsertInput = {
  readonly blocks?: InputMaybe<TimetablesVehicleServiceBlockArrRelInsertInput>;
  readonly day_type?: InputMaybe<TimetablesServiceCalendarDayTypeObjRelInsertInput>;
  /** The DAY TYPE for the VEHICLE SERVICE. */
  readonly day_type_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly journey_patterns_in_vehicle_service?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceArrRelInsertInput>;
  /** Name for vehicle service. */
  readonly name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  readonly vehicle_schedule_frame?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameObjRelInsertInput>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  readonly vehicle_schedule_frame_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly vehicle_service_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type TimetablesVehicleServiceVehicleServiceMaxFields = {
  readonly __typename?: 'timetables_vehicle_service_vehicle_service_max_fields';
  /** The DAY TYPE for the VEHICLE SERVICE. */
  readonly day_type_id?: Maybe<Scalars['uuid']['output']>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  readonly vehicle_schedule_frame_id?: Maybe<Scalars['uuid']['output']>;
  readonly vehicle_service_id?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "vehicle_service.vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceMaxOrderBy = {
  /** The DAY TYPE for the VEHICLE SERVICE. */
  readonly day_type_id?: InputMaybe<OrderBy>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  readonly vehicle_schedule_frame_id?: InputMaybe<OrderBy>;
  readonly vehicle_service_id?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type TimetablesVehicleServiceVehicleServiceMinFields = {
  readonly __typename?: 'timetables_vehicle_service_vehicle_service_min_fields';
  /** The DAY TYPE for the VEHICLE SERVICE. */
  readonly day_type_id?: Maybe<Scalars['uuid']['output']>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  readonly vehicle_schedule_frame_id?: Maybe<Scalars['uuid']['output']>;
  readonly vehicle_service_id?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "vehicle_service.vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceMinOrderBy = {
  /** The DAY TYPE for the VEHICLE SERVICE. */
  readonly day_type_id?: InputMaybe<OrderBy>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  readonly vehicle_schedule_frame_id?: InputMaybe<OrderBy>;
  readonly vehicle_service_id?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "vehicle_service.vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceMutationResponse = {
  readonly __typename?: 'timetables_vehicle_service_vehicle_service_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<TimetablesVehicleServiceVehicleService>;
};

/** input type for inserting object relation for remote table "vehicle_service.vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceObjRelInsertInput = {
  readonly data: TimetablesVehicleServiceVehicleServiceInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<TimetablesVehicleServiceVehicleServiceOnConflict>;
};

/** on_conflict condition type for table "vehicle_service.vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceOnConflict = {
  readonly constraint: TimetablesVehicleServiceVehicleServiceConstraint;
  readonly update_columns?: ReadonlyArray<TimetablesVehicleServiceVehicleServiceUpdateColumn>;
  readonly where?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
};

/** Ordering options when selecting data from "vehicle_service.vehicle_service". */
export type TimetablesVehicleServiceVehicleServiceOrderBy = {
  readonly blocks_aggregate?: InputMaybe<TimetablesVehicleServiceBlockAggregateOrderBy>;
  readonly day_type?: InputMaybe<TimetablesServiceCalendarDayTypeOrderBy>;
  readonly day_type_id?: InputMaybe<OrderBy>;
  readonly journey_patterns_in_vehicle_service_aggregate?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceAggregateOrderBy>;
  readonly name_i18n?: InputMaybe<OrderBy>;
  readonly vehicle_schedule_frame?: InputMaybe<TimetablesVehicleScheduleVehicleScheduleFrameOrderBy>;
  readonly vehicle_schedule_frame_id?: InputMaybe<OrderBy>;
  readonly vehicle_service_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: vehicle_service.vehicle_service */
export type TimetablesVehicleServiceVehicleServicePkColumnsInput = {
  readonly vehicle_service_id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type TimetablesVehicleServiceVehicleServicePrependInput = {
  /** Name for vehicle service. */
  readonly name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "vehicle_service.vehicle_service" */
export enum TimetablesVehicleServiceVehicleServiceSelectColumn {
  /** column name */
  DayTypeId = 'day_type_id',
  /** column name */
  NameI18n = 'name_i18n',
  /** column name */
  VehicleScheduleFrameId = 'vehicle_schedule_frame_id',
  /** column name */
  VehicleServiceId = 'vehicle_service_id'
}

/** input type for updating data in table "vehicle_service.vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceSetInput = {
  /** The DAY TYPE for the VEHICLE SERVICE. */
  readonly day_type_id?: InputMaybe<Scalars['uuid']['input']>;
  /** Name for vehicle service. */
  readonly name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  readonly vehicle_schedule_frame_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly vehicle_service_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "vehicle_service_vehicle_service" */
export type TimetablesVehicleServiceVehicleServiceStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: TimetablesVehicleServiceVehicleServiceStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesVehicleServiceVehicleServiceStreamCursorValueInput = {
  /** The DAY TYPE for the VEHICLE SERVICE. */
  readonly day_type_id?: InputMaybe<Scalars['uuid']['input']>;
  /** Name for vehicle service. */
  readonly name_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  /** Human-readable name for the VEHICLE SCHEDULE FRAME */
  readonly vehicle_schedule_frame_id?: InputMaybe<Scalars['uuid']['input']>;
  readonly vehicle_service_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "vehicle_service.vehicle_service" */
export enum TimetablesVehicleServiceVehicleServiceUpdateColumn {
  /** column name */
  DayTypeId = 'day_type_id',
  /** column name */
  NameI18n = 'name_i18n',
  /** column name */
  VehicleScheduleFrameId = 'vehicle_schedule_frame_id',
  /** column name */
  VehicleServiceId = 'vehicle_service_id'
}

export type TimetablesVehicleServiceVehicleServiceUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  readonly _append?: InputMaybe<TimetablesVehicleServiceVehicleServiceAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  readonly _delete_at_path?: InputMaybe<TimetablesVehicleServiceVehicleServiceDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  readonly _delete_elem?: InputMaybe<TimetablesVehicleServiceVehicleServiceDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  readonly _delete_key?: InputMaybe<TimetablesVehicleServiceVehicleServiceDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  readonly _prepend?: InputMaybe<TimetablesVehicleServiceVehicleServicePrependInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<TimetablesVehicleServiceVehicleServiceSetInput>;
  /** filter the rows which have to be updated */
  readonly where: TimetablesVehicleServiceVehicleServiceBoolExp;
};

/** The VEHICLE entity is used to describe the physical public transport vehicles available for short-term planning of operations and daily assignment (in contrast to logical vehicles considered for resource planning of operations and daily assignment (in contrast to logical vehicles cplanning). Each VEHICLE shall be classified as of a particular VEHICLE TYPE. */
export type TimetablesVehicleTypeVehicleType = {
  readonly __typename?: 'timetables_vehicle_type_vehicle_type';
  /** Description of the vehicle type. */
  readonly description_i18n?: Maybe<Scalars['jsonb']['output']>;
  /** ID used in Hastus to represent the vehicle type. */
  readonly hsl_id: Scalars['smallint']['output'];
  /** Label of the vehicle type. */
  readonly label: Scalars['String']['output'];
  readonly vehicle_type_id: Scalars['uuid']['output'];
};


/** The VEHICLE entity is used to describe the physical public transport vehicles available for short-term planning of operations and daily assignment (in contrast to logical vehicles considered for resource planning of operations and daily assignment (in contrast to logical vehicles cplanning). Each VEHICLE shall be classified as of a particular VEHICLE TYPE. */
export type TimetablesVehicleTypeVehicleTypeDescriptionI18nArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "vehicle_type.vehicle_type" */
export type TimetablesVehicleTypeVehicleTypeAggregate = {
  readonly __typename?: 'timetables_vehicle_type_vehicle_type_aggregate';
  readonly aggregate?: Maybe<TimetablesVehicleTypeVehicleTypeAggregateFields>;
  readonly nodes: ReadonlyArray<TimetablesVehicleTypeVehicleType>;
};

/** aggregate fields of "vehicle_type.vehicle_type" */
export type TimetablesVehicleTypeVehicleTypeAggregateFields = {
  readonly __typename?: 'timetables_vehicle_type_vehicle_type_aggregate_fields';
  readonly avg?: Maybe<TimetablesVehicleTypeVehicleTypeAvgFields>;
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<TimetablesVehicleTypeVehicleTypeMaxFields>;
  readonly min?: Maybe<TimetablesVehicleTypeVehicleTypeMinFields>;
  readonly stddev?: Maybe<TimetablesVehicleTypeVehicleTypeStddevFields>;
  readonly stddev_pop?: Maybe<TimetablesVehicleTypeVehicleTypeStddevPopFields>;
  readonly stddev_samp?: Maybe<TimetablesVehicleTypeVehicleTypeStddevSampFields>;
  readonly sum?: Maybe<TimetablesVehicleTypeVehicleTypeSumFields>;
  readonly var_pop?: Maybe<TimetablesVehicleTypeVehicleTypeVarPopFields>;
  readonly var_samp?: Maybe<TimetablesVehicleTypeVehicleTypeVarSampFields>;
  readonly variance?: Maybe<TimetablesVehicleTypeVehicleTypeVarianceFields>;
};


/** aggregate fields of "vehicle_type.vehicle_type" */
export type TimetablesVehicleTypeVehicleTypeAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<TimetablesVehicleTypeVehicleTypeSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type TimetablesVehicleTypeVehicleTypeAppendInput = {
  /** Description of the vehicle type. */
  readonly description_i18n?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type TimetablesVehicleTypeVehicleTypeAvgFields = {
  readonly __typename?: 'timetables_vehicle_type_vehicle_type_avg_fields';
  /** ID used in Hastus to represent the vehicle type. */
  readonly hsl_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "vehicle_type.vehicle_type". All fields are combined with a logical 'AND'. */
export type TimetablesVehicleTypeVehicleTypeBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<TimetablesVehicleTypeVehicleTypeBoolExp>>;
  readonly _not?: InputMaybe<TimetablesVehicleTypeVehicleTypeBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<TimetablesVehicleTypeVehicleTypeBoolExp>>;
  readonly description_i18n?: InputMaybe<JsonbComparisonExp>;
  readonly hsl_id?: InputMaybe<SmallintComparisonExp>;
  readonly label?: InputMaybe<StringComparisonExp>;
  readonly vehicle_type_id?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "vehicle_type.vehicle_type" */
export enum TimetablesVehicleTypeVehicleTypeConstraint {
  /** unique or primary key constraint on columns "hsl_id" */
  VehicleTypeHslIdIdx = 'vehicle_type_hsl_id_idx',
  /** unique or primary key constraint on columns "label" */
  VehicleTypeLabelIdx = 'vehicle_type_label_idx',
  /** unique or primary key constraint on columns "vehicle_type_id" */
  VehicleTypePkey = 'vehicle_type_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type TimetablesVehicleTypeVehicleTypeDeleteAtPathInput = {
  /** Description of the vehicle type. */
  readonly description_i18n?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type TimetablesVehicleTypeVehicleTypeDeleteElemInput = {
  /** Description of the vehicle type. */
  readonly description_i18n?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type TimetablesVehicleTypeVehicleTypeDeleteKeyInput = {
  /** Description of the vehicle type. */
  readonly description_i18n?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "vehicle_type.vehicle_type" */
export type TimetablesVehicleTypeVehicleTypeIncInput = {
  /** ID used in Hastus to represent the vehicle type. */
  readonly hsl_id?: InputMaybe<Scalars['smallint']['input']>;
};

/** input type for inserting data into table "vehicle_type.vehicle_type" */
export type TimetablesVehicleTypeVehicleTypeInsertInput = {
  /** Description of the vehicle type. */
  readonly description_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  /** ID used in Hastus to represent the vehicle type. */
  readonly hsl_id?: InputMaybe<Scalars['smallint']['input']>;
  /** Label of the vehicle type. */
  readonly label?: InputMaybe<Scalars['String']['input']>;
  readonly vehicle_type_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type TimetablesVehicleTypeVehicleTypeMaxFields = {
  readonly __typename?: 'timetables_vehicle_type_vehicle_type_max_fields';
  /** ID used in Hastus to represent the vehicle type. */
  readonly hsl_id?: Maybe<Scalars['smallint']['output']>;
  /** Label of the vehicle type. */
  readonly label?: Maybe<Scalars['String']['output']>;
  readonly vehicle_type_id?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type TimetablesVehicleTypeVehicleTypeMinFields = {
  readonly __typename?: 'timetables_vehicle_type_vehicle_type_min_fields';
  /** ID used in Hastus to represent the vehicle type. */
  readonly hsl_id?: Maybe<Scalars['smallint']['output']>;
  /** Label of the vehicle type. */
  readonly label?: Maybe<Scalars['String']['output']>;
  readonly vehicle_type_id?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "vehicle_type.vehicle_type" */
export type TimetablesVehicleTypeVehicleTypeMutationResponse = {
  readonly __typename?: 'timetables_vehicle_type_vehicle_type_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<TimetablesVehicleTypeVehicleType>;
};

/** input type for inserting object relation for remote table "vehicle_type.vehicle_type" */
export type TimetablesVehicleTypeVehicleTypeObjRelInsertInput = {
  readonly data: TimetablesVehicleTypeVehicleTypeInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<TimetablesVehicleTypeVehicleTypeOnConflict>;
};

/** on_conflict condition type for table "vehicle_type.vehicle_type" */
export type TimetablesVehicleTypeVehicleTypeOnConflict = {
  readonly constraint: TimetablesVehicleTypeVehicleTypeConstraint;
  readonly update_columns?: ReadonlyArray<TimetablesVehicleTypeVehicleTypeUpdateColumn>;
  readonly where?: InputMaybe<TimetablesVehicleTypeVehicleTypeBoolExp>;
};

/** Ordering options when selecting data from "vehicle_type.vehicle_type". */
export type TimetablesVehicleTypeVehicleTypeOrderBy = {
  readonly description_i18n?: InputMaybe<OrderBy>;
  readonly hsl_id?: InputMaybe<OrderBy>;
  readonly label?: InputMaybe<OrderBy>;
  readonly vehicle_type_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: vehicle_type.vehicle_type */
export type TimetablesVehicleTypeVehicleTypePkColumnsInput = {
  readonly vehicle_type_id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type TimetablesVehicleTypeVehicleTypePrependInput = {
  /** Description of the vehicle type. */
  readonly description_i18n?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "vehicle_type.vehicle_type" */
export enum TimetablesVehicleTypeVehicleTypeSelectColumn {
  /** column name */
  DescriptionI18n = 'description_i18n',
  /** column name */
  HslId = 'hsl_id',
  /** column name */
  Label = 'label',
  /** column name */
  VehicleTypeId = 'vehicle_type_id'
}

/** input type for updating data in table "vehicle_type.vehicle_type" */
export type TimetablesVehicleTypeVehicleTypeSetInput = {
  /** Description of the vehicle type. */
  readonly description_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  /** ID used in Hastus to represent the vehicle type. */
  readonly hsl_id?: InputMaybe<Scalars['smallint']['input']>;
  /** Label of the vehicle type. */
  readonly label?: InputMaybe<Scalars['String']['input']>;
  readonly vehicle_type_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type TimetablesVehicleTypeVehicleTypeStddevFields = {
  readonly __typename?: 'timetables_vehicle_type_vehicle_type_stddev_fields';
  /** ID used in Hastus to represent the vehicle type. */
  readonly hsl_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type TimetablesVehicleTypeVehicleTypeStddevPopFields = {
  readonly __typename?: 'timetables_vehicle_type_vehicle_type_stddev_pop_fields';
  /** ID used in Hastus to represent the vehicle type. */
  readonly hsl_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type TimetablesVehicleTypeVehicleTypeStddevSampFields = {
  readonly __typename?: 'timetables_vehicle_type_vehicle_type_stddev_samp_fields';
  /** ID used in Hastus to represent the vehicle type. */
  readonly hsl_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "vehicle_type_vehicle_type" */
export type TimetablesVehicleTypeVehicleTypeStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: TimetablesVehicleTypeVehicleTypeStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<TimetablesCursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimetablesVehicleTypeVehicleTypeStreamCursorValueInput = {
  /** Description of the vehicle type. */
  readonly description_i18n?: InputMaybe<Scalars['jsonb']['input']>;
  /** ID used in Hastus to represent the vehicle type. */
  readonly hsl_id?: InputMaybe<Scalars['smallint']['input']>;
  /** Label of the vehicle type. */
  readonly label?: InputMaybe<Scalars['String']['input']>;
  readonly vehicle_type_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type TimetablesVehicleTypeVehicleTypeSumFields = {
  readonly __typename?: 'timetables_vehicle_type_vehicle_type_sum_fields';
  /** ID used in Hastus to represent the vehicle type. */
  readonly hsl_id?: Maybe<Scalars['smallint']['output']>;
};

/** update columns of table "vehicle_type.vehicle_type" */
export enum TimetablesVehicleTypeVehicleTypeUpdateColumn {
  /** column name */
  DescriptionI18n = 'description_i18n',
  /** column name */
  HslId = 'hsl_id',
  /** column name */
  Label = 'label',
  /** column name */
  VehicleTypeId = 'vehicle_type_id'
}

export type TimetablesVehicleTypeVehicleTypeUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  readonly _append?: InputMaybe<TimetablesVehicleTypeVehicleTypeAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  readonly _delete_at_path?: InputMaybe<TimetablesVehicleTypeVehicleTypeDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  readonly _delete_elem?: InputMaybe<TimetablesVehicleTypeVehicleTypeDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  readonly _delete_key?: InputMaybe<TimetablesVehicleTypeVehicleTypeDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  readonly _inc?: InputMaybe<TimetablesVehicleTypeVehicleTypeIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  readonly _prepend?: InputMaybe<TimetablesVehicleTypeVehicleTypePrependInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<TimetablesVehicleTypeVehicleTypeSetInput>;
  /** filter the rows which have to be updated */
  readonly where: TimetablesVehicleTypeVehicleTypeBoolExp;
};

/** aggregate var_pop on columns */
export type TimetablesVehicleTypeVehicleTypeVarPopFields = {
  readonly __typename?: 'timetables_vehicle_type_vehicle_type_var_pop_fields';
  /** ID used in Hastus to represent the vehicle type. */
  readonly hsl_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type TimetablesVehicleTypeVehicleTypeVarSampFields = {
  readonly __typename?: 'timetables_vehicle_type_vehicle_type_var_samp_fields';
  /** ID used in Hastus to represent the vehicle type. */
  readonly hsl_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type TimetablesVehicleTypeVehicleTypeVarianceFields = {
  readonly __typename?: 'timetables_vehicle_type_vehicle_type_variance_fields';
  /** ID used in Hastus to represent the vehicle type. */
  readonly hsl_id?: Maybe<Scalars['Float']['output']>;
};

/** A set of SCHEDULED STOP POINTs against which the timing information necessary to build schedules may be recorded. In HSL context this is "Hastus paikka". Based on Transmodel entity TIMING POINT: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:2:709  */
export type TimingPatternTimingPlace = {
  readonly __typename?: 'timing_pattern_timing_place';
  readonly description?: Maybe<Scalars['jsonb']['output']>;
  readonly label: Scalars['String']['output'];
  /** An array relationship */
  readonly scheduled_stop_points: ReadonlyArray<ServicePatternScheduledStopPoint>;
  /** An aggregate relationship */
  readonly scheduled_stop_points_aggregate: ServicePatternScheduledStopPointAggregate;
  readonly timing_place_id: Scalars['uuid']['output'];
};


/** A set of SCHEDULED STOP POINTs against which the timing information necessary to build schedules may be recorded. In HSL context this is "Hastus paikka". Based on Transmodel entity TIMING POINT: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:2:709  */
export type TimingPatternTimingPlaceDescriptionArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** A set of SCHEDULED STOP POINTs against which the timing information necessary to build schedules may be recorded. In HSL context this is "Hastus paikka". Based on Transmodel entity TIMING POINT: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:2:709  */
export type TimingPatternTimingPlaceScheduledStopPointsArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};


/** A set of SCHEDULED STOP POINTs against which the timing information necessary to build schedules may be recorded. In HSL context this is "Hastus paikka". Based on Transmodel entity TIMING POINT: https://www.transmodel-cen.eu/model/index.htm?goto=2:3:2:709  */
export type TimingPatternTimingPlaceScheduledStopPointsAggregateArgs = {
  distinct_on?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<ReadonlyArray<ServicePatternScheduledStopPointOrderBy>>;
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
};

/** aggregated selection of "timing_pattern.timing_place" */
export type TimingPatternTimingPlaceAggregate = {
  readonly __typename?: 'timing_pattern_timing_place_aggregate';
  readonly aggregate?: Maybe<TimingPatternTimingPlaceAggregateFields>;
  readonly nodes: ReadonlyArray<TimingPatternTimingPlace>;
};

/** aggregate fields of "timing_pattern.timing_place" */
export type TimingPatternTimingPlaceAggregateFields = {
  readonly __typename?: 'timing_pattern_timing_place_aggregate_fields';
  readonly count: Scalars['Int']['output'];
  readonly max?: Maybe<TimingPatternTimingPlaceMaxFields>;
  readonly min?: Maybe<TimingPatternTimingPlaceMinFields>;
};


/** aggregate fields of "timing_pattern.timing_place" */
export type TimingPatternTimingPlaceAggregateFieldsCountArgs = {
  columns?: InputMaybe<ReadonlyArray<TimingPatternTimingPlaceSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type TimingPatternTimingPlaceAppendInput = {
  readonly description?: InputMaybe<Scalars['jsonb']['input']>;
};

/** Boolean expression to filter rows from the table "timing_pattern.timing_place". All fields are combined with a logical 'AND'. */
export type TimingPatternTimingPlaceBoolExp = {
  readonly _and?: InputMaybe<ReadonlyArray<TimingPatternTimingPlaceBoolExp>>;
  readonly _not?: InputMaybe<TimingPatternTimingPlaceBoolExp>;
  readonly _or?: InputMaybe<ReadonlyArray<TimingPatternTimingPlaceBoolExp>>;
  readonly description?: InputMaybe<JsonbComparisonExp>;
  readonly label?: InputMaybe<StringComparisonExp>;
  readonly scheduled_stop_points?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
  readonly scheduled_stop_points_aggregate?: InputMaybe<ServicePatternScheduledStopPointAggregateBoolExp>;
  readonly timing_place_id?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "timing_pattern.timing_place" */
export enum TimingPatternTimingPlaceConstraint {
  /** unique or primary key constraint on columns "label" */
  TimingPlaceLabelIdx = 'timing_place_label_idx',
  /** unique or primary key constraint on columns "timing_place_id" */
  TimingPlacePkey = 'timing_place_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type TimingPatternTimingPlaceDeleteAtPathInput = {
  readonly description?: InputMaybe<ReadonlyArray<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type TimingPatternTimingPlaceDeleteElemInput = {
  readonly description?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type TimingPatternTimingPlaceDeleteKeyInput = {
  readonly description?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "timing_pattern.timing_place" */
export type TimingPatternTimingPlaceInsertInput = {
  readonly description?: InputMaybe<Scalars['jsonb']['input']>;
  readonly label?: InputMaybe<Scalars['String']['input']>;
  readonly scheduled_stop_points?: InputMaybe<ServicePatternScheduledStopPointArrRelInsertInput>;
  readonly timing_place_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type TimingPatternTimingPlaceMaxFields = {
  readonly __typename?: 'timing_pattern_timing_place_max_fields';
  readonly label?: Maybe<Scalars['String']['output']>;
  readonly timing_place_id?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type TimingPatternTimingPlaceMinFields = {
  readonly __typename?: 'timing_pattern_timing_place_min_fields';
  readonly label?: Maybe<Scalars['String']['output']>;
  readonly timing_place_id?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "timing_pattern.timing_place" */
export type TimingPatternTimingPlaceMutationResponse = {
  readonly __typename?: 'timing_pattern_timing_place_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<TimingPatternTimingPlace>;
};

/** input type for inserting object relation for remote table "timing_pattern.timing_place" */
export type TimingPatternTimingPlaceObjRelInsertInput = {
  readonly data: TimingPatternTimingPlaceInsertInput;
  /** upsert condition */
  readonly on_conflict?: InputMaybe<TimingPatternTimingPlaceOnConflict>;
};

/** on_conflict condition type for table "timing_pattern.timing_place" */
export type TimingPatternTimingPlaceOnConflict = {
  readonly constraint: TimingPatternTimingPlaceConstraint;
  readonly update_columns?: ReadonlyArray<TimingPatternTimingPlaceUpdateColumn>;
  readonly where?: InputMaybe<TimingPatternTimingPlaceBoolExp>;
};

/** Ordering options when selecting data from "timing_pattern.timing_place". */
export type TimingPatternTimingPlaceOrderBy = {
  readonly description?: InputMaybe<OrderBy>;
  readonly label?: InputMaybe<OrderBy>;
  readonly scheduled_stop_points_aggregate?: InputMaybe<ServicePatternScheduledStopPointAggregateOrderBy>;
  readonly timing_place_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: timing_pattern.timing_place */
export type TimingPatternTimingPlacePkColumnsInput = {
  readonly timing_place_id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type TimingPatternTimingPlacePrependInput = {
  readonly description?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "timing_pattern.timing_place" */
export enum TimingPatternTimingPlaceSelectColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Label = 'label',
  /** column name */
  TimingPlaceId = 'timing_place_id'
}

/** input type for updating data in table "timing_pattern.timing_place" */
export type TimingPatternTimingPlaceSetInput = {
  readonly description?: InputMaybe<Scalars['jsonb']['input']>;
  readonly label?: InputMaybe<Scalars['String']['input']>;
  readonly timing_place_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "timing_pattern_timing_place" */
export type TimingPatternTimingPlaceStreamCursorInput = {
  /** Stream column input with initial value */
  readonly initial_value: TimingPatternTimingPlaceStreamCursorValueInput;
  /** cursor ordering */
  readonly ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimingPatternTimingPlaceStreamCursorValueInput = {
  readonly description?: InputMaybe<Scalars['jsonb']['input']>;
  readonly label?: InputMaybe<Scalars['String']['input']>;
  readonly timing_place_id?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "timing_pattern.timing_place" */
export enum TimingPatternTimingPlaceUpdateColumn {
  /** column name */
  Description = 'description',
  /** column name */
  Label = 'label',
  /** column name */
  TimingPlaceId = 'timing_place_id'
}

export type TimingPatternTimingPlaceUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  readonly _append?: InputMaybe<TimingPatternTimingPlaceAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  readonly _delete_at_path?: InputMaybe<TimingPatternTimingPlaceDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  readonly _delete_elem?: InputMaybe<TimingPatternTimingPlaceDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  readonly _delete_key?: InputMaybe<TimingPatternTimingPlaceDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  readonly _prepend?: InputMaybe<TimingPatternTimingPlacePrependInput>;
  /** sets the columns of the filtered rows to the given values */
  readonly _set?: InputMaybe<TimingPatternTimingPlaceSetInput>;
  /** filter the rows which have to be updated */
  readonly where: TimingPatternTimingPlaceBoolExp;
};

export type TopographicPlaceKeyValuesAggregateBoolExp = {
  readonly count?: InputMaybe<TopographicPlaceKeyValuesAggregateBoolExpCount>;
};

export type TopographicPlaceKeyValuesAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseTopographicPlaceKeyValuesSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseTopographicPlaceKeyValuesBoolExp>;
  readonly predicate: IntComparisonExp;
};

/** Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'. */
export type UuidComparisonExp = {
  readonly _eq?: InputMaybe<Scalars['uuid']['input']>;
  readonly _gt?: InputMaybe<Scalars['uuid']['input']>;
  readonly _gte?: InputMaybe<Scalars['uuid']['input']>;
  readonly _in?: InputMaybe<ReadonlyArray<Scalars['uuid']['input']>>;
  readonly _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  readonly _lt?: InputMaybe<Scalars['uuid']['input']>;
  readonly _lte?: InputMaybe<Scalars['uuid']['input']>;
  readonly _neq?: InputMaybe<Scalars['uuid']['input']>;
  readonly _nin?: InputMaybe<ReadonlyArray<Scalars['uuid']['input']>>;
};

export type ValidityPeriod = {
  readonly validity_end?: Maybe<Scalars['date']['output']>;
  readonly validity_start?: Maybe<Scalars['date']['output']>;
};

export type ValueItemsAggregateBoolExp = {
  readonly count?: InputMaybe<ValueItemsAggregateBoolExpCount>;
};

export type ValueItemsAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<StopsDatabaseValueItemsSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<StopsDatabaseValueItemsBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type VehicleJourneyVehicleJourneyAggregateBoolExp = {
  readonly bool_and?: InputMaybe<VehicleJourneyVehicleJourneyAggregateBoolExpBoolAnd>;
  readonly bool_or?: InputMaybe<VehicleJourneyVehicleJourneyAggregateBoolExpBoolOr>;
  readonly count?: InputMaybe<VehicleJourneyVehicleJourneyAggregateBoolExpCount>;
};

export type VehicleJourneyVehicleJourneyAggregateBoolExpBoolAnd = {
  readonly arguments: TimetablesVehicleJourneyVehicleJourneySelectColumnVehicleJourneyVehicleJourneyAggregateBoolExpBoolAndArgumentsColumns;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
  readonly predicate: BooleanComparisonExp;
};

export type VehicleJourneyVehicleJourneyAggregateBoolExpBoolOr = {
  readonly arguments: TimetablesVehicleJourneyVehicleJourneySelectColumnVehicleJourneyVehicleJourneyAggregateBoolExpBoolOrArgumentsColumns;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
  readonly predicate: BooleanComparisonExp;
};

export type VehicleJourneyVehicleJourneyAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<TimetablesVehicleJourneyVehicleJourneySelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<TimetablesVehicleJourneyVehicleJourneyBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type VehicleServiceBlockAggregateBoolExp = {
  readonly count?: InputMaybe<VehicleServiceBlockAggregateBoolExpCount>;
};

export type VehicleServiceBlockAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceBlockSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<TimetablesVehicleServiceBlockBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type VehicleServiceJourneyPatternsInVehicleServiceAggregateBoolExp = {
  readonly count?: InputMaybe<VehicleServiceJourneyPatternsInVehicleServiceAggregateBoolExpCount>;
};

export type VehicleServiceJourneyPatternsInVehicleServiceAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceJourneyPatternsInVehicleServiceSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<TimetablesVehicleServiceJourneyPatternsInVehicleServiceBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type VehicleServiceVehicleServiceAggregateBoolExp = {
  readonly count?: InputMaybe<VehicleServiceVehicleServiceAggregateBoolExpCount>;
};

export type VehicleServiceVehicleServiceAggregateBoolExpCount = {
  readonly arguments?: InputMaybe<ReadonlyArray<TimetablesVehicleServiceVehicleServiceSelectColumn>>;
  readonly distinct?: InputMaybe<Scalars['Boolean']['input']>;
  readonly filter?: InputMaybe<TimetablesVehicleServiceVehicleServiceBoolExp>;
  readonly predicate: IntComparisonExp;
};

export type LineTableRowFragment = {
  readonly __typename?: 'route_line',
  readonly name_i18n: LocalizedString,
  readonly short_name_i18n: LocalizedString,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly priority: number,
  readonly line_id: UUID,
  readonly label: string,
  readonly line_routes: ReadonlyArray<{
    readonly __typename?: 'route_route',
    readonly unique_label: string,
    readonly direction: RouteDirectionEnum,
    readonly route_id: UUID,
    readonly route_shape?: GeoJSON.LineString | null,
    readonly label: string,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly route_journey_patterns: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly journey_pattern_refs: ReadonlyArray<{
        readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref',
        readonly journey_pattern_ref_id: UUID,
        readonly vehicle_journeys: ReadonlyArray<{
          readonly __typename?: 'timetables_vehicle_journey_vehicle_journey',
          readonly vehicle_journey_id: UUID
        }>
      }>,
      readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
        readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly scheduled_stop_point_sequence: number,
        readonly is_used_as_timing_point: boolean
      }>
    }>
  }>
};

export type RouteTableRowFragment = {
  readonly __typename?: 'route_route',
  readonly name_i18n: LocalizedString,
  readonly direction: RouteDirectionEnum,
  readonly priority: number,
  readonly on_line_id: UUID,
  readonly variant?: number | null,
  readonly unique_label: string,
  readonly route_id: UUID,
  readonly label: string,
  readonly route_shape?: GeoJSON.LineString | null,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly route_journey_patterns: ReadonlyArray<{
    readonly __typename?: 'journey_pattern_journey_pattern',
    readonly journey_pattern_id: UUID,
    readonly journey_pattern_refs: ReadonlyArray<{
      readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref',
      readonly journey_pattern_ref_id: UUID,
      readonly vehicle_journeys: ReadonlyArray<{
        readonly __typename?: 'timetables_vehicle_journey_vehicle_journey',
        readonly vehicle_journey_id: UUID
      }>
    }>,
    readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly scheduled_stop_point_sequence: number,
      readonly is_used_as_timing_point: boolean
    }>
  }>
};

export type GetStopPlaceMaxPrivateCodeQueryVariables = Exact<{
  isParent: Scalars['Boolean']['input'];
  mask: Scalars['String']['input'];
}>;


export type GetStopPlaceMaxPrivateCodeQuery = {
  readonly __typename?: 'query_root',
  readonly stops_database?: {
    readonly __typename?: 'stops_database_stops_database_query',
    readonly stops_database_stop_place_aggregate: {
      readonly __typename?: 'stops_database_stop_place_aggregate',
      readonly aggregate?: {
        readonly __typename?: 'stops_database_stop_place_aggregate_fields',
        readonly max?: {
          readonly __typename?: 'stops_database_stop_place_max_fields',
          readonly private_code_value?: string | null
        } | null
      } | null
    }
  } | null
};

export type UpsertStopAreaMutationVariables = Exact<{
  input: StopRegistryStopPlaceInput;
}>;


export type UpsertStopAreaMutation = {
  readonly __typename?: 'mutation_root',
  readonly stop_registry?: {
    readonly __typename?: 'stop_registryStopPlaceMutation',
    readonly mutateStopPlace?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_StopPlace',
      readonly id?: string | null,
      readonly transportMode?: StopRegistryTransportModeType | null,
      readonly alternativeNames?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_AlternativeName',
        readonly nameType: StopRegistryNameType,
        readonly name: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        }
      } | null> | null,
      readonly privateCode?: {
        readonly __typename?: 'stop_registry_PrivateCode',
        readonly value?: string | null,
        readonly type?: string | null
      } | null,
      readonly name?: {
        readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
        readonly lang?: string | null,
        readonly value?: string | null
      } | null,
      readonly organisations?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_StopPlaceOrganisationRef',
        readonly relationshipType?: StopRegistryStopPlaceOrganisationRelationshipType | null,
        readonly organisationRef: string,
        readonly organisation?: {
          readonly __typename?: 'stop_registry_Organisation',
          readonly id?: string | null,
          readonly name?: string | null,
          readonly privateContactDetails?: {
            readonly __typename?: 'stop_registry_Contact',
            readonly id?: string | null,
            readonly email?: string | null,
            readonly phone?: string | null
          } | null
        } | null
      } | null> | null,
      readonly geometry?: {
        readonly __typename?: 'stop_registry_GeoJSON',
        readonly type?: StopRegistryGeoJsonType | null,
        readonly coordinates?: GeoJSON.Position | null
      } | null,
      readonly keyValues?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_KeyValues',
        readonly key?: string | null,
        readonly values?: ReadonlyArray<string | null> | null
      } | null> | null,
      readonly quays?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_Quay',
        readonly id?: string | null,
        readonly publicCode?: string | null,
        readonly privateCode?: {
          readonly __typename?: 'stop_registry_PrivateCode',
          readonly type?: string | null,
          readonly value?: string | null
        } | null,
        readonly description?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        } | null,
        readonly alternativeNames?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_AlternativeName',
          readonly nameType: StopRegistryNameType,
          readonly name: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly lang?: string | null,
            readonly value?: string | null
          }
        } | null> | null,
        readonly geometry?: {
          readonly __typename?: 'stop_registry_GeoJSON',
          readonly coordinates?: GeoJSON.Position | null,
          readonly type?: StopRegistryGeoJsonType | null
        } | null,
        readonly accessibilityAssessment?: {
          readonly __typename?: 'stop_registry_AccessibilityAssessment',
          readonly id?: string | null,
          readonly hslAccessibilityProperties?: {
            readonly __typename?: 'stop_registry_HslAccessibilityProperties',
            readonly id?: string | null,
            readonly stopAreaSideSlope?: number | null,
            readonly stopAreaLengthwiseSlope?: number | null,
            readonly endRampSlope?: number | null,
            readonly shelterLaneDistance?: number | null,
            readonly curbBackOfRailDistance?: number | null,
            readonly curbDriveSideOfRailDistance?: number | null,
            readonly structureLaneDistance?: number | null,
            readonly stopElevationFromRailTop?: number | null,
            readonly stopElevationFromSidewalk?: number | null,
            readonly lowerCleatHeight?: number | null,
            readonly serviceAreaWidth?: number | null,
            readonly serviceAreaLength?: number | null,
            readonly platformEdgeWarningArea?: boolean | null,
            readonly guidanceTiles?: boolean | null,
            readonly guidanceStripe?: boolean | null,
            readonly serviceAreaStripes?: boolean | null,
            readonly sidewalkAccessibleConnection?: boolean | null,
            readonly stopAreaSurroundingsAccessible?: boolean | null,
            readonly curvedStop?: boolean | null,
            readonly stopType?: StopRegistryStopType | null,
            readonly shelterType?: StopRegistryShelterWidthType | null,
            readonly guidanceType?: StopRegistryGuidanceType | null,
            readonly mapType?: StopRegistryMapType | null,
            readonly pedestrianCrossingRampType?: StopRegistryPedestrianCrossingRampType | null,
            readonly accessibilityLevel?: StopRegistryAccessibilityLevel | null
          } | null,
          readonly limitations?: {
            readonly __typename?: 'stop_registry_AccessibilityLimitations',
            readonly id?: string | null,
            readonly version?: string | null,
            readonly audibleSignalsAvailable?: StopRegistryLimitationStatusType | null,
            readonly escalatorFreeAccess?: StopRegistryLimitationStatusType | null,
            readonly liftFreeAccess?: StopRegistryLimitationStatusType | null,
            readonly stepFreeAccess?: StopRegistryLimitationStatusType | null,
            readonly wheelchairAccess?: StopRegistryLimitationStatusType | null
          } | null
        } | null,
        readonly keyValues?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_KeyValues',
          readonly key?: string | null,
          readonly values?: ReadonlyArray<string | null> | null
        } | null> | null,
        readonly infoSpots?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_infoSpot',
          readonly id?: string | null,
          readonly backlight?: boolean | null,
          readonly displayType?: StopRegistryDisplayType | null,
          readonly floor?: string | null,
          readonly label?: string | null,
          readonly width?: number | null,
          readonly height?: number | null,
          readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
          readonly infoSpotType?: StopRegistryInfoSpotType | null,
          readonly purpose?: string | null,
          readonly railInformation?: string | null,
          readonly speechProperty?: boolean | null,
          readonly zoneLabel?: string | null,
          readonly description?: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly lang?: string | null,
            readonly value?: string | null
          } | null,
          readonly poster?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_poster',
            readonly label?: string | null,
            readonly width?: number | null,
            readonly height?: number | null,
            readonly lines?: string | null
          } | null> | null
        } | null> | null,
        readonly placeEquipments?: {
          readonly __typename?: 'stop_registry_PlaceEquipments',
          readonly id?: string | null,
          readonly shelterEquipment?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_ShelterEquipment',
            readonly id?: string | null,
            readonly enclosed?: boolean | null,
            readonly stepFree?: boolean | null,
            readonly shelterNumber?: number | null,
            readonly shelterType?: StopRegistryShelterType | null,
            readonly shelterElectricity?: StopRegistryShelterElectricity | null,
            readonly shelterLighting?: boolean | null,
            readonly shelterCondition?: StopRegistryShelterCondition | null,
            readonly timetableCabinets?: number | null,
            readonly trashCan?: boolean | null,
            readonly shelterHasDisplay?: boolean | null,
            readonly bicycleParking?: boolean | null,
            readonly leaningRail?: boolean | null,
            readonly outsideBench?: boolean | null,
            readonly shelterFasciaBoardTaping?: boolean | null,
            readonly shelterExternalId?: string | null
          } | null> | null,
          readonly cycleStorageEquipment?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_CycleStorageEquipment',
            readonly cycleStorageType?: StopRegistryCycleStorageType | null
          } | null> | null,
          readonly generalSign?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_GeneralSign',
            readonly signContentType?: StopRegistrySignContentType | null,
            readonly numberOfFrames?: number | null,
            readonly lineSignage?: boolean | null,
            readonly mainLineSign?: boolean | null,
            readonly replacesRailSign?: boolean | null,
            readonly privateCode?: {
              readonly __typename?: 'stop_registry_PrivateCode',
              readonly value?: string | null,
              readonly type?: string | null
            } | null,
            readonly content?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly value?: string | null
            } | null,
            readonly note?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly lang?: string | null,
              readonly value?: string | null
            } | null
          } | null> | null
        } | null,
        readonly scheduled_stop_point?: {
          readonly __typename?: 'service_pattern_scheduled_stop_point',
          readonly priority: number,
          readonly direction: InfrastructureNetworkDirectionEnum,
          readonly scheduled_stop_point_id: UUID,
          readonly label: string,
          readonly timing_place_id?: UUID | null,
          readonly validity_start?: luxon.DateTime | null,
          readonly validity_end?: luxon.DateTime | null,
          readonly located_on_infrastructure_link_id: UUID,
          readonly stop_place_ref?: string | null,
          readonly measured_location: GeoJSON.Point,
          readonly timing_place?: {
            readonly __typename?: 'timing_pattern_timing_place',
            readonly timing_place_id: UUID,
            readonly label: string
          } | null,
          readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
            readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
            readonly vehicle_mode: ReusableComponentsVehicleModeEnum
          }>
        } | null,
        readonly externalLinks?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_externalLink',
          readonly quayId?: number | null,
          readonly orderNum?: number | null,
          readonly name?: string | null,
          readonly location?: string | null
        } | null> | null
      } | null> | null,
      readonly parentStopPlace?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_ParentStopPlace',
        readonly id?: string | null,
        readonly name?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        } | null,
        readonly privateCode?: {
          readonly __typename?: 'stop_registry_PrivateCode',
          readonly value?: string | null,
          readonly type?: string | null
        } | null,
        readonly children?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_StopPlace',
          readonly id?: string | null,
          readonly name?: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly value?: string | null
          } | null,
          readonly privateCode?: {
            readonly __typename?: 'stop_registry_PrivateCode',
            readonly value?: string | null
          } | null,
          readonly quays?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_Quay',
            readonly id?: string | null,
            readonly publicCode?: string | null,
            readonly description?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly lang?: string | null,
              readonly value?: string | null
            } | null,
            readonly scheduled_stop_point?: {
              readonly __typename?: 'service_pattern_scheduled_stop_point',
              readonly priority: number,
              readonly direction: InfrastructureNetworkDirectionEnum,
              readonly scheduled_stop_point_id: UUID,
              readonly label: string,
              readonly timing_place_id?: UUID | null,
              readonly validity_start?: luxon.DateTime | null,
              readonly validity_end?: luxon.DateTime | null,
              readonly located_on_infrastructure_link_id: UUID,
              readonly stop_place_ref?: string | null,
              readonly measured_location: GeoJSON.Point,
              readonly timing_place?: {
                readonly __typename?: 'timing_pattern_timing_place',
                readonly timing_place_id: UUID,
                readonly label: string
              } | null,
              readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
                readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
                readonly vehicle_mode: ReusableComponentsVehicleModeEnum
              }>
            } | null,
            readonly keyValues?: ReadonlyArray<{
              readonly __typename?: 'stop_registry_KeyValues',
              readonly key?: string | null,
              readonly values?: ReadonlyArray<string | null> | null
            } | null> | null,
            readonly infoSpots?: ReadonlyArray<{
              readonly __typename?: 'stop_registry_infoSpot',
              readonly id?: string | null,
              readonly backlight?: boolean | null,
              readonly displayType?: StopRegistryDisplayType | null,
              readonly floor?: string | null,
              readonly label?: string | null,
              readonly width?: number | null,
              readonly height?: number | null,
              readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
              readonly infoSpotType?: StopRegistryInfoSpotType | null,
              readonly purpose?: string | null,
              readonly railInformation?: string | null,
              readonly speechProperty?: boolean | null,
              readonly zoneLabel?: string | null,
              readonly description?: {
                readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
                readonly lang?: string | null,
                readonly value?: string | null
              } | null,
              readonly poster?: ReadonlyArray<{
                readonly __typename?: 'stop_registry_poster',
                readonly label?: string | null,
                readonly width?: number | null,
                readonly height?: number | null,
                readonly lines?: string | null
              } | null> | null
            } | null> | null,
            readonly placeEquipments?: {
              readonly __typename?: 'stop_registry_PlaceEquipments',
              readonly id?: string | null,
              readonly generalSign?: ReadonlyArray<{
                readonly __typename?: 'stop_registry_GeneralSign',
                readonly id?: string | null,
                readonly content?: {
                  readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
                  readonly value?: string | null
                } | null
              } | null> | null,
              readonly shelterEquipment?: ReadonlyArray<{
                readonly __typename?: 'stop_registry_ShelterEquipment',
                readonly id?: string | null,
                readonly shelterNumber?: number | null
              } | null> | null
            } | null
          } | null> | null
        } | null> | null
      } | {
        readonly __typename?: 'stop_registry_StopPlace'
      } | null> | null,
      readonly accessibilityAssessment?: {
        readonly __typename?: 'stop_registry_AccessibilityAssessment',
        readonly id?: string | null,
        readonly hslAccessibilityProperties?: {
          readonly __typename?: 'stop_registry_HslAccessibilityProperties',
          readonly id?: string | null,
          readonly stopAreaSideSlope?: number | null,
          readonly stopAreaLengthwiseSlope?: number | null,
          readonly endRampSlope?: number | null,
          readonly shelterLaneDistance?: number | null,
          readonly curbBackOfRailDistance?: number | null,
          readonly curbDriveSideOfRailDistance?: number | null,
          readonly structureLaneDistance?: number | null,
          readonly stopElevationFromRailTop?: number | null,
          readonly stopElevationFromSidewalk?: number | null,
          readonly lowerCleatHeight?: number | null,
          readonly serviceAreaWidth?: number | null,
          readonly serviceAreaLength?: number | null,
          readonly platformEdgeWarningArea?: boolean | null,
          readonly guidanceTiles?: boolean | null,
          readonly guidanceStripe?: boolean | null,
          readonly serviceAreaStripes?: boolean | null,
          readonly sidewalkAccessibleConnection?: boolean | null,
          readonly stopAreaSurroundingsAccessible?: boolean | null,
          readonly curvedStop?: boolean | null,
          readonly stopType?: StopRegistryStopType | null,
          readonly shelterType?: StopRegistryShelterWidthType | null,
          readonly guidanceType?: StopRegistryGuidanceType | null,
          readonly mapType?: StopRegistryMapType | null,
          readonly pedestrianCrossingRampType?: StopRegistryPedestrianCrossingRampType | null,
          readonly accessibilityLevel?: StopRegistryAccessibilityLevel | null
        } | null,
        readonly limitations?: {
          readonly __typename?: 'stop_registry_AccessibilityLimitations',
          readonly id?: string | null,
          readonly version?: string | null,
          readonly audibleSignalsAvailable?: StopRegistryLimitationStatusType | null,
          readonly escalatorFreeAccess?: StopRegistryLimitationStatusType | null,
          readonly liftFreeAccess?: StopRegistryLimitationStatusType | null,
          readonly stepFreeAccess?: StopRegistryLimitationStatusType | null,
          readonly wheelchairAccess?: StopRegistryLimitationStatusType | null
        } | null
      } | null,
      readonly topographicPlace?: {
        readonly __typename?: 'stop_registry_TopographicPlace',
        readonly id?: string | null,
        readonly name?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly value?: string | null,
          readonly lang?: string | null
        } | null
      } | null,
      readonly fareZones?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_FareZone',
        readonly id?: string | null,
        readonly name?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly value?: string | null,
          readonly lang?: string | null
        } | null
      } | null> | null
    } | null> | null
  } | null
};

export type StopFormStopAreaInfoFragment = {
  readonly __typename?: 'stops_database_stop_place_newest_version',
  readonly id?: any | null,
  readonly netextId?: string | null,
  readonly privateCode?: string | null,
  readonly validityStart?: string | null,
  readonly validityEnd?: string | null,
  readonly nameValue?: string | null,
  readonly nameLang?: string | null,
  readonly alternativeNames: ReadonlyArray<{
    readonly __typename?: 'stops_database_stop_place_alternative_names',
    readonly name: {
      readonly __typename?: 'stops_database_alternative_name',
      readonly type?: string | null,
      readonly value?: string | null,
      readonly lang?: string | null
    }
  }>
};

export type FindStopAreasByNamesQueryVariables = Exact<{
  query: Scalars['String']['input'];
}>;


export type FindStopAreasByNamesQuery = {
  readonly __typename?: 'query_root',
  readonly stops_database?: {
    readonly __typename?: 'stops_database_stops_database_query',
    readonly areas: ReadonlyArray<{
      readonly __typename?: 'stops_database_stop_place_newest_version',
      readonly id?: any | null,
      readonly netextId?: string | null,
      readonly privateCode?: string | null,
      readonly validityStart?: string | null,
      readonly validityEnd?: string | null,
      readonly nameValue?: string | null,
      readonly nameLang?: string | null,
      readonly alternativeNames: ReadonlyArray<{
        readonly __typename?: 'stops_database_stop_place_alternative_names',
        readonly name: {
          readonly __typename?: 'stops_database_alternative_name',
          readonly type?: string | null,
          readonly value?: string | null,
          readonly lang?: string | null
        }
      }>
    }>
  } | null
};

export type GetExistingQuayPublicCodesQueryVariables = Exact<{
  newStopLocation: Scalars['geometry']['input'];
  distanceToNearbyStops: Scalars['Float']['input'];
}>;


export type GetExistingQuayPublicCodesQuery = {
  readonly __typename?: 'query_root',
  readonly stopsDatabase?: {
    readonly __typename?: 'stops_database_stops_database_query',
    readonly municipality: ReadonlyArray<{
      readonly __typename?: 'stops_database_topographic_place',
      readonly id: any,
      readonly name?: string | null
    }>,
    readonly usedPublicCodes: ReadonlyArray<{
      readonly __typename?: 'stops_database_quay',
      readonly id: any,
      readonly publicCode?: string | null
    }>,
    readonly nearbyStops: ReadonlyArray<{
      readonly __typename?: 'stops_database_quay',
      readonly id: any,
      readonly centroid?: GeoJSON.Geometry | null,
      readonly publicCode?: string | null
    }>
  } | null
};

export type GetStopInfoForEditingOnMapQueryVariables = Exact<{
  quayNetexId: Scalars['String']['input'];
}>;


export type GetStopInfoForEditingOnMapQuery = {
  readonly __typename?: 'query_root',
  readonly stops_database?: {
    readonly __typename?: 'stops_database_stops_database_query',
    readonly quay: ReadonlyArray<{
      readonly __typename?: 'stops_database_quay_newest_version',
      readonly id?: any | null,
      readonly centroid?: GeoJSON.Geometry | null,
      readonly priority?: string | null,
      readonly netextId?: string | null,
      readonly label?: string | null,
      readonly versionName?: string | null,
      readonly locationValue?: string | null,
      readonly locationLang?: string | null,
      readonly validityStart?: string | null,
      readonly validityEnd?: string | null,
      readonly alternativeLocations: ReadonlyArray<{
        readonly __typename?: 'stops_database_quay_alternative_names',
        readonly location: {
          readonly __typename?: 'stops_database_alternative_name',
          readonly type?: string | null,
          readonly lang?: string | null,
          readonly value?: string | null
        }
      }>,
      readonly keyValues: ReadonlyArray<{
        readonly __typename?: 'stops_database_quay_key_values',
        readonly key: string,
        readonly values: {
          readonly __typename?: 'stops_database_value',
          readonly valueItems: ReadonlyArray<{
            readonly __typename?: 'stops_database_value_items',
            readonly items?: string | null
          }>
        }
      }>,
      readonly stopPlace?: {
        readonly __typename?: 'stops_database_stop_place_newest_version',
        readonly id?: any | null,
        readonly netextId?: string | null,
        readonly privateCode?: string | null,
        readonly validityStart?: string | null,
        readonly validityEnd?: string | null,
        readonly nameValue?: string | null,
        readonly nameLang?: string | null,
        readonly alternativeNames: ReadonlyArray<{
          readonly __typename?: 'stops_database_stop_place_alternative_names',
          readonly name: {
            readonly __typename?: 'stops_database_alternative_name',
            readonly type?: string | null,
            readonly value?: string | null,
            readonly lang?: string | null
          }
        }>
      } | null,
      readonly stopPoint?: {
        readonly __typename?: 'service_pattern_scheduled_stop_point',
        readonly id: UUID,
        readonly closestPointOnInfraLink?: GeoJSON.Point | null,
        readonly timingPlace?: {
          readonly __typename?: 'timing_pattern_timing_place',
          readonly label: string,
          readonly id: UUID
        } | null
      } | null
    }>
  } | null
};

export type StopInfoTimingPlaceInfoFragment = {
  readonly __typename?: 'timing_pattern_timing_place',
  readonly label: string,
  readonly id: UUID
};

export type GetStopAreasByLocationQueryVariables = Exact<{
  locationFilter?: InputMaybe<GeometryComparisonExp>;
}>;


export type GetStopAreasByLocationQuery = {
  readonly __typename?: 'query_root',
  readonly stops_database?: {
    readonly __typename?: 'stops_database_stops_database_query',
    readonly areas: ReadonlyArray<{
      readonly __typename?: 'stops_database_stop_place_newest_version',
      readonly id?: any | null,
      readonly netex_id?: string | null,
      readonly private_code_value?: string | null,
      readonly centroid?: GeoJSON.Geometry | null,
      readonly name_value?: string | null
    }>
  } | null
};

export type MapMinimalStopAreaDetailsFragment = {
  readonly __typename?: 'stops_database_stop_place_newest_version',
  readonly id?: any | null,
  readonly netex_id?: string | null,
  readonly private_code_value?: string | null,
  readonly centroid?: GeoJSON.Geometry | null,
  readonly name_value?: string | null
};

export type GetMapStopsQueryVariables = Exact<{
  where?: InputMaybe<StopsDatabaseQuayNewestVersionBoolExp>;
}>;


export type GetMapStopsQuery = {
  readonly __typename?: 'query_root',
  readonly stops_database?: {
    readonly __typename?: 'stops_database_stops_database_query',
    readonly stops: ReadonlyArray<{
      readonly __typename?: 'stops_database_quay_newest_version',
      readonly id?: any | null,
      readonly netex_id?: string | null,
      readonly stop_place_netex_id?: string | null,
      readonly validity_start?: string | null,
      readonly validity_end?: string | null,
      readonly priority?: string | null,
      readonly centroid?: GeoJSON.Geometry | null,
      readonly functional_area?: string | null,
      readonly label?: string | null
    }>
  } | null
};

export type MapStopMinimalDetailsFragment = {
  readonly __typename?: 'stops_database_quay_newest_version',
  readonly id?: any | null,
  readonly netex_id?: string | null,
  readonly stop_place_netex_id?: string | null,
  readonly validity_start?: string | null,
  readonly validity_end?: string | null,
  readonly priority?: string | null,
  readonly centroid?: GeoJSON.Geometry | null,
  readonly functional_area?: string | null,
  readonly label?: string | null
};

export type GetStopTerminalsByLocationQueryVariables = Exact<{
  locationFilter?: InputMaybe<GeometryComparisonExp>;
}>;


export type GetStopTerminalsByLocationQuery = {
  readonly __typename?: 'query_root',
  readonly stops_database?: {
    readonly __typename?: 'stops_database_stops_database_query',
    readonly terminals: ReadonlyArray<{
      readonly __typename?: 'stops_database_stop_place_newest_version',
      readonly id?: any | null,
      readonly netex_id?: string | null,
      readonly private_code_value?: string | null,
      readonly centroid?: GeoJSON.Geometry | null,
      readonly name_value?: string | null,
      readonly children: ReadonlyArray<{
        readonly __typename?: 'stops_database_stop_place_children',
        readonly children_id: any,
        readonly stop_place_id: any,
        readonly child: {
          readonly __typename?: 'stops_database_stop_place',
          readonly id: any,
          readonly netexId?: string | null
        }
      }>
    }>
  } | null
};

export type MapMinimalTerminalDetailsFragment = {
  readonly __typename?: 'stops_database_stop_place_newest_version',
  readonly id?: any | null,
  readonly netex_id?: string | null,
  readonly private_code_value?: string | null,
  readonly centroid?: GeoJSON.Geometry | null,
  readonly name_value?: string | null,
  readonly children: ReadonlyArray<{
    readonly __typename?: 'stops_database_stop_place_children',
    readonly children_id: any,
    readonly stop_place_id: any,
    readonly child: {
      readonly __typename?: 'stops_database_stop_place',
      readonly id: any,
      readonly netexId?: string | null
    }
  }>
};

export type GetTerminalDetailsByNetexIdQueryVariables = Exact<{
  netexId: Scalars['String']['input'];
}>;


export type GetTerminalDetailsByNetexIdQuery = {
  readonly __typename?: 'query_root',
  readonly stop_registry?: {
    readonly __typename?: 'stop_registryStopPlaceRegister',
    readonly stopPlace?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_ParentStopPlace',
      readonly id?: string | null,
      readonly alternativeNames?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_AlternativeName',
        readonly nameType: StopRegistryNameType,
        readonly name: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        }
      } | null> | null,
      readonly privateCode?: {
        readonly __typename?: 'stop_registry_PrivateCode',
        readonly value?: string | null,
        readonly type?: string | null
      } | null,
      readonly name?: {
        readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
        readonly lang?: string | null,
        readonly value?: string | null
      } | null,
      readonly description?: {
        readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
        readonly lang?: string | null,
        readonly value?: string | null
      } | null,
      readonly geometry?: {
        readonly __typename?: 'stop_registry_GeoJSON',
        readonly type?: StopRegistryGeoJsonType | null,
        readonly coordinates?: GeoJSON.Position | null
      } | null,
      readonly topographicPlace?: {
        readonly __typename?: 'stop_registry_TopographicPlace',
        readonly name?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly value?: string | null
        } | null
      } | null,
      readonly fareZones?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_FareZone',
        readonly name?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly value?: string | null
        } | null
      } | null> | null,
      readonly keyValues?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_KeyValues',
        readonly key?: string | null,
        readonly values?: ReadonlyArray<string | null> | null
      } | null> | null,
      readonly infoSpots?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_infoSpot',
        readonly id?: string | null,
        readonly backlight?: boolean | null,
        readonly displayType?: StopRegistryDisplayType | null,
        readonly floor?: string | null,
        readonly label?: string | null,
        readonly width?: number | null,
        readonly height?: number | null,
        readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
        readonly infoSpotType?: StopRegistryInfoSpotType | null,
        readonly purpose?: string | null,
        readonly railInformation?: string | null,
        readonly speechProperty?: boolean | null,
        readonly zoneLabel?: string | null,
        readonly description?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        } | null,
        readonly poster?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_poster',
          readonly label?: string | null,
          readonly width?: number | null,
          readonly height?: number | null,
          readonly lines?: string | null
        } | null> | null
      } | null> | null,
      readonly accessibilityAssessment?: {
        readonly __typename?: 'stop_registry_AccessibilityAssessment',
        readonly id?: string | null,
        readonly hslAccessibilityProperties?: {
          readonly __typename?: 'stop_registry_HslAccessibilityProperties',
          readonly id?: string | null,
          readonly stopAreaSideSlope?: number | null,
          readonly stopAreaLengthwiseSlope?: number | null,
          readonly endRampSlope?: number | null,
          readonly shelterLaneDistance?: number | null,
          readonly curbBackOfRailDistance?: number | null,
          readonly curbDriveSideOfRailDistance?: number | null,
          readonly structureLaneDistance?: number | null,
          readonly stopElevationFromRailTop?: number | null,
          readonly stopElevationFromSidewalk?: number | null,
          readonly lowerCleatHeight?: number | null,
          readonly serviceAreaWidth?: number | null,
          readonly serviceAreaLength?: number | null,
          readonly platformEdgeWarningArea?: boolean | null,
          readonly guidanceTiles?: boolean | null,
          readonly guidanceStripe?: boolean | null,
          readonly serviceAreaStripes?: boolean | null,
          readonly sidewalkAccessibleConnection?: boolean | null,
          readonly stopAreaSurroundingsAccessible?: boolean | null,
          readonly curvedStop?: boolean | null,
          readonly stopType?: StopRegistryStopType | null,
          readonly shelterType?: StopRegistryShelterWidthType | null,
          readonly guidanceType?: StopRegistryGuidanceType | null,
          readonly mapType?: StopRegistryMapType | null,
          readonly pedestrianCrossingRampType?: StopRegistryPedestrianCrossingRampType | null,
          readonly accessibilityLevel?: StopRegistryAccessibilityLevel | null
        } | null,
        readonly limitations?: {
          readonly __typename?: 'stop_registry_AccessibilityLimitations',
          readonly id?: string | null,
          readonly version?: string | null,
          readonly audibleSignalsAvailable?: StopRegistryLimitationStatusType | null,
          readonly escalatorFreeAccess?: StopRegistryLimitationStatusType | null,
          readonly liftFreeAccess?: StopRegistryLimitationStatusType | null,
          readonly stepFreeAccess?: StopRegistryLimitationStatusType | null,
          readonly wheelchairAccess?: StopRegistryLimitationStatusType | null
        } | null
      } | null,
      readonly children?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_StopPlace',
        readonly id?: string | null,
        readonly name?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly value?: string | null
        } | null,
        readonly privateCode?: {
          readonly __typename?: 'stop_registry_PrivateCode',
          readonly value?: string | null
        } | null,
        readonly quays?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_Quay',
          readonly id?: string | null,
          readonly publicCode?: string | null,
          readonly description?: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly lang?: string | null,
            readonly value?: string | null
          } | null,
          readonly scheduled_stop_point?: {
            readonly __typename?: 'service_pattern_scheduled_stop_point',
            readonly priority: number,
            readonly direction: InfrastructureNetworkDirectionEnum,
            readonly scheduled_stop_point_id: UUID,
            readonly label: string,
            readonly timing_place_id?: UUID | null,
            readonly validity_start?: luxon.DateTime | null,
            readonly validity_end?: luxon.DateTime | null,
            readonly located_on_infrastructure_link_id: UUID,
            readonly stop_place_ref?: string | null,
            readonly measured_location: GeoJSON.Point,
            readonly timing_place?: {
              readonly __typename?: 'timing_pattern_timing_place',
              readonly timing_place_id: UUID,
              readonly label: string
            } | null,
            readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
              readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
              readonly vehicle_mode: ReusableComponentsVehicleModeEnum
            }>
          } | null,
          readonly keyValues?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_KeyValues',
            readonly key?: string | null,
            readonly values?: ReadonlyArray<string | null> | null
          } | null> | null,
          readonly infoSpots?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_infoSpot',
            readonly id?: string | null,
            readonly backlight?: boolean | null,
            readonly displayType?: StopRegistryDisplayType | null,
            readonly floor?: string | null,
            readonly label?: string | null,
            readonly width?: number | null,
            readonly height?: number | null,
            readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
            readonly infoSpotType?: StopRegistryInfoSpotType | null,
            readonly purpose?: string | null,
            readonly railInformation?: string | null,
            readonly speechProperty?: boolean | null,
            readonly zoneLabel?: string | null,
            readonly description?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly lang?: string | null,
              readonly value?: string | null
            } | null,
            readonly poster?: ReadonlyArray<{
              readonly __typename?: 'stop_registry_poster',
              readonly label?: string | null,
              readonly width?: number | null,
              readonly height?: number | null,
              readonly lines?: string | null
            } | null> | null
          } | null> | null,
          readonly placeEquipments?: {
            readonly __typename?: 'stop_registry_PlaceEquipments',
            readonly id?: string | null,
            readonly generalSign?: ReadonlyArray<{
              readonly __typename?: 'stop_registry_GeneralSign',
              readonly id?: string | null,
              readonly content?: {
                readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
                readonly value?: string | null
              } | null
            } | null> | null,
            readonly shelterEquipment?: ReadonlyArray<{
              readonly __typename?: 'stop_registry_ShelterEquipment',
              readonly id?: string | null,
              readonly shelterNumber?: number | null
            } | null> | null
          } | null
        } | null> | null
      } | null> | null,
      readonly externalLinks?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_stopPlaceExternalLink',
        readonly stopPlaceId?: number | null,
        readonly orderNum?: number | null,
        readonly name?: string | null,
        readonly location?: string | null
      } | null> | null,
      readonly organisations?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_StopPlaceOrganisationRef',
        readonly organisationRef: string,
        readonly relationshipType?: StopRegistryStopPlaceOrganisationRelationshipType | null,
        readonly organisation?: {
          readonly __typename?: 'stop_registry_Organisation',
          readonly id?: string | null,
          readonly name?: string | null,
          readonly privateContactDetails?: {
            readonly __typename?: 'stop_registry_Contact',
            readonly id?: string | null,
            readonly email?: string | null,
            readonly phone?: string | null
          } | null
        } | null
      } | null> | null
    } | {
      readonly __typename?: 'stop_registry_StopPlace'
    } | null> | null
  } | null
};

export type ResolveStopNameQueryVariables = Exact<{
  stopPlaceNetexId: Scalars['String']['input'];
}>;


export type ResolveStopNameQuery = {
  readonly __typename?: 'query_root',
  readonly stops_database?: {
    readonly __typename?: 'stops_database_stops_database_query',
    readonly stops_database_stop_place_newest_version: ReadonlyArray<{
      readonly __typename?: 'stops_database_stop_place_newest_version',
      readonly id?: any | null,
      readonly name_value?: string | null
    }>
  } | null
};

export type LineWithRoutesUniqueFieldsFragment = {
  readonly __typename?: 'route_line',
  readonly primary_vehicle_mode: ReusableComponentsVehicleModeEnum,
  readonly type_of_line: RouteTypeOfLineEnum,
  readonly transport_target: HslRouteTransportTargetEnum,
  readonly line_id: UUID,
  readonly label: string,
  readonly name_i18n: LocalizedString,
  readonly short_name_i18n: LocalizedString,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly priority: number,
  readonly line_routes: ReadonlyArray<{
    readonly __typename?: 'route_route',
    readonly label: string,
    readonly direction: RouteDirectionEnum,
    readonly variant?: number | null,
    readonly route_id: UUID,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly priority: number
  }>
};

export type ListChangingRoutesQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type ListChangingRoutesQuery = {
  readonly __typename?: 'query_root',
  readonly route_route: ReadonlyArray<{
    readonly __typename?: 'route_route',
    readonly name_i18n: LocalizedString,
    readonly direction: RouteDirectionEnum,
    readonly priority: number,
    readonly on_line_id: UUID,
    readonly variant?: number | null,
    readonly unique_label: string,
    readonly route_id: UUID,
    readonly label: string,
    readonly route_shape?: GeoJSON.LineString | null,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly route_journey_patterns: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly journey_pattern_refs: ReadonlyArray<{
        readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref',
        readonly journey_pattern_ref_id: UUID,
        readonly vehicle_journeys: ReadonlyArray<{
          readonly __typename?: 'timetables_vehicle_journey_vehicle_journey',
          readonly vehicle_journey_id: UUID
        }>
      }>,
      readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
        readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly scheduled_stop_point_sequence: number,
        readonly is_used_as_timing_point: boolean
      }>
    }>
  }>
};

export type ListOwnLinesQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type ListOwnLinesQuery = {
  readonly __typename?: 'query_root',
  readonly route_line: ReadonlyArray<{
    readonly __typename?: 'route_line',
    readonly name_i18n: LocalizedString,
    readonly short_name_i18n: LocalizedString,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly priority: number,
    readonly line_id: UUID,
    readonly label: string,
    readonly line_routes: ReadonlyArray<{
      readonly __typename?: 'route_route',
      readonly unique_label: string,
      readonly direction: RouteDirectionEnum,
      readonly route_id: UUID,
      readonly route_shape?: GeoJSON.LineString | null,
      readonly label: string,
      readonly validity_start?: luxon.DateTime | null,
      readonly validity_end?: luxon.DateTime | null,
      readonly route_journey_patterns: ReadonlyArray<{
        readonly __typename?: 'journey_pattern_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly journey_pattern_refs: ReadonlyArray<{
          readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref',
          readonly journey_pattern_ref_id: UUID,
          readonly vehicle_journeys: ReadonlyArray<{
            readonly __typename?: 'timetables_vehicle_journey_vehicle_journey',
            readonly vehicle_journey_id: UUID
          }>
        }>,
        readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
          readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
          readonly journey_pattern_id: UUID,
          readonly scheduled_stop_point_sequence: number,
          readonly is_used_as_timing_point: boolean
        }>
      }>
    }>
  }>
};

export type ScheduledStopPointWithTimingSettingsFragment = {
  readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
  readonly journey_pattern_id: UUID,
  readonly scheduled_stop_point_label: string,
  readonly scheduled_stop_point_sequence: number,
  readonly is_used_as_timing_point: boolean,
  readonly is_regulated_timing_point: boolean,
  readonly is_loading_time_allowed: boolean,
  readonly is_via_point: boolean,
  readonly via_point_name_i18n?: LocalizedString | null,
  readonly via_point_short_name_i18n?: LocalizedString | null,
  readonly journey_pattern: {
    readonly __typename?: 'journey_pattern_journey_pattern',
    readonly journey_pattern_id: UUID,
    readonly on_route_id: UUID,
    readonly journey_pattern_route?: {
      readonly __typename?: 'route_route',
      readonly route_id: UUID,
      readonly label: string
    } | null
  },
  readonly scheduled_stop_points: ReadonlyArray<{
    readonly __typename?: 'service_pattern_scheduled_stop_point',
    readonly scheduled_stop_point_id: UUID,
    readonly timing_place_id?: UUID | null
  }>
};

export type GetScheduledStopPointWithTimingSettingsQueryVariables = Exact<{
  journeyPatternId: Scalars['uuid']['input'];
  stopLabel: Scalars['String']['input'];
  sequence: Scalars['Int']['input'];
}>;


export type GetScheduledStopPointWithTimingSettingsQuery = {
  readonly __typename?: 'query_root',
  readonly journey_pattern_scheduled_stop_point_in_journey_pattern: ReadonlyArray<{
    readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
    readonly journey_pattern_id: UUID,
    readonly scheduled_stop_point_label: string,
    readonly scheduled_stop_point_sequence: number,
    readonly is_used_as_timing_point: boolean,
    readonly is_regulated_timing_point: boolean,
    readonly is_loading_time_allowed: boolean,
    readonly is_via_point: boolean,
    readonly via_point_name_i18n?: LocalizedString | null,
    readonly via_point_short_name_i18n?: LocalizedString | null,
    readonly journey_pattern: {
      readonly __typename?: 'journey_pattern_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly on_route_id: UUID,
      readonly journey_pattern_route?: {
        readonly __typename?: 'route_route',
        readonly route_id: UUID,
        readonly label: string
      } | null
    },
    readonly scheduled_stop_points: ReadonlyArray<{
      readonly __typename?: 'service_pattern_scheduled_stop_point',
      readonly scheduled_stop_point_id: UUID,
      readonly timing_place_id?: UUID | null
    }>
  }>
};

export type FindQuaysByQueryQueryVariables = Exact<{
  cursor: Scalars['bigint']['input'];
  limit: Scalars['Int']['input'];
  query: Scalars['String']['input'];
}>;


export type FindQuaysByQueryQuery = {
  readonly __typename?: 'query_root',
  readonly stops_database?: {
    readonly __typename?: 'stops_database_stops_database_query',
    readonly findStopsForTerminal: ReadonlyArray<{
      readonly __typename?: 'TerminalStopSearchResult',
      readonly cursor: any,
      readonly stops: any
    }>
  } | null
};

export type DoesStopHaveNextValidAlternativeQueryVariables = Exact<{
  label: Scalars['String']['input'];
  validAfter: Scalars['date']['input'];
  validPriorities: ReadonlyArray<Scalars['Int']['input']> | Scalars['Int']['input'];
}>;


export type DoesStopHaveNextValidAlternativeQuery = {
  readonly __typename?: 'query_root',
  readonly stopPoint: {
    readonly __typename?: 'service_pattern_scheduled_stop_point_aggregate',
    readonly aggregate?: {
      readonly __typename?: 'service_pattern_scheduled_stop_point_aggregate_fields',
      readonly count: number
    } | null
  }
};

export type FindLinesByStopSearchQueryVariables = Exact<{
  query: Scalars['String']['input'];
  validOn: Scalars['date']['input'];
}>;


export type FindLinesByStopSearchQuery = {
  readonly __typename?: 'query_root',
  readonly route_line: ReadonlyArray<{
    readonly __typename?: 'route_line',
    readonly line_id: UUID,
    readonly label: string,
    readonly name_i18n: LocalizedString,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly line_routes: ReadonlyArray<{
      readonly __typename?: 'route_route',
      readonly route_id: UUID,
      readonly label: string,
      readonly name_i18n: LocalizedString,
      readonly direction: RouteDirectionEnum,
      readonly priority: number,
      readonly validity_start?: luxon.DateTime | null,
      readonly validity_end?: luxon.DateTime | null
    }>
  }>
};

export type FindStopByLineInfoFragment = {
  readonly __typename?: 'route_line',
  readonly line_id: UUID,
  readonly label: string,
  readonly name_i18n: LocalizedString,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly line_routes: ReadonlyArray<{
    readonly __typename?: 'route_route',
    readonly route_id: UUID,
    readonly label: string,
    readonly name_i18n: LocalizedString,
    readonly direction: RouteDirectionEnum,
    readonly priority: number,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null
  }>
};

export type FindStopByLineRouteInfoFragment = {
  readonly __typename?: 'route_route',
  readonly route_id: UUID,
  readonly label: string,
  readonly name_i18n: LocalizedString,
  readonly direction: RouteDirectionEnum,
  readonly priority: number,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null
};

export type GetLineRouteStopCountsQueryVariables = Exact<{
  inboundRoute: Scalars['uuid']['input'];
  outboundRoute: Scalars['uuid']['input'];
}>;


export type GetLineRouteStopCountsQuery = {
  readonly __typename?: 'query_root',
  readonly combinedStopPoints: {
    readonly __typename?: 'service_pattern_scheduled_stop_point_aggregate',
    readonly aggregate?: {
      readonly __typename?: 'service_pattern_scheduled_stop_point_aggregate_fields',
      readonly count: number
    } | null
  },
  readonly inboundStopPoints: {
    readonly __typename?: 'service_pattern_scheduled_stop_point_aggregate',
    readonly aggregate?: {
      readonly __typename?: 'service_pattern_scheduled_stop_point_aggregate_fields',
      readonly count: number
    } | null
  },
  readonly outboundStopPoints: {
    readonly __typename?: 'service_pattern_scheduled_stop_point_aggregate',
    readonly aggregate?: {
      readonly __typename?: 'service_pattern_scheduled_stop_point_aggregate_fields',
      readonly count: number
    } | null
  }
};

export type GetStopsByRouteIdQueryVariables = Exact<{
  routeId: Scalars['uuid']['input'];
}>;


export type GetStopsByRouteIdQuery = {
  readonly __typename?: 'query_root',
  readonly stopPoints: ReadonlyArray<{
    readonly __typename?: 'service_pattern_scheduled_stop_point',
    readonly scheduled_stop_point_id: UUID,
    readonly label: string,
    readonly measured_location: GeoJSON.Point,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly timing_place_id?: UUID | null,
    readonly priority: number,
    readonly quay?: {
      readonly __typename?: 'stops_database_quay_newest_version',
      readonly id?: any | null,
      readonly netex_id?: string | null,
      readonly stop_place?: {
        readonly __typename?: 'stops_database_stop_place',
        readonly name_lang?: string | null,
        readonly name_value?: string | null,
        readonly stop_place_alternative_names: ReadonlyArray<{
          readonly __typename?: 'stops_database_stop_place_alternative_names',
          readonly alternative_name: {
            readonly __typename?: 'stops_database_alternative_name',
            readonly name_lang?: string | null,
            readonly name_type?: string | null,
            readonly name_value?: string | null
          }
        }>
      } | null
    } | null,
    readonly journeyPatterns: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly sequence: number
    }>,
    readonly timing_place?: {
      readonly __typename?: 'timing_pattern_timing_place',
      readonly timing_place_id: UUID,
      readonly label: string
    } | null
  }>
};

export type GetStopByRouteIdSearchResultFragment = {
  readonly __typename?: 'service_pattern_scheduled_stop_point',
  readonly scheduled_stop_point_id: UUID,
  readonly label: string,
  readonly measured_location: GeoJSON.Point,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly timing_place_id?: UUID | null,
  readonly priority: number,
  readonly quay?: {
    readonly __typename?: 'stops_database_quay_newest_version',
    readonly id?: any | null,
    readonly netex_id?: string | null,
    readonly stop_place?: {
      readonly __typename?: 'stops_database_stop_place',
      readonly name_lang?: string | null,
      readonly name_value?: string | null,
      readonly stop_place_alternative_names: ReadonlyArray<{
        readonly __typename?: 'stops_database_stop_place_alternative_names',
        readonly alternative_name: {
          readonly __typename?: 'stops_database_alternative_name',
          readonly name_lang?: string | null,
          readonly name_type?: string | null,
          readonly name_value?: string | null
        }
      }>
    } | null
  } | null,
  readonly journeyPatterns: ReadonlyArray<{
    readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
    readonly journey_pattern_id: UUID,
    readonly sequence: number
  }>,
  readonly timing_place?: {
    readonly __typename?: 'timing_pattern_timing_place',
    readonly timing_place_id: UUID,
    readonly label: string
  } | null
};

export type ResolveStopPlaceNetextIdsByLineIdsQueryVariables = Exact<{
  routeIds: ReadonlyArray<Scalars['uuid']['input']> | Scalars['uuid']['input'];
}>;


export type ResolveStopPlaceNetextIdsByLineIdsQuery = {
  readonly __typename?: 'query_root',
  readonly stopPoints: ReadonlyArray<{
    readonly __typename?: 'service_pattern_scheduled_stop_point',
    readonly scheduled_stop_point_id: UUID,
    readonly stop_place_ref?: string | null
  }>
};

export type FindStopAreasQueryVariables = Exact<{
  query: Scalars['String']['input'];
  validOn: Scalars['String']['input'];
}>;


export type FindStopAreasQuery = {
  readonly __typename?: 'query_root',
  readonly stops_database?: {
    readonly __typename?: 'stops_database_stops_database_query',
    readonly stopAreas: ReadonlyArray<{
      readonly __typename?: 'stops_database_stop_place_newest_version',
      readonly id?: any | null,
      readonly netex_id?: string | null,
      readonly version?: any | null,
      readonly name_lang?: string | null,
      readonly name_value?: string | null,
      readonly centroid?: GeoJSON.Geometry | null,
      readonly private_code?: string | null
    }>
  } | null
};

export type FindStopAreaInfoFragment = {
  readonly __typename?: 'stops_database_stop_place_newest_version',
  readonly id?: any | null,
  readonly netex_id?: string | null,
  readonly version?: any | null,
  readonly name_lang?: string | null,
  readonly name_value?: string | null,
  readonly centroid?: GeoJSON.Geometry | null,
  readonly private_code?: string | null
};

export type GetStopsByStopAreaIdQueryVariables = Exact<{
  stopAreaId: Scalars['bigint']['input'];
}>;


export type GetStopsByStopAreaIdQuery = {
  readonly __typename?: 'query_root',
  readonly stops_database?: {
    readonly __typename?: 'stops_database_stops_database_query',
    readonly quays: ReadonlyArray<{
      readonly __typename?: 'stops_database_quay_newest_version',
      readonly id?: any | null,
      readonly netex_id?: string | null,
      readonly scheduled_stop_point_instance?: {
        readonly __typename?: 'service_pattern_scheduled_stop_point',
        readonly scheduled_stop_point_id: UUID,
        readonly label: string,
        readonly measured_location: GeoJSON.Point,
        readonly validity_start?: luxon.DateTime | null,
        readonly validity_end?: luxon.DateTime | null,
        readonly timing_place_id?: UUID | null,
        readonly priority: number,
        readonly timing_place?: {
          readonly __typename?: 'timing_pattern_timing_place',
          readonly timing_place_id: UUID,
          readonly label: string
        } | null
      } | null,
      readonly stop_place?: {
        readonly __typename?: 'stops_database_stop_place',
        readonly name_lang?: string | null,
        readonly name_value?: string | null,
        readonly stop_place_alternative_names: ReadonlyArray<{
          readonly __typename?: 'stops_database_stop_place_alternative_names',
          readonly alternative_name: {
            readonly __typename?: 'stops_database_alternative_name',
            readonly name_lang?: string | null,
            readonly name_type?: string | null,
            readonly name_value?: string | null
          }
        }>
      } | null
    }>
  } | null
};

export type StopTableRowFragment = {
  readonly __typename?: 'service_pattern_scheduled_stop_point',
  readonly scheduled_stop_point_id: UUID,
  readonly label: string,
  readonly measured_location: GeoJSON.Point,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly timing_place_id?: UUID | null,
  readonly priority: number,
  readonly timing_place?: {
    readonly __typename?: 'timing_pattern_timing_place',
    readonly timing_place_id: UUID,
    readonly label: string
  } | null
};

export type StopTableRowQuayBaseDetailsFragment = {
  readonly __typename?: 'stops_database_quay_newest_version',
  readonly id?: any | null,
  readonly netex_id?: string | null,
  readonly stop_place?: {
    readonly __typename?: 'stops_database_stop_place',
    readonly name_lang?: string | null,
    readonly name_value?: string | null,
    readonly stop_place_alternative_names: ReadonlyArray<{
      readonly __typename?: 'stops_database_stop_place_alternative_names',
      readonly alternative_name: {
        readonly __typename?: 'stops_database_alternative_name',
        readonly name_lang?: string | null,
        readonly name_type?: string | null,
        readonly name_value?: string | null
      }
    }>
  } | null
};

export type StopTableRowQuayFragment = {
  readonly __typename?: 'stops_database_quay_newest_version',
  readonly id?: any | null,
  readonly netex_id?: string | null,
  readonly scheduled_stop_point_instance?: {
    readonly __typename?: 'service_pattern_scheduled_stop_point',
    readonly scheduled_stop_point_id: UUID,
    readonly label: string,
    readonly measured_location: GeoJSON.Point,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly timing_place_id?: UUID | null,
    readonly priority: number,
    readonly timing_place?: {
      readonly __typename?: 'timing_pattern_timing_place',
      readonly timing_place_id: UUID,
      readonly label: string
    } | null
  } | null,
  readonly stop_place?: {
    readonly __typename?: 'stops_database_stop_place',
    readonly name_lang?: string | null,
    readonly name_value?: string | null,
    readonly stop_place_alternative_names: ReadonlyArray<{
      readonly __typename?: 'stops_database_stop_place_alternative_names',
      readonly alternative_name: {
        readonly __typename?: 'stops_database_alternative_name',
        readonly name_lang?: string | null,
        readonly name_type?: string | null,
        readonly name_value?: string | null
      }
    }>
  } | null
};

export type SearchStopsQueryVariables = Exact<{
  where?: InputMaybe<StopsDatabaseQuayNewestVersionBoolExp>;
  orderBy: ReadonlyArray<StopsDatabaseQuayNewestVersionOrderBy> | StopsDatabaseQuayNewestVersionOrderBy;
  offset: Scalars['Int']['input'];
  limit: Scalars['Int']['input'];
}>;


export type SearchStopsQuery = {
  readonly __typename?: 'query_root',
  readonly stops_database?: {
    readonly __typename?: 'stops_database_stops_database_query',
    readonly stops: ReadonlyArray<{
      readonly __typename?: 'stops_database_quay_newest_version',
      readonly id?: any | null,
      readonly netex_id?: string | null,
      readonly scheduled_stop_point_instance?: {
        readonly __typename?: 'service_pattern_scheduled_stop_point',
        readonly scheduled_stop_point_id: UUID,
        readonly label: string,
        readonly measured_location: GeoJSON.Point,
        readonly validity_start?: luxon.DateTime | null,
        readonly validity_end?: luxon.DateTime | null,
        readonly timing_place_id?: UUID | null,
        readonly priority: number,
        readonly timing_place?: {
          readonly __typename?: 'timing_pattern_timing_place',
          readonly timing_place_id: UUID,
          readonly label: string
        } | null
      } | null,
      readonly stop_place?: {
        readonly __typename?: 'stops_database_stop_place',
        readonly name_lang?: string | null,
        readonly name_value?: string | null,
        readonly stop_place_alternative_names: ReadonlyArray<{
          readonly __typename?: 'stops_database_stop_place_alternative_names',
          readonly alternative_name: {
            readonly __typename?: 'stops_database_alternative_name',
            readonly name_lang?: string | null,
            readonly name_type?: string | null,
            readonly name_value?: string | null
          }
        }>
      } | null
    }>,
    readonly resultCount: {
      readonly __typename?: 'stops_database_quay_newest_version_aggregate',
      readonly aggregate?: {
        readonly __typename?: 'stops_database_quay_newest_version_aggregate_fields',
        readonly count: number
      } | null
    }
  } | null
};

export type MoveQuayToStopPlaceMutationVariables = Exact<{
  toStopPlaceId: Scalars['String']['input'];
  quayIds: ReadonlyArray<Scalars['String']['input']> | Scalars['String']['input'];
  moveQuayFromDate: Scalars['stop_registry_LocalDate']['input'];
  fromVersionComment: Scalars['String']['input'];
  toVersionComment: Scalars['String']['input'];
}>;


export type MoveQuayToStopPlaceMutation = {
  readonly __typename?: 'mutation_root',
  readonly stop_registry?: {
    readonly __typename?: 'stop_registryStopPlaceMutation',
    readonly moveQuaysToStop?: {
      readonly __typename?: 'stop_registry_ParentStopPlace'
    } | {
      readonly __typename?: 'stop_registry_StopPlace',
      readonly id?: string | null,
      readonly version?: string | null,
      readonly versionComment?: string | null,
      readonly quays?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_Quay',
        readonly id?: string | null,
        readonly publicCode?: string | null,
        readonly keyValues?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_KeyValues',
          readonly key?: string | null,
          readonly values?: ReadonlyArray<string | null> | null
        } | null> | null
      } | null> | null
    } | null
  } | null
};

export type GetStopPointsByQuayIdQueryVariables = Exact<{
  quayIds: ReadonlyArray<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type GetStopPointsByQuayIdQuery = {
  readonly __typename?: 'query_root',
  readonly service_pattern_scheduled_stop_point: ReadonlyArray<{
    readonly __typename?: 'service_pattern_scheduled_stop_point',
    readonly scheduled_stop_point_id: UUID,
    readonly priority: number,
    readonly direction: InfrastructureNetworkDirectionEnum,
    readonly label: string,
    readonly timing_place_id?: UUID | null,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly located_on_infrastructure_link_id: UUID,
    readonly stop_place_ref?: string | null,
    readonly measured_location: GeoJSON.Point,
    readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
      readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
      readonly vehicle_mode: ReusableComponentsVehicleModeEnum
    }>
  }>
};

export type UpdateStopPointMutationVariables = Exact<{
  stopId: Scalars['uuid']['input'];
  changes: ServicePatternScheduledStopPointSetInput;
}>;


export type UpdateStopPointMutation = {
  readonly __typename?: 'mutation_root',
  readonly update_service_pattern_scheduled_stop_point?: {
    readonly __typename?: 'service_pattern_scheduled_stop_point_mutation_response',
    readonly returning: ReadonlyArray<{
      readonly __typename?: 'service_pattern_scheduled_stop_point',
      readonly scheduled_stop_point_id: UUID,
      readonly validity_end?: luxon.DateTime | null
    }>
  } | null
};

export type GetOriginalQuaysQueryVariables = Exact<{
  quayId: Scalars['String']['input'];
}>;


export type GetOriginalQuaysQuery = {
  readonly __typename?: 'query_root',
  readonly stop_registry?: {
    readonly __typename?: 'stop_registryStopPlaceRegister',
    readonly stopPlace?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_ParentStopPlace'
    } | {
      readonly __typename?: 'stop_registry_StopPlace',
      readonly quays?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_Quay',
        readonly id?: string | null,
        readonly publicCode?: string | null
      } | null> | null
    } | null> | null
  } | null
};

export type GetStopPlaceDetailsQueryVariables = Exact<{
  where?: InputMaybe<StopsDatabaseStopPlaceNewestVersionBoolExp>;
}>;


export type GetStopPlaceDetailsQuery = {
  readonly __typename?: 'query_root',
  readonly stopsDb?: {
    readonly __typename?: 'stops_database_stops_database_query',
    readonly newestVersion: ReadonlyArray<{
      readonly __typename?: 'stops_database_stop_place_newest_version',
      readonly id?: any | null,
      readonly TiamatStopPlace?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_ParentStopPlace'
      } | {
        readonly __typename?: 'stop_registry_StopPlace',
        readonly id?: string | null,
        readonly transportMode?: StopRegistryTransportModeType | null,
        readonly alternativeNames?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_AlternativeName',
          readonly nameType: StopRegistryNameType,
          readonly name: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly lang?: string | null,
            readonly value?: string | null
          }
        } | null> | null,
        readonly privateCode?: {
          readonly __typename?: 'stop_registry_PrivateCode',
          readonly value?: string | null,
          readonly type?: string | null
        } | null,
        readonly name?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        } | null,
        readonly organisations?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_StopPlaceOrganisationRef',
          readonly relationshipType?: StopRegistryStopPlaceOrganisationRelationshipType | null,
          readonly organisationRef: string,
          readonly organisation?: {
            readonly __typename?: 'stop_registry_Organisation',
            readonly id?: string | null,
            readonly name?: string | null,
            readonly privateContactDetails?: {
              readonly __typename?: 'stop_registry_Contact',
              readonly id?: string | null,
              readonly email?: string | null,
              readonly phone?: string | null
            } | null
          } | null
        } | null> | null,
        readonly geometry?: {
          readonly __typename?: 'stop_registry_GeoJSON',
          readonly type?: StopRegistryGeoJsonType | null,
          readonly coordinates?: GeoJSON.Position | null
        } | null,
        readonly keyValues?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_KeyValues',
          readonly key?: string | null,
          readonly values?: ReadonlyArray<string | null> | null
        } | null> | null,
        readonly quays?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_Quay',
          readonly id?: string | null,
          readonly publicCode?: string | null,
          readonly privateCode?: {
            readonly __typename?: 'stop_registry_PrivateCode',
            readonly type?: string | null,
            readonly value?: string | null
          } | null,
          readonly description?: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly lang?: string | null,
            readonly value?: string | null
          } | null,
          readonly alternativeNames?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_AlternativeName',
            readonly nameType: StopRegistryNameType,
            readonly name: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly lang?: string | null,
              readonly value?: string | null
            }
          } | null> | null,
          readonly geometry?: {
            readonly __typename?: 'stop_registry_GeoJSON',
            readonly coordinates?: GeoJSON.Position | null,
            readonly type?: StopRegistryGeoJsonType | null
          } | null,
          readonly accessibilityAssessment?: {
            readonly __typename?: 'stop_registry_AccessibilityAssessment',
            readonly id?: string | null,
            readonly hslAccessibilityProperties?: {
              readonly __typename?: 'stop_registry_HslAccessibilityProperties',
              readonly id?: string | null,
              readonly stopAreaSideSlope?: number | null,
              readonly stopAreaLengthwiseSlope?: number | null,
              readonly endRampSlope?: number | null,
              readonly shelterLaneDistance?: number | null,
              readonly curbBackOfRailDistance?: number | null,
              readonly curbDriveSideOfRailDistance?: number | null,
              readonly structureLaneDistance?: number | null,
              readonly stopElevationFromRailTop?: number | null,
              readonly stopElevationFromSidewalk?: number | null,
              readonly lowerCleatHeight?: number | null,
              readonly serviceAreaWidth?: number | null,
              readonly serviceAreaLength?: number | null,
              readonly platformEdgeWarningArea?: boolean | null,
              readonly guidanceTiles?: boolean | null,
              readonly guidanceStripe?: boolean | null,
              readonly serviceAreaStripes?: boolean | null,
              readonly sidewalkAccessibleConnection?: boolean | null,
              readonly stopAreaSurroundingsAccessible?: boolean | null,
              readonly curvedStop?: boolean | null,
              readonly stopType?: StopRegistryStopType | null,
              readonly shelterType?: StopRegistryShelterWidthType | null,
              readonly guidanceType?: StopRegistryGuidanceType | null,
              readonly mapType?: StopRegistryMapType | null,
              readonly pedestrianCrossingRampType?: StopRegistryPedestrianCrossingRampType | null,
              readonly accessibilityLevel?: StopRegistryAccessibilityLevel | null
            } | null,
            readonly limitations?: {
              readonly __typename?: 'stop_registry_AccessibilityLimitations',
              readonly id?: string | null,
              readonly version?: string | null,
              readonly audibleSignalsAvailable?: StopRegistryLimitationStatusType | null,
              readonly escalatorFreeAccess?: StopRegistryLimitationStatusType | null,
              readonly liftFreeAccess?: StopRegistryLimitationStatusType | null,
              readonly stepFreeAccess?: StopRegistryLimitationStatusType | null,
              readonly wheelchairAccess?: StopRegistryLimitationStatusType | null
            } | null
          } | null,
          readonly keyValues?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_KeyValues',
            readonly key?: string | null,
            readonly values?: ReadonlyArray<string | null> | null
          } | null> | null,
          readonly infoSpots?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_infoSpot',
            readonly id?: string | null,
            readonly backlight?: boolean | null,
            readonly displayType?: StopRegistryDisplayType | null,
            readonly floor?: string | null,
            readonly label?: string | null,
            readonly width?: number | null,
            readonly height?: number | null,
            readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
            readonly infoSpotType?: StopRegistryInfoSpotType | null,
            readonly purpose?: string | null,
            readonly railInformation?: string | null,
            readonly speechProperty?: boolean | null,
            readonly zoneLabel?: string | null,
            readonly description?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly lang?: string | null,
              readonly value?: string | null
            } | null,
            readonly poster?: ReadonlyArray<{
              readonly __typename?: 'stop_registry_poster',
              readonly label?: string | null,
              readonly width?: number | null,
              readonly height?: number | null,
              readonly lines?: string | null
            } | null> | null
          } | null> | null,
          readonly placeEquipments?: {
            readonly __typename?: 'stop_registry_PlaceEquipments',
            readonly id?: string | null,
            readonly shelterEquipment?: ReadonlyArray<{
              readonly __typename?: 'stop_registry_ShelterEquipment',
              readonly id?: string | null,
              readonly enclosed?: boolean | null,
              readonly stepFree?: boolean | null,
              readonly shelterNumber?: number | null,
              readonly shelterType?: StopRegistryShelterType | null,
              readonly shelterElectricity?: StopRegistryShelterElectricity | null,
              readonly shelterLighting?: boolean | null,
              readonly shelterCondition?: StopRegistryShelterCondition | null,
              readonly timetableCabinets?: number | null,
              readonly trashCan?: boolean | null,
              readonly shelterHasDisplay?: boolean | null,
              readonly bicycleParking?: boolean | null,
              readonly leaningRail?: boolean | null,
              readonly outsideBench?: boolean | null,
              readonly shelterFasciaBoardTaping?: boolean | null,
              readonly shelterExternalId?: string | null
            } | null> | null,
            readonly cycleStorageEquipment?: ReadonlyArray<{
              readonly __typename?: 'stop_registry_CycleStorageEquipment',
              readonly cycleStorageType?: StopRegistryCycleStorageType | null
            } | null> | null,
            readonly generalSign?: ReadonlyArray<{
              readonly __typename?: 'stop_registry_GeneralSign',
              readonly signContentType?: StopRegistrySignContentType | null,
              readonly numberOfFrames?: number | null,
              readonly lineSignage?: boolean | null,
              readonly mainLineSign?: boolean | null,
              readonly replacesRailSign?: boolean | null,
              readonly privateCode?: {
                readonly __typename?: 'stop_registry_PrivateCode',
                readonly value?: string | null,
                readonly type?: string | null
              } | null,
              readonly content?: {
                readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
                readonly value?: string | null
              } | null,
              readonly note?: {
                readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
                readonly lang?: string | null,
                readonly value?: string | null
              } | null
            } | null> | null
          } | null,
          readonly scheduled_stop_point?: {
            readonly __typename?: 'service_pattern_scheduled_stop_point',
            readonly priority: number,
            readonly direction: InfrastructureNetworkDirectionEnum,
            readonly scheduled_stop_point_id: UUID,
            readonly label: string,
            readonly timing_place_id?: UUID | null,
            readonly validity_start?: luxon.DateTime | null,
            readonly validity_end?: luxon.DateTime | null,
            readonly located_on_infrastructure_link_id: UUID,
            readonly stop_place_ref?: string | null,
            readonly measured_location: GeoJSON.Point,
            readonly timing_place?: {
              readonly __typename?: 'timing_pattern_timing_place',
              readonly timing_place_id: UUID,
              readonly label: string
            } | null,
            readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
              readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
              readonly vehicle_mode: ReusableComponentsVehicleModeEnum
            }>
          } | null,
          readonly externalLinks?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_externalLink',
            readonly quayId?: number | null,
            readonly orderNum?: number | null,
            readonly name?: string | null,
            readonly location?: string | null
          } | null> | null
        } | null> | null,
        readonly parentStopPlace?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_ParentStopPlace',
          readonly id?: string | null,
          readonly name?: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly lang?: string | null,
            readonly value?: string | null
          } | null,
          readonly privateCode?: {
            readonly __typename?: 'stop_registry_PrivateCode',
            readonly value?: string | null,
            readonly type?: string | null
          } | null,
          readonly children?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_StopPlace',
            readonly id?: string | null,
            readonly name?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly value?: string | null
            } | null,
            readonly privateCode?: {
              readonly __typename?: 'stop_registry_PrivateCode',
              readonly value?: string | null
            } | null,
            readonly quays?: ReadonlyArray<{
              readonly __typename?: 'stop_registry_Quay',
              readonly id?: string | null,
              readonly publicCode?: string | null,
              readonly description?: {
                readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
                readonly lang?: string | null,
                readonly value?: string | null
              } | null,
              readonly scheduled_stop_point?: {
                readonly __typename?: 'service_pattern_scheduled_stop_point',
                readonly priority: number,
                readonly direction: InfrastructureNetworkDirectionEnum,
                readonly scheduled_stop_point_id: UUID,
                readonly label: string,
                readonly timing_place_id?: UUID | null,
                readonly validity_start?: luxon.DateTime | null,
                readonly validity_end?: luxon.DateTime | null,
                readonly located_on_infrastructure_link_id: UUID,
                readonly stop_place_ref?: string | null,
                readonly measured_location: GeoJSON.Point,
                readonly timing_place?: {
                  readonly __typename?: 'timing_pattern_timing_place',
                  readonly timing_place_id: UUID,
                  readonly label: string
                } | null,
                readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
                  readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
                  readonly vehicle_mode: ReusableComponentsVehicleModeEnum
                }>
              } | null,
              readonly keyValues?: ReadonlyArray<{
                readonly __typename?: 'stop_registry_KeyValues',
                readonly key?: string | null,
                readonly values?: ReadonlyArray<string | null> | null
              } | null> | null,
              readonly infoSpots?: ReadonlyArray<{
                readonly __typename?: 'stop_registry_infoSpot',
                readonly id?: string | null,
                readonly backlight?: boolean | null,
                readonly displayType?: StopRegistryDisplayType | null,
                readonly floor?: string | null,
                readonly label?: string | null,
                readonly width?: number | null,
                readonly height?: number | null,
                readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
                readonly infoSpotType?: StopRegistryInfoSpotType | null,
                readonly purpose?: string | null,
                readonly railInformation?: string | null,
                readonly speechProperty?: boolean | null,
                readonly zoneLabel?: string | null,
                readonly description?: {
                  readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
                  readonly lang?: string | null,
                  readonly value?: string | null
                } | null,
                readonly poster?: ReadonlyArray<{
                  readonly __typename?: 'stop_registry_poster',
                  readonly label?: string | null,
                  readonly width?: number | null,
                  readonly height?: number | null,
                  readonly lines?: string | null
                } | null> | null
              } | null> | null,
              readonly placeEquipments?: {
                readonly __typename?: 'stop_registry_PlaceEquipments',
                readonly id?: string | null,
                readonly generalSign?: ReadonlyArray<{
                  readonly __typename?: 'stop_registry_GeneralSign',
                  readonly id?: string | null,
                  readonly content?: {
                    readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
                    readonly value?: string | null
                  } | null
                } | null> | null,
                readonly shelterEquipment?: ReadonlyArray<{
                  readonly __typename?: 'stop_registry_ShelterEquipment',
                  readonly id?: string | null,
                  readonly shelterNumber?: number | null
                } | null> | null
              } | null
            } | null> | null
          } | null> | null
        } | {
          readonly __typename?: 'stop_registry_StopPlace'
        } | null> | null,
        readonly accessibilityAssessment?: {
          readonly __typename?: 'stop_registry_AccessibilityAssessment',
          readonly id?: string | null,
          readonly hslAccessibilityProperties?: {
            readonly __typename?: 'stop_registry_HslAccessibilityProperties',
            readonly id?: string | null,
            readonly stopAreaSideSlope?: number | null,
            readonly stopAreaLengthwiseSlope?: number | null,
            readonly endRampSlope?: number | null,
            readonly shelterLaneDistance?: number | null,
            readonly curbBackOfRailDistance?: number | null,
            readonly curbDriveSideOfRailDistance?: number | null,
            readonly structureLaneDistance?: number | null,
            readonly stopElevationFromRailTop?: number | null,
            readonly stopElevationFromSidewalk?: number | null,
            readonly lowerCleatHeight?: number | null,
            readonly serviceAreaWidth?: number | null,
            readonly serviceAreaLength?: number | null,
            readonly platformEdgeWarningArea?: boolean | null,
            readonly guidanceTiles?: boolean | null,
            readonly guidanceStripe?: boolean | null,
            readonly serviceAreaStripes?: boolean | null,
            readonly sidewalkAccessibleConnection?: boolean | null,
            readonly stopAreaSurroundingsAccessible?: boolean | null,
            readonly curvedStop?: boolean | null,
            readonly stopType?: StopRegistryStopType | null,
            readonly shelterType?: StopRegistryShelterWidthType | null,
            readonly guidanceType?: StopRegistryGuidanceType | null,
            readonly mapType?: StopRegistryMapType | null,
            readonly pedestrianCrossingRampType?: StopRegistryPedestrianCrossingRampType | null,
            readonly accessibilityLevel?: StopRegistryAccessibilityLevel | null
          } | null,
          readonly limitations?: {
            readonly __typename?: 'stop_registry_AccessibilityLimitations',
            readonly id?: string | null,
            readonly version?: string | null,
            readonly audibleSignalsAvailable?: StopRegistryLimitationStatusType | null,
            readonly escalatorFreeAccess?: StopRegistryLimitationStatusType | null,
            readonly liftFreeAccess?: StopRegistryLimitationStatusType | null,
            readonly stepFreeAccess?: StopRegistryLimitationStatusType | null,
            readonly wheelchairAccess?: StopRegistryLimitationStatusType | null
          } | null
        } | null,
        readonly topographicPlace?: {
          readonly __typename?: 'stop_registry_TopographicPlace',
          readonly id?: string | null,
          readonly name?: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly value?: string | null,
            readonly lang?: string | null
          } | null
        } | null,
        readonly fareZones?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_FareZone',
          readonly id?: string | null,
          readonly name?: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly value?: string | null,
            readonly lang?: string | null
          } | null
        } | null> | null
      } | null> | null
    }>
  } | null
};

export type StopPlaceDetailsFragment = {
  readonly __typename?: 'stop_registry_StopPlace',
  readonly id?: string | null,
  readonly transportMode?: StopRegistryTransportModeType | null,
  readonly alternativeNames?: ReadonlyArray<{
    readonly __typename?: 'stop_registry_AlternativeName',
    readonly nameType: StopRegistryNameType,
    readonly name: {
      readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
      readonly lang?: string | null,
      readonly value?: string | null
    }
  } | null> | null,
  readonly privateCode?: {
    readonly __typename?: 'stop_registry_PrivateCode',
    readonly value?: string | null,
    readonly type?: string | null
  } | null,
  readonly name?: {
    readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
    readonly lang?: string | null,
    readonly value?: string | null
  } | null,
  readonly organisations?: ReadonlyArray<{
    readonly __typename?: 'stop_registry_StopPlaceOrganisationRef',
    readonly relationshipType?: StopRegistryStopPlaceOrganisationRelationshipType | null,
    readonly organisationRef: string,
    readonly organisation?: {
      readonly __typename?: 'stop_registry_Organisation',
      readonly id?: string | null,
      readonly name?: string | null,
      readonly privateContactDetails?: {
        readonly __typename?: 'stop_registry_Contact',
        readonly id?: string | null,
        readonly email?: string | null,
        readonly phone?: string | null
      } | null
    } | null
  } | null> | null,
  readonly geometry?: {
    readonly __typename?: 'stop_registry_GeoJSON',
    readonly type?: StopRegistryGeoJsonType | null,
    readonly coordinates?: GeoJSON.Position | null
  } | null,
  readonly keyValues?: ReadonlyArray<{
    readonly __typename?: 'stop_registry_KeyValues',
    readonly key?: string | null,
    readonly values?: ReadonlyArray<string | null> | null
  } | null> | null,
  readonly quays?: ReadonlyArray<{
    readonly __typename?: 'stop_registry_Quay',
    readonly id?: string | null,
    readonly publicCode?: string | null,
    readonly privateCode?: {
      readonly __typename?: 'stop_registry_PrivateCode',
      readonly type?: string | null,
      readonly value?: string | null
    } | null,
    readonly description?: {
      readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
      readonly lang?: string | null,
      readonly value?: string | null
    } | null,
    readonly alternativeNames?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_AlternativeName',
      readonly nameType: StopRegistryNameType,
      readonly name: {
        readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
        readonly lang?: string | null,
        readonly value?: string | null
      }
    } | null> | null,
    readonly geometry?: {
      readonly __typename?: 'stop_registry_GeoJSON',
      readonly coordinates?: GeoJSON.Position | null,
      readonly type?: StopRegistryGeoJsonType | null
    } | null,
    readonly accessibilityAssessment?: {
      readonly __typename?: 'stop_registry_AccessibilityAssessment',
      readonly id?: string | null,
      readonly hslAccessibilityProperties?: {
        readonly __typename?: 'stop_registry_HslAccessibilityProperties',
        readonly id?: string | null,
        readonly stopAreaSideSlope?: number | null,
        readonly stopAreaLengthwiseSlope?: number | null,
        readonly endRampSlope?: number | null,
        readonly shelterLaneDistance?: number | null,
        readonly curbBackOfRailDistance?: number | null,
        readonly curbDriveSideOfRailDistance?: number | null,
        readonly structureLaneDistance?: number | null,
        readonly stopElevationFromRailTop?: number | null,
        readonly stopElevationFromSidewalk?: number | null,
        readonly lowerCleatHeight?: number | null,
        readonly serviceAreaWidth?: number | null,
        readonly serviceAreaLength?: number | null,
        readonly platformEdgeWarningArea?: boolean | null,
        readonly guidanceTiles?: boolean | null,
        readonly guidanceStripe?: boolean | null,
        readonly serviceAreaStripes?: boolean | null,
        readonly sidewalkAccessibleConnection?: boolean | null,
        readonly stopAreaSurroundingsAccessible?: boolean | null,
        readonly curvedStop?: boolean | null,
        readonly stopType?: StopRegistryStopType | null,
        readonly shelterType?: StopRegistryShelterWidthType | null,
        readonly guidanceType?: StopRegistryGuidanceType | null,
        readonly mapType?: StopRegistryMapType | null,
        readonly pedestrianCrossingRampType?: StopRegistryPedestrianCrossingRampType | null,
        readonly accessibilityLevel?: StopRegistryAccessibilityLevel | null
      } | null,
      readonly limitations?: {
        readonly __typename?: 'stop_registry_AccessibilityLimitations',
        readonly id?: string | null,
        readonly version?: string | null,
        readonly audibleSignalsAvailable?: StopRegistryLimitationStatusType | null,
        readonly escalatorFreeAccess?: StopRegistryLimitationStatusType | null,
        readonly liftFreeAccess?: StopRegistryLimitationStatusType | null,
        readonly stepFreeAccess?: StopRegistryLimitationStatusType | null,
        readonly wheelchairAccess?: StopRegistryLimitationStatusType | null
      } | null
    } | null,
    readonly keyValues?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_KeyValues',
      readonly key?: string | null,
      readonly values?: ReadonlyArray<string | null> | null
    } | null> | null,
    readonly infoSpots?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_infoSpot',
      readonly id?: string | null,
      readonly backlight?: boolean | null,
      readonly displayType?: StopRegistryDisplayType | null,
      readonly floor?: string | null,
      readonly label?: string | null,
      readonly width?: number | null,
      readonly height?: number | null,
      readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
      readonly infoSpotType?: StopRegistryInfoSpotType | null,
      readonly purpose?: string | null,
      readonly railInformation?: string | null,
      readonly speechProperty?: boolean | null,
      readonly zoneLabel?: string | null,
      readonly description?: {
        readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
        readonly lang?: string | null,
        readonly value?: string | null
      } | null,
      readonly poster?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_poster',
        readonly label?: string | null,
        readonly width?: number | null,
        readonly height?: number | null,
        readonly lines?: string | null
      } | null> | null
    } | null> | null,
    readonly placeEquipments?: {
      readonly __typename?: 'stop_registry_PlaceEquipments',
      readonly id?: string | null,
      readonly shelterEquipment?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_ShelterEquipment',
        readonly id?: string | null,
        readonly enclosed?: boolean | null,
        readonly stepFree?: boolean | null,
        readonly shelterNumber?: number | null,
        readonly shelterType?: StopRegistryShelterType | null,
        readonly shelterElectricity?: StopRegistryShelterElectricity | null,
        readonly shelterLighting?: boolean | null,
        readonly shelterCondition?: StopRegistryShelterCondition | null,
        readonly timetableCabinets?: number | null,
        readonly trashCan?: boolean | null,
        readonly shelterHasDisplay?: boolean | null,
        readonly bicycleParking?: boolean | null,
        readonly leaningRail?: boolean | null,
        readonly outsideBench?: boolean | null,
        readonly shelterFasciaBoardTaping?: boolean | null,
        readonly shelterExternalId?: string | null
      } | null> | null,
      readonly cycleStorageEquipment?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_CycleStorageEquipment',
        readonly cycleStorageType?: StopRegistryCycleStorageType | null
      } | null> | null,
      readonly generalSign?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_GeneralSign',
        readonly signContentType?: StopRegistrySignContentType | null,
        readonly numberOfFrames?: number | null,
        readonly lineSignage?: boolean | null,
        readonly mainLineSign?: boolean | null,
        readonly replacesRailSign?: boolean | null,
        readonly privateCode?: {
          readonly __typename?: 'stop_registry_PrivateCode',
          readonly value?: string | null,
          readonly type?: string | null
        } | null,
        readonly content?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly value?: string | null
        } | null,
        readonly note?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        } | null
      } | null> | null
    } | null,
    readonly scheduled_stop_point?: {
      readonly __typename?: 'service_pattern_scheduled_stop_point',
      readonly priority: number,
      readonly direction: InfrastructureNetworkDirectionEnum,
      readonly scheduled_stop_point_id: UUID,
      readonly label: string,
      readonly timing_place_id?: UUID | null,
      readonly validity_start?: luxon.DateTime | null,
      readonly validity_end?: luxon.DateTime | null,
      readonly located_on_infrastructure_link_id: UUID,
      readonly stop_place_ref?: string | null,
      readonly measured_location: GeoJSON.Point,
      readonly timing_place?: {
        readonly __typename?: 'timing_pattern_timing_place',
        readonly timing_place_id: UUID,
        readonly label: string
      } | null,
      readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
        readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
        readonly vehicle_mode: ReusableComponentsVehicleModeEnum
      }>
    } | null,
    readonly externalLinks?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_externalLink',
      readonly quayId?: number | null,
      readonly orderNum?: number | null,
      readonly name?: string | null,
      readonly location?: string | null
    } | null> | null
  } | null> | null,
  readonly parentStopPlace?: ReadonlyArray<{
    readonly __typename?: 'stop_registry_ParentStopPlace',
    readonly id?: string | null,
    readonly name?: {
      readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
      readonly lang?: string | null,
      readonly value?: string | null
    } | null,
    readonly privateCode?: {
      readonly __typename?: 'stop_registry_PrivateCode',
      readonly value?: string | null,
      readonly type?: string | null
    } | null,
    readonly children?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_StopPlace',
      readonly id?: string | null,
      readonly name?: {
        readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
        readonly value?: string | null
      } | null,
      readonly privateCode?: {
        readonly __typename?: 'stop_registry_PrivateCode',
        readonly value?: string | null
      } | null,
      readonly quays?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_Quay',
        readonly id?: string | null,
        readonly publicCode?: string | null,
        readonly description?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        } | null,
        readonly scheduled_stop_point?: {
          readonly __typename?: 'service_pattern_scheduled_stop_point',
          readonly priority: number,
          readonly direction: InfrastructureNetworkDirectionEnum,
          readonly scheduled_stop_point_id: UUID,
          readonly label: string,
          readonly timing_place_id?: UUID | null,
          readonly validity_start?: luxon.DateTime | null,
          readonly validity_end?: luxon.DateTime | null,
          readonly located_on_infrastructure_link_id: UUID,
          readonly stop_place_ref?: string | null,
          readonly measured_location: GeoJSON.Point,
          readonly timing_place?: {
            readonly __typename?: 'timing_pattern_timing_place',
            readonly timing_place_id: UUID,
            readonly label: string
          } | null,
          readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
            readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
            readonly vehicle_mode: ReusableComponentsVehicleModeEnum
          }>
        } | null,
        readonly keyValues?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_KeyValues',
          readonly key?: string | null,
          readonly values?: ReadonlyArray<string | null> | null
        } | null> | null,
        readonly infoSpots?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_infoSpot',
          readonly id?: string | null,
          readonly backlight?: boolean | null,
          readonly displayType?: StopRegistryDisplayType | null,
          readonly floor?: string | null,
          readonly label?: string | null,
          readonly width?: number | null,
          readonly height?: number | null,
          readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
          readonly infoSpotType?: StopRegistryInfoSpotType | null,
          readonly purpose?: string | null,
          readonly railInformation?: string | null,
          readonly speechProperty?: boolean | null,
          readonly zoneLabel?: string | null,
          readonly description?: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly lang?: string | null,
            readonly value?: string | null
          } | null,
          readonly poster?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_poster',
            readonly label?: string | null,
            readonly width?: number | null,
            readonly height?: number | null,
            readonly lines?: string | null
          } | null> | null
        } | null> | null,
        readonly placeEquipments?: {
          readonly __typename?: 'stop_registry_PlaceEquipments',
          readonly id?: string | null,
          readonly generalSign?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_GeneralSign',
            readonly id?: string | null,
            readonly content?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly value?: string | null
            } | null
          } | null> | null,
          readonly shelterEquipment?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_ShelterEquipment',
            readonly id?: string | null,
            readonly shelterNumber?: number | null
          } | null> | null
        } | null
      } | null> | null
    } | null> | null
  } | {
    readonly __typename?: 'stop_registry_StopPlace'
  } | null> | null,
  readonly accessibilityAssessment?: {
    readonly __typename?: 'stop_registry_AccessibilityAssessment',
    readonly id?: string | null,
    readonly hslAccessibilityProperties?: {
      readonly __typename?: 'stop_registry_HslAccessibilityProperties',
      readonly id?: string | null,
      readonly stopAreaSideSlope?: number | null,
      readonly stopAreaLengthwiseSlope?: number | null,
      readonly endRampSlope?: number | null,
      readonly shelterLaneDistance?: number | null,
      readonly curbBackOfRailDistance?: number | null,
      readonly curbDriveSideOfRailDistance?: number | null,
      readonly structureLaneDistance?: number | null,
      readonly stopElevationFromRailTop?: number | null,
      readonly stopElevationFromSidewalk?: number | null,
      readonly lowerCleatHeight?: number | null,
      readonly serviceAreaWidth?: number | null,
      readonly serviceAreaLength?: number | null,
      readonly platformEdgeWarningArea?: boolean | null,
      readonly guidanceTiles?: boolean | null,
      readonly guidanceStripe?: boolean | null,
      readonly serviceAreaStripes?: boolean | null,
      readonly sidewalkAccessibleConnection?: boolean | null,
      readonly stopAreaSurroundingsAccessible?: boolean | null,
      readonly curvedStop?: boolean | null,
      readonly stopType?: StopRegistryStopType | null,
      readonly shelterType?: StopRegistryShelterWidthType | null,
      readonly guidanceType?: StopRegistryGuidanceType | null,
      readonly mapType?: StopRegistryMapType | null,
      readonly pedestrianCrossingRampType?: StopRegistryPedestrianCrossingRampType | null,
      readonly accessibilityLevel?: StopRegistryAccessibilityLevel | null
    } | null,
    readonly limitations?: {
      readonly __typename?: 'stop_registry_AccessibilityLimitations',
      readonly id?: string | null,
      readonly version?: string | null,
      readonly audibleSignalsAvailable?: StopRegistryLimitationStatusType | null,
      readonly escalatorFreeAccess?: StopRegistryLimitationStatusType | null,
      readonly liftFreeAccess?: StopRegistryLimitationStatusType | null,
      readonly stepFreeAccess?: StopRegistryLimitationStatusType | null,
      readonly wheelchairAccess?: StopRegistryLimitationStatusType | null
    } | null
  } | null,
  readonly topographicPlace?: {
    readonly __typename?: 'stop_registry_TopographicPlace',
    readonly id?: string | null,
    readonly name?: {
      readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
      readonly value?: string | null,
      readonly lang?: string | null
    } | null
  } | null,
  readonly fareZones?: ReadonlyArray<{
    readonly __typename?: 'stop_registry_FareZone',
    readonly id?: string | null,
    readonly name?: {
      readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
      readonly value?: string | null,
      readonly lang?: string | null
    } | null
  } | null> | null
};

export type TerminalDetailsFragment = {
  readonly __typename?: 'stop_registry_ParentStopPlace',
  readonly id?: string | null,
  readonly name?: {
    readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
    readonly lang?: string | null,
    readonly value?: string | null
  } | null,
  readonly privateCode?: {
    readonly __typename?: 'stop_registry_PrivateCode',
    readonly value?: string | null,
    readonly type?: string | null
  } | null,
  readonly children?: ReadonlyArray<{
    readonly __typename?: 'stop_registry_StopPlace',
    readonly id?: string | null,
    readonly name?: {
      readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
      readonly value?: string | null
    } | null,
    readonly privateCode?: {
      readonly __typename?: 'stop_registry_PrivateCode',
      readonly value?: string | null
    } | null,
    readonly quays?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_Quay',
      readonly id?: string | null,
      readonly publicCode?: string | null,
      readonly description?: {
        readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
        readonly lang?: string | null,
        readonly value?: string | null
      } | null,
      readonly scheduled_stop_point?: {
        readonly __typename?: 'service_pattern_scheduled_stop_point',
        readonly priority: number,
        readonly direction: InfrastructureNetworkDirectionEnum,
        readonly scheduled_stop_point_id: UUID,
        readonly label: string,
        readonly timing_place_id?: UUID | null,
        readonly validity_start?: luxon.DateTime | null,
        readonly validity_end?: luxon.DateTime | null,
        readonly located_on_infrastructure_link_id: UUID,
        readonly stop_place_ref?: string | null,
        readonly measured_location: GeoJSON.Point,
        readonly timing_place?: {
          readonly __typename?: 'timing_pattern_timing_place',
          readonly timing_place_id: UUID,
          readonly label: string
        } | null,
        readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
          readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
          readonly vehicle_mode: ReusableComponentsVehicleModeEnum
        }>
      } | null,
      readonly keyValues?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_KeyValues',
        readonly key?: string | null,
        readonly values?: ReadonlyArray<string | null> | null
      } | null> | null,
      readonly infoSpots?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_infoSpot',
        readonly id?: string | null,
        readonly backlight?: boolean | null,
        readonly displayType?: StopRegistryDisplayType | null,
        readonly floor?: string | null,
        readonly label?: string | null,
        readonly width?: number | null,
        readonly height?: number | null,
        readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
        readonly infoSpotType?: StopRegistryInfoSpotType | null,
        readonly purpose?: string | null,
        readonly railInformation?: string | null,
        readonly speechProperty?: boolean | null,
        readonly zoneLabel?: string | null,
        readonly description?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        } | null,
        readonly poster?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_poster',
          readonly label?: string | null,
          readonly width?: number | null,
          readonly height?: number | null,
          readonly lines?: string | null
        } | null> | null
      } | null> | null,
      readonly placeEquipments?: {
        readonly __typename?: 'stop_registry_PlaceEquipments',
        readonly id?: string | null,
        readonly generalSign?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_GeneralSign',
          readonly id?: string | null,
          readonly content?: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly value?: string | null
          } | null
        } | null> | null,
        readonly shelterEquipment?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_ShelterEquipment',
          readonly id?: string | null,
          readonly shelterNumber?: number | null
        } | null> | null
      } | null
    } | null> | null
  } | null> | null
};

export type GetStopPlaceVersionsQueryVariables = Exact<{
  privateCode: Scalars['String']['input'];
}>;


export type GetStopPlaceVersionsQuery = {
  readonly __typename?: 'query_root',
  readonly stops_database?: {
    readonly __typename?: 'stops_database_stops_database_query',
    readonly stopAreas: ReadonlyArray<{
      readonly __typename?: 'stops_database_stop_place_newest_version',
      readonly id?: any | null,
      readonly netex_id?: string | null,
      readonly private_code_type?: string | null,
      readonly private_code_value?: string | null,
      readonly name_value?: string | null,
      readonly validity_start?: string | null,
      readonly validity_end?: string | null,
      readonly centroid?: GeoJSON.Geometry | null,
      readonly created?: any | null,
      readonly changed?: any | null,
      readonly changed_by?: string | null,
      readonly version_comment?: string | null
    }>
  } | null
};

export type StopAreaVersionInfoFragment = {
  readonly __typename?: 'stops_database_stop_place_newest_version',
  readonly id?: any | null,
  readonly netex_id?: string | null,
  readonly private_code_type?: string | null,
  readonly private_code_value?: string | null,
  readonly name_value?: string | null,
  readonly validity_start?: string | null,
  readonly validity_end?: string | null,
  readonly centroid?: GeoJSON.Geometry | null,
  readonly created?: any | null,
  readonly changed?: any | null,
  readonly changed_by?: string | null,
  readonly version_comment?: string | null
};

export type DeleteQuayMutationVariables = Exact<{
  stopPlaceId: Scalars['String']['input'];
  quayId: Scalars['String']['input'];
}>;


export type DeleteQuayMutation = {
  readonly __typename?: 'mutation_root',
  readonly stop_registry?: {
    readonly __typename?: 'stop_registryStopPlaceMutation',
    readonly deleteQuay?: {
      readonly __typename?: 'stop_registry_ParentStopPlace',
      readonly id?: string | null,
      readonly version?: string | null
    } | {
      readonly __typename?: 'stop_registry_StopPlace',
      readonly id?: string | null,
      readonly version?: string | null,
      readonly quays?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_Quay',
        readonly id?: string | null,
        readonly version?: string | null
      } | null> | null
    } | null
  } | null
};

export type EditKeyValuesOfQuayMutationVariables = Exact<{
  stopId: Scalars['String']['input'];
  quayId: Scalars['String']['input'];
  keyValues: ReadonlyArray<StopRegistryKeyValuesInput> | StopRegistryKeyValuesInput;
  versionComment: Scalars['String']['input'];
}>;


export type EditKeyValuesOfQuayMutation = {
  readonly __typename?: 'mutation_root',
  readonly stop_registry?: {
    readonly __typename?: 'stop_registryStopPlaceMutation',
    readonly mutateStopPlace?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_StopPlace',
      readonly quays?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_Quay',
        readonly publicCode?: string | null,
        readonly keyValues?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_KeyValues',
          readonly key?: string | null,
          readonly values?: ReadonlyArray<string | null> | null
        } | null> | null
      } | null> | null
    } | null> | null
  } | null
};

export type EditScheduledStopPointValidityMutationVariables = Exact<{
  stopId: Scalars['String']['input'];
  priority: Scalars['Int']['input'];
  validityStart: Scalars['date']['input'];
  validityEnd?: InputMaybe<Scalars['date']['input']>;
}>;


export type EditScheduledStopPointValidityMutation = {
  readonly __typename?: 'mutation_root',
  readonly update_service_pattern_scheduled_stop_point?: {
    readonly __typename?: 'service_pattern_scheduled_stop_point_mutation_response',
    readonly returning: ReadonlyArray<{
      readonly __typename?: 'service_pattern_scheduled_stop_point',
      readonly label: string,
      readonly priority: number,
      readonly stop_place_ref?: string | null,
      readonly scheduled_stop_point_id: UUID,
      readonly validity_start?: luxon.DateTime | null,
      readonly validity_end?: luxon.DateTime | null
    }>
  } | null
};

export type GetQuayQueryVariables = Exact<{
  quayId: Scalars['String']['input'];
}>;


export type GetQuayQuery = {
  readonly __typename?: 'query_root',
  readonly stop_registry?: {
    readonly __typename?: 'stop_registryStopPlaceRegister',
    readonly stopPlace?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_ParentStopPlace'
    } | {
      readonly __typename?: 'stop_registry_StopPlace',
      readonly id?: string | null,
      readonly quays?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_Quay',
        readonly id?: string | null,
        readonly publicCode?: string | null,
        readonly keyValues?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_KeyValues',
          readonly key?: string | null,
          readonly values?: ReadonlyArray<string | null> | null
        } | null> | null
      } | null> | null
    } | null> | null
  } | null
};

export type InsertQuayIntoStopPlaceMutationVariables = Exact<{
  stopPlaceId: Scalars['String']['input'];
  quayInput: StopRegistryQuayInput;
}>;


export type InsertQuayIntoStopPlaceMutation = {
  readonly __typename?: 'mutation_root',
  readonly stop_registry?: {
    readonly __typename?: 'stop_registryStopPlaceMutation',
    readonly mutateStopPlace?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_StopPlace',
      readonly id?: string | null,
      readonly quays?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_Quay',
        readonly id?: string | null,
        readonly keyValues?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_KeyValues',
          readonly key?: string | null,
          readonly values?: ReadonlyArray<string | null> | null
        } | null> | null
      } | null> | null
    } | null> | null
  } | null
};

export type FindExistingPosterNamesQueryVariables = Exact<{ [key: string]: never; }>;


export type FindExistingPosterNamesQuery = {
  readonly __typename?: 'query_root',
  readonly stops_database?: {
    readonly __typename?: 'stops_database_stops_database_query',
    readonly stops_database_info_spot_poster: ReadonlyArray<{
      readonly __typename?: 'stops_database_info_spot_poster',
      readonly id: any,
      readonly label?: string | null
    }>
  } | null
};

export type UpdateInfoSpotMutationVariables = Exact<{
  input: ReadonlyArray<InputMaybe<StopRegistryInfoSpotInput>> | InputMaybe<StopRegistryInfoSpotInput>;
}>;


export type UpdateInfoSpotMutation = {
  readonly __typename?: 'mutation_root',
  readonly stop_registry?: {
    readonly __typename?: 'stop_registryStopPlaceMutation',
    readonly mutateInfoSpots?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_infoSpot',
      readonly id?: string | null,
      readonly backlight?: boolean | null,
      readonly displayType?: StopRegistryDisplayType | null,
      readonly floor?: string | null,
      readonly label?: string | null,
      readonly width?: number | null,
      readonly height?: number | null,
      readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
      readonly infoSpotType?: StopRegistryInfoSpotType | null,
      readonly purpose?: string | null,
      readonly railInformation?: string | null,
      readonly speechProperty?: boolean | null,
      readonly zoneLabel?: string | null,
      readonly description?: {
        readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
        readonly lang?: string | null,
        readonly value?: string | null
      } | null,
      readonly poster?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_poster',
        readonly label?: string | null,
        readonly width?: number | null,
        readonly height?: number | null,
        readonly lines?: string | null
      } | null> | null
    } | null> | null
  } | null
};

export type GetInfoSpotSizesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetInfoSpotSizesQuery = {
  readonly __typename?: 'query_root',
  readonly stopsDb?: {
    readonly __typename?: 'stops_database_stops_database_query',
    readonly infoSpotSizes: ReadonlyArray<{
      readonly __typename?: 'stops_database_info_spot',
      readonly width?: number | null,
      readonly height?: number | null
    }>,
    readonly infoSpotPosterSizes: ReadonlyArray<{
      readonly __typename?: 'stops_database_info_spot_poster',
      readonly width?: number | null,
      readonly height?: number | null
    }>
  } | null
};

export type GetOrganisationsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetOrganisationsQuery = {
  readonly __typename?: 'query_root',
  readonly stop_registry?: {
    readonly __typename?: 'stop_registryStopPlaceRegister',
    readonly organisation?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_Organisation',
      readonly id?: string | null,
      readonly name?: string | null,
      readonly privateContactDetails?: {
        readonly __typename?: 'stop_registry_Contact',
        readonly id?: string | null,
        readonly email?: string | null,
        readonly phone?: string | null
      } | null
    } | null> | null
  } | null
};

export type FindLinesByStopQueryVariables = Exact<{
  stopPlaceId: Scalars['String']['input'];
  validOn: Scalars['date']['input'];
}>;


export type FindLinesByStopQuery = {
  readonly __typename?: 'query_root',
  readonly service_pattern_scheduled_stop_point: ReadonlyArray<{
    readonly __typename?: 'service_pattern_scheduled_stop_point',
    readonly stop_place_ref?: string | null,
    readonly label: string,
    readonly priority: number,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly scheduled_stop_point_id: UUID,
    readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly scheduled_stop_point_sequence: number,
      readonly journey_pattern: {
        readonly __typename?: 'journey_pattern_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly journey_pattern_route?: {
          readonly __typename?: 'route_route',
          readonly label: string,
          readonly priority: number,
          readonly validity_start?: luxon.DateTime | null,
          readonly validity_end?: luxon.DateTime | null,
          readonly route_id: UUID
        } | null
      }
    }>
  }>
};

export type StopPointDetailsFragment = {
  readonly __typename?: 'service_pattern_scheduled_stop_point',
  readonly stop_place_ref?: string | null,
  readonly label: string,
  readonly priority: number,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly scheduled_stop_point_id: UUID
};

export type JourneyRouteInfoFragment = {
  readonly __typename?: 'service_pattern_scheduled_stop_point',
  readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
    readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
    readonly journey_pattern_id: UUID,
    readonly scheduled_stop_point_sequence: number,
    readonly journey_pattern: {
      readonly __typename?: 'journey_pattern_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly journey_pattern_route?: {
        readonly __typename?: 'route_route',
        readonly label: string,
        readonly priority: number,
        readonly validity_start?: luxon.DateTime | null,
        readonly validity_end?: luxon.DateTime | null,
        readonly route_id: UUID
      } | null
    }
  }>
};

export type JourneyPatternRouteFragment = {
  readonly __typename?: 'route_route',
  readonly label: string,
  readonly priority: number,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly route_id: UUID
};

export type GetOverlappingStopVersionsQueryVariables = Exact<{
  stopLabel: Scalars['String']['input'];
  currentStopId: Scalars['String']['input'];
  priority: Scalars['Int']['input'];
  fromDate: Scalars['date']['input'];
  toDate: Scalars['date']['input'];
}>;


export type GetOverlappingStopVersionsQuery = {
  readonly __typename?: 'query_root',
  readonly service_pattern_scheduled_stop_point: ReadonlyArray<{
    readonly __typename?: 'service_pattern_scheduled_stop_point',
    readonly scheduled_stop_point_id: UUID,
    readonly label: string,
    readonly priority: number,
    readonly stop_place_ref?: string | null,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly stop_place?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_ParentStopPlace',
      readonly id?: string | null
    } | {
      readonly __typename?: 'stop_registry_StopPlace',
      readonly id?: string | null
    } | null> | null
  }>
};

export type GetOverlappingStopVersionsIndefiniteQueryVariables = Exact<{
  stopLabel: Scalars['String']['input'];
  currentStopId: Scalars['String']['input'];
  priority: Scalars['Int']['input'];
  fromDate: Scalars['date']['input'];
}>;


export type GetOverlappingStopVersionsIndefiniteQuery = {
  readonly __typename?: 'query_root',
  readonly service_pattern_scheduled_stop_point: ReadonlyArray<{
    readonly __typename?: 'service_pattern_scheduled_stop_point',
    readonly scheduled_stop_point_id: UUID,
    readonly label: string,
    readonly priority: number,
    readonly stop_place_ref?: string | null,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly stop_place?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_ParentStopPlace',
      readonly id?: string | null
    } | {
      readonly __typename?: 'stop_registry_StopPlace',
      readonly id?: string | null
    } | null> | null
  }>
};

export type OverlappingStopVersionsDataFragment = {
  readonly __typename?: 'service_pattern_scheduled_stop_point',
  readonly scheduled_stop_point_id: UUID,
  readonly label: string,
  readonly priority: number,
  readonly stop_place_ref?: string | null,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly stop_place?: ReadonlyArray<{
    readonly __typename?: 'stop_registry_ParentStopPlace',
    readonly id?: string | null
  } | {
    readonly __typename?: 'stop_registry_StopPlace',
    readonly id?: string | null
  } | null> | null
};

export type ResolveStopSheltersQueryVariables = Exact<{
  netexId: Scalars['String']['input'];
}>;


export type ResolveStopSheltersQuery = {
  readonly __typename?: 'query_root',
  readonly stop_registry?: {
    readonly __typename?: 'stop_registryStopPlaceRegister',
    readonly stopPlace?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_ParentStopPlace',
      readonly id?: string | null
    } | {
      readonly __typename?: 'stop_registry_StopPlace',
      readonly id?: string | null,
      readonly quays?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_Quay',
        readonly id?: string | null,
        readonly placeEquipments?: {
          readonly __typename?: 'stop_registry_PlaceEquipments',
          readonly id?: string | null,
          readonly shelterEquipment?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_ShelterEquipment',
            readonly id?: string | null,
            readonly enclosed?: boolean | null,
            readonly stepFree?: boolean | null,
            readonly shelterNumber?: number | null,
            readonly shelterType?: StopRegistryShelterType | null,
            readonly shelterElectricity?: StopRegistryShelterElectricity | null,
            readonly shelterLighting?: boolean | null,
            readonly shelterCondition?: StopRegistryShelterCondition | null,
            readonly timetableCabinets?: number | null,
            readonly trashCan?: boolean | null,
            readonly shelterHasDisplay?: boolean | null,
            readonly bicycleParking?: boolean | null,
            readonly leaningRail?: boolean | null,
            readonly outsideBench?: boolean | null,
            readonly shelterFasciaBoardTaping?: boolean | null,
            readonly shelterExternalId?: string | null
          } | null> | null
        } | null
      } | null> | null
    } | null> | null
  } | null
};

export type ResolveExistingStopValidityRangesQueryVariables = Exact<{
  stopPlaceId: Scalars['String']['input'];
  today?: InputMaybe<Scalars['date']['input']>;
}>;


export type ResolveExistingStopValidityRangesQuery = {
  readonly __typename?: 'query_root',
  readonly stopPoints: ReadonlyArray<{
    readonly __typename?: 'service_pattern_scheduled_stop_point',
    readonly scheduled_stop_point_id: UUID,
    readonly priority: number,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null
  }>
};

export type GetStopPlaceNameQueryVariables = Exact<{
  stopPlaceNetexId: Scalars['String']['input'];
}>;


export type GetStopPlaceNameQuery = {
  readonly __typename?: 'query_root',
  readonly stop_registry?: {
    readonly __typename?: 'stop_registryStopPlaceRegister',
    readonly stopPlace?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_ParentStopPlace',
      readonly id?: string | null,
      readonly name?: {
        readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
        readonly lang?: string | null,
        readonly value?: string | null
      } | null,
      readonly alternativeNames?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_AlternativeName',
        readonly nameType: StopRegistryNameType,
        readonly name: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        }
      } | null> | null
    } | {
      readonly __typename?: 'stop_registry_StopPlace',
      readonly id?: string | null,
      readonly name?: {
        readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
        readonly lang?: string | null,
        readonly value?: string | null
      } | null,
      readonly alternativeNames?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_AlternativeName',
        readonly nameType: StopRegistryNameType,
        readonly name: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        }
      } | null> | null
    } | null> | null
  } | null
};

export type GetQuayVersionsQueryVariables = Exact<{
  publicCode: Scalars['String']['input'];
}>;


export type GetQuayVersionsQuery = {
  readonly __typename?: 'query_root',
  readonly stops_database?: {
    readonly __typename?: 'stops_database_stops_database_query',
    readonly quays: ReadonlyArray<{
      readonly __typename?: 'stops_database_quay_newest_version',
      readonly id?: any | null,
      readonly netex_id?: string | null,
      readonly validity_start?: string | null,
      readonly validity_end?: string | null,
      readonly priority?: string | null,
      readonly public_code?: string | null,
      readonly centroid?: GeoJSON.Geometry | null,
      readonly created?: any | null,
      readonly changed?: any | null,
      readonly changed_by?: string | null,
      readonly version_comment?: string | null,
      readonly stop_place?: {
        readonly __typename?: 'stops_database_stop_place',
        readonly id: any,
        readonly netex_id?: string | null,
        readonly name_value?: string | null
      } | null
    }>
  } | null
};

export type StopVersionInfoFragment = {
  readonly __typename?: 'stops_database_quay_newest_version',
  readonly id?: any | null,
  readonly netex_id?: string | null,
  readonly validity_start?: string | null,
  readonly validity_end?: string | null,
  readonly priority?: string | null,
  readonly public_code?: string | null,
  readonly centroid?: GeoJSON.Geometry | null,
  readonly created?: any | null,
  readonly changed?: any | null,
  readonly changed_by?: string | null,
  readonly version_comment?: string | null,
  readonly stop_place?: {
    readonly __typename?: 'stops_database_stop_place',
    readonly id: any,
    readonly netex_id?: string | null,
    readonly name_value?: string | null
  } | null
};

export type RemoveFromMultiModalStopPlaceMutationVariables = Exact<{
  parentSiteRef: Scalars['String']['input'];
  stopPlaceId?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>>;
}>;


export type RemoveFromMultiModalStopPlaceMutation = {
  readonly __typename?: 'mutation_root',
  readonly stop_registry?: {
    readonly __typename?: 'stop_registryStopPlaceMutation',
    readonly removeFromMultiModalStopPlace?: {
      readonly __typename?: 'stop_registry_ParentStopPlace',
      readonly id?: string | null
    } | null
  } | null
};

export type AddToMultiModalStopPlaceMutationVariables = Exact<{
  input: StopRegistryAddToMultiModalStopPlaceInput;
}>;


export type AddToMultiModalStopPlaceMutation = {
  readonly __typename?: 'mutation_root',
  readonly stop_registry?: {
    readonly __typename?: 'stop_registryStopPlaceMutation',
    readonly addToMultiModalStopPlace?: {
      readonly __typename?: 'stop_registry_ParentStopPlace',
      readonly id?: string | null
    } | null
  } | null
};

export type GetParentStopPlaceDetailsQueryVariables = Exact<{
  privateCode: Scalars['String']['input'];
  validOn: Scalars['String']['input'];
}>;


export type GetParentStopPlaceDetailsQuery = {
  readonly __typename?: 'query_root',
  readonly stops_database?: {
    readonly __typename?: 'stops_database_stops_database_query',
    readonly stops_database_stop_place_newest_version: ReadonlyArray<{
      readonly __typename?: 'stops_database_stop_place_newest_version',
      readonly id?: any | null,
      readonly TiamatStopPlace?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_ParentStopPlace',
        readonly id?: string | null,
        readonly alternativeNames?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_AlternativeName',
          readonly nameType: StopRegistryNameType,
          readonly name: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly lang?: string | null,
            readonly value?: string | null
          }
        } | null> | null,
        readonly privateCode?: {
          readonly __typename?: 'stop_registry_PrivateCode',
          readonly value?: string | null,
          readonly type?: string | null
        } | null,
        readonly name?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        } | null,
        readonly description?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        } | null,
        readonly geometry?: {
          readonly __typename?: 'stop_registry_GeoJSON',
          readonly type?: StopRegistryGeoJsonType | null,
          readonly coordinates?: GeoJSON.Position | null
        } | null,
        readonly topographicPlace?: {
          readonly __typename?: 'stop_registry_TopographicPlace',
          readonly name?: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly value?: string | null
          } | null
        } | null,
        readonly fareZones?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_FareZone',
          readonly name?: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly value?: string | null
          } | null
        } | null> | null,
        readonly keyValues?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_KeyValues',
          readonly key?: string | null,
          readonly values?: ReadonlyArray<string | null> | null
        } | null> | null,
        readonly infoSpots?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_infoSpot',
          readonly id?: string | null,
          readonly backlight?: boolean | null,
          readonly displayType?: StopRegistryDisplayType | null,
          readonly floor?: string | null,
          readonly label?: string | null,
          readonly width?: number | null,
          readonly height?: number | null,
          readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
          readonly infoSpotType?: StopRegistryInfoSpotType | null,
          readonly purpose?: string | null,
          readonly railInformation?: string | null,
          readonly speechProperty?: boolean | null,
          readonly zoneLabel?: string | null,
          readonly description?: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly lang?: string | null,
            readonly value?: string | null
          } | null,
          readonly poster?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_poster',
            readonly label?: string | null,
            readonly width?: number | null,
            readonly height?: number | null,
            readonly lines?: string | null
          } | null> | null
        } | null> | null,
        readonly accessibilityAssessment?: {
          readonly __typename?: 'stop_registry_AccessibilityAssessment',
          readonly id?: string | null,
          readonly hslAccessibilityProperties?: {
            readonly __typename?: 'stop_registry_HslAccessibilityProperties',
            readonly id?: string | null,
            readonly stopAreaSideSlope?: number | null,
            readonly stopAreaLengthwiseSlope?: number | null,
            readonly endRampSlope?: number | null,
            readonly shelterLaneDistance?: number | null,
            readonly curbBackOfRailDistance?: number | null,
            readonly curbDriveSideOfRailDistance?: number | null,
            readonly structureLaneDistance?: number | null,
            readonly stopElevationFromRailTop?: number | null,
            readonly stopElevationFromSidewalk?: number | null,
            readonly lowerCleatHeight?: number | null,
            readonly serviceAreaWidth?: number | null,
            readonly serviceAreaLength?: number | null,
            readonly platformEdgeWarningArea?: boolean | null,
            readonly guidanceTiles?: boolean | null,
            readonly guidanceStripe?: boolean | null,
            readonly serviceAreaStripes?: boolean | null,
            readonly sidewalkAccessibleConnection?: boolean | null,
            readonly stopAreaSurroundingsAccessible?: boolean | null,
            readonly curvedStop?: boolean | null,
            readonly stopType?: StopRegistryStopType | null,
            readonly shelterType?: StopRegistryShelterWidthType | null,
            readonly guidanceType?: StopRegistryGuidanceType | null,
            readonly mapType?: StopRegistryMapType | null,
            readonly pedestrianCrossingRampType?: StopRegistryPedestrianCrossingRampType | null,
            readonly accessibilityLevel?: StopRegistryAccessibilityLevel | null
          } | null,
          readonly limitations?: {
            readonly __typename?: 'stop_registry_AccessibilityLimitations',
            readonly id?: string | null,
            readonly version?: string | null,
            readonly audibleSignalsAvailable?: StopRegistryLimitationStatusType | null,
            readonly escalatorFreeAccess?: StopRegistryLimitationStatusType | null,
            readonly liftFreeAccess?: StopRegistryLimitationStatusType | null,
            readonly stepFreeAccess?: StopRegistryLimitationStatusType | null,
            readonly wheelchairAccess?: StopRegistryLimitationStatusType | null
          } | null
        } | null,
        readonly children?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_StopPlace',
          readonly id?: string | null,
          readonly name?: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly value?: string | null
          } | null,
          readonly privateCode?: {
            readonly __typename?: 'stop_registry_PrivateCode',
            readonly value?: string | null
          } | null,
          readonly quays?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_Quay',
            readonly id?: string | null,
            readonly publicCode?: string | null,
            readonly description?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly lang?: string | null,
              readonly value?: string | null
            } | null,
            readonly scheduled_stop_point?: {
              readonly __typename?: 'service_pattern_scheduled_stop_point',
              readonly priority: number,
              readonly direction: InfrastructureNetworkDirectionEnum,
              readonly scheduled_stop_point_id: UUID,
              readonly label: string,
              readonly timing_place_id?: UUID | null,
              readonly validity_start?: luxon.DateTime | null,
              readonly validity_end?: luxon.DateTime | null,
              readonly located_on_infrastructure_link_id: UUID,
              readonly stop_place_ref?: string | null,
              readonly measured_location: GeoJSON.Point,
              readonly timing_place?: {
                readonly __typename?: 'timing_pattern_timing_place',
                readonly timing_place_id: UUID,
                readonly label: string
              } | null,
              readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
                readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
                readonly vehicle_mode: ReusableComponentsVehicleModeEnum
              }>
            } | null,
            readonly keyValues?: ReadonlyArray<{
              readonly __typename?: 'stop_registry_KeyValues',
              readonly key?: string | null,
              readonly values?: ReadonlyArray<string | null> | null
            } | null> | null,
            readonly infoSpots?: ReadonlyArray<{
              readonly __typename?: 'stop_registry_infoSpot',
              readonly id?: string | null,
              readonly backlight?: boolean | null,
              readonly displayType?: StopRegistryDisplayType | null,
              readonly floor?: string | null,
              readonly label?: string | null,
              readonly width?: number | null,
              readonly height?: number | null,
              readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
              readonly infoSpotType?: StopRegistryInfoSpotType | null,
              readonly purpose?: string | null,
              readonly railInformation?: string | null,
              readonly speechProperty?: boolean | null,
              readonly zoneLabel?: string | null,
              readonly description?: {
                readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
                readonly lang?: string | null,
                readonly value?: string | null
              } | null,
              readonly poster?: ReadonlyArray<{
                readonly __typename?: 'stop_registry_poster',
                readonly label?: string | null,
                readonly width?: number | null,
                readonly height?: number | null,
                readonly lines?: string | null
              } | null> | null
            } | null> | null,
            readonly placeEquipments?: {
              readonly __typename?: 'stop_registry_PlaceEquipments',
              readonly id?: string | null,
              readonly generalSign?: ReadonlyArray<{
                readonly __typename?: 'stop_registry_GeneralSign',
                readonly id?: string | null,
                readonly content?: {
                  readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
                  readonly value?: string | null
                } | null
              } | null> | null,
              readonly shelterEquipment?: ReadonlyArray<{
                readonly __typename?: 'stop_registry_ShelterEquipment',
                readonly id?: string | null,
                readonly shelterNumber?: number | null
              } | null> | null
            } | null
          } | null> | null
        } | null> | null,
        readonly externalLinks?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_stopPlaceExternalLink',
          readonly stopPlaceId?: number | null,
          readonly orderNum?: number | null,
          readonly name?: string | null,
          readonly location?: string | null
        } | null> | null,
        readonly organisations?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_StopPlaceOrganisationRef',
          readonly organisationRef: string,
          readonly relationshipType?: StopRegistryStopPlaceOrganisationRelationshipType | null,
          readonly organisation?: {
            readonly __typename?: 'stop_registry_Organisation',
            readonly id?: string | null,
            readonly name?: string | null,
            readonly privateContactDetails?: {
              readonly __typename?: 'stop_registry_Contact',
              readonly id?: string | null,
              readonly email?: string | null,
              readonly phone?: string | null
            } | null
          } | null
        } | null> | null
      } | {
        readonly __typename?: 'stop_registry_StopPlace'
      } | null> | null
    }>
  } | null
};

export type ParentStopPlaceDetailsFragment = {
  readonly __typename?: 'stop_registry_ParentStopPlace',
  readonly id?: string | null,
  readonly alternativeNames?: ReadonlyArray<{
    readonly __typename?: 'stop_registry_AlternativeName',
    readonly nameType: StopRegistryNameType,
    readonly name: {
      readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
      readonly lang?: string | null,
      readonly value?: string | null
    }
  } | null> | null,
  readonly privateCode?: {
    readonly __typename?: 'stop_registry_PrivateCode',
    readonly value?: string | null,
    readonly type?: string | null
  } | null,
  readonly name?: {
    readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
    readonly lang?: string | null,
    readonly value?: string | null
  } | null,
  readonly description?: {
    readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
    readonly lang?: string | null,
    readonly value?: string | null
  } | null,
  readonly geometry?: {
    readonly __typename?: 'stop_registry_GeoJSON',
    readonly type?: StopRegistryGeoJsonType | null,
    readonly coordinates?: GeoJSON.Position | null
  } | null,
  readonly topographicPlace?: {
    readonly __typename?: 'stop_registry_TopographicPlace',
    readonly name?: {
      readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
      readonly value?: string | null
    } | null
  } | null,
  readonly fareZones?: ReadonlyArray<{
    readonly __typename?: 'stop_registry_FareZone',
    readonly name?: {
      readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
      readonly value?: string | null
    } | null
  } | null> | null,
  readonly keyValues?: ReadonlyArray<{
    readonly __typename?: 'stop_registry_KeyValues',
    readonly key?: string | null,
    readonly values?: ReadonlyArray<string | null> | null
  } | null> | null,
  readonly infoSpots?: ReadonlyArray<{
    readonly __typename?: 'stop_registry_infoSpot',
    readonly id?: string | null,
    readonly backlight?: boolean | null,
    readonly displayType?: StopRegistryDisplayType | null,
    readonly floor?: string | null,
    readonly label?: string | null,
    readonly width?: number | null,
    readonly height?: number | null,
    readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
    readonly infoSpotType?: StopRegistryInfoSpotType | null,
    readonly purpose?: string | null,
    readonly railInformation?: string | null,
    readonly speechProperty?: boolean | null,
    readonly zoneLabel?: string | null,
    readonly description?: {
      readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
      readonly lang?: string | null,
      readonly value?: string | null
    } | null,
    readonly poster?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_poster',
      readonly label?: string | null,
      readonly width?: number | null,
      readonly height?: number | null,
      readonly lines?: string | null
    } | null> | null
  } | null> | null,
  readonly accessibilityAssessment?: {
    readonly __typename?: 'stop_registry_AccessibilityAssessment',
    readonly id?: string | null,
    readonly hslAccessibilityProperties?: {
      readonly __typename?: 'stop_registry_HslAccessibilityProperties',
      readonly id?: string | null,
      readonly stopAreaSideSlope?: number | null,
      readonly stopAreaLengthwiseSlope?: number | null,
      readonly endRampSlope?: number | null,
      readonly shelterLaneDistance?: number | null,
      readonly curbBackOfRailDistance?: number | null,
      readonly curbDriveSideOfRailDistance?: number | null,
      readonly structureLaneDistance?: number | null,
      readonly stopElevationFromRailTop?: number | null,
      readonly stopElevationFromSidewalk?: number | null,
      readonly lowerCleatHeight?: number | null,
      readonly serviceAreaWidth?: number | null,
      readonly serviceAreaLength?: number | null,
      readonly platformEdgeWarningArea?: boolean | null,
      readonly guidanceTiles?: boolean | null,
      readonly guidanceStripe?: boolean | null,
      readonly serviceAreaStripes?: boolean | null,
      readonly sidewalkAccessibleConnection?: boolean | null,
      readonly stopAreaSurroundingsAccessible?: boolean | null,
      readonly curvedStop?: boolean | null,
      readonly stopType?: StopRegistryStopType | null,
      readonly shelterType?: StopRegistryShelterWidthType | null,
      readonly guidanceType?: StopRegistryGuidanceType | null,
      readonly mapType?: StopRegistryMapType | null,
      readonly pedestrianCrossingRampType?: StopRegistryPedestrianCrossingRampType | null,
      readonly accessibilityLevel?: StopRegistryAccessibilityLevel | null
    } | null,
    readonly limitations?: {
      readonly __typename?: 'stop_registry_AccessibilityLimitations',
      readonly id?: string | null,
      readonly version?: string | null,
      readonly audibleSignalsAvailable?: StopRegistryLimitationStatusType | null,
      readonly escalatorFreeAccess?: StopRegistryLimitationStatusType | null,
      readonly liftFreeAccess?: StopRegistryLimitationStatusType | null,
      readonly stepFreeAccess?: StopRegistryLimitationStatusType | null,
      readonly wheelchairAccess?: StopRegistryLimitationStatusType | null
    } | null
  } | null,
  readonly children?: ReadonlyArray<{
    readonly __typename?: 'stop_registry_StopPlace',
    readonly id?: string | null,
    readonly name?: {
      readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
      readonly value?: string | null
    } | null,
    readonly privateCode?: {
      readonly __typename?: 'stop_registry_PrivateCode',
      readonly value?: string | null
    } | null,
    readonly quays?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_Quay',
      readonly id?: string | null,
      readonly publicCode?: string | null,
      readonly description?: {
        readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
        readonly lang?: string | null,
        readonly value?: string | null
      } | null,
      readonly scheduled_stop_point?: {
        readonly __typename?: 'service_pattern_scheduled_stop_point',
        readonly priority: number,
        readonly direction: InfrastructureNetworkDirectionEnum,
        readonly scheduled_stop_point_id: UUID,
        readonly label: string,
        readonly timing_place_id?: UUID | null,
        readonly validity_start?: luxon.DateTime | null,
        readonly validity_end?: luxon.DateTime | null,
        readonly located_on_infrastructure_link_id: UUID,
        readonly stop_place_ref?: string | null,
        readonly measured_location: GeoJSON.Point,
        readonly timing_place?: {
          readonly __typename?: 'timing_pattern_timing_place',
          readonly timing_place_id: UUID,
          readonly label: string
        } | null,
        readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
          readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
          readonly vehicle_mode: ReusableComponentsVehicleModeEnum
        }>
      } | null,
      readonly keyValues?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_KeyValues',
        readonly key?: string | null,
        readonly values?: ReadonlyArray<string | null> | null
      } | null> | null,
      readonly infoSpots?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_infoSpot',
        readonly id?: string | null,
        readonly backlight?: boolean | null,
        readonly displayType?: StopRegistryDisplayType | null,
        readonly floor?: string | null,
        readonly label?: string | null,
        readonly width?: number | null,
        readonly height?: number | null,
        readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
        readonly infoSpotType?: StopRegistryInfoSpotType | null,
        readonly purpose?: string | null,
        readonly railInformation?: string | null,
        readonly speechProperty?: boolean | null,
        readonly zoneLabel?: string | null,
        readonly description?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        } | null,
        readonly poster?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_poster',
          readonly label?: string | null,
          readonly width?: number | null,
          readonly height?: number | null,
          readonly lines?: string | null
        } | null> | null
      } | null> | null,
      readonly placeEquipments?: {
        readonly __typename?: 'stop_registry_PlaceEquipments',
        readonly id?: string | null,
        readonly generalSign?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_GeneralSign',
          readonly id?: string | null,
          readonly content?: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly value?: string | null
          } | null
        } | null> | null,
        readonly shelterEquipment?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_ShelterEquipment',
          readonly id?: string | null,
          readonly shelterNumber?: number | null
        } | null> | null
      } | null
    } | null> | null
  } | null> | null,
  readonly externalLinks?: ReadonlyArray<{
    readonly __typename?: 'stop_registry_stopPlaceExternalLink',
    readonly stopPlaceId?: number | null,
    readonly orderNum?: number | null,
    readonly name?: string | null,
    readonly location?: string | null
  } | null> | null,
  readonly organisations?: ReadonlyArray<{
    readonly __typename?: 'stop_registry_StopPlaceOrganisationRef',
    readonly organisationRef: string,
    readonly relationshipType?: StopRegistryStopPlaceOrganisationRelationshipType | null,
    readonly organisation?: {
      readonly __typename?: 'stop_registry_Organisation',
      readonly id?: string | null,
      readonly name?: string | null,
      readonly privateContactDetails?: {
        readonly __typename?: 'stop_registry_Contact',
        readonly id?: string | null,
        readonly email?: string | null,
        readonly phone?: string | null
      } | null
    } | null
  } | null> | null
};

export type MemberStopStopPlaceDetailsFragment = {
  readonly __typename?: 'stop_registry_StopPlace',
  readonly id?: string | null,
  readonly name?: {
    readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
    readonly value?: string | null
  } | null,
  readonly privateCode?: {
    readonly __typename?: 'stop_registry_PrivateCode',
    readonly value?: string | null
  } | null,
  readonly quays?: ReadonlyArray<{
    readonly __typename?: 'stop_registry_Quay',
    readonly id?: string | null,
    readonly publicCode?: string | null,
    readonly description?: {
      readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
      readonly lang?: string | null,
      readonly value?: string | null
    } | null,
    readonly scheduled_stop_point?: {
      readonly __typename?: 'service_pattern_scheduled_stop_point',
      readonly priority: number,
      readonly direction: InfrastructureNetworkDirectionEnum,
      readonly scheduled_stop_point_id: UUID,
      readonly label: string,
      readonly timing_place_id?: UUID | null,
      readonly validity_start?: luxon.DateTime | null,
      readonly validity_end?: luxon.DateTime | null,
      readonly located_on_infrastructure_link_id: UUID,
      readonly stop_place_ref?: string | null,
      readonly measured_location: GeoJSON.Point,
      readonly timing_place?: {
        readonly __typename?: 'timing_pattern_timing_place',
        readonly timing_place_id: UUID,
        readonly label: string
      } | null,
      readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
        readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
        readonly vehicle_mode: ReusableComponentsVehicleModeEnum
      }>
    } | null,
    readonly keyValues?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_KeyValues',
      readonly key?: string | null,
      readonly values?: ReadonlyArray<string | null> | null
    } | null> | null,
    readonly infoSpots?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_infoSpot',
      readonly id?: string | null,
      readonly backlight?: boolean | null,
      readonly displayType?: StopRegistryDisplayType | null,
      readonly floor?: string | null,
      readonly label?: string | null,
      readonly width?: number | null,
      readonly height?: number | null,
      readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
      readonly infoSpotType?: StopRegistryInfoSpotType | null,
      readonly purpose?: string | null,
      readonly railInformation?: string | null,
      readonly speechProperty?: boolean | null,
      readonly zoneLabel?: string | null,
      readonly description?: {
        readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
        readonly lang?: string | null,
        readonly value?: string | null
      } | null,
      readonly poster?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_poster',
        readonly label?: string | null,
        readonly width?: number | null,
        readonly height?: number | null,
        readonly lines?: string | null
      } | null> | null
    } | null> | null,
    readonly placeEquipments?: {
      readonly __typename?: 'stop_registry_PlaceEquipments',
      readonly id?: string | null,
      readonly generalSign?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_GeneralSign',
        readonly id?: string | null,
        readonly content?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly value?: string | null
        } | null
      } | null> | null,
      readonly shelterEquipment?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_ShelterEquipment',
        readonly id?: string | null,
        readonly shelterNumber?: number | null
      } | null> | null
    } | null
  } | null> | null
};

export type MemberStopQuayDetailsFragment = {
  readonly __typename?: 'stop_registry_Quay',
  readonly id?: string | null,
  readonly publicCode?: string | null,
  readonly description?: {
    readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
    readonly lang?: string | null,
    readonly value?: string | null
  } | null,
  readonly scheduled_stop_point?: {
    readonly __typename?: 'service_pattern_scheduled_stop_point',
    readonly priority: number,
    readonly direction: InfrastructureNetworkDirectionEnum,
    readonly scheduled_stop_point_id: UUID,
    readonly label: string,
    readonly timing_place_id?: UUID | null,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly located_on_infrastructure_link_id: UUID,
    readonly stop_place_ref?: string | null,
    readonly measured_location: GeoJSON.Point,
    readonly timing_place?: {
      readonly __typename?: 'timing_pattern_timing_place',
      readonly timing_place_id: UUID,
      readonly label: string
    } | null,
    readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
      readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
      readonly vehicle_mode: ReusableComponentsVehicleModeEnum
    }>
  } | null,
  readonly keyValues?: ReadonlyArray<{
    readonly __typename?: 'stop_registry_KeyValues',
    readonly key?: string | null,
    readonly values?: ReadonlyArray<string | null> | null
  } | null> | null,
  readonly infoSpots?: ReadonlyArray<{
    readonly __typename?: 'stop_registry_infoSpot',
    readonly id?: string | null,
    readonly backlight?: boolean | null,
    readonly displayType?: StopRegistryDisplayType | null,
    readonly floor?: string | null,
    readonly label?: string | null,
    readonly width?: number | null,
    readonly height?: number | null,
    readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
    readonly infoSpotType?: StopRegistryInfoSpotType | null,
    readonly purpose?: string | null,
    readonly railInformation?: string | null,
    readonly speechProperty?: boolean | null,
    readonly zoneLabel?: string | null,
    readonly description?: {
      readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
      readonly lang?: string | null,
      readonly value?: string | null
    } | null,
    readonly poster?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_poster',
      readonly label?: string | null,
      readonly width?: number | null,
      readonly height?: number | null,
      readonly lines?: string | null
    } | null> | null
  } | null> | null,
  readonly placeEquipments?: {
    readonly __typename?: 'stop_registry_PlaceEquipments',
    readonly id?: string | null,
    readonly generalSign?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_GeneralSign',
      readonly id?: string | null,
      readonly content?: {
        readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
        readonly value?: string | null
      } | null
    } | null> | null,
    readonly shelterEquipment?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_ShelterEquipment',
      readonly id?: string | null,
      readonly shelterNumber?: number | null
    } | null> | null
  } | null
};

export type TerminalExternalLinksDetailsFragment = {
  readonly __typename?: 'stop_registry_stopPlaceExternalLink',
  readonly stopPlaceId?: number | null,
  readonly orderNum?: number | null,
  readonly name?: string | null,
  readonly location?: string | null
};

export type TerminalOrganizationRefFragment = {
  readonly __typename?: 'stop_registry_StopPlaceOrganisationRef',
  readonly organisationRef: string,
  readonly relationshipType?: StopRegistryStopPlaceOrganisationRelationshipType | null,
  readonly organisation?: {
    readonly __typename?: 'stop_registry_Organisation',
    readonly id?: string | null,
    readonly name?: string | null,
    readonly privateContactDetails?: {
      readonly __typename?: 'stop_registry_Contact',
      readonly id?: string | null,
      readonly email?: string | null,
      readonly phone?: string | null
    } | null
  } | null
};

export type VehicleJourneyByStopFragment = {
  readonly __typename?: 'timetables_vehicle_journey_vehicle_journey',
  readonly journey_pattern_ref_id: UUID,
  readonly vehicle_journey_id: UUID,
  readonly timetabled_passing_times: ReadonlyArray<{
    readonly __typename?: 'timetables_passing_times_timetabled_passing_time',
    readonly arrival_time?: luxon.Duration | null,
    readonly departure_time?: luxon.Duration | null,
    readonly passing_time: luxon.Duration,
    readonly scheduled_stop_point_in_journey_pattern_ref_id: UUID,
    readonly timetabled_passing_time_id: UUID,
    readonly vehicle_journey_id: UUID,
    readonly scheduled_stop_point_in_journey_pattern_ref: {
      readonly __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref',
      readonly scheduled_stop_point_in_journey_pattern_ref_id: UUID,
      readonly scheduled_stop_point_label: string,
      readonly journey_pattern_ref: {
        readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref',
        readonly journey_pattern_ref_id: UUID,
        readonly observation_timestamp: luxon.DateTime
      },
      readonly scheduled_stop_point_instances: ReadonlyArray<{
        readonly __typename?: 'service_pattern_scheduled_stop_point',
        readonly priority: number,
        readonly direction: InfrastructureNetworkDirectionEnum,
        readonly scheduled_stop_point_id: UUID,
        readonly label: string,
        readonly timing_place_id?: UUID | null,
        readonly validity_start?: luxon.DateTime | null,
        readonly validity_end?: luxon.DateTime | null,
        readonly located_on_infrastructure_link_id: UUID,
        readonly stop_place_ref?: string | null,
        readonly timing_place?: {
          readonly __typename?: 'timing_pattern_timing_place',
          readonly label: string,
          readonly timing_place_id: UUID
        } | null
      }>
    },
    readonly vehicle_journey: {
      readonly __typename?: 'timetables_vehicle_journey_vehicle_journey',
      readonly vehicle_journey_id: UUID,
      readonly block: {
        readonly __typename?: 'timetables_vehicle_service_block',
        readonly block_id: UUID,
        readonly vehicle_type?: {
          readonly __typename?: 'timetables_vehicle_type_vehicle_type',
          readonly description_i18n?: any | null,
          readonly vehicle_type_id: UUID
        } | null
      }
    }
  }>
};

export type PassingTimeByStopFragment = {
  readonly __typename?: 'timetables_passing_times_timetabled_passing_time',
  readonly arrival_time?: luxon.Duration | null,
  readonly departure_time?: luxon.Duration | null,
  readonly passing_time: luxon.Duration,
  readonly scheduled_stop_point_in_journey_pattern_ref_id: UUID,
  readonly timetabled_passing_time_id: UUID,
  readonly vehicle_journey_id: UUID,
  readonly scheduled_stop_point_in_journey_pattern_ref: {
    readonly __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref',
    readonly scheduled_stop_point_in_journey_pattern_ref_id: UUID,
    readonly scheduled_stop_point_label: string,
    readonly journey_pattern_ref: {
      readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref',
      readonly journey_pattern_ref_id: UUID,
      readonly observation_timestamp: luxon.DateTime
    },
    readonly scheduled_stop_point_instances: ReadonlyArray<{
      readonly __typename?: 'service_pattern_scheduled_stop_point',
      readonly priority: number,
      readonly direction: InfrastructureNetworkDirectionEnum,
      readonly scheduled_stop_point_id: UUID,
      readonly label: string,
      readonly timing_place_id?: UUID | null,
      readonly validity_start?: luxon.DateTime | null,
      readonly validity_end?: luxon.DateTime | null,
      readonly located_on_infrastructure_link_id: UUID,
      readonly stop_place_ref?: string | null,
      readonly timing_place?: {
        readonly __typename?: 'timing_pattern_timing_place',
        readonly label: string,
        readonly timing_place_id: UUID
      } | null
    }>
  },
  readonly vehicle_journey: {
    readonly __typename?: 'timetables_vehicle_journey_vehicle_journey',
    readonly vehicle_journey_id: UUID,
    readonly block: {
      readonly __typename?: 'timetables_vehicle_service_block',
      readonly block_id: UUID,
      readonly vehicle_type?: {
        readonly __typename?: 'timetables_vehicle_type_vehicle_type',
        readonly description_i18n?: any | null,
        readonly vehicle_type_id: UUID
      } | null
    }
  }
};

export type GetRouteWithJourneyPatternQueryVariables = Exact<{
  routeId: Scalars['uuid']['input'];
}>;


export type GetRouteWithJourneyPatternQuery = {
  readonly __typename?: 'query_root',
  readonly route_route_by_pk?: {
    readonly __typename?: 'route_route',
    readonly route_shape?: GeoJSON.LineString | null,
    readonly name_i18n: LocalizedString,
    readonly description_i18n?: LocalizedString | null,
    readonly origin_name_i18n: LocalizedString,
    readonly origin_short_name_i18n: LocalizedString,
    readonly destination_name_i18n: LocalizedString,
    readonly destination_short_name_i18n: LocalizedString,
    readonly on_line_id: UUID,
    readonly label: string,
    readonly direction: RouteDirectionEnum,
    readonly variant?: number | null,
    readonly route_id: UUID,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly priority: number,
    readonly route_journey_patterns: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly on_route_id: UUID,
      readonly ordered_scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
        readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly scheduled_stop_point_label: string,
        readonly scheduled_stop_point_sequence: number,
        readonly is_used_as_timing_point: boolean,
        readonly is_regulated_timing_point: boolean,
        readonly is_loading_time_allowed: boolean,
        readonly is_via_point: boolean,
        readonly via_point_name_i18n?: LocalizedString | null,
        readonly via_point_short_name_i18n?: LocalizedString | null,
        readonly scheduled_stop_points: ReadonlyArray<{
          readonly __typename?: 'service_pattern_scheduled_stop_point',
          readonly priority: number,
          readonly direction: InfrastructureNetworkDirectionEnum,
          readonly scheduled_stop_point_id: UUID,
          readonly label: string,
          readonly timing_place_id?: UUID | null,
          readonly validity_start?: luxon.DateTime | null,
          readonly validity_end?: luxon.DateTime | null,
          readonly located_on_infrastructure_link_id: UUID,
          readonly stop_place_ref?: string | null,
          readonly timing_place?: {
            readonly __typename?: 'timing_pattern_timing_place',
            readonly timing_place_id: UUID,
            readonly label: string
          } | null
        }>,
        readonly journey_pattern: {
          readonly __typename?: 'journey_pattern_journey_pattern',
          readonly journey_pattern_id: UUID,
          readonly on_route_id: UUID
        }
      }>
    }>
  } | null
};

export type RouteInfraLinkFieldsFragment = {
  readonly __typename?: 'infrastructure_network_infrastructure_link',
  readonly external_link_source: InfrastructureNetworkExternalSourceEnum,
  readonly external_link_id: string,
  readonly infrastructure_link_id: UUID,
  readonly shape: GeoJSON.LineString,
  readonly direction: InfrastructureNetworkDirectionEnum,
  readonly scheduled_stop_points_located_on_infrastructure_link: ReadonlyArray<{
    readonly __typename?: 'service_pattern_scheduled_stop_point',
    readonly measured_location: GeoJSON.Point,
    readonly relative_distance_from_infrastructure_link_start: number,
    readonly closest_point_on_infrastructure_link?: GeoJSON.Point | null,
    readonly priority: number,
    readonly direction: InfrastructureNetworkDirectionEnum,
    readonly scheduled_stop_point_id: UUID,
    readonly label: string,
    readonly timing_place_id?: UUID | null,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly located_on_infrastructure_link_id: UUID,
    readonly stop_place_ref?: string | null,
    readonly stop_place?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_ParentStopPlace',
      readonly id?: string | null,
      readonly name?: {
        readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
        readonly lang?: string | null,
        readonly value?: string | null
      } | null
    } | {
      readonly __typename?: 'stop_registry_StopPlace',
      readonly id?: string | null,
      readonly name?: {
        readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
        readonly lang?: string | null,
        readonly value?: string | null
      } | null
    } | null> | null,
    readonly other_label_instances: ReadonlyArray<{
      readonly __typename?: 'service_pattern_scheduled_stop_point',
      readonly priority: number,
      readonly direction: InfrastructureNetworkDirectionEnum,
      readonly scheduled_stop_point_id: UUID,
      readonly label: string,
      readonly timing_place_id?: UUID | null,
      readonly validity_start?: luxon.DateTime | null,
      readonly validity_end?: luxon.DateTime | null,
      readonly located_on_infrastructure_link_id: UUID,
      readonly stop_place_ref?: string | null,
      readonly timing_place?: {
        readonly __typename?: 'timing_pattern_timing_place',
        readonly timing_place_id: UUID,
        readonly label: string
      } | null
    }>,
    readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly scheduled_stop_point_label: string,
      readonly scheduled_stop_point_sequence: number,
      readonly is_used_as_timing_point: boolean,
      readonly is_regulated_timing_point: boolean,
      readonly is_loading_time_allowed: boolean,
      readonly is_via_point: boolean,
      readonly via_point_name_i18n?: LocalizedString | null,
      readonly via_point_short_name_i18n?: LocalizedString | null,
      readonly journey_pattern: {
        readonly __typename?: 'journey_pattern_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly on_route_id: UUID
      }
    }>,
    readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
      readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
      readonly vehicle_mode: ReusableComponentsVehicleModeEnum
    }>,
    readonly timing_place?: {
      readonly __typename?: 'timing_pattern_timing_place',
      readonly timing_place_id: UUID,
      readonly label: string
    } | null
  }>
};

export type InfraLinkAlongRouteDefaultFieldsFragment = {
  readonly __typename?: 'route_infrastructure_link_along_route',
  readonly infrastructure_link_id: UUID,
  readonly is_traversal_forwards: boolean,
  readonly infrastructure_link: {
    readonly __typename?: 'infrastructure_network_infrastructure_link',
    readonly infrastructure_link_id: UUID
  }
};

export type InfrastructureLinkDefaultFieldsFragment = {
  readonly __typename?: 'infrastructure_network_infrastructure_link',
  readonly infrastructure_link_id: UUID
};

export type InfrastructureLinkAllFieldsFragment = {
  readonly __typename?: 'infrastructure_network_infrastructure_link',
  readonly direction: InfrastructureNetworkDirectionEnum,
  readonly shape: GeoJSON.LineString,
  readonly estimated_length_in_metres?: number | null,
  readonly external_link_id: string,
  readonly external_link_source: InfrastructureNetworkExternalSourceEnum,
  readonly infrastructure_link_id: UUID
};

export type InfraLinkMatchingFieldsFragment = {
  readonly __typename?: 'infrastructure_network_infrastructure_link',
  readonly external_link_id: string,
  readonly infrastructure_link_id: UUID,
  readonly shape: GeoJSON.LineString,
  readonly direction: InfrastructureNetworkDirectionEnum
};

export type QueryClosestLinkQueryVariables = Exact<{
  point?: InputMaybe<Scalars['geography']['input']>;
}>;


export type QueryClosestLinkQuery = {
  readonly __typename?: 'query_root',
  readonly infrastructure_network_resolve_point_to_closest_link: ReadonlyArray<{
    readonly __typename?: 'infrastructure_network_infrastructure_link',
    readonly direction: InfrastructureNetworkDirectionEnum,
    readonly shape: GeoJSON.LineString,
    readonly estimated_length_in_metres?: number | null,
    readonly external_link_id: string,
    readonly external_link_source: InfrastructureNetworkExternalSourceEnum,
    readonly infrastructure_link_id: UUID
  }>
};

export type QueryPointDirectionOnLinkQueryVariables = Exact<{
  point_of_interest?: InputMaybe<Scalars['geography']['input']>;
  infrastructure_link_uuid?: InputMaybe<Scalars['uuid']['input']>;
  point_max_distance_in_meters?: InputMaybe<Scalars['float8']['input']>;
}>;


export type QueryPointDirectionOnLinkQuery = {
  readonly __typename?: 'query_root',
  readonly infrastructure_network_find_point_direction_on_link: ReadonlyArray<{
    readonly __typename?: 'infrastructure_network_direction',
    readonly value: InfrastructureNetworkDirectionEnum
  }>
};

export type GetStopsAlongInfrastructureLinksQueryVariables = Exact<{
  infrastructure_link_ids?: InputMaybe<ReadonlyArray<Scalars['uuid']['input']> | Scalars['uuid']['input']>;
}>;


export type GetStopsAlongInfrastructureLinksQuery = {
  readonly __typename?: 'query_root',
  readonly service_pattern_scheduled_stop_point: ReadonlyArray<{
    readonly __typename?: 'service_pattern_scheduled_stop_point',
    readonly measured_location: GeoJSON.Point,
    readonly relative_distance_from_infrastructure_link_start: number,
    readonly closest_point_on_infrastructure_link?: GeoJSON.Point | null,
    readonly priority: number,
    readonly direction: InfrastructureNetworkDirectionEnum,
    readonly scheduled_stop_point_id: UUID,
    readonly label: string,
    readonly timing_place_id?: UUID | null,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly located_on_infrastructure_link_id: UUID,
    readonly stop_place_ref?: string | null,
    readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
      readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
      readonly vehicle_mode: ReusableComponentsVehicleModeEnum
    }>,
    readonly timing_place?: {
      readonly __typename?: 'timing_pattern_timing_place',
      readonly timing_place_id: UUID,
      readonly label: string
    } | null
  }>
};

export type ScheduledStopPointInJourneyPatternAllFieldsFragment = {
  readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
  readonly journey_pattern_id: UUID,
  readonly scheduled_stop_point_label: string,
  readonly scheduled_stop_point_sequence: number,
  readonly is_used_as_timing_point: boolean,
  readonly is_regulated_timing_point: boolean,
  readonly is_loading_time_allowed: boolean,
  readonly is_via_point: boolean,
  readonly via_point_name_i18n?: LocalizedString | null,
  readonly via_point_short_name_i18n?: LocalizedString | null,
  readonly journey_pattern: {
    readonly __typename?: 'journey_pattern_journey_pattern',
    readonly journey_pattern_id: UUID,
    readonly on_route_id: UUID
  }
};

export type JourneyPatternWithStopsFragment = {
  readonly __typename?: 'journey_pattern_journey_pattern',
  readonly journey_pattern_id: UUID,
  readonly on_route_id: UUID,
  readonly ordered_scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
    readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
    readonly journey_pattern_id: UUID,
    readonly scheduled_stop_point_label: string,
    readonly scheduled_stop_point_sequence: number,
    readonly is_used_as_timing_point: boolean,
    readonly is_regulated_timing_point: boolean,
    readonly is_loading_time_allowed: boolean,
    readonly is_via_point: boolean,
    readonly via_point_name_i18n?: LocalizedString | null,
    readonly via_point_short_name_i18n?: LocalizedString | null,
    readonly scheduled_stop_points: ReadonlyArray<{
      readonly __typename?: 'service_pattern_scheduled_stop_point',
      readonly priority: number,
      readonly direction: InfrastructureNetworkDirectionEnum,
      readonly scheduled_stop_point_id: UUID,
      readonly label: string,
      readonly timing_place_id?: UUID | null,
      readonly validity_start?: luxon.DateTime | null,
      readonly validity_end?: luxon.DateTime | null,
      readonly located_on_infrastructure_link_id: UUID,
      readonly stop_place_ref?: string | null,
      readonly timing_place?: {
        readonly __typename?: 'timing_pattern_timing_place',
        readonly timing_place_id: UUID,
        readonly label: string
      } | null
    }>,
    readonly journey_pattern: {
      readonly __typename?: 'journey_pattern_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly on_route_id: UUID
    }
  }>
};

export type PatchScheduledStopPointViaInfoMutationVariables = Exact<{
  stopLabel: Scalars['String']['input'];
  journeyPatternId: Scalars['uuid']['input'];
  patch: JourneyPatternScheduledStopPointInJourneyPatternSetInput;
}>;


export type PatchScheduledStopPointViaInfoMutation = {
  readonly __typename?: 'mutation_root',
  readonly update_journey_pattern_scheduled_stop_point_in_journey_pattern?: {
    readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_mutation_response',
    readonly returning: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly scheduled_stop_point_label: string,
      readonly scheduled_stop_point_sequence: number,
      readonly is_used_as_timing_point: boolean,
      readonly is_regulated_timing_point: boolean,
      readonly is_loading_time_allowed: boolean,
      readonly is_via_point: boolean,
      readonly via_point_name_i18n?: LocalizedString | null,
      readonly via_point_short_name_i18n?: LocalizedString | null,
      readonly journey_pattern: {
        readonly __typename?: 'journey_pattern_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly on_route_id: UUID
      }
    }>
  } | null
};

export type RemoveScheduledStopPointViaInfoMutationVariables = Exact<{
  stopLabel: Scalars['String']['input'];
  journeyPatternId: Scalars['uuid']['input'];
}>;


export type RemoveScheduledStopPointViaInfoMutation = {
  readonly __typename?: 'mutation_root',
  readonly update_journey_pattern_scheduled_stop_point_in_journey_pattern?: {
    readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_mutation_response',
    readonly returning: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly scheduled_stop_point_label: string,
      readonly scheduled_stop_point_sequence: number,
      readonly is_used_as_timing_point: boolean,
      readonly is_regulated_timing_point: boolean,
      readonly is_loading_time_allowed: boolean,
      readonly is_via_point: boolean,
      readonly via_point_name_i18n?: LocalizedString | null,
      readonly via_point_short_name_i18n?: LocalizedString | null,
      readonly journey_pattern: {
        readonly __typename?: 'journey_pattern_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly on_route_id: UUID
      }
    }>
  } | null
};

export type GetScheduledStopPointWithViaInfoQueryVariables = Exact<{
  journeyPatternId: Scalars['uuid']['input'];
  stopLabel: Scalars['String']['input'];
}>;


export type GetScheduledStopPointWithViaInfoQuery = {
  readonly __typename?: 'query_root',
  readonly journey_pattern_scheduled_stop_point_in_journey_pattern: ReadonlyArray<{
    readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
    readonly journey_pattern_id: UUID,
    readonly scheduled_stop_point_label: string,
    readonly scheduled_stop_point_sequence: number,
    readonly is_used_as_timing_point: boolean,
    readonly is_regulated_timing_point: boolean,
    readonly is_loading_time_allowed: boolean,
    readonly is_via_point: boolean,
    readonly via_point_name_i18n?: LocalizedString | null,
    readonly via_point_short_name_i18n?: LocalizedString | null,
    readonly journey_pattern: {
      readonly __typename?: 'journey_pattern_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly on_route_id: UUID,
      readonly journey_pattern_route?: {
        readonly __typename?: 'route_route',
        readonly route_id: UUID,
        readonly label: string
      } | null
    }
  }>
};

export type LineDefaultFieldsFragment = {
  readonly __typename?: 'route_line',
  readonly line_id: UUID,
  readonly label: string,
  readonly name_i18n: LocalizedString,
  readonly short_name_i18n: LocalizedString,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly priority: number
};

export type LineAllFieldsFragment = {
  readonly __typename?: 'route_line',
  readonly primary_vehicle_mode: ReusableComponentsVehicleModeEnum,
  readonly type_of_line: RouteTypeOfLineEnum,
  readonly transport_target: HslRouteTransportTargetEnum,
  readonly line_id: UUID,
  readonly label: string,
  readonly name_i18n: LocalizedString,
  readonly short_name_i18n: LocalizedString,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly priority: number
};

export type RouteValidityFragment = {
  readonly __typename?: 'route_route',
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly priority: number
};

export type RouteUniqueFieldsFragment = {
  readonly __typename?: 'route_route',
  readonly label: string,
  readonly direction: RouteDirectionEnum,
  readonly variant?: number | null,
  readonly route_id: UUID,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly priority: number
};

export type RouteAllFieldsFragment = {
  readonly __typename?: 'route_route',
  readonly route_shape?: GeoJSON.LineString | null,
  readonly name_i18n: LocalizedString,
  readonly description_i18n?: LocalizedString | null,
  readonly origin_name_i18n: LocalizedString,
  readonly origin_short_name_i18n: LocalizedString,
  readonly destination_name_i18n: LocalizedString,
  readonly destination_short_name_i18n: LocalizedString,
  readonly on_line_id: UUID,
  readonly label: string,
  readonly direction: RouteDirectionEnum,
  readonly variant?: number | null,
  readonly route_id: UUID,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly priority: number
};

export type RouteDefaultFieldsFragment = {
  readonly __typename?: 'route_route',
  readonly name_i18n: LocalizedString,
  readonly description_i18n?: LocalizedString | null,
  readonly origin_name_i18n: LocalizedString,
  readonly origin_short_name_i18n: LocalizedString,
  readonly destination_name_i18n: LocalizedString,
  readonly destination_short_name_i18n: LocalizedString,
  readonly on_line_id: UUID,
  readonly label: string,
  readonly direction: RouteDirectionEnum,
  readonly variant?: number | null,
  readonly route_id: UUID,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly priority: number
};

export type RouteWithJourneyPatternStopsFragment = {
  readonly __typename?: 'route_route',
  readonly route_shape?: GeoJSON.LineString | null,
  readonly name_i18n: LocalizedString,
  readonly description_i18n?: LocalizedString | null,
  readonly origin_name_i18n: LocalizedString,
  readonly origin_short_name_i18n: LocalizedString,
  readonly destination_name_i18n: LocalizedString,
  readonly destination_short_name_i18n: LocalizedString,
  readonly on_line_id: UUID,
  readonly label: string,
  readonly direction: RouteDirectionEnum,
  readonly variant?: number | null,
  readonly route_id: UUID,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly priority: number,
  readonly route_journey_patterns: ReadonlyArray<{
    readonly __typename?: 'journey_pattern_journey_pattern',
    readonly journey_pattern_id: UUID,
    readonly on_route_id: UUID,
    readonly ordered_scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly scheduled_stop_point_label: string,
      readonly scheduled_stop_point_sequence: number,
      readonly is_used_as_timing_point: boolean,
      readonly is_regulated_timing_point: boolean,
      readonly is_loading_time_allowed: boolean,
      readonly is_via_point: boolean,
      readonly via_point_name_i18n?: LocalizedString | null,
      readonly via_point_short_name_i18n?: LocalizedString | null,
      readonly scheduled_stop_points: ReadonlyArray<{
        readonly __typename?: 'service_pattern_scheduled_stop_point',
        readonly priority: number,
        readonly direction: InfrastructureNetworkDirectionEnum,
        readonly scheduled_stop_point_id: UUID,
        readonly label: string,
        readonly timing_place_id?: UUID | null,
        readonly validity_start?: luxon.DateTime | null,
        readonly validity_end?: luxon.DateTime | null,
        readonly located_on_infrastructure_link_id: UUID,
        readonly stop_place_ref?: string | null,
        readonly timing_place?: {
          readonly __typename?: 'timing_pattern_timing_place',
          readonly timing_place_id: UUID,
          readonly label: string
        } | null
      }>,
      readonly journey_pattern: {
        readonly __typename?: 'journey_pattern_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly on_route_id: UUID
      }
    }>
  }>
};

export type RouteWithInfrastructureLinksFragment = {
  readonly __typename?: 'route_route',
  readonly route_shape?: GeoJSON.LineString | null,
  readonly name_i18n: LocalizedString,
  readonly description_i18n?: LocalizedString | null,
  readonly origin_name_i18n: LocalizedString,
  readonly origin_short_name_i18n: LocalizedString,
  readonly destination_name_i18n: LocalizedString,
  readonly destination_short_name_i18n: LocalizedString,
  readonly on_line_id: UUID,
  readonly label: string,
  readonly direction: RouteDirectionEnum,
  readonly variant?: number | null,
  readonly route_id: UUID,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly priority: number,
  readonly route_line: {
    readonly __typename?: 'route_line',
    readonly primary_vehicle_mode: ReusableComponentsVehicleModeEnum,
    readonly type_of_line: RouteTypeOfLineEnum,
    readonly transport_target: HslRouteTransportTargetEnum,
    readonly line_id: UUID,
    readonly label: string,
    readonly name_i18n: LocalizedString,
    readonly short_name_i18n: LocalizedString,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly priority: number
  },
  readonly infrastructure_links_along_route: ReadonlyArray<{
    readonly __typename?: 'route_infrastructure_link_along_route',
    readonly route_id: UUID,
    readonly infrastructure_link_sequence: number,
    readonly infrastructure_link_id: UUID,
    readonly is_traversal_forwards: boolean,
    readonly infrastructure_link: {
      readonly __typename?: 'infrastructure_network_infrastructure_link',
      readonly infrastructure_link_id: UUID,
      readonly shape: GeoJSON.LineString,
      readonly direction: InfrastructureNetworkDirectionEnum,
      readonly external_link_id: string,
      readonly external_link_source: InfrastructureNetworkExternalSourceEnum
    }
  }>
};

export type GetLineDetailsByIdQueryVariables = Exact<{
  line_id: Scalars['uuid']['input'];
}>;


export type GetLineDetailsByIdQuery = {
  readonly __typename?: 'query_root',
  readonly route_line_by_pk?: {
    readonly __typename?: 'route_line',
    readonly primary_vehicle_mode: ReusableComponentsVehicleModeEnum,
    readonly type_of_line: RouteTypeOfLineEnum,
    readonly transport_target: HslRouteTransportTargetEnum,
    readonly line_id: UUID,
    readonly label: string,
    readonly name_i18n: LocalizedString,
    readonly short_name_i18n: LocalizedString,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly priority: number
  } | null
};

export type GetLineValidityPeriodByIdQueryVariables = Exact<{
  line_id: Scalars['uuid']['input'];
}>;


export type GetLineValidityPeriodByIdQuery = {
  readonly __typename?: 'query_root',
  readonly route_line_by_pk?: {
    readonly __typename?: 'route_line',
    readonly line_id: UUID,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null
  } | null
};

export type GetLinesByValidityQueryVariables = Exact<{
  filter?: InputMaybe<RouteLineBoolExp>;
}>;


export type GetLinesByValidityQuery = {
  readonly __typename?: 'query_root',
  readonly route_line: ReadonlyArray<{
    readonly __typename?: 'route_line',
    readonly primary_vehicle_mode: ReusableComponentsVehicleModeEnum,
    readonly type_of_line: RouteTypeOfLineEnum,
    readonly transport_target: HslRouteTransportTargetEnum,
    readonly line_id: UUID,
    readonly label: string,
    readonly name_i18n: LocalizedString,
    readonly short_name_i18n: LocalizedString,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly priority: number
  }>
};

export type GetLineDetailsWithRoutesByIdQueryVariables = Exact<{
  line_id: Scalars['uuid']['input'];
}>;


export type GetLineDetailsWithRoutesByIdQuery = {
  readonly __typename?: 'query_root',
  readonly route_line_by_pk?: {
    readonly __typename?: 'route_line',
    readonly primary_vehicle_mode: ReusableComponentsVehicleModeEnum,
    readonly type_of_line: RouteTypeOfLineEnum,
    readonly transport_target: HslRouteTransportTargetEnum,
    readonly line_id: UUID,
    readonly label: string,
    readonly name_i18n: LocalizedString,
    readonly short_name_i18n: LocalizedString,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly priority: number,
    readonly line_routes: ReadonlyArray<{
      readonly __typename?: 'route_route',
      readonly route_shape?: GeoJSON.LineString | null,
      readonly name_i18n: LocalizedString,
      readonly description_i18n?: LocalizedString | null,
      readonly origin_name_i18n: LocalizedString,
      readonly origin_short_name_i18n: LocalizedString,
      readonly destination_name_i18n: LocalizedString,
      readonly destination_short_name_i18n: LocalizedString,
      readonly on_line_id: UUID,
      readonly label: string,
      readonly direction: RouteDirectionEnum,
      readonly variant?: number | null,
      readonly route_id: UUID,
      readonly validity_start?: luxon.DateTime | null,
      readonly validity_end?: luxon.DateTime | null,
      readonly priority: number,
      readonly infrastructure_links_along_route: ReadonlyArray<{
        readonly __typename?: 'route_infrastructure_link_along_route',
        readonly route_id: UUID,
        readonly infrastructure_link_id: UUID,
        readonly infrastructure_link_sequence: number,
        readonly is_traversal_forwards: boolean,
        readonly infrastructure_link: {
          readonly __typename?: 'infrastructure_network_infrastructure_link',
          readonly infrastructure_link_id: UUID,
          readonly scheduled_stop_points_located_on_infrastructure_link: ReadonlyArray<{
            readonly __typename?: 'service_pattern_scheduled_stop_point',
            readonly measured_location: GeoJSON.Point,
            readonly relative_distance_from_infrastructure_link_start: number,
            readonly closest_point_on_infrastructure_link?: GeoJSON.Point | null,
            readonly priority: number,
            readonly direction: InfrastructureNetworkDirectionEnum,
            readonly scheduled_stop_point_id: UUID,
            readonly label: string,
            readonly timing_place_id?: UUID | null,
            readonly validity_start?: luxon.DateTime | null,
            readonly validity_end?: luxon.DateTime | null,
            readonly located_on_infrastructure_link_id: UUID,
            readonly stop_place_ref?: string | null,
            readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
              readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
              readonly journey_pattern_id: UUID,
              readonly scheduled_stop_point_label: string,
              readonly scheduled_stop_point_sequence: number,
              readonly is_used_as_timing_point: boolean,
              readonly is_regulated_timing_point: boolean,
              readonly is_loading_time_allowed: boolean,
              readonly is_via_point: boolean,
              readonly via_point_name_i18n?: LocalizedString | null,
              readonly via_point_short_name_i18n?: LocalizedString | null,
              readonly journey_pattern: {
                readonly __typename?: 'journey_pattern_journey_pattern',
                readonly journey_pattern_id: UUID,
                readonly on_route_id: UUID
              }
            }>,
            readonly other_label_instances: ReadonlyArray<{
              readonly __typename?: 'service_pattern_scheduled_stop_point',
              readonly priority: number,
              readonly direction: InfrastructureNetworkDirectionEnum,
              readonly scheduled_stop_point_id: UUID,
              readonly label: string,
              readonly timing_place_id?: UUID | null,
              readonly validity_start?: luxon.DateTime | null,
              readonly validity_end?: luxon.DateTime | null,
              readonly located_on_infrastructure_link_id: UUID,
              readonly stop_place_ref?: string | null,
              readonly timing_place?: {
                readonly __typename?: 'timing_pattern_timing_place',
                readonly timing_place_id: UUID,
                readonly label: string
              } | null
            }>,
            readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
              readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
              readonly vehicle_mode: ReusableComponentsVehicleModeEnum
            }>,
            readonly timing_place?: {
              readonly __typename?: 'timing_pattern_timing_place',
              readonly timing_place_id: UUID,
              readonly label: string
            } | null
          }>
        }
      }>
    }>
  } | null
};

export type GetRoutesWithStopsQueryVariables = Exact<{
  routeFilters?: InputMaybe<RouteRouteBoolExp>;
}>;


export type GetRoutesWithStopsQuery = {
  readonly __typename?: 'query_root',
  readonly route_route: ReadonlyArray<{
    readonly __typename?: 'route_route',
    readonly route_shape?: GeoJSON.LineString | null,
    readonly name_i18n: LocalizedString,
    readonly description_i18n?: LocalizedString | null,
    readonly origin_name_i18n: LocalizedString,
    readonly origin_short_name_i18n: LocalizedString,
    readonly destination_name_i18n: LocalizedString,
    readonly destination_short_name_i18n: LocalizedString,
    readonly on_line_id: UUID,
    readonly label: string,
    readonly direction: RouteDirectionEnum,
    readonly variant?: number | null,
    readonly route_id: UUID,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly priority: number,
    readonly route_line: {
      readonly __typename?: 'route_line',
      readonly primary_vehicle_mode: ReusableComponentsVehicleModeEnum,
      readonly type_of_line: RouteTypeOfLineEnum,
      readonly transport_target: HslRouteTransportTargetEnum,
      readonly line_id: UUID,
      readonly label: string,
      readonly name_i18n: LocalizedString,
      readonly short_name_i18n: LocalizedString,
      readonly validity_start?: luxon.DateTime | null,
      readonly validity_end?: luxon.DateTime | null,
      readonly priority: number
    },
    readonly infrastructure_links_along_route: ReadonlyArray<{
      readonly __typename?: 'route_infrastructure_link_along_route',
      readonly route_id: UUID,
      readonly infrastructure_link_sequence: number,
      readonly infrastructure_link_id: UUID,
      readonly is_traversal_forwards: boolean,
      readonly infrastructure_link: {
        readonly __typename?: 'infrastructure_network_infrastructure_link',
        readonly external_link_source: InfrastructureNetworkExternalSourceEnum,
        readonly external_link_id: string,
        readonly infrastructure_link_id: UUID,
        readonly shape: GeoJSON.LineString,
        readonly direction: InfrastructureNetworkDirectionEnum,
        readonly scheduled_stop_points_located_on_infrastructure_link: ReadonlyArray<{
          readonly __typename?: 'service_pattern_scheduled_stop_point',
          readonly measured_location: GeoJSON.Point,
          readonly relative_distance_from_infrastructure_link_start: number,
          readonly closest_point_on_infrastructure_link?: GeoJSON.Point | null,
          readonly priority: number,
          readonly direction: InfrastructureNetworkDirectionEnum,
          readonly scheduled_stop_point_id: UUID,
          readonly label: string,
          readonly timing_place_id?: UUID | null,
          readonly validity_start?: luxon.DateTime | null,
          readonly validity_end?: luxon.DateTime | null,
          readonly located_on_infrastructure_link_id: UUID,
          readonly stop_place_ref?: string | null,
          readonly stop_place?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_ParentStopPlace',
            readonly id?: string | null,
            readonly name?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly lang?: string | null,
              readonly value?: string | null
            } | null
          } | {
            readonly __typename?: 'stop_registry_StopPlace',
            readonly id?: string | null,
            readonly name?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly lang?: string | null,
              readonly value?: string | null
            } | null
          } | null> | null,
          readonly other_label_instances: ReadonlyArray<{
            readonly __typename?: 'service_pattern_scheduled_stop_point',
            readonly priority: number,
            readonly direction: InfrastructureNetworkDirectionEnum,
            readonly scheduled_stop_point_id: UUID,
            readonly label: string,
            readonly timing_place_id?: UUID | null,
            readonly validity_start?: luxon.DateTime | null,
            readonly validity_end?: luxon.DateTime | null,
            readonly located_on_infrastructure_link_id: UUID,
            readonly stop_place_ref?: string | null,
            readonly timing_place?: {
              readonly __typename?: 'timing_pattern_timing_place',
              readonly timing_place_id: UUID,
              readonly label: string
            } | null
          }>,
          readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
            readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
            readonly journey_pattern_id: UUID,
            readonly scheduled_stop_point_label: string,
            readonly scheduled_stop_point_sequence: number,
            readonly is_used_as_timing_point: boolean,
            readonly is_regulated_timing_point: boolean,
            readonly is_loading_time_allowed: boolean,
            readonly is_via_point: boolean,
            readonly via_point_name_i18n?: LocalizedString | null,
            readonly via_point_short_name_i18n?: LocalizedString | null,
            readonly journey_pattern: {
              readonly __typename?: 'journey_pattern_journey_pattern',
              readonly journey_pattern_id: UUID,
              readonly on_route_id: UUID
            }
          }>,
          readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
            readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
            readonly vehicle_mode: ReusableComponentsVehicleModeEnum
          }>,
          readonly timing_place?: {
            readonly __typename?: 'timing_pattern_timing_place',
            readonly timing_place_id: UUID,
            readonly label: string
          } | null
        }>
      }
    }>,
    readonly route_journey_patterns: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly on_route_id: UUID,
      readonly ordered_scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
        readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly scheduled_stop_point_label: string,
        readonly scheduled_stop_point_sequence: number,
        readonly is_used_as_timing_point: boolean,
        readonly is_regulated_timing_point: boolean,
        readonly is_loading_time_allowed: boolean,
        readonly is_via_point: boolean,
        readonly via_point_name_i18n?: LocalizedString | null,
        readonly via_point_short_name_i18n?: LocalizedString | null,
        readonly scheduled_stop_points: ReadonlyArray<{
          readonly __typename?: 'service_pattern_scheduled_stop_point',
          readonly priority: number,
          readonly direction: InfrastructureNetworkDirectionEnum,
          readonly scheduled_stop_point_id: UUID,
          readonly label: string,
          readonly timing_place_id?: UUID | null,
          readonly validity_start?: luxon.DateTime | null,
          readonly validity_end?: luxon.DateTime | null,
          readonly located_on_infrastructure_link_id: UUID,
          readonly stop_place_ref?: string | null,
          readonly timing_place?: {
            readonly __typename?: 'timing_pattern_timing_place',
            readonly timing_place_id: UUID,
            readonly label: string
          } | null
        }>,
        readonly journey_pattern: {
          readonly __typename?: 'journey_pattern_journey_pattern',
          readonly journey_pattern_id: UUID,
          readonly on_route_id: UUID
        }
      }>
    }>
  }>
};

export type GetRouteDetailsByIdQueryVariables = Exact<{
  routeId: Scalars['uuid']['input'];
}>;


export type GetRouteDetailsByIdQuery = {
  readonly __typename?: 'query_root',
  readonly route_route_by_pk?: {
    readonly __typename?: 'route_route',
    readonly route_shape?: GeoJSON.LineString | null,
    readonly name_i18n: LocalizedString,
    readonly description_i18n?: LocalizedString | null,
    readonly origin_name_i18n: LocalizedString,
    readonly origin_short_name_i18n: LocalizedString,
    readonly destination_name_i18n: LocalizedString,
    readonly destination_short_name_i18n: LocalizedString,
    readonly on_line_id: UUID,
    readonly label: string,
    readonly direction: RouteDirectionEnum,
    readonly variant?: number | null,
    readonly route_id: UUID,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly priority: number,
    readonly route_line: {
      readonly __typename?: 'route_line',
      readonly primary_vehicle_mode: ReusableComponentsVehicleModeEnum,
      readonly type_of_line: RouteTypeOfLineEnum,
      readonly transport_target: HslRouteTransportTargetEnum,
      readonly line_id: UUID,
      readonly label: string,
      readonly name_i18n: LocalizedString,
      readonly short_name_i18n: LocalizedString,
      readonly validity_start?: luxon.DateTime | null,
      readonly validity_end?: luxon.DateTime | null,
      readonly priority: number
    },
    readonly infrastructure_links_along_route: ReadonlyArray<{
      readonly __typename?: 'route_infrastructure_link_along_route',
      readonly route_id: UUID,
      readonly infrastructure_link_sequence: number,
      readonly infrastructure_link_id: UUID,
      readonly is_traversal_forwards: boolean,
      readonly infrastructure_link: {
        readonly __typename?: 'infrastructure_network_infrastructure_link',
        readonly external_link_source: InfrastructureNetworkExternalSourceEnum,
        readonly external_link_id: string,
        readonly infrastructure_link_id: UUID,
        readonly shape: GeoJSON.LineString,
        readonly direction: InfrastructureNetworkDirectionEnum,
        readonly scheduled_stop_points_located_on_infrastructure_link: ReadonlyArray<{
          readonly __typename?: 'service_pattern_scheduled_stop_point',
          readonly measured_location: GeoJSON.Point,
          readonly relative_distance_from_infrastructure_link_start: number,
          readonly closest_point_on_infrastructure_link?: GeoJSON.Point | null,
          readonly priority: number,
          readonly direction: InfrastructureNetworkDirectionEnum,
          readonly scheduled_stop_point_id: UUID,
          readonly label: string,
          readonly timing_place_id?: UUID | null,
          readonly validity_start?: luxon.DateTime | null,
          readonly validity_end?: luxon.DateTime | null,
          readonly located_on_infrastructure_link_id: UUID,
          readonly stop_place_ref?: string | null,
          readonly stop_place?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_ParentStopPlace',
            readonly id?: string | null,
            readonly name?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly lang?: string | null,
              readonly value?: string | null
            } | null
          } | {
            readonly __typename?: 'stop_registry_StopPlace',
            readonly id?: string | null,
            readonly name?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly lang?: string | null,
              readonly value?: string | null
            } | null
          } | null> | null,
          readonly other_label_instances: ReadonlyArray<{
            readonly __typename?: 'service_pattern_scheduled_stop_point',
            readonly priority: number,
            readonly direction: InfrastructureNetworkDirectionEnum,
            readonly scheduled_stop_point_id: UUID,
            readonly label: string,
            readonly timing_place_id?: UUID | null,
            readonly validity_start?: luxon.DateTime | null,
            readonly validity_end?: luxon.DateTime | null,
            readonly located_on_infrastructure_link_id: UUID,
            readonly stop_place_ref?: string | null,
            readonly timing_place?: {
              readonly __typename?: 'timing_pattern_timing_place',
              readonly timing_place_id: UUID,
              readonly label: string
            } | null
          }>,
          readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
            readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
            readonly journey_pattern_id: UUID,
            readonly scheduled_stop_point_label: string,
            readonly scheduled_stop_point_sequence: number,
            readonly is_used_as_timing_point: boolean,
            readonly is_regulated_timing_point: boolean,
            readonly is_loading_time_allowed: boolean,
            readonly is_via_point: boolean,
            readonly via_point_name_i18n?: LocalizedString | null,
            readonly via_point_short_name_i18n?: LocalizedString | null,
            readonly journey_pattern: {
              readonly __typename?: 'journey_pattern_journey_pattern',
              readonly journey_pattern_id: UUID,
              readonly on_route_id: UUID
            }
          }>,
          readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
            readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
            readonly vehicle_mode: ReusableComponentsVehicleModeEnum
          }>,
          readonly timing_place?: {
            readonly __typename?: 'timing_pattern_timing_place',
            readonly timing_place_id: UUID,
            readonly label: string
          } | null
        }>
      }
    }>,
    readonly route_journey_patterns: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly on_route_id: UUID,
      readonly ordered_scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
        readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly scheduled_stop_point_label: string,
        readonly scheduled_stop_point_sequence: number,
        readonly is_used_as_timing_point: boolean,
        readonly is_regulated_timing_point: boolean,
        readonly is_loading_time_allowed: boolean,
        readonly is_via_point: boolean,
        readonly via_point_name_i18n?: LocalizedString | null,
        readonly via_point_short_name_i18n?: LocalizedString | null,
        readonly scheduled_stop_points: ReadonlyArray<{
          readonly __typename?: 'service_pattern_scheduled_stop_point',
          readonly priority: number,
          readonly direction: InfrastructureNetworkDirectionEnum,
          readonly scheduled_stop_point_id: UUID,
          readonly label: string,
          readonly timing_place_id?: UUID | null,
          readonly validity_start?: luxon.DateTime | null,
          readonly validity_end?: luxon.DateTime | null,
          readonly located_on_infrastructure_link_id: UUID,
          readonly stop_place_ref?: string | null,
          readonly timing_place?: {
            readonly __typename?: 'timing_pattern_timing_place',
            readonly timing_place_id: UUID,
            readonly label: string
          } | null
        }>,
        readonly journey_pattern: {
          readonly __typename?: 'journey_pattern_journey_pattern',
          readonly journey_pattern_id: UUID,
          readonly on_route_id: UUID
        }
      }>
    }>
  } | null
};

export type GetRouteDetailsByIdsQueryVariables = Exact<{
  route_ids?: InputMaybe<ReadonlyArray<Scalars['uuid']['input']> | Scalars['uuid']['input']>;
}>;


export type GetRouteDetailsByIdsQuery = {
  readonly __typename?: 'query_root',
  readonly route_route: ReadonlyArray<{
    readonly __typename?: 'route_route',
    readonly route_shape?: GeoJSON.LineString | null,
    readonly name_i18n: LocalizedString,
    readonly description_i18n?: LocalizedString | null,
    readonly origin_name_i18n: LocalizedString,
    readonly origin_short_name_i18n: LocalizedString,
    readonly destination_name_i18n: LocalizedString,
    readonly destination_short_name_i18n: LocalizedString,
    readonly on_line_id: UUID,
    readonly label: string,
    readonly direction: RouteDirectionEnum,
    readonly variant?: number | null,
    readonly route_id: UUID,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly priority: number,
    readonly route_line: {
      readonly __typename?: 'route_line',
      readonly primary_vehicle_mode: ReusableComponentsVehicleModeEnum,
      readonly type_of_line: RouteTypeOfLineEnum,
      readonly transport_target: HslRouteTransportTargetEnum,
      readonly line_id: UUID,
      readonly label: string,
      readonly name_i18n: LocalizedString,
      readonly short_name_i18n: LocalizedString,
      readonly validity_start?: luxon.DateTime | null,
      readonly validity_end?: luxon.DateTime | null,
      readonly priority: number
    },
    readonly infrastructure_links_along_route: ReadonlyArray<{
      readonly __typename?: 'route_infrastructure_link_along_route',
      readonly route_id: UUID,
      readonly infrastructure_link_sequence: number,
      readonly infrastructure_link_id: UUID,
      readonly is_traversal_forwards: boolean,
      readonly infrastructure_link: {
        readonly __typename?: 'infrastructure_network_infrastructure_link',
        readonly external_link_source: InfrastructureNetworkExternalSourceEnum,
        readonly external_link_id: string,
        readonly infrastructure_link_id: UUID,
        readonly shape: GeoJSON.LineString,
        readonly direction: InfrastructureNetworkDirectionEnum,
        readonly scheduled_stop_points_located_on_infrastructure_link: ReadonlyArray<{
          readonly __typename?: 'service_pattern_scheduled_stop_point',
          readonly measured_location: GeoJSON.Point,
          readonly relative_distance_from_infrastructure_link_start: number,
          readonly closest_point_on_infrastructure_link?: GeoJSON.Point | null,
          readonly priority: number,
          readonly direction: InfrastructureNetworkDirectionEnum,
          readonly scheduled_stop_point_id: UUID,
          readonly label: string,
          readonly timing_place_id?: UUID | null,
          readonly validity_start?: luxon.DateTime | null,
          readonly validity_end?: luxon.DateTime | null,
          readonly located_on_infrastructure_link_id: UUID,
          readonly stop_place_ref?: string | null,
          readonly stop_place?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_ParentStopPlace',
            readonly id?: string | null,
            readonly name?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly lang?: string | null,
              readonly value?: string | null
            } | null
          } | {
            readonly __typename?: 'stop_registry_StopPlace',
            readonly id?: string | null,
            readonly name?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly lang?: string | null,
              readonly value?: string | null
            } | null
          } | null> | null,
          readonly other_label_instances: ReadonlyArray<{
            readonly __typename?: 'service_pattern_scheduled_stop_point',
            readonly priority: number,
            readonly direction: InfrastructureNetworkDirectionEnum,
            readonly scheduled_stop_point_id: UUID,
            readonly label: string,
            readonly timing_place_id?: UUID | null,
            readonly validity_start?: luxon.DateTime | null,
            readonly validity_end?: luxon.DateTime | null,
            readonly located_on_infrastructure_link_id: UUID,
            readonly stop_place_ref?: string | null,
            readonly timing_place?: {
              readonly __typename?: 'timing_pattern_timing_place',
              readonly timing_place_id: UUID,
              readonly label: string
            } | null
          }>,
          readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
            readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
            readonly journey_pattern_id: UUID,
            readonly scheduled_stop_point_label: string,
            readonly scheduled_stop_point_sequence: number,
            readonly is_used_as_timing_point: boolean,
            readonly is_regulated_timing_point: boolean,
            readonly is_loading_time_allowed: boolean,
            readonly is_via_point: boolean,
            readonly via_point_name_i18n?: LocalizedString | null,
            readonly via_point_short_name_i18n?: LocalizedString | null,
            readonly journey_pattern: {
              readonly __typename?: 'journey_pattern_journey_pattern',
              readonly journey_pattern_id: UUID,
              readonly on_route_id: UUID
            }
          }>,
          readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
            readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
            readonly vehicle_mode: ReusableComponentsVehicleModeEnum
          }>,
          readonly timing_place?: {
            readonly __typename?: 'timing_pattern_timing_place',
            readonly timing_place_id: UUID,
            readonly label: string
          } | null
        }>
      }
    }>,
    readonly route_journey_patterns: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly on_route_id: UUID,
      readonly ordered_scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
        readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly scheduled_stop_point_label: string,
        readonly scheduled_stop_point_sequence: number,
        readonly is_used_as_timing_point: boolean,
        readonly is_regulated_timing_point: boolean,
        readonly is_loading_time_allowed: boolean,
        readonly is_via_point: boolean,
        readonly via_point_name_i18n?: LocalizedString | null,
        readonly via_point_short_name_i18n?: LocalizedString | null,
        readonly scheduled_stop_points: ReadonlyArray<{
          readonly __typename?: 'service_pattern_scheduled_stop_point',
          readonly priority: number,
          readonly direction: InfrastructureNetworkDirectionEnum,
          readonly scheduled_stop_point_id: UUID,
          readonly label: string,
          readonly timing_place_id?: UUID | null,
          readonly validity_start?: luxon.DateTime | null,
          readonly validity_end?: luxon.DateTime | null,
          readonly located_on_infrastructure_link_id: UUID,
          readonly stop_place_ref?: string | null,
          readonly timing_place?: {
            readonly __typename?: 'timing_pattern_timing_place',
            readonly timing_place_id: UUID,
            readonly label: string
          } | null
        }>,
        readonly journey_pattern: {
          readonly __typename?: 'journey_pattern_journey_pattern',
          readonly journey_pattern_id: UUID,
          readonly on_route_id: UUID
        }
      }>
    }>
  }>
};

export type GetRouteRenderInfoByIdQueryVariables = Exact<{
  routeId: Scalars['uuid']['input'];
}>;


export type GetRouteRenderInfoByIdQuery = {
  readonly __typename?: 'query_root',
  readonly route_route_by_pk?: {
    readonly __typename?: 'route_route',
    readonly route_id: UUID,
    readonly route_shape?: GeoJSON.LineString | null,
    readonly route_line: {
      readonly __typename?: 'route_line',
      readonly line_id: UUID,
      readonly primary_vehicle_mode: ReusableComponentsVehicleModeEnum
    }
  } | null
};

export type GetRouteDetailsByLabelsQueryVariables = Exact<{
  labels?: InputMaybe<ReadonlyArray<Scalars['String']['input']> | Scalars['String']['input']>;
  date?: InputMaybe<Scalars['date']['input']>;
}>;


export type GetRouteDetailsByLabelsQuery = {
  readonly __typename?: 'query_root',
  readonly route_route: ReadonlyArray<{
    readonly __typename?: 'route_route',
    readonly route_shape?: GeoJSON.LineString | null,
    readonly name_i18n: LocalizedString,
    readonly description_i18n?: LocalizedString | null,
    readonly origin_name_i18n: LocalizedString,
    readonly origin_short_name_i18n: LocalizedString,
    readonly destination_name_i18n: LocalizedString,
    readonly destination_short_name_i18n: LocalizedString,
    readonly on_line_id: UUID,
    readonly label: string,
    readonly direction: RouteDirectionEnum,
    readonly variant?: number | null,
    readonly route_id: UUID,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly priority: number,
    readonly route_line: {
      readonly __typename?: 'route_line',
      readonly line_id: UUID,
      readonly label: string,
      readonly primary_vehicle_mode: ReusableComponentsVehicleModeEnum
    },
    readonly route_journey_patterns: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly on_route_id: UUID,
      readonly ordered_scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
        readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly scheduled_stop_point_label: string,
        readonly scheduled_stop_point_sequence: number,
        readonly is_used_as_timing_point: boolean,
        readonly is_regulated_timing_point: boolean,
        readonly is_loading_time_allowed: boolean,
        readonly is_via_point: boolean,
        readonly via_point_name_i18n?: LocalizedString | null,
        readonly via_point_short_name_i18n?: LocalizedString | null,
        readonly scheduled_stop_points: ReadonlyArray<{
          readonly __typename?: 'service_pattern_scheduled_stop_point',
          readonly priority: number,
          readonly direction: InfrastructureNetworkDirectionEnum,
          readonly scheduled_stop_point_id: UUID,
          readonly label: string,
          readonly timing_place_id?: UUID | null,
          readonly validity_start?: luxon.DateTime | null,
          readonly validity_end?: luxon.DateTime | null,
          readonly located_on_infrastructure_link_id: UUID,
          readonly stop_place_ref?: string | null,
          readonly timing_place?: {
            readonly __typename?: 'timing_pattern_timing_place',
            readonly timing_place_id: UUID,
            readonly label: string
          } | null
        }>,
        readonly journey_pattern: {
          readonly __typename?: 'journey_pattern_journey_pattern',
          readonly journey_pattern_id: UUID,
          readonly on_route_id: UUID
        }
      }>
    }>
  }>
};

export type GetRoutesWithInfrastructureLinksQueryVariables = Exact<{
  route_ids?: InputMaybe<ReadonlyArray<Scalars['uuid']['input']> | Scalars['uuid']['input']>;
}>;


export type GetRoutesWithInfrastructureLinksQuery = {
  readonly __typename?: 'query_root',
  readonly route_route: ReadonlyArray<{
    readonly __typename?: 'route_route',
    readonly route_shape?: GeoJSON.LineString | null,
    readonly name_i18n: LocalizedString,
    readonly description_i18n?: LocalizedString | null,
    readonly origin_name_i18n: LocalizedString,
    readonly origin_short_name_i18n: LocalizedString,
    readonly destination_name_i18n: LocalizedString,
    readonly destination_short_name_i18n: LocalizedString,
    readonly on_line_id: UUID,
    readonly label: string,
    readonly direction: RouteDirectionEnum,
    readonly variant?: number | null,
    readonly route_id: UUID,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly priority: number,
    readonly route_line: {
      readonly __typename?: 'route_line',
      readonly primary_vehicle_mode: ReusableComponentsVehicleModeEnum,
      readonly type_of_line: RouteTypeOfLineEnum,
      readonly transport_target: HslRouteTransportTargetEnum,
      readonly line_id: UUID,
      readonly label: string,
      readonly name_i18n: LocalizedString,
      readonly short_name_i18n: LocalizedString,
      readonly validity_start?: luxon.DateTime | null,
      readonly validity_end?: luxon.DateTime | null,
      readonly priority: number
    },
    readonly infrastructure_links_along_route: ReadonlyArray<{
      readonly __typename?: 'route_infrastructure_link_along_route',
      readonly route_id: UUID,
      readonly infrastructure_link_sequence: number,
      readonly infrastructure_link_id: UUID,
      readonly is_traversal_forwards: boolean,
      readonly infrastructure_link: {
        readonly __typename?: 'infrastructure_network_infrastructure_link',
        readonly infrastructure_link_id: UUID,
        readonly shape: GeoJSON.LineString,
        readonly direction: InfrastructureNetworkDirectionEnum,
        readonly external_link_id: string,
        readonly external_link_source: InfrastructureNetworkExternalSourceEnum
      }
    }>
  }>
};

export type GetRoutesByValidityQueryVariables = Exact<{
  filter?: InputMaybe<RouteRouteBoolExp>;
}>;


export type GetRoutesByValidityQuery = {
  readonly __typename?: 'query_root',
  readonly route_route: ReadonlyArray<{
    readonly __typename?: 'route_route',
    readonly name_i18n: LocalizedString,
    readonly description_i18n?: LocalizedString | null,
    readonly origin_name_i18n: LocalizedString,
    readonly origin_short_name_i18n: LocalizedString,
    readonly destination_name_i18n: LocalizedString,
    readonly destination_short_name_i18n: LocalizedString,
    readonly on_line_id: UUID,
    readonly label: string,
    readonly direction: RouteDirectionEnum,
    readonly variant?: number | null,
    readonly route_id: UUID,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly priority: number
  }>
};

export type InsertLineOneMutationVariables = Exact<{
  object: RouteLineInsertInput;
}>;


export type InsertLineOneMutation = {
  readonly __typename?: 'mutation_root',
  readonly insert_route_line_one?: {
    readonly __typename?: 'route_line',
    readonly line_id: UUID,
    readonly label: string,
    readonly priority: number,
    readonly primary_vehicle_mode: ReusableComponentsVehicleModeEnum,
    readonly transport_target: HslRouteTransportTargetEnum,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null
  } | null
};

export type PatchLineMutationVariables = Exact<{
  line_id: Scalars['uuid']['input'];
  object: RouteLineSetInput;
}>;


export type PatchLineMutation = {
  readonly __typename?: 'mutation_root',
  readonly update_route_line_by_pk?: {
    readonly __typename?: 'route_line',
    readonly primary_vehicle_mode: ReusableComponentsVehicleModeEnum,
    readonly type_of_line: RouteTypeOfLineEnum,
    readonly transport_target: HslRouteTransportTargetEnum,
    readonly line_id: UUID,
    readonly label: string,
    readonly name_i18n: LocalizedString,
    readonly short_name_i18n: LocalizedString,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly priority: number
  } | null
};

export type InsertRouteOneMutationVariables = Exact<{
  object: RouteRouteInsertInput;
}>;


export type InsertRouteOneMutation = {
  readonly __typename?: 'mutation_root',
  readonly insert_route_route_one?: {
    readonly __typename?: 'route_route',
    readonly route_shape?: GeoJSON.LineString | null,
    readonly name_i18n: LocalizedString,
    readonly description_i18n?: LocalizedString | null,
    readonly origin_name_i18n: LocalizedString,
    readonly origin_short_name_i18n: LocalizedString,
    readonly destination_name_i18n: LocalizedString,
    readonly destination_short_name_i18n: LocalizedString,
    readonly on_line_id: UUID,
    readonly label: string,
    readonly direction: RouteDirectionEnum,
    readonly variant?: number | null,
    readonly route_id: UUID,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly priority: number
  } | null
};

export type PatchRouteMutationVariables = Exact<{
  route_id: Scalars['uuid']['input'];
  object: RouteRouteSetInput;
}>;


export type PatchRouteMutation = {
  readonly __typename?: 'mutation_root',
  readonly update_route_route?: {
    readonly __typename?: 'route_route_mutation_response',
    readonly returning: ReadonlyArray<{
      readonly __typename?: 'route_route',
      readonly route_shape?: GeoJSON.LineString | null,
      readonly name_i18n: LocalizedString,
      readonly description_i18n?: LocalizedString | null,
      readonly origin_name_i18n: LocalizedString,
      readonly origin_short_name_i18n: LocalizedString,
      readonly destination_name_i18n: LocalizedString,
      readonly destination_short_name_i18n: LocalizedString,
      readonly on_line_id: UUID,
      readonly label: string,
      readonly direction: RouteDirectionEnum,
      readonly variant?: number | null,
      readonly route_id: UUID,
      readonly validity_start?: luxon.DateTime | null,
      readonly validity_end?: luxon.DateTime | null,
      readonly priority: number
    }>
  } | null
};

export type DeleteRouteMutationVariables = Exact<{
  route_id: Scalars['uuid']['input'];
}>;


export type DeleteRouteMutation = {
  readonly __typename?: 'mutation_root',
  readonly delete_route_route?: {
    readonly __typename?: 'route_route_mutation_response',
    readonly returning: ReadonlyArray<{
      readonly __typename?: 'route_route',
      readonly route_id: UUID
    }>
  } | null
};

export type GetScheduledStopsOnRouteQueryVariables = Exact<{
  routeId: Scalars['uuid']['input'];
}>;


export type GetScheduledStopsOnRouteQuery = {
  readonly __typename?: 'query_root',
  readonly journey_pattern_journey_pattern: ReadonlyArray<{
    readonly __typename?: 'journey_pattern_journey_pattern',
    readonly journey_pattern_id: UUID,
    readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly scheduled_stop_point_sequence: number,
      readonly scheduled_stop_points: ReadonlyArray<{
        readonly __typename?: 'service_pattern_scheduled_stop_point',
        readonly priority: number,
        readonly direction: InfrastructureNetworkDirectionEnum,
        readonly scheduled_stop_point_id: UUID,
        readonly label: string,
        readonly timing_place_id?: UUID | null,
        readonly validity_start?: luxon.DateTime | null,
        readonly validity_end?: luxon.DateTime | null,
        readonly located_on_infrastructure_link_id: UUID,
        readonly stop_place_ref?: string | null,
        readonly timing_place?: {
          readonly __typename?: 'timing_pattern_timing_place',
          readonly timing_place_id: UUID,
          readonly label: string
        } | null
      }>
    }>
  }>
};

export type ScheduledStopPointDefaultFieldsFragment = {
  readonly __typename?: 'service_pattern_scheduled_stop_point',
  readonly priority: number,
  readonly direction: InfrastructureNetworkDirectionEnum,
  readonly scheduled_stop_point_id: UUID,
  readonly label: string,
  readonly timing_place_id?: UUID | null,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly located_on_infrastructure_link_id: UUID,
  readonly stop_place_ref?: string | null,
  readonly timing_place?: {
    readonly __typename?: 'timing_pattern_timing_place',
    readonly timing_place_id: UUID,
    readonly label: string
  } | null
};

export type ScheduledStopPointAllFieldsFragment = {
  readonly __typename?: 'service_pattern_scheduled_stop_point',
  readonly measured_location: GeoJSON.Point,
  readonly relative_distance_from_infrastructure_link_start: number,
  readonly closest_point_on_infrastructure_link?: GeoJSON.Point | null,
  readonly priority: number,
  readonly direction: InfrastructureNetworkDirectionEnum,
  readonly scheduled_stop_point_id: UUID,
  readonly label: string,
  readonly timing_place_id?: UUID | null,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly located_on_infrastructure_link_id: UUID,
  readonly stop_place_ref?: string | null,
  readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
    readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
    readonly vehicle_mode: ReusableComponentsVehicleModeEnum
  }>,
  readonly timing_place?: {
    readonly __typename?: 'timing_pattern_timing_place',
    readonly timing_place_id: UUID,
    readonly label: string
  } | null
};

export type StopWithJourneyPatternFieldsFragment = {
  readonly __typename?: 'service_pattern_scheduled_stop_point',
  readonly measured_location: GeoJSON.Point,
  readonly relative_distance_from_infrastructure_link_start: number,
  readonly closest_point_on_infrastructure_link?: GeoJSON.Point | null,
  readonly priority: number,
  readonly direction: InfrastructureNetworkDirectionEnum,
  readonly scheduled_stop_point_id: UUID,
  readonly label: string,
  readonly timing_place_id?: UUID | null,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly located_on_infrastructure_link_id: UUID,
  readonly stop_place_ref?: string | null,
  readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
    readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
    readonly journey_pattern_id: UUID,
    readonly scheduled_stop_point_label: string,
    readonly scheduled_stop_point_sequence: number,
    readonly is_used_as_timing_point: boolean,
    readonly is_regulated_timing_point: boolean,
    readonly is_loading_time_allowed: boolean,
    readonly is_via_point: boolean,
    readonly via_point_name_i18n?: LocalizedString | null,
    readonly via_point_short_name_i18n?: LocalizedString | null,
    readonly journey_pattern: {
      readonly __typename?: 'journey_pattern_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly on_route_id: UUID
    }
  }>,
  readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
    readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
    readonly vehicle_mode: ReusableComponentsVehicleModeEnum
  }>,
  readonly timing_place?: {
    readonly __typename?: 'timing_pattern_timing_place',
    readonly timing_place_id: UUID,
    readonly label: string
  } | null
};

export type RouteStopFieldsFragment = {
  readonly __typename?: 'service_pattern_scheduled_stop_point',
  readonly measured_location: GeoJSON.Point,
  readonly relative_distance_from_infrastructure_link_start: number,
  readonly closest_point_on_infrastructure_link?: GeoJSON.Point | null,
  readonly priority: number,
  readonly direction: InfrastructureNetworkDirectionEnum,
  readonly scheduled_stop_point_id: UUID,
  readonly label: string,
  readonly timing_place_id?: UUID | null,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly located_on_infrastructure_link_id: UUID,
  readonly stop_place_ref?: string | null,
  readonly stop_place?: ReadonlyArray<{
    readonly __typename?: 'stop_registry_ParentStopPlace',
    readonly id?: string | null,
    readonly name?: {
      readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
      readonly lang?: string | null,
      readonly value?: string | null
    } | null
  } | {
    readonly __typename?: 'stop_registry_StopPlace',
    readonly id?: string | null,
    readonly name?: {
      readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
      readonly lang?: string | null,
      readonly value?: string | null
    } | null
  } | null> | null,
  readonly other_label_instances: ReadonlyArray<{
    readonly __typename?: 'service_pattern_scheduled_stop_point',
    readonly priority: number,
    readonly direction: InfrastructureNetworkDirectionEnum,
    readonly scheduled_stop_point_id: UUID,
    readonly label: string,
    readonly timing_place_id?: UUID | null,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly located_on_infrastructure_link_id: UUID,
    readonly stop_place_ref?: string | null,
    readonly timing_place?: {
      readonly __typename?: 'timing_pattern_timing_place',
      readonly timing_place_id: UUID,
      readonly label: string
    } | null
  }>,
  readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
    readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
    readonly journey_pattern_id: UUID,
    readonly scheduled_stop_point_label: string,
    readonly scheduled_stop_point_sequence: number,
    readonly is_used_as_timing_point: boolean,
    readonly is_regulated_timing_point: boolean,
    readonly is_loading_time_allowed: boolean,
    readonly is_via_point: boolean,
    readonly via_point_name_i18n?: LocalizedString | null,
    readonly via_point_short_name_i18n?: LocalizedString | null,
    readonly journey_pattern: {
      readonly __typename?: 'journey_pattern_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly on_route_id: UUID
    }
  }>,
  readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
    readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
    readonly vehicle_mode: ReusableComponentsVehicleModeEnum
  }>,
  readonly timing_place?: {
    readonly __typename?: 'timing_pattern_timing_place',
    readonly timing_place_id: UUID,
    readonly label: string
  } | null
};

export type RemoveStopMutationVariables = Exact<{
  stop_id: Scalars['uuid']['input'];
}>;


export type RemoveStopMutation = {
  readonly __typename?: 'mutation_root',
  readonly delete_service_pattern_scheduled_stop_point?: {
    readonly __typename?: 'service_pattern_scheduled_stop_point_mutation_response',
    readonly returning: ReadonlyArray<{
      readonly __typename?: 'service_pattern_scheduled_stop_point',
      readonly scheduled_stop_point_id: UUID
    }>
  } | null
};

export type GetStopsByValidityQueryVariables = Exact<{
  filter?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
}>;


export type GetStopsByValidityQuery = {
  readonly __typename?: 'query_root',
  readonly service_pattern_scheduled_stop_point: ReadonlyArray<{
    readonly __typename?: 'service_pattern_scheduled_stop_point',
    readonly measured_location: GeoJSON.Point,
    readonly relative_distance_from_infrastructure_link_start: number,
    readonly closest_point_on_infrastructure_link?: GeoJSON.Point | null,
    readonly priority: number,
    readonly direction: InfrastructureNetworkDirectionEnum,
    readonly scheduled_stop_point_id: UUID,
    readonly label: string,
    readonly timing_place_id?: UUID | null,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly located_on_infrastructure_link_id: UUID,
    readonly stop_place_ref?: string | null,
    readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
      readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
      readonly vehicle_mode: ReusableComponentsVehicleModeEnum
    }>,
    readonly timing_place?: {
      readonly __typename?: 'timing_pattern_timing_place',
      readonly timing_place_id: UUID,
      readonly label: string
    } | null
  }>
};

export type GetStopsByIdsQueryVariables = Exact<{
  stopIds?: InputMaybe<ReadonlyArray<Scalars['uuid']['input']> | Scalars['uuid']['input']>;
}>;


export type GetStopsByIdsQuery = {
  readonly __typename?: 'query_root',
  readonly service_pattern_scheduled_stop_point: ReadonlyArray<{
    readonly __typename?: 'service_pattern_scheduled_stop_point',
    readonly measured_location: GeoJSON.Point,
    readonly relative_distance_from_infrastructure_link_start: number,
    readonly closest_point_on_infrastructure_link?: GeoJSON.Point | null,
    readonly priority: number,
    readonly direction: InfrastructureNetworkDirectionEnum,
    readonly scheduled_stop_point_id: UUID,
    readonly label: string,
    readonly timing_place_id?: UUID | null,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly located_on_infrastructure_link_id: UUID,
    readonly stop_place_ref?: string | null,
    readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
      readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
      readonly vehicle_mode: ReusableComponentsVehicleModeEnum
    }>,
    readonly timing_place?: {
      readonly __typename?: 'timing_pattern_timing_place',
      readonly timing_place_id: UUID,
      readonly label: string
    } | null
  }>
};

export type GetStopsByLabelsQueryVariables = Exact<{
  stopLabels?: InputMaybe<ReadonlyArray<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type GetStopsByLabelsQuery = {
  readonly __typename?: 'query_root',
  readonly service_pattern_scheduled_stop_point: ReadonlyArray<{
    readonly __typename?: 'service_pattern_scheduled_stop_point',
    readonly measured_location: GeoJSON.Point,
    readonly relative_distance_from_infrastructure_link_start: number,
    readonly closest_point_on_infrastructure_link?: GeoJSON.Point | null,
    readonly priority: number,
    readonly direction: InfrastructureNetworkDirectionEnum,
    readonly scheduled_stop_point_id: UUID,
    readonly label: string,
    readonly timing_place_id?: UUID | null,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly located_on_infrastructure_link_id: UUID,
    readonly stop_place_ref?: string | null,
    readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
      readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
      readonly vehicle_mode: ReusableComponentsVehicleModeEnum
    }>,
    readonly timing_place?: {
      readonly __typename?: 'timing_pattern_timing_place',
      readonly timing_place_id: UUID,
      readonly label: string
    } | null
  }>
};

export type GetStopWithRouteGraphDataByIdQueryVariables = Exact<{
  stopId: Scalars['uuid']['input'];
}>;


export type GetStopWithRouteGraphDataByIdQuery = {
  readonly __typename?: 'query_root',
  readonly service_pattern_scheduled_stop_point: ReadonlyArray<{
    readonly __typename?: 'service_pattern_scheduled_stop_point',
    readonly measured_location: GeoJSON.Point,
    readonly relative_distance_from_infrastructure_link_start: number,
    readonly closest_point_on_infrastructure_link?: GeoJSON.Point | null,
    readonly priority: number,
    readonly direction: InfrastructureNetworkDirectionEnum,
    readonly scheduled_stop_point_id: UUID,
    readonly label: string,
    readonly timing_place_id?: UUID | null,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly located_on_infrastructure_link_id: UUID,
    readonly stop_place_ref?: string | null,
    readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly scheduled_stop_point_label: string,
      readonly scheduled_stop_point_sequence: number,
      readonly is_used_as_timing_point: boolean,
      readonly is_regulated_timing_point: boolean,
      readonly is_loading_time_allowed: boolean,
      readonly is_via_point: boolean,
      readonly via_point_name_i18n?: LocalizedString | null,
      readonly via_point_short_name_i18n?: LocalizedString | null,
      readonly journey_pattern: {
        readonly __typename?: 'journey_pattern_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly on_route_id: UUID,
        readonly journey_pattern_route?: {
          readonly __typename?: 'route_route',
          readonly name_i18n: LocalizedString,
          readonly description_i18n?: LocalizedString | null,
          readonly origin_name_i18n: LocalizedString,
          readonly origin_short_name_i18n: LocalizedString,
          readonly destination_name_i18n: LocalizedString,
          readonly destination_short_name_i18n: LocalizedString,
          readonly on_line_id: UUID,
          readonly label: string,
          readonly direction: RouteDirectionEnum,
          readonly variant?: number | null,
          readonly route_id: UUID,
          readonly validity_start?: luxon.DateTime | null,
          readonly validity_end?: luxon.DateTime | null,
          readonly priority: number,
          readonly infrastructure_links_along_route: ReadonlyArray<{
            readonly __typename?: 'route_infrastructure_link_along_route',
            readonly route_id: UUID,
            readonly infrastructure_link_id: UUID,
            readonly infrastructure_link_sequence: number
          }>
        } | null
      }
    }>,
    readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
      readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
      readonly vehicle_mode: ReusableComponentsVehicleModeEnum
    }>,
    readonly timing_place?: {
      readonly __typename?: 'timing_pattern_timing_place',
      readonly timing_place_id: UUID,
      readonly label: string
    } | null
  }>
};

export type InfrastructureLinkWithStopsFragment = {
  readonly __typename?: 'infrastructure_network_infrastructure_link',
  readonly direction: InfrastructureNetworkDirectionEnum,
  readonly shape: GeoJSON.LineString,
  readonly estimated_length_in_metres?: number | null,
  readonly external_link_id: string,
  readonly external_link_source: InfrastructureNetworkExternalSourceEnum,
  readonly infrastructure_link_id: UUID,
  readonly scheduled_stop_points_located_on_infrastructure_link: ReadonlyArray<{
    readonly __typename?: 'service_pattern_scheduled_stop_point',
    readonly measured_location: GeoJSON.Point,
    readonly relative_distance_from_infrastructure_link_start: number,
    readonly closest_point_on_infrastructure_link?: GeoJSON.Point | null,
    readonly priority: number,
    readonly direction: InfrastructureNetworkDirectionEnum,
    readonly scheduled_stop_point_id: UUID,
    readonly label: string,
    readonly timing_place_id?: UUID | null,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly located_on_infrastructure_link_id: UUID,
    readonly stop_place_ref?: string | null,
    readonly other_label_instances: ReadonlyArray<{
      readonly __typename?: 'service_pattern_scheduled_stop_point',
      readonly priority: number,
      readonly direction: InfrastructureNetworkDirectionEnum,
      readonly scheduled_stop_point_id: UUID,
      readonly label: string,
      readonly timing_place_id?: UUID | null,
      readonly validity_start?: luxon.DateTime | null,
      readonly validity_end?: luxon.DateTime | null,
      readonly located_on_infrastructure_link_id: UUID,
      readonly stop_place_ref?: string | null,
      readonly timing_place?: {
        readonly __typename?: 'timing_pattern_timing_place',
        readonly timing_place_id: UUID,
        readonly label: string
      } | null
    }>,
    readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly scheduled_stop_point_label: string,
      readonly scheduled_stop_point_sequence: number,
      readonly is_used_as_timing_point: boolean,
      readonly is_regulated_timing_point: boolean,
      readonly is_loading_time_allowed: boolean,
      readonly is_via_point: boolean,
      readonly via_point_name_i18n?: LocalizedString | null,
      readonly via_point_short_name_i18n?: LocalizedString | null,
      readonly journey_pattern: {
        readonly __typename?: 'journey_pattern_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly on_route_id: UUID
      }
    }>,
    readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
      readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
      readonly vehicle_mode: ReusableComponentsVehicleModeEnum
    }>,
    readonly timing_place?: {
      readonly __typename?: 'timing_pattern_timing_place',
      readonly timing_place_id: UUID,
      readonly label: string
    } | null
  }>
};

export type LineWithRoutesFragment = {
  readonly __typename?: 'route_line',
  readonly primary_vehicle_mode: ReusableComponentsVehicleModeEnum,
  readonly type_of_line: RouteTypeOfLineEnum,
  readonly transport_target: HslRouteTransportTargetEnum,
  readonly line_id: UUID,
  readonly label: string,
  readonly name_i18n: LocalizedString,
  readonly short_name_i18n: LocalizedString,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly priority: number,
  readonly line_routes: ReadonlyArray<{
    readonly __typename?: 'route_route',
    readonly route_shape?: GeoJSON.LineString | null,
    readonly name_i18n: LocalizedString,
    readonly description_i18n?: LocalizedString | null,
    readonly origin_name_i18n: LocalizedString,
    readonly origin_short_name_i18n: LocalizedString,
    readonly destination_name_i18n: LocalizedString,
    readonly destination_short_name_i18n: LocalizedString,
    readonly on_line_id: UUID,
    readonly label: string,
    readonly direction: RouteDirectionEnum,
    readonly variant?: number | null,
    readonly route_id: UUID,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly priority: number,
    readonly route_line: {
      readonly __typename?: 'route_line',
      readonly primary_vehicle_mode: ReusableComponentsVehicleModeEnum,
      readonly type_of_line: RouteTypeOfLineEnum,
      readonly transport_target: HslRouteTransportTargetEnum,
      readonly line_id: UUID,
      readonly label: string,
      readonly name_i18n: LocalizedString,
      readonly short_name_i18n: LocalizedString,
      readonly validity_start?: luxon.DateTime | null,
      readonly validity_end?: luxon.DateTime | null,
      readonly priority: number
    },
    readonly infrastructure_links_along_route: ReadonlyArray<{
      readonly __typename?: 'route_infrastructure_link_along_route',
      readonly route_id: UUID,
      readonly infrastructure_link_sequence: number,
      readonly infrastructure_link_id: UUID,
      readonly is_traversal_forwards: boolean,
      readonly infrastructure_link: {
        readonly __typename?: 'infrastructure_network_infrastructure_link',
        readonly external_link_source: InfrastructureNetworkExternalSourceEnum,
        readonly external_link_id: string,
        readonly infrastructure_link_id: UUID,
        readonly shape: GeoJSON.LineString,
        readonly direction: InfrastructureNetworkDirectionEnum,
        readonly scheduled_stop_points_located_on_infrastructure_link: ReadonlyArray<{
          readonly __typename?: 'service_pattern_scheduled_stop_point',
          readonly measured_location: GeoJSON.Point,
          readonly relative_distance_from_infrastructure_link_start: number,
          readonly closest_point_on_infrastructure_link?: GeoJSON.Point | null,
          readonly priority: number,
          readonly direction: InfrastructureNetworkDirectionEnum,
          readonly scheduled_stop_point_id: UUID,
          readonly label: string,
          readonly timing_place_id?: UUID | null,
          readonly validity_start?: luxon.DateTime | null,
          readonly validity_end?: luxon.DateTime | null,
          readonly located_on_infrastructure_link_id: UUID,
          readonly stop_place_ref?: string | null,
          readonly stop_place?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_ParentStopPlace',
            readonly id?: string | null,
            readonly name?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly lang?: string | null,
              readonly value?: string | null
            } | null
          } | {
            readonly __typename?: 'stop_registry_StopPlace',
            readonly id?: string | null,
            readonly name?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly lang?: string | null,
              readonly value?: string | null
            } | null
          } | null> | null,
          readonly other_label_instances: ReadonlyArray<{
            readonly __typename?: 'service_pattern_scheduled_stop_point',
            readonly priority: number,
            readonly direction: InfrastructureNetworkDirectionEnum,
            readonly scheduled_stop_point_id: UUID,
            readonly label: string,
            readonly timing_place_id?: UUID | null,
            readonly validity_start?: luxon.DateTime | null,
            readonly validity_end?: luxon.DateTime | null,
            readonly located_on_infrastructure_link_id: UUID,
            readonly stop_place_ref?: string | null,
            readonly timing_place?: {
              readonly __typename?: 'timing_pattern_timing_place',
              readonly timing_place_id: UUID,
              readonly label: string
            } | null
          }>,
          readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
            readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
            readonly journey_pattern_id: UUID,
            readonly scheduled_stop_point_label: string,
            readonly scheduled_stop_point_sequence: number,
            readonly is_used_as_timing_point: boolean,
            readonly is_regulated_timing_point: boolean,
            readonly is_loading_time_allowed: boolean,
            readonly is_via_point: boolean,
            readonly via_point_name_i18n?: LocalizedString | null,
            readonly via_point_short_name_i18n?: LocalizedString | null,
            readonly journey_pattern: {
              readonly __typename?: 'journey_pattern_journey_pattern',
              readonly journey_pattern_id: UUID,
              readonly on_route_id: UUID
            }
          }>,
          readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
            readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
            readonly vehicle_mode: ReusableComponentsVehicleModeEnum
          }>,
          readonly timing_place?: {
            readonly __typename?: 'timing_pattern_timing_place',
            readonly timing_place_id: UUID,
            readonly label: string
          } | null
        }>
      }
    }>,
    readonly route_journey_patterns: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly on_route_id: UUID,
      readonly ordered_scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
        readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly scheduled_stop_point_label: string,
        readonly scheduled_stop_point_sequence: number,
        readonly is_used_as_timing_point: boolean,
        readonly is_regulated_timing_point: boolean,
        readonly is_loading_time_allowed: boolean,
        readonly is_via_point: boolean,
        readonly via_point_name_i18n?: LocalizedString | null,
        readonly via_point_short_name_i18n?: LocalizedString | null,
        readonly scheduled_stop_points: ReadonlyArray<{
          readonly __typename?: 'service_pattern_scheduled_stop_point',
          readonly priority: number,
          readonly direction: InfrastructureNetworkDirectionEnum,
          readonly scheduled_stop_point_id: UUID,
          readonly label: string,
          readonly timing_place_id?: UUID | null,
          readonly validity_start?: luxon.DateTime | null,
          readonly validity_end?: luxon.DateTime | null,
          readonly located_on_infrastructure_link_id: UUID,
          readonly stop_place_ref?: string | null,
          readonly timing_place?: {
            readonly __typename?: 'timing_pattern_timing_place',
            readonly timing_place_id: UUID,
            readonly label: string
          } | null
        }>,
        readonly journey_pattern: {
          readonly __typename?: 'journey_pattern_journey_pattern',
          readonly journey_pattern_id: UUID,
          readonly on_route_id: UUID
        }
      }>
    }>
  }>
};

export type GetHighestPriorityLineDetailsWithRoutesQueryVariables = Exact<{
  lineFilters?: InputMaybe<RouteLineBoolExp>;
  lineRouteFilters?: InputMaybe<RouteRouteBoolExp>;
  routeStopFilters?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
}>;


export type GetHighestPriorityLineDetailsWithRoutesQuery = {
  readonly __typename?: 'query_root',
  readonly route_line: ReadonlyArray<{
    readonly __typename?: 'route_line',
    readonly primary_vehicle_mode: ReusableComponentsVehicleModeEnum,
    readonly type_of_line: RouteTypeOfLineEnum,
    readonly transport_target: HslRouteTransportTargetEnum,
    readonly line_id: UUID,
    readonly label: string,
    readonly name_i18n: LocalizedString,
    readonly short_name_i18n: LocalizedString,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly priority: number,
    readonly line_routes: ReadonlyArray<{
      readonly __typename?: 'route_route',
      readonly label: string,
      readonly direction: RouteDirectionEnum,
      readonly variant?: number | null,
      readonly route_id: UUID,
      readonly validity_start?: luxon.DateTime | null,
      readonly validity_end?: luxon.DateTime | null,
      readonly priority: number
    }>
  }>
};

export type UpdateRouteGeometryMutationVariables = Exact<{
  route_id: Scalars['uuid']['input'];
  journey_pattern_id: Scalars['uuid']['input'];
  new_infrastructure_links: ReadonlyArray<RouteInfrastructureLinkAlongRouteInsertInput> | RouteInfrastructureLinkAlongRouteInsertInput;
  new_stops_in_journey_pattern: ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternInsertInput> | JourneyPatternScheduledStopPointInJourneyPatternInsertInput;
}>;


export type UpdateRouteGeometryMutation = {
  readonly __typename?: 'mutation_root',
  readonly delete_route_infrastructure_link_along_route?: {
    readonly __typename?: 'route_infrastructure_link_along_route_mutation_response',
    readonly returning: ReadonlyArray<{
      readonly __typename?: 'route_infrastructure_link_along_route',
      readonly infrastructure_link_id: UUID,
      readonly infrastructure_link_sequence: number,
      readonly route_id: UUID
    }>
  } | null,
  readonly insert_route_infrastructure_link_along_route?: {
    readonly __typename?: 'route_infrastructure_link_along_route_mutation_response',
    readonly returning: ReadonlyArray<{
      readonly __typename?: 'route_infrastructure_link_along_route',
      readonly route_id: UUID,
      readonly infrastructure_link_id: UUID,
      readonly infrastructure_link_sequence: number,
      readonly is_traversal_forwards: boolean,
      readonly infrastructure_link: {
        readonly __typename?: 'infrastructure_network_infrastructure_link',
        readonly infrastructure_link_id: UUID,
        readonly shape: GeoJSON.LineString
      }
    }>
  } | null,
  readonly delete_journey_pattern_scheduled_stop_point_in_journey_pattern?: {
    readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_mutation_response',
    readonly returning: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
      readonly scheduled_stop_point_label: string,
      readonly scheduled_stop_point_sequence: number,
      readonly journey_pattern_id: UUID
    }>
  } | null,
  readonly insert_journey_pattern_scheduled_stop_point_in_journey_pattern?: {
    readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_mutation_response',
    readonly returning: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
      readonly scheduled_stop_point_label: string,
      readonly scheduled_stop_point_sequence: number,
      readonly journey_pattern_id: UUID
    }>
  } | null
};

export type UpdateRouteJourneyPatternMutationVariables = Exact<{
  journey_pattern_id: Scalars['uuid']['input'];
  new_stops_in_journey_pattern: ReadonlyArray<JourneyPatternScheduledStopPointInJourneyPatternInsertInput> | JourneyPatternScheduledStopPointInJourneyPatternInsertInput;
}>;


export type UpdateRouteJourneyPatternMutation = {
  readonly __typename?: 'mutation_root',
  readonly delete_journey_pattern_scheduled_stop_point_in_journey_pattern?: {
    readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_mutation_response',
    readonly returning: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
      readonly scheduled_stop_point_label: string,
      readonly scheduled_stop_point_sequence: number,
      readonly journey_pattern_id: UUID
    }>
  } | null,
  readonly insert_journey_pattern_scheduled_stop_point_in_journey_pattern?: {
    readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_mutation_response',
    readonly returning: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
      readonly scheduled_stop_point_label: string,
      readonly scheduled_stop_point_sequence: number,
      readonly journey_pattern_id: UUID
    }>
  } | null
};

export type GetLinksWithStopsByExternalLinkIdsQueryVariables = Exact<{
  externalLinkIds?: InputMaybe<ReadonlyArray<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type GetLinksWithStopsByExternalLinkIdsQuery = {
  readonly __typename?: 'query_root',
  readonly infrastructure_network_infrastructure_link: ReadonlyArray<{
    readonly __typename?: 'infrastructure_network_infrastructure_link',
    readonly external_link_source: InfrastructureNetworkExternalSourceEnum,
    readonly external_link_id: string,
    readonly infrastructure_link_id: UUID,
    readonly shape: GeoJSON.LineString,
    readonly direction: InfrastructureNetworkDirectionEnum,
    readonly scheduled_stop_points_located_on_infrastructure_link: ReadonlyArray<{
      readonly __typename?: 'service_pattern_scheduled_stop_point',
      readonly measured_location: GeoJSON.Point,
      readonly relative_distance_from_infrastructure_link_start: number,
      readonly closest_point_on_infrastructure_link?: GeoJSON.Point | null,
      readonly priority: number,
      readonly direction: InfrastructureNetworkDirectionEnum,
      readonly scheduled_stop_point_id: UUID,
      readonly label: string,
      readonly timing_place_id?: UUID | null,
      readonly validity_start?: luxon.DateTime | null,
      readonly validity_end?: luxon.DateTime | null,
      readonly located_on_infrastructure_link_id: UUID,
      readonly stop_place_ref?: string | null,
      readonly stop_place?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_ParentStopPlace',
        readonly id?: string | null,
        readonly name?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        } | null
      } | {
        readonly __typename?: 'stop_registry_StopPlace',
        readonly id?: string | null,
        readonly name?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        } | null
      } | null> | null,
      readonly other_label_instances: ReadonlyArray<{
        readonly __typename?: 'service_pattern_scheduled_stop_point',
        readonly priority: number,
        readonly direction: InfrastructureNetworkDirectionEnum,
        readonly scheduled_stop_point_id: UUID,
        readonly label: string,
        readonly timing_place_id?: UUID | null,
        readonly validity_start?: luxon.DateTime | null,
        readonly validity_end?: luxon.DateTime | null,
        readonly located_on_infrastructure_link_id: UUID,
        readonly stop_place_ref?: string | null,
        readonly timing_place?: {
          readonly __typename?: 'timing_pattern_timing_place',
          readonly timing_place_id: UUID,
          readonly label: string
        } | null
      }>,
      readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
        readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly scheduled_stop_point_label: string,
        readonly scheduled_stop_point_sequence: number,
        readonly is_used_as_timing_point: boolean,
        readonly is_regulated_timing_point: boolean,
        readonly is_loading_time_allowed: boolean,
        readonly is_via_point: boolean,
        readonly via_point_name_i18n?: LocalizedString | null,
        readonly via_point_short_name_i18n?: LocalizedString | null,
        readonly journey_pattern: {
          readonly __typename?: 'journey_pattern_journey_pattern',
          readonly journey_pattern_id: UUID,
          readonly on_route_id: UUID
        }
      }>,
      readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
        readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
        readonly vehicle_mode: ReusableComponentsVehicleModeEnum
      }>,
      readonly timing_place?: {
        readonly __typename?: 'timing_pattern_timing_place',
        readonly timing_place_id: UUID,
        readonly label: string
      } | null
    }>
  }>
};

export type GetLineRoutesByLabelQueryVariables = Exact<{
  lineFilters?: InputMaybe<RouteLineBoolExp>;
  lineRouteFilters?: InputMaybe<RouteRouteBoolExp>;
}>;


export type GetLineRoutesByLabelQuery = {
  readonly __typename?: 'query_root',
  readonly route_line: ReadonlyArray<{
    readonly __typename?: 'route_line',
    readonly line_id: UUID,
    readonly line_routes: ReadonlyArray<{
      readonly __typename?: 'route_route',
      readonly route_id: UUID,
      readonly label: string,
      readonly variant?: number | null,
      readonly validity_start?: luxon.DateTime | null,
      readonly validity_end?: luxon.DateTime | null,
      readonly priority: number,
      readonly direction: RouteDirectionEnum,
      readonly route_journey_patterns: ReadonlyArray<{
        readonly __typename?: 'journey_pattern_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
          readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
          readonly journey_pattern_id: UUID,
          readonly scheduled_stop_point_label: string,
          readonly scheduled_stop_point_sequence: number
        }>
      }>
    }>
  }>
};

export type GetRouteByFiltersQueryVariables = Exact<{
  routeFilters?: InputMaybe<RouteRouteBoolExp>;
}>;


export type GetRouteByFiltersQuery = {
  readonly __typename?: 'query_root',
  readonly route_route: ReadonlyArray<{
    readonly __typename?: 'route_route',
    readonly route_id: UUID,
    readonly label: string,
    readonly variant?: number | null,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly priority: number,
    readonly direction: RouteDirectionEnum,
    readonly route_journey_patterns: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
        readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly scheduled_stop_point_label: string,
        readonly scheduled_stop_point_sequence: number
      }>
    }>
  }>
};

export type DisplayedRouteFragment = {
  readonly __typename?: 'route_route',
  readonly route_id: UUID,
  readonly label: string,
  readonly variant?: number | null,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly priority: number,
  readonly direction: RouteDirectionEnum,
  readonly route_journey_patterns: ReadonlyArray<{
    readonly __typename?: 'journey_pattern_journey_pattern',
    readonly journey_pattern_id: UUID,
    readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly scheduled_stop_point_label: string,
      readonly scheduled_stop_point_sequence: number
    }>
  }>
};

export type RouteMetadataFragment = {
  readonly __typename?: 'route_route',
  readonly name_i18n: LocalizedString,
  readonly label: string,
  readonly priority: number,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly direction: RouteDirectionEnum,
  readonly variant?: number | null
};

export type RouteWithInfrastructureLinksWithStopsFragment = {
  readonly __typename?: 'route_route',
  readonly route_shape?: GeoJSON.LineString | null,
  readonly name_i18n: LocalizedString,
  readonly description_i18n?: LocalizedString | null,
  readonly origin_name_i18n: LocalizedString,
  readonly origin_short_name_i18n: LocalizedString,
  readonly destination_name_i18n: LocalizedString,
  readonly destination_short_name_i18n: LocalizedString,
  readonly on_line_id: UUID,
  readonly label: string,
  readonly direction: RouteDirectionEnum,
  readonly variant?: number | null,
  readonly route_id: UUID,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly priority: number,
  readonly route_line: {
    readonly __typename?: 'route_line',
    readonly primary_vehicle_mode: ReusableComponentsVehicleModeEnum,
    readonly type_of_line: RouteTypeOfLineEnum,
    readonly transport_target: HslRouteTransportTargetEnum,
    readonly line_id: UUID,
    readonly label: string,
    readonly name_i18n: LocalizedString,
    readonly short_name_i18n: LocalizedString,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly priority: number
  },
  readonly infrastructure_links_along_route: ReadonlyArray<{
    readonly __typename?: 'route_infrastructure_link_along_route',
    readonly route_id: UUID,
    readonly infrastructure_link_sequence: number,
    readonly infrastructure_link_id: UUID,
    readonly is_traversal_forwards: boolean,
    readonly infrastructure_link: {
      readonly __typename?: 'infrastructure_network_infrastructure_link',
      readonly external_link_source: InfrastructureNetworkExternalSourceEnum,
      readonly external_link_id: string,
      readonly infrastructure_link_id: UUID,
      readonly shape: GeoJSON.LineString,
      readonly direction: InfrastructureNetworkDirectionEnum,
      readonly scheduled_stop_points_located_on_infrastructure_link: ReadonlyArray<{
        readonly __typename?: 'service_pattern_scheduled_stop_point',
        readonly measured_location: GeoJSON.Point,
        readonly relative_distance_from_infrastructure_link_start: number,
        readonly closest_point_on_infrastructure_link?: GeoJSON.Point | null,
        readonly priority: number,
        readonly direction: InfrastructureNetworkDirectionEnum,
        readonly scheduled_stop_point_id: UUID,
        readonly label: string,
        readonly timing_place_id?: UUID | null,
        readonly validity_start?: luxon.DateTime | null,
        readonly validity_end?: luxon.DateTime | null,
        readonly located_on_infrastructure_link_id: UUID,
        readonly stop_place_ref?: string | null,
        readonly stop_place?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_ParentStopPlace',
          readonly id?: string | null,
          readonly name?: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly lang?: string | null,
            readonly value?: string | null
          } | null
        } | {
          readonly __typename?: 'stop_registry_StopPlace',
          readonly id?: string | null,
          readonly name?: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly lang?: string | null,
            readonly value?: string | null
          } | null
        } | null> | null,
        readonly other_label_instances: ReadonlyArray<{
          readonly __typename?: 'service_pattern_scheduled_stop_point',
          readonly priority: number,
          readonly direction: InfrastructureNetworkDirectionEnum,
          readonly scheduled_stop_point_id: UUID,
          readonly label: string,
          readonly timing_place_id?: UUID | null,
          readonly validity_start?: luxon.DateTime | null,
          readonly validity_end?: luxon.DateTime | null,
          readonly located_on_infrastructure_link_id: UUID,
          readonly stop_place_ref?: string | null,
          readonly timing_place?: {
            readonly __typename?: 'timing_pattern_timing_place',
            readonly timing_place_id: UUID,
            readonly label: string
          } | null
        }>,
        readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
          readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
          readonly journey_pattern_id: UUID,
          readonly scheduled_stop_point_label: string,
          readonly scheduled_stop_point_sequence: number,
          readonly is_used_as_timing_point: boolean,
          readonly is_regulated_timing_point: boolean,
          readonly is_loading_time_allowed: boolean,
          readonly is_via_point: boolean,
          readonly via_point_name_i18n?: LocalizedString | null,
          readonly via_point_short_name_i18n?: LocalizedString | null,
          readonly journey_pattern: {
            readonly __typename?: 'journey_pattern_journey_pattern',
            readonly journey_pattern_id: UUID,
            readonly on_route_id: UUID
          }
        }>,
        readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
          readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
          readonly vehicle_mode: ReusableComponentsVehicleModeEnum
        }>,
        readonly timing_place?: {
          readonly __typename?: 'timing_pattern_timing_place',
          readonly timing_place_id: UUID,
          readonly label: string
        } | null
      }>
    }
  }>
};

export type RouteWithInfrastructureLinksWithStopsAndJpsFragment = {
  readonly __typename?: 'route_route',
  readonly route_shape?: GeoJSON.LineString | null,
  readonly name_i18n: LocalizedString,
  readonly description_i18n?: LocalizedString | null,
  readonly origin_name_i18n: LocalizedString,
  readonly origin_short_name_i18n: LocalizedString,
  readonly destination_name_i18n: LocalizedString,
  readonly destination_short_name_i18n: LocalizedString,
  readonly on_line_id: UUID,
  readonly label: string,
  readonly direction: RouteDirectionEnum,
  readonly variant?: number | null,
  readonly route_id: UUID,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly priority: number,
  readonly route_line: {
    readonly __typename?: 'route_line',
    readonly primary_vehicle_mode: ReusableComponentsVehicleModeEnum,
    readonly type_of_line: RouteTypeOfLineEnum,
    readonly transport_target: HslRouteTransportTargetEnum,
    readonly line_id: UUID,
    readonly label: string,
    readonly name_i18n: LocalizedString,
    readonly short_name_i18n: LocalizedString,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly priority: number
  },
  readonly infrastructure_links_along_route: ReadonlyArray<{
    readonly __typename?: 'route_infrastructure_link_along_route',
    readonly route_id: UUID,
    readonly infrastructure_link_sequence: number,
    readonly infrastructure_link_id: UUID,
    readonly is_traversal_forwards: boolean,
    readonly infrastructure_link: {
      readonly __typename?: 'infrastructure_network_infrastructure_link',
      readonly external_link_source: InfrastructureNetworkExternalSourceEnum,
      readonly external_link_id: string,
      readonly infrastructure_link_id: UUID,
      readonly shape: GeoJSON.LineString,
      readonly direction: InfrastructureNetworkDirectionEnum,
      readonly scheduled_stop_points_located_on_infrastructure_link: ReadonlyArray<{
        readonly __typename?: 'service_pattern_scheduled_stop_point',
        readonly measured_location: GeoJSON.Point,
        readonly relative_distance_from_infrastructure_link_start: number,
        readonly closest_point_on_infrastructure_link?: GeoJSON.Point | null,
        readonly priority: number,
        readonly direction: InfrastructureNetworkDirectionEnum,
        readonly scheduled_stop_point_id: UUID,
        readonly label: string,
        readonly timing_place_id?: UUID | null,
        readonly validity_start?: luxon.DateTime | null,
        readonly validity_end?: luxon.DateTime | null,
        readonly located_on_infrastructure_link_id: UUID,
        readonly stop_place_ref?: string | null,
        readonly stop_place?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_ParentStopPlace',
          readonly id?: string | null,
          readonly name?: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly lang?: string | null,
            readonly value?: string | null
          } | null
        } | {
          readonly __typename?: 'stop_registry_StopPlace',
          readonly id?: string | null,
          readonly name?: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly lang?: string | null,
            readonly value?: string | null
          } | null
        } | null> | null,
        readonly other_label_instances: ReadonlyArray<{
          readonly __typename?: 'service_pattern_scheduled_stop_point',
          readonly priority: number,
          readonly direction: InfrastructureNetworkDirectionEnum,
          readonly scheduled_stop_point_id: UUID,
          readonly label: string,
          readonly timing_place_id?: UUID | null,
          readonly validity_start?: luxon.DateTime | null,
          readonly validity_end?: luxon.DateTime | null,
          readonly located_on_infrastructure_link_id: UUID,
          readonly stop_place_ref?: string | null,
          readonly timing_place?: {
            readonly __typename?: 'timing_pattern_timing_place',
            readonly timing_place_id: UUID,
            readonly label: string
          } | null
        }>,
        readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
          readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
          readonly journey_pattern_id: UUID,
          readonly scheduled_stop_point_label: string,
          readonly scheduled_stop_point_sequence: number,
          readonly is_used_as_timing_point: boolean,
          readonly is_regulated_timing_point: boolean,
          readonly is_loading_time_allowed: boolean,
          readonly is_via_point: boolean,
          readonly via_point_name_i18n?: LocalizedString | null,
          readonly via_point_short_name_i18n?: LocalizedString | null,
          readonly journey_pattern: {
            readonly __typename?: 'journey_pattern_journey_pattern',
            readonly journey_pattern_id: UUID,
            readonly on_route_id: UUID
          }
        }>,
        readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
          readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
          readonly vehicle_mode: ReusableComponentsVehicleModeEnum
        }>,
        readonly timing_place?: {
          readonly __typename?: 'timing_pattern_timing_place',
          readonly timing_place_id: UUID,
          readonly label: string
        } | null
      }>
    }
  }>,
  readonly route_journey_patterns: ReadonlyArray<{
    readonly __typename?: 'journey_pattern_journey_pattern',
    readonly journey_pattern_id: UUID,
    readonly on_route_id: UUID,
    readonly ordered_scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly scheduled_stop_point_label: string,
      readonly scheduled_stop_point_sequence: number,
      readonly is_used_as_timing_point: boolean,
      readonly is_regulated_timing_point: boolean,
      readonly is_loading_time_allowed: boolean,
      readonly is_via_point: boolean,
      readonly via_point_name_i18n?: LocalizedString | null,
      readonly via_point_short_name_i18n?: LocalizedString | null,
      readonly scheduled_stop_points: ReadonlyArray<{
        readonly __typename?: 'service_pattern_scheduled_stop_point',
        readonly priority: number,
        readonly direction: InfrastructureNetworkDirectionEnum,
        readonly scheduled_stop_point_id: UUID,
        readonly label: string,
        readonly timing_place_id?: UUID | null,
        readonly validity_start?: luxon.DateTime | null,
        readonly validity_end?: luxon.DateTime | null,
        readonly located_on_infrastructure_link_id: UUID,
        readonly stop_place_ref?: string | null,
        readonly timing_place?: {
          readonly __typename?: 'timing_pattern_timing_place',
          readonly timing_place_id: UUID,
          readonly label: string
        } | null
      }>,
      readonly journey_pattern: {
        readonly __typename?: 'journey_pattern_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly on_route_id: UUID
      }
    }>
  }>
};

export type InfraLinkAlongRouteWithStopsFragment = {
  readonly __typename?: 'route_infrastructure_link_along_route',
  readonly route_id: UUID,
  readonly infrastructure_link_sequence: number,
  readonly infrastructure_link_id: UUID,
  readonly is_traversal_forwards: boolean,
  readonly infrastructure_link: {
    readonly __typename?: 'infrastructure_network_infrastructure_link',
    readonly external_link_source: InfrastructureNetworkExternalSourceEnum,
    readonly external_link_id: string,
    readonly infrastructure_link_id: UUID,
    readonly shape: GeoJSON.LineString,
    readonly direction: InfrastructureNetworkDirectionEnum,
    readonly scheduled_stop_points_located_on_infrastructure_link: ReadonlyArray<{
      readonly __typename?: 'service_pattern_scheduled_stop_point',
      readonly measured_location: GeoJSON.Point,
      readonly relative_distance_from_infrastructure_link_start: number,
      readonly closest_point_on_infrastructure_link?: GeoJSON.Point | null,
      readonly priority: number,
      readonly direction: InfrastructureNetworkDirectionEnum,
      readonly scheduled_stop_point_id: UUID,
      readonly label: string,
      readonly timing_place_id?: UUID | null,
      readonly validity_start?: luxon.DateTime | null,
      readonly validity_end?: luxon.DateTime | null,
      readonly located_on_infrastructure_link_id: UUID,
      readonly stop_place_ref?: string | null,
      readonly stop_place?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_ParentStopPlace',
        readonly id?: string | null,
        readonly name?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        } | null
      } | {
        readonly __typename?: 'stop_registry_StopPlace',
        readonly id?: string | null,
        readonly name?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        } | null
      } | null> | null,
      readonly other_label_instances: ReadonlyArray<{
        readonly __typename?: 'service_pattern_scheduled_stop_point',
        readonly priority: number,
        readonly direction: InfrastructureNetworkDirectionEnum,
        readonly scheduled_stop_point_id: UUID,
        readonly label: string,
        readonly timing_place_id?: UUID | null,
        readonly validity_start?: luxon.DateTime | null,
        readonly validity_end?: luxon.DateTime | null,
        readonly located_on_infrastructure_link_id: UUID,
        readonly stop_place_ref?: string | null,
        readonly timing_place?: {
          readonly __typename?: 'timing_pattern_timing_place',
          readonly timing_place_id: UUID,
          readonly label: string
        } | null
      }>,
      readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
        readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly scheduled_stop_point_label: string,
        readonly scheduled_stop_point_sequence: number,
        readonly is_used_as_timing_point: boolean,
        readonly is_regulated_timing_point: boolean,
        readonly is_loading_time_allowed: boolean,
        readonly is_via_point: boolean,
        readonly via_point_name_i18n?: LocalizedString | null,
        readonly via_point_short_name_i18n?: LocalizedString | null,
        readonly journey_pattern: {
          readonly __typename?: 'journey_pattern_journey_pattern',
          readonly journey_pattern_id: UUID,
          readonly on_route_id: UUID
        }
      }>,
      readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
        readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
        readonly vehicle_mode: ReusableComponentsVehicleModeEnum
      }>,
      readonly timing_place?: {
        readonly __typename?: 'timing_pattern_timing_place',
        readonly timing_place_id: UUID,
        readonly label: string
      } | null
    }>
  }
};

export type GetRouteWithInfrastructureLinksWithStopsQueryVariables = Exact<{
  route_id: Scalars['uuid']['input'];
}>;


export type GetRouteWithInfrastructureLinksWithStopsQuery = {
  readonly __typename?: 'query_root',
  readonly route_route_by_pk?: {
    readonly __typename?: 'route_route',
    readonly route_shape?: GeoJSON.LineString | null,
    readonly name_i18n: LocalizedString,
    readonly description_i18n?: LocalizedString | null,
    readonly origin_name_i18n: LocalizedString,
    readonly origin_short_name_i18n: LocalizedString,
    readonly destination_name_i18n: LocalizedString,
    readonly destination_short_name_i18n: LocalizedString,
    readonly on_line_id: UUID,
    readonly label: string,
    readonly direction: RouteDirectionEnum,
    readonly variant?: number | null,
    readonly route_id: UUID,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly priority: number,
    readonly route_line: {
      readonly __typename?: 'route_line',
      readonly primary_vehicle_mode: ReusableComponentsVehicleModeEnum,
      readonly type_of_line: RouteTypeOfLineEnum,
      readonly transport_target: HslRouteTransportTargetEnum,
      readonly line_id: UUID,
      readonly label: string,
      readonly name_i18n: LocalizedString,
      readonly short_name_i18n: LocalizedString,
      readonly validity_start?: luxon.DateTime | null,
      readonly validity_end?: luxon.DateTime | null,
      readonly priority: number
    },
    readonly infrastructure_links_along_route: ReadonlyArray<{
      readonly __typename?: 'route_infrastructure_link_along_route',
      readonly route_id: UUID,
      readonly infrastructure_link_sequence: number,
      readonly infrastructure_link_id: UUID,
      readonly is_traversal_forwards: boolean,
      readonly infrastructure_link: {
        readonly __typename?: 'infrastructure_network_infrastructure_link',
        readonly external_link_source: InfrastructureNetworkExternalSourceEnum,
        readonly external_link_id: string,
        readonly infrastructure_link_id: UUID,
        readonly shape: GeoJSON.LineString,
        readonly direction: InfrastructureNetworkDirectionEnum,
        readonly scheduled_stop_points_located_on_infrastructure_link: ReadonlyArray<{
          readonly __typename?: 'service_pattern_scheduled_stop_point',
          readonly measured_location: GeoJSON.Point,
          readonly relative_distance_from_infrastructure_link_start: number,
          readonly closest_point_on_infrastructure_link?: GeoJSON.Point | null,
          readonly priority: number,
          readonly direction: InfrastructureNetworkDirectionEnum,
          readonly scheduled_stop_point_id: UUID,
          readonly label: string,
          readonly timing_place_id?: UUID | null,
          readonly validity_start?: luxon.DateTime | null,
          readonly validity_end?: luxon.DateTime | null,
          readonly located_on_infrastructure_link_id: UUID,
          readonly stop_place_ref?: string | null,
          readonly stop_place?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_ParentStopPlace',
            readonly id?: string | null,
            readonly name?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly lang?: string | null,
              readonly value?: string | null
            } | null
          } | {
            readonly __typename?: 'stop_registry_StopPlace',
            readonly id?: string | null,
            readonly name?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly lang?: string | null,
              readonly value?: string | null
            } | null
          } | null> | null,
          readonly other_label_instances: ReadonlyArray<{
            readonly __typename?: 'service_pattern_scheduled_stop_point',
            readonly priority: number,
            readonly direction: InfrastructureNetworkDirectionEnum,
            readonly scheduled_stop_point_id: UUID,
            readonly label: string,
            readonly timing_place_id?: UUID | null,
            readonly validity_start?: luxon.DateTime | null,
            readonly validity_end?: luxon.DateTime | null,
            readonly located_on_infrastructure_link_id: UUID,
            readonly stop_place_ref?: string | null,
            readonly timing_place?: {
              readonly __typename?: 'timing_pattern_timing_place',
              readonly timing_place_id: UUID,
              readonly label: string
            } | null
          }>,
          readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
            readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
            readonly journey_pattern_id: UUID,
            readonly scheduled_stop_point_label: string,
            readonly scheduled_stop_point_sequence: number,
            readonly is_used_as_timing_point: boolean,
            readonly is_regulated_timing_point: boolean,
            readonly is_loading_time_allowed: boolean,
            readonly is_via_point: boolean,
            readonly via_point_name_i18n?: LocalizedString | null,
            readonly via_point_short_name_i18n?: LocalizedString | null,
            readonly journey_pattern: {
              readonly __typename?: 'journey_pattern_journey_pattern',
              readonly journey_pattern_id: UUID,
              readonly on_route_id: UUID
            }
          }>,
          readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
            readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
            readonly vehicle_mode: ReusableComponentsVehicleModeEnum
          }>,
          readonly timing_place?: {
            readonly __typename?: 'timing_pattern_timing_place',
            readonly timing_place_id: UUID,
            readonly label: string
          } | null
        }>
      }
    }>,
    readonly route_journey_patterns: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly on_route_id: UUID,
      readonly ordered_scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
        readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly scheduled_stop_point_label: string,
        readonly scheduled_stop_point_sequence: number,
        readonly is_used_as_timing_point: boolean,
        readonly is_regulated_timing_point: boolean,
        readonly is_loading_time_allowed: boolean,
        readonly is_via_point: boolean,
        readonly via_point_name_i18n?: LocalizedString | null,
        readonly via_point_short_name_i18n?: LocalizedString | null,
        readonly scheduled_stop_points: ReadonlyArray<{
          readonly __typename?: 'service_pattern_scheduled_stop_point',
          readonly priority: number,
          readonly direction: InfrastructureNetworkDirectionEnum,
          readonly scheduled_stop_point_id: UUID,
          readonly label: string,
          readonly timing_place_id?: UUID | null,
          readonly validity_start?: luxon.DateTime | null,
          readonly validity_end?: luxon.DateTime | null,
          readonly located_on_infrastructure_link_id: UUID,
          readonly stop_place_ref?: string | null,
          readonly timing_place?: {
            readonly __typename?: 'timing_pattern_timing_place',
            readonly timing_place_id: UUID,
            readonly label: string
          } | null
        }>,
        readonly journey_pattern: {
          readonly __typename?: 'journey_pattern_journey_pattern',
          readonly journey_pattern_id: UUID,
          readonly on_route_id: UUID
        }
      }>
    }>
  } | null
};

export type SearchLinesAndRoutesQueryVariables = Exact<{
  lineFilter?: InputMaybe<RouteLineBoolExp>;
  routeFilter?: InputMaybe<RouteRouteBoolExp>;
  lineOrderBy?: InputMaybe<ReadonlyArray<RouteLineOrderBy> | RouteLineOrderBy>;
  routeOrderBy?: InputMaybe<ReadonlyArray<RouteRouteOrderBy> | RouteRouteOrderBy>;
}>;


export type SearchLinesAndRoutesQuery = {
  readonly __typename?: 'query_root',
  readonly route_line: ReadonlyArray<{
    readonly __typename?: 'route_line',
    readonly name_i18n: LocalizedString,
    readonly short_name_i18n: LocalizedString,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly priority: number,
    readonly line_id: UUID,
    readonly label: string,
    readonly line_routes: ReadonlyArray<{
      readonly __typename?: 'route_route',
      readonly unique_label: string,
      readonly direction: RouteDirectionEnum,
      readonly route_id: UUID,
      readonly route_shape?: GeoJSON.LineString | null,
      readonly label: string,
      readonly validity_start?: luxon.DateTime | null,
      readonly validity_end?: luxon.DateTime | null,
      readonly route_journey_patterns: ReadonlyArray<{
        readonly __typename?: 'journey_pattern_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly journey_pattern_refs: ReadonlyArray<{
          readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref',
          readonly journey_pattern_ref_id: UUID,
          readonly vehicle_journeys: ReadonlyArray<{
            readonly __typename?: 'timetables_vehicle_journey_vehicle_journey',
            readonly vehicle_journey_id: UUID
          }>
        }>,
        readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
          readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
          readonly journey_pattern_id: UUID,
          readonly scheduled_stop_point_sequence: number,
          readonly is_used_as_timing_point: boolean
        }>
      }>
    }>
  }>,
  readonly route_route: ReadonlyArray<{
    readonly __typename?: 'route_route',
    readonly name_i18n: LocalizedString,
    readonly direction: RouteDirectionEnum,
    readonly priority: number,
    readonly on_line_id: UUID,
    readonly variant?: number | null,
    readonly unique_label: string,
    readonly route_id: UUID,
    readonly label: string,
    readonly route_shape?: GeoJSON.LineString | null,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly route_journey_patterns: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly journey_pattern_refs: ReadonlyArray<{
        readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref',
        readonly journey_pattern_ref_id: UUID,
        readonly vehicle_journeys: ReadonlyArray<{
          readonly __typename?: 'timetables_vehicle_journey_vehicle_journey',
          readonly vehicle_journey_id: UUID
        }>
      }>,
      readonly scheduled_stop_point_in_journey_patterns: ReadonlyArray<{
        readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly scheduled_stop_point_sequence: number,
        readonly is_used_as_timing_point: boolean
      }>
    }>
  }>
};

export type DeleteStopAreaMutationVariables = Exact<{
  stopPlaceId: Scalars['String']['input'];
}>;


export type DeleteStopAreaMutation = {
  readonly __typename?: 'mutation_root',
  readonly stop_registry?: {
    readonly __typename?: 'stop_registryStopPlaceMutation',
    readonly deleteStopPlace?: boolean | null
  } | null
};

export type CreateTerminalMutationVariables = Exact<{
  input: StopRegistryCreateMultiModalStopPlaceInput;
}>;


export type CreateTerminalMutation = {
  readonly __typename?: 'mutation_root',
  readonly stop_registry?: {
    readonly __typename?: 'stop_registryStopPlaceMutation',
    readonly createMultiModalStopPlace?: {
      readonly __typename?: 'stop_registry_ParentStopPlace',
      readonly id?: string | null,
      readonly alternativeNames?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_AlternativeName',
        readonly nameType: StopRegistryNameType,
        readonly name: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        }
      } | null> | null,
      readonly privateCode?: {
        readonly __typename?: 'stop_registry_PrivateCode',
        readonly value?: string | null,
        readonly type?: string | null
      } | null,
      readonly name?: {
        readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
        readonly lang?: string | null,
        readonly value?: string | null
      } | null,
      readonly description?: {
        readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
        readonly lang?: string | null,
        readonly value?: string | null
      } | null,
      readonly geometry?: {
        readonly __typename?: 'stop_registry_GeoJSON',
        readonly type?: StopRegistryGeoJsonType | null,
        readonly coordinates?: GeoJSON.Position | null
      } | null,
      readonly topographicPlace?: {
        readonly __typename?: 'stop_registry_TopographicPlace',
        readonly name?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly value?: string | null
        } | null
      } | null,
      readonly fareZones?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_FareZone',
        readonly name?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly value?: string | null
        } | null
      } | null> | null,
      readonly keyValues?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_KeyValues',
        readonly key?: string | null,
        readonly values?: ReadonlyArray<string | null> | null
      } | null> | null,
      readonly infoSpots?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_infoSpot',
        readonly id?: string | null,
        readonly backlight?: boolean | null,
        readonly displayType?: StopRegistryDisplayType | null,
        readonly floor?: string | null,
        readonly label?: string | null,
        readonly width?: number | null,
        readonly height?: number | null,
        readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
        readonly infoSpotType?: StopRegistryInfoSpotType | null,
        readonly purpose?: string | null,
        readonly railInformation?: string | null,
        readonly speechProperty?: boolean | null,
        readonly zoneLabel?: string | null,
        readonly description?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        } | null,
        readonly poster?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_poster',
          readonly label?: string | null,
          readonly width?: number | null,
          readonly height?: number | null,
          readonly lines?: string | null
        } | null> | null
      } | null> | null,
      readonly accessibilityAssessment?: {
        readonly __typename?: 'stop_registry_AccessibilityAssessment',
        readonly id?: string | null,
        readonly hslAccessibilityProperties?: {
          readonly __typename?: 'stop_registry_HslAccessibilityProperties',
          readonly id?: string | null,
          readonly stopAreaSideSlope?: number | null,
          readonly stopAreaLengthwiseSlope?: number | null,
          readonly endRampSlope?: number | null,
          readonly shelterLaneDistance?: number | null,
          readonly curbBackOfRailDistance?: number | null,
          readonly curbDriveSideOfRailDistance?: number | null,
          readonly structureLaneDistance?: number | null,
          readonly stopElevationFromRailTop?: number | null,
          readonly stopElevationFromSidewalk?: number | null,
          readonly lowerCleatHeight?: number | null,
          readonly serviceAreaWidth?: number | null,
          readonly serviceAreaLength?: number | null,
          readonly platformEdgeWarningArea?: boolean | null,
          readonly guidanceTiles?: boolean | null,
          readonly guidanceStripe?: boolean | null,
          readonly serviceAreaStripes?: boolean | null,
          readonly sidewalkAccessibleConnection?: boolean | null,
          readonly stopAreaSurroundingsAccessible?: boolean | null,
          readonly curvedStop?: boolean | null,
          readonly stopType?: StopRegistryStopType | null,
          readonly shelterType?: StopRegistryShelterWidthType | null,
          readonly guidanceType?: StopRegistryGuidanceType | null,
          readonly mapType?: StopRegistryMapType | null,
          readonly pedestrianCrossingRampType?: StopRegistryPedestrianCrossingRampType | null,
          readonly accessibilityLevel?: StopRegistryAccessibilityLevel | null
        } | null,
        readonly limitations?: {
          readonly __typename?: 'stop_registry_AccessibilityLimitations',
          readonly id?: string | null,
          readonly version?: string | null,
          readonly audibleSignalsAvailable?: StopRegistryLimitationStatusType | null,
          readonly escalatorFreeAccess?: StopRegistryLimitationStatusType | null,
          readonly liftFreeAccess?: StopRegistryLimitationStatusType | null,
          readonly stepFreeAccess?: StopRegistryLimitationStatusType | null,
          readonly wheelchairAccess?: StopRegistryLimitationStatusType | null
        } | null
      } | null,
      readonly children?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_StopPlace',
        readonly id?: string | null,
        readonly name?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly value?: string | null
        } | null,
        readonly privateCode?: {
          readonly __typename?: 'stop_registry_PrivateCode',
          readonly value?: string | null
        } | null,
        readonly quays?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_Quay',
          readonly id?: string | null,
          readonly publicCode?: string | null,
          readonly description?: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly lang?: string | null,
            readonly value?: string | null
          } | null,
          readonly scheduled_stop_point?: {
            readonly __typename?: 'service_pattern_scheduled_stop_point',
            readonly priority: number,
            readonly direction: InfrastructureNetworkDirectionEnum,
            readonly scheduled_stop_point_id: UUID,
            readonly label: string,
            readonly timing_place_id?: UUID | null,
            readonly validity_start?: luxon.DateTime | null,
            readonly validity_end?: luxon.DateTime | null,
            readonly located_on_infrastructure_link_id: UUID,
            readonly stop_place_ref?: string | null,
            readonly measured_location: GeoJSON.Point,
            readonly timing_place?: {
              readonly __typename?: 'timing_pattern_timing_place',
              readonly timing_place_id: UUID,
              readonly label: string
            } | null,
            readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
              readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
              readonly vehicle_mode: ReusableComponentsVehicleModeEnum
            }>
          } | null,
          readonly keyValues?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_KeyValues',
            readonly key?: string | null,
            readonly values?: ReadonlyArray<string | null> | null
          } | null> | null,
          readonly infoSpots?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_infoSpot',
            readonly id?: string | null,
            readonly backlight?: boolean | null,
            readonly displayType?: StopRegistryDisplayType | null,
            readonly floor?: string | null,
            readonly label?: string | null,
            readonly width?: number | null,
            readonly height?: number | null,
            readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
            readonly infoSpotType?: StopRegistryInfoSpotType | null,
            readonly purpose?: string | null,
            readonly railInformation?: string | null,
            readonly speechProperty?: boolean | null,
            readonly zoneLabel?: string | null,
            readonly description?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly lang?: string | null,
              readonly value?: string | null
            } | null,
            readonly poster?: ReadonlyArray<{
              readonly __typename?: 'stop_registry_poster',
              readonly label?: string | null,
              readonly width?: number | null,
              readonly height?: number | null,
              readonly lines?: string | null
            } | null> | null
          } | null> | null,
          readonly placeEquipments?: {
            readonly __typename?: 'stop_registry_PlaceEquipments',
            readonly id?: string | null,
            readonly generalSign?: ReadonlyArray<{
              readonly __typename?: 'stop_registry_GeneralSign',
              readonly id?: string | null,
              readonly content?: {
                readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
                readonly value?: string | null
              } | null
            } | null> | null,
            readonly shelterEquipment?: ReadonlyArray<{
              readonly __typename?: 'stop_registry_ShelterEquipment',
              readonly id?: string | null,
              readonly shelterNumber?: number | null
            } | null> | null
          } | null
        } | null> | null
      } | null> | null,
      readonly externalLinks?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_stopPlaceExternalLink',
        readonly stopPlaceId?: number | null,
        readonly orderNum?: number | null,
        readonly name?: string | null,
        readonly location?: string | null
      } | null> | null,
      readonly organisations?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_StopPlaceOrganisationRef',
        readonly organisationRef: string,
        readonly relationshipType?: StopRegistryStopPlaceOrganisationRelationshipType | null,
        readonly organisation?: {
          readonly __typename?: 'stop_registry_Organisation',
          readonly id?: string | null,
          readonly name?: string | null,
          readonly privateContactDetails?: {
            readonly __typename?: 'stop_registry_Contact',
            readonly id?: string | null,
            readonly email?: string | null,
            readonly phone?: string | null
          } | null
        } | null
      } | null> | null
    } | null
  } | null
};

export type DeleteTerminalMutationVariables = Exact<{
  terminalId: Scalars['String']['input'];
}>;


export type DeleteTerminalMutation = {
  readonly __typename?: 'mutation_root',
  readonly stop_registry?: {
    readonly __typename?: 'stop_registryStopPlaceMutation',
    readonly deleteStopPlace?: boolean | null
  } | null
};

export type UpdateTerminalMutationVariables = Exact<{
  input: StopRegistryParentStopPlaceInput;
}>;


export type UpdateTerminalMutation = {
  readonly __typename?: 'mutation_root',
  readonly stop_registry?: {
    readonly __typename?: 'stop_registryStopPlaceMutation',
    readonly mutateParentStopPlace?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_ParentStopPlace',
      readonly id?: string | null,
      readonly alternativeNames?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_AlternativeName',
        readonly nameType: StopRegistryNameType,
        readonly name: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        }
      } | null> | null,
      readonly privateCode?: {
        readonly __typename?: 'stop_registry_PrivateCode',
        readonly value?: string | null,
        readonly type?: string | null
      } | null,
      readonly name?: {
        readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
        readonly lang?: string | null,
        readonly value?: string | null
      } | null,
      readonly description?: {
        readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
        readonly lang?: string | null,
        readonly value?: string | null
      } | null,
      readonly geometry?: {
        readonly __typename?: 'stop_registry_GeoJSON',
        readonly type?: StopRegistryGeoJsonType | null,
        readonly coordinates?: GeoJSON.Position | null
      } | null,
      readonly topographicPlace?: {
        readonly __typename?: 'stop_registry_TopographicPlace',
        readonly name?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly value?: string | null
        } | null
      } | null,
      readonly fareZones?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_FareZone',
        readonly name?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly value?: string | null
        } | null
      } | null> | null,
      readonly keyValues?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_KeyValues',
        readonly key?: string | null,
        readonly values?: ReadonlyArray<string | null> | null
      } | null> | null,
      readonly infoSpots?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_infoSpot',
        readonly id?: string | null,
        readonly backlight?: boolean | null,
        readonly displayType?: StopRegistryDisplayType | null,
        readonly floor?: string | null,
        readonly label?: string | null,
        readonly width?: number | null,
        readonly height?: number | null,
        readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
        readonly infoSpotType?: StopRegistryInfoSpotType | null,
        readonly purpose?: string | null,
        readonly railInformation?: string | null,
        readonly speechProperty?: boolean | null,
        readonly zoneLabel?: string | null,
        readonly description?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        } | null,
        readonly poster?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_poster',
          readonly label?: string | null,
          readonly width?: number | null,
          readonly height?: number | null,
          readonly lines?: string | null
        } | null> | null
      } | null> | null,
      readonly accessibilityAssessment?: {
        readonly __typename?: 'stop_registry_AccessibilityAssessment',
        readonly id?: string | null,
        readonly hslAccessibilityProperties?: {
          readonly __typename?: 'stop_registry_HslAccessibilityProperties',
          readonly id?: string | null,
          readonly stopAreaSideSlope?: number | null,
          readonly stopAreaLengthwiseSlope?: number | null,
          readonly endRampSlope?: number | null,
          readonly shelterLaneDistance?: number | null,
          readonly curbBackOfRailDistance?: number | null,
          readonly curbDriveSideOfRailDistance?: number | null,
          readonly structureLaneDistance?: number | null,
          readonly stopElevationFromRailTop?: number | null,
          readonly stopElevationFromSidewalk?: number | null,
          readonly lowerCleatHeight?: number | null,
          readonly serviceAreaWidth?: number | null,
          readonly serviceAreaLength?: number | null,
          readonly platformEdgeWarningArea?: boolean | null,
          readonly guidanceTiles?: boolean | null,
          readonly guidanceStripe?: boolean | null,
          readonly serviceAreaStripes?: boolean | null,
          readonly sidewalkAccessibleConnection?: boolean | null,
          readonly stopAreaSurroundingsAccessible?: boolean | null,
          readonly curvedStop?: boolean | null,
          readonly stopType?: StopRegistryStopType | null,
          readonly shelterType?: StopRegistryShelterWidthType | null,
          readonly guidanceType?: StopRegistryGuidanceType | null,
          readonly mapType?: StopRegistryMapType | null,
          readonly pedestrianCrossingRampType?: StopRegistryPedestrianCrossingRampType | null,
          readonly accessibilityLevel?: StopRegistryAccessibilityLevel | null
        } | null,
        readonly limitations?: {
          readonly __typename?: 'stop_registry_AccessibilityLimitations',
          readonly id?: string | null,
          readonly version?: string | null,
          readonly audibleSignalsAvailable?: StopRegistryLimitationStatusType | null,
          readonly escalatorFreeAccess?: StopRegistryLimitationStatusType | null,
          readonly liftFreeAccess?: StopRegistryLimitationStatusType | null,
          readonly stepFreeAccess?: StopRegistryLimitationStatusType | null,
          readonly wheelchairAccess?: StopRegistryLimitationStatusType | null
        } | null
      } | null,
      readonly children?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_StopPlace',
        readonly id?: string | null,
        readonly name?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly value?: string | null
        } | null,
        readonly privateCode?: {
          readonly __typename?: 'stop_registry_PrivateCode',
          readonly value?: string | null
        } | null,
        readonly quays?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_Quay',
          readonly id?: string | null,
          readonly publicCode?: string | null,
          readonly description?: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly lang?: string | null,
            readonly value?: string | null
          } | null,
          readonly scheduled_stop_point?: {
            readonly __typename?: 'service_pattern_scheduled_stop_point',
            readonly priority: number,
            readonly direction: InfrastructureNetworkDirectionEnum,
            readonly scheduled_stop_point_id: UUID,
            readonly label: string,
            readonly timing_place_id?: UUID | null,
            readonly validity_start?: luxon.DateTime | null,
            readonly validity_end?: luxon.DateTime | null,
            readonly located_on_infrastructure_link_id: UUID,
            readonly stop_place_ref?: string | null,
            readonly measured_location: GeoJSON.Point,
            readonly timing_place?: {
              readonly __typename?: 'timing_pattern_timing_place',
              readonly timing_place_id: UUID,
              readonly label: string
            } | null,
            readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
              readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
              readonly vehicle_mode: ReusableComponentsVehicleModeEnum
            }>
          } | null,
          readonly keyValues?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_KeyValues',
            readonly key?: string | null,
            readonly values?: ReadonlyArray<string | null> | null
          } | null> | null,
          readonly infoSpots?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_infoSpot',
            readonly id?: string | null,
            readonly backlight?: boolean | null,
            readonly displayType?: StopRegistryDisplayType | null,
            readonly floor?: string | null,
            readonly label?: string | null,
            readonly width?: number | null,
            readonly height?: number | null,
            readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
            readonly infoSpotType?: StopRegistryInfoSpotType | null,
            readonly purpose?: string | null,
            readonly railInformation?: string | null,
            readonly speechProperty?: boolean | null,
            readonly zoneLabel?: string | null,
            readonly description?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly lang?: string | null,
              readonly value?: string | null
            } | null,
            readonly poster?: ReadonlyArray<{
              readonly __typename?: 'stop_registry_poster',
              readonly label?: string | null,
              readonly width?: number | null,
              readonly height?: number | null,
              readonly lines?: string | null
            } | null> | null
          } | null> | null,
          readonly placeEquipments?: {
            readonly __typename?: 'stop_registry_PlaceEquipments',
            readonly id?: string | null,
            readonly generalSign?: ReadonlyArray<{
              readonly __typename?: 'stop_registry_GeneralSign',
              readonly id?: string | null,
              readonly content?: {
                readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
                readonly value?: string | null
              } | null
            } | null> | null,
            readonly shelterEquipment?: ReadonlyArray<{
              readonly __typename?: 'stop_registry_ShelterEquipment',
              readonly id?: string | null,
              readonly shelterNumber?: number | null
            } | null> | null
          } | null
        } | null> | null
      } | null> | null,
      readonly externalLinks?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_stopPlaceExternalLink',
        readonly stopPlaceId?: number | null,
        readonly orderNum?: number | null,
        readonly name?: string | null,
        readonly location?: string | null
      } | null> | null,
      readonly organisations?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_StopPlaceOrganisationRef',
        readonly organisationRef: string,
        readonly relationshipType?: StopRegistryStopPlaceOrganisationRelationshipType | null,
        readonly organisation?: {
          readonly __typename?: 'stop_registry_Organisation',
          readonly id?: string | null,
          readonly name?: string | null,
          readonly privateContactDetails?: {
            readonly __typename?: 'stop_registry_Contact',
            readonly id?: string | null,
            readonly email?: string | null,
            readonly phone?: string | null
          } | null
        } | null
      } | null> | null
    } | null> | null
  } | null
};

export type UpdateStopPlaceMutationVariables = Exact<{
  input: StopRegistryStopPlaceInput;
}>;


export type UpdateStopPlaceMutation = {
  readonly __typename?: 'mutation_root',
  readonly stop_registry?: {
    readonly __typename?: 'stop_registryStopPlaceMutation',
    readonly mutateStopPlace?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_StopPlace',
      readonly id?: string | null,
      readonly transportMode?: StopRegistryTransportModeType | null,
      readonly alternativeNames?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_AlternativeName',
        readonly nameType: StopRegistryNameType,
        readonly name: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        }
      } | null> | null,
      readonly privateCode?: {
        readonly __typename?: 'stop_registry_PrivateCode',
        readonly value?: string | null,
        readonly type?: string | null
      } | null,
      readonly name?: {
        readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
        readonly lang?: string | null,
        readonly value?: string | null
      } | null,
      readonly organisations?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_StopPlaceOrganisationRef',
        readonly relationshipType?: StopRegistryStopPlaceOrganisationRelationshipType | null,
        readonly organisationRef: string,
        readonly organisation?: {
          readonly __typename?: 'stop_registry_Organisation',
          readonly id?: string | null,
          readonly name?: string | null,
          readonly privateContactDetails?: {
            readonly __typename?: 'stop_registry_Contact',
            readonly id?: string | null,
            readonly email?: string | null,
            readonly phone?: string | null
          } | null
        } | null
      } | null> | null,
      readonly geometry?: {
        readonly __typename?: 'stop_registry_GeoJSON',
        readonly type?: StopRegistryGeoJsonType | null,
        readonly coordinates?: GeoJSON.Position | null
      } | null,
      readonly keyValues?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_KeyValues',
        readonly key?: string | null,
        readonly values?: ReadonlyArray<string | null> | null
      } | null> | null,
      readonly quays?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_Quay',
        readonly id?: string | null,
        readonly publicCode?: string | null,
        readonly privateCode?: {
          readonly __typename?: 'stop_registry_PrivateCode',
          readonly type?: string | null,
          readonly value?: string | null
        } | null,
        readonly description?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        } | null,
        readonly alternativeNames?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_AlternativeName',
          readonly nameType: StopRegistryNameType,
          readonly name: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly lang?: string | null,
            readonly value?: string | null
          }
        } | null> | null,
        readonly geometry?: {
          readonly __typename?: 'stop_registry_GeoJSON',
          readonly coordinates?: GeoJSON.Position | null,
          readonly type?: StopRegistryGeoJsonType | null
        } | null,
        readonly accessibilityAssessment?: {
          readonly __typename?: 'stop_registry_AccessibilityAssessment',
          readonly id?: string | null,
          readonly hslAccessibilityProperties?: {
            readonly __typename?: 'stop_registry_HslAccessibilityProperties',
            readonly id?: string | null,
            readonly stopAreaSideSlope?: number | null,
            readonly stopAreaLengthwiseSlope?: number | null,
            readonly endRampSlope?: number | null,
            readonly shelterLaneDistance?: number | null,
            readonly curbBackOfRailDistance?: number | null,
            readonly curbDriveSideOfRailDistance?: number | null,
            readonly structureLaneDistance?: number | null,
            readonly stopElevationFromRailTop?: number | null,
            readonly stopElevationFromSidewalk?: number | null,
            readonly lowerCleatHeight?: number | null,
            readonly serviceAreaWidth?: number | null,
            readonly serviceAreaLength?: number | null,
            readonly platformEdgeWarningArea?: boolean | null,
            readonly guidanceTiles?: boolean | null,
            readonly guidanceStripe?: boolean | null,
            readonly serviceAreaStripes?: boolean | null,
            readonly sidewalkAccessibleConnection?: boolean | null,
            readonly stopAreaSurroundingsAccessible?: boolean | null,
            readonly curvedStop?: boolean | null,
            readonly stopType?: StopRegistryStopType | null,
            readonly shelterType?: StopRegistryShelterWidthType | null,
            readonly guidanceType?: StopRegistryGuidanceType | null,
            readonly mapType?: StopRegistryMapType | null,
            readonly pedestrianCrossingRampType?: StopRegistryPedestrianCrossingRampType | null,
            readonly accessibilityLevel?: StopRegistryAccessibilityLevel | null
          } | null,
          readonly limitations?: {
            readonly __typename?: 'stop_registry_AccessibilityLimitations',
            readonly id?: string | null,
            readonly version?: string | null,
            readonly audibleSignalsAvailable?: StopRegistryLimitationStatusType | null,
            readonly escalatorFreeAccess?: StopRegistryLimitationStatusType | null,
            readonly liftFreeAccess?: StopRegistryLimitationStatusType | null,
            readonly stepFreeAccess?: StopRegistryLimitationStatusType | null,
            readonly wheelchairAccess?: StopRegistryLimitationStatusType | null
          } | null
        } | null,
        readonly keyValues?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_KeyValues',
          readonly key?: string | null,
          readonly values?: ReadonlyArray<string | null> | null
        } | null> | null,
        readonly infoSpots?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_infoSpot',
          readonly id?: string | null,
          readonly backlight?: boolean | null,
          readonly displayType?: StopRegistryDisplayType | null,
          readonly floor?: string | null,
          readonly label?: string | null,
          readonly width?: number | null,
          readonly height?: number | null,
          readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
          readonly infoSpotType?: StopRegistryInfoSpotType | null,
          readonly purpose?: string | null,
          readonly railInformation?: string | null,
          readonly speechProperty?: boolean | null,
          readonly zoneLabel?: string | null,
          readonly description?: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly lang?: string | null,
            readonly value?: string | null
          } | null,
          readonly poster?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_poster',
            readonly label?: string | null,
            readonly width?: number | null,
            readonly height?: number | null,
            readonly lines?: string | null
          } | null> | null
        } | null> | null,
        readonly placeEquipments?: {
          readonly __typename?: 'stop_registry_PlaceEquipments',
          readonly id?: string | null,
          readonly shelterEquipment?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_ShelterEquipment',
            readonly id?: string | null,
            readonly enclosed?: boolean | null,
            readonly stepFree?: boolean | null,
            readonly shelterNumber?: number | null,
            readonly shelterType?: StopRegistryShelterType | null,
            readonly shelterElectricity?: StopRegistryShelterElectricity | null,
            readonly shelterLighting?: boolean | null,
            readonly shelterCondition?: StopRegistryShelterCondition | null,
            readonly timetableCabinets?: number | null,
            readonly trashCan?: boolean | null,
            readonly shelterHasDisplay?: boolean | null,
            readonly bicycleParking?: boolean | null,
            readonly leaningRail?: boolean | null,
            readonly outsideBench?: boolean | null,
            readonly shelterFasciaBoardTaping?: boolean | null,
            readonly shelterExternalId?: string | null
          } | null> | null,
          readonly cycleStorageEquipment?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_CycleStorageEquipment',
            readonly cycleStorageType?: StopRegistryCycleStorageType | null
          } | null> | null,
          readonly generalSign?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_GeneralSign',
            readonly signContentType?: StopRegistrySignContentType | null,
            readonly numberOfFrames?: number | null,
            readonly lineSignage?: boolean | null,
            readonly mainLineSign?: boolean | null,
            readonly replacesRailSign?: boolean | null,
            readonly privateCode?: {
              readonly __typename?: 'stop_registry_PrivateCode',
              readonly value?: string | null,
              readonly type?: string | null
            } | null,
            readonly content?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly value?: string | null
            } | null,
            readonly note?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly lang?: string | null,
              readonly value?: string | null
            } | null
          } | null> | null
        } | null,
        readonly scheduled_stop_point?: {
          readonly __typename?: 'service_pattern_scheduled_stop_point',
          readonly priority: number,
          readonly direction: InfrastructureNetworkDirectionEnum,
          readonly scheduled_stop_point_id: UUID,
          readonly label: string,
          readonly timing_place_id?: UUID | null,
          readonly validity_start?: luxon.DateTime | null,
          readonly validity_end?: luxon.DateTime | null,
          readonly located_on_infrastructure_link_id: UUID,
          readonly stop_place_ref?: string | null,
          readonly measured_location: GeoJSON.Point,
          readonly timing_place?: {
            readonly __typename?: 'timing_pattern_timing_place',
            readonly timing_place_id: UUID,
            readonly label: string
          } | null,
          readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
            readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
            readonly vehicle_mode: ReusableComponentsVehicleModeEnum
          }>
        } | null,
        readonly externalLinks?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_externalLink',
          readonly quayId?: number | null,
          readonly orderNum?: number | null,
          readonly name?: string | null,
          readonly location?: string | null
        } | null> | null
      } | null> | null,
      readonly parentStopPlace?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_ParentStopPlace',
        readonly id?: string | null,
        readonly name?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        } | null,
        readonly privateCode?: {
          readonly __typename?: 'stop_registry_PrivateCode',
          readonly value?: string | null,
          readonly type?: string | null
        } | null,
        readonly children?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_StopPlace',
          readonly id?: string | null,
          readonly name?: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly value?: string | null
          } | null,
          readonly privateCode?: {
            readonly __typename?: 'stop_registry_PrivateCode',
            readonly value?: string | null
          } | null,
          readonly quays?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_Quay',
            readonly id?: string | null,
            readonly publicCode?: string | null,
            readonly description?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly lang?: string | null,
              readonly value?: string | null
            } | null,
            readonly scheduled_stop_point?: {
              readonly __typename?: 'service_pattern_scheduled_stop_point',
              readonly priority: number,
              readonly direction: InfrastructureNetworkDirectionEnum,
              readonly scheduled_stop_point_id: UUID,
              readonly label: string,
              readonly timing_place_id?: UUID | null,
              readonly validity_start?: luxon.DateTime | null,
              readonly validity_end?: luxon.DateTime | null,
              readonly located_on_infrastructure_link_id: UUID,
              readonly stop_place_ref?: string | null,
              readonly measured_location: GeoJSON.Point,
              readonly timing_place?: {
                readonly __typename?: 'timing_pattern_timing_place',
                readonly timing_place_id: UUID,
                readonly label: string
              } | null,
              readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
                readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
                readonly vehicle_mode: ReusableComponentsVehicleModeEnum
              }>
            } | null,
            readonly keyValues?: ReadonlyArray<{
              readonly __typename?: 'stop_registry_KeyValues',
              readonly key?: string | null,
              readonly values?: ReadonlyArray<string | null> | null
            } | null> | null,
            readonly infoSpots?: ReadonlyArray<{
              readonly __typename?: 'stop_registry_infoSpot',
              readonly id?: string | null,
              readonly backlight?: boolean | null,
              readonly displayType?: StopRegistryDisplayType | null,
              readonly floor?: string | null,
              readonly label?: string | null,
              readonly width?: number | null,
              readonly height?: number | null,
              readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
              readonly infoSpotType?: StopRegistryInfoSpotType | null,
              readonly purpose?: string | null,
              readonly railInformation?: string | null,
              readonly speechProperty?: boolean | null,
              readonly zoneLabel?: string | null,
              readonly description?: {
                readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
                readonly lang?: string | null,
                readonly value?: string | null
              } | null,
              readonly poster?: ReadonlyArray<{
                readonly __typename?: 'stop_registry_poster',
                readonly label?: string | null,
                readonly width?: number | null,
                readonly height?: number | null,
                readonly lines?: string | null
              } | null> | null
            } | null> | null,
            readonly placeEquipments?: {
              readonly __typename?: 'stop_registry_PlaceEquipments',
              readonly id?: string | null,
              readonly generalSign?: ReadonlyArray<{
                readonly __typename?: 'stop_registry_GeneralSign',
                readonly id?: string | null,
                readonly content?: {
                  readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
                  readonly value?: string | null
                } | null
              } | null> | null,
              readonly shelterEquipment?: ReadonlyArray<{
                readonly __typename?: 'stop_registry_ShelterEquipment',
                readonly id?: string | null,
                readonly shelterNumber?: number | null
              } | null> | null
            } | null
          } | null> | null
        } | null> | null
      } | {
        readonly __typename?: 'stop_registry_StopPlace'
      } | null> | null,
      readonly accessibilityAssessment?: {
        readonly __typename?: 'stop_registry_AccessibilityAssessment',
        readonly id?: string | null,
        readonly hslAccessibilityProperties?: {
          readonly __typename?: 'stop_registry_HslAccessibilityProperties',
          readonly id?: string | null,
          readonly stopAreaSideSlope?: number | null,
          readonly stopAreaLengthwiseSlope?: number | null,
          readonly endRampSlope?: number | null,
          readonly shelterLaneDistance?: number | null,
          readonly curbBackOfRailDistance?: number | null,
          readonly curbDriveSideOfRailDistance?: number | null,
          readonly structureLaneDistance?: number | null,
          readonly stopElevationFromRailTop?: number | null,
          readonly stopElevationFromSidewalk?: number | null,
          readonly lowerCleatHeight?: number | null,
          readonly serviceAreaWidth?: number | null,
          readonly serviceAreaLength?: number | null,
          readonly platformEdgeWarningArea?: boolean | null,
          readonly guidanceTiles?: boolean | null,
          readonly guidanceStripe?: boolean | null,
          readonly serviceAreaStripes?: boolean | null,
          readonly sidewalkAccessibleConnection?: boolean | null,
          readonly stopAreaSurroundingsAccessible?: boolean | null,
          readonly curvedStop?: boolean | null,
          readonly stopType?: StopRegistryStopType | null,
          readonly shelterType?: StopRegistryShelterWidthType | null,
          readonly guidanceType?: StopRegistryGuidanceType | null,
          readonly mapType?: StopRegistryMapType | null,
          readonly pedestrianCrossingRampType?: StopRegistryPedestrianCrossingRampType | null,
          readonly accessibilityLevel?: StopRegistryAccessibilityLevel | null
        } | null,
        readonly limitations?: {
          readonly __typename?: 'stop_registry_AccessibilityLimitations',
          readonly id?: string | null,
          readonly version?: string | null,
          readonly audibleSignalsAvailable?: StopRegistryLimitationStatusType | null,
          readonly escalatorFreeAccess?: StopRegistryLimitationStatusType | null,
          readonly liftFreeAccess?: StopRegistryLimitationStatusType | null,
          readonly stepFreeAccess?: StopRegistryLimitationStatusType | null,
          readonly wheelchairAccess?: StopRegistryLimitationStatusType | null
        } | null
      } | null,
      readonly topographicPlace?: {
        readonly __typename?: 'stop_registry_TopographicPlace',
        readonly id?: string | null,
        readonly name?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly value?: string | null,
          readonly lang?: string | null
        } | null
      } | null,
      readonly fareZones?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_FareZone',
        readonly id?: string | null,
        readonly name?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly value?: string | null,
          readonly lang?: string | null
        } | null
      } | null> | null
    } | null> | null
  } | null
};

export type ScheduledStopPointDetailFieldsFragment = {
  readonly __typename?: 'service_pattern_scheduled_stop_point',
  readonly priority: number,
  readonly direction: InfrastructureNetworkDirectionEnum,
  readonly scheduled_stop_point_id: UUID,
  readonly label: string,
  readonly timing_place_id?: UUID | null,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly located_on_infrastructure_link_id: UUID,
  readonly stop_place_ref?: string | null,
  readonly measured_location: GeoJSON.Point,
  readonly timing_place?: {
    readonly __typename?: 'timing_pattern_timing_place',
    readonly timing_place_id: UUID,
    readonly label: string
  } | null,
  readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
    readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
    readonly vehicle_mode: ReusableComponentsVehicleModeEnum
  }>
};

export type GetStopDetailsQueryVariables = Exact<{
  where?: InputMaybe<ServicePatternScheduledStopPointBoolExp>;
}>;


export type GetStopDetailsQuery = {
  readonly __typename?: 'query_root',
  readonly service_pattern_scheduled_stop_point: ReadonlyArray<{
    readonly __typename?: 'service_pattern_scheduled_stop_point',
    readonly priority: number,
    readonly direction: InfrastructureNetworkDirectionEnum,
    readonly scheduled_stop_point_id: UUID,
    readonly label: string,
    readonly timing_place_id?: UUID | null,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly located_on_infrastructure_link_id: UUID,
    readonly stop_place_ref?: string | null,
    readonly measured_location: GeoJSON.Point,
    readonly stop_place?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_ParentStopPlace'
    } | {
      readonly __typename?: 'stop_registry_StopPlace',
      readonly id?: string | null,
      readonly transportMode?: StopRegistryTransportModeType | null,
      readonly alternativeNames?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_AlternativeName',
        readonly nameType: StopRegistryNameType,
        readonly name: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        }
      } | null> | null,
      readonly privateCode?: {
        readonly __typename?: 'stop_registry_PrivateCode',
        readonly value?: string | null,
        readonly type?: string | null
      } | null,
      readonly name?: {
        readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
        readonly lang?: string | null,
        readonly value?: string | null
      } | null,
      readonly organisations?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_StopPlaceOrganisationRef',
        readonly relationshipType?: StopRegistryStopPlaceOrganisationRelationshipType | null,
        readonly organisationRef: string,
        readonly organisation?: {
          readonly __typename?: 'stop_registry_Organisation',
          readonly id?: string | null,
          readonly name?: string | null,
          readonly privateContactDetails?: {
            readonly __typename?: 'stop_registry_Contact',
            readonly id?: string | null,
            readonly email?: string | null,
            readonly phone?: string | null
          } | null
        } | null
      } | null> | null,
      readonly geometry?: {
        readonly __typename?: 'stop_registry_GeoJSON',
        readonly type?: StopRegistryGeoJsonType | null,
        readonly coordinates?: GeoJSON.Position | null
      } | null,
      readonly keyValues?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_KeyValues',
        readonly key?: string | null,
        readonly values?: ReadonlyArray<string | null> | null
      } | null> | null,
      readonly quays?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_Quay',
        readonly id?: string | null,
        readonly publicCode?: string | null,
        readonly privateCode?: {
          readonly __typename?: 'stop_registry_PrivateCode',
          readonly type?: string | null,
          readonly value?: string | null
        } | null,
        readonly description?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        } | null,
        readonly alternativeNames?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_AlternativeName',
          readonly nameType: StopRegistryNameType,
          readonly name: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly lang?: string | null,
            readonly value?: string | null
          }
        } | null> | null,
        readonly geometry?: {
          readonly __typename?: 'stop_registry_GeoJSON',
          readonly coordinates?: GeoJSON.Position | null,
          readonly type?: StopRegistryGeoJsonType | null
        } | null,
        readonly accessibilityAssessment?: {
          readonly __typename?: 'stop_registry_AccessibilityAssessment',
          readonly id?: string | null,
          readonly hslAccessibilityProperties?: {
            readonly __typename?: 'stop_registry_HslAccessibilityProperties',
            readonly id?: string | null,
            readonly stopAreaSideSlope?: number | null,
            readonly stopAreaLengthwiseSlope?: number | null,
            readonly endRampSlope?: number | null,
            readonly shelterLaneDistance?: number | null,
            readonly curbBackOfRailDistance?: number | null,
            readonly curbDriveSideOfRailDistance?: number | null,
            readonly structureLaneDistance?: number | null,
            readonly stopElevationFromRailTop?: number | null,
            readonly stopElevationFromSidewalk?: number | null,
            readonly lowerCleatHeight?: number | null,
            readonly serviceAreaWidth?: number | null,
            readonly serviceAreaLength?: number | null,
            readonly platformEdgeWarningArea?: boolean | null,
            readonly guidanceTiles?: boolean | null,
            readonly guidanceStripe?: boolean | null,
            readonly serviceAreaStripes?: boolean | null,
            readonly sidewalkAccessibleConnection?: boolean | null,
            readonly stopAreaSurroundingsAccessible?: boolean | null,
            readonly curvedStop?: boolean | null,
            readonly stopType?: StopRegistryStopType | null,
            readonly shelterType?: StopRegistryShelterWidthType | null,
            readonly guidanceType?: StopRegistryGuidanceType | null,
            readonly mapType?: StopRegistryMapType | null,
            readonly pedestrianCrossingRampType?: StopRegistryPedestrianCrossingRampType | null,
            readonly accessibilityLevel?: StopRegistryAccessibilityLevel | null
          } | null,
          readonly limitations?: {
            readonly __typename?: 'stop_registry_AccessibilityLimitations',
            readonly id?: string | null,
            readonly version?: string | null,
            readonly audibleSignalsAvailable?: StopRegistryLimitationStatusType | null,
            readonly escalatorFreeAccess?: StopRegistryLimitationStatusType | null,
            readonly liftFreeAccess?: StopRegistryLimitationStatusType | null,
            readonly stepFreeAccess?: StopRegistryLimitationStatusType | null,
            readonly wheelchairAccess?: StopRegistryLimitationStatusType | null
          } | null
        } | null,
        readonly keyValues?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_KeyValues',
          readonly key?: string | null,
          readonly values?: ReadonlyArray<string | null> | null
        } | null> | null,
        readonly infoSpots?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_infoSpot',
          readonly id?: string | null,
          readonly backlight?: boolean | null,
          readonly displayType?: StopRegistryDisplayType | null,
          readonly floor?: string | null,
          readonly label?: string | null,
          readonly width?: number | null,
          readonly height?: number | null,
          readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
          readonly infoSpotType?: StopRegistryInfoSpotType | null,
          readonly purpose?: string | null,
          readonly railInformation?: string | null,
          readonly speechProperty?: boolean | null,
          readonly zoneLabel?: string | null,
          readonly description?: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly lang?: string | null,
            readonly value?: string | null
          } | null,
          readonly poster?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_poster',
            readonly label?: string | null,
            readonly width?: number | null,
            readonly height?: number | null,
            readonly lines?: string | null
          } | null> | null
        } | null> | null,
        readonly placeEquipments?: {
          readonly __typename?: 'stop_registry_PlaceEquipments',
          readonly id?: string | null,
          readonly shelterEquipment?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_ShelterEquipment',
            readonly id?: string | null,
            readonly enclosed?: boolean | null,
            readonly stepFree?: boolean | null,
            readonly shelterNumber?: number | null,
            readonly shelterType?: StopRegistryShelterType | null,
            readonly shelterElectricity?: StopRegistryShelterElectricity | null,
            readonly shelterLighting?: boolean | null,
            readonly shelterCondition?: StopRegistryShelterCondition | null,
            readonly timetableCabinets?: number | null,
            readonly trashCan?: boolean | null,
            readonly shelterHasDisplay?: boolean | null,
            readonly bicycleParking?: boolean | null,
            readonly leaningRail?: boolean | null,
            readonly outsideBench?: boolean | null,
            readonly shelterFasciaBoardTaping?: boolean | null,
            readonly shelterExternalId?: string | null
          } | null> | null,
          readonly cycleStorageEquipment?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_CycleStorageEquipment',
            readonly cycleStorageType?: StopRegistryCycleStorageType | null
          } | null> | null,
          readonly generalSign?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_GeneralSign',
            readonly signContentType?: StopRegistrySignContentType | null,
            readonly numberOfFrames?: number | null,
            readonly lineSignage?: boolean | null,
            readonly mainLineSign?: boolean | null,
            readonly replacesRailSign?: boolean | null,
            readonly privateCode?: {
              readonly __typename?: 'stop_registry_PrivateCode',
              readonly value?: string | null,
              readonly type?: string | null
            } | null,
            readonly content?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly value?: string | null
            } | null,
            readonly note?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly lang?: string | null,
              readonly value?: string | null
            } | null
          } | null> | null
        } | null,
        readonly scheduled_stop_point?: {
          readonly __typename?: 'service_pattern_scheduled_stop_point',
          readonly priority: number,
          readonly direction: InfrastructureNetworkDirectionEnum,
          readonly scheduled_stop_point_id: UUID,
          readonly label: string,
          readonly timing_place_id?: UUID | null,
          readonly validity_start?: luxon.DateTime | null,
          readonly validity_end?: luxon.DateTime | null,
          readonly located_on_infrastructure_link_id: UUID,
          readonly stop_place_ref?: string | null,
          readonly measured_location: GeoJSON.Point,
          readonly timing_place?: {
            readonly __typename?: 'timing_pattern_timing_place',
            readonly timing_place_id: UUID,
            readonly label: string
          } | null,
          readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
            readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
            readonly vehicle_mode: ReusableComponentsVehicleModeEnum
          }>
        } | null,
        readonly externalLinks?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_externalLink',
          readonly quayId?: number | null,
          readonly orderNum?: number | null,
          readonly name?: string | null,
          readonly location?: string | null
        } | null> | null
      } | null> | null,
      readonly parentStopPlace?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_ParentStopPlace',
        readonly id?: string | null,
        readonly name?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly lang?: string | null,
          readonly value?: string | null
        } | null,
        readonly privateCode?: {
          readonly __typename?: 'stop_registry_PrivateCode',
          readonly value?: string | null,
          readonly type?: string | null
        } | null,
        readonly children?: ReadonlyArray<{
          readonly __typename?: 'stop_registry_StopPlace',
          readonly id?: string | null,
          readonly name?: {
            readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
            readonly value?: string | null
          } | null,
          readonly privateCode?: {
            readonly __typename?: 'stop_registry_PrivateCode',
            readonly value?: string | null
          } | null,
          readonly quays?: ReadonlyArray<{
            readonly __typename?: 'stop_registry_Quay',
            readonly id?: string | null,
            readonly publicCode?: string | null,
            readonly description?: {
              readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
              readonly lang?: string | null,
              readonly value?: string | null
            } | null,
            readonly scheduled_stop_point?: {
              readonly __typename?: 'service_pattern_scheduled_stop_point',
              readonly priority: number,
              readonly direction: InfrastructureNetworkDirectionEnum,
              readonly scheduled_stop_point_id: UUID,
              readonly label: string,
              readonly timing_place_id?: UUID | null,
              readonly validity_start?: luxon.DateTime | null,
              readonly validity_end?: luxon.DateTime | null,
              readonly located_on_infrastructure_link_id: UUID,
              readonly stop_place_ref?: string | null,
              readonly measured_location: GeoJSON.Point,
              readonly timing_place?: {
                readonly __typename?: 'timing_pattern_timing_place',
                readonly timing_place_id: UUID,
                readonly label: string
              } | null,
              readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
                readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
                readonly vehicle_mode: ReusableComponentsVehicleModeEnum
              }>
            } | null,
            readonly keyValues?: ReadonlyArray<{
              readonly __typename?: 'stop_registry_KeyValues',
              readonly key?: string | null,
              readonly values?: ReadonlyArray<string | null> | null
            } | null> | null,
            readonly infoSpots?: ReadonlyArray<{
              readonly __typename?: 'stop_registry_infoSpot',
              readonly id?: string | null,
              readonly backlight?: boolean | null,
              readonly displayType?: StopRegistryDisplayType | null,
              readonly floor?: string | null,
              readonly label?: string | null,
              readonly width?: number | null,
              readonly height?: number | null,
              readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
              readonly infoSpotType?: StopRegistryInfoSpotType | null,
              readonly purpose?: string | null,
              readonly railInformation?: string | null,
              readonly speechProperty?: boolean | null,
              readonly zoneLabel?: string | null,
              readonly description?: {
                readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
                readonly lang?: string | null,
                readonly value?: string | null
              } | null,
              readonly poster?: ReadonlyArray<{
                readonly __typename?: 'stop_registry_poster',
                readonly label?: string | null,
                readonly width?: number | null,
                readonly height?: number | null,
                readonly lines?: string | null
              } | null> | null
            } | null> | null,
            readonly placeEquipments?: {
              readonly __typename?: 'stop_registry_PlaceEquipments',
              readonly id?: string | null,
              readonly generalSign?: ReadonlyArray<{
                readonly __typename?: 'stop_registry_GeneralSign',
                readonly id?: string | null,
                readonly content?: {
                  readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
                  readonly value?: string | null
                } | null
              } | null> | null,
              readonly shelterEquipment?: ReadonlyArray<{
                readonly __typename?: 'stop_registry_ShelterEquipment',
                readonly id?: string | null,
                readonly shelterNumber?: number | null
              } | null> | null
            } | null
          } | null> | null
        } | null> | null
      } | {
        readonly __typename?: 'stop_registry_StopPlace'
      } | null> | null,
      readonly accessibilityAssessment?: {
        readonly __typename?: 'stop_registry_AccessibilityAssessment',
        readonly id?: string | null,
        readonly hslAccessibilityProperties?: {
          readonly __typename?: 'stop_registry_HslAccessibilityProperties',
          readonly id?: string | null,
          readonly stopAreaSideSlope?: number | null,
          readonly stopAreaLengthwiseSlope?: number | null,
          readonly endRampSlope?: number | null,
          readonly shelterLaneDistance?: number | null,
          readonly curbBackOfRailDistance?: number | null,
          readonly curbDriveSideOfRailDistance?: number | null,
          readonly structureLaneDistance?: number | null,
          readonly stopElevationFromRailTop?: number | null,
          readonly stopElevationFromSidewalk?: number | null,
          readonly lowerCleatHeight?: number | null,
          readonly serviceAreaWidth?: number | null,
          readonly serviceAreaLength?: number | null,
          readonly platformEdgeWarningArea?: boolean | null,
          readonly guidanceTiles?: boolean | null,
          readonly guidanceStripe?: boolean | null,
          readonly serviceAreaStripes?: boolean | null,
          readonly sidewalkAccessibleConnection?: boolean | null,
          readonly stopAreaSurroundingsAccessible?: boolean | null,
          readonly curvedStop?: boolean | null,
          readonly stopType?: StopRegistryStopType | null,
          readonly shelterType?: StopRegistryShelterWidthType | null,
          readonly guidanceType?: StopRegistryGuidanceType | null,
          readonly mapType?: StopRegistryMapType | null,
          readonly pedestrianCrossingRampType?: StopRegistryPedestrianCrossingRampType | null,
          readonly accessibilityLevel?: StopRegistryAccessibilityLevel | null
        } | null,
        readonly limitations?: {
          readonly __typename?: 'stop_registry_AccessibilityLimitations',
          readonly id?: string | null,
          readonly version?: string | null,
          readonly audibleSignalsAvailable?: StopRegistryLimitationStatusType | null,
          readonly escalatorFreeAccess?: StopRegistryLimitationStatusType | null,
          readonly liftFreeAccess?: StopRegistryLimitationStatusType | null,
          readonly stepFreeAccess?: StopRegistryLimitationStatusType | null,
          readonly wheelchairAccess?: StopRegistryLimitationStatusType | null
        } | null
      } | null,
      readonly topographicPlace?: {
        readonly __typename?: 'stop_registry_TopographicPlace',
        readonly id?: string | null,
        readonly name?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly value?: string | null,
          readonly lang?: string | null
        } | null
      } | null,
      readonly fareZones?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_FareZone',
        readonly id?: string | null,
        readonly name?: {
          readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
          readonly value?: string | null,
          readonly lang?: string | null
        } | null
      } | null> | null
    } | null> | null,
    readonly timing_place?: {
      readonly __typename?: 'timing_pattern_timing_place',
      readonly timing_place_id: UUID,
      readonly label: string
    } | null,
    readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
      readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
      readonly vehicle_mode: ReusableComponentsVehicleModeEnum
    }>
  }>
};

export type ShelterEquipmentDetailsFragment = {
  readonly __typename?: 'stop_registry_ShelterEquipment',
  readonly id?: string | null,
  readonly enclosed?: boolean | null,
  readonly stepFree?: boolean | null,
  readonly shelterNumber?: number | null,
  readonly shelterType?: StopRegistryShelterType | null,
  readonly shelterElectricity?: StopRegistryShelterElectricity | null,
  readonly shelterLighting?: boolean | null,
  readonly shelterCondition?: StopRegistryShelterCondition | null,
  readonly timetableCabinets?: number | null,
  readonly trashCan?: boolean | null,
  readonly shelterHasDisplay?: boolean | null,
  readonly bicycleParking?: boolean | null,
  readonly leaningRail?: boolean | null,
  readonly outsideBench?: boolean | null,
  readonly shelterFasciaBoardTaping?: boolean | null,
  readonly shelterExternalId?: string | null
};

export type AccessibilityAssessmentDetailsFragment = {
  readonly __typename?: 'stop_registry_AccessibilityAssessment',
  readonly id?: string | null,
  readonly hslAccessibilityProperties?: {
    readonly __typename?: 'stop_registry_HslAccessibilityProperties',
    readonly id?: string | null,
    readonly stopAreaSideSlope?: number | null,
    readonly stopAreaLengthwiseSlope?: number | null,
    readonly endRampSlope?: number | null,
    readonly shelterLaneDistance?: number | null,
    readonly curbBackOfRailDistance?: number | null,
    readonly curbDriveSideOfRailDistance?: number | null,
    readonly structureLaneDistance?: number | null,
    readonly stopElevationFromRailTop?: number | null,
    readonly stopElevationFromSidewalk?: number | null,
    readonly lowerCleatHeight?: number | null,
    readonly serviceAreaWidth?: number | null,
    readonly serviceAreaLength?: number | null,
    readonly platformEdgeWarningArea?: boolean | null,
    readonly guidanceTiles?: boolean | null,
    readonly guidanceStripe?: boolean | null,
    readonly serviceAreaStripes?: boolean | null,
    readonly sidewalkAccessibleConnection?: boolean | null,
    readonly stopAreaSurroundingsAccessible?: boolean | null,
    readonly curvedStop?: boolean | null,
    readonly stopType?: StopRegistryStopType | null,
    readonly shelterType?: StopRegistryShelterWidthType | null,
    readonly guidanceType?: StopRegistryGuidanceType | null,
    readonly mapType?: StopRegistryMapType | null,
    readonly pedestrianCrossingRampType?: StopRegistryPedestrianCrossingRampType | null,
    readonly accessibilityLevel?: StopRegistryAccessibilityLevel | null
  } | null,
  readonly limitations?: {
    readonly __typename?: 'stop_registry_AccessibilityLimitations',
    readonly id?: string | null,
    readonly version?: string | null,
    readonly audibleSignalsAvailable?: StopRegistryLimitationStatusType | null,
    readonly escalatorFreeAccess?: StopRegistryLimitationStatusType | null,
    readonly liftFreeAccess?: StopRegistryLimitationStatusType | null,
    readonly stepFreeAccess?: StopRegistryLimitationStatusType | null,
    readonly wheelchairAccess?: StopRegistryLimitationStatusType | null
  } | null
};

export type QuayDetailsFragment = {
  readonly __typename?: 'stop_registry_Quay',
  readonly id?: string | null,
  readonly publicCode?: string | null,
  readonly privateCode?: {
    readonly __typename?: 'stop_registry_PrivateCode',
    readonly type?: string | null,
    readonly value?: string | null
  } | null,
  readonly description?: {
    readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
    readonly lang?: string | null,
    readonly value?: string | null
  } | null,
  readonly alternativeNames?: ReadonlyArray<{
    readonly __typename?: 'stop_registry_AlternativeName',
    readonly nameType: StopRegistryNameType,
    readonly name: {
      readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
      readonly lang?: string | null,
      readonly value?: string | null
    }
  } | null> | null,
  readonly geometry?: {
    readonly __typename?: 'stop_registry_GeoJSON',
    readonly coordinates?: GeoJSON.Position | null,
    readonly type?: StopRegistryGeoJsonType | null
  } | null,
  readonly accessibilityAssessment?: {
    readonly __typename?: 'stop_registry_AccessibilityAssessment',
    readonly id?: string | null,
    readonly hslAccessibilityProperties?: {
      readonly __typename?: 'stop_registry_HslAccessibilityProperties',
      readonly id?: string | null,
      readonly stopAreaSideSlope?: number | null,
      readonly stopAreaLengthwiseSlope?: number | null,
      readonly endRampSlope?: number | null,
      readonly shelterLaneDistance?: number | null,
      readonly curbBackOfRailDistance?: number | null,
      readonly curbDriveSideOfRailDistance?: number | null,
      readonly structureLaneDistance?: number | null,
      readonly stopElevationFromRailTop?: number | null,
      readonly stopElevationFromSidewalk?: number | null,
      readonly lowerCleatHeight?: number | null,
      readonly serviceAreaWidth?: number | null,
      readonly serviceAreaLength?: number | null,
      readonly platformEdgeWarningArea?: boolean | null,
      readonly guidanceTiles?: boolean | null,
      readonly guidanceStripe?: boolean | null,
      readonly serviceAreaStripes?: boolean | null,
      readonly sidewalkAccessibleConnection?: boolean | null,
      readonly stopAreaSurroundingsAccessible?: boolean | null,
      readonly curvedStop?: boolean | null,
      readonly stopType?: StopRegistryStopType | null,
      readonly shelterType?: StopRegistryShelterWidthType | null,
      readonly guidanceType?: StopRegistryGuidanceType | null,
      readonly mapType?: StopRegistryMapType | null,
      readonly pedestrianCrossingRampType?: StopRegistryPedestrianCrossingRampType | null,
      readonly accessibilityLevel?: StopRegistryAccessibilityLevel | null
    } | null,
    readonly limitations?: {
      readonly __typename?: 'stop_registry_AccessibilityLimitations',
      readonly id?: string | null,
      readonly version?: string | null,
      readonly audibleSignalsAvailable?: StopRegistryLimitationStatusType | null,
      readonly escalatorFreeAccess?: StopRegistryLimitationStatusType | null,
      readonly liftFreeAccess?: StopRegistryLimitationStatusType | null,
      readonly stepFreeAccess?: StopRegistryLimitationStatusType | null,
      readonly wheelchairAccess?: StopRegistryLimitationStatusType | null
    } | null
  } | null,
  readonly keyValues?: ReadonlyArray<{
    readonly __typename?: 'stop_registry_KeyValues',
    readonly key?: string | null,
    readonly values?: ReadonlyArray<string | null> | null
  } | null> | null,
  readonly infoSpots?: ReadonlyArray<{
    readonly __typename?: 'stop_registry_infoSpot',
    readonly id?: string | null,
    readonly backlight?: boolean | null,
    readonly displayType?: StopRegistryDisplayType | null,
    readonly floor?: string | null,
    readonly label?: string | null,
    readonly width?: number | null,
    readonly height?: number | null,
    readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
    readonly infoSpotType?: StopRegistryInfoSpotType | null,
    readonly purpose?: string | null,
    readonly railInformation?: string | null,
    readonly speechProperty?: boolean | null,
    readonly zoneLabel?: string | null,
    readonly description?: {
      readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
      readonly lang?: string | null,
      readonly value?: string | null
    } | null,
    readonly poster?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_poster',
      readonly label?: string | null,
      readonly width?: number | null,
      readonly height?: number | null,
      readonly lines?: string | null
    } | null> | null
  } | null> | null,
  readonly placeEquipments?: {
    readonly __typename?: 'stop_registry_PlaceEquipments',
    readonly id?: string | null,
    readonly shelterEquipment?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_ShelterEquipment',
      readonly id?: string | null,
      readonly enclosed?: boolean | null,
      readonly stepFree?: boolean | null,
      readonly shelterNumber?: number | null,
      readonly shelterType?: StopRegistryShelterType | null,
      readonly shelterElectricity?: StopRegistryShelterElectricity | null,
      readonly shelterLighting?: boolean | null,
      readonly shelterCondition?: StopRegistryShelterCondition | null,
      readonly timetableCabinets?: number | null,
      readonly trashCan?: boolean | null,
      readonly shelterHasDisplay?: boolean | null,
      readonly bicycleParking?: boolean | null,
      readonly leaningRail?: boolean | null,
      readonly outsideBench?: boolean | null,
      readonly shelterFasciaBoardTaping?: boolean | null,
      readonly shelterExternalId?: string | null
    } | null> | null,
    readonly cycleStorageEquipment?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_CycleStorageEquipment',
      readonly cycleStorageType?: StopRegistryCycleStorageType | null
    } | null> | null,
    readonly generalSign?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_GeneralSign',
      readonly signContentType?: StopRegistrySignContentType | null,
      readonly numberOfFrames?: number | null,
      readonly lineSignage?: boolean | null,
      readonly mainLineSign?: boolean | null,
      readonly replacesRailSign?: boolean | null,
      readonly privateCode?: {
        readonly __typename?: 'stop_registry_PrivateCode',
        readonly value?: string | null,
        readonly type?: string | null
      } | null,
      readonly content?: {
        readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
        readonly value?: string | null
      } | null,
      readonly note?: {
        readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
        readonly lang?: string | null,
        readonly value?: string | null
      } | null
    } | null> | null
  } | null,
  readonly scheduled_stop_point?: {
    readonly __typename?: 'service_pattern_scheduled_stop_point',
    readonly priority: number,
    readonly direction: InfrastructureNetworkDirectionEnum,
    readonly scheduled_stop_point_id: UUID,
    readonly label: string,
    readonly timing_place_id?: UUID | null,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly located_on_infrastructure_link_id: UUID,
    readonly stop_place_ref?: string | null,
    readonly measured_location: GeoJSON.Point,
    readonly timing_place?: {
      readonly __typename?: 'timing_pattern_timing_place',
      readonly timing_place_id: UUID,
      readonly label: string
    } | null,
    readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
      readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
      readonly vehicle_mode: ReusableComponentsVehicleModeEnum
    }>
  } | null,
  readonly externalLinks?: ReadonlyArray<{
    readonly __typename?: 'stop_registry_externalLink',
    readonly quayId?: number | null,
    readonly orderNum?: number | null,
    readonly name?: string | null,
    readonly location?: string | null
  } | null> | null
};

export type ExternalLinksDetailsFragment = {
  readonly __typename?: 'stop_registry_externalLink',
  readonly quayId?: number | null,
  readonly orderNum?: number | null,
  readonly name?: string | null,
  readonly location?: string | null
};

export type TopographicPlaceDetailsFragment = {
  readonly __typename?: 'stop_registry_TopographicPlace',
  readonly id?: string | null,
  readonly name?: {
    readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
    readonly value?: string | null,
    readonly lang?: string | null
  } | null
};

export type FareZoneDetailsFragment = {
  readonly __typename?: 'stop_registry_FareZone',
  readonly id?: string | null,
  readonly name?: {
    readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
    readonly value?: string | null,
    readonly lang?: string | null
  } | null
};

export type HslAccessibilityPropertiesDetailsFragment = {
  readonly __typename?: 'stop_registry_HslAccessibilityProperties',
  readonly id?: string | null,
  readonly stopAreaSideSlope?: number | null,
  readonly stopAreaLengthwiseSlope?: number | null,
  readonly endRampSlope?: number | null,
  readonly shelterLaneDistance?: number | null,
  readonly curbBackOfRailDistance?: number | null,
  readonly curbDriveSideOfRailDistance?: number | null,
  readonly structureLaneDistance?: number | null,
  readonly stopElevationFromRailTop?: number | null,
  readonly stopElevationFromSidewalk?: number | null,
  readonly lowerCleatHeight?: number | null,
  readonly serviceAreaWidth?: number | null,
  readonly serviceAreaLength?: number | null,
  readonly platformEdgeWarningArea?: boolean | null,
  readonly guidanceTiles?: boolean | null,
  readonly guidanceStripe?: boolean | null,
  readonly serviceAreaStripes?: boolean | null,
  readonly sidewalkAccessibleConnection?: boolean | null,
  readonly stopAreaSurroundingsAccessible?: boolean | null,
  readonly curvedStop?: boolean | null,
  readonly stopType?: StopRegistryStopType | null,
  readonly shelterType?: StopRegistryShelterWidthType | null,
  readonly guidanceType?: StopRegistryGuidanceType | null,
  readonly mapType?: StopRegistryMapType | null,
  readonly pedestrianCrossingRampType?: StopRegistryPedestrianCrossingRampType | null,
  readonly accessibilityLevel?: StopRegistryAccessibilityLevel | null
};

export type StopPlaceOrganisationFieldsFragment = {
  readonly __typename?: 'stop_registry_Organisation',
  readonly id?: string | null,
  readonly name?: string | null,
  readonly privateContactDetails?: {
    readonly __typename?: 'stop_registry_Contact',
    readonly id?: string | null,
    readonly email?: string | null,
    readonly phone?: string | null
  } | null
};

export type InfoSpotDetailsFragment = {
  readonly __typename?: 'stop_registry_infoSpot',
  readonly id?: string | null,
  readonly backlight?: boolean | null,
  readonly displayType?: StopRegistryDisplayType | null,
  readonly floor?: string | null,
  readonly label?: string | null,
  readonly width?: number | null,
  readonly height?: number | null,
  readonly infoSpotLocations?: ReadonlyArray<string | null> | null,
  readonly infoSpotType?: StopRegistryInfoSpotType | null,
  readonly purpose?: string | null,
  readonly railInformation?: string | null,
  readonly speechProperty?: boolean | null,
  readonly zoneLabel?: string | null,
  readonly description?: {
    readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
    readonly lang?: string | null,
    readonly value?: string | null
  } | null,
  readonly poster?: ReadonlyArray<{
    readonly __typename?: 'stop_registry_poster',
    readonly label?: string | null,
    readonly width?: number | null,
    readonly height?: number | null,
    readonly lines?: string | null
  } | null> | null
};

export type UpsertOrganisationMutationVariables = Exact<{
  objects?: InputMaybe<ReadonlyArray<InputMaybe<StopRegistryOrganisationInput>> | InputMaybe<StopRegistryOrganisationInput>>;
}>;


export type UpsertOrganisationMutation = {
  readonly __typename?: 'mutation_root',
  readonly stop_registry?: {
    readonly __typename?: 'stop_registryStopPlaceMutation',
    readonly mutateOrganisation?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_Organisation',
      readonly id?: string | null
    } | null> | null
  } | null
};

export type PatchScheduledStopPointTimingSettingsMutationVariables = Exact<{
  stopLabel: Scalars['String']['input'];
  journeyPatternId: Scalars['uuid']['input'];
  sequence: Scalars['Int']['input'];
  patch: JourneyPatternScheduledStopPointInJourneyPatternSetInput;
  stopId: Scalars['uuid']['input'];
  timingPlaceId?: InputMaybe<Scalars['uuid']['input']>;
}>;


export type PatchScheduledStopPointTimingSettingsMutation = {
  readonly __typename?: 'mutation_root',
  readonly update_service_pattern_scheduled_stop_point?: {
    readonly __typename?: 'service_pattern_scheduled_stop_point_mutation_response',
    readonly returning: ReadonlyArray<{
      readonly __typename?: 'service_pattern_scheduled_stop_point',
      readonly scheduled_stop_point_id: UUID,
      readonly timing_place_id?: UUID | null,
      readonly timing_place?: {
        readonly __typename?: 'timing_pattern_timing_place',
        readonly timing_place_id: UUID
      } | null
    }>
  } | null,
  readonly update_journey_pattern_scheduled_stop_point_in_journey_pattern?: {
    readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_mutation_response',
    readonly returning: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly scheduled_stop_point_label: string,
      readonly scheduled_stop_point_sequence: number,
      readonly is_used_as_timing_point: boolean,
      readonly is_regulated_timing_point: boolean,
      readonly is_loading_time_allowed: boolean,
      readonly is_via_point: boolean,
      readonly via_point_name_i18n?: LocalizedString | null,
      readonly via_point_short_name_i18n?: LocalizedString | null,
      readonly journey_pattern: {
        readonly __typename?: 'journey_pattern_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly on_route_id: UUID
      }
    }>
  } | null
};

export type InsertStopPointMutationVariables = Exact<{
  stopPoint: ServicePatternScheduledStopPointInsertInput;
}>;


export type InsertStopPointMutation = {
  readonly __typename?: 'mutation_root',
  readonly stopPoint?: {
    readonly __typename?: 'service_pattern_scheduled_stop_point',
    readonly scheduled_stop_point_id: UUID,
    readonly located_on_infrastructure_link_id: UUID,
    readonly direction: InfrastructureNetworkDirectionEnum,
    readonly priority: number,
    readonly measured_location: GeoJSON.Point,
    readonly label: string,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly stop_place_ref?: string | null
  } | null
};

export type GetRoutesBrokenByStopChangeQueryVariables = Exact<{
  new_located_on_infrastructure_link_id: Scalars['uuid']['input'];
  new_direction: Scalars['String']['input'];
  new_label: Scalars['String']['input'];
  new_validity_start?: InputMaybe<Scalars['date']['input']>;
  new_validity_end?: InputMaybe<Scalars['date']['input']>;
  new_priority: Scalars['Int']['input'];
  new_measured_location: Scalars['geography']['input'];
  replace_scheduled_stop_point_id?: InputMaybe<Scalars['uuid']['input']>;
}>;


export type GetRoutesBrokenByStopChangeQuery = {
  readonly __typename?: 'query_root',
  readonly journey_pattern_check_infra_link_stop_refs_with_new_scheduled_stop_point: ReadonlyArray<{
    readonly __typename?: 'journey_pattern_journey_pattern',
    readonly journey_pattern_id: UUID,
    readonly journey_pattern_route?: {
      readonly __typename?: 'route_route',
      readonly route_shape?: GeoJSON.LineString | null,
      readonly name_i18n: LocalizedString,
      readonly description_i18n?: LocalizedString | null,
      readonly origin_name_i18n: LocalizedString,
      readonly origin_short_name_i18n: LocalizedString,
      readonly destination_name_i18n: LocalizedString,
      readonly destination_short_name_i18n: LocalizedString,
      readonly on_line_id: UUID,
      readonly label: string,
      readonly direction: RouteDirectionEnum,
      readonly variant?: number | null,
      readonly route_id: UUID,
      readonly validity_start?: luxon.DateTime | null,
      readonly validity_end?: luxon.DateTime | null,
      readonly priority: number
    } | null
  }>
};

export type EditStopMutationVariables = Exact<{
  stop_id: Scalars['uuid']['input'];
  stop_label: Scalars['String']['input'];
  stop_patch: ServicePatternScheduledStopPointSetInput;
  delete_from_journey_pattern_ids: ReadonlyArray<Scalars['uuid']['input']> | Scalars['uuid']['input'];
}>;


export type EditStopMutation = {
  readonly __typename?: 'mutation_root',
  readonly update_service_pattern_scheduled_stop_point?: {
    readonly __typename?: 'service_pattern_scheduled_stop_point_mutation_response',
    readonly returning: ReadonlyArray<{
      readonly __typename?: 'service_pattern_scheduled_stop_point',
      readonly measured_location: GeoJSON.Point,
      readonly relative_distance_from_infrastructure_link_start: number,
      readonly closest_point_on_infrastructure_link?: GeoJSON.Point | null,
      readonly priority: number,
      readonly direction: InfrastructureNetworkDirectionEnum,
      readonly scheduled_stop_point_id: UUID,
      readonly label: string,
      readonly timing_place_id?: UUID | null,
      readonly validity_start?: luxon.DateTime | null,
      readonly validity_end?: luxon.DateTime | null,
      readonly located_on_infrastructure_link_id: UUID,
      readonly stop_place_ref?: string | null,
      readonly vehicle_mode_on_scheduled_stop_point: ReadonlyArray<{
        readonly __typename?: 'service_pattern_vehicle_mode_on_scheduled_stop_point',
        readonly vehicle_mode: ReusableComponentsVehicleModeEnum
      }>,
      readonly timing_place?: {
        readonly __typename?: 'timing_pattern_timing_place',
        readonly timing_place_id: UUID,
        readonly label: string
      } | null
    }>
  } | null,
  readonly delete_journey_pattern_scheduled_stop_point_in_journey_pattern?: {
    readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern_mutation_response',
    readonly returning: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly scheduled_stop_point_label: string,
      readonly scheduled_stop_point_sequence: number,
      readonly is_used_as_timing_point: boolean,
      readonly is_regulated_timing_point: boolean,
      readonly is_loading_time_allowed: boolean,
      readonly is_via_point: boolean,
      readonly via_point_name_i18n?: LocalizedString | null,
      readonly via_point_short_name_i18n?: LocalizedString | null,
      readonly journey_pattern: {
        readonly __typename?: 'journey_pattern_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly on_route_id: UUID
      }
    }>
  } | null
};

export type EditStopPlaceMutationVariables = Exact<{
  patch?: InputMaybe<StopRegistryStopPlaceInput>;
}>;


export type EditStopPlaceMutation = {
  readonly __typename?: 'mutation_root',
  readonly stop_registry?: {
    readonly __typename?: 'stop_registryStopPlaceMutation',
    readonly mutateStopPlace?: ReadonlyArray<{
      readonly __typename?: 'stop_registry_StopPlace',
      readonly id?: string | null,
      readonly version?: string | null,
      readonly name?: {
        readonly __typename?: 'stop_registry_EmbeddableMultilingualString',
        readonly value?: string | null
      } | null,
      readonly geometry?: {
        readonly __typename?: 'stop_registry_GeoJSON',
        readonly coordinates?: GeoJSON.Position | null
      } | null,
      readonly keyValues?: ReadonlyArray<{
        readonly __typename?: 'stop_registry_KeyValues',
        readonly key?: string | null,
        readonly values?: ReadonlyArray<string | null> | null
      } | null> | null
    } | null> | null
  } | null
};

export type GetQuayMaxPrivateCodeQueryVariables = Exact<{ [key: string]: never; }>;


export type GetQuayMaxPrivateCodeQuery = {
  readonly __typename?: 'query_root',
  readonly stops_database?: {
    readonly __typename?: 'stops_database_stops_database_query',
    readonly stops_database_quay_aggregate: {
      readonly __typename?: 'stops_database_quay_aggregate',
      readonly aggregate?: {
        readonly __typename?: 'stops_database_quay_aggregate_fields',
        readonly max?: {
          readonly __typename?: 'stops_database_quay_max_fields',
          readonly private_code_value?: string | null
        } | null
      } | null
    }
  } | null
};

export type GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQueryVariables = Exact<{
  label: Scalars['String']['input'];
}>;


export type GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery = {
  readonly __typename?: 'query_root',
  readonly journey_pattern_scheduled_stop_point_in_journey_pattern: ReadonlyArray<{
    readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
    readonly journey_pattern_id: UUID,
    readonly scheduled_stop_point_label: string,
    readonly scheduled_stop_point_sequence: number,
    readonly journey_pattern: {
      readonly __typename?: 'journey_pattern_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly on_route_id: UUID,
      readonly journey_pattern_route?: {
        readonly __typename?: 'route_route',
        readonly route_id: UUID,
        readonly label: string,
        readonly variant?: number | null
      } | null
    }
  }>
};

export type CreateSubstituteOperatingPeriodMutationVariables = Exact<{
  data: ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingPeriodInsertInput> | TimetablesServiceCalendarSubstituteOperatingPeriodInsertInput;
}>;


export type CreateSubstituteOperatingPeriodMutation = {
  readonly __typename?: 'mutation_root',
  readonly timetables?: {
    readonly __typename?: 'timetables_timetables_mutation_frontend',
    readonly timetables_insert_service_calendar_substitute_operating_period?: {
      readonly __typename?: 'timetables_service_calendar_substitute_operating_period_mutation_response',
      readonly returning: ReadonlyArray<{
        readonly __typename?: 'timetables_service_calendar_substitute_operating_period',
        readonly substitute_operating_period_id: UUID,
        readonly period_name: string,
        readonly is_preset: boolean,
        readonly substitute_operating_day_by_line_types: ReadonlyArray<{
          readonly __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type',
          readonly begin_time?: luxon.Duration | null,
          readonly end_time?: luxon.Duration | null,
          readonly substitute_day_of_week?: number | null,
          readonly substitute_operating_day_by_line_type_id: UUID,
          readonly superseded_date: luxon.DateTime,
          readonly type_of_line: string
        }>
      }>
    } | null
  } | null
};

export type DeleteSubstituteOperatingPeriodMutationVariables = Exact<{
  ids: ReadonlyArray<Scalars['uuid']['input']> | Scalars['uuid']['input'];
}>;


export type DeleteSubstituteOperatingPeriodMutation = {
  readonly __typename?: 'mutation_root',
  readonly timetables?: {
    readonly __typename?: 'timetables_timetables_mutation_frontend',
    readonly timetables_delete_service_calendar_substitute_operating_period?: {
      readonly __typename?: 'timetables_service_calendar_substitute_operating_period_mutation_response',
      readonly affected_rows: number
    } | null
  } | null
};

export type EditSubstituteOperatingPeriodsMutationVariables = Exact<{
  periodsToInsert: ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingPeriodInsertInput> | TimetablesServiceCalendarSubstituteOperatingPeriodInsertInput;
  periodsToDelete: ReadonlyArray<Scalars['uuid']['input']> | Scalars['uuid']['input'];
  daysToInsert: ReadonlyArray<TimetablesServiceCalendarSubstituteOperatingDayByLineTypeInsertInput> | TimetablesServiceCalendarSubstituteOperatingDayByLineTypeInsertInput;
}>;


export type EditSubstituteOperatingPeriodsMutation = {
  readonly __typename?: 'mutation_root',
  readonly timetables?: {
    readonly __typename?: 'timetables_timetables_mutation_frontend',
    readonly timetables_insert_service_calendar_substitute_operating_period?: {
      readonly __typename?: 'timetables_service_calendar_substitute_operating_period_mutation_response',
      readonly affected_rows: number
    } | null,
    readonly timetables_delete_service_calendar_substitute_operating_day_by_line_type?: {
      readonly __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_mutation_response',
      readonly affected_rows: number
    } | null,
    readonly timetables_insert_service_calendar_substitute_operating_day_by_line_type?: {
      readonly __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type_mutation_response',
      readonly affected_rows: number
    } | null
  } | null
};

export type GetSubstituteOperatingPeriodsQueryVariables = Exact<{
  periodFilters?: InputMaybe<TimetablesServiceCalendarSubstituteOperatingPeriodBoolExp>;
}>;


export type GetSubstituteOperatingPeriodsQuery = {
  readonly __typename?: 'query_root',
  readonly timetables?: {
    readonly __typename?: 'timetables_timetables_query',
    readonly timetables_service_calendar_substitute_operating_period: ReadonlyArray<{
      readonly __typename?: 'timetables_service_calendar_substitute_operating_period',
      readonly period_name: string,
      readonly is_preset: boolean,
      readonly substitute_operating_period_id: UUID,
      readonly substitute_operating_day_by_line_types: ReadonlyArray<{
        readonly __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type',
        readonly begin_time?: luxon.Duration | null,
        readonly end_time?: luxon.Duration | null,
        readonly substitute_day_of_week?: number | null,
        readonly substitute_operating_day_by_line_type_id: UUID,
        readonly superseded_date: luxon.DateTime,
        readonly type_of_line: string
      }>
    }>
  } | null
};

export type GetToCombineTargetVehicleScheduleFrameIdQueryVariables = Exact<{
  arg1: ToCombineTargetVehicleScheduleFrameIdInput;
}>;


export type GetToCombineTargetVehicleScheduleFrameIdQuery = {
  readonly __typename?: 'query_root',
  readonly toCombineTargetVehicleScheduleFrameId?: {
    readonly __typename?: 'ToCombineTargetVehicleScheduleFrameIdOutput',
    readonly toCombineTargetVehicleScheduleFrameId: UUID
  } | null
};

export type GetToReplaceVehicleScheduleFramesQueryVariables = Exact<{
  arg1: ToReplaceVehicleScheduleFrameIdsInput;
}>;


export type GetToReplaceVehicleScheduleFramesQuery = {
  readonly __typename?: 'query_root',
  readonly toReplaceVehicleScheduleFrameIds?: {
    readonly __typename?: 'ToReplaceVehicleScheduleFrameIdsOutput',
    readonly toReplaceVehicleScheduleFrameIds: ReadonlyArray<UUID | null>
  } | null
};

export type VehicleJourneyWithPatternAndRouteFragmentFragment = {
  readonly __typename?: 'timetables_vehicle_journey_vehicle_journey',
  readonly vehicle_journey_id: UUID,
  readonly start_time: luxon.Duration,
  readonly contract_number: string,
  readonly journey_pattern_ref: {
    readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref',
    readonly journey_pattern_ref_id: UUID,
    readonly journey_pattern_instance?: {
      readonly __typename?: 'journey_pattern_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly journey_pattern_route?: {
        readonly __typename?: 'route_route',
        readonly route_id: UUID,
        readonly unique_label: string,
        readonly direction: RouteDirectionEnum,
        readonly variant?: number | null,
        readonly name_i18n: LocalizedString,
        readonly route_line: {
          readonly __typename?: 'route_line',
          readonly line_id: UUID
        }
      } | null
    } | null
  }
};

export type GetVehicleScheduleFrameWithJourneyInfoQueryVariables = Exact<{
  vehicle_schedule_frame_ids: ReadonlyArray<Scalars['uuid']['input']> | Scalars['uuid']['input'];
}>;


export type GetVehicleScheduleFrameWithJourneyInfoQuery = {
  readonly __typename?: 'query_root',
  readonly timetables?: {
    readonly __typename?: 'timetables_timetables_query',
    readonly timetables_vehicle_schedule_vehicle_schedule_frame: ReadonlyArray<{
      readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame',
      readonly vehicle_schedule_frame_id: UUID,
      readonly validity_start: luxon.DateTime,
      readonly validity_end: luxon.DateTime,
      readonly vehicle_services: ReadonlyArray<{
        readonly __typename?: 'timetables_vehicle_service_vehicle_service',
        readonly vehicle_service_id: UUID,
        readonly day_type: {
          readonly __typename?: 'timetables_service_calendar_day_type',
          readonly day_type_id: UUID,
          readonly label: string,
          readonly name_i18n: any
        },
        readonly blocks: ReadonlyArray<{
          readonly __typename?: 'timetables_vehicle_service_block',
          readonly block_id: UUID,
          readonly vehicle_journeys: ReadonlyArray<{
            readonly __typename?: 'timetables_vehicle_journey_vehicle_journey',
            readonly vehicle_journey_id: UUID,
            readonly start_time: luxon.Duration,
            readonly contract_number: string,
            readonly journey_pattern_ref: {
              readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref',
              readonly journey_pattern_ref_id: UUID,
              readonly journey_pattern_instance?: {
                readonly __typename?: 'journey_pattern_journey_pattern',
                readonly journey_pattern_id: UUID,
                readonly journey_pattern_route?: {
                  readonly __typename?: 'route_route',
                  readonly route_id: UUID,
                  readonly unique_label: string,
                  readonly direction: RouteDirectionEnum,
                  readonly variant?: number | null,
                  readonly name_i18n: LocalizedString,
                  readonly route_line: {
                    readonly __typename?: 'route_line',
                    readonly line_id: UUID
                  }
                } | null
              } | null
            }
          }>
        }>
      }>
    }>
  } | null
};

export type GetVehicleScheduleFrameWithRouteAndLineInfoQueryVariables = Exact<{
  vehicle_schedule_frame_ids: ReadonlyArray<Scalars['uuid']['input']> | Scalars['uuid']['input'];
}>;


export type GetVehicleScheduleFrameWithRouteAndLineInfoQuery = {
  readonly __typename?: 'query_root',
  readonly timetables?: {
    readonly __typename?: 'timetables_timetables_query',
    readonly timetables_vehicle_schedule_vehicle_schedule_frame: ReadonlyArray<{
      readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame',
      readonly vehicle_schedule_frame_id: UUID,
      readonly vehicle_services: ReadonlyArray<{
        readonly __typename?: 'timetables_vehicle_service_vehicle_service',
        readonly vehicle_service_id: UUID,
        readonly journey_patterns_in_vehicle_service: ReadonlyArray<{
          readonly __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service',
          readonly journey_pattern_id: UUID,
          readonly journey_pattern_instance?: {
            readonly __typename?: 'journey_pattern_journey_pattern',
            readonly journey_pattern_id: UUID,
            readonly journey_pattern_route?: {
              readonly __typename?: 'route_route',
              readonly route_id: UUID,
              readonly unique_label: string,
              readonly direction: RouteDirectionEnum,
              readonly variant?: number | null,
              readonly name_i18n: LocalizedString,
              readonly route_line: {
                readonly __typename?: 'route_line',
                readonly line_id: UUID
              }
            } | null
          } | null
        }>
      }>
    }>
  } | null
};

export type VehicleJourneyWithRouteInfoFragment = {
  readonly __typename?: 'timetables_vehicle_journey_vehicle_journey',
  readonly start_time: luxon.Duration,
  readonly end_time: luxon.Duration,
  readonly contract_number: string,
  readonly vehicle_journey_id: UUID,
  readonly journey_pattern_ref: {
    readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref',
    readonly journey_pattern_ref_id: UUID,
    readonly journey_pattern_instance?: {
      readonly __typename?: 'journey_pattern_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly journey_pattern_route?: {
        readonly __typename?: 'route_route',
        readonly direction: RouteDirectionEnum,
        readonly name_i18n: LocalizedString,
        readonly description_i18n?: LocalizedString | null,
        readonly origin_name_i18n: LocalizedString,
        readonly origin_short_name_i18n: LocalizedString,
        readonly destination_name_i18n: LocalizedString,
        readonly destination_short_name_i18n: LocalizedString,
        readonly on_line_id: UUID,
        readonly label: string,
        readonly variant?: number | null,
        readonly route_id: UUID,
        readonly validity_start?: luxon.DateTime | null,
        readonly validity_end?: luxon.DateTime | null,
        readonly priority: number
      } | null
    } | null
  }
};

export type VehicleServiceWithJourneysFragment = {
  readonly __typename?: 'timetables_vehicle_service_vehicle_service',
  readonly vehicle_service_id: UUID,
  readonly name_i18n?: any | null,
  readonly day_type: {
    readonly __typename?: 'timetables_service_calendar_day_type',
    readonly day_type_id: UUID,
    readonly label: string,
    readonly name_i18n: any
  },
  readonly blocks: ReadonlyArray<{
    readonly __typename?: 'timetables_vehicle_service_block',
    readonly block_id: UUID,
    readonly vehicle_journeys: ReadonlyArray<{
      readonly __typename?: 'timetables_vehicle_journey_vehicle_journey',
      readonly start_time: luxon.Duration,
      readonly end_time: luxon.Duration,
      readonly contract_number: string,
      readonly vehicle_journey_id: UUID,
      readonly journey_pattern_ref: {
        readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref',
        readonly journey_pattern_ref_id: UUID,
        readonly journey_pattern_instance?: {
          readonly __typename?: 'journey_pattern_journey_pattern',
          readonly journey_pattern_id: UUID,
          readonly journey_pattern_route?: {
            readonly __typename?: 'route_route',
            readonly direction: RouteDirectionEnum,
            readonly name_i18n: LocalizedString,
            readonly description_i18n?: LocalizedString | null,
            readonly origin_name_i18n: LocalizedString,
            readonly origin_short_name_i18n: LocalizedString,
            readonly destination_name_i18n: LocalizedString,
            readonly destination_short_name_i18n: LocalizedString,
            readonly on_line_id: UUID,
            readonly label: string,
            readonly variant?: number | null,
            readonly route_id: UUID,
            readonly validity_start?: luxon.DateTime | null,
            readonly validity_end?: luxon.DateTime | null,
            readonly priority: number
          } | null
        } | null
      }
    }>,
    readonly vehicle_type?: {
      readonly __typename?: 'timetables_vehicle_type_vehicle_type',
      readonly vehicle_type_id: UUID,
      readonly description_i18n?: any | null
    } | null
  }>
};

export type VehicleScheduleFrameWithRouteInfoFragment = {
  readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame',
  readonly label: string,
  readonly validity_end: luxon.DateTime,
  readonly validity_start: luxon.DateTime,
  readonly name_i18n?: any | null,
  readonly vehicle_schedule_frame_id: UUID,
  readonly priority: number,
  readonly vehicle_services: ReadonlyArray<{
    readonly __typename?: 'timetables_vehicle_service_vehicle_service',
    readonly vehicle_service_id: UUID,
    readonly name_i18n?: any | null,
    readonly day_type: {
      readonly __typename?: 'timetables_service_calendar_day_type',
      readonly day_type_id: UUID,
      readonly label: string,
      readonly name_i18n: any
    },
    readonly blocks: ReadonlyArray<{
      readonly __typename?: 'timetables_vehicle_service_block',
      readonly block_id: UUID,
      readonly vehicle_journeys: ReadonlyArray<{
        readonly __typename?: 'timetables_vehicle_journey_vehicle_journey',
        readonly start_time: luxon.Duration,
        readonly end_time: luxon.Duration,
        readonly contract_number: string,
        readonly vehicle_journey_id: UUID,
        readonly journey_pattern_ref: {
          readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref',
          readonly journey_pattern_ref_id: UUID,
          readonly journey_pattern_instance?: {
            readonly __typename?: 'journey_pattern_journey_pattern',
            readonly journey_pattern_id: UUID,
            readonly journey_pattern_route?: {
              readonly __typename?: 'route_route',
              readonly direction: RouteDirectionEnum,
              readonly name_i18n: LocalizedString,
              readonly description_i18n?: LocalizedString | null,
              readonly origin_name_i18n: LocalizedString,
              readonly origin_short_name_i18n: LocalizedString,
              readonly destination_name_i18n: LocalizedString,
              readonly destination_short_name_i18n: LocalizedString,
              readonly on_line_id: UUID,
              readonly label: string,
              readonly variant?: number | null,
              readonly route_id: UUID,
              readonly validity_start?: luxon.DateTime | null,
              readonly validity_end?: luxon.DateTime | null,
              readonly priority: number
            } | null
          } | null
        }
      }>,
      readonly vehicle_type?: {
        readonly __typename?: 'timetables_vehicle_type_vehicle_type',
        readonly vehicle_type_id: UUID,
        readonly description_i18n?: any | null
      } | null
    }>
  }>
};

export type GetStagingVehicleScheduleFramesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetStagingVehicleScheduleFramesQuery = {
  readonly __typename?: 'query_root',
  readonly timetables?: {
    readonly __typename?: 'timetables_timetables_query',
    readonly timetables_vehicle_schedule_vehicle_schedule_frame: ReadonlyArray<{
      readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame',
      readonly label: string,
      readonly validity_end: luxon.DateTime,
      readonly validity_start: luxon.DateTime,
      readonly name_i18n?: any | null,
      readonly vehicle_schedule_frame_id: UUID,
      readonly priority: number,
      readonly vehicle_services: ReadonlyArray<{
        readonly __typename?: 'timetables_vehicle_service_vehicle_service',
        readonly vehicle_service_id: UUID,
        readonly name_i18n?: any | null,
        readonly day_type: {
          readonly __typename?: 'timetables_service_calendar_day_type',
          readonly day_type_id: UUID,
          readonly label: string,
          readonly name_i18n: any
        },
        readonly blocks: ReadonlyArray<{
          readonly __typename?: 'timetables_vehicle_service_block',
          readonly block_id: UUID,
          readonly vehicle_journeys: ReadonlyArray<{
            readonly __typename?: 'timetables_vehicle_journey_vehicle_journey',
            readonly start_time: luxon.Duration,
            readonly end_time: luxon.Duration,
            readonly contract_number: string,
            readonly vehicle_journey_id: UUID,
            readonly journey_pattern_ref: {
              readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref',
              readonly journey_pattern_ref_id: UUID,
              readonly journey_pattern_instance?: {
                readonly __typename?: 'journey_pattern_journey_pattern',
                readonly journey_pattern_id: UUID,
                readonly journey_pattern_route?: {
                  readonly __typename?: 'route_route',
                  readonly direction: RouteDirectionEnum,
                  readonly name_i18n: LocalizedString,
                  readonly description_i18n?: LocalizedString | null,
                  readonly origin_name_i18n: LocalizedString,
                  readonly origin_short_name_i18n: LocalizedString,
                  readonly destination_name_i18n: LocalizedString,
                  readonly destination_short_name_i18n: LocalizedString,
                  readonly on_line_id: UUID,
                  readonly label: string,
                  readonly variant?: number | null,
                  readonly route_id: UUID,
                  readonly validity_start?: luxon.DateTime | null,
                  readonly validity_end?: luxon.DateTime | null,
                  readonly priority: number
                } | null
              } | null
            }
          }>,
          readonly vehicle_type?: {
            readonly __typename?: 'timetables_vehicle_type_vehicle_type',
            readonly vehicle_type_id: UUID,
            readonly description_i18n?: any | null
          } | null
        }>
      }>
    }>
  } | null
};

export type ChangeStagingVehicleScheduleFramePriorityMutationVariables = Exact<{
  newPriority: Scalars['Int']['input'];
}>;


export type ChangeStagingVehicleScheduleFramePriorityMutation = {
  readonly __typename?: 'mutation_root',
  readonly timetables?: {
    readonly __typename?: 'timetables_timetables_mutation_frontend',
    readonly timetables_update_vehicle_schedule_vehicle_schedule_frame?: {
      readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_mutation_response',
      readonly returning: ReadonlyArray<{
        readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame',
        readonly priority: number,
        readonly validity_end: luxon.DateTime,
        readonly validity_start: luxon.DateTime,
        readonly name_i18n?: any | null,
        readonly vehicle_schedule_frame_id: UUID
      }>
    } | null
  } | null
};

export type CombineTimetablesMutationVariables = Exact<{
  stagingVehicleScheduleFrameIds: ReadonlyArray<InputMaybe<Scalars['uuid']['input']>> | InputMaybe<Scalars['uuid']['input']>;
  targetPriority: Scalars['Int']['input'];
}>;


export type CombineTimetablesMutation = {
  readonly __typename?: 'mutation_root',
  readonly combineTimetables?: {
    readonly __typename?: 'CombineTimetablesOutput',
    readonly combinedIntoVehicleScheduleFrameIds: ReadonlyArray<UUID | null>
  } | null
};

export type ReplaceTimetablesMutationVariables = Exact<{
  stagingVehicleScheduleFrameIds: ReadonlyArray<InputMaybe<Scalars['uuid']['input']>> | InputMaybe<Scalars['uuid']['input']>;
  targetPriority: Scalars['Int']['input'];
}>;


export type ReplaceTimetablesMutation = {
  readonly __typename?: 'mutation_root',
  readonly replaceTimetables?: {
    readonly __typename?: 'ReplaceTimetablesOutput',
    readonly replacedVehicleScheduleFrameIds: ReadonlyArray<UUID | null>
  } | null
};

export type DeleteStagingTimetablesMutationVariables = Exact<{
  stagingVehicleScheduleFrameIds?: InputMaybe<ReadonlyArray<Scalars['uuid']['input']> | Scalars['uuid']['input']>;
}>;


export type DeleteStagingTimetablesMutation = {
  readonly __typename?: 'mutation_root',
  readonly timetables?: {
    readonly __typename?: 'timetables_timetables_mutation_frontend',
    readonly timetables_delete_vehicle_schedule_vehicle_schedule_frame?: {
      readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_mutation_response',
      readonly returning: ReadonlyArray<{
        readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame',
        readonly vehicle_schedule_frame_id: UUID
      }>
    } | null
  } | null
};

export type NewTimingPlaceFragment = {
  readonly __typename?: 'timing_pattern_timing_place',
  readonly label: string,
  readonly description?: any | null
};

export type CreatedTimingPlaceFragment = {
  readonly __typename?: 'timing_pattern_timing_place',
  readonly timing_place_id: UUID,
  readonly label: string,
  readonly description?: any | null
};

export type InsertTimingPlaceMutationVariables = Exact<{
  object: TimingPatternTimingPlaceInsertInput;
}>;


export type InsertTimingPlaceMutation = {
  readonly __typename?: 'mutation_root',
  readonly insert_timing_pattern_timing_place_one?: {
    readonly __typename?: 'timing_pattern_timing_place',
    readonly timing_place_id: UUID,
    readonly label: string,
    readonly description?: any | null
  } | null
};

export type GetTimingPlacesByLabelQueryVariables = Exact<{
  label: Scalars['String']['input'];
}>;


export type GetTimingPlacesByLabelQuery = {
  readonly __typename?: 'query_root',
  readonly timing_pattern_timing_place: ReadonlyArray<{
    readonly __typename?: 'timing_pattern_timing_place',
    readonly timing_place_id: UUID,
    readonly label: string,
    readonly description?: any | null
  }>
};

export type GetLinesForComboboxQueryVariables = Exact<{
  labelPattern: Scalars['String']['input'];
  date: Scalars['date']['input'];
}>;


export type GetLinesForComboboxQuery = {
  readonly __typename?: 'query_root',
  readonly route_line: ReadonlyArray<{
    readonly __typename?: 'route_line',
    readonly line_id: UUID,
    readonly name_i18n: LocalizedString,
    readonly label: string,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null
  }>
};

export type GetSelectedLineDetailsByIdQueryVariables = Exact<{
  line_id: Scalars['uuid']['input'];
}>;


export type GetSelectedLineDetailsByIdQuery = {
  readonly __typename?: 'query_root',
  readonly route_line_by_pk?: {
    readonly __typename?: 'route_line',
    readonly line_id: UUID,
    readonly name_i18n: LocalizedString,
    readonly label: string,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null
  } | null
};

export type LineForComboboxFragment = {
  readonly __typename?: 'route_line',
  readonly line_id: UUID,
  readonly name_i18n: LocalizedString,
  readonly label: string,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null
};

export type GetRouteDetailsByLabelWildcardQueryVariables = Exact<{
  labelPattern: Scalars['String']['input'];
  date?: InputMaybe<Scalars['date']['input']>;
  priorities?: InputMaybe<ReadonlyArray<Scalars['Int']['input']> | Scalars['Int']['input']>;
}>;


export type GetRouteDetailsByLabelWildcardQuery = {
  readonly __typename?: 'query_root',
  readonly route_route: ReadonlyArray<{
    readonly __typename?: 'route_route',
    readonly route_shape?: GeoJSON.LineString | null,
    readonly name_i18n: LocalizedString,
    readonly description_i18n?: LocalizedString | null,
    readonly origin_name_i18n: LocalizedString,
    readonly origin_short_name_i18n: LocalizedString,
    readonly destination_name_i18n: LocalizedString,
    readonly destination_short_name_i18n: LocalizedString,
    readonly on_line_id: UUID,
    readonly label: string,
    readonly direction: RouteDirectionEnum,
    readonly variant?: number | null,
    readonly route_id: UUID,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly priority: number
  }>
};

export type GetSelectedRouteDetailsByIdQueryVariables = Exact<{
  routeId: Scalars['uuid']['input'];
}>;


export type GetSelectedRouteDetailsByIdQuery = {
  readonly __typename?: 'query_root',
  readonly route_route_by_pk?: {
    readonly __typename?: 'route_route',
    readonly route_shape?: GeoJSON.LineString | null,
    readonly name_i18n: LocalizedString,
    readonly description_i18n?: LocalizedString | null,
    readonly origin_name_i18n: LocalizedString,
    readonly origin_short_name_i18n: LocalizedString,
    readonly destination_name_i18n: LocalizedString,
    readonly destination_short_name_i18n: LocalizedString,
    readonly on_line_id: UUID,
    readonly label: string,
    readonly direction: RouteDirectionEnum,
    readonly variant?: number | null,
    readonly route_id: UUID,
    readonly validity_start?: luxon.DateTime | null,
    readonly validity_end?: luxon.DateTime | null,
    readonly priority: number
  } | null
};

export type GetTimingPlacesForComboboxQueryVariables = Exact<{
  labelPattern: Scalars['String']['input'];
}>;


export type GetTimingPlacesForComboboxQuery = {
  readonly __typename?: 'query_root',
  readonly timing_pattern_timing_place: ReadonlyArray<{
    readonly __typename?: 'timing_pattern_timing_place',
    readonly timing_place_id: UUID,
    readonly label: string,
    readonly description?: any | null
  }>
};

export type GetSelectedTimingPlaceDetailsByIdQueryVariables = Exact<{
  timing_place_id: Scalars['uuid']['input'];
}>;


export type GetSelectedTimingPlaceDetailsByIdQuery = {
  readonly __typename?: 'query_root',
  readonly timing_pattern_timing_place_by_pk?: {
    readonly __typename?: 'timing_pattern_timing_place',
    readonly timing_place_id: UUID,
    readonly label: string,
    readonly description?: any | null
  } | null
};

export type TimingPlaceForComboboxFragment = {
  readonly __typename?: 'timing_pattern_timing_place',
  readonly timing_place_id: UUID,
  readonly label: string,
  readonly description?: any | null
};

export type RouteInfoForTimetableVersionFragment = {
  readonly __typename?: 'route_route',
  readonly route_id: UUID,
  readonly label: string,
  readonly variant?: number | null,
  readonly validity_start?: luxon.DateTime | null,
  readonly priority: number,
  readonly validity_end?: luxon.DateTime | null,
  readonly route_journey_patterns: ReadonlyArray<{
    readonly __typename?: 'journey_pattern_journey_pattern',
    readonly journey_pattern_id: UUID
  }>
};

export type GetRouteInfoForTimetableVersionsQueryVariables = Exact<{
  routeFilters?: InputMaybe<RouteRouteBoolExp>;
}>;


export type GetRouteInfoForTimetableVersionsQuery = {
  readonly __typename?: 'query_root',
  readonly route_route: ReadonlyArray<{
    readonly __typename?: 'route_route',
    readonly route_id: UUID,
    readonly label: string,
    readonly variant?: number | null,
    readonly validity_start?: luxon.DateTime | null,
    readonly priority: number,
    readonly validity_end?: luxon.DateTime | null,
    readonly route_journey_patterns: ReadonlyArray<{
      readonly __typename?: 'journey_pattern_journey_pattern',
      readonly journey_pattern_id: UUID
    }>
  }>
};

export type TimetableVersionFragment = {
  readonly __typename?: 'timetables_return_value_timetable_version',
  readonly validity_start: luxon.DateTime,
  readonly validity_end: luxon.DateTime,
  readonly priority: number,
  readonly in_effect: boolean,
  readonly day_type?: {
    readonly __typename?: 'timetables_service_calendar_day_type',
    readonly day_type_id: UUID,
    readonly name_i18n: any,
    readonly label: string
  } | null,
  readonly substitute_operating_day_by_line_type?: {
    readonly __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type',
    readonly substitute_operating_day_by_line_type_id: UUID,
    readonly superseded_date: luxon.DateTime,
    readonly substitute_day_of_week?: number | null
  } | null,
  readonly vehicle_schedule_frame?: {
    readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame',
    readonly vehicle_schedule_frame_id: UUID,
    readonly name_i18n?: any | null
  } | null
};

export type GetTimetableVersionsByJourneyPatternIdsQueryVariables = Exact<{
  journey_pattern_ids?: InputMaybe<Scalars['_uuid']['input']>;
  start_date?: InputMaybe<Scalars['date']['input']>;
  end_date?: InputMaybe<Scalars['date']['input']>;
  observation_date?: InputMaybe<Scalars['date']['input']>;
}>;


export type GetTimetableVersionsByJourneyPatternIdsQuery = {
  readonly __typename?: 'query_root',
  readonly timetables?: {
    readonly __typename?: 'timetables_timetables_query',
    readonly timetables_vehicle_service_get_timetable_versions_by_journey_pattern_ids: ReadonlyArray<{
      readonly __typename?: 'timetables_return_value_timetable_version',
      readonly validity_start: luxon.DateTime,
      readonly validity_end: luxon.DateTime,
      readonly priority: number,
      readonly in_effect: boolean,
      readonly day_type?: {
        readonly __typename?: 'timetables_service_calendar_day_type',
        readonly day_type_id: UUID,
        readonly name_i18n: any,
        readonly label: string
      } | null,
      readonly substitute_operating_day_by_line_type?: {
        readonly __typename?: 'timetables_service_calendar_substitute_operating_day_by_line_type',
        readonly substitute_operating_day_by_line_type_id: UUID,
        readonly superseded_date: luxon.DateTime,
        readonly substitute_day_of_week?: number | null
      } | null,
      readonly vehicle_schedule_frame?: {
        readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame',
        readonly vehicle_schedule_frame_id: UUID,
        readonly name_i18n?: any | null
      } | null
    }>
  } | null
};

export type RouteMapParamsFragment = {
  readonly __typename?: 'route_route',
  readonly route_id: UUID,
  readonly label: string,
  readonly route_shape?: GeoJSON.LineString | null,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null
};

export type LineMapParamsFragment = {
  readonly __typename?: 'route_line',
  readonly line_id: UUID,
  readonly label: string,
  readonly validity_start?: luxon.DateTime | null,
  readonly validity_end?: luxon.DateTime | null,
  readonly line_routes: ReadonlyArray<{
    readonly __typename?: 'route_route',
    readonly route_id: UUID,
    readonly route_shape?: GeoJSON.LineString | null
  }>
};

export type DeleteVehicleScheduleFrameMutationVariables = Exact<{
  vehicle_schedule_frame_id: Scalars['uuid']['input'];
}>;


export type DeleteVehicleScheduleFrameMutation = {
  readonly __typename?: 'mutation_root',
  readonly timetables?: {
    readonly __typename?: 'timetables_timetables_mutation_frontend',
    readonly timetables_delete_vehicle_schedule_vehicle_schedule_frame_by_pk?: {
      readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame',
      readonly vehicle_schedule_frame_id: UUID
    } | null
  } | null
};

export type GetVehicleScheduleFrameSchedulesQueryVariables = Exact<{
  vehicle_schedule_frame_id: Scalars['uuid']['input'];
}>;


export type GetVehicleScheduleFrameSchedulesQuery = {
  readonly __typename?: 'query_root',
  readonly timetables?: {
    readonly __typename?: 'timetables_timetables_query',
    readonly timetables_vehicle_schedule_vehicle_schedule_frame_by_pk?: {
      readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame',
      readonly vehicle_schedule_frame_id: UUID,
      readonly validity_start: luxon.DateTime,
      readonly validity_end: luxon.DateTime,
      readonly priority: number,
      readonly created_at: luxon.DateTime,
      readonly vehicle_services: ReadonlyArray<{
        readonly __typename?: 'timetables_vehicle_service_vehicle_service',
        readonly vehicle_service_id: UUID,
        readonly day_type: {
          readonly __typename?: 'timetables_service_calendar_day_type',
          readonly day_type_id: UUID,
          readonly label: string,
          readonly name_i18n: any
        },
        readonly blocks: ReadonlyArray<{
          readonly __typename?: 'timetables_vehicle_service_block',
          readonly block_id: UUID,
          readonly vehicle_journeys: ReadonlyArray<{
            readonly __typename?: 'timetables_vehicle_journey_vehicle_journey',
            readonly vehicle_journey_id: UUID,
            readonly start_time: luxon.Duration,
            readonly journey_pattern_ref: {
              readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref',
              readonly journey_pattern_ref_id: UUID,
              readonly journey_pattern_instance?: {
                readonly __typename?: 'journey_pattern_journey_pattern',
                readonly journey_pattern_id: UUID,
                readonly journey_pattern_route?: {
                  readonly __typename?: 'route_route',
                  readonly route_id: UUID,
                  readonly unique_label: string,
                  readonly direction: RouteDirectionEnum,
                  readonly name_i18n: LocalizedString
                } | null
              } | null
            }
          }>
        }>
      }>
    } | null
  } | null
};

export type VehicleJourneyWithStartTimeInfoFragment = {
  readonly __typename?: 'timetables_vehicle_journey_vehicle_journey',
  readonly vehicle_journey_id: UUID,
  readonly start_time: luxon.Duration,
  readonly journey_pattern_ref: {
    readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref',
    readonly journey_pattern_ref_id: UUID,
    readonly journey_pattern_instance?: {
      readonly __typename?: 'journey_pattern_journey_pattern',
      readonly journey_pattern_id: UUID,
      readonly journey_pattern_route?: {
        readonly __typename?: 'route_route',
        readonly route_id: UUID,
        readonly unique_label: string,
        readonly direction: RouteDirectionEnum,
        readonly name_i18n: LocalizedString
      } | null
    } | null
  }
};

export type VehicleScheduleFrameWithRoutesFragment = {
  readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame',
  readonly vehicle_schedule_frame_id: UUID,
  readonly validity_start: luxon.DateTime,
  readonly validity_end: luxon.DateTime,
  readonly vehicle_services: ReadonlyArray<{
    readonly __typename?: 'timetables_vehicle_service_vehicle_service',
    readonly vehicle_service_id: UUID,
    readonly journey_patterns_in_vehicle_service: ReadonlyArray<{
      readonly __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service',
      readonly journey_pattern_instance?: {
        readonly __typename?: 'journey_pattern_journey_pattern',
        readonly journey_pattern_id: UUID,
        readonly journey_pattern_route?: {
          readonly __typename?: 'route_route',
          readonly route_id: UUID,
          readonly label: string
        } | null
      } | null
    }>
  }>
};

export type GetVehicleScheduleFrameWithRoutesQueryVariables = Exact<{
  vehicle_schedule_frame_id: Scalars['uuid']['input'];
}>;


export type GetVehicleScheduleFrameWithRoutesQuery = {
  readonly __typename?: 'query_root',
  readonly timetables?: {
    readonly __typename?: 'timetables_timetables_query',
    readonly timetables_vehicle_schedule_vehicle_schedule_frame: ReadonlyArray<{
      readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame',
      readonly vehicle_schedule_frame_id: UUID,
      readonly validity_start: luxon.DateTime,
      readonly validity_end: luxon.DateTime,
      readonly vehicle_services: ReadonlyArray<{
        readonly __typename?: 'timetables_vehicle_service_vehicle_service',
        readonly vehicle_service_id: UUID,
        readonly journey_patterns_in_vehicle_service: ReadonlyArray<{
          readonly __typename?: 'timetables_vehicle_service_journey_patterns_in_vehicle_service',
          readonly journey_pattern_instance?: {
            readonly __typename?: 'journey_pattern_journey_pattern',
            readonly journey_pattern_id: UUID,
            readonly journey_pattern_route?: {
              readonly __typename?: 'route_route',
              readonly route_id: UUID,
              readonly label: string
            } | null
          } | null
        }>
      }>
    }>
  } | null
};

export type UpdateVehicleScheduleFrameValidityMutationVariables = Exact<{
  vehicle_schedule_frame_id: Scalars['uuid']['input'];
  validity_start?: InputMaybe<Scalars['date']['input']>;
  validity_end?: InputMaybe<Scalars['date']['input']>;
}>;


export type UpdateVehicleScheduleFrameValidityMutation = {
  readonly __typename?: 'mutation_root',
  readonly timetables?: {
    readonly __typename?: 'timetables_timetables_mutation_frontend',
    readonly timetables_update_vehicle_schedule_vehicle_schedule_frame?: {
      readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame_mutation_response',
      readonly returning: ReadonlyArray<{
        readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame',
        readonly vehicle_schedule_frame_id: UUID,
        readonly validity_start: luxon.DateTime,
        readonly validity_end: luxon.DateTime
      }>
    } | null
  } | null
};

export type DayTypeAllFieldsFragment = {
  readonly __typename?: 'timetables_service_calendar_day_type',
  readonly day_type_id: UUID,
  readonly label: string,
  readonly name_i18n: any
};

export type VehicleJourneyWithServiceFragment = {
  readonly __typename?: 'timetables_vehicle_journey_vehicle_journey',
  readonly vehicle_journey_id: UUID,
  readonly start_time: luxon.Duration,
  readonly end_time: luxon.Duration,
  readonly journey_pattern_ref_id: UUID,
  readonly journey_pattern_ref: {
    readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref',
    readonly journey_pattern_ref_id: UUID,
    readonly journey_pattern_id: UUID
  },
  readonly block: {
    readonly __typename?: 'timetables_vehicle_service_block',
    readonly block_id: UUID,
    readonly vehicle_service_id: UUID,
    readonly vehicle_service: {
      readonly __typename?: 'timetables_vehicle_service_vehicle_service',
      readonly vehicle_service_id: UUID,
      readonly day_type_id: UUID,
      readonly vehicle_schedule_frame: {
        readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame',
        readonly vehicle_schedule_frame_id: UUID,
        readonly validity_end: luxon.DateTime,
        readonly validity_start: luxon.DateTime,
        readonly priority: number,
        readonly name_i18n?: any | null,
        readonly created_at: luxon.DateTime
      },
      readonly day_type: {
        readonly __typename?: 'timetables_service_calendar_day_type',
        readonly day_type_id: UUID,
        readonly label: string,
        readonly name_i18n: any
      }
    }
  },
  readonly timetabled_passing_times: ReadonlyArray<{
    readonly __typename?: 'timetables_passing_times_timetabled_passing_time',
    readonly arrival_time?: luxon.Duration | null,
    readonly departure_time?: luxon.Duration | null,
    readonly passing_time: luxon.Duration,
    readonly scheduled_stop_point_in_journey_pattern_ref_id: UUID,
    readonly timetabled_passing_time_id: UUID,
    readonly vehicle_journey_id: UUID,
    readonly scheduled_stop_point_in_journey_pattern_ref: {
      readonly __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref',
      readonly scheduled_stop_point_in_journey_pattern_ref_id: UUID,
      readonly scheduled_stop_point_label: string,
      readonly journey_pattern_ref: {
        readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref',
        readonly journey_pattern_ref_id: UUID,
        readonly observation_timestamp: luxon.DateTime
      },
      readonly scheduled_stop_point_instances: ReadonlyArray<{
        readonly __typename?: 'service_pattern_scheduled_stop_point',
        readonly priority: number,
        readonly direction: InfrastructureNetworkDirectionEnum,
        readonly scheduled_stop_point_id: UUID,
        readonly label: string,
        readonly timing_place_id?: UUID | null,
        readonly validity_start?: luxon.DateTime | null,
        readonly validity_end?: luxon.DateTime | null,
        readonly located_on_infrastructure_link_id: UUID,
        readonly stop_place_ref?: string | null,
        readonly timing_place?: {
          readonly __typename?: 'timing_pattern_timing_place',
          readonly label: string,
          readonly timing_place_id: UUID
        } | null
      }>
    },
    readonly vehicle_journey: {
      readonly __typename?: 'timetables_vehicle_journey_vehicle_journey',
      readonly vehicle_journey_id: UUID,
      readonly block: {
        readonly __typename?: 'timetables_vehicle_service_block',
        readonly block_id: UUID,
        readonly vehicle_type?: {
          readonly __typename?: 'timetables_vehicle_type_vehicle_type',
          readonly description_i18n?: any | null,
          readonly vehicle_type_id: UUID
        } | null
      }
    }
  }>
};

export type VehicleScheduleFragment = {
  readonly __typename?: 'timetables_return_value_vehicle_schedule',
  readonly priority: number,
  readonly validity_start: luxon.DateTime,
  readonly validity_end: luxon.DateTime,
  readonly created_at?: luxon.DateTime | null,
  readonly vehicle_schedule_frame_id?: UUID | null,
  readonly vehicle_journey?: {
    readonly __typename?: 'timetables_vehicle_journey_vehicle_journey',
    readonly vehicle_journey_id: UUID,
    readonly start_time: luxon.Duration,
    readonly end_time: luxon.Duration,
    readonly journey_pattern_ref_id: UUID,
    readonly journey_pattern_ref: {
      readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref',
      readonly journey_pattern_ref_id: UUID,
      readonly journey_pattern_id: UUID
    },
    readonly block: {
      readonly __typename?: 'timetables_vehicle_service_block',
      readonly block_id: UUID,
      readonly vehicle_service_id: UUID,
      readonly vehicle_service: {
        readonly __typename?: 'timetables_vehicle_service_vehicle_service',
        readonly vehicle_service_id: UUID,
        readonly day_type_id: UUID,
        readonly vehicle_schedule_frame: {
          readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame',
          readonly vehicle_schedule_frame_id: UUID,
          readonly validity_end: luxon.DateTime,
          readonly validity_start: luxon.DateTime,
          readonly priority: number,
          readonly name_i18n?: any | null,
          readonly created_at: luxon.DateTime
        },
        readonly day_type: {
          readonly __typename?: 'timetables_service_calendar_day_type',
          readonly day_type_id: UUID,
          readonly label: string,
          readonly name_i18n: any
        }
      }
    },
    readonly timetabled_passing_times: ReadonlyArray<{
      readonly __typename?: 'timetables_passing_times_timetabled_passing_time',
      readonly arrival_time?: luxon.Duration | null,
      readonly departure_time?: luxon.Duration | null,
      readonly passing_time: luxon.Duration,
      readonly scheduled_stop_point_in_journey_pattern_ref_id: UUID,
      readonly timetabled_passing_time_id: UUID,
      readonly vehicle_journey_id: UUID,
      readonly scheduled_stop_point_in_journey_pattern_ref: {
        readonly __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref',
        readonly scheduled_stop_point_in_journey_pattern_ref_id: UUID,
        readonly scheduled_stop_point_label: string,
        readonly journey_pattern_ref: {
          readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref',
          readonly journey_pattern_ref_id: UUID,
          readonly observation_timestamp: luxon.DateTime
        },
        readonly scheduled_stop_point_instances: ReadonlyArray<{
          readonly __typename?: 'service_pattern_scheduled_stop_point',
          readonly priority: number,
          readonly direction: InfrastructureNetworkDirectionEnum,
          readonly scheduled_stop_point_id: UUID,
          readonly label: string,
          readonly timing_place_id?: UUID | null,
          readonly validity_start?: luxon.DateTime | null,
          readonly validity_end?: luxon.DateTime | null,
          readonly located_on_infrastructure_link_id: UUID,
          readonly stop_place_ref?: string | null,
          readonly timing_place?: {
            readonly __typename?: 'timing_pattern_timing_place',
            readonly label: string,
            readonly timing_place_id: UUID
          } | null
        }>
      },
      readonly vehicle_journey: {
        readonly __typename?: 'timetables_vehicle_journey_vehicle_journey',
        readonly vehicle_journey_id: UUID,
        readonly block: {
          readonly __typename?: 'timetables_vehicle_service_block',
          readonly block_id: UUID,
          readonly vehicle_type?: {
            readonly __typename?: 'timetables_vehicle_type_vehicle_type',
            readonly description_i18n?: any | null,
            readonly vehicle_type_id: UUID
          } | null
        }
      }
    }>
  } | null,
  readonly day_type?: {
    readonly __typename?: 'timetables_service_calendar_day_type',
    readonly day_type_id: UUID,
    readonly label: string,
    readonly name_i18n: any
  } | null
};

export type GetVehicleSchedulesForDateQueryVariables = Exact<{
  journey_pattern_id: Scalars['uuid']['input'];
  observation_date: Scalars['date']['input'];
}>;


export type GetVehicleSchedulesForDateQuery = {
  readonly __typename?: 'query_root',
  readonly timetables?: {
    readonly __typename?: 'timetables_timetables_query',
    readonly timetables_vehicle_journey_get_vehicle_schedules_on_date: ReadonlyArray<{
      readonly __typename?: 'timetables_return_value_vehicle_schedule',
      readonly priority: number,
      readonly validity_start: luxon.DateTime,
      readonly validity_end: luxon.DateTime,
      readonly created_at?: luxon.DateTime | null,
      readonly vehicle_schedule_frame_id?: UUID | null,
      readonly vehicle_journey?: {
        readonly __typename?: 'timetables_vehicle_journey_vehicle_journey',
        readonly vehicle_journey_id: UUID,
        readonly start_time: luxon.Duration,
        readonly end_time: luxon.Duration,
        readonly journey_pattern_ref_id: UUID,
        readonly journey_pattern_ref: {
          readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref',
          readonly journey_pattern_ref_id: UUID,
          readonly journey_pattern_id: UUID
        },
        readonly block: {
          readonly __typename?: 'timetables_vehicle_service_block',
          readonly block_id: UUID,
          readonly vehicle_service_id: UUID,
          readonly vehicle_service: {
            readonly __typename?: 'timetables_vehicle_service_vehicle_service',
            readonly vehicle_service_id: UUID,
            readonly day_type_id: UUID,
            readonly vehicle_schedule_frame: {
              readonly __typename?: 'timetables_vehicle_schedule_vehicle_schedule_frame',
              readonly vehicle_schedule_frame_id: UUID,
              readonly validity_end: luxon.DateTime,
              readonly validity_start: luxon.DateTime,
              readonly priority: number,
              readonly name_i18n?: any | null,
              readonly created_at: luxon.DateTime
            },
            readonly day_type: {
              readonly __typename?: 'timetables_service_calendar_day_type',
              readonly day_type_id: UUID,
              readonly label: string,
              readonly name_i18n: any
            }
          }
        },
        readonly timetabled_passing_times: ReadonlyArray<{
          readonly __typename?: 'timetables_passing_times_timetabled_passing_time',
          readonly arrival_time?: luxon.Duration | null,
          readonly departure_time?: luxon.Duration | null,
          readonly passing_time: luxon.Duration,
          readonly scheduled_stop_point_in_journey_pattern_ref_id: UUID,
          readonly timetabled_passing_time_id: UUID,
          readonly vehicle_journey_id: UUID,
          readonly scheduled_stop_point_in_journey_pattern_ref: {
            readonly __typename?: 'timetables_service_pattern_scheduled_stop_point_in_journey_pattern_ref',
            readonly scheduled_stop_point_in_journey_pattern_ref_id: UUID,
            readonly scheduled_stop_point_label: string,
            readonly journey_pattern_ref: {
              readonly __typename?: 'timetables_journey_pattern_journey_pattern_ref',
              readonly journey_pattern_ref_id: UUID,
              readonly observation_timestamp: luxon.DateTime
            },
            readonly scheduled_stop_point_instances: ReadonlyArray<{
              readonly __typename?: 'service_pattern_scheduled_stop_point',
              readonly priority: number,
              readonly direction: InfrastructureNetworkDirectionEnum,
              readonly scheduled_stop_point_id: UUID,
              readonly label: string,
              readonly timing_place_id?: UUID | null,
              readonly validity_start?: luxon.DateTime | null,
              readonly validity_end?: luxon.DateTime | null,
              readonly located_on_infrastructure_link_id: UUID,
              readonly stop_place_ref?: string | null,
              readonly timing_place?: {
                readonly __typename?: 'timing_pattern_timing_place',
                readonly label: string,
                readonly timing_place_id: UUID
              } | null
            }>
          },
          readonly vehicle_journey: {
            readonly __typename?: 'timetables_vehicle_journey_vehicle_journey',
            readonly vehicle_journey_id: UUID,
            readonly block: {
              readonly __typename?: 'timetables_vehicle_service_block',
              readonly block_id: UUID,
              readonly vehicle_type?: {
                readonly __typename?: 'timetables_vehicle_type_vehicle_type',
                readonly description_i18n?: any | null,
                readonly vehicle_type_id: UUID
              } | null
            }
          }
        }>
      } | null,
      readonly day_type?: {
        readonly __typename?: 'timetables_service_calendar_day_type',
        readonly day_type_id: UUID,
        readonly label: string,
        readonly name_i18n: any
      } | null
    }>,
    readonly timetables_service_calendar_get_active_day_types_for_date: ReadonlyArray<{
      readonly __typename?: 'timetables_service_calendar_day_type',
      readonly day_type_id: UUID
    }>
  } | null
};

export type JourneyPatternStopFragment = {
  readonly __typename?: 'journey_pattern_scheduled_stop_point_in_journey_pattern',
  readonly scheduled_stop_point_label: string,
  readonly scheduled_stop_point_sequence: number,
  readonly is_used_as_timing_point: boolean,
  readonly is_via_point: boolean,
  readonly via_point_name_i18n?: LocalizedString | null,
  readonly via_point_short_name_i18n?: LocalizedString | null
};

export const LineMapParamsFragmentDoc = gql`
    fragment line_map_params on route_line {
  line_id
  label
  validity_start
  validity_end
  line_routes {
    route_id
    route_shape
  }
}
    `;
export const RouteMapParamsFragmentDoc = gql`
    fragment route_map_params on route_route {
  route_id
  label
  route_shape
  validity_start
  validity_end
}
    `;
export const LineTableRowFragmentDoc = gql`
    fragment line_table_row on route_line {
  name_i18n
  short_name_i18n
  validity_start
  validity_end
  priority
  ...line_map_params
  line_routes {
    ...route_map_params
    unique_label
    direction
    route_journey_patterns {
      journey_pattern_id
      journey_pattern_refs {
        journey_pattern_ref_id
        vehicle_journeys {
          vehicle_journey_id
        }
      }
      scheduled_stop_point_in_journey_patterns {
        journey_pattern_id
        scheduled_stop_point_sequence
        is_used_as_timing_point
      }
    }
  }
}
    ${LineMapParamsFragmentDoc}
${RouteMapParamsFragmentDoc}`;
export const RouteTableRowFragmentDoc = gql`
    fragment route_table_row on route_route {
  ...route_map_params
  name_i18n
  direction
  priority
  on_line_id
  variant
  unique_label
  route_journey_patterns {
    journey_pattern_id
    journey_pattern_refs {
      journey_pattern_ref_id
      vehicle_journeys {
        vehicle_journey_id
      }
    }
    scheduled_stop_point_in_journey_patterns {
      journey_pattern_id
      scheduled_stop_point_sequence
      is_used_as_timing_point
    }
  }
}
    ${RouteMapParamsFragmentDoc}`;
export const StopFormStopAreaInfoFragmentDoc = gql`
    fragment StopFormStopAreaInfo on stops_database_stop_place_newest_version {
  id
  netextId: netex_id
  privateCode: private_code_value
  validityStart: validity_start
  validityEnd: validity_end
  nameValue: name_value
  nameLang: name_lang
  alternativeNames: stop_place_alternative_names {
    name: alternative_name {
      type: name_type
      value: name_value
      lang: name_lang
    }
  }
}
    `;
export const StopInfoTimingPlaceInfoFragmentDoc = gql`
    fragment StopInfoTimingPlaceInfo on timing_pattern_timing_place {
  id: timing_place_id
  label
}
    `;
export const MapMinimalStopAreaDetailsFragmentDoc = gql`
    fragment mapMinimalStopAreaDetails on stops_database_stop_place_newest_version {
  id
  netex_id
  private_code_value
  centroid
  name_value
}
    `;
export const MapStopMinimalDetailsFragmentDoc = gql`
    fragment MapStopMinimalDetails on stops_database_quay_newest_version {
  id
  netex_id
  stop_place_netex_id
  label: public_code
  validity_start
  validity_end
  priority
  centroid
  functional_area
}
    `;
export const MapMinimalTerminalDetailsFragmentDoc = gql`
    fragment MapMinimalTerminalDetails on stops_database_stop_place_newest_version {
  id
  netex_id
  private_code_value
  centroid
  name_value
  children {
    children_id
    stop_place_id
    child {
      id
      netexId: netex_id
    }
  }
}
    `;
export const LineDefaultFieldsFragmentDoc = gql`
    fragment line_default_fields on route_line {
  line_id
  label
  name_i18n
  short_name_i18n
  validity_start
  validity_end
  priority
}
    `;
export const LineAllFieldsFragmentDoc = gql`
    fragment line_all_fields on route_line {
  ...line_default_fields
  primary_vehicle_mode
  type_of_line
  transport_target
}
    ${LineDefaultFieldsFragmentDoc}`;
export const RouteValidityFragmentDoc = gql`
    fragment route_validity on route_route {
  validity_start
  validity_end
  priority
}
    `;
export const RouteUniqueFieldsFragmentDoc = gql`
    fragment route_unique_fields on route_route {
  ...route_validity
  label
  direction
  variant
  route_id
}
    ${RouteValidityFragmentDoc}`;
export const LineWithRoutesUniqueFieldsFragmentDoc = gql`
    fragment line_with_routes_unique_fields on route_line {
  ...line_all_fields
  line_routes(where: $lineRouteFilters) {
    ...route_unique_fields
  }
}
    ${LineAllFieldsFragmentDoc}
${RouteUniqueFieldsFragmentDoc}`;
export const ScheduledStopPointInJourneyPatternAllFieldsFragmentDoc = gql`
    fragment scheduled_stop_point_in_journey_pattern_all_fields on journey_pattern_scheduled_stop_point_in_journey_pattern {
  journey_pattern_id
  scheduled_stop_point_label
  scheduled_stop_point_sequence
  is_used_as_timing_point
  is_regulated_timing_point
  is_loading_time_allowed
  is_via_point
  via_point_name_i18n
  via_point_short_name_i18n
  journey_pattern {
    journey_pattern_id
    on_route_id
  }
}
    `;
export const ScheduledStopPointWithTimingSettingsFragmentDoc = gql`
    fragment scheduled_stop_point_with_timing_settings on journey_pattern_scheduled_stop_point_in_journey_pattern {
  ...scheduled_stop_point_in_journey_pattern_all_fields
  journey_pattern {
    journey_pattern_id
    journey_pattern_route {
      route_id
      label
    }
  }
  scheduled_stop_points {
    scheduled_stop_point_id
    timing_place_id
  }
}
    ${ScheduledStopPointInJourneyPatternAllFieldsFragmentDoc}`;
export const FindStopByLineRouteInfoFragmentDoc = gql`
    fragment FindStopByLineRouteInfo on route_route {
  route_id
  label
  name_i18n
  direction
  priority
  validity_start
  validity_end
}
    `;
export const FindStopByLineInfoFragmentDoc = gql`
    fragment FindStopByLineInfo on route_line {
  line_id
  label
  name_i18n
  validity_start
  validity_end
  line_routes(
    where: {validity_start: {_lte: $validOn}, _or: [{validity_end: {_gte: $validOn}}, {validity_end: {_is_null: true}}]}
    order_by: [{direction: desc}, {priority: desc}]
    distinct_on: [direction, priority]
  ) {
    ...FindStopByLineRouteInfo
  }
}
    ${FindStopByLineRouteInfoFragmentDoc}`;
export const StopTableRowFragmentDoc = gql`
    fragment stop_table_row on service_pattern_scheduled_stop_point {
  scheduled_stop_point_id
  label
  measured_location
  validity_start
  validity_end
  timing_place_id
  priority
  timing_place {
    timing_place_id
    label
  }
}
    `;
export const StopTableRowQuayBaseDetailsFragmentDoc = gql`
    fragment stop_table_row_quay_base_details on stops_database_quay_newest_version {
  id
  netex_id
  stop_place {
    name_lang
    name_value
    stop_place_alternative_names {
      alternative_name {
        name_lang
        name_type
        name_value
      }
    }
  }
}
    `;
export const GetStopByRouteIdSearchResultFragmentDoc = gql`
    fragment GetStopByRouteIdSearchResult on service_pattern_scheduled_stop_point {
  ...stop_table_row
  quay: newest_quay {
    ...stop_table_row_quay_base_details
  }
  journeyPatterns: scheduled_stop_point_in_journey_patterns(
    where: {journey_pattern: {on_route_id: {_eq: $routeId}}}
  ) {
    journey_pattern_id
    sequence: scheduled_stop_point_sequence
  }
}
    ${StopTableRowFragmentDoc}
${StopTableRowQuayBaseDetailsFragmentDoc}`;
export const FindStopAreaInfoFragmentDoc = gql`
    fragment FindStopAreaInfo on stops_database_stop_place_newest_version {
  id
  netex_id
  version
  name_lang
  name_value
  private_code: private_code_value
  centroid
}
    `;
export const StopTableRowQuayFragmentDoc = gql`
    fragment stop_table_row_quay on stops_database_quay_newest_version {
  ...stop_table_row_quay_base_details
  scheduled_stop_point_instance {
    ...stop_table_row
  }
}
    ${StopTableRowQuayBaseDetailsFragmentDoc}
${StopTableRowFragmentDoc}`;
export const StopPlaceOrganisationFieldsFragmentDoc = gql`
    fragment stop_place_organisation_fields on stop_registry_Organisation {
  id
  name
  privateContactDetails {
    id
    email
    phone
  }
}
    `;
export const HslAccessibilityPropertiesDetailsFragmentDoc = gql`
    fragment hsl_accessibility_properties_details on stop_registry_HslAccessibilityProperties {
  id
  stopAreaSideSlope
  stopAreaLengthwiseSlope
  endRampSlope
  shelterLaneDistance
  curbBackOfRailDistance
  curbDriveSideOfRailDistance
  structureLaneDistance
  stopElevationFromRailTop
  stopElevationFromSidewalk
  lowerCleatHeight
  serviceAreaWidth
  serviceAreaLength
  platformEdgeWarningArea
  guidanceTiles
  guidanceStripe
  serviceAreaStripes
  sidewalkAccessibleConnection
  stopAreaSurroundingsAccessible
  curvedStop
  stopType
  shelterType
  guidanceType
  mapType
  pedestrianCrossingRampType
  accessibilityLevel
}
    `;
export const AccessibilityAssessmentDetailsFragmentDoc = gql`
    fragment accessibility_assessment_details on stop_registry_AccessibilityAssessment {
  id
  hslAccessibilityProperties {
    ...hsl_accessibility_properties_details
  }
  limitations {
    id
    version
    audibleSignalsAvailable
    escalatorFreeAccess
    liftFreeAccess
    stepFreeAccess
    wheelchairAccess
  }
}
    ${HslAccessibilityPropertiesDetailsFragmentDoc}`;
export const InfoSpotDetailsFragmentDoc = gql`
    fragment info_spot_details on stop_registry_infoSpot {
  id
  backlight
  description {
    lang
    value
  }
  displayType
  floor
  label
  width
  height
  infoSpotLocations
  infoSpotType
  purpose
  railInformation
  speechProperty
  zoneLabel
  poster {
    label
    width
    height
    lines
  }
}
    `;
export const ShelterEquipmentDetailsFragmentDoc = gql`
    fragment shelter_equipment_details on stop_registry_ShelterEquipment {
  id
  enclosed
  stepFree
  shelterNumber
  shelterType
  shelterElectricity
  shelterLighting
  shelterCondition
  timetableCabinets
  trashCan
  shelterHasDisplay
  bicycleParking
  leaningRail
  outsideBench
  shelterFasciaBoardTaping
  shelterExternalId
}
    `;
export const ScheduledStopPointDetailFieldsFragmentDoc = gql`
    fragment scheduled_stop_point_detail_fields on service_pattern_scheduled_stop_point {
  priority
  direction
  scheduled_stop_point_id
  label
  timing_place_id
  timing_place {
    timing_place_id
    label
  }
  validity_start
  validity_end
  located_on_infrastructure_link_id
  stop_place_ref
  measured_location
  vehicle_mode_on_scheduled_stop_point {
    vehicle_mode
  }
}
    `;
export const ExternalLinksDetailsFragmentDoc = gql`
    fragment external_links_details on stop_registry_externalLink {
  quayId
  orderNum
  name
  location
}
    `;
export const QuayDetailsFragmentDoc = gql`
    fragment quay_details on stop_registry_Quay {
  id
  publicCode
  privateCode {
    type
    value
  }
  description {
    lang
    value
  }
  alternativeNames {
    name {
      lang
      value
    }
    nameType
  }
  geometry {
    coordinates
    type
  }
  accessibilityAssessment {
    ...accessibility_assessment_details
  }
  keyValues {
    key
    values
  }
  infoSpots {
    ...info_spot_details
  }
  placeEquipments {
    id
    shelterEquipment {
      ...shelter_equipment_details
    }
    cycleStorageEquipment {
      cycleStorageType
    }
    generalSign {
      privateCode {
        value
        type
      }
      content {
        value
      }
      signContentType
      numberOfFrames
      lineSignage
      mainLineSign
      replacesRailSign
      note {
        lang
        value
      }
    }
  }
  scheduled_stop_point {
    ...scheduled_stop_point_detail_fields
  }
  externalLinks {
    ...external_links_details
  }
}
    ${AccessibilityAssessmentDetailsFragmentDoc}
${InfoSpotDetailsFragmentDoc}
${ShelterEquipmentDetailsFragmentDoc}
${ScheduledStopPointDetailFieldsFragmentDoc}
${ExternalLinksDetailsFragmentDoc}`;
export const MemberStopQuayDetailsFragmentDoc = gql`
    fragment member_stop_quay_details on stop_registry_Quay {
  id
  publicCode
  description {
    lang
    value
  }
  scheduled_stop_point {
    ...scheduled_stop_point_detail_fields
  }
  keyValues {
    key
    values
  }
  infoSpots {
    ...info_spot_details
  }
  placeEquipments {
    id
    generalSign {
      id
      content {
        value
      }
    }
    shelterEquipment {
      id
      shelterNumber
    }
  }
}
    ${ScheduledStopPointDetailFieldsFragmentDoc}
${InfoSpotDetailsFragmentDoc}`;
export const MemberStopStopPlaceDetailsFragmentDoc = gql`
    fragment member_stop_stop_place_details on stop_registry_StopPlace {
  id
  name {
    value
  }
  privateCode {
    value
  }
  quays {
    ...member_stop_quay_details
  }
}
    ${MemberStopQuayDetailsFragmentDoc}`;
export const TerminalDetailsFragmentDoc = gql`
    fragment terminal_details on stop_registry_ParentStopPlace {
  id
  name {
    lang
    value
  }
  privateCode {
    value
    type
  }
  children {
    ...member_stop_stop_place_details
  }
}
    ${MemberStopStopPlaceDetailsFragmentDoc}`;
export const TopographicPlaceDetailsFragmentDoc = gql`
    fragment topographic_place_details on stop_registry_TopographicPlace {
  id
  name {
    value
    lang
  }
}
    `;
export const FareZoneDetailsFragmentDoc = gql`
    fragment fare_zone_details on stop_registry_FareZone {
  id
  name {
    value
    lang
  }
}
    `;
export const StopPlaceDetailsFragmentDoc = gql`
    fragment stop_place_details on stop_registry_StopPlace {
  id
  alternativeNames {
    name {
      lang
      value
    }
    nameType
  }
  privateCode {
    value
    type
  }
  name {
    lang
    value
  }
  organisations {
    relationshipType
    organisationRef
    organisation {
      ...stop_place_organisation_fields
    }
  }
  geometry {
    type
    coordinates
  }
  keyValues {
    key
    values
  }
  quays {
    ...quay_details
  }
  parentStopPlace {
    ...terminal_details
  }
  accessibilityAssessment {
    ...accessibility_assessment_details
  }
  transportMode
  topographicPlace {
    ...topographic_place_details
  }
  fareZones {
    ...fare_zone_details
  }
}
    ${StopPlaceOrganisationFieldsFragmentDoc}
${QuayDetailsFragmentDoc}
${TerminalDetailsFragmentDoc}
${AccessibilityAssessmentDetailsFragmentDoc}
${TopographicPlaceDetailsFragmentDoc}
${FareZoneDetailsFragmentDoc}`;
export const StopAreaVersionInfoFragmentDoc = gql`
    fragment StopAreaVersionInfo on stops_database_stop_place_newest_version {
  id
  netex_id
  private_code_type
  private_code_value
  name_value
  validity_start
  validity_end
  centroid
  created
  changed
  changed_by
  version_comment
}
    `;
export const StopPointDetailsFragmentDoc = gql`
    fragment StopPointDetails on service_pattern_scheduled_stop_point {
  stop_place_ref
  label
  priority
  validity_start
  validity_end
  scheduled_stop_point_id
}
    `;
export const JourneyPatternRouteFragmentDoc = gql`
    fragment JourneyPatternRoute on route_route {
  label
  priority
  validity_start
  validity_end
  route_id
}
    `;
export const JourneyRouteInfoFragmentDoc = gql`
    fragment JourneyRouteInfo on service_pattern_scheduled_stop_point {
  scheduled_stop_point_in_journey_patterns(
    where: {journey_pattern: {journey_pattern_route: {validity_start: {_lte: $validOn}, _or: [{validity_end: {_gte: $validOn}}, {validity_end: {_is_null: true}}]}}}
  ) {
    journey_pattern_id
    scheduled_stop_point_sequence
    journey_pattern {
      journey_pattern_id
      journey_pattern_route {
        ...JourneyPatternRoute
      }
    }
  }
}
    ${JourneyPatternRouteFragmentDoc}`;
export const OverlappingStopVersionsDataFragmentDoc = gql`
    fragment OverlappingStopVersionsData on service_pattern_scheduled_stop_point {
  scheduled_stop_point_id
  label
  priority
  stop_place_ref
  validity_start
  validity_end
  stop_place {
    id
  }
}
    `;
export const StopVersionInfoFragmentDoc = gql`
    fragment StopVersionInfo on stops_database_quay_newest_version {
  id
  netex_id
  stop_place {
    id
    netex_id
    name_value
  }
  validity_start
  validity_end
  priority
  public_code
  centroid
  created
  changed
  changed_by
  version_comment
}
    `;
export const TerminalExternalLinksDetailsFragmentDoc = gql`
    fragment terminal_external_links_details on stop_registry_stopPlaceExternalLink {
  stopPlaceId
  orderNum
  name
  location
}
    `;
export const TerminalOrganizationRefFragmentDoc = gql`
    fragment terminal_organization_ref on stop_registry_StopPlaceOrganisationRef {
  organisationRef
  relationshipType
  organisation {
    ...stop_place_organisation_fields
  }
}
    ${StopPlaceOrganisationFieldsFragmentDoc}`;
export const ParentStopPlaceDetailsFragmentDoc = gql`
    fragment parent_stop_place_details on stop_registry_ParentStopPlace {
  id
  alternativeNames {
    name {
      lang
      value
    }
    nameType
  }
  privateCode {
    value
    type
  }
  name {
    lang
    value
  }
  description {
    lang
    value
  }
  geometry {
    type
    coordinates
  }
  topographicPlace {
    name {
      value
    }
  }
  fareZones {
    name {
      value
    }
  }
  keyValues {
    key
    values
  }
  infoSpots {
    ...info_spot_details
  }
  accessibilityAssessment {
    ...accessibility_assessment_details
  }
  children {
    ...member_stop_stop_place_details
  }
  externalLinks {
    ...terminal_external_links_details
  }
  organisations {
    ...terminal_organization_ref
  }
}
    ${InfoSpotDetailsFragmentDoc}
${AccessibilityAssessmentDetailsFragmentDoc}
${MemberStopStopPlaceDetailsFragmentDoc}
${TerminalExternalLinksDetailsFragmentDoc}
${TerminalOrganizationRefFragmentDoc}`;
export const InfraLinkMatchingFieldsFragmentDoc = gql`
    fragment infra_link_matching_fields on infrastructure_network_infrastructure_link {
  external_link_id
  infrastructure_link_id
  shape
  direction
}
    `;
export const ScheduledStopPointDefaultFieldsFragmentDoc = gql`
    fragment scheduled_stop_point_default_fields on service_pattern_scheduled_stop_point {
  priority
  direction
  scheduled_stop_point_id
  label
  timing_place_id
  timing_place {
    timing_place_id
    label
  }
  validity_start
  validity_end
  located_on_infrastructure_link_id
  stop_place_ref
}
    `;
export const ScheduledStopPointAllFieldsFragmentDoc = gql`
    fragment scheduled_stop_point_all_fields on service_pattern_scheduled_stop_point {
  ...scheduled_stop_point_default_fields
  measured_location
  relative_distance_from_infrastructure_link_start
  closest_point_on_infrastructure_link
  vehicle_mode_on_scheduled_stop_point {
    vehicle_mode
  }
}
    ${ScheduledStopPointDefaultFieldsFragmentDoc}`;
export const StopWithJourneyPatternFieldsFragmentDoc = gql`
    fragment stop_with_journey_pattern_fields on service_pattern_scheduled_stop_point {
  ...scheduled_stop_point_all_fields
  scheduled_stop_point_in_journey_patterns {
    ...scheduled_stop_point_in_journey_pattern_all_fields
  }
}
    ${ScheduledStopPointAllFieldsFragmentDoc}
${ScheduledStopPointInJourneyPatternAllFieldsFragmentDoc}`;
export const RouteStopFieldsFragmentDoc = gql`
    fragment route_stop_fields on service_pattern_scheduled_stop_point {
  ...stop_with_journey_pattern_fields
  stop_place {
    id
    name {
      lang
      value
    }
  }
  other_label_instances {
    ...scheduled_stop_point_default_fields
  }
}
    ${StopWithJourneyPatternFieldsFragmentDoc}
${ScheduledStopPointDefaultFieldsFragmentDoc}`;
export const RouteInfraLinkFieldsFragmentDoc = gql`
    fragment route_infra_link_fields on infrastructure_network_infrastructure_link {
  ...infra_link_matching_fields
  external_link_source
  scheduled_stop_points_located_on_infrastructure_link {
    ...route_stop_fields
  }
}
    ${InfraLinkMatchingFieldsFragmentDoc}
${RouteStopFieldsFragmentDoc}`;
export const InfraLinkAlongRouteDefaultFieldsFragmentDoc = gql`
    fragment infra_link_along_route_default_fields on route_infrastructure_link_along_route {
  infrastructure_link_id
  infrastructure_link {
    infrastructure_link_id
  }
  is_traversal_forwards
}
    `;
export const RouteDefaultFieldsFragmentDoc = gql`
    fragment route_default_fields on route_route {
  ...route_unique_fields
  name_i18n
  description_i18n
  origin_name_i18n
  origin_short_name_i18n
  destination_name_i18n
  destination_short_name_i18n
  on_line_id
}
    ${RouteUniqueFieldsFragmentDoc}`;
export const RouteAllFieldsFragmentDoc = gql`
    fragment route_all_fields on route_route {
  ...route_default_fields
  route_shape
}
    ${RouteDefaultFieldsFragmentDoc}`;
export const RouteWithInfrastructureLinksFragmentDoc = gql`
    fragment route_with_infrastructure_links on route_route {
  ...route_all_fields
  route_line {
    ...line_all_fields
  }
  infrastructure_links_along_route {
    route_id
    infrastructure_link_sequence
    infrastructure_link_id
    infrastructure_link {
      infrastructure_link_id
      shape
      direction
      external_link_id
      external_link_source
    }
    is_traversal_forwards
  }
}
    ${RouteAllFieldsFragmentDoc}
${LineAllFieldsFragmentDoc}`;
export const InfrastructureLinkDefaultFieldsFragmentDoc = gql`
    fragment infrastructure_link_default_fields on infrastructure_network_infrastructure_link {
  infrastructure_link_id
}
    `;
export const InfrastructureLinkAllFieldsFragmentDoc = gql`
    fragment infrastructure_link_all_fields on infrastructure_network_infrastructure_link {
  ...infrastructure_link_default_fields
  direction
  shape
  estimated_length_in_metres
  external_link_id
  external_link_source
}
    ${InfrastructureLinkDefaultFieldsFragmentDoc}`;
export const InfrastructureLinkWithStopsFragmentDoc = gql`
    fragment infrastructure_link_with_stops on infrastructure_network_infrastructure_link {
  ...infrastructure_link_all_fields
  scheduled_stop_points_located_on_infrastructure_link(where: $routeStopFilters) {
    ...scheduled_stop_point_all_fields
    other_label_instances {
      ...scheduled_stop_point_default_fields
    }
    scheduled_stop_point_in_journey_patterns {
      ...scheduled_stop_point_in_journey_pattern_all_fields
      journey_pattern {
        journey_pattern_id
        on_route_id
      }
    }
  }
}
    ${InfrastructureLinkAllFieldsFragmentDoc}
${ScheduledStopPointAllFieldsFragmentDoc}
${ScheduledStopPointDefaultFieldsFragmentDoc}
${ScheduledStopPointInJourneyPatternAllFieldsFragmentDoc}`;
export const InfraLinkAlongRouteWithStopsFragmentDoc = gql`
    fragment infra_link_along_route_with_stops on route_infrastructure_link_along_route {
  route_id
  infrastructure_link_sequence
  infrastructure_link_id
  infrastructure_link {
    ...infra_link_matching_fields
    external_link_source
    scheduled_stop_points_located_on_infrastructure_link {
      ...route_stop_fields
    }
  }
  is_traversal_forwards
}
    ${InfraLinkMatchingFieldsFragmentDoc}
${RouteStopFieldsFragmentDoc}`;
export const RouteWithInfrastructureLinksWithStopsFragmentDoc = gql`
    fragment route_with_infrastructure_links_with_stops on route_route {
  ...route_all_fields
  route_line {
    ...line_all_fields
  }
  infrastructure_links_along_route {
    ...infra_link_along_route_with_stops
  }
}
    ${RouteAllFieldsFragmentDoc}
${LineAllFieldsFragmentDoc}
${InfraLinkAlongRouteWithStopsFragmentDoc}`;
export const JourneyPatternWithStopsFragmentDoc = gql`
    fragment journey_pattern_with_stops on journey_pattern_journey_pattern {
  journey_pattern_id
  on_route_id
  ordered_scheduled_stop_point_in_journey_patterns: scheduled_stop_point_in_journey_patterns(
    order_by: {scheduled_stop_point_sequence: asc}
  ) {
    ...scheduled_stop_point_in_journey_pattern_all_fields
    scheduled_stop_points {
      ...scheduled_stop_point_default_fields
    }
  }
}
    ${ScheduledStopPointInJourneyPatternAllFieldsFragmentDoc}
${ScheduledStopPointDefaultFieldsFragmentDoc}`;
export const RouteWithJourneyPatternStopsFragmentDoc = gql`
    fragment route_with_journey_pattern_stops on route_route {
  ...route_all_fields
  route_journey_patterns {
    ...journey_pattern_with_stops
  }
}
    ${RouteAllFieldsFragmentDoc}
${JourneyPatternWithStopsFragmentDoc}`;
export const RouteWithInfrastructureLinksWithStopsAndJpsFragmentDoc = gql`
    fragment route_with_infrastructure_links_with_stops_and_jps on route_route {
  ...route_with_infrastructure_links_with_stops
  ...route_with_journey_pattern_stops
}
    ${RouteWithInfrastructureLinksWithStopsFragmentDoc}
${RouteWithJourneyPatternStopsFragmentDoc}`;
export const LineWithRoutesFragmentDoc = gql`
    fragment line_with_routes on route_line {
  ...line_all_fields
  line_routes(where: $lineRouteFilters) {
    ...route_with_infrastructure_links_with_stops_and_jps
  }
}
    ${LineAllFieldsFragmentDoc}
${RouteWithInfrastructureLinksWithStopsAndJpsFragmentDoc}`;
export const DisplayedRouteFragmentDoc = gql`
    fragment displayed_route on route_route {
  route_id
  label
  variant
  validity_start
  validity_end
  priority
  direction
  route_journey_patterns {
    journey_pattern_id
    scheduled_stop_point_in_journey_patterns {
      journey_pattern_id
      scheduled_stop_point_label
      scheduled_stop_point_sequence
    }
  }
}
    `;
export const RouteMetadataFragmentDoc = gql`
    fragment route_metadata on route_route {
  name_i18n
  label
  priority
  validity_start
  validity_end
  direction
  variant
}
    `;
export const VehicleJourneyWithPatternAndRouteFragmentFragmentDoc = gql`
    fragment vehicle_journey_with_pattern_and_route_fragment on timetables_vehicle_journey_vehicle_journey {
  vehicle_journey_id
  start_time
  contract_number
  journey_pattern_ref {
    journey_pattern_ref_id
    journey_pattern_instance {
      journey_pattern_id
      journey_pattern_route {
        route_id
        unique_label
        direction
        variant
        name_i18n
        route_line {
          line_id
        }
      }
    }
  }
}
    `;
export const DayTypeAllFieldsFragmentDoc = gql`
    fragment day_type_all_fields on timetables_service_calendar_day_type {
  day_type_id
  label
  name_i18n
}
    `;
export const VehicleJourneyWithRouteInfoFragmentDoc = gql`
    fragment vehicle_journey_with_route_info on timetables_vehicle_journey_vehicle_journey {
  start_time
  end_time
  contract_number
  vehicle_journey_id
  journey_pattern_ref {
    journey_pattern_ref_id
    journey_pattern_instance {
      journey_pattern_id
      journey_pattern_route {
        ...route_default_fields
        direction
      }
    }
  }
}
    ${RouteDefaultFieldsFragmentDoc}`;
export const VehicleServiceWithJourneysFragmentDoc = gql`
    fragment vehicle_service_with_journeys on timetables_vehicle_service_vehicle_service {
  vehicle_service_id
  name_i18n
  day_type {
    ...day_type_all_fields
  }
  blocks {
    block_id
    vehicle_journeys {
      ...vehicle_journey_with_route_info
    }
    vehicle_type {
      vehicle_type_id
      description_i18n
    }
  }
}
    ${DayTypeAllFieldsFragmentDoc}
${VehicleJourneyWithRouteInfoFragmentDoc}`;
export const VehicleScheduleFrameWithRouteInfoFragmentDoc = gql`
    fragment vehicle_schedule_frame_with_route_info on timetables_vehicle_schedule_vehicle_schedule_frame {
  label
  validity_end
  validity_start
  name_i18n
  vehicle_schedule_frame_id
  priority
  vehicle_services {
    ...vehicle_service_with_journeys
  }
}
    ${VehicleServiceWithJourneysFragmentDoc}`;
export const NewTimingPlaceFragmentDoc = gql`
    fragment new_timing_place on timing_pattern_timing_place {
  label
  description
}
    `;
export const CreatedTimingPlaceFragmentDoc = gql`
    fragment created_timing_place on timing_pattern_timing_place {
  timing_place_id
  label
  description
}
    `;
export const LineForComboboxFragmentDoc = gql`
    fragment line_for_combobox on route_line {
  line_id
  name_i18n
  label
  validity_start
  validity_end
}
    `;
export const TimingPlaceForComboboxFragmentDoc = gql`
    fragment timing_place_for_combobox on timing_pattern_timing_place {
  timing_place_id
  label
  description
}
    `;
export const RouteInfoForTimetableVersionFragmentDoc = gql`
    fragment route_info_for_timetable_version on route_route {
  route_id
  label
  variant
  validity_start
  priority
  validity_end
  route_journey_patterns {
    journey_pattern_id
  }
}
    `;
export const TimetableVersionFragmentDoc = gql`
    fragment timetable_version on timetables_return_value_timetable_version {
  day_type {
    day_type_id
    name_i18n
    label
  }
  substitute_operating_day_by_line_type {
    substitute_operating_day_by_line_type_id
    superseded_date
    substitute_day_of_week
  }
  vehicle_schedule_frame {
    vehicle_schedule_frame_id
    name_i18n
  }
  validity_start
  validity_end
  priority
  in_effect
}
    `;
export const VehicleJourneyWithStartTimeInfoFragmentDoc = gql`
    fragment vehicle_journey_with_start_time_info on timetables_vehicle_journey_vehicle_journey {
  vehicle_journey_id
  start_time
  journey_pattern_ref {
    journey_pattern_ref_id
    journey_pattern_instance {
      journey_pattern_id
      journey_pattern_route {
        route_id
        unique_label
        direction
        name_i18n
      }
    }
  }
}
    `;
export const VehicleScheduleFrameWithRoutesFragmentDoc = gql`
    fragment vehicle_schedule_frame_with_routes on timetables_vehicle_schedule_vehicle_schedule_frame {
  vehicle_schedule_frame_id
  validity_start
  validity_end
  vehicle_services {
    vehicle_service_id
    journey_patterns_in_vehicle_service {
      journey_pattern_instance {
        journey_pattern_id
        journey_pattern_route {
          route_id
          label
        }
      }
    }
  }
}
    `;
export const PassingTimeByStopFragmentDoc = gql`
    fragment passing_time_by_stop on timetables_passing_times_timetabled_passing_time {
  arrival_time
  departure_time
  passing_time
  scheduled_stop_point_in_journey_pattern_ref_id
  timetabled_passing_time_id
  vehicle_journey_id
  scheduled_stop_point_in_journey_pattern_ref {
    journey_pattern_ref {
      journey_pattern_ref_id
      observation_timestamp
    }
    scheduled_stop_point_in_journey_pattern_ref_id
    scheduled_stop_point_label
    scheduled_stop_point_instances {
      ...scheduled_stop_point_default_fields
      timing_place {
        label
        timing_place_id
      }
    }
  }
  vehicle_journey {
    vehicle_journey_id
    block {
      block_id
      vehicle_type {
        description_i18n
        vehicle_type_id
      }
    }
  }
}
    ${ScheduledStopPointDefaultFieldsFragmentDoc}`;
export const VehicleJourneyByStopFragmentDoc = gql`
    fragment vehicle_journey_by_stop on timetables_vehicle_journey_vehicle_journey {
  timetabled_passing_times {
    ...passing_time_by_stop
  }
  journey_pattern_ref_id
  vehicle_journey_id
}
    ${PassingTimeByStopFragmentDoc}`;
export const VehicleJourneyWithServiceFragmentDoc = gql`
    fragment vehicle_journey_with_service on timetables_vehicle_journey_vehicle_journey {
  vehicle_journey_id
  start_time
  end_time
  journey_pattern_ref {
    journey_pattern_ref_id
    journey_pattern_id
  }
  block {
    block_id
    vehicle_service_id
    vehicle_service {
      vehicle_schedule_frame {
        vehicle_schedule_frame_id
        validity_end
        validity_start
        priority
        name_i18n
        created_at
      }
      vehicle_service_id
      day_type_id
      day_type {
        ...day_type_all_fields
      }
    }
  }
  ...vehicle_journey_by_stop
}
    ${DayTypeAllFieldsFragmentDoc}
${VehicleJourneyByStopFragmentDoc}`;
export const VehicleScheduleFragmentDoc = gql`
    fragment vehicle_schedule on timetables_return_value_vehicle_schedule {
  vehicle_journey {
    ...vehicle_journey_with_service
  }
  day_type {
    ...day_type_all_fields
  }
  priority
  validity_start
  validity_end
  created_at
  vehicle_schedule_frame_id
}
    ${VehicleJourneyWithServiceFragmentDoc}
${DayTypeAllFieldsFragmentDoc}`;
export const JourneyPatternStopFragmentDoc = gql`
    fragment journey_pattern_stop on journey_pattern_scheduled_stop_point_in_journey_pattern {
  scheduled_stop_point_label
  scheduled_stop_point_sequence
  is_used_as_timing_point
  is_via_point
  via_point_name_i18n
  via_point_short_name_i18n
}
    `;
export const GetStopPlaceMaxPrivateCodeDocument = gql`
    query GetStopPlaceMaxPrivateCode($isParent: Boolean!, $mask: String!) {
  stops_database {
    stops_database_stop_place_aggregate(
      where: {parent_stop_place: {_eq: $isParent}, private_code_value: {_like: $mask}}
    ) {
      aggregate {
        max {
          private_code_value
        }
      }
    }
  }
}
    `;

/**
 * __useGetStopPlaceMaxPrivateCodeQuery__
 *
 * To run a query within a React component, call `useGetStopPlaceMaxPrivateCodeQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStopPlaceMaxPrivateCodeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStopPlaceMaxPrivateCodeQuery({
 *   variables: {
 *      isParent: // value for 'isParent'
 *      mask: // value for 'mask'
 *   },
 * });
 */
export function useGetStopPlaceMaxPrivateCodeQuery(baseOptions: Apollo.QueryHookOptions<GetStopPlaceMaxPrivateCodeQuery, GetStopPlaceMaxPrivateCodeQueryVariables> & ({ variables: GetStopPlaceMaxPrivateCodeQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStopPlaceMaxPrivateCodeQuery, GetStopPlaceMaxPrivateCodeQueryVariables>(GetStopPlaceMaxPrivateCodeDocument, options);
      }
export function useGetStopPlaceMaxPrivateCodeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStopPlaceMaxPrivateCodeQuery, GetStopPlaceMaxPrivateCodeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStopPlaceMaxPrivateCodeQuery, GetStopPlaceMaxPrivateCodeQueryVariables>(GetStopPlaceMaxPrivateCodeDocument, options);
        }
export function useGetStopPlaceMaxPrivateCodeSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetStopPlaceMaxPrivateCodeQuery, GetStopPlaceMaxPrivateCodeQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetStopPlaceMaxPrivateCodeQuery, GetStopPlaceMaxPrivateCodeQueryVariables>(GetStopPlaceMaxPrivateCodeDocument, options);
        }
export type GetStopPlaceMaxPrivateCodeQueryHookResult = ReturnType<typeof useGetStopPlaceMaxPrivateCodeQuery>;
export type GetStopPlaceMaxPrivateCodeLazyQueryHookResult = ReturnType<typeof useGetStopPlaceMaxPrivateCodeLazyQuery>;
export type GetStopPlaceMaxPrivateCodeSuspenseQueryHookResult = ReturnType<typeof useGetStopPlaceMaxPrivateCodeSuspenseQuery>;
export type GetStopPlaceMaxPrivateCodeQueryResult = Apollo.QueryResult<GetStopPlaceMaxPrivateCodeQuery, GetStopPlaceMaxPrivateCodeQueryVariables>;
export const UpsertStopAreaDocument = gql`
    mutation UpsertStopArea($input: stop_registry_StopPlaceInput!) {
  stop_registry {
    mutateStopPlace(StopPlace: $input) {
      ...stop_place_details
    }
  }
}
    ${StopPlaceDetailsFragmentDoc}`;
export type UpsertStopAreaMutationFn = Apollo.MutationFunction<UpsertStopAreaMutation, UpsertStopAreaMutationVariables>;

/**
 * __useUpsertStopAreaMutation__
 *
 * To run a mutation, you first call `useUpsertStopAreaMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertStopAreaMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertStopAreaMutation, { data, loading, error }] = useUpsertStopAreaMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpsertStopAreaMutation(baseOptions?: Apollo.MutationHookOptions<UpsertStopAreaMutation, UpsertStopAreaMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpsertStopAreaMutation, UpsertStopAreaMutationVariables>(UpsertStopAreaDocument, options);
      }
export type UpsertStopAreaMutationHookResult = ReturnType<typeof useUpsertStopAreaMutation>;
export type UpsertStopAreaMutationResult = Apollo.MutationResult<UpsertStopAreaMutation>;
export type UpsertStopAreaMutationOptions = Apollo.BaseMutationOptions<UpsertStopAreaMutation, UpsertStopAreaMutationVariables>;
export const FindStopAreasByNamesDocument = gql`
    query FindStopAreasByNames($query: String!) {
  stops_database {
    areas: stops_database_stop_place_newest_version(
      where: {_or: [{name_value: {_ilike: $query}}, {stop_place_alternative_names: {alternative_name: {name_value: {_ilike: $query}}}}, {private_code_value: {_ilike: $query}}]}
    ) {
      ...StopFormStopAreaInfo
    }
  }
}
    ${StopFormStopAreaInfoFragmentDoc}`;

/**
 * __useFindStopAreasByNamesQuery__
 *
 * To run a query within a React component, call `useFindStopAreasByNamesQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindStopAreasByNamesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindStopAreasByNamesQuery({
 *   variables: {
 *      query: // value for 'query'
 *   },
 * });
 */
export function useFindStopAreasByNamesQuery(baseOptions: Apollo.QueryHookOptions<FindStopAreasByNamesQuery, FindStopAreasByNamesQueryVariables> & ({ variables: FindStopAreasByNamesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FindStopAreasByNamesQuery, FindStopAreasByNamesQueryVariables>(FindStopAreasByNamesDocument, options);
      }
export function useFindStopAreasByNamesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FindStopAreasByNamesQuery, FindStopAreasByNamesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FindStopAreasByNamesQuery, FindStopAreasByNamesQueryVariables>(FindStopAreasByNamesDocument, options);
        }
export function useFindStopAreasByNamesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<FindStopAreasByNamesQuery, FindStopAreasByNamesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FindStopAreasByNamesQuery, FindStopAreasByNamesQueryVariables>(FindStopAreasByNamesDocument, options);
        }
export type FindStopAreasByNamesQueryHookResult = ReturnType<typeof useFindStopAreasByNamesQuery>;
export type FindStopAreasByNamesLazyQueryHookResult = ReturnType<typeof useFindStopAreasByNamesLazyQuery>;
export type FindStopAreasByNamesSuspenseQueryHookResult = ReturnType<typeof useFindStopAreasByNamesSuspenseQuery>;
export type FindStopAreasByNamesQueryResult = Apollo.QueryResult<FindStopAreasByNamesQuery, FindStopAreasByNamesQueryVariables>;
export const GetExistingQuayPublicCodesDocument = gql`
    query GetExistingQuayPublicCodes($newStopLocation: geometry!, $distanceToNearbyStops: Float!) {
  stopsDatabase: stops_database {
    municipality: stops_database_topographic_place(
      where: {topographic_place_type: {_eq: "MUNICIPALITY"}, persistable_polygon: {polygon: {_st_contains: $newStopLocation}}}
      limit: 1
    ) {
      id
      name: name_value
    }
    usedPublicCodes: stops_database_quay(distinct_on: [public_code]) {
      id
      publicCode: public_code
    }
    nearbyStops: stops_database_quay(
      where: {centroid: {_st_d_within: {distance: $distanceToNearbyStops, from: $newStopLocation}}}
      distinct_on: [public_code]
    ) {
      id
      publicCode: public_code
      centroid
    }
  }
}
    `;

/**
 * __useGetExistingQuayPublicCodesQuery__
 *
 * To run a query within a React component, call `useGetExistingQuayPublicCodesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetExistingQuayPublicCodesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetExistingQuayPublicCodesQuery({
 *   variables: {
 *      newStopLocation: // value for 'newStopLocation'
 *      distanceToNearbyStops: // value for 'distanceToNearbyStops'
 *   },
 * });
 */
export function useGetExistingQuayPublicCodesQuery(baseOptions: Apollo.QueryHookOptions<GetExistingQuayPublicCodesQuery, GetExistingQuayPublicCodesQueryVariables> & ({ variables: GetExistingQuayPublicCodesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetExistingQuayPublicCodesQuery, GetExistingQuayPublicCodesQueryVariables>(GetExistingQuayPublicCodesDocument, options);
      }
export function useGetExistingQuayPublicCodesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetExistingQuayPublicCodesQuery, GetExistingQuayPublicCodesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetExistingQuayPublicCodesQuery, GetExistingQuayPublicCodesQueryVariables>(GetExistingQuayPublicCodesDocument, options);
        }
export function useGetExistingQuayPublicCodesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetExistingQuayPublicCodesQuery, GetExistingQuayPublicCodesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetExistingQuayPublicCodesQuery, GetExistingQuayPublicCodesQueryVariables>(GetExistingQuayPublicCodesDocument, options);
        }
export type GetExistingQuayPublicCodesQueryHookResult = ReturnType<typeof useGetExistingQuayPublicCodesQuery>;
export type GetExistingQuayPublicCodesLazyQueryHookResult = ReturnType<typeof useGetExistingQuayPublicCodesLazyQuery>;
export type GetExistingQuayPublicCodesSuspenseQueryHookResult = ReturnType<typeof useGetExistingQuayPublicCodesSuspenseQuery>;
export type GetExistingQuayPublicCodesQueryResult = Apollo.QueryResult<GetExistingQuayPublicCodesQuery, GetExistingQuayPublicCodesQueryVariables>;
export const GetStopInfoForEditingOnMapDocument = gql`
    query GetStopInfoForEditingOnMap($quayNetexId: String!) {
  stops_database {
    quay: stops_database_quay_newest_version(where: {netex_id: {_eq: $quayNetexId}}) {
      id
      netextId: netex_id
      label: public_code
      versionName: version_comment
      centroid
      locationValue: description_value
      locationLang: description_lang
      alternativeLocations: quay_alternative_names {
        location: alternative_name {
          type: name_type
          lang: name_lang
          value: name_value
        }
      }
      priority
      validityStart: validity_start
      validityEnd: validity_end
      keyValues: quay_key_values {
        key: key_values_key
        values: value {
          valueItems: value_items {
            items
          }
        }
      }
      stopPlace: stop_place_newest_version {
        ...StopFormStopAreaInfo
      }
      stopPoint: scheduled_stop_point_instance {
        id: scheduled_stop_point_id
        closestPointOnInfraLink: closest_point_on_infrastructure_link
        timingPlace: timing_place {
          ...StopInfoTimingPlaceInfo
        }
      }
    }
  }
}
    ${StopFormStopAreaInfoFragmentDoc}
${StopInfoTimingPlaceInfoFragmentDoc}`;

/**
 * __useGetStopInfoForEditingOnMapQuery__
 *
 * To run a query within a React component, call `useGetStopInfoForEditingOnMapQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStopInfoForEditingOnMapQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStopInfoForEditingOnMapQuery({
 *   variables: {
 *      quayNetexId: // value for 'quayNetexId'
 *   },
 * });
 */
export function useGetStopInfoForEditingOnMapQuery(baseOptions: Apollo.QueryHookOptions<GetStopInfoForEditingOnMapQuery, GetStopInfoForEditingOnMapQueryVariables> & ({ variables: GetStopInfoForEditingOnMapQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStopInfoForEditingOnMapQuery, GetStopInfoForEditingOnMapQueryVariables>(GetStopInfoForEditingOnMapDocument, options);
      }
export function useGetStopInfoForEditingOnMapLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStopInfoForEditingOnMapQuery, GetStopInfoForEditingOnMapQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStopInfoForEditingOnMapQuery, GetStopInfoForEditingOnMapQueryVariables>(GetStopInfoForEditingOnMapDocument, options);
        }
export function useGetStopInfoForEditingOnMapSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetStopInfoForEditingOnMapQuery, GetStopInfoForEditingOnMapQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetStopInfoForEditingOnMapQuery, GetStopInfoForEditingOnMapQueryVariables>(GetStopInfoForEditingOnMapDocument, options);
        }
export type GetStopInfoForEditingOnMapQueryHookResult = ReturnType<typeof useGetStopInfoForEditingOnMapQuery>;
export type GetStopInfoForEditingOnMapLazyQueryHookResult = ReturnType<typeof useGetStopInfoForEditingOnMapLazyQuery>;
export type GetStopInfoForEditingOnMapSuspenseQueryHookResult = ReturnType<typeof useGetStopInfoForEditingOnMapSuspenseQuery>;
export type GetStopInfoForEditingOnMapQueryResult = Apollo.QueryResult<GetStopInfoForEditingOnMapQuery, GetStopInfoForEditingOnMapQueryVariables>;
export const GetStopAreasByLocationDocument = gql`
    query GetStopAreasByLocation($locationFilter: geometry_comparison_exp) {
  stops_database {
    areas: stops_database_stop_place_newest_version(
      where: {centroid: $locationFilter, netex_id: {_is_null: false}, parent_stop_place: {_eq: false}}
    ) {
      ...mapMinimalStopAreaDetails
    }
  }
}
    ${MapMinimalStopAreaDetailsFragmentDoc}`;

/**
 * __useGetStopAreasByLocationQuery__
 *
 * To run a query within a React component, call `useGetStopAreasByLocationQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStopAreasByLocationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStopAreasByLocationQuery({
 *   variables: {
 *      locationFilter: // value for 'locationFilter'
 *   },
 * });
 */
export function useGetStopAreasByLocationQuery(baseOptions?: Apollo.QueryHookOptions<GetStopAreasByLocationQuery, GetStopAreasByLocationQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStopAreasByLocationQuery, GetStopAreasByLocationQueryVariables>(GetStopAreasByLocationDocument, options);
      }
export function useGetStopAreasByLocationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStopAreasByLocationQuery, GetStopAreasByLocationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStopAreasByLocationQuery, GetStopAreasByLocationQueryVariables>(GetStopAreasByLocationDocument, options);
        }
export function useGetStopAreasByLocationSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetStopAreasByLocationQuery, GetStopAreasByLocationQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetStopAreasByLocationQuery, GetStopAreasByLocationQueryVariables>(GetStopAreasByLocationDocument, options);
        }
export type GetStopAreasByLocationQueryHookResult = ReturnType<typeof useGetStopAreasByLocationQuery>;
export type GetStopAreasByLocationLazyQueryHookResult = ReturnType<typeof useGetStopAreasByLocationLazyQuery>;
export type GetStopAreasByLocationSuspenseQueryHookResult = ReturnType<typeof useGetStopAreasByLocationSuspenseQuery>;
export type GetStopAreasByLocationQueryResult = Apollo.QueryResult<GetStopAreasByLocationQuery, GetStopAreasByLocationQueryVariables>;
export const GetMapStopsDocument = gql`
    query GetMapStops($where: stops_database_quay_newest_version_bool_exp) {
  stops_database {
    stops: stops_database_quay_newest_version(where: $where) {
      ...MapStopMinimalDetails
    }
  }
}
    ${MapStopMinimalDetailsFragmentDoc}`;

/**
 * __useGetMapStopsQuery__
 *
 * To run a query within a React component, call `useGetMapStopsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMapStopsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMapStopsQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useGetMapStopsQuery(baseOptions?: Apollo.QueryHookOptions<GetMapStopsQuery, GetMapStopsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMapStopsQuery, GetMapStopsQueryVariables>(GetMapStopsDocument, options);
      }
export function useGetMapStopsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMapStopsQuery, GetMapStopsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMapStopsQuery, GetMapStopsQueryVariables>(GetMapStopsDocument, options);
        }
export function useGetMapStopsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetMapStopsQuery, GetMapStopsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetMapStopsQuery, GetMapStopsQueryVariables>(GetMapStopsDocument, options);
        }
export type GetMapStopsQueryHookResult = ReturnType<typeof useGetMapStopsQuery>;
export type GetMapStopsLazyQueryHookResult = ReturnType<typeof useGetMapStopsLazyQuery>;
export type GetMapStopsSuspenseQueryHookResult = ReturnType<typeof useGetMapStopsSuspenseQuery>;
export type GetMapStopsQueryResult = Apollo.QueryResult<GetMapStopsQuery, GetMapStopsQueryVariables>;
export const GetStopTerminalsByLocationDocument = gql`
    query GetStopTerminalsByLocation($locationFilter: geometry_comparison_exp) {
  stops_database {
    terminals: stops_database_stop_place_newest_version(
      where: {centroid: $locationFilter, netex_id: {_is_null: false}, parent_stop_place: {_eq: true}}
    ) {
      ...MapMinimalTerminalDetails
    }
  }
}
    ${MapMinimalTerminalDetailsFragmentDoc}`;

/**
 * __useGetStopTerminalsByLocationQuery__
 *
 * To run a query within a React component, call `useGetStopTerminalsByLocationQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStopTerminalsByLocationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStopTerminalsByLocationQuery({
 *   variables: {
 *      locationFilter: // value for 'locationFilter'
 *   },
 * });
 */
export function useGetStopTerminalsByLocationQuery(baseOptions?: Apollo.QueryHookOptions<GetStopTerminalsByLocationQuery, GetStopTerminalsByLocationQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStopTerminalsByLocationQuery, GetStopTerminalsByLocationQueryVariables>(GetStopTerminalsByLocationDocument, options);
      }
export function useGetStopTerminalsByLocationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStopTerminalsByLocationQuery, GetStopTerminalsByLocationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStopTerminalsByLocationQuery, GetStopTerminalsByLocationQueryVariables>(GetStopTerminalsByLocationDocument, options);
        }
export function useGetStopTerminalsByLocationSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetStopTerminalsByLocationQuery, GetStopTerminalsByLocationQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetStopTerminalsByLocationQuery, GetStopTerminalsByLocationQueryVariables>(GetStopTerminalsByLocationDocument, options);
        }
export type GetStopTerminalsByLocationQueryHookResult = ReturnType<typeof useGetStopTerminalsByLocationQuery>;
export type GetStopTerminalsByLocationLazyQueryHookResult = ReturnType<typeof useGetStopTerminalsByLocationLazyQuery>;
export type GetStopTerminalsByLocationSuspenseQueryHookResult = ReturnType<typeof useGetStopTerminalsByLocationSuspenseQuery>;
export type GetStopTerminalsByLocationQueryResult = Apollo.QueryResult<GetStopTerminalsByLocationQuery, GetStopTerminalsByLocationQueryVariables>;
export const GetTerminalDetailsByNetexIdDocument = gql`
    query GetTerminalDetailsByNetexId($netexId: String!) {
  stop_registry {
    stopPlace(id: $netexId) {
      ...parent_stop_place_details
    }
  }
}
    ${ParentStopPlaceDetailsFragmentDoc}`;

/**
 * __useGetTerminalDetailsByNetexIdQuery__
 *
 * To run a query within a React component, call `useGetTerminalDetailsByNetexIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTerminalDetailsByNetexIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTerminalDetailsByNetexIdQuery({
 *   variables: {
 *      netexId: // value for 'netexId'
 *   },
 * });
 */
export function useGetTerminalDetailsByNetexIdQuery(baseOptions: Apollo.QueryHookOptions<GetTerminalDetailsByNetexIdQuery, GetTerminalDetailsByNetexIdQueryVariables> & ({ variables: GetTerminalDetailsByNetexIdQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTerminalDetailsByNetexIdQuery, GetTerminalDetailsByNetexIdQueryVariables>(GetTerminalDetailsByNetexIdDocument, options);
      }
export function useGetTerminalDetailsByNetexIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTerminalDetailsByNetexIdQuery, GetTerminalDetailsByNetexIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTerminalDetailsByNetexIdQuery, GetTerminalDetailsByNetexIdQueryVariables>(GetTerminalDetailsByNetexIdDocument, options);
        }
export function useGetTerminalDetailsByNetexIdSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetTerminalDetailsByNetexIdQuery, GetTerminalDetailsByNetexIdQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTerminalDetailsByNetexIdQuery, GetTerminalDetailsByNetexIdQueryVariables>(GetTerminalDetailsByNetexIdDocument, options);
        }
export type GetTerminalDetailsByNetexIdQueryHookResult = ReturnType<typeof useGetTerminalDetailsByNetexIdQuery>;
export type GetTerminalDetailsByNetexIdLazyQueryHookResult = ReturnType<typeof useGetTerminalDetailsByNetexIdLazyQuery>;
export type GetTerminalDetailsByNetexIdSuspenseQueryHookResult = ReturnType<typeof useGetTerminalDetailsByNetexIdSuspenseQuery>;
export type GetTerminalDetailsByNetexIdQueryResult = Apollo.QueryResult<GetTerminalDetailsByNetexIdQuery, GetTerminalDetailsByNetexIdQueryVariables>;
export const ResolveStopNameDocument = gql`
    query ResolveStopName($stopPlaceNetexId: String!) {
  stops_database {
    stops_database_stop_place_newest_version(
      where: {netex_id: {_eq: $stopPlaceNetexId}}
    ) {
      id
      name_value
    }
  }
}
    `;

/**
 * __useResolveStopNameQuery__
 *
 * To run a query within a React component, call `useResolveStopNameQuery` and pass it any options that fit your needs.
 * When your component renders, `useResolveStopNameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useResolveStopNameQuery({
 *   variables: {
 *      stopPlaceNetexId: // value for 'stopPlaceNetexId'
 *   },
 * });
 */
export function useResolveStopNameQuery(baseOptions: Apollo.QueryHookOptions<ResolveStopNameQuery, ResolveStopNameQueryVariables> & ({ variables: ResolveStopNameQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ResolveStopNameQuery, ResolveStopNameQueryVariables>(ResolveStopNameDocument, options);
      }
export function useResolveStopNameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ResolveStopNameQuery, ResolveStopNameQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ResolveStopNameQuery, ResolveStopNameQueryVariables>(ResolveStopNameDocument, options);
        }
export function useResolveStopNameSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<ResolveStopNameQuery, ResolveStopNameQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ResolveStopNameQuery, ResolveStopNameQueryVariables>(ResolveStopNameDocument, options);
        }
export type ResolveStopNameQueryHookResult = ReturnType<typeof useResolveStopNameQuery>;
export type ResolveStopNameLazyQueryHookResult = ReturnType<typeof useResolveStopNameLazyQuery>;
export type ResolveStopNameSuspenseQueryHookResult = ReturnType<typeof useResolveStopNameSuspenseQuery>;
export type ResolveStopNameQueryResult = Apollo.QueryResult<ResolveStopNameQuery, ResolveStopNameQueryVariables>;
export const ListChangingRoutesDocument = gql`
    query ListChangingRoutes($limit: Int) {
  route_route(limit: $limit, order_by: [{label: asc}, {validity_start: asc}]) {
    ...route_table_row
  }
}
    ${RouteTableRowFragmentDoc}`;

/**
 * __useListChangingRoutesQuery__
 *
 * To run a query within a React component, call `useListChangingRoutesQuery` and pass it any options that fit your needs.
 * When your component renders, `useListChangingRoutesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListChangingRoutesQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useListChangingRoutesQuery(baseOptions?: Apollo.QueryHookOptions<ListChangingRoutesQuery, ListChangingRoutesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ListChangingRoutesQuery, ListChangingRoutesQueryVariables>(ListChangingRoutesDocument, options);
      }
export function useListChangingRoutesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListChangingRoutesQuery, ListChangingRoutesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ListChangingRoutesQuery, ListChangingRoutesQueryVariables>(ListChangingRoutesDocument, options);
        }
export function useListChangingRoutesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<ListChangingRoutesQuery, ListChangingRoutesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ListChangingRoutesQuery, ListChangingRoutesQueryVariables>(ListChangingRoutesDocument, options);
        }
export type ListChangingRoutesQueryHookResult = ReturnType<typeof useListChangingRoutesQuery>;
export type ListChangingRoutesLazyQueryHookResult = ReturnType<typeof useListChangingRoutesLazyQuery>;
export type ListChangingRoutesSuspenseQueryHookResult = ReturnType<typeof useListChangingRoutesSuspenseQuery>;
export type ListChangingRoutesQueryResult = Apollo.QueryResult<ListChangingRoutesQuery, ListChangingRoutesQueryVariables>;
export const ListOwnLinesDocument = gql`
    query ListOwnLines($limit: Int = 10) {
  route_line(limit: $limit, order_by: [{label: asc}, {validity_start: asc}]) {
    ...line_table_row
  }
}
    ${LineTableRowFragmentDoc}`;

/**
 * __useListOwnLinesQuery__
 *
 * To run a query within a React component, call `useListOwnLinesQuery` and pass it any options that fit your needs.
 * When your component renders, `useListOwnLinesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListOwnLinesQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useListOwnLinesQuery(baseOptions?: Apollo.QueryHookOptions<ListOwnLinesQuery, ListOwnLinesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ListOwnLinesQuery, ListOwnLinesQueryVariables>(ListOwnLinesDocument, options);
      }
export function useListOwnLinesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListOwnLinesQuery, ListOwnLinesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ListOwnLinesQuery, ListOwnLinesQueryVariables>(ListOwnLinesDocument, options);
        }
export function useListOwnLinesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<ListOwnLinesQuery, ListOwnLinesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ListOwnLinesQuery, ListOwnLinesQueryVariables>(ListOwnLinesDocument, options);
        }
export type ListOwnLinesQueryHookResult = ReturnType<typeof useListOwnLinesQuery>;
export type ListOwnLinesLazyQueryHookResult = ReturnType<typeof useListOwnLinesLazyQuery>;
export type ListOwnLinesSuspenseQueryHookResult = ReturnType<typeof useListOwnLinesSuspenseQuery>;
export type ListOwnLinesQueryResult = Apollo.QueryResult<ListOwnLinesQuery, ListOwnLinesQueryVariables>;
export const GetScheduledStopPointWithTimingSettingsDocument = gql`
    query GetScheduledStopPointWithTimingSettings($journeyPatternId: uuid!, $stopLabel: String!, $sequence: Int!) {
  journey_pattern_scheduled_stop_point_in_journey_pattern(
    where: {journey_pattern_id: {_eq: $journeyPatternId}, scheduled_stop_point_label: {_eq: $stopLabel}, scheduled_stop_point_sequence: {_eq: $sequence}}
  ) {
    ...scheduled_stop_point_with_timing_settings
  }
}
    ${ScheduledStopPointWithTimingSettingsFragmentDoc}`;

/**
 * __useGetScheduledStopPointWithTimingSettingsQuery__
 *
 * To run a query within a React component, call `useGetScheduledStopPointWithTimingSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetScheduledStopPointWithTimingSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetScheduledStopPointWithTimingSettingsQuery({
 *   variables: {
 *      journeyPatternId: // value for 'journeyPatternId'
 *      stopLabel: // value for 'stopLabel'
 *      sequence: // value for 'sequence'
 *   },
 * });
 */
export function useGetScheduledStopPointWithTimingSettingsQuery(baseOptions: Apollo.QueryHookOptions<GetScheduledStopPointWithTimingSettingsQuery, GetScheduledStopPointWithTimingSettingsQueryVariables> & ({ variables: GetScheduledStopPointWithTimingSettingsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetScheduledStopPointWithTimingSettingsQuery, GetScheduledStopPointWithTimingSettingsQueryVariables>(GetScheduledStopPointWithTimingSettingsDocument, options);
      }
export function useGetScheduledStopPointWithTimingSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetScheduledStopPointWithTimingSettingsQuery, GetScheduledStopPointWithTimingSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetScheduledStopPointWithTimingSettingsQuery, GetScheduledStopPointWithTimingSettingsQueryVariables>(GetScheduledStopPointWithTimingSettingsDocument, options);
        }
export function useGetScheduledStopPointWithTimingSettingsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetScheduledStopPointWithTimingSettingsQuery, GetScheduledStopPointWithTimingSettingsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetScheduledStopPointWithTimingSettingsQuery, GetScheduledStopPointWithTimingSettingsQueryVariables>(GetScheduledStopPointWithTimingSettingsDocument, options);
        }
export type GetScheduledStopPointWithTimingSettingsQueryHookResult = ReturnType<typeof useGetScheduledStopPointWithTimingSettingsQuery>;
export type GetScheduledStopPointWithTimingSettingsLazyQueryHookResult = ReturnType<typeof useGetScheduledStopPointWithTimingSettingsLazyQuery>;
export type GetScheduledStopPointWithTimingSettingsSuspenseQueryHookResult = ReturnType<typeof useGetScheduledStopPointWithTimingSettingsSuspenseQuery>;
export type GetScheduledStopPointWithTimingSettingsQueryResult = Apollo.QueryResult<GetScheduledStopPointWithTimingSettingsQuery, GetScheduledStopPointWithTimingSettingsQueryVariables>;
export const FindQuaysByQueryDocument = gql`
    query findQuaysByQuery($cursor: bigint!, $limit: Int!, $query: String!) {
  stops_database {
    findStopsForTerminal(
      args: {query: $query}
      limit: $limit
      order_by: [{cursor: asc}]
      where: {cursor: {_gt: $cursor}}
    ) {
      cursor
      stops
    }
  }
}
    `;

/**
 * __useFindQuaysByQueryQuery__
 *
 * To run a query within a React component, call `useFindQuaysByQueryQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindQuaysByQueryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindQuaysByQueryQuery({
 *   variables: {
 *      cursor: // value for 'cursor'
 *      limit: // value for 'limit'
 *      query: // value for 'query'
 *   },
 * });
 */
export function useFindQuaysByQueryQuery(baseOptions: Apollo.QueryHookOptions<FindQuaysByQueryQuery, FindQuaysByQueryQueryVariables> & ({ variables: FindQuaysByQueryQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FindQuaysByQueryQuery, FindQuaysByQueryQueryVariables>(FindQuaysByQueryDocument, options);
      }
export function useFindQuaysByQueryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FindQuaysByQueryQuery, FindQuaysByQueryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FindQuaysByQueryQuery, FindQuaysByQueryQueryVariables>(FindQuaysByQueryDocument, options);
        }
export function useFindQuaysByQuerySuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<FindQuaysByQueryQuery, FindQuaysByQueryQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FindQuaysByQueryQuery, FindQuaysByQueryQueryVariables>(FindQuaysByQueryDocument, options);
        }
export type FindQuaysByQueryQueryHookResult = ReturnType<typeof useFindQuaysByQueryQuery>;
export type FindQuaysByQueryLazyQueryHookResult = ReturnType<typeof useFindQuaysByQueryLazyQuery>;
export type FindQuaysByQuerySuspenseQueryHookResult = ReturnType<typeof useFindQuaysByQuerySuspenseQuery>;
export type FindQuaysByQueryQueryResult = Apollo.QueryResult<FindQuaysByQueryQuery, FindQuaysByQueryQueryVariables>;
export const DoesStopHaveNextValidAlternativeDocument = gql`
    query DoesStopHaveNextValidAlternative($label: String!, $validAfter: date!, $validPriorities: [Int!]!) {
  stopPoint: service_pattern_scheduled_stop_point_aggregate(
    where: {_and: [{label: {_eq: $label}}, {priority: {_in: $validPriorities}}, {_or: [{validity_end: {_is_null: true}}, {validity_end: {_gt: $validAfter}}]}]}
  ) {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useDoesStopHaveNextValidAlternativeQuery__
 *
 * To run a query within a React component, call `useDoesStopHaveNextValidAlternativeQuery` and pass it any options that fit your needs.
 * When your component renders, `useDoesStopHaveNextValidAlternativeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDoesStopHaveNextValidAlternativeQuery({
 *   variables: {
 *      label: // value for 'label'
 *      validAfter: // value for 'validAfter'
 *      validPriorities: // value for 'validPriorities'
 *   },
 * });
 */
export function useDoesStopHaveNextValidAlternativeQuery(baseOptions: Apollo.QueryHookOptions<DoesStopHaveNextValidAlternativeQuery, DoesStopHaveNextValidAlternativeQueryVariables> & ({ variables: DoesStopHaveNextValidAlternativeQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DoesStopHaveNextValidAlternativeQuery, DoesStopHaveNextValidAlternativeQueryVariables>(DoesStopHaveNextValidAlternativeDocument, options);
      }
export function useDoesStopHaveNextValidAlternativeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DoesStopHaveNextValidAlternativeQuery, DoesStopHaveNextValidAlternativeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DoesStopHaveNextValidAlternativeQuery, DoesStopHaveNextValidAlternativeQueryVariables>(DoesStopHaveNextValidAlternativeDocument, options);
        }
export function useDoesStopHaveNextValidAlternativeSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<DoesStopHaveNextValidAlternativeQuery, DoesStopHaveNextValidAlternativeQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<DoesStopHaveNextValidAlternativeQuery, DoesStopHaveNextValidAlternativeQueryVariables>(DoesStopHaveNextValidAlternativeDocument, options);
        }
export type DoesStopHaveNextValidAlternativeQueryHookResult = ReturnType<typeof useDoesStopHaveNextValidAlternativeQuery>;
export type DoesStopHaveNextValidAlternativeLazyQueryHookResult = ReturnType<typeof useDoesStopHaveNextValidAlternativeLazyQuery>;
export type DoesStopHaveNextValidAlternativeSuspenseQueryHookResult = ReturnType<typeof useDoesStopHaveNextValidAlternativeSuspenseQuery>;
export type DoesStopHaveNextValidAlternativeQueryResult = Apollo.QueryResult<DoesStopHaveNextValidAlternativeQuery, DoesStopHaveNextValidAlternativeQueryVariables>;
export const FindLinesByStopSearchDocument = gql`
    query findLinesByStopSearch($query: String!, $validOn: date!) {
  route_line(
    where: {label: {_ilike: $query}, validity_start: {_lte: $validOn}, _or: [{validity_end: {_gte: $validOn}}, {validity_end: {_is_null: true}}]}
    order_by: [{label: asc}, {priority: desc}]
    distinct_on: [label, priority]
  ) {
    ...FindStopByLineInfo
  }
}
    ${FindStopByLineInfoFragmentDoc}`;

/**
 * __useFindLinesByStopSearchQuery__
 *
 * To run a query within a React component, call `useFindLinesByStopSearchQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindLinesByStopSearchQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindLinesByStopSearchQuery({
 *   variables: {
 *      query: // value for 'query'
 *      validOn: // value for 'validOn'
 *   },
 * });
 */
export function useFindLinesByStopSearchQuery(baseOptions: Apollo.QueryHookOptions<FindLinesByStopSearchQuery, FindLinesByStopSearchQueryVariables> & ({ variables: FindLinesByStopSearchQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FindLinesByStopSearchQuery, FindLinesByStopSearchQueryVariables>(FindLinesByStopSearchDocument, options);
      }
export function useFindLinesByStopSearchLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FindLinesByStopSearchQuery, FindLinesByStopSearchQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FindLinesByStopSearchQuery, FindLinesByStopSearchQueryVariables>(FindLinesByStopSearchDocument, options);
        }
export function useFindLinesByStopSearchSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<FindLinesByStopSearchQuery, FindLinesByStopSearchQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FindLinesByStopSearchQuery, FindLinesByStopSearchQueryVariables>(FindLinesByStopSearchDocument, options);
        }
export type FindLinesByStopSearchQueryHookResult = ReturnType<typeof useFindLinesByStopSearchQuery>;
export type FindLinesByStopSearchLazyQueryHookResult = ReturnType<typeof useFindLinesByStopSearchLazyQuery>;
export type FindLinesByStopSearchSuspenseQueryHookResult = ReturnType<typeof useFindLinesByStopSearchSuspenseQuery>;
export type FindLinesByStopSearchQueryResult = Apollo.QueryResult<FindLinesByStopSearchQuery, FindLinesByStopSearchQueryVariables>;
export const GetLineRouteStopCountsDocument = gql`
    query GetLineRouteStopCounts($inboundRoute: uuid!, $outboundRoute: uuid!) {
  combinedStopPoints: service_pattern_scheduled_stop_point_aggregate(
    where: {scheduled_stop_point_in_journey_patterns: {journey_pattern: {on_route_id: {_in: [$inboundRoute, $outboundRoute]}}}}
    distinct_on: [label]
  ) {
    aggregate {
      count
    }
  }
  inboundStopPoints: service_pattern_scheduled_stop_point_aggregate(
    where: {scheduled_stop_point_in_journey_patterns: {journey_pattern: {on_route_id: {_eq: $inboundRoute}}}}
    distinct_on: [label]
  ) {
    aggregate {
      count
    }
  }
  outboundStopPoints: service_pattern_scheduled_stop_point_aggregate(
    where: {scheduled_stop_point_in_journey_patterns: {journey_pattern: {on_route_id: {_eq: $outboundRoute}}}}
    distinct_on: [label]
  ) {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useGetLineRouteStopCountsQuery__
 *
 * To run a query within a React component, call `useGetLineRouteStopCountsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLineRouteStopCountsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLineRouteStopCountsQuery({
 *   variables: {
 *      inboundRoute: // value for 'inboundRoute'
 *      outboundRoute: // value for 'outboundRoute'
 *   },
 * });
 */
export function useGetLineRouteStopCountsQuery(baseOptions: Apollo.QueryHookOptions<GetLineRouteStopCountsQuery, GetLineRouteStopCountsQueryVariables> & ({ variables: GetLineRouteStopCountsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetLineRouteStopCountsQuery, GetLineRouteStopCountsQueryVariables>(GetLineRouteStopCountsDocument, options);
      }
export function useGetLineRouteStopCountsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetLineRouteStopCountsQuery, GetLineRouteStopCountsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetLineRouteStopCountsQuery, GetLineRouteStopCountsQueryVariables>(GetLineRouteStopCountsDocument, options);
        }
export function useGetLineRouteStopCountsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetLineRouteStopCountsQuery, GetLineRouteStopCountsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetLineRouteStopCountsQuery, GetLineRouteStopCountsQueryVariables>(GetLineRouteStopCountsDocument, options);
        }
export type GetLineRouteStopCountsQueryHookResult = ReturnType<typeof useGetLineRouteStopCountsQuery>;
export type GetLineRouteStopCountsLazyQueryHookResult = ReturnType<typeof useGetLineRouteStopCountsLazyQuery>;
export type GetLineRouteStopCountsSuspenseQueryHookResult = ReturnType<typeof useGetLineRouteStopCountsSuspenseQuery>;
export type GetLineRouteStopCountsQueryResult = Apollo.QueryResult<GetLineRouteStopCountsQuery, GetLineRouteStopCountsQueryVariables>;
export const GetStopsByRouteIdDocument = gql`
    query getStopsByRouteId($routeId: uuid!) {
  stopPoints: service_pattern_scheduled_stop_point(
    where: {scheduled_stop_point_in_journey_patterns: {journey_pattern: {on_route_id: {_eq: $routeId}}}}
  ) {
    ...GetStopByRouteIdSearchResult
  }
}
    ${GetStopByRouteIdSearchResultFragmentDoc}`;

/**
 * __useGetStopsByRouteIdQuery__
 *
 * To run a query within a React component, call `useGetStopsByRouteIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStopsByRouteIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStopsByRouteIdQuery({
 *   variables: {
 *      routeId: // value for 'routeId'
 *   },
 * });
 */
export function useGetStopsByRouteIdQuery(baseOptions: Apollo.QueryHookOptions<GetStopsByRouteIdQuery, GetStopsByRouteIdQueryVariables> & ({ variables: GetStopsByRouteIdQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStopsByRouteIdQuery, GetStopsByRouteIdQueryVariables>(GetStopsByRouteIdDocument, options);
      }
export function useGetStopsByRouteIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStopsByRouteIdQuery, GetStopsByRouteIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStopsByRouteIdQuery, GetStopsByRouteIdQueryVariables>(GetStopsByRouteIdDocument, options);
        }
export function useGetStopsByRouteIdSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetStopsByRouteIdQuery, GetStopsByRouteIdQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetStopsByRouteIdQuery, GetStopsByRouteIdQueryVariables>(GetStopsByRouteIdDocument, options);
        }
export type GetStopsByRouteIdQueryHookResult = ReturnType<typeof useGetStopsByRouteIdQuery>;
export type GetStopsByRouteIdLazyQueryHookResult = ReturnType<typeof useGetStopsByRouteIdLazyQuery>;
export type GetStopsByRouteIdSuspenseQueryHookResult = ReturnType<typeof useGetStopsByRouteIdSuspenseQuery>;
export type GetStopsByRouteIdQueryResult = Apollo.QueryResult<GetStopsByRouteIdQuery, GetStopsByRouteIdQueryVariables>;
export const ResolveStopPlaceNetextIdsByLineIdsDocument = gql`
    query ResolveStopPlaceNetextIdsByLineIds($routeIds: [uuid!]!) {
  stopPoints: service_pattern_scheduled_stop_point(
    where: {scheduled_stop_point_in_journey_patterns: {journey_pattern: {on_route_id: {_in: $routeIds}}}, stop_place_ref: {_is_null: false}}
  ) {
    scheduled_stop_point_id
    stop_place_ref
  }
}
    `;

/**
 * __useResolveStopPlaceNetextIdsByLineIdsQuery__
 *
 * To run a query within a React component, call `useResolveStopPlaceNetextIdsByLineIdsQuery` and pass it any options that fit your needs.
 * When your component renders, `useResolveStopPlaceNetextIdsByLineIdsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useResolveStopPlaceNetextIdsByLineIdsQuery({
 *   variables: {
 *      routeIds: // value for 'routeIds'
 *   },
 * });
 */
export function useResolveStopPlaceNetextIdsByLineIdsQuery(baseOptions: Apollo.QueryHookOptions<ResolveStopPlaceNetextIdsByLineIdsQuery, ResolveStopPlaceNetextIdsByLineIdsQueryVariables> & ({ variables: ResolveStopPlaceNetextIdsByLineIdsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ResolveStopPlaceNetextIdsByLineIdsQuery, ResolveStopPlaceNetextIdsByLineIdsQueryVariables>(ResolveStopPlaceNetextIdsByLineIdsDocument, options);
      }
export function useResolveStopPlaceNetextIdsByLineIdsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ResolveStopPlaceNetextIdsByLineIdsQuery, ResolveStopPlaceNetextIdsByLineIdsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ResolveStopPlaceNetextIdsByLineIdsQuery, ResolveStopPlaceNetextIdsByLineIdsQueryVariables>(ResolveStopPlaceNetextIdsByLineIdsDocument, options);
        }
export function useResolveStopPlaceNetextIdsByLineIdsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<ResolveStopPlaceNetextIdsByLineIdsQuery, ResolveStopPlaceNetextIdsByLineIdsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ResolveStopPlaceNetextIdsByLineIdsQuery, ResolveStopPlaceNetextIdsByLineIdsQueryVariables>(ResolveStopPlaceNetextIdsByLineIdsDocument, options);
        }
export type ResolveStopPlaceNetextIdsByLineIdsQueryHookResult = ReturnType<typeof useResolveStopPlaceNetextIdsByLineIdsQuery>;
export type ResolveStopPlaceNetextIdsByLineIdsLazyQueryHookResult = ReturnType<typeof useResolveStopPlaceNetextIdsByLineIdsLazyQuery>;
export type ResolveStopPlaceNetextIdsByLineIdsSuspenseQueryHookResult = ReturnType<typeof useResolveStopPlaceNetextIdsByLineIdsSuspenseQuery>;
export type ResolveStopPlaceNetextIdsByLineIdsQueryResult = Apollo.QueryResult<ResolveStopPlaceNetextIdsByLineIdsQuery, ResolveStopPlaceNetextIdsByLineIdsQueryVariables>;
export const FindStopAreasDocument = gql`
    query findStopAreas($query: String!, $validOn: String!) {
  stops_database {
    stopAreas: stops_database_stop_place_newest_version(
      where: {_and: [{_or: [{private_code_value: {_ilike: $query}}, {name_value: {_ilike: $query}}, {stop_place_alternative_names: {alternative_name: {name_value: {_ilike: $query}}}}]}, {validity_start: {_lte: $validOn}}, {_or: [{validity_end: {_gte: $validOn}}, {validity_end: {_is_null: true}}]}]}
      order_by: [{netex_id: asc}, {version: desc}]
    ) {
      ...FindStopAreaInfo
    }
  }
}
    ${FindStopAreaInfoFragmentDoc}`;

/**
 * __useFindStopAreasQuery__
 *
 * To run a query within a React component, call `useFindStopAreasQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindStopAreasQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindStopAreasQuery({
 *   variables: {
 *      query: // value for 'query'
 *      validOn: // value for 'validOn'
 *   },
 * });
 */
export function useFindStopAreasQuery(baseOptions: Apollo.QueryHookOptions<FindStopAreasQuery, FindStopAreasQueryVariables> & ({ variables: FindStopAreasQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FindStopAreasQuery, FindStopAreasQueryVariables>(FindStopAreasDocument, options);
      }
export function useFindStopAreasLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FindStopAreasQuery, FindStopAreasQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FindStopAreasQuery, FindStopAreasQueryVariables>(FindStopAreasDocument, options);
        }
export function useFindStopAreasSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<FindStopAreasQuery, FindStopAreasQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FindStopAreasQuery, FindStopAreasQueryVariables>(FindStopAreasDocument, options);
        }
export type FindStopAreasQueryHookResult = ReturnType<typeof useFindStopAreasQuery>;
export type FindStopAreasLazyQueryHookResult = ReturnType<typeof useFindStopAreasLazyQuery>;
export type FindStopAreasSuspenseQueryHookResult = ReturnType<typeof useFindStopAreasSuspenseQuery>;
export type FindStopAreasQueryResult = Apollo.QueryResult<FindStopAreasQuery, FindStopAreasQueryVariables>;
export const GetStopsByStopAreaIdDocument = gql`
    query getStopsByStopAreaId($stopAreaId: bigint!) {
  stops_database {
    quays: stops_database_quay_newest_version(
      where: {stop_place_id: {_eq: $stopAreaId}}
      order_by: [{public_code: asc}]
    ) {
      ...stop_table_row_quay
    }
  }
}
    ${StopTableRowQuayFragmentDoc}`;

/**
 * __useGetStopsByStopAreaIdQuery__
 *
 * To run a query within a React component, call `useGetStopsByStopAreaIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStopsByStopAreaIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStopsByStopAreaIdQuery({
 *   variables: {
 *      stopAreaId: // value for 'stopAreaId'
 *   },
 * });
 */
export function useGetStopsByStopAreaIdQuery(baseOptions: Apollo.QueryHookOptions<GetStopsByStopAreaIdQuery, GetStopsByStopAreaIdQueryVariables> & ({ variables: GetStopsByStopAreaIdQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStopsByStopAreaIdQuery, GetStopsByStopAreaIdQueryVariables>(GetStopsByStopAreaIdDocument, options);
      }
export function useGetStopsByStopAreaIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStopsByStopAreaIdQuery, GetStopsByStopAreaIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStopsByStopAreaIdQuery, GetStopsByStopAreaIdQueryVariables>(GetStopsByStopAreaIdDocument, options);
        }
export function useGetStopsByStopAreaIdSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetStopsByStopAreaIdQuery, GetStopsByStopAreaIdQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetStopsByStopAreaIdQuery, GetStopsByStopAreaIdQueryVariables>(GetStopsByStopAreaIdDocument, options);
        }
export type GetStopsByStopAreaIdQueryHookResult = ReturnType<typeof useGetStopsByStopAreaIdQuery>;
export type GetStopsByStopAreaIdLazyQueryHookResult = ReturnType<typeof useGetStopsByStopAreaIdLazyQuery>;
export type GetStopsByStopAreaIdSuspenseQueryHookResult = ReturnType<typeof useGetStopsByStopAreaIdSuspenseQuery>;
export type GetStopsByStopAreaIdQueryResult = Apollo.QueryResult<GetStopsByStopAreaIdQuery, GetStopsByStopAreaIdQueryVariables>;
export const SearchStopsDocument = gql`
    query SearchStops($where: stops_database_quay_newest_version_bool_exp, $orderBy: [stops_database_quay_newest_version_order_by!]!, $offset: Int!, $limit: Int!) {
  stops_database {
    stops: stops_database_quay_newest_version(
      where: $where
      order_by: $orderBy
      offset: $offset
      limit: $limit
    ) {
      ...stop_table_row_quay
    }
    resultCount: stops_database_quay_newest_version_aggregate(where: $where) {
      aggregate {
        count
      }
    }
  }
}
    ${StopTableRowQuayFragmentDoc}`;

/**
 * __useSearchStopsQuery__
 *
 * To run a query within a React component, call `useSearchStopsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchStopsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchStopsQuery({
 *   variables: {
 *      where: // value for 'where'
 *      orderBy: // value for 'orderBy'
 *      offset: // value for 'offset'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useSearchStopsQuery(baseOptions: Apollo.QueryHookOptions<SearchStopsQuery, SearchStopsQueryVariables> & ({ variables: SearchStopsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchStopsQuery, SearchStopsQueryVariables>(SearchStopsDocument, options);
      }
export function useSearchStopsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchStopsQuery, SearchStopsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchStopsQuery, SearchStopsQueryVariables>(SearchStopsDocument, options);
        }
export function useSearchStopsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<SearchStopsQuery, SearchStopsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SearchStopsQuery, SearchStopsQueryVariables>(SearchStopsDocument, options);
        }
export type SearchStopsQueryHookResult = ReturnType<typeof useSearchStopsQuery>;
export type SearchStopsLazyQueryHookResult = ReturnType<typeof useSearchStopsLazyQuery>;
export type SearchStopsSuspenseQueryHookResult = ReturnType<typeof useSearchStopsSuspenseQuery>;
export type SearchStopsQueryResult = Apollo.QueryResult<SearchStopsQuery, SearchStopsQueryVariables>;
export const MoveQuayToStopPlaceDocument = gql`
    mutation moveQuayToStopPlace($toStopPlaceId: String!, $quayIds: [String!]!, $moveQuayFromDate: stop_registry_LocalDate!, $fromVersionComment: String!, $toVersionComment: String!) {
  stop_registry {
    moveQuaysToStop(
      toStopPlaceId: $toStopPlaceId
      quayIds: $quayIds
      moveQuayFromDate: $moveQuayFromDate
      fromVersionComment: $fromVersionComment
      toVersionComment: $toVersionComment
    ) {
      ... on stop_registry_StopPlace {
        id
        version
        versionComment
        quays {
          id
          publicCode
          keyValues {
            key
            values
          }
        }
      }
    }
  }
}
    `;
export type MoveQuayToStopPlaceMutationFn = Apollo.MutationFunction<MoveQuayToStopPlaceMutation, MoveQuayToStopPlaceMutationVariables>;

/**
 * __useMoveQuayToStopPlaceMutation__
 *
 * To run a mutation, you first call `useMoveQuayToStopPlaceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useMoveQuayToStopPlaceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [moveQuayToStopPlaceMutation, { data, loading, error }] = useMoveQuayToStopPlaceMutation({
 *   variables: {
 *      toStopPlaceId: // value for 'toStopPlaceId'
 *      quayIds: // value for 'quayIds'
 *      moveQuayFromDate: // value for 'moveQuayFromDate'
 *      fromVersionComment: // value for 'fromVersionComment'
 *      toVersionComment: // value for 'toVersionComment'
 *   },
 * });
 */
export function useMoveQuayToStopPlaceMutation(baseOptions?: Apollo.MutationHookOptions<MoveQuayToStopPlaceMutation, MoveQuayToStopPlaceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<MoveQuayToStopPlaceMutation, MoveQuayToStopPlaceMutationVariables>(MoveQuayToStopPlaceDocument, options);
      }
export type MoveQuayToStopPlaceMutationHookResult = ReturnType<typeof useMoveQuayToStopPlaceMutation>;
export type MoveQuayToStopPlaceMutationResult = Apollo.MutationResult<MoveQuayToStopPlaceMutation>;
export type MoveQuayToStopPlaceMutationOptions = Apollo.BaseMutationOptions<MoveQuayToStopPlaceMutation, MoveQuayToStopPlaceMutationVariables>;
export const GetStopPointsByQuayIdDocument = gql`
    query GetStopPointsByQuayId($quayIds: [String!]!) {
  service_pattern_scheduled_stop_point(where: {stop_place_ref: {_in: $quayIds}}) {
    scheduled_stop_point_id
    priority
    direction
    label
    timing_place_id
    validity_start
    validity_end
    located_on_infrastructure_link_id
    stop_place_ref
    measured_location
    vehicle_mode_on_scheduled_stop_point {
      vehicle_mode
    }
  }
}
    `;

/**
 * __useGetStopPointsByQuayIdQuery__
 *
 * To run a query within a React component, call `useGetStopPointsByQuayIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStopPointsByQuayIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStopPointsByQuayIdQuery({
 *   variables: {
 *      quayIds: // value for 'quayIds'
 *   },
 * });
 */
export function useGetStopPointsByQuayIdQuery(baseOptions: Apollo.QueryHookOptions<GetStopPointsByQuayIdQuery, GetStopPointsByQuayIdQueryVariables> & ({ variables: GetStopPointsByQuayIdQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStopPointsByQuayIdQuery, GetStopPointsByQuayIdQueryVariables>(GetStopPointsByQuayIdDocument, options);
      }
export function useGetStopPointsByQuayIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStopPointsByQuayIdQuery, GetStopPointsByQuayIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStopPointsByQuayIdQuery, GetStopPointsByQuayIdQueryVariables>(GetStopPointsByQuayIdDocument, options);
        }
export function useGetStopPointsByQuayIdSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetStopPointsByQuayIdQuery, GetStopPointsByQuayIdQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetStopPointsByQuayIdQuery, GetStopPointsByQuayIdQueryVariables>(GetStopPointsByQuayIdDocument, options);
        }
export type GetStopPointsByQuayIdQueryHookResult = ReturnType<typeof useGetStopPointsByQuayIdQuery>;
export type GetStopPointsByQuayIdLazyQueryHookResult = ReturnType<typeof useGetStopPointsByQuayIdLazyQuery>;
export type GetStopPointsByQuayIdSuspenseQueryHookResult = ReturnType<typeof useGetStopPointsByQuayIdSuspenseQuery>;
export type GetStopPointsByQuayIdQueryResult = Apollo.QueryResult<GetStopPointsByQuayIdQuery, GetStopPointsByQuayIdQueryVariables>;
export const UpdateStopPointDocument = gql`
    mutation UpdateStopPoint($stopId: uuid!, $changes: service_pattern_scheduled_stop_point_set_input!) {
  update_service_pattern_scheduled_stop_point(
    where: {scheduled_stop_point_id: {_eq: $stopId}}
    _set: $changes
  ) {
    returning {
      scheduled_stop_point_id
      validity_end
    }
  }
}
    `;
export type UpdateStopPointMutationFn = Apollo.MutationFunction<UpdateStopPointMutation, UpdateStopPointMutationVariables>;

/**
 * __useUpdateStopPointMutation__
 *
 * To run a mutation, you first call `useUpdateStopPointMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateStopPointMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateStopPointMutation, { data, loading, error }] = useUpdateStopPointMutation({
 *   variables: {
 *      stopId: // value for 'stopId'
 *      changes: // value for 'changes'
 *   },
 * });
 */
export function useUpdateStopPointMutation(baseOptions?: Apollo.MutationHookOptions<UpdateStopPointMutation, UpdateStopPointMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateStopPointMutation, UpdateStopPointMutationVariables>(UpdateStopPointDocument, options);
      }
export type UpdateStopPointMutationHookResult = ReturnType<typeof useUpdateStopPointMutation>;
export type UpdateStopPointMutationResult = Apollo.MutationResult<UpdateStopPointMutation>;
export type UpdateStopPointMutationOptions = Apollo.BaseMutationOptions<UpdateStopPointMutation, UpdateStopPointMutationVariables>;
export const GetOriginalQuaysDocument = gql`
    query GetOriginalQuays($quayId: String!) {
  stop_registry {
    stopPlace(query: $quayId, onlyMonomodalStopPlaces: true) {
      ... on stop_registry_StopPlace {
        quays {
          id
          publicCode
        }
      }
    }
  }
}
    `;

/**
 * __useGetOriginalQuaysQuery__
 *
 * To run a query within a React component, call `useGetOriginalQuaysQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOriginalQuaysQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOriginalQuaysQuery({
 *   variables: {
 *      quayId: // value for 'quayId'
 *   },
 * });
 */
export function useGetOriginalQuaysQuery(baseOptions: Apollo.QueryHookOptions<GetOriginalQuaysQuery, GetOriginalQuaysQueryVariables> & ({ variables: GetOriginalQuaysQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOriginalQuaysQuery, GetOriginalQuaysQueryVariables>(GetOriginalQuaysDocument, options);
      }
export function useGetOriginalQuaysLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOriginalQuaysQuery, GetOriginalQuaysQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOriginalQuaysQuery, GetOriginalQuaysQueryVariables>(GetOriginalQuaysDocument, options);
        }
export function useGetOriginalQuaysSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetOriginalQuaysQuery, GetOriginalQuaysQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetOriginalQuaysQuery, GetOriginalQuaysQueryVariables>(GetOriginalQuaysDocument, options);
        }
export type GetOriginalQuaysQueryHookResult = ReturnType<typeof useGetOriginalQuaysQuery>;
export type GetOriginalQuaysLazyQueryHookResult = ReturnType<typeof useGetOriginalQuaysLazyQuery>;
export type GetOriginalQuaysSuspenseQueryHookResult = ReturnType<typeof useGetOriginalQuaysSuspenseQuery>;
export type GetOriginalQuaysQueryResult = Apollo.QueryResult<GetOriginalQuaysQuery, GetOriginalQuaysQueryVariables>;
export const GetStopPlaceDetailsDocument = gql`
    query getStopPlaceDetails($where: stops_database_stop_place_newest_version_bool_exp) {
  stopsDb: stops_database {
    newestVersion: stops_database_stop_place_newest_version(where: $where) {
      id
      TiamatStopPlace {
        ...stop_place_details
      }
    }
  }
}
    ${StopPlaceDetailsFragmentDoc}`;

/**
 * __useGetStopPlaceDetailsQuery__
 *
 * To run a query within a React component, call `useGetStopPlaceDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStopPlaceDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStopPlaceDetailsQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useGetStopPlaceDetailsQuery(baseOptions?: Apollo.QueryHookOptions<GetStopPlaceDetailsQuery, GetStopPlaceDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStopPlaceDetailsQuery, GetStopPlaceDetailsQueryVariables>(GetStopPlaceDetailsDocument, options);
      }
export function useGetStopPlaceDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStopPlaceDetailsQuery, GetStopPlaceDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStopPlaceDetailsQuery, GetStopPlaceDetailsQueryVariables>(GetStopPlaceDetailsDocument, options);
        }
export function useGetStopPlaceDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetStopPlaceDetailsQuery, GetStopPlaceDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetStopPlaceDetailsQuery, GetStopPlaceDetailsQueryVariables>(GetStopPlaceDetailsDocument, options);
        }
export type GetStopPlaceDetailsQueryHookResult = ReturnType<typeof useGetStopPlaceDetailsQuery>;
export type GetStopPlaceDetailsLazyQueryHookResult = ReturnType<typeof useGetStopPlaceDetailsLazyQuery>;
export type GetStopPlaceDetailsSuspenseQueryHookResult = ReturnType<typeof useGetStopPlaceDetailsSuspenseQuery>;
export type GetStopPlaceDetailsQueryResult = Apollo.QueryResult<GetStopPlaceDetailsQuery, GetStopPlaceDetailsQueryVariables>;
export const GetStopPlaceVersionsDocument = gql`
    query GetStopPlaceVersions($privateCode: String!) {
  stops_database {
    stopAreas: stops_database_stop_place_newest_version(
      where: {private_code_value: {_eq: $privateCode}}
      order_by: [{validity_start: asc}, {priority: asc}]
    ) {
      ...StopAreaVersionInfo
    }
  }
}
    ${StopAreaVersionInfoFragmentDoc}`;

/**
 * __useGetStopPlaceVersionsQuery__
 *
 * To run a query within a React component, call `useGetStopPlaceVersionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStopPlaceVersionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStopPlaceVersionsQuery({
 *   variables: {
 *      privateCode: // value for 'privateCode'
 *   },
 * });
 */
export function useGetStopPlaceVersionsQuery(baseOptions: Apollo.QueryHookOptions<GetStopPlaceVersionsQuery, GetStopPlaceVersionsQueryVariables> & ({ variables: GetStopPlaceVersionsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStopPlaceVersionsQuery, GetStopPlaceVersionsQueryVariables>(GetStopPlaceVersionsDocument, options);
      }
export function useGetStopPlaceVersionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStopPlaceVersionsQuery, GetStopPlaceVersionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStopPlaceVersionsQuery, GetStopPlaceVersionsQueryVariables>(GetStopPlaceVersionsDocument, options);
        }
export function useGetStopPlaceVersionsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetStopPlaceVersionsQuery, GetStopPlaceVersionsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetStopPlaceVersionsQuery, GetStopPlaceVersionsQueryVariables>(GetStopPlaceVersionsDocument, options);
        }
export type GetStopPlaceVersionsQueryHookResult = ReturnType<typeof useGetStopPlaceVersionsQuery>;
export type GetStopPlaceVersionsLazyQueryHookResult = ReturnType<typeof useGetStopPlaceVersionsLazyQuery>;
export type GetStopPlaceVersionsSuspenseQueryHookResult = ReturnType<typeof useGetStopPlaceVersionsSuspenseQuery>;
export type GetStopPlaceVersionsQueryResult = Apollo.QueryResult<GetStopPlaceVersionsQuery, GetStopPlaceVersionsQueryVariables>;
export const DeleteQuayDocument = gql`
    mutation DeleteQuay($stopPlaceId: String!, $quayId: String!) {
  stop_registry {
    deleteQuay(stopPlaceId: $stopPlaceId, quayId: $quayId) {
      id
      version
      ... on stop_registry_StopPlace {
        quays {
          id
          version
        }
      }
    }
  }
}
    `;
export type DeleteQuayMutationFn = Apollo.MutationFunction<DeleteQuayMutation, DeleteQuayMutationVariables>;

/**
 * __useDeleteQuayMutation__
 *
 * To run a mutation, you first call `useDeleteQuayMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteQuayMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteQuayMutation, { data, loading, error }] = useDeleteQuayMutation({
 *   variables: {
 *      stopPlaceId: // value for 'stopPlaceId'
 *      quayId: // value for 'quayId'
 *   },
 * });
 */
export function useDeleteQuayMutation(baseOptions?: Apollo.MutationHookOptions<DeleteQuayMutation, DeleteQuayMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteQuayMutation, DeleteQuayMutationVariables>(DeleteQuayDocument, options);
      }
export type DeleteQuayMutationHookResult = ReturnType<typeof useDeleteQuayMutation>;
export type DeleteQuayMutationResult = Apollo.MutationResult<DeleteQuayMutation>;
export type DeleteQuayMutationOptions = Apollo.BaseMutationOptions<DeleteQuayMutation, DeleteQuayMutationVariables>;
export const EditKeyValuesOfQuayDocument = gql`
    mutation EditKeyValuesOfQuay($stopId: String!, $quayId: String!, $keyValues: [stop_registry_KeyValuesInput!]!, $versionComment: String!) {
  stop_registry {
    mutateStopPlace(
      StopPlace: {id: $stopId, quays: {id: $quayId, keyValues: $keyValues, versionComment: $versionComment}}
    ) {
      quays {
        publicCode
        keyValues {
          key
          values
        }
      }
    }
  }
}
    `;
export type EditKeyValuesOfQuayMutationFn = Apollo.MutationFunction<EditKeyValuesOfQuayMutation, EditKeyValuesOfQuayMutationVariables>;

/**
 * __useEditKeyValuesOfQuayMutation__
 *
 * To run a mutation, you first call `useEditKeyValuesOfQuayMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditKeyValuesOfQuayMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editKeyValuesOfQuayMutation, { data, loading, error }] = useEditKeyValuesOfQuayMutation({
 *   variables: {
 *      stopId: // value for 'stopId'
 *      quayId: // value for 'quayId'
 *      keyValues: // value for 'keyValues'
 *      versionComment: // value for 'versionComment'
 *   },
 * });
 */
export function useEditKeyValuesOfQuayMutation(baseOptions?: Apollo.MutationHookOptions<EditKeyValuesOfQuayMutation, EditKeyValuesOfQuayMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditKeyValuesOfQuayMutation, EditKeyValuesOfQuayMutationVariables>(EditKeyValuesOfQuayDocument, options);
      }
export type EditKeyValuesOfQuayMutationHookResult = ReturnType<typeof useEditKeyValuesOfQuayMutation>;
export type EditKeyValuesOfQuayMutationResult = Apollo.MutationResult<EditKeyValuesOfQuayMutation>;
export type EditKeyValuesOfQuayMutationOptions = Apollo.BaseMutationOptions<EditKeyValuesOfQuayMutation, EditKeyValuesOfQuayMutationVariables>;
export const EditScheduledStopPointValidityDocument = gql`
    mutation EditScheduledStopPointValidity($stopId: String!, $priority: Int!, $validityStart: date!, $validityEnd: date) {
  update_service_pattern_scheduled_stop_point(
    where: {stop_place_ref: {_eq: $stopId}}
    _set: {validity_start: $validityStart, validity_end: $validityEnd, priority: $priority}
  ) {
    returning {
      label
      priority
      stop_place_ref
      scheduled_stop_point_id
      validity_start
      validity_end
    }
  }
}
    `;
export type EditScheduledStopPointValidityMutationFn = Apollo.MutationFunction<EditScheduledStopPointValidityMutation, EditScheduledStopPointValidityMutationVariables>;

/**
 * __useEditScheduledStopPointValidityMutation__
 *
 * To run a mutation, you first call `useEditScheduledStopPointValidityMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditScheduledStopPointValidityMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editScheduledStopPointValidityMutation, { data, loading, error }] = useEditScheduledStopPointValidityMutation({
 *   variables: {
 *      stopId: // value for 'stopId'
 *      priority: // value for 'priority'
 *      validityStart: // value for 'validityStart'
 *      validityEnd: // value for 'validityEnd'
 *   },
 * });
 */
export function useEditScheduledStopPointValidityMutation(baseOptions?: Apollo.MutationHookOptions<EditScheduledStopPointValidityMutation, EditScheduledStopPointValidityMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditScheduledStopPointValidityMutation, EditScheduledStopPointValidityMutationVariables>(EditScheduledStopPointValidityDocument, options);
      }
export type EditScheduledStopPointValidityMutationHookResult = ReturnType<typeof useEditScheduledStopPointValidityMutation>;
export type EditScheduledStopPointValidityMutationResult = Apollo.MutationResult<EditScheduledStopPointValidityMutation>;
export type EditScheduledStopPointValidityMutationOptions = Apollo.BaseMutationOptions<EditScheduledStopPointValidityMutation, EditScheduledStopPointValidityMutationVariables>;
export const GetQuayDocument = gql`
    query GetQuay($quayId: String!) {
  stop_registry {
    stopPlace(query: $quayId, onlyMonomodalStopPlaces: true) {
      ... on stop_registry_StopPlace {
        id
        quays {
          id
          publicCode
          keyValues {
            key
            values
          }
        }
      }
    }
  }
}
    `;

/**
 * __useGetQuayQuery__
 *
 * To run a query within a React component, call `useGetQuayQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetQuayQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetQuayQuery({
 *   variables: {
 *      quayId: // value for 'quayId'
 *   },
 * });
 */
export function useGetQuayQuery(baseOptions: Apollo.QueryHookOptions<GetQuayQuery, GetQuayQueryVariables> & ({ variables: GetQuayQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetQuayQuery, GetQuayQueryVariables>(GetQuayDocument, options);
      }
export function useGetQuayLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetQuayQuery, GetQuayQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetQuayQuery, GetQuayQueryVariables>(GetQuayDocument, options);
        }
export function useGetQuaySuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetQuayQuery, GetQuayQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetQuayQuery, GetQuayQueryVariables>(GetQuayDocument, options);
        }
export type GetQuayQueryHookResult = ReturnType<typeof useGetQuayQuery>;
export type GetQuayLazyQueryHookResult = ReturnType<typeof useGetQuayLazyQuery>;
export type GetQuaySuspenseQueryHookResult = ReturnType<typeof useGetQuaySuspenseQuery>;
export type GetQuayQueryResult = Apollo.QueryResult<GetQuayQuery, GetQuayQueryVariables>;
export const InsertQuayIntoStopPlaceDocument = gql`
    mutation InsertQuayIntoStopPlace($stopPlaceId: String!, $quayInput: stop_registry_QuayInput!) {
  stop_registry {
    mutateStopPlace(StopPlace: {id: $stopPlaceId, quays: [$quayInput]}) {
      id
      quays {
        id
        keyValues {
          key
          values
        }
      }
    }
  }
}
    `;
export type InsertQuayIntoStopPlaceMutationFn = Apollo.MutationFunction<InsertQuayIntoStopPlaceMutation, InsertQuayIntoStopPlaceMutationVariables>;

/**
 * __useInsertQuayIntoStopPlaceMutation__
 *
 * To run a mutation, you first call `useInsertQuayIntoStopPlaceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertQuayIntoStopPlaceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertQuayIntoStopPlaceMutation, { data, loading, error }] = useInsertQuayIntoStopPlaceMutation({
 *   variables: {
 *      stopPlaceId: // value for 'stopPlaceId'
 *      quayInput: // value for 'quayInput'
 *   },
 * });
 */
export function useInsertQuayIntoStopPlaceMutation(baseOptions?: Apollo.MutationHookOptions<InsertQuayIntoStopPlaceMutation, InsertQuayIntoStopPlaceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertQuayIntoStopPlaceMutation, InsertQuayIntoStopPlaceMutationVariables>(InsertQuayIntoStopPlaceDocument, options);
      }
export type InsertQuayIntoStopPlaceMutationHookResult = ReturnType<typeof useInsertQuayIntoStopPlaceMutation>;
export type InsertQuayIntoStopPlaceMutationResult = Apollo.MutationResult<InsertQuayIntoStopPlaceMutation>;
export type InsertQuayIntoStopPlaceMutationOptions = Apollo.BaseMutationOptions<InsertQuayIntoStopPlaceMutation, InsertQuayIntoStopPlaceMutationVariables>;
export const FindExistingPosterNamesDocument = gql`
    query findExistingPosterNames {
  stops_database {
    stops_database_info_spot_poster(order_by: [{label: asc}], distinct_on: [label]) {
      id
      label
    }
  }
}
    `;

/**
 * __useFindExistingPosterNamesQuery__
 *
 * To run a query within a React component, call `useFindExistingPosterNamesQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindExistingPosterNamesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindExistingPosterNamesQuery({
 *   variables: {
 *   },
 * });
 */
export function useFindExistingPosterNamesQuery(baseOptions?: Apollo.QueryHookOptions<FindExistingPosterNamesQuery, FindExistingPosterNamesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FindExistingPosterNamesQuery, FindExistingPosterNamesQueryVariables>(FindExistingPosterNamesDocument, options);
      }
export function useFindExistingPosterNamesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FindExistingPosterNamesQuery, FindExistingPosterNamesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FindExistingPosterNamesQuery, FindExistingPosterNamesQueryVariables>(FindExistingPosterNamesDocument, options);
        }
export function useFindExistingPosterNamesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<FindExistingPosterNamesQuery, FindExistingPosterNamesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FindExistingPosterNamesQuery, FindExistingPosterNamesQueryVariables>(FindExistingPosterNamesDocument, options);
        }
export type FindExistingPosterNamesQueryHookResult = ReturnType<typeof useFindExistingPosterNamesQuery>;
export type FindExistingPosterNamesLazyQueryHookResult = ReturnType<typeof useFindExistingPosterNamesLazyQuery>;
export type FindExistingPosterNamesSuspenseQueryHookResult = ReturnType<typeof useFindExistingPosterNamesSuspenseQuery>;
export type FindExistingPosterNamesQueryResult = Apollo.QueryResult<FindExistingPosterNamesQuery, FindExistingPosterNamesQueryVariables>;
export const UpdateInfoSpotDocument = gql`
    mutation UpdateInfoSpot($input: [stop_registry_infoSpotInput]!) {
  stop_registry {
    mutateInfoSpots(infoSpot: $input) {
      ...info_spot_details
    }
  }
}
    ${InfoSpotDetailsFragmentDoc}`;
export type UpdateInfoSpotMutationFn = Apollo.MutationFunction<UpdateInfoSpotMutation, UpdateInfoSpotMutationVariables>;

/**
 * __useUpdateInfoSpotMutation__
 *
 * To run a mutation, you first call `useUpdateInfoSpotMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateInfoSpotMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateInfoSpotMutation, { data, loading, error }] = useUpdateInfoSpotMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateInfoSpotMutation(baseOptions?: Apollo.MutationHookOptions<UpdateInfoSpotMutation, UpdateInfoSpotMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateInfoSpotMutation, UpdateInfoSpotMutationVariables>(UpdateInfoSpotDocument, options);
      }
export type UpdateInfoSpotMutationHookResult = ReturnType<typeof useUpdateInfoSpotMutation>;
export type UpdateInfoSpotMutationResult = Apollo.MutationResult<UpdateInfoSpotMutation>;
export type UpdateInfoSpotMutationOptions = Apollo.BaseMutationOptions<UpdateInfoSpotMutation, UpdateInfoSpotMutationVariables>;
export const GetInfoSpotSizesDocument = gql`
    query GetInfoSpotSizes {
  stopsDb: stops_database {
    infoSpotSizes: stops_database_info_spot(
      distinct_on: [width, height]
      order_by: [{width: desc}, {height: desc}]
      where: {width: {_is_null: false}, height: {_is_null: false}}
    ) {
      width
      height
    }
    infoSpotPosterSizes: stops_database_info_spot_poster(
      distinct_on: [width, height]
      order_by: [{width: desc}, {height: desc}]
      where: {width: {_is_null: false}, height: {_is_null: false}}
    ) {
      width
      height
    }
  }
}
    `;

/**
 * __useGetInfoSpotSizesQuery__
 *
 * To run a query within a React component, call `useGetInfoSpotSizesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInfoSpotSizesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInfoSpotSizesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetInfoSpotSizesQuery(baseOptions?: Apollo.QueryHookOptions<GetInfoSpotSizesQuery, GetInfoSpotSizesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInfoSpotSizesQuery, GetInfoSpotSizesQueryVariables>(GetInfoSpotSizesDocument, options);
      }
export function useGetInfoSpotSizesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInfoSpotSizesQuery, GetInfoSpotSizesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInfoSpotSizesQuery, GetInfoSpotSizesQueryVariables>(GetInfoSpotSizesDocument, options);
        }
export function useGetInfoSpotSizesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInfoSpotSizesQuery, GetInfoSpotSizesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInfoSpotSizesQuery, GetInfoSpotSizesQueryVariables>(GetInfoSpotSizesDocument, options);
        }
export type GetInfoSpotSizesQueryHookResult = ReturnType<typeof useGetInfoSpotSizesQuery>;
export type GetInfoSpotSizesLazyQueryHookResult = ReturnType<typeof useGetInfoSpotSizesLazyQuery>;
export type GetInfoSpotSizesSuspenseQueryHookResult = ReturnType<typeof useGetInfoSpotSizesSuspenseQuery>;
export type GetInfoSpotSizesQueryResult = Apollo.QueryResult<GetInfoSpotSizesQuery, GetInfoSpotSizesQueryVariables>;
export const GetOrganisationsDocument = gql`
    query GetOrganisations {
  stop_registry {
    organisation {
      ...stop_place_organisation_fields
    }
  }
}
    ${StopPlaceOrganisationFieldsFragmentDoc}`;

/**
 * __useGetOrganisationsQuery__
 *
 * To run a query within a React component, call `useGetOrganisationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOrganisationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOrganisationsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetOrganisationsQuery(baseOptions?: Apollo.QueryHookOptions<GetOrganisationsQuery, GetOrganisationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOrganisationsQuery, GetOrganisationsQueryVariables>(GetOrganisationsDocument, options);
      }
export function useGetOrganisationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOrganisationsQuery, GetOrganisationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOrganisationsQuery, GetOrganisationsQueryVariables>(GetOrganisationsDocument, options);
        }
export function useGetOrganisationsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetOrganisationsQuery, GetOrganisationsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetOrganisationsQuery, GetOrganisationsQueryVariables>(GetOrganisationsDocument, options);
        }
export type GetOrganisationsQueryHookResult = ReturnType<typeof useGetOrganisationsQuery>;
export type GetOrganisationsLazyQueryHookResult = ReturnType<typeof useGetOrganisationsLazyQuery>;
export type GetOrganisationsSuspenseQueryHookResult = ReturnType<typeof useGetOrganisationsSuspenseQuery>;
export type GetOrganisationsQueryResult = Apollo.QueryResult<GetOrganisationsQuery, GetOrganisationsQueryVariables>;
export const FindLinesByStopDocument = gql`
    query FindLinesByStop($stopPlaceId: String!, $validOn: date!) {
  service_pattern_scheduled_stop_point(
    where: {stop_place_ref: {_eq: $stopPlaceId}, validity_start: {_lte: $validOn}, _or: [{validity_end: {_gte: $validOn}}, {validity_end: {_is_null: true}}]}
    distinct_on: [label, priority]
    order_by: {label: asc, priority: desc}
  ) {
    ...StopPointDetails
    ...JourneyRouteInfo
  }
}
    ${StopPointDetailsFragmentDoc}
${JourneyRouteInfoFragmentDoc}`;

/**
 * __useFindLinesByStopQuery__
 *
 * To run a query within a React component, call `useFindLinesByStopQuery` and pass it any options that fit your needs.
 * When your component renders, `useFindLinesByStopQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFindLinesByStopQuery({
 *   variables: {
 *      stopPlaceId: // value for 'stopPlaceId'
 *      validOn: // value for 'validOn'
 *   },
 * });
 */
export function useFindLinesByStopQuery(baseOptions: Apollo.QueryHookOptions<FindLinesByStopQuery, FindLinesByStopQueryVariables> & ({ variables: FindLinesByStopQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FindLinesByStopQuery, FindLinesByStopQueryVariables>(FindLinesByStopDocument, options);
      }
export function useFindLinesByStopLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FindLinesByStopQuery, FindLinesByStopQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FindLinesByStopQuery, FindLinesByStopQueryVariables>(FindLinesByStopDocument, options);
        }
export function useFindLinesByStopSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<FindLinesByStopQuery, FindLinesByStopQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FindLinesByStopQuery, FindLinesByStopQueryVariables>(FindLinesByStopDocument, options);
        }
export type FindLinesByStopQueryHookResult = ReturnType<typeof useFindLinesByStopQuery>;
export type FindLinesByStopLazyQueryHookResult = ReturnType<typeof useFindLinesByStopLazyQuery>;
export type FindLinesByStopSuspenseQueryHookResult = ReturnType<typeof useFindLinesByStopSuspenseQuery>;
export type FindLinesByStopQueryResult = Apollo.QueryResult<FindLinesByStopQuery, FindLinesByStopQueryVariables>;
export const GetOverlappingStopVersionsDocument = gql`
    query GetOverlappingStopVersions($stopLabel: String!, $currentStopId: String!, $priority: Int!, $fromDate: date!, $toDate: date!) {
  service_pattern_scheduled_stop_point(
    where: {label: {_eq: $stopLabel}, stop_place_ref: {_neq: $currentStopId}, priority: {_eq: $priority}, validity_start: {_lte: $toDate}, _or: [{validity_end: {_gte: $fromDate}}, {validity_end: {_is_null: true}}]}
  ) {
    ...OverlappingStopVersionsData
  }
}
    ${OverlappingStopVersionsDataFragmentDoc}`;

/**
 * __useGetOverlappingStopVersionsQuery__
 *
 * To run a query within a React component, call `useGetOverlappingStopVersionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOverlappingStopVersionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOverlappingStopVersionsQuery({
 *   variables: {
 *      stopLabel: // value for 'stopLabel'
 *      currentStopId: // value for 'currentStopId'
 *      priority: // value for 'priority'
 *      fromDate: // value for 'fromDate'
 *      toDate: // value for 'toDate'
 *   },
 * });
 */
export function useGetOverlappingStopVersionsQuery(baseOptions: Apollo.QueryHookOptions<GetOverlappingStopVersionsQuery, GetOverlappingStopVersionsQueryVariables> & ({ variables: GetOverlappingStopVersionsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOverlappingStopVersionsQuery, GetOverlappingStopVersionsQueryVariables>(GetOverlappingStopVersionsDocument, options);
      }
export function useGetOverlappingStopVersionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOverlappingStopVersionsQuery, GetOverlappingStopVersionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOverlappingStopVersionsQuery, GetOverlappingStopVersionsQueryVariables>(GetOverlappingStopVersionsDocument, options);
        }
export function useGetOverlappingStopVersionsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetOverlappingStopVersionsQuery, GetOverlappingStopVersionsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetOverlappingStopVersionsQuery, GetOverlappingStopVersionsQueryVariables>(GetOverlappingStopVersionsDocument, options);
        }
export type GetOverlappingStopVersionsQueryHookResult = ReturnType<typeof useGetOverlappingStopVersionsQuery>;
export type GetOverlappingStopVersionsLazyQueryHookResult = ReturnType<typeof useGetOverlappingStopVersionsLazyQuery>;
export type GetOverlappingStopVersionsSuspenseQueryHookResult = ReturnType<typeof useGetOverlappingStopVersionsSuspenseQuery>;
export type GetOverlappingStopVersionsQueryResult = Apollo.QueryResult<GetOverlappingStopVersionsQuery, GetOverlappingStopVersionsQueryVariables>;
export const GetOverlappingStopVersionsIndefiniteDocument = gql`
    query GetOverlappingStopVersionsIndefinite($stopLabel: String!, $currentStopId: String!, $priority: Int!, $fromDate: date!) {
  service_pattern_scheduled_stop_point(
    where: {label: {_eq: $stopLabel}, stop_place_ref: {_neq: $currentStopId}, priority: {_eq: $priority}, _not: {validity_end: {_lt: $fromDate}}}
  ) {
    ...OverlappingStopVersionsData
  }
}
    ${OverlappingStopVersionsDataFragmentDoc}`;

/**
 * __useGetOverlappingStopVersionsIndefiniteQuery__
 *
 * To run a query within a React component, call `useGetOverlappingStopVersionsIndefiniteQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOverlappingStopVersionsIndefiniteQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOverlappingStopVersionsIndefiniteQuery({
 *   variables: {
 *      stopLabel: // value for 'stopLabel'
 *      currentStopId: // value for 'currentStopId'
 *      priority: // value for 'priority'
 *      fromDate: // value for 'fromDate'
 *   },
 * });
 */
export function useGetOverlappingStopVersionsIndefiniteQuery(baseOptions: Apollo.QueryHookOptions<GetOverlappingStopVersionsIndefiniteQuery, GetOverlappingStopVersionsIndefiniteQueryVariables> & ({ variables: GetOverlappingStopVersionsIndefiniteQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOverlappingStopVersionsIndefiniteQuery, GetOverlappingStopVersionsIndefiniteQueryVariables>(GetOverlappingStopVersionsIndefiniteDocument, options);
      }
export function useGetOverlappingStopVersionsIndefiniteLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOverlappingStopVersionsIndefiniteQuery, GetOverlappingStopVersionsIndefiniteQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOverlappingStopVersionsIndefiniteQuery, GetOverlappingStopVersionsIndefiniteQueryVariables>(GetOverlappingStopVersionsIndefiniteDocument, options);
        }
export function useGetOverlappingStopVersionsIndefiniteSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetOverlappingStopVersionsIndefiniteQuery, GetOverlappingStopVersionsIndefiniteQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetOverlappingStopVersionsIndefiniteQuery, GetOverlappingStopVersionsIndefiniteQueryVariables>(GetOverlappingStopVersionsIndefiniteDocument, options);
        }
export type GetOverlappingStopVersionsIndefiniteQueryHookResult = ReturnType<typeof useGetOverlappingStopVersionsIndefiniteQuery>;
export type GetOverlappingStopVersionsIndefiniteLazyQueryHookResult = ReturnType<typeof useGetOverlappingStopVersionsIndefiniteLazyQuery>;
export type GetOverlappingStopVersionsIndefiniteSuspenseQueryHookResult = ReturnType<typeof useGetOverlappingStopVersionsIndefiniteSuspenseQuery>;
export type GetOverlappingStopVersionsIndefiniteQueryResult = Apollo.QueryResult<GetOverlappingStopVersionsIndefiniteQuery, GetOverlappingStopVersionsIndefiniteQueryVariables>;
export const ResolveStopSheltersDocument = gql`
    query ResolveStopShelters($netexId: String!) {
  stop_registry {
    stopPlace(query: $netexId, onlyMonomodalStopPlaces: true) {
      id
      ... on stop_registry_StopPlace {
        quays {
          id
          placeEquipments {
            id
            shelterEquipment {
              ...shelter_equipment_details
            }
          }
        }
      }
    }
  }
}
    ${ShelterEquipmentDetailsFragmentDoc}`;

/**
 * __useResolveStopSheltersQuery__
 *
 * To run a query within a React component, call `useResolveStopSheltersQuery` and pass it any options that fit your needs.
 * When your component renders, `useResolveStopSheltersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useResolveStopSheltersQuery({
 *   variables: {
 *      netexId: // value for 'netexId'
 *   },
 * });
 */
export function useResolveStopSheltersQuery(baseOptions: Apollo.QueryHookOptions<ResolveStopSheltersQuery, ResolveStopSheltersQueryVariables> & ({ variables: ResolveStopSheltersQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ResolveStopSheltersQuery, ResolveStopSheltersQueryVariables>(ResolveStopSheltersDocument, options);
      }
export function useResolveStopSheltersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ResolveStopSheltersQuery, ResolveStopSheltersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ResolveStopSheltersQuery, ResolveStopSheltersQueryVariables>(ResolveStopSheltersDocument, options);
        }
export function useResolveStopSheltersSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<ResolveStopSheltersQuery, ResolveStopSheltersQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ResolveStopSheltersQuery, ResolveStopSheltersQueryVariables>(ResolveStopSheltersDocument, options);
        }
export type ResolveStopSheltersQueryHookResult = ReturnType<typeof useResolveStopSheltersQuery>;
export type ResolveStopSheltersLazyQueryHookResult = ReturnType<typeof useResolveStopSheltersLazyQuery>;
export type ResolveStopSheltersSuspenseQueryHookResult = ReturnType<typeof useResolveStopSheltersSuspenseQuery>;
export type ResolveStopSheltersQueryResult = Apollo.QueryResult<ResolveStopSheltersQuery, ResolveStopSheltersQueryVariables>;
export const ResolveExistingStopValidityRangesDocument = gql`
    query ResolveExistingStopValidityRanges($stopPlaceId: String!, $today: date) {
  stopPoints: service_pattern_scheduled_stop_point(
    where: {stop_place_ref: {_eq: $stopPlaceId}, _or: [{validity_end: {_is_null: true}}, {validity_end: {_gte: $today}}]}
    order_by: [{validity_start: asc}]
  ) {
    scheduled_stop_point_id
    priority
    validity_start
    validity_end
  }
}
    `;

/**
 * __useResolveExistingStopValidityRangesQuery__
 *
 * To run a query within a React component, call `useResolveExistingStopValidityRangesQuery` and pass it any options that fit your needs.
 * When your component renders, `useResolveExistingStopValidityRangesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useResolveExistingStopValidityRangesQuery({
 *   variables: {
 *      stopPlaceId: // value for 'stopPlaceId'
 *      today: // value for 'today'
 *   },
 * });
 */
export function useResolveExistingStopValidityRangesQuery(baseOptions: Apollo.QueryHookOptions<ResolveExistingStopValidityRangesQuery, ResolveExistingStopValidityRangesQueryVariables> & ({ variables: ResolveExistingStopValidityRangesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ResolveExistingStopValidityRangesQuery, ResolveExistingStopValidityRangesQueryVariables>(ResolveExistingStopValidityRangesDocument, options);
      }
export function useResolveExistingStopValidityRangesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ResolveExistingStopValidityRangesQuery, ResolveExistingStopValidityRangesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ResolveExistingStopValidityRangesQuery, ResolveExistingStopValidityRangesQueryVariables>(ResolveExistingStopValidityRangesDocument, options);
        }
export function useResolveExistingStopValidityRangesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<ResolveExistingStopValidityRangesQuery, ResolveExistingStopValidityRangesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ResolveExistingStopValidityRangesQuery, ResolveExistingStopValidityRangesQueryVariables>(ResolveExistingStopValidityRangesDocument, options);
        }
export type ResolveExistingStopValidityRangesQueryHookResult = ReturnType<typeof useResolveExistingStopValidityRangesQuery>;
export type ResolveExistingStopValidityRangesLazyQueryHookResult = ReturnType<typeof useResolveExistingStopValidityRangesLazyQuery>;
export type ResolveExistingStopValidityRangesSuspenseQueryHookResult = ReturnType<typeof useResolveExistingStopValidityRangesSuspenseQuery>;
export type ResolveExistingStopValidityRangesQueryResult = Apollo.QueryResult<ResolveExistingStopValidityRangesQuery, ResolveExistingStopValidityRangesQueryVariables>;
export const GetStopPlaceNameDocument = gql`
    query GetStopPlaceName($stopPlaceNetexId: String!) {
  stop_registry {
    stopPlace(id: $stopPlaceNetexId, onlyMonomodalStopPlaces: true) {
      id
      name {
        lang
        value
      }
      alternativeNames {
        nameType
        name {
          lang
          value
        }
      }
    }
  }
}
    `;

/**
 * __useGetStopPlaceNameQuery__
 *
 * To run a query within a React component, call `useGetStopPlaceNameQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStopPlaceNameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStopPlaceNameQuery({
 *   variables: {
 *      stopPlaceNetexId: // value for 'stopPlaceNetexId'
 *   },
 * });
 */
export function useGetStopPlaceNameQuery(baseOptions: Apollo.QueryHookOptions<GetStopPlaceNameQuery, GetStopPlaceNameQueryVariables> & ({ variables: GetStopPlaceNameQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStopPlaceNameQuery, GetStopPlaceNameQueryVariables>(GetStopPlaceNameDocument, options);
      }
export function useGetStopPlaceNameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStopPlaceNameQuery, GetStopPlaceNameQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStopPlaceNameQuery, GetStopPlaceNameQueryVariables>(GetStopPlaceNameDocument, options);
        }
export function useGetStopPlaceNameSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetStopPlaceNameQuery, GetStopPlaceNameQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetStopPlaceNameQuery, GetStopPlaceNameQueryVariables>(GetStopPlaceNameDocument, options);
        }
export type GetStopPlaceNameQueryHookResult = ReturnType<typeof useGetStopPlaceNameQuery>;
export type GetStopPlaceNameLazyQueryHookResult = ReturnType<typeof useGetStopPlaceNameLazyQuery>;
export type GetStopPlaceNameSuspenseQueryHookResult = ReturnType<typeof useGetStopPlaceNameSuspenseQuery>;
export type GetStopPlaceNameQueryResult = Apollo.QueryResult<GetStopPlaceNameQuery, GetStopPlaceNameQueryVariables>;
export const GetQuayVersionsDocument = gql`
    query GetQuayVersions($publicCode: String!) {
  stops_database {
    quays: stops_database_quay_newest_version(
      where: {public_code: {_eq: $publicCode}}
      order_by: [{validity_start: asc}, {priority: asc}]
    ) {
      ...StopVersionInfo
    }
  }
}
    ${StopVersionInfoFragmentDoc}`;

/**
 * __useGetQuayVersionsQuery__
 *
 * To run a query within a React component, call `useGetQuayVersionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetQuayVersionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetQuayVersionsQuery({
 *   variables: {
 *      publicCode: // value for 'publicCode'
 *   },
 * });
 */
export function useGetQuayVersionsQuery(baseOptions: Apollo.QueryHookOptions<GetQuayVersionsQuery, GetQuayVersionsQueryVariables> & ({ variables: GetQuayVersionsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetQuayVersionsQuery, GetQuayVersionsQueryVariables>(GetQuayVersionsDocument, options);
      }
export function useGetQuayVersionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetQuayVersionsQuery, GetQuayVersionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetQuayVersionsQuery, GetQuayVersionsQueryVariables>(GetQuayVersionsDocument, options);
        }
export function useGetQuayVersionsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetQuayVersionsQuery, GetQuayVersionsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetQuayVersionsQuery, GetQuayVersionsQueryVariables>(GetQuayVersionsDocument, options);
        }
export type GetQuayVersionsQueryHookResult = ReturnType<typeof useGetQuayVersionsQuery>;
export type GetQuayVersionsLazyQueryHookResult = ReturnType<typeof useGetQuayVersionsLazyQuery>;
export type GetQuayVersionsSuspenseQueryHookResult = ReturnType<typeof useGetQuayVersionsSuspenseQuery>;
export type GetQuayVersionsQueryResult = Apollo.QueryResult<GetQuayVersionsQuery, GetQuayVersionsQueryVariables>;
export const RemoveFromMultiModalStopPlaceDocument = gql`
    mutation removeFromMultiModalStopPlace($parentSiteRef: String!, $stopPlaceId: [String]) {
  stop_registry {
    removeFromMultiModalStopPlace(
      parentSiteRef: $parentSiteRef
      stopPlaceId: $stopPlaceId
    ) {
      id
    }
  }
}
    `;
export type RemoveFromMultiModalStopPlaceMutationFn = Apollo.MutationFunction<RemoveFromMultiModalStopPlaceMutation, RemoveFromMultiModalStopPlaceMutationVariables>;

/**
 * __useRemoveFromMultiModalStopPlaceMutation__
 *
 * To run a mutation, you first call `useRemoveFromMultiModalStopPlaceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveFromMultiModalStopPlaceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeFromMultiModalStopPlaceMutation, { data, loading, error }] = useRemoveFromMultiModalStopPlaceMutation({
 *   variables: {
 *      parentSiteRef: // value for 'parentSiteRef'
 *      stopPlaceId: // value for 'stopPlaceId'
 *   },
 * });
 */
export function useRemoveFromMultiModalStopPlaceMutation(baseOptions?: Apollo.MutationHookOptions<RemoveFromMultiModalStopPlaceMutation, RemoveFromMultiModalStopPlaceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveFromMultiModalStopPlaceMutation, RemoveFromMultiModalStopPlaceMutationVariables>(RemoveFromMultiModalStopPlaceDocument, options);
      }
export type RemoveFromMultiModalStopPlaceMutationHookResult = ReturnType<typeof useRemoveFromMultiModalStopPlaceMutation>;
export type RemoveFromMultiModalStopPlaceMutationResult = Apollo.MutationResult<RemoveFromMultiModalStopPlaceMutation>;
export type RemoveFromMultiModalStopPlaceMutationOptions = Apollo.BaseMutationOptions<RemoveFromMultiModalStopPlaceMutation, RemoveFromMultiModalStopPlaceMutationVariables>;
export const AddToMultiModalStopPlaceDocument = gql`
    mutation addToMultiModalStopPlace($input: stop_registry_addToMultiModalStopPlaceInput!) {
  stop_registry {
    addToMultiModalStopPlace(input: $input) {
      id
    }
  }
}
    `;
export type AddToMultiModalStopPlaceMutationFn = Apollo.MutationFunction<AddToMultiModalStopPlaceMutation, AddToMultiModalStopPlaceMutationVariables>;

/**
 * __useAddToMultiModalStopPlaceMutation__
 *
 * To run a mutation, you first call `useAddToMultiModalStopPlaceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddToMultiModalStopPlaceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addToMultiModalStopPlaceMutation, { data, loading, error }] = useAddToMultiModalStopPlaceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAddToMultiModalStopPlaceMutation(baseOptions?: Apollo.MutationHookOptions<AddToMultiModalStopPlaceMutation, AddToMultiModalStopPlaceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddToMultiModalStopPlaceMutation, AddToMultiModalStopPlaceMutationVariables>(AddToMultiModalStopPlaceDocument, options);
      }
export type AddToMultiModalStopPlaceMutationHookResult = ReturnType<typeof useAddToMultiModalStopPlaceMutation>;
export type AddToMultiModalStopPlaceMutationResult = Apollo.MutationResult<AddToMultiModalStopPlaceMutation>;
export type AddToMultiModalStopPlaceMutationOptions = Apollo.BaseMutationOptions<AddToMultiModalStopPlaceMutation, AddToMultiModalStopPlaceMutationVariables>;
export const GetParentStopPlaceDetailsDocument = gql`
    query getParentStopPlaceDetails($privateCode: String!, $validOn: String!) {
  stops_database {
    stops_database_stop_place_newest_version(
      where: {private_code_value: {_eq: $privateCode}, validity_start: {_lte: $validOn}, _or: [{validity_end: {_is_null: true}}, {validity_end: {_gte: $validOn}}]}
    ) {
      id
      TiamatStopPlace {
        ...parent_stop_place_details
      }
    }
  }
}
    ${ParentStopPlaceDetailsFragmentDoc}`;

/**
 * __useGetParentStopPlaceDetailsQuery__
 *
 * To run a query within a React component, call `useGetParentStopPlaceDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetParentStopPlaceDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetParentStopPlaceDetailsQuery({
 *   variables: {
 *      privateCode: // value for 'privateCode'
 *      validOn: // value for 'validOn'
 *   },
 * });
 */
export function useGetParentStopPlaceDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetParentStopPlaceDetailsQuery, GetParentStopPlaceDetailsQueryVariables> & ({ variables: GetParentStopPlaceDetailsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetParentStopPlaceDetailsQuery, GetParentStopPlaceDetailsQueryVariables>(GetParentStopPlaceDetailsDocument, options);
      }
export function useGetParentStopPlaceDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetParentStopPlaceDetailsQuery, GetParentStopPlaceDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetParentStopPlaceDetailsQuery, GetParentStopPlaceDetailsQueryVariables>(GetParentStopPlaceDetailsDocument, options);
        }
export function useGetParentStopPlaceDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetParentStopPlaceDetailsQuery, GetParentStopPlaceDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetParentStopPlaceDetailsQuery, GetParentStopPlaceDetailsQueryVariables>(GetParentStopPlaceDetailsDocument, options);
        }
export type GetParentStopPlaceDetailsQueryHookResult = ReturnType<typeof useGetParentStopPlaceDetailsQuery>;
export type GetParentStopPlaceDetailsLazyQueryHookResult = ReturnType<typeof useGetParentStopPlaceDetailsLazyQuery>;
export type GetParentStopPlaceDetailsSuspenseQueryHookResult = ReturnType<typeof useGetParentStopPlaceDetailsSuspenseQuery>;
export type GetParentStopPlaceDetailsQueryResult = Apollo.QueryResult<GetParentStopPlaceDetailsQuery, GetParentStopPlaceDetailsQueryVariables>;
export const GetRouteWithJourneyPatternDocument = gql`
    query GetRouteWithJourneyPattern($routeId: uuid!) {
  route_route_by_pk(route_id: $routeId) {
    ...route_with_journey_pattern_stops
  }
}
    ${RouteWithJourneyPatternStopsFragmentDoc}`;

/**
 * __useGetRouteWithJourneyPatternQuery__
 *
 * To run a query within a React component, call `useGetRouteWithJourneyPatternQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRouteWithJourneyPatternQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRouteWithJourneyPatternQuery({
 *   variables: {
 *      routeId: // value for 'routeId'
 *   },
 * });
 */
export function useGetRouteWithJourneyPatternQuery(baseOptions: Apollo.QueryHookOptions<GetRouteWithJourneyPatternQuery, GetRouteWithJourneyPatternQueryVariables> & ({ variables: GetRouteWithJourneyPatternQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRouteWithJourneyPatternQuery, GetRouteWithJourneyPatternQueryVariables>(GetRouteWithJourneyPatternDocument, options);
      }
export function useGetRouteWithJourneyPatternLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRouteWithJourneyPatternQuery, GetRouteWithJourneyPatternQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRouteWithJourneyPatternQuery, GetRouteWithJourneyPatternQueryVariables>(GetRouteWithJourneyPatternDocument, options);
        }
export function useGetRouteWithJourneyPatternSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetRouteWithJourneyPatternQuery, GetRouteWithJourneyPatternQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetRouteWithJourneyPatternQuery, GetRouteWithJourneyPatternQueryVariables>(GetRouteWithJourneyPatternDocument, options);
        }
export type GetRouteWithJourneyPatternQueryHookResult = ReturnType<typeof useGetRouteWithJourneyPatternQuery>;
export type GetRouteWithJourneyPatternLazyQueryHookResult = ReturnType<typeof useGetRouteWithJourneyPatternLazyQuery>;
export type GetRouteWithJourneyPatternSuspenseQueryHookResult = ReturnType<typeof useGetRouteWithJourneyPatternSuspenseQuery>;
export type GetRouteWithJourneyPatternQueryResult = Apollo.QueryResult<GetRouteWithJourneyPatternQuery, GetRouteWithJourneyPatternQueryVariables>;
export const QueryClosestLinkDocument = gql`
    query QueryClosestLink($point: geography) {
  infrastructure_network_resolve_point_to_closest_link(args: {geog: $point}) {
    ...infrastructure_link_all_fields
  }
}
    ${InfrastructureLinkAllFieldsFragmentDoc}`;

/**
 * __useQueryClosestLinkQuery__
 *
 * To run a query within a React component, call `useQueryClosestLinkQuery` and pass it any options that fit your needs.
 * When your component renders, `useQueryClosestLinkQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQueryClosestLinkQuery({
 *   variables: {
 *      point: // value for 'point'
 *   },
 * });
 */
export function useQueryClosestLinkQuery(baseOptions?: Apollo.QueryHookOptions<QueryClosestLinkQuery, QueryClosestLinkQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<QueryClosestLinkQuery, QueryClosestLinkQueryVariables>(QueryClosestLinkDocument, options);
      }
export function useQueryClosestLinkLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<QueryClosestLinkQuery, QueryClosestLinkQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<QueryClosestLinkQuery, QueryClosestLinkQueryVariables>(QueryClosestLinkDocument, options);
        }
export function useQueryClosestLinkSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<QueryClosestLinkQuery, QueryClosestLinkQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<QueryClosestLinkQuery, QueryClosestLinkQueryVariables>(QueryClosestLinkDocument, options);
        }
export type QueryClosestLinkQueryHookResult = ReturnType<typeof useQueryClosestLinkQuery>;
export type QueryClosestLinkLazyQueryHookResult = ReturnType<typeof useQueryClosestLinkLazyQuery>;
export type QueryClosestLinkSuspenseQueryHookResult = ReturnType<typeof useQueryClosestLinkSuspenseQuery>;
export type QueryClosestLinkQueryResult = Apollo.QueryResult<QueryClosestLinkQuery, QueryClosestLinkQueryVariables>;
export const QueryPointDirectionOnLinkDocument = gql`
    query QueryPointDirectionOnLink($point_of_interest: geography, $infrastructure_link_uuid: uuid, $point_max_distance_in_meters: float8) {
  infrastructure_network_find_point_direction_on_link(
    args: {point_of_interest: $point_of_interest, infrastructure_link_uuid: $infrastructure_link_uuid, point_max_distance_in_meters: $point_max_distance_in_meters}
  ) {
    value
  }
}
    `;

/**
 * __useQueryPointDirectionOnLinkQuery__
 *
 * To run a query within a React component, call `useQueryPointDirectionOnLinkQuery` and pass it any options that fit your needs.
 * When your component renders, `useQueryPointDirectionOnLinkQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQueryPointDirectionOnLinkQuery({
 *   variables: {
 *      point_of_interest: // value for 'point_of_interest'
 *      infrastructure_link_uuid: // value for 'infrastructure_link_uuid'
 *      point_max_distance_in_meters: // value for 'point_max_distance_in_meters'
 *   },
 * });
 */
export function useQueryPointDirectionOnLinkQuery(baseOptions?: Apollo.QueryHookOptions<QueryPointDirectionOnLinkQuery, QueryPointDirectionOnLinkQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<QueryPointDirectionOnLinkQuery, QueryPointDirectionOnLinkQueryVariables>(QueryPointDirectionOnLinkDocument, options);
      }
export function useQueryPointDirectionOnLinkLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<QueryPointDirectionOnLinkQuery, QueryPointDirectionOnLinkQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<QueryPointDirectionOnLinkQuery, QueryPointDirectionOnLinkQueryVariables>(QueryPointDirectionOnLinkDocument, options);
        }
export function useQueryPointDirectionOnLinkSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<QueryPointDirectionOnLinkQuery, QueryPointDirectionOnLinkQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<QueryPointDirectionOnLinkQuery, QueryPointDirectionOnLinkQueryVariables>(QueryPointDirectionOnLinkDocument, options);
        }
export type QueryPointDirectionOnLinkQueryHookResult = ReturnType<typeof useQueryPointDirectionOnLinkQuery>;
export type QueryPointDirectionOnLinkLazyQueryHookResult = ReturnType<typeof useQueryPointDirectionOnLinkLazyQuery>;
export type QueryPointDirectionOnLinkSuspenseQueryHookResult = ReturnType<typeof useQueryPointDirectionOnLinkSuspenseQuery>;
export type QueryPointDirectionOnLinkQueryResult = Apollo.QueryResult<QueryPointDirectionOnLinkQuery, QueryPointDirectionOnLinkQueryVariables>;
export const GetStopsAlongInfrastructureLinksDocument = gql`
    query GetStopsAlongInfrastructureLinks($infrastructure_link_ids: [uuid!]) {
  service_pattern_scheduled_stop_point(
    where: {located_on_infrastructure_link_id: {_in: $infrastructure_link_ids}}
  ) {
    ...scheduled_stop_point_all_fields
  }
}
    ${ScheduledStopPointAllFieldsFragmentDoc}`;

/**
 * __useGetStopsAlongInfrastructureLinksQuery__
 *
 * To run a query within a React component, call `useGetStopsAlongInfrastructureLinksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStopsAlongInfrastructureLinksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStopsAlongInfrastructureLinksQuery({
 *   variables: {
 *      infrastructure_link_ids: // value for 'infrastructure_link_ids'
 *   },
 * });
 */
export function useGetStopsAlongInfrastructureLinksQuery(baseOptions?: Apollo.QueryHookOptions<GetStopsAlongInfrastructureLinksQuery, GetStopsAlongInfrastructureLinksQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStopsAlongInfrastructureLinksQuery, GetStopsAlongInfrastructureLinksQueryVariables>(GetStopsAlongInfrastructureLinksDocument, options);
      }
export function useGetStopsAlongInfrastructureLinksLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStopsAlongInfrastructureLinksQuery, GetStopsAlongInfrastructureLinksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStopsAlongInfrastructureLinksQuery, GetStopsAlongInfrastructureLinksQueryVariables>(GetStopsAlongInfrastructureLinksDocument, options);
        }
export function useGetStopsAlongInfrastructureLinksSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetStopsAlongInfrastructureLinksQuery, GetStopsAlongInfrastructureLinksQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetStopsAlongInfrastructureLinksQuery, GetStopsAlongInfrastructureLinksQueryVariables>(GetStopsAlongInfrastructureLinksDocument, options);
        }
export type GetStopsAlongInfrastructureLinksQueryHookResult = ReturnType<typeof useGetStopsAlongInfrastructureLinksQuery>;
export type GetStopsAlongInfrastructureLinksLazyQueryHookResult = ReturnType<typeof useGetStopsAlongInfrastructureLinksLazyQuery>;
export type GetStopsAlongInfrastructureLinksSuspenseQueryHookResult = ReturnType<typeof useGetStopsAlongInfrastructureLinksSuspenseQuery>;
export type GetStopsAlongInfrastructureLinksQueryResult = Apollo.QueryResult<GetStopsAlongInfrastructureLinksQuery, GetStopsAlongInfrastructureLinksQueryVariables>;
export const PatchScheduledStopPointViaInfoDocument = gql`
    mutation PatchScheduledStopPointViaInfo($stopLabel: String!, $journeyPatternId: uuid!, $patch: journey_pattern_scheduled_stop_point_in_journey_pattern_set_input!) {
  update_journey_pattern_scheduled_stop_point_in_journey_pattern(
    where: {scheduled_stop_point_label: {_eq: $stopLabel}, journey_pattern_id: {_eq: $journeyPatternId}}
    _set: $patch
  ) {
    returning {
      ...scheduled_stop_point_in_journey_pattern_all_fields
    }
  }
}
    ${ScheduledStopPointInJourneyPatternAllFieldsFragmentDoc}`;
export type PatchScheduledStopPointViaInfoMutationFn = Apollo.MutationFunction<PatchScheduledStopPointViaInfoMutation, PatchScheduledStopPointViaInfoMutationVariables>;

/**
 * __usePatchScheduledStopPointViaInfoMutation__
 *
 * To run a mutation, you first call `usePatchScheduledStopPointViaInfoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePatchScheduledStopPointViaInfoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [patchScheduledStopPointViaInfoMutation, { data, loading, error }] = usePatchScheduledStopPointViaInfoMutation({
 *   variables: {
 *      stopLabel: // value for 'stopLabel'
 *      journeyPatternId: // value for 'journeyPatternId'
 *      patch: // value for 'patch'
 *   },
 * });
 */
export function usePatchScheduledStopPointViaInfoMutation(baseOptions?: Apollo.MutationHookOptions<PatchScheduledStopPointViaInfoMutation, PatchScheduledStopPointViaInfoMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PatchScheduledStopPointViaInfoMutation, PatchScheduledStopPointViaInfoMutationVariables>(PatchScheduledStopPointViaInfoDocument, options);
      }
export type PatchScheduledStopPointViaInfoMutationHookResult = ReturnType<typeof usePatchScheduledStopPointViaInfoMutation>;
export type PatchScheduledStopPointViaInfoMutationResult = Apollo.MutationResult<PatchScheduledStopPointViaInfoMutation>;
export type PatchScheduledStopPointViaInfoMutationOptions = Apollo.BaseMutationOptions<PatchScheduledStopPointViaInfoMutation, PatchScheduledStopPointViaInfoMutationVariables>;
export const RemoveScheduledStopPointViaInfoDocument = gql`
    mutation RemoveScheduledStopPointViaInfo($stopLabel: String!, $journeyPatternId: uuid!) {
  update_journey_pattern_scheduled_stop_point_in_journey_pattern(
    where: {scheduled_stop_point_label: {_eq: $stopLabel}, journey_pattern_id: {_eq: $journeyPatternId}}
    _set: {is_via_point: false, via_point_name_i18n: null, via_point_short_name_i18n: null}
  ) {
    returning {
      ...scheduled_stop_point_in_journey_pattern_all_fields
    }
  }
}
    ${ScheduledStopPointInJourneyPatternAllFieldsFragmentDoc}`;
export type RemoveScheduledStopPointViaInfoMutationFn = Apollo.MutationFunction<RemoveScheduledStopPointViaInfoMutation, RemoveScheduledStopPointViaInfoMutationVariables>;

/**
 * __useRemoveScheduledStopPointViaInfoMutation__
 *
 * To run a mutation, you first call `useRemoveScheduledStopPointViaInfoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveScheduledStopPointViaInfoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeScheduledStopPointViaInfoMutation, { data, loading, error }] = useRemoveScheduledStopPointViaInfoMutation({
 *   variables: {
 *      stopLabel: // value for 'stopLabel'
 *      journeyPatternId: // value for 'journeyPatternId'
 *   },
 * });
 */
export function useRemoveScheduledStopPointViaInfoMutation(baseOptions?: Apollo.MutationHookOptions<RemoveScheduledStopPointViaInfoMutation, RemoveScheduledStopPointViaInfoMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveScheduledStopPointViaInfoMutation, RemoveScheduledStopPointViaInfoMutationVariables>(RemoveScheduledStopPointViaInfoDocument, options);
      }
export type RemoveScheduledStopPointViaInfoMutationHookResult = ReturnType<typeof useRemoveScheduledStopPointViaInfoMutation>;
export type RemoveScheduledStopPointViaInfoMutationResult = Apollo.MutationResult<RemoveScheduledStopPointViaInfoMutation>;
export type RemoveScheduledStopPointViaInfoMutationOptions = Apollo.BaseMutationOptions<RemoveScheduledStopPointViaInfoMutation, RemoveScheduledStopPointViaInfoMutationVariables>;
export const GetScheduledStopPointWithViaInfoDocument = gql`
    query GetScheduledStopPointWithViaInfo($journeyPatternId: uuid!, $stopLabel: String!) {
  journey_pattern_scheduled_stop_point_in_journey_pattern(
    where: {journey_pattern_id: {_eq: $journeyPatternId}, scheduled_stop_point_label: {_eq: $stopLabel}}
  ) {
    ...scheduled_stop_point_in_journey_pattern_all_fields
    journey_pattern {
      journey_pattern_id
      journey_pattern_route {
        route_id
        label
      }
    }
  }
}
    ${ScheduledStopPointInJourneyPatternAllFieldsFragmentDoc}`;

/**
 * __useGetScheduledStopPointWithViaInfoQuery__
 *
 * To run a query within a React component, call `useGetScheduledStopPointWithViaInfoQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetScheduledStopPointWithViaInfoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetScheduledStopPointWithViaInfoQuery({
 *   variables: {
 *      journeyPatternId: // value for 'journeyPatternId'
 *      stopLabel: // value for 'stopLabel'
 *   },
 * });
 */
export function useGetScheduledStopPointWithViaInfoQuery(baseOptions: Apollo.QueryHookOptions<GetScheduledStopPointWithViaInfoQuery, GetScheduledStopPointWithViaInfoQueryVariables> & ({ variables: GetScheduledStopPointWithViaInfoQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetScheduledStopPointWithViaInfoQuery, GetScheduledStopPointWithViaInfoQueryVariables>(GetScheduledStopPointWithViaInfoDocument, options);
      }
export function useGetScheduledStopPointWithViaInfoLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetScheduledStopPointWithViaInfoQuery, GetScheduledStopPointWithViaInfoQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetScheduledStopPointWithViaInfoQuery, GetScheduledStopPointWithViaInfoQueryVariables>(GetScheduledStopPointWithViaInfoDocument, options);
        }
export function useGetScheduledStopPointWithViaInfoSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetScheduledStopPointWithViaInfoQuery, GetScheduledStopPointWithViaInfoQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetScheduledStopPointWithViaInfoQuery, GetScheduledStopPointWithViaInfoQueryVariables>(GetScheduledStopPointWithViaInfoDocument, options);
        }
export type GetScheduledStopPointWithViaInfoQueryHookResult = ReturnType<typeof useGetScheduledStopPointWithViaInfoQuery>;
export type GetScheduledStopPointWithViaInfoLazyQueryHookResult = ReturnType<typeof useGetScheduledStopPointWithViaInfoLazyQuery>;
export type GetScheduledStopPointWithViaInfoSuspenseQueryHookResult = ReturnType<typeof useGetScheduledStopPointWithViaInfoSuspenseQuery>;
export type GetScheduledStopPointWithViaInfoQueryResult = Apollo.QueryResult<GetScheduledStopPointWithViaInfoQuery, GetScheduledStopPointWithViaInfoQueryVariables>;
export const GetLineDetailsByIdDocument = gql`
    query GetLineDetailsById($line_id: uuid!) {
  route_line_by_pk(line_id: $line_id) {
    ...line_all_fields
  }
}
    ${LineAllFieldsFragmentDoc}`;

/**
 * __useGetLineDetailsByIdQuery__
 *
 * To run a query within a React component, call `useGetLineDetailsByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLineDetailsByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLineDetailsByIdQuery({
 *   variables: {
 *      line_id: // value for 'line_id'
 *   },
 * });
 */
export function useGetLineDetailsByIdQuery(baseOptions: Apollo.QueryHookOptions<GetLineDetailsByIdQuery, GetLineDetailsByIdQueryVariables> & ({ variables: GetLineDetailsByIdQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetLineDetailsByIdQuery, GetLineDetailsByIdQueryVariables>(GetLineDetailsByIdDocument, options);
      }
export function useGetLineDetailsByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetLineDetailsByIdQuery, GetLineDetailsByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetLineDetailsByIdQuery, GetLineDetailsByIdQueryVariables>(GetLineDetailsByIdDocument, options);
        }
export function useGetLineDetailsByIdSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetLineDetailsByIdQuery, GetLineDetailsByIdQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetLineDetailsByIdQuery, GetLineDetailsByIdQueryVariables>(GetLineDetailsByIdDocument, options);
        }
export type GetLineDetailsByIdQueryHookResult = ReturnType<typeof useGetLineDetailsByIdQuery>;
export type GetLineDetailsByIdLazyQueryHookResult = ReturnType<typeof useGetLineDetailsByIdLazyQuery>;
export type GetLineDetailsByIdSuspenseQueryHookResult = ReturnType<typeof useGetLineDetailsByIdSuspenseQuery>;
export type GetLineDetailsByIdQueryResult = Apollo.QueryResult<GetLineDetailsByIdQuery, GetLineDetailsByIdQueryVariables>;
export const GetLineValidityPeriodByIdDocument = gql`
    query GetLineValidityPeriodById($line_id: uuid!) {
  route_line_by_pk(line_id: $line_id) {
    line_id
    validity_start
    validity_end
  }
}
    `;

/**
 * __useGetLineValidityPeriodByIdQuery__
 *
 * To run a query within a React component, call `useGetLineValidityPeriodByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLineValidityPeriodByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLineValidityPeriodByIdQuery({
 *   variables: {
 *      line_id: // value for 'line_id'
 *   },
 * });
 */
export function useGetLineValidityPeriodByIdQuery(baseOptions: Apollo.QueryHookOptions<GetLineValidityPeriodByIdQuery, GetLineValidityPeriodByIdQueryVariables> & ({ variables: GetLineValidityPeriodByIdQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetLineValidityPeriodByIdQuery, GetLineValidityPeriodByIdQueryVariables>(GetLineValidityPeriodByIdDocument, options);
      }
export function useGetLineValidityPeriodByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetLineValidityPeriodByIdQuery, GetLineValidityPeriodByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetLineValidityPeriodByIdQuery, GetLineValidityPeriodByIdQueryVariables>(GetLineValidityPeriodByIdDocument, options);
        }
export function useGetLineValidityPeriodByIdSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetLineValidityPeriodByIdQuery, GetLineValidityPeriodByIdQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetLineValidityPeriodByIdQuery, GetLineValidityPeriodByIdQueryVariables>(GetLineValidityPeriodByIdDocument, options);
        }
export type GetLineValidityPeriodByIdQueryHookResult = ReturnType<typeof useGetLineValidityPeriodByIdQuery>;
export type GetLineValidityPeriodByIdLazyQueryHookResult = ReturnType<typeof useGetLineValidityPeriodByIdLazyQuery>;
export type GetLineValidityPeriodByIdSuspenseQueryHookResult = ReturnType<typeof useGetLineValidityPeriodByIdSuspenseQuery>;
export type GetLineValidityPeriodByIdQueryResult = Apollo.QueryResult<GetLineValidityPeriodByIdQuery, GetLineValidityPeriodByIdQueryVariables>;
export const GetLinesByValidityDocument = gql`
    query GetLinesByValidity($filter: route_line_bool_exp) {
  route_line(where: $filter) {
    ...line_all_fields
  }
}
    ${LineAllFieldsFragmentDoc}`;

/**
 * __useGetLinesByValidityQuery__
 *
 * To run a query within a React component, call `useGetLinesByValidityQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLinesByValidityQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLinesByValidityQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *   },
 * });
 */
export function useGetLinesByValidityQuery(baseOptions?: Apollo.QueryHookOptions<GetLinesByValidityQuery, GetLinesByValidityQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetLinesByValidityQuery, GetLinesByValidityQueryVariables>(GetLinesByValidityDocument, options);
      }
export function useGetLinesByValidityLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetLinesByValidityQuery, GetLinesByValidityQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetLinesByValidityQuery, GetLinesByValidityQueryVariables>(GetLinesByValidityDocument, options);
        }
export function useGetLinesByValiditySuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetLinesByValidityQuery, GetLinesByValidityQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetLinesByValidityQuery, GetLinesByValidityQueryVariables>(GetLinesByValidityDocument, options);
        }
export type GetLinesByValidityQueryHookResult = ReturnType<typeof useGetLinesByValidityQuery>;
export type GetLinesByValidityLazyQueryHookResult = ReturnType<typeof useGetLinesByValidityLazyQuery>;
export type GetLinesByValiditySuspenseQueryHookResult = ReturnType<typeof useGetLinesByValiditySuspenseQuery>;
export type GetLinesByValidityQueryResult = Apollo.QueryResult<GetLinesByValidityQuery, GetLinesByValidityQueryVariables>;
export const GetLineDetailsWithRoutesByIdDocument = gql`
    query GetLineDetailsWithRoutesById($line_id: uuid!) {
  route_line_by_pk(line_id: $line_id) {
    ...line_all_fields
    line_routes {
      ...route_all_fields
      infrastructure_links_along_route {
        route_id
        infrastructure_link_id
        infrastructure_link_sequence
        is_traversal_forwards
        infrastructure_link {
          infrastructure_link_id
          scheduled_stop_points_located_on_infrastructure_link {
            ...scheduled_stop_point_all_fields
            scheduled_stop_point_in_journey_patterns {
              ...scheduled_stop_point_in_journey_pattern_all_fields
              journey_pattern {
                journey_pattern_id
                on_route_id
              }
            }
            other_label_instances {
              ...scheduled_stop_point_default_fields
            }
          }
        }
      }
    }
  }
}
    ${LineAllFieldsFragmentDoc}
${RouteAllFieldsFragmentDoc}
${ScheduledStopPointAllFieldsFragmentDoc}
${ScheduledStopPointInJourneyPatternAllFieldsFragmentDoc}
${ScheduledStopPointDefaultFieldsFragmentDoc}`;

/**
 * __useGetLineDetailsWithRoutesByIdQuery__
 *
 * To run a query within a React component, call `useGetLineDetailsWithRoutesByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLineDetailsWithRoutesByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLineDetailsWithRoutesByIdQuery({
 *   variables: {
 *      line_id: // value for 'line_id'
 *   },
 * });
 */
export function useGetLineDetailsWithRoutesByIdQuery(baseOptions: Apollo.QueryHookOptions<GetLineDetailsWithRoutesByIdQuery, GetLineDetailsWithRoutesByIdQueryVariables> & ({ variables: GetLineDetailsWithRoutesByIdQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetLineDetailsWithRoutesByIdQuery, GetLineDetailsWithRoutesByIdQueryVariables>(GetLineDetailsWithRoutesByIdDocument, options);
      }
export function useGetLineDetailsWithRoutesByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetLineDetailsWithRoutesByIdQuery, GetLineDetailsWithRoutesByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetLineDetailsWithRoutesByIdQuery, GetLineDetailsWithRoutesByIdQueryVariables>(GetLineDetailsWithRoutesByIdDocument, options);
        }
export function useGetLineDetailsWithRoutesByIdSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetLineDetailsWithRoutesByIdQuery, GetLineDetailsWithRoutesByIdQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetLineDetailsWithRoutesByIdQuery, GetLineDetailsWithRoutesByIdQueryVariables>(GetLineDetailsWithRoutesByIdDocument, options);
        }
export type GetLineDetailsWithRoutesByIdQueryHookResult = ReturnType<typeof useGetLineDetailsWithRoutesByIdQuery>;
export type GetLineDetailsWithRoutesByIdLazyQueryHookResult = ReturnType<typeof useGetLineDetailsWithRoutesByIdLazyQuery>;
export type GetLineDetailsWithRoutesByIdSuspenseQueryHookResult = ReturnType<typeof useGetLineDetailsWithRoutesByIdSuspenseQuery>;
export type GetLineDetailsWithRoutesByIdQueryResult = Apollo.QueryResult<GetLineDetailsWithRoutesByIdQuery, GetLineDetailsWithRoutesByIdQueryVariables>;
export const GetRoutesWithStopsDocument = gql`
    query GetRoutesWithStops($routeFilters: route_route_bool_exp) {
  route_route(where: $routeFilters) {
    ...route_with_infrastructure_links_with_stops_and_jps
  }
}
    ${RouteWithInfrastructureLinksWithStopsAndJpsFragmentDoc}`;

/**
 * __useGetRoutesWithStopsQuery__
 *
 * To run a query within a React component, call `useGetRoutesWithStopsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRoutesWithStopsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRoutesWithStopsQuery({
 *   variables: {
 *      routeFilters: // value for 'routeFilters'
 *   },
 * });
 */
export function useGetRoutesWithStopsQuery(baseOptions?: Apollo.QueryHookOptions<GetRoutesWithStopsQuery, GetRoutesWithStopsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRoutesWithStopsQuery, GetRoutesWithStopsQueryVariables>(GetRoutesWithStopsDocument, options);
      }
export function useGetRoutesWithStopsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRoutesWithStopsQuery, GetRoutesWithStopsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRoutesWithStopsQuery, GetRoutesWithStopsQueryVariables>(GetRoutesWithStopsDocument, options);
        }
export function useGetRoutesWithStopsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetRoutesWithStopsQuery, GetRoutesWithStopsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetRoutesWithStopsQuery, GetRoutesWithStopsQueryVariables>(GetRoutesWithStopsDocument, options);
        }
export type GetRoutesWithStopsQueryHookResult = ReturnType<typeof useGetRoutesWithStopsQuery>;
export type GetRoutesWithStopsLazyQueryHookResult = ReturnType<typeof useGetRoutesWithStopsLazyQuery>;
export type GetRoutesWithStopsSuspenseQueryHookResult = ReturnType<typeof useGetRoutesWithStopsSuspenseQuery>;
export type GetRoutesWithStopsQueryResult = Apollo.QueryResult<GetRoutesWithStopsQuery, GetRoutesWithStopsQueryVariables>;
export const GetRouteDetailsByIdDocument = gql`
    query GetRouteDetailsById($routeId: uuid!) {
  route_route_by_pk(route_id: $routeId) {
    ...route_with_infrastructure_links_with_stops_and_jps
  }
}
    ${RouteWithInfrastructureLinksWithStopsAndJpsFragmentDoc}`;

/**
 * __useGetRouteDetailsByIdQuery__
 *
 * To run a query within a React component, call `useGetRouteDetailsByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRouteDetailsByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRouteDetailsByIdQuery({
 *   variables: {
 *      routeId: // value for 'routeId'
 *   },
 * });
 */
export function useGetRouteDetailsByIdQuery(baseOptions: Apollo.QueryHookOptions<GetRouteDetailsByIdQuery, GetRouteDetailsByIdQueryVariables> & ({ variables: GetRouteDetailsByIdQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRouteDetailsByIdQuery, GetRouteDetailsByIdQueryVariables>(GetRouteDetailsByIdDocument, options);
      }
export function useGetRouteDetailsByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRouteDetailsByIdQuery, GetRouteDetailsByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRouteDetailsByIdQuery, GetRouteDetailsByIdQueryVariables>(GetRouteDetailsByIdDocument, options);
        }
export function useGetRouteDetailsByIdSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetRouteDetailsByIdQuery, GetRouteDetailsByIdQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetRouteDetailsByIdQuery, GetRouteDetailsByIdQueryVariables>(GetRouteDetailsByIdDocument, options);
        }
export type GetRouteDetailsByIdQueryHookResult = ReturnType<typeof useGetRouteDetailsByIdQuery>;
export type GetRouteDetailsByIdLazyQueryHookResult = ReturnType<typeof useGetRouteDetailsByIdLazyQuery>;
export type GetRouteDetailsByIdSuspenseQueryHookResult = ReturnType<typeof useGetRouteDetailsByIdSuspenseQuery>;
export type GetRouteDetailsByIdQueryResult = Apollo.QueryResult<GetRouteDetailsByIdQuery, GetRouteDetailsByIdQueryVariables>;
export const GetRouteDetailsByIdsDocument = gql`
    query GetRouteDetailsByIds($route_ids: [uuid!]) {
  route_route(where: {route_id: {_in: $route_ids}}) {
    ...route_with_infrastructure_links_with_stops_and_jps
  }
}
    ${RouteWithInfrastructureLinksWithStopsAndJpsFragmentDoc}`;

/**
 * __useGetRouteDetailsByIdsQuery__
 *
 * To run a query within a React component, call `useGetRouteDetailsByIdsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRouteDetailsByIdsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRouteDetailsByIdsQuery({
 *   variables: {
 *      route_ids: // value for 'route_ids'
 *   },
 * });
 */
export function useGetRouteDetailsByIdsQuery(baseOptions?: Apollo.QueryHookOptions<GetRouteDetailsByIdsQuery, GetRouteDetailsByIdsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRouteDetailsByIdsQuery, GetRouteDetailsByIdsQueryVariables>(GetRouteDetailsByIdsDocument, options);
      }
export function useGetRouteDetailsByIdsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRouteDetailsByIdsQuery, GetRouteDetailsByIdsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRouteDetailsByIdsQuery, GetRouteDetailsByIdsQueryVariables>(GetRouteDetailsByIdsDocument, options);
        }
export function useGetRouteDetailsByIdsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetRouteDetailsByIdsQuery, GetRouteDetailsByIdsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetRouteDetailsByIdsQuery, GetRouteDetailsByIdsQueryVariables>(GetRouteDetailsByIdsDocument, options);
        }
export type GetRouteDetailsByIdsQueryHookResult = ReturnType<typeof useGetRouteDetailsByIdsQuery>;
export type GetRouteDetailsByIdsLazyQueryHookResult = ReturnType<typeof useGetRouteDetailsByIdsLazyQuery>;
export type GetRouteDetailsByIdsSuspenseQueryHookResult = ReturnType<typeof useGetRouteDetailsByIdsSuspenseQuery>;
export type GetRouteDetailsByIdsQueryResult = Apollo.QueryResult<GetRouteDetailsByIdsQuery, GetRouteDetailsByIdsQueryVariables>;
export const GetRouteRenderInfoByIdDocument = gql`
    query GetRouteRenderInfoById($routeId: uuid!) {
  route_route_by_pk(route_id: $routeId) {
    route_id
    route_shape
    route_line {
      line_id
      primary_vehicle_mode
    }
  }
}
    `;

/**
 * __useGetRouteRenderInfoByIdQuery__
 *
 * To run a query within a React component, call `useGetRouteRenderInfoByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRouteRenderInfoByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRouteRenderInfoByIdQuery({
 *   variables: {
 *      routeId: // value for 'routeId'
 *   },
 * });
 */
export function useGetRouteRenderInfoByIdQuery(baseOptions: Apollo.QueryHookOptions<GetRouteRenderInfoByIdQuery, GetRouteRenderInfoByIdQueryVariables> & ({ variables: GetRouteRenderInfoByIdQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRouteRenderInfoByIdQuery, GetRouteRenderInfoByIdQueryVariables>(GetRouteRenderInfoByIdDocument, options);
      }
export function useGetRouteRenderInfoByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRouteRenderInfoByIdQuery, GetRouteRenderInfoByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRouteRenderInfoByIdQuery, GetRouteRenderInfoByIdQueryVariables>(GetRouteRenderInfoByIdDocument, options);
        }
export function useGetRouteRenderInfoByIdSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetRouteRenderInfoByIdQuery, GetRouteRenderInfoByIdQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetRouteRenderInfoByIdQuery, GetRouteRenderInfoByIdQueryVariables>(GetRouteRenderInfoByIdDocument, options);
        }
export type GetRouteRenderInfoByIdQueryHookResult = ReturnType<typeof useGetRouteRenderInfoByIdQuery>;
export type GetRouteRenderInfoByIdLazyQueryHookResult = ReturnType<typeof useGetRouteRenderInfoByIdLazyQuery>;
export type GetRouteRenderInfoByIdSuspenseQueryHookResult = ReturnType<typeof useGetRouteRenderInfoByIdSuspenseQuery>;
export type GetRouteRenderInfoByIdQueryResult = Apollo.QueryResult<GetRouteRenderInfoByIdQuery, GetRouteRenderInfoByIdQueryVariables>;
export const GetRouteDetailsByLabelsDocument = gql`
    query GetRouteDetailsByLabels($labels: [String!], $date: date) {
  route_route(
    where: {label: {_in: $labels}, validity_start: {_lte: $date}, _or: [{validity_end: {_gte: $date}}, {validity_end: {_is_null: true}}]}
  ) {
    ...route_with_journey_pattern_stops
    route_line {
      line_id
      label
      primary_vehicle_mode
    }
  }
}
    ${RouteWithJourneyPatternStopsFragmentDoc}`;

/**
 * __useGetRouteDetailsByLabelsQuery__
 *
 * To run a query within a React component, call `useGetRouteDetailsByLabelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRouteDetailsByLabelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRouteDetailsByLabelsQuery({
 *   variables: {
 *      labels: // value for 'labels'
 *      date: // value for 'date'
 *   },
 * });
 */
export function useGetRouteDetailsByLabelsQuery(baseOptions?: Apollo.QueryHookOptions<GetRouteDetailsByLabelsQuery, GetRouteDetailsByLabelsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRouteDetailsByLabelsQuery, GetRouteDetailsByLabelsQueryVariables>(GetRouteDetailsByLabelsDocument, options);
      }
export function useGetRouteDetailsByLabelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRouteDetailsByLabelsQuery, GetRouteDetailsByLabelsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRouteDetailsByLabelsQuery, GetRouteDetailsByLabelsQueryVariables>(GetRouteDetailsByLabelsDocument, options);
        }
export function useGetRouteDetailsByLabelsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetRouteDetailsByLabelsQuery, GetRouteDetailsByLabelsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetRouteDetailsByLabelsQuery, GetRouteDetailsByLabelsQueryVariables>(GetRouteDetailsByLabelsDocument, options);
        }
export type GetRouteDetailsByLabelsQueryHookResult = ReturnType<typeof useGetRouteDetailsByLabelsQuery>;
export type GetRouteDetailsByLabelsLazyQueryHookResult = ReturnType<typeof useGetRouteDetailsByLabelsLazyQuery>;
export type GetRouteDetailsByLabelsSuspenseQueryHookResult = ReturnType<typeof useGetRouteDetailsByLabelsSuspenseQuery>;
export type GetRouteDetailsByLabelsQueryResult = Apollo.QueryResult<GetRouteDetailsByLabelsQuery, GetRouteDetailsByLabelsQueryVariables>;
export const GetRoutesWithInfrastructureLinksDocument = gql`
    query GetRoutesWithInfrastructureLinks($route_ids: [uuid!]) {
  route_route(where: {route_id: {_in: $route_ids}}) {
    ...route_with_infrastructure_links
  }
}
    ${RouteWithInfrastructureLinksFragmentDoc}`;

/**
 * __useGetRoutesWithInfrastructureLinksQuery__
 *
 * To run a query within a React component, call `useGetRoutesWithInfrastructureLinksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRoutesWithInfrastructureLinksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRoutesWithInfrastructureLinksQuery({
 *   variables: {
 *      route_ids: // value for 'route_ids'
 *   },
 * });
 */
export function useGetRoutesWithInfrastructureLinksQuery(baseOptions?: Apollo.QueryHookOptions<GetRoutesWithInfrastructureLinksQuery, GetRoutesWithInfrastructureLinksQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRoutesWithInfrastructureLinksQuery, GetRoutesWithInfrastructureLinksQueryVariables>(GetRoutesWithInfrastructureLinksDocument, options);
      }
export function useGetRoutesWithInfrastructureLinksLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRoutesWithInfrastructureLinksQuery, GetRoutesWithInfrastructureLinksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRoutesWithInfrastructureLinksQuery, GetRoutesWithInfrastructureLinksQueryVariables>(GetRoutesWithInfrastructureLinksDocument, options);
        }
export function useGetRoutesWithInfrastructureLinksSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetRoutesWithInfrastructureLinksQuery, GetRoutesWithInfrastructureLinksQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetRoutesWithInfrastructureLinksQuery, GetRoutesWithInfrastructureLinksQueryVariables>(GetRoutesWithInfrastructureLinksDocument, options);
        }
export type GetRoutesWithInfrastructureLinksQueryHookResult = ReturnType<typeof useGetRoutesWithInfrastructureLinksQuery>;
export type GetRoutesWithInfrastructureLinksLazyQueryHookResult = ReturnType<typeof useGetRoutesWithInfrastructureLinksLazyQuery>;
export type GetRoutesWithInfrastructureLinksSuspenseQueryHookResult = ReturnType<typeof useGetRoutesWithInfrastructureLinksSuspenseQuery>;
export type GetRoutesWithInfrastructureLinksQueryResult = Apollo.QueryResult<GetRoutesWithInfrastructureLinksQuery, GetRoutesWithInfrastructureLinksQueryVariables>;
export const GetRoutesByValidityDocument = gql`
    query GetRoutesByValidity($filter: route_route_bool_exp) {
  route_route(where: $filter) {
    ...route_default_fields
  }
}
    ${RouteDefaultFieldsFragmentDoc}`;

/**
 * __useGetRoutesByValidityQuery__
 *
 * To run a query within a React component, call `useGetRoutesByValidityQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRoutesByValidityQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRoutesByValidityQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *   },
 * });
 */
export function useGetRoutesByValidityQuery(baseOptions?: Apollo.QueryHookOptions<GetRoutesByValidityQuery, GetRoutesByValidityQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRoutesByValidityQuery, GetRoutesByValidityQueryVariables>(GetRoutesByValidityDocument, options);
      }
export function useGetRoutesByValidityLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRoutesByValidityQuery, GetRoutesByValidityQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRoutesByValidityQuery, GetRoutesByValidityQueryVariables>(GetRoutesByValidityDocument, options);
        }
export function useGetRoutesByValiditySuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetRoutesByValidityQuery, GetRoutesByValidityQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetRoutesByValidityQuery, GetRoutesByValidityQueryVariables>(GetRoutesByValidityDocument, options);
        }
export type GetRoutesByValidityQueryHookResult = ReturnType<typeof useGetRoutesByValidityQuery>;
export type GetRoutesByValidityLazyQueryHookResult = ReturnType<typeof useGetRoutesByValidityLazyQuery>;
export type GetRoutesByValiditySuspenseQueryHookResult = ReturnType<typeof useGetRoutesByValiditySuspenseQuery>;
export type GetRoutesByValidityQueryResult = Apollo.QueryResult<GetRoutesByValidityQuery, GetRoutesByValidityQueryVariables>;
export const InsertLineOneDocument = gql`
    mutation InsertLineOne($object: route_line_insert_input!) {
  insert_route_line_one(object: $object) {
    line_id
    label
    priority
    primary_vehicle_mode
    transport_target
    validity_start
    validity_end
  }
}
    `;
export type InsertLineOneMutationFn = Apollo.MutationFunction<InsertLineOneMutation, InsertLineOneMutationVariables>;

/**
 * __useInsertLineOneMutation__
 *
 * To run a mutation, you first call `useInsertLineOneMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertLineOneMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertLineOneMutation, { data, loading, error }] = useInsertLineOneMutation({
 *   variables: {
 *      object: // value for 'object'
 *   },
 * });
 */
export function useInsertLineOneMutation(baseOptions?: Apollo.MutationHookOptions<InsertLineOneMutation, InsertLineOneMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertLineOneMutation, InsertLineOneMutationVariables>(InsertLineOneDocument, options);
      }
export type InsertLineOneMutationHookResult = ReturnType<typeof useInsertLineOneMutation>;
export type InsertLineOneMutationResult = Apollo.MutationResult<InsertLineOneMutation>;
export type InsertLineOneMutationOptions = Apollo.BaseMutationOptions<InsertLineOneMutation, InsertLineOneMutationVariables>;
export const PatchLineDocument = gql`
    mutation PatchLine($line_id: uuid!, $object: route_line_set_input!) {
  update_route_line_by_pk(pk_columns: {line_id: $line_id}, _set: $object) {
    ...line_all_fields
  }
}
    ${LineAllFieldsFragmentDoc}`;
export type PatchLineMutationFn = Apollo.MutationFunction<PatchLineMutation, PatchLineMutationVariables>;

/**
 * __usePatchLineMutation__
 *
 * To run a mutation, you first call `usePatchLineMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePatchLineMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [patchLineMutation, { data, loading, error }] = usePatchLineMutation({
 *   variables: {
 *      line_id: // value for 'line_id'
 *      object: // value for 'object'
 *   },
 * });
 */
export function usePatchLineMutation(baseOptions?: Apollo.MutationHookOptions<PatchLineMutation, PatchLineMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PatchLineMutation, PatchLineMutationVariables>(PatchLineDocument, options);
      }
export type PatchLineMutationHookResult = ReturnType<typeof usePatchLineMutation>;
export type PatchLineMutationResult = Apollo.MutationResult<PatchLineMutation>;
export type PatchLineMutationOptions = Apollo.BaseMutationOptions<PatchLineMutation, PatchLineMutationVariables>;
export const InsertRouteOneDocument = gql`
    mutation InsertRouteOne($object: route_route_insert_input!) {
  insert_route_route_one(object: $object) {
    ...route_all_fields
  }
}
    ${RouteAllFieldsFragmentDoc}`;
export type InsertRouteOneMutationFn = Apollo.MutationFunction<InsertRouteOneMutation, InsertRouteOneMutationVariables>;

/**
 * __useInsertRouteOneMutation__
 *
 * To run a mutation, you first call `useInsertRouteOneMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertRouteOneMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertRouteOneMutation, { data, loading, error }] = useInsertRouteOneMutation({
 *   variables: {
 *      object: // value for 'object'
 *   },
 * });
 */
export function useInsertRouteOneMutation(baseOptions?: Apollo.MutationHookOptions<InsertRouteOneMutation, InsertRouteOneMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertRouteOneMutation, InsertRouteOneMutationVariables>(InsertRouteOneDocument, options);
      }
export type InsertRouteOneMutationHookResult = ReturnType<typeof useInsertRouteOneMutation>;
export type InsertRouteOneMutationResult = Apollo.MutationResult<InsertRouteOneMutation>;
export type InsertRouteOneMutationOptions = Apollo.BaseMutationOptions<InsertRouteOneMutation, InsertRouteOneMutationVariables>;
export const PatchRouteDocument = gql`
    mutation PatchRoute($route_id: uuid!, $object: route_route_set_input!) {
  update_route_route(where: {route_id: {_eq: $route_id}}, _set: $object) {
    returning {
      ...route_all_fields
    }
  }
}
    ${RouteAllFieldsFragmentDoc}`;
export type PatchRouteMutationFn = Apollo.MutationFunction<PatchRouteMutation, PatchRouteMutationVariables>;

/**
 * __usePatchRouteMutation__
 *
 * To run a mutation, you first call `usePatchRouteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePatchRouteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [patchRouteMutation, { data, loading, error }] = usePatchRouteMutation({
 *   variables: {
 *      route_id: // value for 'route_id'
 *      object: // value for 'object'
 *   },
 * });
 */
export function usePatchRouteMutation(baseOptions?: Apollo.MutationHookOptions<PatchRouteMutation, PatchRouteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PatchRouteMutation, PatchRouteMutationVariables>(PatchRouteDocument, options);
      }
export type PatchRouteMutationHookResult = ReturnType<typeof usePatchRouteMutation>;
export type PatchRouteMutationResult = Apollo.MutationResult<PatchRouteMutation>;
export type PatchRouteMutationOptions = Apollo.BaseMutationOptions<PatchRouteMutation, PatchRouteMutationVariables>;
export const DeleteRouteDocument = gql`
    mutation DeleteRoute($route_id: uuid!) {
  delete_route_route(where: {route_id: {_eq: $route_id}}) {
    returning {
      route_id
    }
  }
}
    `;
export type DeleteRouteMutationFn = Apollo.MutationFunction<DeleteRouteMutation, DeleteRouteMutationVariables>;

/**
 * __useDeleteRouteMutation__
 *
 * To run a mutation, you first call `useDeleteRouteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteRouteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteRouteMutation, { data, loading, error }] = useDeleteRouteMutation({
 *   variables: {
 *      route_id: // value for 'route_id'
 *   },
 * });
 */
export function useDeleteRouteMutation(baseOptions?: Apollo.MutationHookOptions<DeleteRouteMutation, DeleteRouteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteRouteMutation, DeleteRouteMutationVariables>(DeleteRouteDocument, options);
      }
export type DeleteRouteMutationHookResult = ReturnType<typeof useDeleteRouteMutation>;
export type DeleteRouteMutationResult = Apollo.MutationResult<DeleteRouteMutation>;
export type DeleteRouteMutationOptions = Apollo.BaseMutationOptions<DeleteRouteMutation, DeleteRouteMutationVariables>;
export const GetScheduledStopsOnRouteDocument = gql`
    query GetScheduledStopsOnRoute($routeId: uuid!) {
  journey_pattern_journey_pattern(where: {on_route_id: {_eq: $routeId}}) {
    journey_pattern_id
    scheduled_stop_point_in_journey_patterns {
      journey_pattern_id
      scheduled_stop_point_sequence
      scheduled_stop_points {
        ...scheduled_stop_point_default_fields
      }
    }
  }
}
    ${ScheduledStopPointDefaultFieldsFragmentDoc}`;

/**
 * __useGetScheduledStopsOnRouteQuery__
 *
 * To run a query within a React component, call `useGetScheduledStopsOnRouteQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetScheduledStopsOnRouteQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetScheduledStopsOnRouteQuery({
 *   variables: {
 *      routeId: // value for 'routeId'
 *   },
 * });
 */
export function useGetScheduledStopsOnRouteQuery(baseOptions: Apollo.QueryHookOptions<GetScheduledStopsOnRouteQuery, GetScheduledStopsOnRouteQueryVariables> & ({ variables: GetScheduledStopsOnRouteQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetScheduledStopsOnRouteQuery, GetScheduledStopsOnRouteQueryVariables>(GetScheduledStopsOnRouteDocument, options);
      }
export function useGetScheduledStopsOnRouteLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetScheduledStopsOnRouteQuery, GetScheduledStopsOnRouteQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetScheduledStopsOnRouteQuery, GetScheduledStopsOnRouteQueryVariables>(GetScheduledStopsOnRouteDocument, options);
        }
export function useGetScheduledStopsOnRouteSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetScheduledStopsOnRouteQuery, GetScheduledStopsOnRouteQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetScheduledStopsOnRouteQuery, GetScheduledStopsOnRouteQueryVariables>(GetScheduledStopsOnRouteDocument, options);
        }
export type GetScheduledStopsOnRouteQueryHookResult = ReturnType<typeof useGetScheduledStopsOnRouteQuery>;
export type GetScheduledStopsOnRouteLazyQueryHookResult = ReturnType<typeof useGetScheduledStopsOnRouteLazyQuery>;
export type GetScheduledStopsOnRouteSuspenseQueryHookResult = ReturnType<typeof useGetScheduledStopsOnRouteSuspenseQuery>;
export type GetScheduledStopsOnRouteQueryResult = Apollo.QueryResult<GetScheduledStopsOnRouteQuery, GetScheduledStopsOnRouteQueryVariables>;
export const RemoveStopDocument = gql`
    mutation RemoveStop($stop_id: uuid!) {
  delete_service_pattern_scheduled_stop_point(
    where: {scheduled_stop_point_id: {_eq: $stop_id}}
  ) {
    returning {
      scheduled_stop_point_id
    }
  }
}
    `;
export type RemoveStopMutationFn = Apollo.MutationFunction<RemoveStopMutation, RemoveStopMutationVariables>;

/**
 * __useRemoveStopMutation__
 *
 * To run a mutation, you first call `useRemoveStopMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveStopMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeStopMutation, { data, loading, error }] = useRemoveStopMutation({
 *   variables: {
 *      stop_id: // value for 'stop_id'
 *   },
 * });
 */
export function useRemoveStopMutation(baseOptions?: Apollo.MutationHookOptions<RemoveStopMutation, RemoveStopMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveStopMutation, RemoveStopMutationVariables>(RemoveStopDocument, options);
      }
export type RemoveStopMutationHookResult = ReturnType<typeof useRemoveStopMutation>;
export type RemoveStopMutationResult = Apollo.MutationResult<RemoveStopMutation>;
export type RemoveStopMutationOptions = Apollo.BaseMutationOptions<RemoveStopMutation, RemoveStopMutationVariables>;
export const GetStopsByValidityDocument = gql`
    query GetStopsByValidity($filter: service_pattern_scheduled_stop_point_bool_exp) {
  service_pattern_scheduled_stop_point(where: $filter) {
    ...scheduled_stop_point_all_fields
  }
}
    ${ScheduledStopPointAllFieldsFragmentDoc}`;

/**
 * __useGetStopsByValidityQuery__
 *
 * To run a query within a React component, call `useGetStopsByValidityQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStopsByValidityQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStopsByValidityQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *   },
 * });
 */
export function useGetStopsByValidityQuery(baseOptions?: Apollo.QueryHookOptions<GetStopsByValidityQuery, GetStopsByValidityQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStopsByValidityQuery, GetStopsByValidityQueryVariables>(GetStopsByValidityDocument, options);
      }
export function useGetStopsByValidityLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStopsByValidityQuery, GetStopsByValidityQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStopsByValidityQuery, GetStopsByValidityQueryVariables>(GetStopsByValidityDocument, options);
        }
export function useGetStopsByValiditySuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetStopsByValidityQuery, GetStopsByValidityQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetStopsByValidityQuery, GetStopsByValidityQueryVariables>(GetStopsByValidityDocument, options);
        }
export type GetStopsByValidityQueryHookResult = ReturnType<typeof useGetStopsByValidityQuery>;
export type GetStopsByValidityLazyQueryHookResult = ReturnType<typeof useGetStopsByValidityLazyQuery>;
export type GetStopsByValiditySuspenseQueryHookResult = ReturnType<typeof useGetStopsByValiditySuspenseQuery>;
export type GetStopsByValidityQueryResult = Apollo.QueryResult<GetStopsByValidityQuery, GetStopsByValidityQueryVariables>;
export const GetStopsByIdsDocument = gql`
    query GetStopsByIds($stopIds: [uuid!]) {
  service_pattern_scheduled_stop_point(
    where: {scheduled_stop_point_id: {_in: $stopIds}}
  ) {
    ...scheduled_stop_point_all_fields
  }
}
    ${ScheduledStopPointAllFieldsFragmentDoc}`;

/**
 * __useGetStopsByIdsQuery__
 *
 * To run a query within a React component, call `useGetStopsByIdsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStopsByIdsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStopsByIdsQuery({
 *   variables: {
 *      stopIds: // value for 'stopIds'
 *   },
 * });
 */
export function useGetStopsByIdsQuery(baseOptions?: Apollo.QueryHookOptions<GetStopsByIdsQuery, GetStopsByIdsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStopsByIdsQuery, GetStopsByIdsQueryVariables>(GetStopsByIdsDocument, options);
      }
export function useGetStopsByIdsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStopsByIdsQuery, GetStopsByIdsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStopsByIdsQuery, GetStopsByIdsQueryVariables>(GetStopsByIdsDocument, options);
        }
export function useGetStopsByIdsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetStopsByIdsQuery, GetStopsByIdsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetStopsByIdsQuery, GetStopsByIdsQueryVariables>(GetStopsByIdsDocument, options);
        }
export type GetStopsByIdsQueryHookResult = ReturnType<typeof useGetStopsByIdsQuery>;
export type GetStopsByIdsLazyQueryHookResult = ReturnType<typeof useGetStopsByIdsLazyQuery>;
export type GetStopsByIdsSuspenseQueryHookResult = ReturnType<typeof useGetStopsByIdsSuspenseQuery>;
export type GetStopsByIdsQueryResult = Apollo.QueryResult<GetStopsByIdsQuery, GetStopsByIdsQueryVariables>;
export const GetStopsByLabelsDocument = gql`
    query GetStopsByLabels($stopLabels: [String!]) {
  service_pattern_scheduled_stop_point(where: {label: {_in: $stopLabels}}) {
    ...scheduled_stop_point_all_fields
  }
}
    ${ScheduledStopPointAllFieldsFragmentDoc}`;

/**
 * __useGetStopsByLabelsQuery__
 *
 * To run a query within a React component, call `useGetStopsByLabelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStopsByLabelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStopsByLabelsQuery({
 *   variables: {
 *      stopLabels: // value for 'stopLabels'
 *   },
 * });
 */
export function useGetStopsByLabelsQuery(baseOptions?: Apollo.QueryHookOptions<GetStopsByLabelsQuery, GetStopsByLabelsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStopsByLabelsQuery, GetStopsByLabelsQueryVariables>(GetStopsByLabelsDocument, options);
      }
export function useGetStopsByLabelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStopsByLabelsQuery, GetStopsByLabelsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStopsByLabelsQuery, GetStopsByLabelsQueryVariables>(GetStopsByLabelsDocument, options);
        }
export function useGetStopsByLabelsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetStopsByLabelsQuery, GetStopsByLabelsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetStopsByLabelsQuery, GetStopsByLabelsQueryVariables>(GetStopsByLabelsDocument, options);
        }
export type GetStopsByLabelsQueryHookResult = ReturnType<typeof useGetStopsByLabelsQuery>;
export type GetStopsByLabelsLazyQueryHookResult = ReturnType<typeof useGetStopsByLabelsLazyQuery>;
export type GetStopsByLabelsSuspenseQueryHookResult = ReturnType<typeof useGetStopsByLabelsSuspenseQuery>;
export type GetStopsByLabelsQueryResult = Apollo.QueryResult<GetStopsByLabelsQuery, GetStopsByLabelsQueryVariables>;
export const GetStopWithRouteGraphDataByIdDocument = gql`
    query GetStopWithRouteGraphDataById($stopId: uuid!) {
  service_pattern_scheduled_stop_point(
    where: {scheduled_stop_point_id: {_eq: $stopId}}
  ) {
    ...scheduled_stop_point_all_fields
    scheduled_stop_point_in_journey_patterns {
      ...scheduled_stop_point_in_journey_pattern_all_fields
      journey_pattern {
        journey_pattern_id
        journey_pattern_route {
          ...route_default_fields
          infrastructure_links_along_route {
            route_id
            infrastructure_link_id
            infrastructure_link_sequence
          }
        }
      }
    }
  }
}
    ${ScheduledStopPointAllFieldsFragmentDoc}
${ScheduledStopPointInJourneyPatternAllFieldsFragmentDoc}
${RouteDefaultFieldsFragmentDoc}`;

/**
 * __useGetStopWithRouteGraphDataByIdQuery__
 *
 * To run a query within a React component, call `useGetStopWithRouteGraphDataByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStopWithRouteGraphDataByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStopWithRouteGraphDataByIdQuery({
 *   variables: {
 *      stopId: // value for 'stopId'
 *   },
 * });
 */
export function useGetStopWithRouteGraphDataByIdQuery(baseOptions: Apollo.QueryHookOptions<GetStopWithRouteGraphDataByIdQuery, GetStopWithRouteGraphDataByIdQueryVariables> & ({ variables: GetStopWithRouteGraphDataByIdQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStopWithRouteGraphDataByIdQuery, GetStopWithRouteGraphDataByIdQueryVariables>(GetStopWithRouteGraphDataByIdDocument, options);
      }
export function useGetStopWithRouteGraphDataByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStopWithRouteGraphDataByIdQuery, GetStopWithRouteGraphDataByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStopWithRouteGraphDataByIdQuery, GetStopWithRouteGraphDataByIdQueryVariables>(GetStopWithRouteGraphDataByIdDocument, options);
        }
export function useGetStopWithRouteGraphDataByIdSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetStopWithRouteGraphDataByIdQuery, GetStopWithRouteGraphDataByIdQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetStopWithRouteGraphDataByIdQuery, GetStopWithRouteGraphDataByIdQueryVariables>(GetStopWithRouteGraphDataByIdDocument, options);
        }
export type GetStopWithRouteGraphDataByIdQueryHookResult = ReturnType<typeof useGetStopWithRouteGraphDataByIdQuery>;
export type GetStopWithRouteGraphDataByIdLazyQueryHookResult = ReturnType<typeof useGetStopWithRouteGraphDataByIdLazyQuery>;
export type GetStopWithRouteGraphDataByIdSuspenseQueryHookResult = ReturnType<typeof useGetStopWithRouteGraphDataByIdSuspenseQuery>;
export type GetStopWithRouteGraphDataByIdQueryResult = Apollo.QueryResult<GetStopWithRouteGraphDataByIdQuery, GetStopWithRouteGraphDataByIdQueryVariables>;
export const GetHighestPriorityLineDetailsWithRoutesDocument = gql`
    query GetHighestPriorityLineDetailsWithRoutes($lineFilters: route_line_bool_exp, $lineRouteFilters: route_route_bool_exp, $routeStopFilters: service_pattern_scheduled_stop_point_bool_exp) {
  route_line(where: $lineFilters, order_by: {priority: desc}, limit: 1) {
    ...line_with_routes_unique_fields
  }
}
    ${LineWithRoutesUniqueFieldsFragmentDoc}`;

/**
 * __useGetHighestPriorityLineDetailsWithRoutesQuery__
 *
 * To run a query within a React component, call `useGetHighestPriorityLineDetailsWithRoutesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetHighestPriorityLineDetailsWithRoutesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetHighestPriorityLineDetailsWithRoutesQuery({
 *   variables: {
 *      lineFilters: // value for 'lineFilters'
 *      lineRouteFilters: // value for 'lineRouteFilters'
 *      routeStopFilters: // value for 'routeStopFilters'
 *   },
 * });
 */
export function useGetHighestPriorityLineDetailsWithRoutesQuery(baseOptions?: Apollo.QueryHookOptions<GetHighestPriorityLineDetailsWithRoutesQuery, GetHighestPriorityLineDetailsWithRoutesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetHighestPriorityLineDetailsWithRoutesQuery, GetHighestPriorityLineDetailsWithRoutesQueryVariables>(GetHighestPriorityLineDetailsWithRoutesDocument, options);
      }
export function useGetHighestPriorityLineDetailsWithRoutesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetHighestPriorityLineDetailsWithRoutesQuery, GetHighestPriorityLineDetailsWithRoutesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetHighestPriorityLineDetailsWithRoutesQuery, GetHighestPriorityLineDetailsWithRoutesQueryVariables>(GetHighestPriorityLineDetailsWithRoutesDocument, options);
        }
export function useGetHighestPriorityLineDetailsWithRoutesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetHighestPriorityLineDetailsWithRoutesQuery, GetHighestPriorityLineDetailsWithRoutesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetHighestPriorityLineDetailsWithRoutesQuery, GetHighestPriorityLineDetailsWithRoutesQueryVariables>(GetHighestPriorityLineDetailsWithRoutesDocument, options);
        }
export type GetHighestPriorityLineDetailsWithRoutesQueryHookResult = ReturnType<typeof useGetHighestPriorityLineDetailsWithRoutesQuery>;
export type GetHighestPriorityLineDetailsWithRoutesLazyQueryHookResult = ReturnType<typeof useGetHighestPriorityLineDetailsWithRoutesLazyQuery>;
export type GetHighestPriorityLineDetailsWithRoutesSuspenseQueryHookResult = ReturnType<typeof useGetHighestPriorityLineDetailsWithRoutesSuspenseQuery>;
export type GetHighestPriorityLineDetailsWithRoutesQueryResult = Apollo.QueryResult<GetHighestPriorityLineDetailsWithRoutesQuery, GetHighestPriorityLineDetailsWithRoutesQueryVariables>;
export const UpdateRouteGeometryDocument = gql`
    mutation UpdateRouteGeometry($route_id: uuid!, $journey_pattern_id: uuid!, $new_infrastructure_links: [route_infrastructure_link_along_route_insert_input!]!, $new_stops_in_journey_pattern: [journey_pattern_scheduled_stop_point_in_journey_pattern_insert_input!]!) {
  delete_route_infrastructure_link_along_route(
    where: {route_id: {_eq: $route_id}}
  ) {
    returning {
      infrastructure_link_id
      infrastructure_link_sequence
      route_id
    }
  }
  insert_route_infrastructure_link_along_route(objects: $new_infrastructure_links) {
    returning {
      route_id
      infrastructure_link_id
      infrastructure_link_sequence
      infrastructure_link {
        infrastructure_link_id
        shape
      }
      is_traversal_forwards
    }
  }
  delete_journey_pattern_scheduled_stop_point_in_journey_pattern(
    where: {journey_pattern_id: {_eq: $journey_pattern_id}}
  ) {
    returning {
      scheduled_stop_point_label
      scheduled_stop_point_sequence
      journey_pattern_id
    }
  }
  insert_journey_pattern_scheduled_stop_point_in_journey_pattern(
    objects: $new_stops_in_journey_pattern
  ) {
    returning {
      scheduled_stop_point_label
      scheduled_stop_point_sequence
      journey_pattern_id
    }
  }
}
    `;
export type UpdateRouteGeometryMutationFn = Apollo.MutationFunction<UpdateRouteGeometryMutation, UpdateRouteGeometryMutationVariables>;

/**
 * __useUpdateRouteGeometryMutation__
 *
 * To run a mutation, you first call `useUpdateRouteGeometryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRouteGeometryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRouteGeometryMutation, { data, loading, error }] = useUpdateRouteGeometryMutation({
 *   variables: {
 *      route_id: // value for 'route_id'
 *      journey_pattern_id: // value for 'journey_pattern_id'
 *      new_infrastructure_links: // value for 'new_infrastructure_links'
 *      new_stops_in_journey_pattern: // value for 'new_stops_in_journey_pattern'
 *   },
 * });
 */
export function useUpdateRouteGeometryMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRouteGeometryMutation, UpdateRouteGeometryMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRouteGeometryMutation, UpdateRouteGeometryMutationVariables>(UpdateRouteGeometryDocument, options);
      }
export type UpdateRouteGeometryMutationHookResult = ReturnType<typeof useUpdateRouteGeometryMutation>;
export type UpdateRouteGeometryMutationResult = Apollo.MutationResult<UpdateRouteGeometryMutation>;
export type UpdateRouteGeometryMutationOptions = Apollo.BaseMutationOptions<UpdateRouteGeometryMutation, UpdateRouteGeometryMutationVariables>;
export const UpdateRouteJourneyPatternDocument = gql`
    mutation UpdateRouteJourneyPattern($journey_pattern_id: uuid!, $new_stops_in_journey_pattern: [journey_pattern_scheduled_stop_point_in_journey_pattern_insert_input!]!) {
  delete_journey_pattern_scheduled_stop_point_in_journey_pattern(
    where: {journey_pattern_id: {_eq: $journey_pattern_id}}
  ) {
    returning {
      scheduled_stop_point_label
      scheduled_stop_point_sequence
      journey_pattern_id
    }
  }
  insert_journey_pattern_scheduled_stop_point_in_journey_pattern(
    objects: $new_stops_in_journey_pattern
  ) {
    returning {
      scheduled_stop_point_label
      scheduled_stop_point_sequence
      journey_pattern_id
    }
  }
}
    `;
export type UpdateRouteJourneyPatternMutationFn = Apollo.MutationFunction<UpdateRouteJourneyPatternMutation, UpdateRouteJourneyPatternMutationVariables>;

/**
 * __useUpdateRouteJourneyPatternMutation__
 *
 * To run a mutation, you first call `useUpdateRouteJourneyPatternMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRouteJourneyPatternMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRouteJourneyPatternMutation, { data, loading, error }] = useUpdateRouteJourneyPatternMutation({
 *   variables: {
 *      journey_pattern_id: // value for 'journey_pattern_id'
 *      new_stops_in_journey_pattern: // value for 'new_stops_in_journey_pattern'
 *   },
 * });
 */
export function useUpdateRouteJourneyPatternMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRouteJourneyPatternMutation, UpdateRouteJourneyPatternMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRouteJourneyPatternMutation, UpdateRouteJourneyPatternMutationVariables>(UpdateRouteJourneyPatternDocument, options);
      }
export type UpdateRouteJourneyPatternMutationHookResult = ReturnType<typeof useUpdateRouteJourneyPatternMutation>;
export type UpdateRouteJourneyPatternMutationResult = Apollo.MutationResult<UpdateRouteJourneyPatternMutation>;
export type UpdateRouteJourneyPatternMutationOptions = Apollo.BaseMutationOptions<UpdateRouteJourneyPatternMutation, UpdateRouteJourneyPatternMutationVariables>;
export const GetLinksWithStopsByExternalLinkIdsDocument = gql`
    query GetLinksWithStopsByExternalLinkIds($externalLinkIds: [String!]) {
  infrastructure_network_infrastructure_link(
    where: {external_link_id: {_in: $externalLinkIds}}
  ) {
    ...route_infra_link_fields
  }
}
    ${RouteInfraLinkFieldsFragmentDoc}`;

/**
 * __useGetLinksWithStopsByExternalLinkIdsQuery__
 *
 * To run a query within a React component, call `useGetLinksWithStopsByExternalLinkIdsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLinksWithStopsByExternalLinkIdsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLinksWithStopsByExternalLinkIdsQuery({
 *   variables: {
 *      externalLinkIds: // value for 'externalLinkIds'
 *   },
 * });
 */
export function useGetLinksWithStopsByExternalLinkIdsQuery(baseOptions?: Apollo.QueryHookOptions<GetLinksWithStopsByExternalLinkIdsQuery, GetLinksWithStopsByExternalLinkIdsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetLinksWithStopsByExternalLinkIdsQuery, GetLinksWithStopsByExternalLinkIdsQueryVariables>(GetLinksWithStopsByExternalLinkIdsDocument, options);
      }
export function useGetLinksWithStopsByExternalLinkIdsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetLinksWithStopsByExternalLinkIdsQuery, GetLinksWithStopsByExternalLinkIdsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetLinksWithStopsByExternalLinkIdsQuery, GetLinksWithStopsByExternalLinkIdsQueryVariables>(GetLinksWithStopsByExternalLinkIdsDocument, options);
        }
export function useGetLinksWithStopsByExternalLinkIdsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetLinksWithStopsByExternalLinkIdsQuery, GetLinksWithStopsByExternalLinkIdsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetLinksWithStopsByExternalLinkIdsQuery, GetLinksWithStopsByExternalLinkIdsQueryVariables>(GetLinksWithStopsByExternalLinkIdsDocument, options);
        }
export type GetLinksWithStopsByExternalLinkIdsQueryHookResult = ReturnType<typeof useGetLinksWithStopsByExternalLinkIdsQuery>;
export type GetLinksWithStopsByExternalLinkIdsLazyQueryHookResult = ReturnType<typeof useGetLinksWithStopsByExternalLinkIdsLazyQuery>;
export type GetLinksWithStopsByExternalLinkIdsSuspenseQueryHookResult = ReturnType<typeof useGetLinksWithStopsByExternalLinkIdsSuspenseQuery>;
export type GetLinksWithStopsByExternalLinkIdsQueryResult = Apollo.QueryResult<GetLinksWithStopsByExternalLinkIdsQuery, GetLinksWithStopsByExternalLinkIdsQueryVariables>;
export const GetLineRoutesByLabelDocument = gql`
    query GetLineRoutesByLabel($lineFilters: route_line_bool_exp, $lineRouteFilters: route_route_bool_exp) {
  route_line(where: $lineFilters) {
    line_id
    line_routes(where: $lineRouteFilters) {
      ...displayed_route
    }
  }
}
    ${DisplayedRouteFragmentDoc}`;

/**
 * __useGetLineRoutesByLabelQuery__
 *
 * To run a query within a React component, call `useGetLineRoutesByLabelQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLineRoutesByLabelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLineRoutesByLabelQuery({
 *   variables: {
 *      lineFilters: // value for 'lineFilters'
 *      lineRouteFilters: // value for 'lineRouteFilters'
 *   },
 * });
 */
export function useGetLineRoutesByLabelQuery(baseOptions?: Apollo.QueryHookOptions<GetLineRoutesByLabelQuery, GetLineRoutesByLabelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetLineRoutesByLabelQuery, GetLineRoutesByLabelQueryVariables>(GetLineRoutesByLabelDocument, options);
      }
export function useGetLineRoutesByLabelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetLineRoutesByLabelQuery, GetLineRoutesByLabelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetLineRoutesByLabelQuery, GetLineRoutesByLabelQueryVariables>(GetLineRoutesByLabelDocument, options);
        }
export function useGetLineRoutesByLabelSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetLineRoutesByLabelQuery, GetLineRoutesByLabelQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetLineRoutesByLabelQuery, GetLineRoutesByLabelQueryVariables>(GetLineRoutesByLabelDocument, options);
        }
export type GetLineRoutesByLabelQueryHookResult = ReturnType<typeof useGetLineRoutesByLabelQuery>;
export type GetLineRoutesByLabelLazyQueryHookResult = ReturnType<typeof useGetLineRoutesByLabelLazyQuery>;
export type GetLineRoutesByLabelSuspenseQueryHookResult = ReturnType<typeof useGetLineRoutesByLabelSuspenseQuery>;
export type GetLineRoutesByLabelQueryResult = Apollo.QueryResult<GetLineRoutesByLabelQuery, GetLineRoutesByLabelQueryVariables>;
export const GetRouteByFiltersDocument = gql`
    query GetRouteByFilters($routeFilters: route_route_bool_exp) {
  route_route(where: $routeFilters) {
    ...displayed_route
  }
}
    ${DisplayedRouteFragmentDoc}`;

/**
 * __useGetRouteByFiltersQuery__
 *
 * To run a query within a React component, call `useGetRouteByFiltersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRouteByFiltersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRouteByFiltersQuery({
 *   variables: {
 *      routeFilters: // value for 'routeFilters'
 *   },
 * });
 */
export function useGetRouteByFiltersQuery(baseOptions?: Apollo.QueryHookOptions<GetRouteByFiltersQuery, GetRouteByFiltersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRouteByFiltersQuery, GetRouteByFiltersQueryVariables>(GetRouteByFiltersDocument, options);
      }
export function useGetRouteByFiltersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRouteByFiltersQuery, GetRouteByFiltersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRouteByFiltersQuery, GetRouteByFiltersQueryVariables>(GetRouteByFiltersDocument, options);
        }
export function useGetRouteByFiltersSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetRouteByFiltersQuery, GetRouteByFiltersQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetRouteByFiltersQuery, GetRouteByFiltersQueryVariables>(GetRouteByFiltersDocument, options);
        }
export type GetRouteByFiltersQueryHookResult = ReturnType<typeof useGetRouteByFiltersQuery>;
export type GetRouteByFiltersLazyQueryHookResult = ReturnType<typeof useGetRouteByFiltersLazyQuery>;
export type GetRouteByFiltersSuspenseQueryHookResult = ReturnType<typeof useGetRouteByFiltersSuspenseQuery>;
export type GetRouteByFiltersQueryResult = Apollo.QueryResult<GetRouteByFiltersQuery, GetRouteByFiltersQueryVariables>;
export const GetRouteWithInfrastructureLinksWithStopsDocument = gql`
    query GetRouteWithInfrastructureLinksWithStops($route_id: uuid!) {
  route_route_by_pk(route_id: $route_id) {
    ...route_with_infrastructure_links_with_stops_and_jps
  }
}
    ${RouteWithInfrastructureLinksWithStopsAndJpsFragmentDoc}`;

/**
 * __useGetRouteWithInfrastructureLinksWithStopsQuery__
 *
 * To run a query within a React component, call `useGetRouteWithInfrastructureLinksWithStopsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRouteWithInfrastructureLinksWithStopsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRouteWithInfrastructureLinksWithStopsQuery({
 *   variables: {
 *      route_id: // value for 'route_id'
 *   },
 * });
 */
export function useGetRouteWithInfrastructureLinksWithStopsQuery(baseOptions: Apollo.QueryHookOptions<GetRouteWithInfrastructureLinksWithStopsQuery, GetRouteWithInfrastructureLinksWithStopsQueryVariables> & ({ variables: GetRouteWithInfrastructureLinksWithStopsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRouteWithInfrastructureLinksWithStopsQuery, GetRouteWithInfrastructureLinksWithStopsQueryVariables>(GetRouteWithInfrastructureLinksWithStopsDocument, options);
      }
export function useGetRouteWithInfrastructureLinksWithStopsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRouteWithInfrastructureLinksWithStopsQuery, GetRouteWithInfrastructureLinksWithStopsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRouteWithInfrastructureLinksWithStopsQuery, GetRouteWithInfrastructureLinksWithStopsQueryVariables>(GetRouteWithInfrastructureLinksWithStopsDocument, options);
        }
export function useGetRouteWithInfrastructureLinksWithStopsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetRouteWithInfrastructureLinksWithStopsQuery, GetRouteWithInfrastructureLinksWithStopsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetRouteWithInfrastructureLinksWithStopsQuery, GetRouteWithInfrastructureLinksWithStopsQueryVariables>(GetRouteWithInfrastructureLinksWithStopsDocument, options);
        }
export type GetRouteWithInfrastructureLinksWithStopsQueryHookResult = ReturnType<typeof useGetRouteWithInfrastructureLinksWithStopsQuery>;
export type GetRouteWithInfrastructureLinksWithStopsLazyQueryHookResult = ReturnType<typeof useGetRouteWithInfrastructureLinksWithStopsLazyQuery>;
export type GetRouteWithInfrastructureLinksWithStopsSuspenseQueryHookResult = ReturnType<typeof useGetRouteWithInfrastructureLinksWithStopsSuspenseQuery>;
export type GetRouteWithInfrastructureLinksWithStopsQueryResult = Apollo.QueryResult<GetRouteWithInfrastructureLinksWithStopsQuery, GetRouteWithInfrastructureLinksWithStopsQueryVariables>;
export const SearchLinesAndRoutesDocument = gql`
    query SearchLinesAndRoutes($lineFilter: route_line_bool_exp, $routeFilter: route_route_bool_exp, $lineOrderBy: [route_line_order_by!], $routeOrderBy: [route_route_order_by!]) {
  route_line(where: $lineFilter, order_by: $lineOrderBy) {
    ...line_table_row
  }
  route_route(where: $routeFilter, order_by: $routeOrderBy) {
    ...route_table_row
  }
}
    ${LineTableRowFragmentDoc}
${RouteTableRowFragmentDoc}`;

/**
 * __useSearchLinesAndRoutesQuery__
 *
 * To run a query within a React component, call `useSearchLinesAndRoutesQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchLinesAndRoutesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchLinesAndRoutesQuery({
 *   variables: {
 *      lineFilter: // value for 'lineFilter'
 *      routeFilter: // value for 'routeFilter'
 *      lineOrderBy: // value for 'lineOrderBy'
 *      routeOrderBy: // value for 'routeOrderBy'
 *   },
 * });
 */
export function useSearchLinesAndRoutesQuery(baseOptions?: Apollo.QueryHookOptions<SearchLinesAndRoutesQuery, SearchLinesAndRoutesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchLinesAndRoutesQuery, SearchLinesAndRoutesQueryVariables>(SearchLinesAndRoutesDocument, options);
      }
export function useSearchLinesAndRoutesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchLinesAndRoutesQuery, SearchLinesAndRoutesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchLinesAndRoutesQuery, SearchLinesAndRoutesQueryVariables>(SearchLinesAndRoutesDocument, options);
        }
export function useSearchLinesAndRoutesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<SearchLinesAndRoutesQuery, SearchLinesAndRoutesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SearchLinesAndRoutesQuery, SearchLinesAndRoutesQueryVariables>(SearchLinesAndRoutesDocument, options);
        }
export type SearchLinesAndRoutesQueryHookResult = ReturnType<typeof useSearchLinesAndRoutesQuery>;
export type SearchLinesAndRoutesLazyQueryHookResult = ReturnType<typeof useSearchLinesAndRoutesLazyQuery>;
export type SearchLinesAndRoutesSuspenseQueryHookResult = ReturnType<typeof useSearchLinesAndRoutesSuspenseQuery>;
export type SearchLinesAndRoutesQueryResult = Apollo.QueryResult<SearchLinesAndRoutesQuery, SearchLinesAndRoutesQueryVariables>;
export const DeleteStopAreaDocument = gql`
    mutation DeleteStopArea($stopPlaceId: String!) {
  stop_registry {
    deleteStopPlace(stopPlaceId: $stopPlaceId)
  }
}
    `;
export type DeleteStopAreaMutationFn = Apollo.MutationFunction<DeleteStopAreaMutation, DeleteStopAreaMutationVariables>;

/**
 * __useDeleteStopAreaMutation__
 *
 * To run a mutation, you first call `useDeleteStopAreaMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteStopAreaMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteStopAreaMutation, { data, loading, error }] = useDeleteStopAreaMutation({
 *   variables: {
 *      stopPlaceId: // value for 'stopPlaceId'
 *   },
 * });
 */
export function useDeleteStopAreaMutation(baseOptions?: Apollo.MutationHookOptions<DeleteStopAreaMutation, DeleteStopAreaMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteStopAreaMutation, DeleteStopAreaMutationVariables>(DeleteStopAreaDocument, options);
      }
export type DeleteStopAreaMutationHookResult = ReturnType<typeof useDeleteStopAreaMutation>;
export type DeleteStopAreaMutationResult = Apollo.MutationResult<DeleteStopAreaMutation>;
export type DeleteStopAreaMutationOptions = Apollo.BaseMutationOptions<DeleteStopAreaMutation, DeleteStopAreaMutationVariables>;
export const CreateTerminalDocument = gql`
    mutation CreateTerminal($input: stop_registry_createMultiModalStopPlaceInput!) {
  stop_registry {
    createMultiModalStopPlace(input: $input) {
      ...parent_stop_place_details
    }
  }
}
    ${ParentStopPlaceDetailsFragmentDoc}`;
export type CreateTerminalMutationFn = Apollo.MutationFunction<CreateTerminalMutation, CreateTerminalMutationVariables>;

/**
 * __useCreateTerminalMutation__
 *
 * To run a mutation, you first call `useCreateTerminalMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateTerminalMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createTerminalMutation, { data, loading, error }] = useCreateTerminalMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateTerminalMutation(baseOptions?: Apollo.MutationHookOptions<CreateTerminalMutation, CreateTerminalMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateTerminalMutation, CreateTerminalMutationVariables>(CreateTerminalDocument, options);
      }
export type CreateTerminalMutationHookResult = ReturnType<typeof useCreateTerminalMutation>;
export type CreateTerminalMutationResult = Apollo.MutationResult<CreateTerminalMutation>;
export type CreateTerminalMutationOptions = Apollo.BaseMutationOptions<CreateTerminalMutation, CreateTerminalMutationVariables>;
export const DeleteTerminalDocument = gql`
    mutation DeleteTerminal($terminalId: String!) {
  stop_registry {
    deleteStopPlace(stopPlaceId: $terminalId)
  }
}
    `;
export type DeleteTerminalMutationFn = Apollo.MutationFunction<DeleteTerminalMutation, DeleteTerminalMutationVariables>;

/**
 * __useDeleteTerminalMutation__
 *
 * To run a mutation, you first call `useDeleteTerminalMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteTerminalMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteTerminalMutation, { data, loading, error }] = useDeleteTerminalMutation({
 *   variables: {
 *      terminalId: // value for 'terminalId'
 *   },
 * });
 */
export function useDeleteTerminalMutation(baseOptions?: Apollo.MutationHookOptions<DeleteTerminalMutation, DeleteTerminalMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteTerminalMutation, DeleteTerminalMutationVariables>(DeleteTerminalDocument, options);
      }
export type DeleteTerminalMutationHookResult = ReturnType<typeof useDeleteTerminalMutation>;
export type DeleteTerminalMutationResult = Apollo.MutationResult<DeleteTerminalMutation>;
export type DeleteTerminalMutationOptions = Apollo.BaseMutationOptions<DeleteTerminalMutation, DeleteTerminalMutationVariables>;
export const UpdateTerminalDocument = gql`
    mutation UpdateTerminal($input: stop_registry_ParentStopPlaceInput!) {
  stop_registry {
    mutateParentStopPlace(ParentStopPlace: $input) {
      ...parent_stop_place_details
    }
  }
}
    ${ParentStopPlaceDetailsFragmentDoc}`;
export type UpdateTerminalMutationFn = Apollo.MutationFunction<UpdateTerminalMutation, UpdateTerminalMutationVariables>;

/**
 * __useUpdateTerminalMutation__
 *
 * To run a mutation, you first call `useUpdateTerminalMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateTerminalMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateTerminalMutation, { data, loading, error }] = useUpdateTerminalMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateTerminalMutation(baseOptions?: Apollo.MutationHookOptions<UpdateTerminalMutation, UpdateTerminalMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateTerminalMutation, UpdateTerminalMutationVariables>(UpdateTerminalDocument, options);
      }
export type UpdateTerminalMutationHookResult = ReturnType<typeof useUpdateTerminalMutation>;
export type UpdateTerminalMutationResult = Apollo.MutationResult<UpdateTerminalMutation>;
export type UpdateTerminalMutationOptions = Apollo.BaseMutationOptions<UpdateTerminalMutation, UpdateTerminalMutationVariables>;
export const UpdateStopPlaceDocument = gql`
    mutation UpdateStopPlace($input: stop_registry_StopPlaceInput!) {
  stop_registry {
    mutateStopPlace(StopPlace: $input) {
      ...stop_place_details
    }
  }
}
    ${StopPlaceDetailsFragmentDoc}`;
export type UpdateStopPlaceMutationFn = Apollo.MutationFunction<UpdateStopPlaceMutation, UpdateStopPlaceMutationVariables>;

/**
 * __useUpdateStopPlaceMutation__
 *
 * To run a mutation, you first call `useUpdateStopPlaceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateStopPlaceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateStopPlaceMutation, { data, loading, error }] = useUpdateStopPlaceMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateStopPlaceMutation(baseOptions?: Apollo.MutationHookOptions<UpdateStopPlaceMutation, UpdateStopPlaceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateStopPlaceMutation, UpdateStopPlaceMutationVariables>(UpdateStopPlaceDocument, options);
      }
export type UpdateStopPlaceMutationHookResult = ReturnType<typeof useUpdateStopPlaceMutation>;
export type UpdateStopPlaceMutationResult = Apollo.MutationResult<UpdateStopPlaceMutation>;
export type UpdateStopPlaceMutationOptions = Apollo.BaseMutationOptions<UpdateStopPlaceMutation, UpdateStopPlaceMutationVariables>;
export const GetStopDetailsDocument = gql`
    query GetStopDetails($where: service_pattern_scheduled_stop_point_bool_exp) {
  service_pattern_scheduled_stop_point(
    where: $where
    order_by: {priority: desc}
    limit: 1
  ) {
    ...scheduled_stop_point_detail_fields
    stop_place(onlyMonomodalStopPlaces: true) {
      ...stop_place_details
    }
  }
}
    ${ScheduledStopPointDetailFieldsFragmentDoc}
${StopPlaceDetailsFragmentDoc}`;

/**
 * __useGetStopDetailsQuery__
 *
 * To run a query within a React component, call `useGetStopDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStopDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStopDetailsQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useGetStopDetailsQuery(baseOptions?: Apollo.QueryHookOptions<GetStopDetailsQuery, GetStopDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStopDetailsQuery, GetStopDetailsQueryVariables>(GetStopDetailsDocument, options);
      }
export function useGetStopDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStopDetailsQuery, GetStopDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStopDetailsQuery, GetStopDetailsQueryVariables>(GetStopDetailsDocument, options);
        }
export function useGetStopDetailsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetStopDetailsQuery, GetStopDetailsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetStopDetailsQuery, GetStopDetailsQueryVariables>(GetStopDetailsDocument, options);
        }
export type GetStopDetailsQueryHookResult = ReturnType<typeof useGetStopDetailsQuery>;
export type GetStopDetailsLazyQueryHookResult = ReturnType<typeof useGetStopDetailsLazyQuery>;
export type GetStopDetailsSuspenseQueryHookResult = ReturnType<typeof useGetStopDetailsSuspenseQuery>;
export type GetStopDetailsQueryResult = Apollo.QueryResult<GetStopDetailsQuery, GetStopDetailsQueryVariables>;
export const UpsertOrganisationDocument = gql`
    mutation UpsertOrganisation($objects: [stop_registry_OrganisationInput]) {
  stop_registry {
    mutateOrganisation(Organisation: $objects) {
      id
    }
  }
}
    `;
export type UpsertOrganisationMutationFn = Apollo.MutationFunction<UpsertOrganisationMutation, UpsertOrganisationMutationVariables>;

/**
 * __useUpsertOrganisationMutation__
 *
 * To run a mutation, you first call `useUpsertOrganisationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertOrganisationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertOrganisationMutation, { data, loading, error }] = useUpsertOrganisationMutation({
 *   variables: {
 *      objects: // value for 'objects'
 *   },
 * });
 */
export function useUpsertOrganisationMutation(baseOptions?: Apollo.MutationHookOptions<UpsertOrganisationMutation, UpsertOrganisationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpsertOrganisationMutation, UpsertOrganisationMutationVariables>(UpsertOrganisationDocument, options);
      }
export type UpsertOrganisationMutationHookResult = ReturnType<typeof useUpsertOrganisationMutation>;
export type UpsertOrganisationMutationResult = Apollo.MutationResult<UpsertOrganisationMutation>;
export type UpsertOrganisationMutationOptions = Apollo.BaseMutationOptions<UpsertOrganisationMutation, UpsertOrganisationMutationVariables>;
export const PatchScheduledStopPointTimingSettingsDocument = gql`
    mutation PatchScheduledStopPointTimingSettings($stopLabel: String!, $journeyPatternId: uuid!, $sequence: Int!, $patch: journey_pattern_scheduled_stop_point_in_journey_pattern_set_input!, $stopId: uuid!, $timingPlaceId: uuid) {
  update_service_pattern_scheduled_stop_point(
    where: {scheduled_stop_point_id: {_eq: $stopId}}
    _set: {timing_place_id: $timingPlaceId}
  ) {
    returning {
      scheduled_stop_point_id
      timing_place_id
      timing_place {
        timing_place_id
      }
    }
  }
  update_journey_pattern_scheduled_stop_point_in_journey_pattern(
    where: {scheduled_stop_point_label: {_eq: $stopLabel}, scheduled_stop_point_sequence: {_eq: $sequence}, journey_pattern_id: {_eq: $journeyPatternId}}
    _set: $patch
  ) {
    returning {
      ...scheduled_stop_point_in_journey_pattern_all_fields
    }
  }
}
    ${ScheduledStopPointInJourneyPatternAllFieldsFragmentDoc}`;
export type PatchScheduledStopPointTimingSettingsMutationFn = Apollo.MutationFunction<PatchScheduledStopPointTimingSettingsMutation, PatchScheduledStopPointTimingSettingsMutationVariables>;

/**
 * __usePatchScheduledStopPointTimingSettingsMutation__
 *
 * To run a mutation, you first call `usePatchScheduledStopPointTimingSettingsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePatchScheduledStopPointTimingSettingsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [patchScheduledStopPointTimingSettingsMutation, { data, loading, error }] = usePatchScheduledStopPointTimingSettingsMutation({
 *   variables: {
 *      stopLabel: // value for 'stopLabel'
 *      journeyPatternId: // value for 'journeyPatternId'
 *      sequence: // value for 'sequence'
 *      patch: // value for 'patch'
 *      stopId: // value for 'stopId'
 *      timingPlaceId: // value for 'timingPlaceId'
 *   },
 * });
 */
export function usePatchScheduledStopPointTimingSettingsMutation(baseOptions?: Apollo.MutationHookOptions<PatchScheduledStopPointTimingSettingsMutation, PatchScheduledStopPointTimingSettingsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PatchScheduledStopPointTimingSettingsMutation, PatchScheduledStopPointTimingSettingsMutationVariables>(PatchScheduledStopPointTimingSettingsDocument, options);
      }
export type PatchScheduledStopPointTimingSettingsMutationHookResult = ReturnType<typeof usePatchScheduledStopPointTimingSettingsMutation>;
export type PatchScheduledStopPointTimingSettingsMutationResult = Apollo.MutationResult<PatchScheduledStopPointTimingSettingsMutation>;
export type PatchScheduledStopPointTimingSettingsMutationOptions = Apollo.BaseMutationOptions<PatchScheduledStopPointTimingSettingsMutation, PatchScheduledStopPointTimingSettingsMutationVariables>;
export const InsertStopPointDocument = gql`
    mutation InsertStopPoint($stopPoint: service_pattern_scheduled_stop_point_insert_input!) {
  stopPoint: insert_service_pattern_scheduled_stop_point_one(object: $stopPoint) {
    scheduled_stop_point_id
    located_on_infrastructure_link_id
    direction
    priority
    measured_location
    label
    validity_start
    validity_end
    stop_place_ref
  }
}
    `;
export type InsertStopPointMutationFn = Apollo.MutationFunction<InsertStopPointMutation, InsertStopPointMutationVariables>;

/**
 * __useInsertStopPointMutation__
 *
 * To run a mutation, you first call `useInsertStopPointMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertStopPointMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertStopPointMutation, { data, loading, error }] = useInsertStopPointMutation({
 *   variables: {
 *      stopPoint: // value for 'stopPoint'
 *   },
 * });
 */
export function useInsertStopPointMutation(baseOptions?: Apollo.MutationHookOptions<InsertStopPointMutation, InsertStopPointMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertStopPointMutation, InsertStopPointMutationVariables>(InsertStopPointDocument, options);
      }
export type InsertStopPointMutationHookResult = ReturnType<typeof useInsertStopPointMutation>;
export type InsertStopPointMutationResult = Apollo.MutationResult<InsertStopPointMutation>;
export type InsertStopPointMutationOptions = Apollo.BaseMutationOptions<InsertStopPointMutation, InsertStopPointMutationVariables>;
export const GetRoutesBrokenByStopChangeDocument = gql`
    query GetRoutesBrokenByStopChange($new_located_on_infrastructure_link_id: uuid!, $new_direction: String!, $new_label: String!, $new_validity_start: date, $new_validity_end: date, $new_priority: Int!, $new_measured_location: geography!, $replace_scheduled_stop_point_id: uuid) {
  journey_pattern_check_infra_link_stop_refs_with_new_scheduled_stop_point(
    args: {replace_scheduled_stop_point_id: $replace_scheduled_stop_point_id, new_located_on_infrastructure_link_id: $new_located_on_infrastructure_link_id, new_direction: $new_direction, new_label: $new_label, new_validity_start: $new_validity_start, new_validity_end: $new_validity_end, new_priority: $new_priority, new_measured_location: $new_measured_location}
  ) {
    journey_pattern_id
    journey_pattern_route {
      ...route_all_fields
    }
  }
}
    ${RouteAllFieldsFragmentDoc}`;

/**
 * __useGetRoutesBrokenByStopChangeQuery__
 *
 * To run a query within a React component, call `useGetRoutesBrokenByStopChangeQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRoutesBrokenByStopChangeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRoutesBrokenByStopChangeQuery({
 *   variables: {
 *      new_located_on_infrastructure_link_id: // value for 'new_located_on_infrastructure_link_id'
 *      new_direction: // value for 'new_direction'
 *      new_label: // value for 'new_label'
 *      new_validity_start: // value for 'new_validity_start'
 *      new_validity_end: // value for 'new_validity_end'
 *      new_priority: // value for 'new_priority'
 *      new_measured_location: // value for 'new_measured_location'
 *      replace_scheduled_stop_point_id: // value for 'replace_scheduled_stop_point_id'
 *   },
 * });
 */
export function useGetRoutesBrokenByStopChangeQuery(baseOptions: Apollo.QueryHookOptions<GetRoutesBrokenByStopChangeQuery, GetRoutesBrokenByStopChangeQueryVariables> & ({ variables: GetRoutesBrokenByStopChangeQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRoutesBrokenByStopChangeQuery, GetRoutesBrokenByStopChangeQueryVariables>(GetRoutesBrokenByStopChangeDocument, options);
      }
export function useGetRoutesBrokenByStopChangeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRoutesBrokenByStopChangeQuery, GetRoutesBrokenByStopChangeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRoutesBrokenByStopChangeQuery, GetRoutesBrokenByStopChangeQueryVariables>(GetRoutesBrokenByStopChangeDocument, options);
        }
export function useGetRoutesBrokenByStopChangeSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetRoutesBrokenByStopChangeQuery, GetRoutesBrokenByStopChangeQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetRoutesBrokenByStopChangeQuery, GetRoutesBrokenByStopChangeQueryVariables>(GetRoutesBrokenByStopChangeDocument, options);
        }
export type GetRoutesBrokenByStopChangeQueryHookResult = ReturnType<typeof useGetRoutesBrokenByStopChangeQuery>;
export type GetRoutesBrokenByStopChangeLazyQueryHookResult = ReturnType<typeof useGetRoutesBrokenByStopChangeLazyQuery>;
export type GetRoutesBrokenByStopChangeSuspenseQueryHookResult = ReturnType<typeof useGetRoutesBrokenByStopChangeSuspenseQuery>;
export type GetRoutesBrokenByStopChangeQueryResult = Apollo.QueryResult<GetRoutesBrokenByStopChangeQuery, GetRoutesBrokenByStopChangeQueryVariables>;
export const EditStopDocument = gql`
    mutation EditStop($stop_id: uuid!, $stop_label: String!, $stop_patch: service_pattern_scheduled_stop_point_set_input!, $delete_from_journey_pattern_ids: [uuid!]!) {
  update_service_pattern_scheduled_stop_point(
    where: {scheduled_stop_point_id: {_eq: $stop_id}}
    _set: $stop_patch
  ) {
    returning {
      ...scheduled_stop_point_all_fields
    }
  }
  delete_journey_pattern_scheduled_stop_point_in_journey_pattern(
    where: {_and: {scheduled_stop_point_label: {_eq: $stop_label}, journey_pattern_id: {_in: $delete_from_journey_pattern_ids}}}
  ) {
    returning {
      ...scheduled_stop_point_in_journey_pattern_all_fields
    }
  }
}
    ${ScheduledStopPointAllFieldsFragmentDoc}
${ScheduledStopPointInJourneyPatternAllFieldsFragmentDoc}`;
export type EditStopMutationFn = Apollo.MutationFunction<EditStopMutation, EditStopMutationVariables>;

/**
 * __useEditStopMutation__
 *
 * To run a mutation, you first call `useEditStopMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditStopMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editStopMutation, { data, loading, error }] = useEditStopMutation({
 *   variables: {
 *      stop_id: // value for 'stop_id'
 *      stop_label: // value for 'stop_label'
 *      stop_patch: // value for 'stop_patch'
 *      delete_from_journey_pattern_ids: // value for 'delete_from_journey_pattern_ids'
 *   },
 * });
 */
export function useEditStopMutation(baseOptions?: Apollo.MutationHookOptions<EditStopMutation, EditStopMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditStopMutation, EditStopMutationVariables>(EditStopDocument, options);
      }
export type EditStopMutationHookResult = ReturnType<typeof useEditStopMutation>;
export type EditStopMutationResult = Apollo.MutationResult<EditStopMutation>;
export type EditStopMutationOptions = Apollo.BaseMutationOptions<EditStopMutation, EditStopMutationVariables>;
export const EditStopPlaceDocument = gql`
    mutation EditStopPlace($patch: stop_registry_StopPlaceInput) {
  stop_registry {
    mutateStopPlace(StopPlace: $patch) {
      id
      version
      name {
        value
      }
      geometry {
        coordinates
      }
      keyValues {
        key
        values
      }
    }
  }
}
    `;
export type EditStopPlaceMutationFn = Apollo.MutationFunction<EditStopPlaceMutation, EditStopPlaceMutationVariables>;

/**
 * __useEditStopPlaceMutation__
 *
 * To run a mutation, you first call `useEditStopPlaceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditStopPlaceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editStopPlaceMutation, { data, loading, error }] = useEditStopPlaceMutation({
 *   variables: {
 *      patch: // value for 'patch'
 *   },
 * });
 */
export function useEditStopPlaceMutation(baseOptions?: Apollo.MutationHookOptions<EditStopPlaceMutation, EditStopPlaceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditStopPlaceMutation, EditStopPlaceMutationVariables>(EditStopPlaceDocument, options);
      }
export type EditStopPlaceMutationHookResult = ReturnType<typeof useEditStopPlaceMutation>;
export type EditStopPlaceMutationResult = Apollo.MutationResult<EditStopPlaceMutation>;
export type EditStopPlaceMutationOptions = Apollo.BaseMutationOptions<EditStopPlaceMutation, EditStopPlaceMutationVariables>;
export const GetQuayMaxPrivateCodeDocument = gql`
    query GetQuayMaxPrivateCode {
  stops_database {
    stops_database_quay_aggregate(where: {private_code_value: {_like: "7______"}}) {
      aggregate {
        max {
          private_code_value
        }
      }
    }
  }
}
    `;

/**
 * __useGetQuayMaxPrivateCodeQuery__
 *
 * To run a query within a React component, call `useGetQuayMaxPrivateCodeQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetQuayMaxPrivateCodeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetQuayMaxPrivateCodeQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetQuayMaxPrivateCodeQuery(baseOptions?: Apollo.QueryHookOptions<GetQuayMaxPrivateCodeQuery, GetQuayMaxPrivateCodeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetQuayMaxPrivateCodeQuery, GetQuayMaxPrivateCodeQueryVariables>(GetQuayMaxPrivateCodeDocument, options);
      }
export function useGetQuayMaxPrivateCodeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetQuayMaxPrivateCodeQuery, GetQuayMaxPrivateCodeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetQuayMaxPrivateCodeQuery, GetQuayMaxPrivateCodeQueryVariables>(GetQuayMaxPrivateCodeDocument, options);
        }
export function useGetQuayMaxPrivateCodeSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetQuayMaxPrivateCodeQuery, GetQuayMaxPrivateCodeQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetQuayMaxPrivateCodeQuery, GetQuayMaxPrivateCodeQueryVariables>(GetQuayMaxPrivateCodeDocument, options);
        }
export type GetQuayMaxPrivateCodeQueryHookResult = ReturnType<typeof useGetQuayMaxPrivateCodeQuery>;
export type GetQuayMaxPrivateCodeLazyQueryHookResult = ReturnType<typeof useGetQuayMaxPrivateCodeLazyQuery>;
export type GetQuayMaxPrivateCodeSuspenseQueryHookResult = ReturnType<typeof useGetQuayMaxPrivateCodeSuspenseQuery>;
export type GetQuayMaxPrivateCodeQueryResult = Apollo.QueryResult<GetQuayMaxPrivateCodeQuery, GetQuayMaxPrivateCodeQueryVariables>;
export const GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsDocument = gql`
    query GetScheduledStopPointsInJourneyPatternsUsedAsTimingPoints($label: String!) {
  journey_pattern_scheduled_stop_point_in_journey_pattern(
    where: {is_used_as_timing_point: {_eq: true}, scheduled_stop_points: {label: {_eq: $label}}}
  ) {
    journey_pattern_id
    scheduled_stop_point_label
    scheduled_stop_point_sequence
    journey_pattern {
      journey_pattern_id
      on_route_id
      journey_pattern_route {
        route_id
        label
        variant
      }
    }
  }
}
    `;

/**
 * __useGetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery__
 *
 * To run a query within a React component, call `useGetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery({
 *   variables: {
 *      label: // value for 'label'
 *   },
 * });
 */
export function useGetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery(baseOptions: Apollo.QueryHookOptions<GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery, GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQueryVariables> & ({ variables: GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery, GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQueryVariables>(GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsDocument, options);
      }
export function useGetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery, GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery, GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQueryVariables>(GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsDocument, options);
        }
export function useGetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery, GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery, GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQueryVariables>(GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsDocument, options);
        }
export type GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQueryHookResult = ReturnType<typeof useGetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery>;
export type GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsLazyQueryHookResult = ReturnType<typeof useGetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsLazyQuery>;
export type GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsSuspenseQueryHookResult = ReturnType<typeof useGetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsSuspenseQuery>;
export type GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQueryResult = Apollo.QueryResult<GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQuery, GetScheduledStopPointsInJourneyPatternsUsedAsTimingPointsQueryVariables>;
export const CreateSubstituteOperatingPeriodDocument = gql`
    mutation CreateSubstituteOperatingPeriod($data: [timetables_service_calendar_substitute_operating_period_insert_input!]!) {
  timetables {
    timetables_insert_service_calendar_substitute_operating_period(objects: $data) {
      returning {
        substitute_operating_period_id
        period_name
        is_preset
        substitute_operating_day_by_line_types {
          begin_time
          end_time
          substitute_day_of_week
          substitute_operating_day_by_line_type_id
          superseded_date
          type_of_line
        }
      }
    }
  }
}
    `;
export type CreateSubstituteOperatingPeriodMutationFn = Apollo.MutationFunction<CreateSubstituteOperatingPeriodMutation, CreateSubstituteOperatingPeriodMutationVariables>;

/**
 * __useCreateSubstituteOperatingPeriodMutation__
 *
 * To run a mutation, you first call `useCreateSubstituteOperatingPeriodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSubstituteOperatingPeriodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSubstituteOperatingPeriodMutation, { data, loading, error }] = useCreateSubstituteOperatingPeriodMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateSubstituteOperatingPeriodMutation(baseOptions?: Apollo.MutationHookOptions<CreateSubstituteOperatingPeriodMutation, CreateSubstituteOperatingPeriodMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateSubstituteOperatingPeriodMutation, CreateSubstituteOperatingPeriodMutationVariables>(CreateSubstituteOperatingPeriodDocument, options);
      }
export type CreateSubstituteOperatingPeriodMutationHookResult = ReturnType<typeof useCreateSubstituteOperatingPeriodMutation>;
export type CreateSubstituteOperatingPeriodMutationResult = Apollo.MutationResult<CreateSubstituteOperatingPeriodMutation>;
export type CreateSubstituteOperatingPeriodMutationOptions = Apollo.BaseMutationOptions<CreateSubstituteOperatingPeriodMutation, CreateSubstituteOperatingPeriodMutationVariables>;
export const DeleteSubstituteOperatingPeriodDocument = gql`
    mutation DeleteSubstituteOperatingPeriod($ids: [uuid!]!) {
  timetables {
    timetables_delete_service_calendar_substitute_operating_period(
      where: {substitute_operating_period_id: {_in: $ids}}
    ) {
      affected_rows
    }
  }
}
    `;
export type DeleteSubstituteOperatingPeriodMutationFn = Apollo.MutationFunction<DeleteSubstituteOperatingPeriodMutation, DeleteSubstituteOperatingPeriodMutationVariables>;

/**
 * __useDeleteSubstituteOperatingPeriodMutation__
 *
 * To run a mutation, you first call `useDeleteSubstituteOperatingPeriodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteSubstituteOperatingPeriodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteSubstituteOperatingPeriodMutation, { data, loading, error }] = useDeleteSubstituteOperatingPeriodMutation({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useDeleteSubstituteOperatingPeriodMutation(baseOptions?: Apollo.MutationHookOptions<DeleteSubstituteOperatingPeriodMutation, DeleteSubstituteOperatingPeriodMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteSubstituteOperatingPeriodMutation, DeleteSubstituteOperatingPeriodMutationVariables>(DeleteSubstituteOperatingPeriodDocument, options);
      }
export type DeleteSubstituteOperatingPeriodMutationHookResult = ReturnType<typeof useDeleteSubstituteOperatingPeriodMutation>;
export type DeleteSubstituteOperatingPeriodMutationResult = Apollo.MutationResult<DeleteSubstituteOperatingPeriodMutation>;
export type DeleteSubstituteOperatingPeriodMutationOptions = Apollo.BaseMutationOptions<DeleteSubstituteOperatingPeriodMutation, DeleteSubstituteOperatingPeriodMutationVariables>;
export const EditSubstituteOperatingPeriodsDocument = gql`
    mutation EditSubstituteOperatingPeriods($periodsToInsert: [timetables_service_calendar_substitute_operating_period_insert_input!]!, $periodsToDelete: [uuid!]!, $daysToInsert: [timetables_service_calendar_substitute_operating_day_by_line_type_insert_input!]!) {
  timetables {
    timetables_insert_service_calendar_substitute_operating_period(
      objects: $periodsToInsert
      on_conflict: {constraint: substitute_operating_period_pkey, update_columns: [period_name]}
    ) {
      affected_rows
    }
    timetables_delete_service_calendar_substitute_operating_day_by_line_type(
      where: {substitute_operating_period_id: {_in: $periodsToDelete}}
    ) {
      affected_rows
    }
    timetables_insert_service_calendar_substitute_operating_day_by_line_type(
      objects: $daysToInsert
    ) {
      affected_rows
    }
  }
}
    `;
export type EditSubstituteOperatingPeriodsMutationFn = Apollo.MutationFunction<EditSubstituteOperatingPeriodsMutation, EditSubstituteOperatingPeriodsMutationVariables>;

/**
 * __useEditSubstituteOperatingPeriodsMutation__
 *
 * To run a mutation, you first call `useEditSubstituteOperatingPeriodsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditSubstituteOperatingPeriodsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editSubstituteOperatingPeriodsMutation, { data, loading, error }] = useEditSubstituteOperatingPeriodsMutation({
 *   variables: {
 *      periodsToInsert: // value for 'periodsToInsert'
 *      periodsToDelete: // value for 'periodsToDelete'
 *      daysToInsert: // value for 'daysToInsert'
 *   },
 * });
 */
export function useEditSubstituteOperatingPeriodsMutation(baseOptions?: Apollo.MutationHookOptions<EditSubstituteOperatingPeriodsMutation, EditSubstituteOperatingPeriodsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditSubstituteOperatingPeriodsMutation, EditSubstituteOperatingPeriodsMutationVariables>(EditSubstituteOperatingPeriodsDocument, options);
      }
export type EditSubstituteOperatingPeriodsMutationHookResult = ReturnType<typeof useEditSubstituteOperatingPeriodsMutation>;
export type EditSubstituteOperatingPeriodsMutationResult = Apollo.MutationResult<EditSubstituteOperatingPeriodsMutation>;
export type EditSubstituteOperatingPeriodsMutationOptions = Apollo.BaseMutationOptions<EditSubstituteOperatingPeriodsMutation, EditSubstituteOperatingPeriodsMutationVariables>;
export const GetSubstituteOperatingPeriodsDocument = gql`
    query GetSubstituteOperatingPeriods($periodFilters: timetables_service_calendar_substitute_operating_period_bool_exp) {
  timetables {
    timetables_service_calendar_substitute_operating_period(where: $periodFilters) {
      period_name
      is_preset
      substitute_operating_period_id
      substitute_operating_day_by_line_types {
        begin_time
        end_time
        substitute_day_of_week
        substitute_operating_day_by_line_type_id
        superseded_date
        type_of_line
      }
    }
  }
}
    `;

/**
 * __useGetSubstituteOperatingPeriodsQuery__
 *
 * To run a query within a React component, call `useGetSubstituteOperatingPeriodsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSubstituteOperatingPeriodsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSubstituteOperatingPeriodsQuery({
 *   variables: {
 *      periodFilters: // value for 'periodFilters'
 *   },
 * });
 */
export function useGetSubstituteOperatingPeriodsQuery(baseOptions?: Apollo.QueryHookOptions<GetSubstituteOperatingPeriodsQuery, GetSubstituteOperatingPeriodsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSubstituteOperatingPeriodsQuery, GetSubstituteOperatingPeriodsQueryVariables>(GetSubstituteOperatingPeriodsDocument, options);
      }
export function useGetSubstituteOperatingPeriodsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSubstituteOperatingPeriodsQuery, GetSubstituteOperatingPeriodsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSubstituteOperatingPeriodsQuery, GetSubstituteOperatingPeriodsQueryVariables>(GetSubstituteOperatingPeriodsDocument, options);
        }
export function useGetSubstituteOperatingPeriodsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSubstituteOperatingPeriodsQuery, GetSubstituteOperatingPeriodsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSubstituteOperatingPeriodsQuery, GetSubstituteOperatingPeriodsQueryVariables>(GetSubstituteOperatingPeriodsDocument, options);
        }
export type GetSubstituteOperatingPeriodsQueryHookResult = ReturnType<typeof useGetSubstituteOperatingPeriodsQuery>;
export type GetSubstituteOperatingPeriodsLazyQueryHookResult = ReturnType<typeof useGetSubstituteOperatingPeriodsLazyQuery>;
export type GetSubstituteOperatingPeriodsSuspenseQueryHookResult = ReturnType<typeof useGetSubstituteOperatingPeriodsSuspenseQuery>;
export type GetSubstituteOperatingPeriodsQueryResult = Apollo.QueryResult<GetSubstituteOperatingPeriodsQuery, GetSubstituteOperatingPeriodsQueryVariables>;
export const GetToCombineTargetVehicleScheduleFrameIdDocument = gql`
    query GetToCombineTargetVehicleScheduleFrameId($arg1: ToCombineTargetVehicleScheduleFrameIdInput!) {
  toCombineTargetVehicleScheduleFrameId(arg1: $arg1) {
    toCombineTargetVehicleScheduleFrameId
  }
}
    `;

/**
 * __useGetToCombineTargetVehicleScheduleFrameIdQuery__
 *
 * To run a query within a React component, call `useGetToCombineTargetVehicleScheduleFrameIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetToCombineTargetVehicleScheduleFrameIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetToCombineTargetVehicleScheduleFrameIdQuery({
 *   variables: {
 *      arg1: // value for 'arg1'
 *   },
 * });
 */
export function useGetToCombineTargetVehicleScheduleFrameIdQuery(baseOptions: Apollo.QueryHookOptions<GetToCombineTargetVehicleScheduleFrameIdQuery, GetToCombineTargetVehicleScheduleFrameIdQueryVariables> & ({ variables: GetToCombineTargetVehicleScheduleFrameIdQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetToCombineTargetVehicleScheduleFrameIdQuery, GetToCombineTargetVehicleScheduleFrameIdQueryVariables>(GetToCombineTargetVehicleScheduleFrameIdDocument, options);
      }
export function useGetToCombineTargetVehicleScheduleFrameIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetToCombineTargetVehicleScheduleFrameIdQuery, GetToCombineTargetVehicleScheduleFrameIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetToCombineTargetVehicleScheduleFrameIdQuery, GetToCombineTargetVehicleScheduleFrameIdQueryVariables>(GetToCombineTargetVehicleScheduleFrameIdDocument, options);
        }
export function useGetToCombineTargetVehicleScheduleFrameIdSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetToCombineTargetVehicleScheduleFrameIdQuery, GetToCombineTargetVehicleScheduleFrameIdQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetToCombineTargetVehicleScheduleFrameIdQuery, GetToCombineTargetVehicleScheduleFrameIdQueryVariables>(GetToCombineTargetVehicleScheduleFrameIdDocument, options);
        }
export type GetToCombineTargetVehicleScheduleFrameIdQueryHookResult = ReturnType<typeof useGetToCombineTargetVehicleScheduleFrameIdQuery>;
export type GetToCombineTargetVehicleScheduleFrameIdLazyQueryHookResult = ReturnType<typeof useGetToCombineTargetVehicleScheduleFrameIdLazyQuery>;
export type GetToCombineTargetVehicleScheduleFrameIdSuspenseQueryHookResult = ReturnType<typeof useGetToCombineTargetVehicleScheduleFrameIdSuspenseQuery>;
export type GetToCombineTargetVehicleScheduleFrameIdQueryResult = Apollo.QueryResult<GetToCombineTargetVehicleScheduleFrameIdQuery, GetToCombineTargetVehicleScheduleFrameIdQueryVariables>;
export const GetToReplaceVehicleScheduleFramesDocument = gql`
    query GetToReplaceVehicleScheduleFrames($arg1: ToReplaceVehicleScheduleFrameIdsInput!) {
  toReplaceVehicleScheduleFrameIds(arg1: $arg1) {
    toReplaceVehicleScheduleFrameIds
  }
}
    `;

/**
 * __useGetToReplaceVehicleScheduleFramesQuery__
 *
 * To run a query within a React component, call `useGetToReplaceVehicleScheduleFramesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetToReplaceVehicleScheduleFramesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetToReplaceVehicleScheduleFramesQuery({
 *   variables: {
 *      arg1: // value for 'arg1'
 *   },
 * });
 */
export function useGetToReplaceVehicleScheduleFramesQuery(baseOptions: Apollo.QueryHookOptions<GetToReplaceVehicleScheduleFramesQuery, GetToReplaceVehicleScheduleFramesQueryVariables> & ({ variables: GetToReplaceVehicleScheduleFramesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetToReplaceVehicleScheduleFramesQuery, GetToReplaceVehicleScheduleFramesQueryVariables>(GetToReplaceVehicleScheduleFramesDocument, options);
      }
export function useGetToReplaceVehicleScheduleFramesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetToReplaceVehicleScheduleFramesQuery, GetToReplaceVehicleScheduleFramesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetToReplaceVehicleScheduleFramesQuery, GetToReplaceVehicleScheduleFramesQueryVariables>(GetToReplaceVehicleScheduleFramesDocument, options);
        }
export function useGetToReplaceVehicleScheduleFramesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetToReplaceVehicleScheduleFramesQuery, GetToReplaceVehicleScheduleFramesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetToReplaceVehicleScheduleFramesQuery, GetToReplaceVehicleScheduleFramesQueryVariables>(GetToReplaceVehicleScheduleFramesDocument, options);
        }
export type GetToReplaceVehicleScheduleFramesQueryHookResult = ReturnType<typeof useGetToReplaceVehicleScheduleFramesQuery>;
export type GetToReplaceVehicleScheduleFramesLazyQueryHookResult = ReturnType<typeof useGetToReplaceVehicleScheduleFramesLazyQuery>;
export type GetToReplaceVehicleScheduleFramesSuspenseQueryHookResult = ReturnType<typeof useGetToReplaceVehicleScheduleFramesSuspenseQuery>;
export type GetToReplaceVehicleScheduleFramesQueryResult = Apollo.QueryResult<GetToReplaceVehicleScheduleFramesQuery, GetToReplaceVehicleScheduleFramesQueryVariables>;
export const GetVehicleScheduleFrameWithJourneyInfoDocument = gql`
    query GetVehicleScheduleFrameWithJourneyInfo($vehicle_schedule_frame_ids: [uuid!]!) {
  timetables {
    timetables_vehicle_schedule_vehicle_schedule_frame(
      where: {vehicle_schedule_frame_id: {_in: $vehicle_schedule_frame_ids}}
    ) {
      vehicle_schedule_frame_id
      validity_start
      validity_end
      vehicle_services {
        vehicle_service_id
        day_type {
          day_type_id
          label
          name_i18n
        }
        blocks {
          block_id
          vehicle_journeys {
            ...vehicle_journey_with_pattern_and_route_fragment
          }
        }
      }
    }
  }
}
    ${VehicleJourneyWithPatternAndRouteFragmentFragmentDoc}`;

/**
 * __useGetVehicleScheduleFrameWithJourneyInfoQuery__
 *
 * To run a query within a React component, call `useGetVehicleScheduleFrameWithJourneyInfoQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetVehicleScheduleFrameWithJourneyInfoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetVehicleScheduleFrameWithJourneyInfoQuery({
 *   variables: {
 *      vehicle_schedule_frame_ids: // value for 'vehicle_schedule_frame_ids'
 *   },
 * });
 */
export function useGetVehicleScheduleFrameWithJourneyInfoQuery(baseOptions: Apollo.QueryHookOptions<GetVehicleScheduleFrameWithJourneyInfoQuery, GetVehicleScheduleFrameWithJourneyInfoQueryVariables> & ({ variables: GetVehicleScheduleFrameWithJourneyInfoQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetVehicleScheduleFrameWithJourneyInfoQuery, GetVehicleScheduleFrameWithJourneyInfoQueryVariables>(GetVehicleScheduleFrameWithJourneyInfoDocument, options);
      }
export function useGetVehicleScheduleFrameWithJourneyInfoLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetVehicleScheduleFrameWithJourneyInfoQuery, GetVehicleScheduleFrameWithJourneyInfoQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetVehicleScheduleFrameWithJourneyInfoQuery, GetVehicleScheduleFrameWithJourneyInfoQueryVariables>(GetVehicleScheduleFrameWithJourneyInfoDocument, options);
        }
export function useGetVehicleScheduleFrameWithJourneyInfoSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetVehicleScheduleFrameWithJourneyInfoQuery, GetVehicleScheduleFrameWithJourneyInfoQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetVehicleScheduleFrameWithJourneyInfoQuery, GetVehicleScheduleFrameWithJourneyInfoQueryVariables>(GetVehicleScheduleFrameWithJourneyInfoDocument, options);
        }
export type GetVehicleScheduleFrameWithJourneyInfoQueryHookResult = ReturnType<typeof useGetVehicleScheduleFrameWithJourneyInfoQuery>;
export type GetVehicleScheduleFrameWithJourneyInfoLazyQueryHookResult = ReturnType<typeof useGetVehicleScheduleFrameWithJourneyInfoLazyQuery>;
export type GetVehicleScheduleFrameWithJourneyInfoSuspenseQueryHookResult = ReturnType<typeof useGetVehicleScheduleFrameWithJourneyInfoSuspenseQuery>;
export type GetVehicleScheduleFrameWithJourneyInfoQueryResult = Apollo.QueryResult<GetVehicleScheduleFrameWithJourneyInfoQuery, GetVehicleScheduleFrameWithJourneyInfoQueryVariables>;
export const GetVehicleScheduleFrameWithRouteAndLineInfoDocument = gql`
    query GetVehicleScheduleFrameWithRouteAndLineInfo($vehicle_schedule_frame_ids: [uuid!]!) {
  timetables {
    timetables_vehicle_schedule_vehicle_schedule_frame(
      where: {vehicle_schedule_frame_id: {_in: $vehicle_schedule_frame_ids}}
    ) {
      vehicle_schedule_frame_id
      vehicle_services {
        vehicle_service_id
        journey_patterns_in_vehicle_service {
          journey_pattern_id
          journey_pattern_instance {
            journey_pattern_id
            journey_pattern_route {
              route_id
              unique_label
              direction
              variant
              name_i18n
              route_line {
                line_id
              }
            }
          }
        }
      }
    }
  }
}
    `;

/**
 * __useGetVehicleScheduleFrameWithRouteAndLineInfoQuery__
 *
 * To run a query within a React component, call `useGetVehicleScheduleFrameWithRouteAndLineInfoQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetVehicleScheduleFrameWithRouteAndLineInfoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetVehicleScheduleFrameWithRouteAndLineInfoQuery({
 *   variables: {
 *      vehicle_schedule_frame_ids: // value for 'vehicle_schedule_frame_ids'
 *   },
 * });
 */
export function useGetVehicleScheduleFrameWithRouteAndLineInfoQuery(baseOptions: Apollo.QueryHookOptions<GetVehicleScheduleFrameWithRouteAndLineInfoQuery, GetVehicleScheduleFrameWithRouteAndLineInfoQueryVariables> & ({ variables: GetVehicleScheduleFrameWithRouteAndLineInfoQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetVehicleScheduleFrameWithRouteAndLineInfoQuery, GetVehicleScheduleFrameWithRouteAndLineInfoQueryVariables>(GetVehicleScheduleFrameWithRouteAndLineInfoDocument, options);
      }
export function useGetVehicleScheduleFrameWithRouteAndLineInfoLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetVehicleScheduleFrameWithRouteAndLineInfoQuery, GetVehicleScheduleFrameWithRouteAndLineInfoQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetVehicleScheduleFrameWithRouteAndLineInfoQuery, GetVehicleScheduleFrameWithRouteAndLineInfoQueryVariables>(GetVehicleScheduleFrameWithRouteAndLineInfoDocument, options);
        }
export function useGetVehicleScheduleFrameWithRouteAndLineInfoSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetVehicleScheduleFrameWithRouteAndLineInfoQuery, GetVehicleScheduleFrameWithRouteAndLineInfoQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetVehicleScheduleFrameWithRouteAndLineInfoQuery, GetVehicleScheduleFrameWithRouteAndLineInfoQueryVariables>(GetVehicleScheduleFrameWithRouteAndLineInfoDocument, options);
        }
export type GetVehicleScheduleFrameWithRouteAndLineInfoQueryHookResult = ReturnType<typeof useGetVehicleScheduleFrameWithRouteAndLineInfoQuery>;
export type GetVehicleScheduleFrameWithRouteAndLineInfoLazyQueryHookResult = ReturnType<typeof useGetVehicleScheduleFrameWithRouteAndLineInfoLazyQuery>;
export type GetVehicleScheduleFrameWithRouteAndLineInfoSuspenseQueryHookResult = ReturnType<typeof useGetVehicleScheduleFrameWithRouteAndLineInfoSuspenseQuery>;
export type GetVehicleScheduleFrameWithRouteAndLineInfoQueryResult = Apollo.QueryResult<GetVehicleScheduleFrameWithRouteAndLineInfoQuery, GetVehicleScheduleFrameWithRouteAndLineInfoQueryVariables>;
export const GetStagingVehicleScheduleFramesDocument = gql`
    query GetStagingVehicleScheduleFrames {
  timetables {
    timetables_vehicle_schedule_vehicle_schedule_frame(where: {priority: {_eq: 40}}) {
      ...vehicle_schedule_frame_with_route_info
    }
  }
}
    ${VehicleScheduleFrameWithRouteInfoFragmentDoc}`;

/**
 * __useGetStagingVehicleScheduleFramesQuery__
 *
 * To run a query within a React component, call `useGetStagingVehicleScheduleFramesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStagingVehicleScheduleFramesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStagingVehicleScheduleFramesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetStagingVehicleScheduleFramesQuery(baseOptions?: Apollo.QueryHookOptions<GetStagingVehicleScheduleFramesQuery, GetStagingVehicleScheduleFramesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStagingVehicleScheduleFramesQuery, GetStagingVehicleScheduleFramesQueryVariables>(GetStagingVehicleScheduleFramesDocument, options);
      }
export function useGetStagingVehicleScheduleFramesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStagingVehicleScheduleFramesQuery, GetStagingVehicleScheduleFramesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStagingVehicleScheduleFramesQuery, GetStagingVehicleScheduleFramesQueryVariables>(GetStagingVehicleScheduleFramesDocument, options);
        }
export function useGetStagingVehicleScheduleFramesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetStagingVehicleScheduleFramesQuery, GetStagingVehicleScheduleFramesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetStagingVehicleScheduleFramesQuery, GetStagingVehicleScheduleFramesQueryVariables>(GetStagingVehicleScheduleFramesDocument, options);
        }
export type GetStagingVehicleScheduleFramesQueryHookResult = ReturnType<typeof useGetStagingVehicleScheduleFramesQuery>;
export type GetStagingVehicleScheduleFramesLazyQueryHookResult = ReturnType<typeof useGetStagingVehicleScheduleFramesLazyQuery>;
export type GetStagingVehicleScheduleFramesSuspenseQueryHookResult = ReturnType<typeof useGetStagingVehicleScheduleFramesSuspenseQuery>;
export type GetStagingVehicleScheduleFramesQueryResult = Apollo.QueryResult<GetStagingVehicleScheduleFramesQuery, GetStagingVehicleScheduleFramesQueryVariables>;
export const ChangeStagingVehicleScheduleFramePriorityDocument = gql`
    mutation ChangeStagingVehicleScheduleFramePriority($newPriority: Int!) {
  timetables {
    timetables_update_vehicle_schedule_vehicle_schedule_frame(
      where: {priority: {_eq: 40}}
      _set: {priority: $newPriority}
    ) {
      returning {
        priority
        validity_end
        validity_start
        name_i18n
        vehicle_schedule_frame_id
      }
    }
  }
}
    `;
export type ChangeStagingVehicleScheduleFramePriorityMutationFn = Apollo.MutationFunction<ChangeStagingVehicleScheduleFramePriorityMutation, ChangeStagingVehicleScheduleFramePriorityMutationVariables>;

/**
 * __useChangeStagingVehicleScheduleFramePriorityMutation__
 *
 * To run a mutation, you first call `useChangeStagingVehicleScheduleFramePriorityMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChangeStagingVehicleScheduleFramePriorityMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [changeStagingVehicleScheduleFramePriorityMutation, { data, loading, error }] = useChangeStagingVehicleScheduleFramePriorityMutation({
 *   variables: {
 *      newPriority: // value for 'newPriority'
 *   },
 * });
 */
export function useChangeStagingVehicleScheduleFramePriorityMutation(baseOptions?: Apollo.MutationHookOptions<ChangeStagingVehicleScheduleFramePriorityMutation, ChangeStagingVehicleScheduleFramePriorityMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChangeStagingVehicleScheduleFramePriorityMutation, ChangeStagingVehicleScheduleFramePriorityMutationVariables>(ChangeStagingVehicleScheduleFramePriorityDocument, options);
      }
export type ChangeStagingVehicleScheduleFramePriorityMutationHookResult = ReturnType<typeof useChangeStagingVehicleScheduleFramePriorityMutation>;
export type ChangeStagingVehicleScheduleFramePriorityMutationResult = Apollo.MutationResult<ChangeStagingVehicleScheduleFramePriorityMutation>;
export type ChangeStagingVehicleScheduleFramePriorityMutationOptions = Apollo.BaseMutationOptions<ChangeStagingVehicleScheduleFramePriorityMutation, ChangeStagingVehicleScheduleFramePriorityMutationVariables>;
export const CombineTimetablesDocument = gql`
    mutation CombineTimetables($stagingVehicleScheduleFrameIds: [uuid]!, $targetPriority: Int!) {
  combineTimetables(
    arg1: {stagingVehicleScheduleFrameIds: $stagingVehicleScheduleFrameIds, targetPriority: $targetPriority}
  ) {
    combinedIntoVehicleScheduleFrameIds
  }
}
    `;
export type CombineTimetablesMutationFn = Apollo.MutationFunction<CombineTimetablesMutation, CombineTimetablesMutationVariables>;

/**
 * __useCombineTimetablesMutation__
 *
 * To run a mutation, you first call `useCombineTimetablesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCombineTimetablesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [combineTimetablesMutation, { data, loading, error }] = useCombineTimetablesMutation({
 *   variables: {
 *      stagingVehicleScheduleFrameIds: // value for 'stagingVehicleScheduleFrameIds'
 *      targetPriority: // value for 'targetPriority'
 *   },
 * });
 */
export function useCombineTimetablesMutation(baseOptions?: Apollo.MutationHookOptions<CombineTimetablesMutation, CombineTimetablesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CombineTimetablesMutation, CombineTimetablesMutationVariables>(CombineTimetablesDocument, options);
      }
export type CombineTimetablesMutationHookResult = ReturnType<typeof useCombineTimetablesMutation>;
export type CombineTimetablesMutationResult = Apollo.MutationResult<CombineTimetablesMutation>;
export type CombineTimetablesMutationOptions = Apollo.BaseMutationOptions<CombineTimetablesMutation, CombineTimetablesMutationVariables>;
export const ReplaceTimetablesDocument = gql`
    mutation ReplaceTimetables($stagingVehicleScheduleFrameIds: [uuid]!, $targetPriority: Int!) {
  replaceTimetables(
    arg1: {stagingVehicleScheduleFrameIds: $stagingVehicleScheduleFrameIds, targetPriority: $targetPriority}
  ) {
    replacedVehicleScheduleFrameIds
  }
}
    `;
export type ReplaceTimetablesMutationFn = Apollo.MutationFunction<ReplaceTimetablesMutation, ReplaceTimetablesMutationVariables>;

/**
 * __useReplaceTimetablesMutation__
 *
 * To run a mutation, you first call `useReplaceTimetablesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useReplaceTimetablesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [replaceTimetablesMutation, { data, loading, error }] = useReplaceTimetablesMutation({
 *   variables: {
 *      stagingVehicleScheduleFrameIds: // value for 'stagingVehicleScheduleFrameIds'
 *      targetPriority: // value for 'targetPriority'
 *   },
 * });
 */
export function useReplaceTimetablesMutation(baseOptions?: Apollo.MutationHookOptions<ReplaceTimetablesMutation, ReplaceTimetablesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ReplaceTimetablesMutation, ReplaceTimetablesMutationVariables>(ReplaceTimetablesDocument, options);
      }
export type ReplaceTimetablesMutationHookResult = ReturnType<typeof useReplaceTimetablesMutation>;
export type ReplaceTimetablesMutationResult = Apollo.MutationResult<ReplaceTimetablesMutation>;
export type ReplaceTimetablesMutationOptions = Apollo.BaseMutationOptions<ReplaceTimetablesMutation, ReplaceTimetablesMutationVariables>;
export const DeleteStagingTimetablesDocument = gql`
    mutation DeleteStagingTimetables($stagingVehicleScheduleFrameIds: [uuid!]) {
  timetables {
    timetables_delete_vehicle_schedule_vehicle_schedule_frame(
      where: {_and: {priority: {_eq: 40}, vehicle_schedule_frame_id: {_in: $stagingVehicleScheduleFrameIds}}}
    ) {
      returning {
        vehicle_schedule_frame_id
      }
    }
  }
}
    `;
export type DeleteStagingTimetablesMutationFn = Apollo.MutationFunction<DeleteStagingTimetablesMutation, DeleteStagingTimetablesMutationVariables>;

/**
 * __useDeleteStagingTimetablesMutation__
 *
 * To run a mutation, you first call `useDeleteStagingTimetablesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteStagingTimetablesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteStagingTimetablesMutation, { data, loading, error }] = useDeleteStagingTimetablesMutation({
 *   variables: {
 *      stagingVehicleScheduleFrameIds: // value for 'stagingVehicleScheduleFrameIds'
 *   },
 * });
 */
export function useDeleteStagingTimetablesMutation(baseOptions?: Apollo.MutationHookOptions<DeleteStagingTimetablesMutation, DeleteStagingTimetablesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteStagingTimetablesMutation, DeleteStagingTimetablesMutationVariables>(DeleteStagingTimetablesDocument, options);
      }
export type DeleteStagingTimetablesMutationHookResult = ReturnType<typeof useDeleteStagingTimetablesMutation>;
export type DeleteStagingTimetablesMutationResult = Apollo.MutationResult<DeleteStagingTimetablesMutation>;
export type DeleteStagingTimetablesMutationOptions = Apollo.BaseMutationOptions<DeleteStagingTimetablesMutation, DeleteStagingTimetablesMutationVariables>;
export const InsertTimingPlaceDocument = gql`
    mutation InsertTimingPlace($object: timing_pattern_timing_place_insert_input!) {
  insert_timing_pattern_timing_place_one(object: $object) {
    ...created_timing_place
  }
}
    ${CreatedTimingPlaceFragmentDoc}`;
export type InsertTimingPlaceMutationFn = Apollo.MutationFunction<InsertTimingPlaceMutation, InsertTimingPlaceMutationVariables>;

/**
 * __useInsertTimingPlaceMutation__
 *
 * To run a mutation, you first call `useInsertTimingPlaceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertTimingPlaceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertTimingPlaceMutation, { data, loading, error }] = useInsertTimingPlaceMutation({
 *   variables: {
 *      object: // value for 'object'
 *   },
 * });
 */
export function useInsertTimingPlaceMutation(baseOptions?: Apollo.MutationHookOptions<InsertTimingPlaceMutation, InsertTimingPlaceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertTimingPlaceMutation, InsertTimingPlaceMutationVariables>(InsertTimingPlaceDocument, options);
      }
export type InsertTimingPlaceMutationHookResult = ReturnType<typeof useInsertTimingPlaceMutation>;
export type InsertTimingPlaceMutationResult = Apollo.MutationResult<InsertTimingPlaceMutation>;
export type InsertTimingPlaceMutationOptions = Apollo.BaseMutationOptions<InsertTimingPlaceMutation, InsertTimingPlaceMutationVariables>;
export const GetTimingPlacesByLabelDocument = gql`
    query GetTimingPlacesByLabel($label: String!) {
  timing_pattern_timing_place(where: {label: {_eq: $label}}) {
    ...created_timing_place
  }
}
    ${CreatedTimingPlaceFragmentDoc}`;

/**
 * __useGetTimingPlacesByLabelQuery__
 *
 * To run a query within a React component, call `useGetTimingPlacesByLabelQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTimingPlacesByLabelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTimingPlacesByLabelQuery({
 *   variables: {
 *      label: // value for 'label'
 *   },
 * });
 */
export function useGetTimingPlacesByLabelQuery(baseOptions: Apollo.QueryHookOptions<GetTimingPlacesByLabelQuery, GetTimingPlacesByLabelQueryVariables> & ({ variables: GetTimingPlacesByLabelQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTimingPlacesByLabelQuery, GetTimingPlacesByLabelQueryVariables>(GetTimingPlacesByLabelDocument, options);
      }
export function useGetTimingPlacesByLabelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTimingPlacesByLabelQuery, GetTimingPlacesByLabelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTimingPlacesByLabelQuery, GetTimingPlacesByLabelQueryVariables>(GetTimingPlacesByLabelDocument, options);
        }
export function useGetTimingPlacesByLabelSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetTimingPlacesByLabelQuery, GetTimingPlacesByLabelQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTimingPlacesByLabelQuery, GetTimingPlacesByLabelQueryVariables>(GetTimingPlacesByLabelDocument, options);
        }
export type GetTimingPlacesByLabelQueryHookResult = ReturnType<typeof useGetTimingPlacesByLabelQuery>;
export type GetTimingPlacesByLabelLazyQueryHookResult = ReturnType<typeof useGetTimingPlacesByLabelLazyQuery>;
export type GetTimingPlacesByLabelSuspenseQueryHookResult = ReturnType<typeof useGetTimingPlacesByLabelSuspenseQuery>;
export type GetTimingPlacesByLabelQueryResult = Apollo.QueryResult<GetTimingPlacesByLabelQuery, GetTimingPlacesByLabelQueryVariables>;
export const GetLinesForComboboxDocument = gql`
    query GetLinesForCombobox($labelPattern: String!, $date: date!) {
  route_line(
    limit: 10
    where: {label: {_ilike: $labelPattern}, _or: [{validity_end: {_gte: $date}}, {validity_end: {_is_null: true}}]}
    order_by: [{label: asc}, {validity_start: asc}]
  ) {
    ...line_for_combobox
  }
}
    ${LineForComboboxFragmentDoc}`;

/**
 * __useGetLinesForComboboxQuery__
 *
 * To run a query within a React component, call `useGetLinesForComboboxQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLinesForComboboxQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLinesForComboboxQuery({
 *   variables: {
 *      labelPattern: // value for 'labelPattern'
 *      date: // value for 'date'
 *   },
 * });
 */
export function useGetLinesForComboboxQuery(baseOptions: Apollo.QueryHookOptions<GetLinesForComboboxQuery, GetLinesForComboboxQueryVariables> & ({ variables: GetLinesForComboboxQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetLinesForComboboxQuery, GetLinesForComboboxQueryVariables>(GetLinesForComboboxDocument, options);
      }
export function useGetLinesForComboboxLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetLinesForComboboxQuery, GetLinesForComboboxQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetLinesForComboboxQuery, GetLinesForComboboxQueryVariables>(GetLinesForComboboxDocument, options);
        }
export function useGetLinesForComboboxSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetLinesForComboboxQuery, GetLinesForComboboxQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetLinesForComboboxQuery, GetLinesForComboboxQueryVariables>(GetLinesForComboboxDocument, options);
        }
export type GetLinesForComboboxQueryHookResult = ReturnType<typeof useGetLinesForComboboxQuery>;
export type GetLinesForComboboxLazyQueryHookResult = ReturnType<typeof useGetLinesForComboboxLazyQuery>;
export type GetLinesForComboboxSuspenseQueryHookResult = ReturnType<typeof useGetLinesForComboboxSuspenseQuery>;
export type GetLinesForComboboxQueryResult = Apollo.QueryResult<GetLinesForComboboxQuery, GetLinesForComboboxQueryVariables>;
export const GetSelectedLineDetailsByIdDocument = gql`
    query GetSelectedLineDetailsById($line_id: uuid!) {
  route_line_by_pk(line_id: $line_id) {
    ...line_for_combobox
  }
}
    ${LineForComboboxFragmentDoc}`;

/**
 * __useGetSelectedLineDetailsByIdQuery__
 *
 * To run a query within a React component, call `useGetSelectedLineDetailsByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSelectedLineDetailsByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSelectedLineDetailsByIdQuery({
 *   variables: {
 *      line_id: // value for 'line_id'
 *   },
 * });
 */
export function useGetSelectedLineDetailsByIdQuery(baseOptions: Apollo.QueryHookOptions<GetSelectedLineDetailsByIdQuery, GetSelectedLineDetailsByIdQueryVariables> & ({ variables: GetSelectedLineDetailsByIdQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSelectedLineDetailsByIdQuery, GetSelectedLineDetailsByIdQueryVariables>(GetSelectedLineDetailsByIdDocument, options);
      }
export function useGetSelectedLineDetailsByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSelectedLineDetailsByIdQuery, GetSelectedLineDetailsByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSelectedLineDetailsByIdQuery, GetSelectedLineDetailsByIdQueryVariables>(GetSelectedLineDetailsByIdDocument, options);
        }
export function useGetSelectedLineDetailsByIdSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSelectedLineDetailsByIdQuery, GetSelectedLineDetailsByIdQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSelectedLineDetailsByIdQuery, GetSelectedLineDetailsByIdQueryVariables>(GetSelectedLineDetailsByIdDocument, options);
        }
export type GetSelectedLineDetailsByIdQueryHookResult = ReturnType<typeof useGetSelectedLineDetailsByIdQuery>;
export type GetSelectedLineDetailsByIdLazyQueryHookResult = ReturnType<typeof useGetSelectedLineDetailsByIdLazyQuery>;
export type GetSelectedLineDetailsByIdSuspenseQueryHookResult = ReturnType<typeof useGetSelectedLineDetailsByIdSuspenseQuery>;
export type GetSelectedLineDetailsByIdQueryResult = Apollo.QueryResult<GetSelectedLineDetailsByIdQuery, GetSelectedLineDetailsByIdQueryVariables>;
export const GetRouteDetailsByLabelWildcardDocument = gql`
    query GetRouteDetailsByLabelWildcard($labelPattern: String!, $date: date, $priorities: [Int!]) {
  route_route(
    limit: 7
    where: {label: {_ilike: $labelPattern}, validity_start: {_lte: $date}, _or: [{validity_end: {_gte: $date}}, {validity_end: {_is_null: true}}], priority: {_in: $priorities}}
    order_by: {label: asc}
  ) {
    ...route_all_fields
  }
}
    ${RouteAllFieldsFragmentDoc}`;

/**
 * __useGetRouteDetailsByLabelWildcardQuery__
 *
 * To run a query within a React component, call `useGetRouteDetailsByLabelWildcardQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRouteDetailsByLabelWildcardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRouteDetailsByLabelWildcardQuery({
 *   variables: {
 *      labelPattern: // value for 'labelPattern'
 *      date: // value for 'date'
 *      priorities: // value for 'priorities'
 *   },
 * });
 */
export function useGetRouteDetailsByLabelWildcardQuery(baseOptions: Apollo.QueryHookOptions<GetRouteDetailsByLabelWildcardQuery, GetRouteDetailsByLabelWildcardQueryVariables> & ({ variables: GetRouteDetailsByLabelWildcardQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRouteDetailsByLabelWildcardQuery, GetRouteDetailsByLabelWildcardQueryVariables>(GetRouteDetailsByLabelWildcardDocument, options);
      }
export function useGetRouteDetailsByLabelWildcardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRouteDetailsByLabelWildcardQuery, GetRouteDetailsByLabelWildcardQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRouteDetailsByLabelWildcardQuery, GetRouteDetailsByLabelWildcardQueryVariables>(GetRouteDetailsByLabelWildcardDocument, options);
        }
export function useGetRouteDetailsByLabelWildcardSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetRouteDetailsByLabelWildcardQuery, GetRouteDetailsByLabelWildcardQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetRouteDetailsByLabelWildcardQuery, GetRouteDetailsByLabelWildcardQueryVariables>(GetRouteDetailsByLabelWildcardDocument, options);
        }
export type GetRouteDetailsByLabelWildcardQueryHookResult = ReturnType<typeof useGetRouteDetailsByLabelWildcardQuery>;
export type GetRouteDetailsByLabelWildcardLazyQueryHookResult = ReturnType<typeof useGetRouteDetailsByLabelWildcardLazyQuery>;
export type GetRouteDetailsByLabelWildcardSuspenseQueryHookResult = ReturnType<typeof useGetRouteDetailsByLabelWildcardSuspenseQuery>;
export type GetRouteDetailsByLabelWildcardQueryResult = Apollo.QueryResult<GetRouteDetailsByLabelWildcardQuery, GetRouteDetailsByLabelWildcardQueryVariables>;
export const GetSelectedRouteDetailsByIdDocument = gql`
    query GetSelectedRouteDetailsById($routeId: uuid!) {
  route_route_by_pk(route_id: $routeId) {
    ...route_all_fields
  }
}
    ${RouteAllFieldsFragmentDoc}`;

/**
 * __useGetSelectedRouteDetailsByIdQuery__
 *
 * To run a query within a React component, call `useGetSelectedRouteDetailsByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSelectedRouteDetailsByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSelectedRouteDetailsByIdQuery({
 *   variables: {
 *      routeId: // value for 'routeId'
 *   },
 * });
 */
export function useGetSelectedRouteDetailsByIdQuery(baseOptions: Apollo.QueryHookOptions<GetSelectedRouteDetailsByIdQuery, GetSelectedRouteDetailsByIdQueryVariables> & ({ variables: GetSelectedRouteDetailsByIdQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSelectedRouteDetailsByIdQuery, GetSelectedRouteDetailsByIdQueryVariables>(GetSelectedRouteDetailsByIdDocument, options);
      }
export function useGetSelectedRouteDetailsByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSelectedRouteDetailsByIdQuery, GetSelectedRouteDetailsByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSelectedRouteDetailsByIdQuery, GetSelectedRouteDetailsByIdQueryVariables>(GetSelectedRouteDetailsByIdDocument, options);
        }
export function useGetSelectedRouteDetailsByIdSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSelectedRouteDetailsByIdQuery, GetSelectedRouteDetailsByIdQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSelectedRouteDetailsByIdQuery, GetSelectedRouteDetailsByIdQueryVariables>(GetSelectedRouteDetailsByIdDocument, options);
        }
export type GetSelectedRouteDetailsByIdQueryHookResult = ReturnType<typeof useGetSelectedRouteDetailsByIdQuery>;
export type GetSelectedRouteDetailsByIdLazyQueryHookResult = ReturnType<typeof useGetSelectedRouteDetailsByIdLazyQuery>;
export type GetSelectedRouteDetailsByIdSuspenseQueryHookResult = ReturnType<typeof useGetSelectedRouteDetailsByIdSuspenseQuery>;
export type GetSelectedRouteDetailsByIdQueryResult = Apollo.QueryResult<GetSelectedRouteDetailsByIdQuery, GetSelectedRouteDetailsByIdQueryVariables>;
export const GetTimingPlacesForComboboxDocument = gql`
    query GetTimingPlacesForCombobox($labelPattern: String!) {
  timing_pattern_timing_place(
    limit: 10
    where: {label: {_ilike: $labelPattern}}
    order_by: [{label: asc}]
  ) {
    ...timing_place_for_combobox
  }
}
    ${TimingPlaceForComboboxFragmentDoc}`;

/**
 * __useGetTimingPlacesForComboboxQuery__
 *
 * To run a query within a React component, call `useGetTimingPlacesForComboboxQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTimingPlacesForComboboxQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTimingPlacesForComboboxQuery({
 *   variables: {
 *      labelPattern: // value for 'labelPattern'
 *   },
 * });
 */
export function useGetTimingPlacesForComboboxQuery(baseOptions: Apollo.QueryHookOptions<GetTimingPlacesForComboboxQuery, GetTimingPlacesForComboboxQueryVariables> & ({ variables: GetTimingPlacesForComboboxQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTimingPlacesForComboboxQuery, GetTimingPlacesForComboboxQueryVariables>(GetTimingPlacesForComboboxDocument, options);
      }
export function useGetTimingPlacesForComboboxLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTimingPlacesForComboboxQuery, GetTimingPlacesForComboboxQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTimingPlacesForComboboxQuery, GetTimingPlacesForComboboxQueryVariables>(GetTimingPlacesForComboboxDocument, options);
        }
export function useGetTimingPlacesForComboboxSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetTimingPlacesForComboboxQuery, GetTimingPlacesForComboboxQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTimingPlacesForComboboxQuery, GetTimingPlacesForComboboxQueryVariables>(GetTimingPlacesForComboboxDocument, options);
        }
export type GetTimingPlacesForComboboxQueryHookResult = ReturnType<typeof useGetTimingPlacesForComboboxQuery>;
export type GetTimingPlacesForComboboxLazyQueryHookResult = ReturnType<typeof useGetTimingPlacesForComboboxLazyQuery>;
export type GetTimingPlacesForComboboxSuspenseQueryHookResult = ReturnType<typeof useGetTimingPlacesForComboboxSuspenseQuery>;
export type GetTimingPlacesForComboboxQueryResult = Apollo.QueryResult<GetTimingPlacesForComboboxQuery, GetTimingPlacesForComboboxQueryVariables>;
export const GetSelectedTimingPlaceDetailsByIdDocument = gql`
    query GetSelectedTimingPlaceDetailsById($timing_place_id: uuid!) {
  timing_pattern_timing_place_by_pk(timing_place_id: $timing_place_id) {
    ...timing_place_for_combobox
  }
}
    ${TimingPlaceForComboboxFragmentDoc}`;

/**
 * __useGetSelectedTimingPlaceDetailsByIdQuery__
 *
 * To run a query within a React component, call `useGetSelectedTimingPlaceDetailsByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSelectedTimingPlaceDetailsByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSelectedTimingPlaceDetailsByIdQuery({
 *   variables: {
 *      timing_place_id: // value for 'timing_place_id'
 *   },
 * });
 */
export function useGetSelectedTimingPlaceDetailsByIdQuery(baseOptions: Apollo.QueryHookOptions<GetSelectedTimingPlaceDetailsByIdQuery, GetSelectedTimingPlaceDetailsByIdQueryVariables> & ({ variables: GetSelectedTimingPlaceDetailsByIdQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSelectedTimingPlaceDetailsByIdQuery, GetSelectedTimingPlaceDetailsByIdQueryVariables>(GetSelectedTimingPlaceDetailsByIdDocument, options);
      }
export function useGetSelectedTimingPlaceDetailsByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSelectedTimingPlaceDetailsByIdQuery, GetSelectedTimingPlaceDetailsByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSelectedTimingPlaceDetailsByIdQuery, GetSelectedTimingPlaceDetailsByIdQueryVariables>(GetSelectedTimingPlaceDetailsByIdDocument, options);
        }
export function useGetSelectedTimingPlaceDetailsByIdSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetSelectedTimingPlaceDetailsByIdQuery, GetSelectedTimingPlaceDetailsByIdQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSelectedTimingPlaceDetailsByIdQuery, GetSelectedTimingPlaceDetailsByIdQueryVariables>(GetSelectedTimingPlaceDetailsByIdDocument, options);
        }
export type GetSelectedTimingPlaceDetailsByIdQueryHookResult = ReturnType<typeof useGetSelectedTimingPlaceDetailsByIdQuery>;
export type GetSelectedTimingPlaceDetailsByIdLazyQueryHookResult = ReturnType<typeof useGetSelectedTimingPlaceDetailsByIdLazyQuery>;
export type GetSelectedTimingPlaceDetailsByIdSuspenseQueryHookResult = ReturnType<typeof useGetSelectedTimingPlaceDetailsByIdSuspenseQuery>;
export type GetSelectedTimingPlaceDetailsByIdQueryResult = Apollo.QueryResult<GetSelectedTimingPlaceDetailsByIdQuery, GetSelectedTimingPlaceDetailsByIdQueryVariables>;
export const GetRouteInfoForTimetableVersionsDocument = gql`
    query GetRouteInfoForTimetableVersions($routeFilters: route_route_bool_exp) {
  route_route(where: $routeFilters) {
    ...route_info_for_timetable_version
  }
}
    ${RouteInfoForTimetableVersionFragmentDoc}`;

/**
 * __useGetRouteInfoForTimetableVersionsQuery__
 *
 * To run a query within a React component, call `useGetRouteInfoForTimetableVersionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRouteInfoForTimetableVersionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRouteInfoForTimetableVersionsQuery({
 *   variables: {
 *      routeFilters: // value for 'routeFilters'
 *   },
 * });
 */
export function useGetRouteInfoForTimetableVersionsQuery(baseOptions?: Apollo.QueryHookOptions<GetRouteInfoForTimetableVersionsQuery, GetRouteInfoForTimetableVersionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRouteInfoForTimetableVersionsQuery, GetRouteInfoForTimetableVersionsQueryVariables>(GetRouteInfoForTimetableVersionsDocument, options);
      }
export function useGetRouteInfoForTimetableVersionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRouteInfoForTimetableVersionsQuery, GetRouteInfoForTimetableVersionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRouteInfoForTimetableVersionsQuery, GetRouteInfoForTimetableVersionsQueryVariables>(GetRouteInfoForTimetableVersionsDocument, options);
        }
export function useGetRouteInfoForTimetableVersionsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetRouteInfoForTimetableVersionsQuery, GetRouteInfoForTimetableVersionsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetRouteInfoForTimetableVersionsQuery, GetRouteInfoForTimetableVersionsQueryVariables>(GetRouteInfoForTimetableVersionsDocument, options);
        }
export type GetRouteInfoForTimetableVersionsQueryHookResult = ReturnType<typeof useGetRouteInfoForTimetableVersionsQuery>;
export type GetRouteInfoForTimetableVersionsLazyQueryHookResult = ReturnType<typeof useGetRouteInfoForTimetableVersionsLazyQuery>;
export type GetRouteInfoForTimetableVersionsSuspenseQueryHookResult = ReturnType<typeof useGetRouteInfoForTimetableVersionsSuspenseQuery>;
export type GetRouteInfoForTimetableVersionsQueryResult = Apollo.QueryResult<GetRouteInfoForTimetableVersionsQuery, GetRouteInfoForTimetableVersionsQueryVariables>;
export const GetTimetableVersionsByJourneyPatternIdsDocument = gql`
    query GetTimetableVersionsByJourneyPatternIds($journey_pattern_ids: _uuid, $start_date: date, $end_date: date, $observation_date: date) {
  timetables {
    timetables_vehicle_service_get_timetable_versions_by_journey_pattern_ids(
      args: {journey_pattern_ids: $journey_pattern_ids, start_date: $start_date, end_date: $end_date, observation_date: $observation_date}
    ) {
      ...timetable_version
    }
  }
}
    ${TimetableVersionFragmentDoc}`;

/**
 * __useGetTimetableVersionsByJourneyPatternIdsQuery__
 *
 * To run a query within a React component, call `useGetTimetableVersionsByJourneyPatternIdsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTimetableVersionsByJourneyPatternIdsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTimetableVersionsByJourneyPatternIdsQuery({
 *   variables: {
 *      journey_pattern_ids: // value for 'journey_pattern_ids'
 *      start_date: // value for 'start_date'
 *      end_date: // value for 'end_date'
 *      observation_date: // value for 'observation_date'
 *   },
 * });
 */
export function useGetTimetableVersionsByJourneyPatternIdsQuery(baseOptions?: Apollo.QueryHookOptions<GetTimetableVersionsByJourneyPatternIdsQuery, GetTimetableVersionsByJourneyPatternIdsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTimetableVersionsByJourneyPatternIdsQuery, GetTimetableVersionsByJourneyPatternIdsQueryVariables>(GetTimetableVersionsByJourneyPatternIdsDocument, options);
      }
export function useGetTimetableVersionsByJourneyPatternIdsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTimetableVersionsByJourneyPatternIdsQuery, GetTimetableVersionsByJourneyPatternIdsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTimetableVersionsByJourneyPatternIdsQuery, GetTimetableVersionsByJourneyPatternIdsQueryVariables>(GetTimetableVersionsByJourneyPatternIdsDocument, options);
        }
export function useGetTimetableVersionsByJourneyPatternIdsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetTimetableVersionsByJourneyPatternIdsQuery, GetTimetableVersionsByJourneyPatternIdsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTimetableVersionsByJourneyPatternIdsQuery, GetTimetableVersionsByJourneyPatternIdsQueryVariables>(GetTimetableVersionsByJourneyPatternIdsDocument, options);
        }
export type GetTimetableVersionsByJourneyPatternIdsQueryHookResult = ReturnType<typeof useGetTimetableVersionsByJourneyPatternIdsQuery>;
export type GetTimetableVersionsByJourneyPatternIdsLazyQueryHookResult = ReturnType<typeof useGetTimetableVersionsByJourneyPatternIdsLazyQuery>;
export type GetTimetableVersionsByJourneyPatternIdsSuspenseQueryHookResult = ReturnType<typeof useGetTimetableVersionsByJourneyPatternIdsSuspenseQuery>;
export type GetTimetableVersionsByJourneyPatternIdsQueryResult = Apollo.QueryResult<GetTimetableVersionsByJourneyPatternIdsQuery, GetTimetableVersionsByJourneyPatternIdsQueryVariables>;
export const DeleteVehicleScheduleFrameDocument = gql`
    mutation DeleteVehicleScheduleFrame($vehicle_schedule_frame_id: uuid!) {
  timetables {
    timetables_delete_vehicle_schedule_vehicle_schedule_frame_by_pk(
      vehicle_schedule_frame_id: $vehicle_schedule_frame_id
    ) {
      vehicle_schedule_frame_id
    }
  }
}
    `;
export type DeleteVehicleScheduleFrameMutationFn = Apollo.MutationFunction<DeleteVehicleScheduleFrameMutation, DeleteVehicleScheduleFrameMutationVariables>;

/**
 * __useDeleteVehicleScheduleFrameMutation__
 *
 * To run a mutation, you first call `useDeleteVehicleScheduleFrameMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteVehicleScheduleFrameMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteVehicleScheduleFrameMutation, { data, loading, error }] = useDeleteVehicleScheduleFrameMutation({
 *   variables: {
 *      vehicle_schedule_frame_id: // value for 'vehicle_schedule_frame_id'
 *   },
 * });
 */
export function useDeleteVehicleScheduleFrameMutation(baseOptions?: Apollo.MutationHookOptions<DeleteVehicleScheduleFrameMutation, DeleteVehicleScheduleFrameMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteVehicleScheduleFrameMutation, DeleteVehicleScheduleFrameMutationVariables>(DeleteVehicleScheduleFrameDocument, options);
      }
export type DeleteVehicleScheduleFrameMutationHookResult = ReturnType<typeof useDeleteVehicleScheduleFrameMutation>;
export type DeleteVehicleScheduleFrameMutationResult = Apollo.MutationResult<DeleteVehicleScheduleFrameMutation>;
export type DeleteVehicleScheduleFrameMutationOptions = Apollo.BaseMutationOptions<DeleteVehicleScheduleFrameMutation, DeleteVehicleScheduleFrameMutationVariables>;
export const GetVehicleScheduleFrameSchedulesDocument = gql`
    query GetVehicleScheduleFrameSchedules($vehicle_schedule_frame_id: uuid!) {
  timetables {
    timetables_vehicle_schedule_vehicle_schedule_frame_by_pk(
      vehicle_schedule_frame_id: $vehicle_schedule_frame_id
    ) {
      vehicle_schedule_frame_id
      validity_start
      validity_end
      priority
      created_at
      vehicle_services {
        vehicle_service_id
        day_type {
          day_type_id
          label
          name_i18n
        }
        blocks {
          block_id
          vehicle_journeys {
            ...vehicle_journey_with_start_time_info
          }
        }
      }
    }
  }
}
    ${VehicleJourneyWithStartTimeInfoFragmentDoc}`;

/**
 * __useGetVehicleScheduleFrameSchedulesQuery__
 *
 * To run a query within a React component, call `useGetVehicleScheduleFrameSchedulesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetVehicleScheduleFrameSchedulesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetVehicleScheduleFrameSchedulesQuery({
 *   variables: {
 *      vehicle_schedule_frame_id: // value for 'vehicle_schedule_frame_id'
 *   },
 * });
 */
export function useGetVehicleScheduleFrameSchedulesQuery(baseOptions: Apollo.QueryHookOptions<GetVehicleScheduleFrameSchedulesQuery, GetVehicleScheduleFrameSchedulesQueryVariables> & ({ variables: GetVehicleScheduleFrameSchedulesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetVehicleScheduleFrameSchedulesQuery, GetVehicleScheduleFrameSchedulesQueryVariables>(GetVehicleScheduleFrameSchedulesDocument, options);
      }
export function useGetVehicleScheduleFrameSchedulesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetVehicleScheduleFrameSchedulesQuery, GetVehicleScheduleFrameSchedulesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetVehicleScheduleFrameSchedulesQuery, GetVehicleScheduleFrameSchedulesQueryVariables>(GetVehicleScheduleFrameSchedulesDocument, options);
        }
export function useGetVehicleScheduleFrameSchedulesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetVehicleScheduleFrameSchedulesQuery, GetVehicleScheduleFrameSchedulesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetVehicleScheduleFrameSchedulesQuery, GetVehicleScheduleFrameSchedulesQueryVariables>(GetVehicleScheduleFrameSchedulesDocument, options);
        }
export type GetVehicleScheduleFrameSchedulesQueryHookResult = ReturnType<typeof useGetVehicleScheduleFrameSchedulesQuery>;
export type GetVehicleScheduleFrameSchedulesLazyQueryHookResult = ReturnType<typeof useGetVehicleScheduleFrameSchedulesLazyQuery>;
export type GetVehicleScheduleFrameSchedulesSuspenseQueryHookResult = ReturnType<typeof useGetVehicleScheduleFrameSchedulesSuspenseQuery>;
export type GetVehicleScheduleFrameSchedulesQueryResult = Apollo.QueryResult<GetVehicleScheduleFrameSchedulesQuery, GetVehicleScheduleFrameSchedulesQueryVariables>;
export const GetVehicleScheduleFrameWithRoutesDocument = gql`
    query GetVehicleScheduleFrameWithRoutes($vehicle_schedule_frame_id: uuid!) {
  timetables {
    timetables_vehicle_schedule_vehicle_schedule_frame(
      where: {vehicle_schedule_frame_id: {_eq: $vehicle_schedule_frame_id}}
    ) {
      ...vehicle_schedule_frame_with_routes
    }
  }
}
    ${VehicleScheduleFrameWithRoutesFragmentDoc}`;

/**
 * __useGetVehicleScheduleFrameWithRoutesQuery__
 *
 * To run a query within a React component, call `useGetVehicleScheduleFrameWithRoutesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetVehicleScheduleFrameWithRoutesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetVehicleScheduleFrameWithRoutesQuery({
 *   variables: {
 *      vehicle_schedule_frame_id: // value for 'vehicle_schedule_frame_id'
 *   },
 * });
 */
export function useGetVehicleScheduleFrameWithRoutesQuery(baseOptions: Apollo.QueryHookOptions<GetVehicleScheduleFrameWithRoutesQuery, GetVehicleScheduleFrameWithRoutesQueryVariables> & ({ variables: GetVehicleScheduleFrameWithRoutesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetVehicleScheduleFrameWithRoutesQuery, GetVehicleScheduleFrameWithRoutesQueryVariables>(GetVehicleScheduleFrameWithRoutesDocument, options);
      }
export function useGetVehicleScheduleFrameWithRoutesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetVehicleScheduleFrameWithRoutesQuery, GetVehicleScheduleFrameWithRoutesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetVehicleScheduleFrameWithRoutesQuery, GetVehicleScheduleFrameWithRoutesQueryVariables>(GetVehicleScheduleFrameWithRoutesDocument, options);
        }
export function useGetVehicleScheduleFrameWithRoutesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetVehicleScheduleFrameWithRoutesQuery, GetVehicleScheduleFrameWithRoutesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetVehicleScheduleFrameWithRoutesQuery, GetVehicleScheduleFrameWithRoutesQueryVariables>(GetVehicleScheduleFrameWithRoutesDocument, options);
        }
export type GetVehicleScheduleFrameWithRoutesQueryHookResult = ReturnType<typeof useGetVehicleScheduleFrameWithRoutesQuery>;
export type GetVehicleScheduleFrameWithRoutesLazyQueryHookResult = ReturnType<typeof useGetVehicleScheduleFrameWithRoutesLazyQuery>;
export type GetVehicleScheduleFrameWithRoutesSuspenseQueryHookResult = ReturnType<typeof useGetVehicleScheduleFrameWithRoutesSuspenseQuery>;
export type GetVehicleScheduleFrameWithRoutesQueryResult = Apollo.QueryResult<GetVehicleScheduleFrameWithRoutesQuery, GetVehicleScheduleFrameWithRoutesQueryVariables>;
export const UpdateVehicleScheduleFrameValidityDocument = gql`
    mutation UpdateVehicleScheduleFrameValidity($vehicle_schedule_frame_id: uuid!, $validity_start: date, $validity_end: date) {
  timetables {
    timetables_update_vehicle_schedule_vehicle_schedule_frame(
      _set: {validity_start: $validity_start, validity_end: $validity_end}
      where: {vehicle_schedule_frame_id: {_eq: $vehicle_schedule_frame_id}}
    ) {
      returning {
        vehicle_schedule_frame_id
        validity_start
        validity_end
      }
    }
  }
}
    `;
export type UpdateVehicleScheduleFrameValidityMutationFn = Apollo.MutationFunction<UpdateVehicleScheduleFrameValidityMutation, UpdateVehicleScheduleFrameValidityMutationVariables>;

/**
 * __useUpdateVehicleScheduleFrameValidityMutation__
 *
 * To run a mutation, you first call `useUpdateVehicleScheduleFrameValidityMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateVehicleScheduleFrameValidityMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateVehicleScheduleFrameValidityMutation, { data, loading, error }] = useUpdateVehicleScheduleFrameValidityMutation({
 *   variables: {
 *      vehicle_schedule_frame_id: // value for 'vehicle_schedule_frame_id'
 *      validity_start: // value for 'validity_start'
 *      validity_end: // value for 'validity_end'
 *   },
 * });
 */
export function useUpdateVehicleScheduleFrameValidityMutation(baseOptions?: Apollo.MutationHookOptions<UpdateVehicleScheduleFrameValidityMutation, UpdateVehicleScheduleFrameValidityMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateVehicleScheduleFrameValidityMutation, UpdateVehicleScheduleFrameValidityMutationVariables>(UpdateVehicleScheduleFrameValidityDocument, options);
      }
export type UpdateVehicleScheduleFrameValidityMutationHookResult = ReturnType<typeof useUpdateVehicleScheduleFrameValidityMutation>;
export type UpdateVehicleScheduleFrameValidityMutationResult = Apollo.MutationResult<UpdateVehicleScheduleFrameValidityMutation>;
export type UpdateVehicleScheduleFrameValidityMutationOptions = Apollo.BaseMutationOptions<UpdateVehicleScheduleFrameValidityMutation, UpdateVehicleScheduleFrameValidityMutationVariables>;
export const GetVehicleSchedulesForDateDocument = gql`
    query GetVehicleSchedulesForDate($journey_pattern_id: uuid!, $observation_date: date!) {
  timetables {
    timetables_vehicle_journey_get_vehicle_schedules_on_date(
      args: {journey_pattern_uuid: $journey_pattern_id, observation_date: $observation_date}
    ) {
      ...vehicle_schedule
    }
    timetables_service_calendar_get_active_day_types_for_date(
      args: {observation_date: $observation_date}
    ) {
      day_type_id
    }
  }
}
    ${VehicleScheduleFragmentDoc}`;

/**
 * __useGetVehicleSchedulesForDateQuery__
 *
 * To run a query within a React component, call `useGetVehicleSchedulesForDateQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetVehicleSchedulesForDateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetVehicleSchedulesForDateQuery({
 *   variables: {
 *      journey_pattern_id: // value for 'journey_pattern_id'
 *      observation_date: // value for 'observation_date'
 *   },
 * });
 */
export function useGetVehicleSchedulesForDateQuery(baseOptions: Apollo.QueryHookOptions<GetVehicleSchedulesForDateQuery, GetVehicleSchedulesForDateQueryVariables> & ({ variables: GetVehicleSchedulesForDateQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetVehicleSchedulesForDateQuery, GetVehicleSchedulesForDateQueryVariables>(GetVehicleSchedulesForDateDocument, options);
      }
export function useGetVehicleSchedulesForDateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetVehicleSchedulesForDateQuery, GetVehicleSchedulesForDateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetVehicleSchedulesForDateQuery, GetVehicleSchedulesForDateQueryVariables>(GetVehicleSchedulesForDateDocument, options);
        }
export function useGetVehicleSchedulesForDateSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetVehicleSchedulesForDateQuery, GetVehicleSchedulesForDateQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetVehicleSchedulesForDateQuery, GetVehicleSchedulesForDateQueryVariables>(GetVehicleSchedulesForDateDocument, options);
        }
export type GetVehicleSchedulesForDateQueryHookResult = ReturnType<typeof useGetVehicleSchedulesForDateQuery>;
export type GetVehicleSchedulesForDateLazyQueryHookResult = ReturnType<typeof useGetVehicleSchedulesForDateLazyQuery>;
export type GetVehicleSchedulesForDateSuspenseQueryHookResult = ReturnType<typeof useGetVehicleSchedulesForDateSuspenseQuery>;
export type GetVehicleSchedulesForDateQueryResult = Apollo.QueryResult<GetVehicleSchedulesForDateQuery, GetVehicleSchedulesForDateQueryVariables>;
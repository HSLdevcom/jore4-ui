services:
  jore4-ui:
    build:
      context: ".."

  jore4-hasura:
    # locking hasura image so that we can develop the UI against a static graphql API
    # Link to available jore4-hasura imags in Docker Hub:
    # https://hub.docker.com/r/hsldevcom/jore4-hasura/tags?page=1&ordering=last_updated
    # The :hsl-tag contains the desired version of hsl specific hasura.
    # Waiting for merging feature-branch to main in hasura-repo
    image: &hasura-image 'hsldevcom/jore4-hasura:hsl-combine-target-api--20231208-f9593cbd1d3331dd86347a863db3aedf8c63e014'
    # Waiting for database to be ready to avoid startup delay due to hasura crashing at startup if db is offline
    # Note: this should only be done in development setups as Kubernetes does not allow waiting for services to be ready
    depends_on:
      jore4-testdb:
        condition: service_healthy

  jore4-mapmatching:
    # pinning map-matching API to compatible version
    image: "hsldevcom/jore4-map-matching:main--20230922-d1608c25525ce4ef250b8a61abaa01a64451538b"

  jore4-hastus:
    # pinning hastus import-export-microservice version
    image: "hsldevcom/jore4-hastus:main--20231208-9de36cd8d12edaf870db6ca7163f8ad6f96872f9"
    environment:
      # use the same Hasura URL that the UI uses to enable routing requests to correct Hasura instances
      # when running e2e tests in parallel
      HASURA_URL: "http://host.docker.internal:3300/api/graphql/v1/graphql"
    extra_hosts:
      - "host.docker.internal:host-gateway"

  jore4-timetablesapi:
    # pinning timetables api
    image: "hsldevcom/jore4-timetables-api:combine-target-api--20231204-6216569ea77f01d428cead179cf620230d247121"

  jore4-hasura-e2e1:
    image: *hasura-image
    depends_on:
      jore4-testdb-e2e1:
        condition: service_healthy

  jore4-hasura-e2e2:
    image: *hasura-image
    depends_on:
      jore4-testdb-e2e2:
        condition: service_healthy

  jore4-hasura-e2e3:
    image: *hasura-image
    depends_on:
      jore4-testdb-e2e3:
        condition: service_healthy
